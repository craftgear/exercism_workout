<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / 数字の並び替え</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>数字の並び替え</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>問題の説明</h3>
<p> 数字の並べ替えは、「おしどりの遊び」のように数字をペアで空いている場所に動かして、数字を順番に並べるパズルです。「おしどりの遊び」は、<a href="kaeru.html">蛙跳びゲーム</a> で簡単に説明しています。
</p>

<pre class="fig">
 ┌─┬─┬─┬─┬─┬─┐
 │４│３│２│１│  │  │スタート 
 └─┴─┴─┴─┴─┴─┘
 ┌─┬─┬─┬─┬─┬─┐
 │１│２│３│４│  │  │ゴール
 └─┴─┴─┴─┴─┴─┘

    図：数字の並べ替え
</pre>

<p> 注意事項として、数字を動かすときはペアの順番を変えてはいけません。たとえば、上図の先頭にある 4, 3 を動かすときに、3, 4 というように数字を逆にすることは許されません。それでは問題です。
</p>
<div class="question">
<b>[問題]</b><br>
次に示す数列を並べ替えることはできるでしょうか。できる場合は、最短手順を示してください。
<OL>
  <li> [４ ３ ２ １ ・ ・]     --&gt; [１ ２ ３ ４ ・ ・] 
  <li> [５ ４ ３ ２ １ ・ ・]   --&gt; [１ ２ ３ ４ ５ ・ ・]
  <li> [６ ５ ４ ３ ２ １ ・ ・] --&gt; [１ ２ ３ ４ ５ ６ ・ ・]
</OL>
[注意] ・は空いている場所を表します。
</div>
<h4 id="update">●解答</h4>
<p> それでは、解答を発表します。1. は 4 手、2. は 7 手で並べ替えることができますが、3. の並べ替えは不可能です。正解手順の一例を示します。
</p>

<pre>
----- 4 種類の探索 ----- 
4 3 2 1 0 0
4 0 0 1 3 2
4 1 3 0 0 2
0 0 3 4 1 2
1 2 3 4 0 0

----- 5 種類の探索 ----- 
5 4 3 2 1 0 0
5 0 0 2 1 4 3
5 2 1 0 0 4 3
0 0 1 5 2 4 3
1 5 0 0 2 4 3
1 5 2 4 0 0 3
1 0 0 4 5 2 3
1 2 3 4 5 0 0

----- 6 種類の探索 ----- 
6 5 4 3 2 1 0 0
無し
</pre>
<p> ついでに、次に示す数列の並べ替えも調べてみました。
</p>
<ol start=4>
  <li> [７ ６ ５ ４ ３ ２ １ ・ ・] --&gt; [１ ２ ３ ４ ５ ６ ７ ・ ・]
  <li> [８ ７ ６ ５ ４ ３ ２ １ ・ ・] --&gt; [１ ２ ３ ４ ５ ６ ７ ８ ・ ・]
  <li> [９ ８ ７ ６ ５ ４ ３ ２ １ ・ ・] --&gt; [１ ２ ３ ４ ５ ６ ７ ８ ９ ・ ・]
</ol>
<pre>
----- 7 種類の探索 ----- 
7 6 5 4 3 2 1 0 0
無し

----- 8 種類の探索 ----- 
8 7 6 5 4 3 2 1 0 0
8 7 6 0 0 3 2 1 5 4
0 0 6 8 7 3 2 1 5 4
1 5 6 8 7 3 2 0 0 4
1 5 6 8 0 0 2 7 3 4
1 0 0 8 5 6 2 7 3 4
1 2 7 8 5 6 0 0 3 4
1 2 0 0 5 6 7 8 3 4
1 2 3 4 5 6 7 8 0 0

----- 9 種類の探索 ----- 
9 8 7 6 5 4 3 2 1 0 0
9 8 7 6 5 4 0 0 1 3 2
0 0 7 6 5 4 9 8 1 3 2
6 5 7 0 0 4 9 8 1 3 2
6 5 7 4 9 0 0 8 1 3 2
6 5 7 4 9 1 3 8 0 0 2
6 5 7 4 0 0 3 8 9 1 2
6 0 0 4 5 7 3 8 9 1 2
6 7 3 4 5 0 0 8 9 1 2
0 0 3 4 5 6 7 8 9 1 2
1 2 3 4 5 6 7 8 9 0 0
</pre>
<p> 4. は並べ替え不可能ですが、5. は 8 手で、6. は 10 手で並べ替えることができました。実はこのパズル、15 パズルと同様の「偶奇性 (パリティ) 」があり、これをチェックすることで並べ替えの可否を簡単に判断することができます。
</p>

<h4 id="parity">●偶奇性</h4>
<p> たとえば、数字の並びが [1 2 3 4] の場合を考えてみます。数字が順番に並んでいる場合、各数字の左側には自分より大きな数字はありませんね。これに対して [4 3 2 1] の場合、1 の左側には 3, 4, 5 があり、2 の左側には 3 と 4 があり、3 の左側には 4 があります。このように数字の順番が逆になっている個数を数え、その総数を仮に「転倒数」と名づけましょう。[1 2 3 4] は転倒数が 0 で、[4 3 2 1] は転倒数が 6 となります。
</p>
<p> ここで、[1 2 3 4] と [4 3 2 1] の転倒数が偶数であることに注目してください。このような数字の並びを「偶順列」といい、転倒数が奇数の場合を「奇順列」といいます。たとえば、[2 1 3 4] は 1 と 2 が逆転しているだけなので、転倒数が 1 の奇順列になります。そして、数字をペアで動かす場合、<b>「偶順列は偶順列のままで、奇順列は奇順列のままである」</b> ことが <a href="index.html#puz_cite">参考文献 [10]</a> で証明されています。つまり、奇順列である [2 1 3 4] は、どうやっても偶順列 [1 2 3 4] に並べ替えることはできないのです。[6 5 4 3 2 1] と [7 6 5 4 3 2 1] の場合も転倒数が 15 と 21 の奇順列なので、並べ替えることができなかったわけです。
</p>
<p> このように、パズルには奇数と偶数に場合分けができるものがあり、このような性質を <b>偶奇性（パリティ）</b> といいます。15 パズルにも偶順列と奇順列があり、どのように駒を移動しても、偶順列は偶順列、奇順列は奇順列にしか移行できないそうです。15 パズルについては、<a href="index.html#puz_cite">参考文献 [9]</a> に詳細な説明があります。
</p>
<hr>
<h3 id="reverse">n 個の数字を逆順に並べる場合</h3>
<p> 今度は、「n 個の数字を逆順に並べる」場合を考えてみましょう。この場合、並べ替えの可否だけならば、簡単に調べることができます。次の表を見てください。
</p>
<section class="contents">
<h4>●訂正(2001/03/30)</h4>
<p> 転倒数が奇数（奇順列）であれば絶対に解くことはできませんが、「偶順列であれば必ず解くことができる」とは限りません。数字が 4 種類の場合、偶順列でも解けない場合があります。したがって、簡単に調べることができるのは「解けない場合」だけです。訂正してお詫びいたします。詳しい説明は <a href="changenum.html#update2">最長手数を求める</a> をご覧ください。
</p>
</section>
<table border=1>
<thead>
  <tr><th>数字の並び</th><th>転倒数</th></tr>
</thead>
<tbody>
  <tr><td>4 3 2 1</td><td>6</td></tr>
  <tr><td>5 4 3 2 1</td><td>10</td></tr>
  <tr><td>6 5 4 3 2 1</td><td>15</td></tr>
  <tr><td>7 6 5 4 3 2 1</td><td>21</td></tr>
  <tr><td>8 7 6 5 4 3 2 1</td><td>28</td></tr>
  <tr><td>9 8 7 6 5 4 3 2 1</td><td>36</td></tr>
  <tr><td>10 9 8 7 6 5 4 3 2 1</td><td>45</td></tr>
</tbody>
</table>
<p> n 個の数字の並びに数字をひとつ追加すると、各数字に逆順の数字がひとつずつ増えるため、転倒数が n 増えることがわかります。つまり、n 個の数字を逆順に並べた場合、転倒数は 1 から n - 1 までの総和になるのです。したがって、転倒数は次の式で求めることができます。
</p>
<pre class="item">
転倒数 = n * (n - 1) / 2
</pre>
<p> 求めた転倒数が<del>偶数であれば並べ替えることができますが、</del> 奇数であれば並べ替えることはできません。
</p>

<p>表をよく見てみると、転倒数は「偶数、偶数、奇数、奇数、・・・・」と順番に並んでいますね。これも数式から求めることができます。数字の個数を 4m, 4m + 1, 4m + 2, 4m + 3 (m = 1, 2, 3 ...) で表すことにすると、転倒数は次のようになります。
</p>
<ol>
  <li>4m の場合<br>
      4m(4m - 1) / 2 = 2m(4m - 1) --- 偶数
  <li>4m + 1 の場合<br>
      (4m + 1)4m / 2 = 2m(4m + 1) --- 偶数
  <li>4m + 2 の場合<br>
      (4m + 2)(4m + 1) / 2 = 2m(4m + 3) + 1 --- 奇数
  <li>4m + 3 の場合<br>
      (4m + 3)(4m + 2) / 2 = 2m(4m + 5) + 3 --- 奇数
</ol>
<p> 整数に偶数を掛け算すると、その結果は偶数になります。<del>したがって、1. と 2. の転倒数は必ず偶数になるので、並べ替えることができます。</del> それから、偶数に奇数を足し算すると、その結果は奇数になりますね。よって、3. と 4. の転倒数は必ず奇数になるので、並べ替えることができないのです。
</p>

<p> 「おしどりの遊び」や「蛙跳びゲーム」では、<a href="kaeru.html#follow1">白黒 n 個ずつの最短手数</a> を求めることができました。<del> では、数字を逆順に並べた場合、4m 個と 4m + 1 個の最短手数を求めることはできるのでしょうか。</del> 実際、12 と 13 は並び替えができることをプログラムで確認しましたが、規則性についてはよくわかりません。
</p>
<p> また、今回のプログラムは幅優先探索を使っているため、これ以上大きな数を探索しようとすると、メモリが足りなくなってしまいます。13 を解いているときでもスワップしまくりだったので、探索手法は幅優先探索から反復深化へ切り替えた方がよいでしょう。<del>この問題はもう少し考えてみたいと思います。何か良いアイデアがありましたら、教えてくださいませ。</del>
</p>
<p><a href="changenum.html#list1">●プログラムリスト１</a>
</p>
<hr>
<h3 id="update2">最長手数を求める</h3>
<p> 次は、最長手数となる並び、つまり、いちばん難しい数字の並びを求めてみましょう。このような場合、すべての並び (パターン) について最小手数をチェックしていたのでは、時間がとてもかかってしまいます。そこで、完成形から始めていちばん長い手数の局面を生成することにします。
</p>
<p> まず、完成形から数字を動かして 1 手で到達する局面をすべて作ります。次に、これらの局面から数字を動かして新しい局面を作れば、完成形から 2 手で到達する局面となります。このように、手数を 1 手ずつ延ばしていき、新しい局面が生成できなくなった時点での手数が求める最長手数となります。この処理は幅優先探索を使えばぴったりです。
</p>
<p> さて、生成されるパターンの総数ですが、ふたつの空き場所はひとつの数字にみなすことができるので、数字が n 種類のパターンは (n + 1)! / 2 通りになります。たとえば、数字が 8 種類の場合は 9! / 2 = 181440 通りとなります。これは「8 パズル」と同じ総数ですね。とりあえず、4 - 8 種類の最長手数を求めることにします。
</p>
<p> プログラムは前回作成したプログラムを少し改造するだけでＯＫです。それでは実行結果を示します。
</p>
<pre>
----- 4 種類の探索 ----- 
状態数 20, 最長手数 6 手
0 0 4 3 2 1 
総数 1 個

----- 5 種類の探索 ----- 
状態数 360, 最長手数 9 手
0 0 5 3 4 1 2 
1 2 4 5 3 0 0 
4 5 0 0 3 1 2 
1 2 5 0 0 3 4 
1 2 5 3 4 0 0 
0 0 5 1 2 3 4 
5 1 0 0 2 3 4 
2 3 5 1 0 0 4 
5 2 1 4 0 0 3 
1 0 0 5 3 2 4 
総数 10 個

----- 6 種類の探索 ----- 
状態数 2520, 最長手数 10 手
0 0 6 5 2 3 4 1 
2 5 0 0 4 3 6 1 
総数 2 個

----- 7 種類の探索 ----- 
状態数 20160, 最長手数 9 手
0 0 3 4 1 2 5 6 7 
7 0 0 3 5 4 6 2 1 
6 1 7 2 5 4 3 0 0 
・・・省略・・・
総数 864 個

----- 8 種類の探索 ----- 
状態数 181440, 最長手数 10 手
2 7 4 5 6 3 8 0 0 1 
4 2 7 3 8 5 0 0 6 1 
0 0 4 3 6 5 8 7 2 1 
・・・省略・・・
総数 1273 個
</pre>
<p> うーん、思っていたよりも最長手数は短いですね。パズルとして楽しむ場合、5, 6 種類くらいで十分なのかもしれません。
</p>
<p> それから、4 種類の場合は 5! / 2 = 60 通りのパターンがあるはずですが、20 通りのパターンしか生成していません。ということは、<b>「数字の並びが偶順列でも解けない場合がある」</b> ということです。たとえば、[1 3 4 2 0 0] は偶順列ですが、実際に試してみると解くことはできません。つまり、偶奇性（パリティ）を満たしているからといって、解けるとは限らないのです。逆に、偶奇性を満たしていないと絶対に解けません。
</p>
<p> ところが、数字が 5 - 8 種類の場合はすべてのパターンを生成していますね。この場合、数字の並びが偶順列であれば必ず解くことができます。どうも 4 種類の場合だけが特別で、数字が 5 種類以上の場合、偶奇性を満たせば解くことができるように思われます。数学的に証明できればいいのですが、M.Hiroi はお手上げです。何か良いアイデアがありましたら、ぜひ教えてくださいませ。
</p>
<p><a href="changenum.html#list2">●プログラムリスト２</a>
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
/*
 * chgnum.c : パズル「数字の並べ替え」逆順の解法
 *            移動ルールは「おしどりの遊び」と同じ
 *
 *              Copyright (C) 2001 Makoto Hiroi
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE  1
#define FALSE 0
#define NOT_FOUND (-1)
#define MAX_SIZE 12
#define FORWARD  0
#define BACKWARD 1 
#define NIL   (-1)


/* 適当 */
#define MAX_STATE 80000

/* 連結リスト */
typedef struct {
  char board[MAX_SIZE];
  int next;
} CELL;

/* 状態 */
CELL *state;
char space_postion[MAX_STATE];
char move_postion[MAX_STATE];
int  prev_state[MAX_STATE];
char direction[MAX_STATE];

/* ハッシュ表 */
#define HASH_SIZE 19997
int hash_table[HASH_SIZE];

/* ハッシュ関数 */
int hash_value( int n, int size )
{
  int i;
  unsigned int value = 0;
  for( i = 0; i &lt; size; i++ ){
    value = value * 10 + state[n].board[i];
  }
  return value % HASH_SIZE;
}

/* ハッシュ表への登録 */
int insert_hash( int i, int size, int board_size )
{
  int h = hash_value( i, size );
  int n = hash_table[h];
  /* 連結リストの探索 */
  while( n != NIL ){
    if( memcmp( state[i].board, state[n].board, board_size ) == 0 ){
      return n;      /* 登録済み */
    }
    n = state[n].next;
  }
  /* 先頭に追加 */
  state[i].next = hash_table[h];
  hash_table[h] = i;
  return NOT_FOUND;
}


/* 結果を出力 */
void print_answer_forward( int n, int size )
{
  int i;
  if( n &gt; 1 ) print_answer_forward( prev_state[n], size );
  for( i = 0; i &lt; size; i++ ){
    printf("%d ", state[n].board[i] );
  }
  printf("\n");
}

void print_answer_backward( int n, int size )
{
  do {
    int i;
    n = prev_state[n];
    for( i = 0; i &lt; size; i++ ){
      printf("%d ", state[n].board[i] );
    }
    printf("\n");
  } while( prev_state[n] != -1 );
}

void print_answer( int i, int j, int size )
{
  if( direction[i] == FORWARD ){
    print_answer_forward( i, size );
    print_answer_backward( j, size );
  } else {
    print_answer_forward( j, size );
    print_answer_backward( i, size );
  }
}


/* 初期化 */
void init_data( int size, int board_size )
{
  int i;
  /* 初期値 */
  for( i = 0; i &lt; size; i++ ){
    state[0].board[i] = size - i;
  };
  space_postion[0] = i;
  move_postion[0] = NIL;
  state[0].board[i++] = 0;
  state[0].board[i] = 0;
  prev_state[0] = NIL;
  direction[0] = FORWARD;
  
  /* ゴール */
  for( i = 0; i &lt; size; i++ ){
    state[1].board[i] = i + 1;
  };
  space_postion[1] = i;
  move_postion[1] = NIL;
  state[1].board[i++] = 0;
  state[1].board[i] = 0;
  prev_state[1] = NIL;
  direction[1] = BACKWARD;

  /* ハッシュ表の初期化 */
  for( i = 0; i &lt; HASH_SIZE; i++ ){
    hash_table[i] = NIL;
  }
  /* 登録 */
  insert_hash( 0, size, board_size );
  insert_hash( 1, size, board_size );
}

/* 探索関数 */
void search( int size )
{
  int r = 0, w = 2;
  int board_size = size + 2;
  /* 初期化 */
  init_data( size, board_size );
  printf("----- %d 種類の探索 ----- \n", size );
  for( ; r &lt; w; r++ ){
    int k = space_postion[r];
    int i, j;
    for( i = 0; i &lt; board_size - 1; i++ ){
      if( (i != move_postion[r]) &amp;&amp; (state[r].board[i] &amp;&amp; state[r].board[i + 1])  ){
        /* 盤面をコピーする */
        memcpy( state[w].board, state[r].board, board_size );
        state[w].board[k] = state[r].board[i];
        state[w].board[k + 1] = state[r].board[i + 1];
        state[w].board[i] = 0;
        state[w].board[i + 1] = 0;
        space_postion[w] = i;
        move_postion[w] = k;
        direction[w] = direction[r];
        prev_state[w] = r;
        /* 検索する */
        j = insert_hash( w, size, board_size );
        if( j &gt;= 0 ){
          if( direction[j] != direction[w] ){
	    /* 解けた */
	    print_answer( j, w, board_size );
            printf("状態数 %d 個\n", w );
            return;
	  }
        } else {
          w++; /* 登録 */
          if( w &gt;= MAX_STATE ){
            fprintf( stderr, "状態数オーバー\n" ); exit( 1 );
          }
        }
      }
    }
  }
  printf("状態数 %d 個\n", w );
}

int main()
{
  int i, j, start, end;
  state = malloc( sizeof( CELL ) * MAX_STATE );
  if( state == NULL ){
    fprintf( stderr, "Out of Memory\n" );
  }
  for( i = 4; i &lt; 10; i++ ){
    start = clock();
    search( i );
    end = clock();
    printf("時間 %d\n", end - start );
  }
  return 0;
}
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
/*
 * chgnum1.c : パズル「数字の並べ替え」最長手数を求める
 *
 *             Copyright (C) 2001 by Makoto Hiroi
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE  1
#define FALSE 0
#define NOT_FOUND (-1)
#define MAX_SIZE 12
#define NIL   (-1)


/* 9! / 2 + 1 */
#define MAX_STATE 181441

/* 連結リスト */
typedef struct {
  char board[MAX_SIZE];
  int next;
} CELL;

/* 状態 */
CELL *state;
char space_postion[MAX_STATE];
char move_postion[MAX_STATE];
int  prev_state[MAX_STATE];
char move_count[MAX_STATE];

/* ハッシュ表 */
#define HASH_SIZE 19997
int hash_table[HASH_SIZE];

/* ハッシュ関数 */
int hash_value( int n, int size )
{
  int i;
  unsigned int value = 0;
  for( i = 0; i &lt; size; i++ ){
    value = value * 10 + state[n].board[i];
  }
  return value % HASH_SIZE;
}

/* ハッシュ表への登録 */
int insert_hash( int i, int size, int board_size )
{
  int h = hash_value( i, size );
  int n = hash_table[h];
  /* 連結リストの探索 */
  while( n != NIL ){
    if( memcmp( state[i].board, state[n].board, board_size ) == 0 ){
      return n;      /* 登録済み */
    }
    n = state[n].next;
  }
  /* 先頭に追加 */
  state[i].next = hash_table[h];
  hash_table[h] = i;
  return NOT_FOUND;
}


/* 結果を出力 */
void print_answer( int w, int size )
{
  int c = 0;
  int max_move = move_count[--w];
  printf("状態数 %d, 最長手数 %d 手\n", w + 1, max_move );
  do {
    int i;
    for( i = 0; i &lt; size; i++ ){
      printf("%d ", state[w].board[i] );
    }
    printf("\n");
    c++;
  } while( move_count[--w] == max_move );
  printf("総数 %d 個\n", c );
}

/* 初期化 */
void init_data( int size, int board_size )
{
  int i;
  /* 初期値 */
  for( i = 0; i &lt; size; i++ ){
    state[0].board[i] = i + 1;
  };
  space_postion[0] = i;
  move_postion[0] = NIL;
  state[0].board[i++] = 0;
  state[0].board[i] = 0;
  prev_state[0] = NIL;
  move_count[0] = 0;

  /* ハッシュ表の初期化 */
  for( i = 0; i &lt; HASH_SIZE; i++ ){
    hash_table[i] = NIL;
  }
  /* 登録 */
  insert_hash( 0, size, board_size );
}

/* 探索関数 */
void search( int size )
{
  int r = 0, w = 1;
  int board_size = size + 2;
  /* 初期化 */
  init_data( size, board_size );
  printf("----- %d 種類の探索 ----- \n", size );
  for( ; r &lt; w; r++ ){
    int k = space_postion[r];
    int i;
    for( i = 0; i &lt; board_size - 1; i++ ){
      if( (i != move_postion[r]) &amp;&amp; (state[r].board[i] &amp;&amp state[r].board[i + 1])  ){
        /* 盤面をコピーする */
        memcpy( state[w].board, state[r].board, board_size );
        state[w].board[k] = state[r].board[i];
        state[w].board[k + 1] = state[r].board[i + 1];
        state[w].board[i] = 0;
        state[w].board[i + 1] = 0;
        space_postion[w] = i;
        move_postion[w] = k;
        move_count[w] = move_count[r] + 1;
        prev_state[w] = r;
        /* 検索する */
        if( insert_hash( w, size, board_size ) &lt; 0 ){
          w++; 
        }
      }
    }
  }
  /* 答えを出力 */
  print_answer( w, board_size );
}

int main()
{
  int i, j, start, end;
  state = malloc( sizeof( CELL ) * MAX_STATE );
  if( state == NULL ){
    fprintf( stderr, "Out of Memory\n" );
  }
  for( i = 4; i &lt; 9 ; i++ ){
    start = clock();
    search( i );
    end = clock();
    printf("時間 %d\n", end - start );
  }
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>