<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / スライディングブロックパズル</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881774</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>スライディングブロックパズル</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>問題の説明</h3>
<p> 15 パズルの変形版です。下図を見てください。
</p>
<pre class="fig">
┌─┬─┬─┬─┐  ┌─┬─┬─┬─┐
│●│●│●│●│  │  │○│○│○│
├─┼─┼─┼─┤  ├─┼─┼─┼─┤
│●│●│●│●│  │○│○│○│○│
├─┼─┼─┼─┤=&gt;├─┼─┼─┼─┤ 
│○│○│○│○│  │●│●│●│●│
├─┼─┼─┼─┤  ├─┼─┼─┼─┤
│○│○│○│  │  │●│●│●│●│
└─┴─┴─┴─┘  └─┴─┴─┴─┘
    ＳＴＡＲＴ           ＧＯＡＬ

  図：スライディングブロックパズル(1)
</pre>
<p> 駒の種類は白と黒の 2 種類しかありません。駒の動かし方も 15 パズルと同じで、1 回に 1 個の駒を空いている隣の場所に滑らせて移動します。駒を跳び越したり持ち上げたりすることはできません。START から GOAL までの最短手順を求めてください。
</p>
<hr>
<h4 id="update">●解答</h4>
<p> 最短手順は 48 手です。以下に手順を示します。数字の 1 が黒駒、2 が白駒、0 が空いている場所を表します。
</p>
<pre class="fig">
[START]
1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1
1 1 1 1   1 1 1 1   1 1 1 0   1 1 0 1   1 1 2 1   1 1 2 1   1 0 2 1   0 1 2 1
2 2 2 2   2 2 2 0   2 2 2 1   2 2 2 1   2 2 0 1   2 0 2 1   2 1 2 1   2 1 2 1
2 2 2 0   2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2

1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 0 1 1   0 1 1 1   2 1 1 1
2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 0 2 1   2 1 2 1   2 1 2 1   0 1 2 1
0 1 2 1   2 1 2 1   2 1 2 1   2 0 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1
2 2 2 2   0 2 2 2   2 0 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2

2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   2 0 1 1   2 1 0 1   2 1 2 1
2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 0 2 1   2 1 2 1   2 1 2 1   2 1 0 1
0 1 2 1   2 1 2 1   2 1 2 1   2 0 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1
2 1 2 2   0 1 2 2   1 0 2 2   1 1 2 2   1 1 2 2   1 1 2 2   1 1 2 2   1 1 2 2

2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 0   2 1 0 2   2 1 2 2
2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 0   2 1 2 1   2 1 2 1   2 1 0 1
2 1 0 1   2 1 2 1   2 1 2 1   2 1 2 0   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1
1 1 2 2   1 1 0 2   1 1 2 0   1 1 2 1   1 1 2 1   1 1 2 1   1 1 2 1   1 1 2 1

2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2   2 1 2 2
2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 1   2 1 2 0   2 1 0 2   2 1 2 2   2 1 2 2
2 1 0 1   2 1 2 1   2 1 2 1   2 1 2 0   2 1 2 1   2 1 2 1   2 1 0 1   2 0 1 1
1 1 2 1   1 1 0 1   1 1 1 0   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1

2 1 2 2   2 0 2 2   0 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   2 0 2 2
2 0 2 2   2 1 2 2   2 1 2 2   0 1 2 2   2 1 2 2   2 1 2 2   2 0 2 2   2 2 2 2
2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   0 1 1 1   1 0 1 1   1 1 1 1   1 1 1 1
1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1

[GOAL1]   [GOAL2]
0 2 2 2   2 2 0 2
2 2 2 2   2 2 2 2
1 1 1 1   1 1 1 1
1 1 1 1   1 1 1 1
</pre>

<h4 id="update1">●組み合わせに番号をつける方法</h4>
<p> それではプログラムを作ります。使用するプログラミング言語はＣ言語です。今回はオーソドックスに幅優先探索を使いましょう。局面の総数ですが、空き場所の位置が 16 通りで、残り 15 マスに 8 個の黒駒を置くわけですから、次のようになります。
</p>
<pre class="item">
16 * <sub>15</sub>Ｃ<sub>8</sub> = 16 * 6435 = 102960 通り
</pre>
<p> 何度も説明しましたが、幅優先探索でパズルを解く場合、同一局面の検索処理が重要になります。単純な線形探索で局面を検索すると、答えが出るまでに時間がとてもかかってしまいます。<a href="eight.html">幅優先探索の高速化(1)</a> では、順列 N! に 0 から N! - 1 までの番号をつけることで、同一局面のチェックを高速に行うことができました。そこで、今回は <sub>n</sub>Ｃ<sub>r</sub> の組み合わせに番号をつけることにします。
</p>

<p> たとえば、0 から 5 までの数字から 3 つを選ぶ組み合わせを考えましょう。この場合、組み合わせの総数は <sub>6</sub>Ｃ<sub>3</sub> = 20 通りになります。実は、組み合わせを数値に変換するだけならば、次の方法で簡単に行うことができます。
</p>
<p> 各数字を 0 bit から 5 bit までに対応させます。すると、2, 3, 4 という組み合わせは  0 1 1 1 0 0 と表すことができますね。したがって、数値は 0 0 0 1 1 1 (7) から 1 1 1 0 0 0 (56) までとなります。ハッシュ関数の中で、ハッシュ値が衝突しない関数を<b>完全ハッシュ関数</b>、N 個のデータを 0 から N - 1 に変換する関数を<b>最小完全ハッシュ関数</b>と呼びますが、この方法では最小完全ハッシュ関数を実現することはできません。
</p>

<p> 今回は 15 個の中から 8 個を選ぶ組み合わせですから、この方法だと最大で 32640 になります。組み合わせの総数は 6435 通りしかないので、これでは無駄が多すぎます。そこで、最小完全ハッシュ関数を作ることにしましょう。基本的な考え方は順列の場合と同じです。たとえば、<sub>6</sub>Ｃ<sub>3</sub> の組み合わせで 1 1 1 0 0 0 を考えてみましょう。次の図を見てください。
</p>
<pre class="fig">
5 4 3 2 1 0
─────────
0 0 0 1 1 1    ↑
0 0 1 0 1 1    │
0 0 1 1 0 1    │
0 0 1 1 1 0    │
0 1 0 0 1 1    │
0 1 0 1 0 1   5Ｃ3 = 10 通り
0 1 0 1 1 0    │
0 1 1 0 0 1    │
0 1 1 0 1 0    │
0 1 1 1 0 0    ↓
─────────
1 0 0 0 1 1    ↑
1 0 0 1 0 1    │
1 0 0 1 1 0    │
1 0 1 0 0 1   4Ｃ2 = 6 通り
1 0 1 0 1 0    │
1 0 1 1 0 0    ↓
  ────────
1 1 0 0 0 1    ↑
1 1 0 0 1 0   3Ｃ1 = 3 通り
1 1 0 1 0 0    ↓
    ───────
1 1 1 0 0 0    19 番目
─────────

  図：6Ｃ3 の組み合わせ
</pre>

<p> 最初に 5 をチェックします。5 を選ばない場合は <sub>5</sub>Ｃ<sub>3</sub> = 10 通りありますね。この組み合わせに 0 から 9 までの番号を割り当てることにすると、5 を選ぶ組み合わせの番号は 10 から 19 までとなります。
</p>
<p> 次に、4 をチェックします。4 を選ばない場合は、<sub>4</sub>Ｃ<sub>2</sub> = 6 通りあります。したがって、5 を選んで 4 を選ばない組み合わせに 10 から 15 までの番号を割り当てることにすると、5 と 4 を選ぶ組み合わせには 16 から 19 までの番号となります。
</p>
<p> 最後に、3 をチェックします。同様に 3 を選ばない場合は 3 通りあるので、これに 16 から 18 までの番号を割り当て、5, 4, 3 を選ぶ組み合わせには 19 を割り当てます。これで組み合わせ 1 1 1 0 0 0 の番号を求めることができました。
</p>
<p> では、0 0 0 1 1 1 はどうなるのでしょうか。左から順番にチェックしていくと、最初の 1 が見つかった時点で、その数字を選ばない組み合わせは存在しません。つまり、残りの数字をすべて選ぶしかないわけです。したがって、これが 0 番目となります。
</p>

<p> このように、数字を選ぶときに、数字を選ばない場合の組み合わせの数を足し算していけば、その組み合わせの番号を求めることができるのです。
</p>

<h4>●パスカルの三角形</h4>
<p> ところで、このプログラムでは組み合わせの数が必要になります。このような場合、公式を使っていちいち計算するよりも、あらかじめ値をテーブルに格納しておいて参照した方がいいでしょう。そこで、<b>パスカルの三角形</b>を利用してテーブルを作成することにします。次の図を見てください。
</p>
<pre class="fig">
                １                                 0Ｃ0
              ／  ＼                              ／  ＼
            １      １                         1Ｃ0    1Ｃ1
          ／  ＼  ／  ＼                      ／  ＼  ／  ＼
        １      ２      １                 2Ｃ0    2Ｃ1    2Ｃ2
      ／  ＼  ／  ＼  ／  ＼              ／  ＼  ／  ＼  ／  ＼
    １      ３      ３      １         3Ｃ0    3Ｃ1    3Ｃ2    3Ｃ3
  ／  ＼  ／  ＼  ／  ＼  ／  ＼      ／  ＼  ／  ＼  ／  ＼  ／  ＼
１      ４      ６      ４      １ 4Ｃ0    4Ｃ1    4Ｃ2    4Ｃ3    4Ｃ4

                        図：パスカルの三角形
</pre>
<p> パスカルの三角形は、左側の図のように両側がすべて 1 で、内側の数はその左上と右上の和になっています。これは (a + b)<SUP>n</SUP> を展開したときの各項の係数を表しています。そして、その値は右側の図のように組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> に対応しています。
</p>

<p> プログラムはとても簡単です。
</p>

<pre class="list">
リスト：パスカルの三角形

/* グローバル変数 */
int comb_table[15][15];

/* 初期化 */
void init_comb_table( void )
{
  int i, j;
  comb_table[0][0] = 1;
  for( i = 1; i &lt; 15; i++ ){
    comb_table[i][0] = comb_table[i][i] = 1;
    for( j = 1; j &lt; i; j++ ){
      comb_table[i][j] = comb_table[i -1][j - 1] + comb_table[i - 1][j];
    }
  }
}
</pre>
<p> 組み合わせの数はグローバル変数 comb_table に格納します。あとは、パスカルの三角形をそのままプログラムしただけです。ただし、comb_table には 2 次元配列を使っているため、無駄が多いのが欠点です。まあ、大きな配列というわけではないので、今回は大目に見てくださいね。1 次元配列に収めることもできるので、興味のある方は作り直してみてください。
</p>

<h4 id="update2">●最小完全ハッシュ関数</h4>
<p> 組み合わせに番号をつけることができれば、最小完全ハッシュ関数を作るのは簡単です。空き場所の位置は 0 から 15 まであるので、「空き場所の位置 * 組み合わせの番号」が求めるハッシュ値となります。プログラムは次のようになります。空き場所の位置を S (0)、黒石を B (1)、白石を W (2) で表しています。
</p>

<pre class="list">
リスト：最小完全ハッシュ関数

int hash_value( char *board )
{
  int space = 0, value = 0;
  int i, n = 15, r = 8;
  for (i = 0; i &lt; SIZE; i++){
    switch( board[i] ){
    case S:
      space = i; break;
    case B:
      if( n &gt; r &amp;&amp; r &gt; 0 ){
        value += comb_table[--n][r--];
      }
      break;
    default:
      n--;
    }
  }
  return space * 6435 + value;
}
</pre>

<p> 変数 space に空き場所の位置を格納し、組み合わせの番号は変数 value に求めます。このプログラムのポイントは変数 n と r の使い方です。これらの変数は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。黒石を見つけたら n と r の値をチェックします。n と r の値が同じになるか、もしくは r が 0 になれば、組み合わせの番号は確定しているので何もしません。そうでなければ、comb_table の値を value に加えます。comb_table の値を参照するとき、n をデクリメントすることをお忘れなく。
</p>

<p> あとのプログラムは、お馴染みの幅優先探索なので難しくはありません。いつものように、スタートとゴールの両方向から探索を行っています。詳細は <a href="slide.html#list">プログラムリスト</a> をお読みくださいませ。実行時間ですが、オンボロマシン (Pentium 166 MHz) で 600 msec 前後くらいになりました。
</p>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
/*
 * slide.c : スライディングブロックパズル
 *           １５パズルの変形版
 *
 *           Copyright (C) 2001 M.Hiroi
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE 1
#define FALSE 0

#define SIZE  16
#define NIL   (-1)

#define MAX_STATE 102960
#define FORWARD  1
#define BACKWARD 2

#define S 0
#define B 1
#define W 2

/* 隣接リスト
    0  1  2  3
    4  5  6  7
    8  9 10 11
   12 13 14 15
*/
const char adjacent[SIZE][5] = {
   1,  4, -1, -1, -1,  /* 0 */
   0,  2,  5, -1, -1,  /* 1 */
   1,  3,  6, -1, -1,  /* 2 */
   2,  7, -1, -1, -1,  /* 3 */
   0,  5,  8, -1, -1,  /* 4 */
   1,  4,  6,  9, -1,  /* 5 */
   2,  5,  7, 10, -1,  /* 6 */
   3,  6, 11, -1, -1,  /* 7 */
   4,  9, 12, -1, -1,  /* 8 */
   5,  8, 10, 13, -1,  /* 9 */
   6,  9, 11, 14, -1,  /* 10 */
   7, 10, 15, -1, -1,  /* 11 */
   8, 13, -1, -1, -1,  /* 12 */
   9, 12, 14, -1, -1,  /* 13 */
  10, 13, 15, -1, -1,  /* 14 */
  11, 14, -1, -1, -1,  /* 15 */
};

/* 初期状態 */
char init_state[SIZE] = {
  B, B, B, B,
  B, B, B, B,
  W, W, W, W,
  W, W, W, S,
};

/* 最終状態 */
char final_state[SIZE] = {
  S, W, W, W,
  W, W, W, W,
  B, B, B, B,
  B, B, B, B,
};

/* ハッシュ表 state number を記憶 */
int hash_table[MAX_STATE];

/* キュー */
char state[MAX_STATE + 1][SIZE];    /* +1 はワーク領域 */
char space_postion[MAX_STATE +1];
int  prev_state[MAX_STATE + 1];
char direction[MAX_STATE + 1];

/* パスカルの三角形 */
int comb_table[15][15];

/* 初期化 */
void init( void )
{
  int i, j;
  comb_table[0][0] = 1;
  for( i = 1; i &lt; 15; i++ ){
    comb_table[i][0] = comb_table[i][i] = 1;
    for( j = 1; j &lt; i; j++ ){
      comb_table[i][j] = comb_table[i -1][j - 1] + comb_table[i - 1][j];
    }
  }
  /* ハッシュ表の初期化 */
  for( i = 0; i &lt; MAX_STATE; i++ ){
    hash_table[i] = NIL;
  }
}

/* 組み合わせの完全ハッシュ関数 */
int hash_value( char *board )
{
  int space = 0, value = 0;
  int i, n = 15, r = 8;
  for (i = 0; i &lt; SIZE; i++){
    switch( board[i] ){
    case S:
      space = i; break;
    case B:
      if( n &gt; r &amp;&amp; r &gt; 0 ){
        value += comb_table[--n][r--];
      }
      break;
    default:
      n--;
    }
  }
  return space * 6435 + value;
}

/* ハッシュへ挿入 */
int insert_hash( int n )
{
  int value = hash_value( state[n] );
  if( hash_table[value] != NIL ) return hash_table[value];
  hash_table[value] = n;
  return NIL;
}

/* 結果を出力 */
void print_answer_forward( int n )
{
  int i;
  if( n &gt; 1 ) print_answer_forward( prev_state[n] );
  for( i = 0; i &lt; SIZE; i++ ){
    printf("%d ", state[n][i] );
  }
  printf("\n");
}

void print_answer_backward( int n )
{
  do {
    int i;
    n = prev_state[n];
    for( i = 0; i &lt; SIZE; i++ ){
      printf("%d ", state[n][i] );
    }
    printf("\n");
  } while( prev_state[n] != -1 );
}

void print_answer( int i, int j )
{
  if( direction[i] == FORWARD ){
    print_answer_forward( i );
    print_answer_backward( j );
  } else {
    print_answer_forward( j );
    print_answer_backward( i );
  }
}

/* キューを初期化 */
void init_queue( void )
{
  /* 初期化 */
  memcpy( state[0], init_state, SIZE );
  space_postion[0] = 15;
  direction[0] = FORWARD;
  prev_state[0] = NIL;
  insert_hash( 0 );

  memcpy( state[1], final_state, SIZE );
  space_postion[1] = 0;
  direction[1] = BACKWARD;
  prev_state[1] = NIL;
  insert_hash( 1 );
}

/* 探索 */
void search( void )
{
  int front = 0, rear = 2;

  init_queue();
  /* 探索 */
  while( front &lt; rear ){
    int s = space_postion[front];
    int i, n, m;
    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){
      /* 状態をコピー */
      memcpy( state[rear], state[front], SIZE );
      /* 移動 */
      state[rear][s] = state[rear][n];
      state[rear][n] = S;
      space_postion[rear] = n;
      prev_state[rear] = front;
      direction[rear] = direction[front];

      /* 局面のチェック */
      m = insert_hash( rear );
      if( m &gt;= 0 ){
        if( direction[m] != direction[rear] ){
          /* 前後からの探索が一致した */
          print_answer( m, rear );
          printf("総数 %d 個\n", rear );
          return;
        }
      } else {
        /* 登録 */
        rear++;
      }
    }
    front++;
  }
}

int main()
{
  int start, end;
  init();
  start = clock();
  search();
  end = clock();
  printf("時間 %d \n", end - start );
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>