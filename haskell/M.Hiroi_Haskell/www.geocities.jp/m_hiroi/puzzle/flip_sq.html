<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / フリップ・イット・スクエア</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>フリップ・イット・スクエア</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>問題の説明</h3>
<p> 「フリップ・イット (Flip It)」は芦ヶ原伸之氏 (<a href="index.html#puz_cite">参考文献 [12]</a>) が考案されたパズルで、すべての駒を裏返しにするのが目的です。<a href="flip_it.html">フリップ・イット・スター</a> では、駒の配置を六芒星の形にしたパズルを解きました。今回は駒を正方形に配置した「フリップ・イット・スクエア」を解いてみましょう。それでは問題です。
</p>

<pre class="fig">
      ┌─┬─┬─┬─┐
      │●│●│●│●│
      ├─┼─┼─┼─┤
      │●│  │●│●│
      ├─┼─┼─┼─┤
      │●│●│●│●│
      ├─┼─┼─┼─┤
      │●│●│●│●│
      └─┴─┴─┴─┘

問題：フリップ・イット・スクエア
</pre>
<p> ルールは「フリップ・イット」と同じで、駒はほかの駒を跳び越すことで移動することができます。詳しい説明は <a href="flip_it.html">フリップ・イット・スター</a> をお読みくださいませ。今回は駒の移動方向を縦と横の 2 方向に限定し、斜め跳びは禁止することにします。すべての駒を白にする最短手順を求めてください。
</p>
<p> 興味のある方は、斜め跳びを許可した場合の最短手順にも挑戦してみてください。この場合、単純な反復深化では時間がかかるかもしれません。ご注意くださいませ。
</p>

<p> それでは、パズルをお楽しみください。
</p>
<hr>
<h3 id="solve_id">反復深化による解法</h3>
<p> 最初は斜め跳びを禁止した場合の解法プログラムを単純な反復深化で作りましょう。使用するプログラミング言語はＣ言語です。プログラムは <a href="flip_it.html">フリップ・イット・スター</a> とほとんど同じで、グローバル変数の定義を変更するだけです。次のリストを見てください。
</p>

<pre class="fig">
  ┌─┬─┬─┬─┐
  │０│１│２│３│
  ├─┼─┼─┼─┤
  │４│５│６│７│
  ├─┼─┼─┼─┤
  │８│９│10│11│
  ├─┼─┼─┼─┤
  │12│13│14│15│
  └─┴─┴─┴─┘

 図：配列と盤面の対応
</pre>
<pre class="list">
リスト：グローバル変数の定義

/* 盤面 */
char board[SIZE];

/* 直線 */
const char line[LINE][4] = {
  0, 1, 2,  3,   4, 5, 6,  7,   8, 9, 10, 11,  12, 13, 14, 15,
  0, 4, 8, 12,   1, 5, 9, 13,   2, 6, 10, 14,   3,  7, 11, 15,
};

/* 移動手順 */
int line_number[MAX_MOVE + 1];
int space_position[MAX_MOVE + 1];
int piece_position[MAX_MOVE + 1];
</pre>

<p> 盤面は 1 次元配列 board で表します。盤面の位置と配列の添字の対応は、左図のように定義します。斜め跳びを禁止した場合、駒の移動方向は縦と横の 8 本の直線で表すことができます。これを配列 line で定義します。ここで、line に格納される番号は昇順に並んでいることに注意してください。
</p>
<p> 移動手順は 3 つの配列で表します。line_number に駒を動かした直線の番号、space_position に空き場所の位置、piece_position に動かした駒の位置を格納します。
</p>

<p> 次は駒の跳び先表を定義します。次のリストを見てください。
</p>

<pre class="list">
リスト：駒の跳び先表

/* 駒の跳び先表 (直線の番号と駒の位置）*/
const char move_pattern_table[][SIZE] = {
  {0, 2, 0, 3, 4, 8, 4, 12, -1},   /* 0 */
  {0, 3, 5, 9, 5, 13, -1},         /* 1 */
  {0, 0, 6, 10, 6, 14, -1},        /* 2 */
  {0, 0, 0, 1, 7, 11, 7, 15, -1},  /* 3 */
  {1, 6, 1, 7, 4, 12, -1},         /* 4 */
  {1, 7, 5, 13, -1},               /* 5 */
  {1, 4, 6, 14, -1},               /* 6 */
  {1, 4, 1, 5, 7, 15, -1},         /* 7 */
  {2, 10, 2, 11, 4, 0, -1},        /* 8 */
  {2, 11, 5, 1, -1},               /* 9 */
  {2, 8, 6, 2, -1},                /* 10 */
  {2, 8, 2, 9, 7, 3, -1},          /* 11 */
  {3, 14, 3, 15, 4, 0, 4, 4, -1},  /* 12 */
  {3, 15, 5, 1, 5, 5, -1},         /* 13 */
  {3, 12, 6, 2, 6, 6, -1},         /* 14 */
  {3, 12, 3, 13, 7, 3, 7, 7, -1},  /* 15 */
};
</pre>
<p> 配列 move_pattern_table は空き場所を基準にして、直線の番号と移動する駒の位置を順番に定義しています。-1 は終端を表します。たとえば、空き場所が 5 であれば、直線 1 の 7 にある駒、直線 5 の 13 にある駒を動かすことがでます。
</p>

<p> あとは <a href="flip_it.html">フリップ・イット・スター</a> で作成したプログラムとほとんど同じです。詳細は <a name="list_id" href="flip_sq.html#src_id">プログラムリスト１</a> をお読みください。
</p>

<h4>●実行結果</h4>
<p> さっそく実行してみたところ、最短手順は次のようになりました。図では黒石を 1, 白石を 2, 空き場所を 0 で表しています。
</p>
<pre class="fig">
  1 1 1 1
  1 0 1 1
  1 1 1 1
  1 1 1 1

  - 1 ---   - 2 ---   - 3 ---   - 4 ---   - 5 ---   - 6 ---  
  1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 0 1   0 2 1 1  
  1 1 2 0   1 1 2 1   1 1 2 1   1 1 2 1   1 1 1 1   1 1 1 1  
  1 1 1 1   1 1 1 2   1 1 1 2   1 1 1 2   1 1 2 2   1 1 2 2  
  1 1 1 1   1 1 1 0   0 2 2 1   2 1 0 1   2 1 1 1   2 1 1 1  

  - 7 ---   - 8 ---   - 9 ---   - 10 --   - 11 --   - 12 --  
  1 1 2 0   1 1 2 2   1 1 2 2   0 1 2 2   2 1 2 2   2 1 2 2  
  1 1 1 1   1 1 1 2   1 1 1 2   2 1 1 2   1 1 1 2   1 1 1 2  
  1 1 2 2   1 1 2 0   0 2 1 1   1 2 1 1   2 2 1 1   2 2 1 1  
  2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   0 1 1 1   1 2 2 0  

  - 13 --   - 14 --   - 15 --   - 16 --   - 17 --   - 18 --  
  2 1 2 2   2 1 2 2   2 1 2 2   0 1 2 2   2 2 1 0   2 2 1 2  
  1 1 1 0   0 2 2 1   1 2 2 1   2 2 2 1   2 2 2 1   2 2 2 2  
  2 2 1 2   2 2 1 2   1 2 1 2   2 2 1 2   2 2 1 2   2 2 1 0  
  1 2 2 2   1 2 2 2   0 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2  

  - 19 --   - 20 --   - 21 --   - 22 --  
  2 2 1 2   2 2 1 2   2 2 0 2   2 2 2 2  
  2 2 2 2   2 2 2 2   2 2 1 2   2 2 2 2  
  0 1 2 2   2 2 0 2   2 2 1 2   2 2 2 2  
  2 2 2 2   2 2 2 2   2 2 2 2   2 2 0 2  

            図：「フリップ・イット・スクエア」の解答
</pre>

<p> 最短手数は 22 手になりました。実は、これが斜め跳びを禁止した場合の最長手数になります。実行時間は M.Hiroi のオンボロマシン (Pentium 166 MHz) で約 90 秒でした。単純な反復深化なので、時間がかかるのはしかたがないですね。そこで、次は下限値枝刈り法を使ってプログラムの高速化に挑戦してみましょう。
</p>

<h3 id="solve_id_low">下限値枝刈り法による高速化</h3>
<p> フリップ・イット・スクエアの場合、簡単な方法で下限値を求めることができます。4 つのコーナーに注目してください。コーナーにある駒はほかの駒から跳び越されることはありません。したがって、コーナーの駒が黒の場合、まずコーナーから別の場所に移動して、それからほかの駒に跳び越されないと白にすることはできません。よって、コーナーにある黒駒を裏返しにするには、最低でも 2 手必要になることがわかります。これを下限値として利用することにしましょう。
</p>

<p> プログラムの修正は次のようになります。
</p>

<pre class="list">
リスト：下限値枝刈り法による解法

/* 下限値を求める */
int get_lower_value( void )
{
  int c = 0;
  if( board[0] == B ) c++;
  if( board[3] == B ) c++;
  if( board[12] == B ) c++;
  if( board[15] == B ) c++;
  return c * 2;
}

/* 反復深化による探索 */
void solve_id( int n, int limit, int space )
{
  if( n == limit ){
    if( !count_piece( B ) ){
      print_answer( n );
      printf("時間 %d\n", clock() - start );
      exit( 1 );
    }
  } else {
    int i, l, p;
    for( i = 0; (l = move_pattern_table[space][i++]) != -1; ){
      p = move_pattern_table[space][i++];
      if( l != line_number[n] || p != space_position[n] ){
        move_piece( l, space, p );
        piece_position[n + 1] = p;
        space_position[n + 1] = space;
        line_number[n + 1] = l;
        /* 下限値枝刈り法 */
        if( n + 1 + get_lower_value() &lt;= limit ){
          solve_id( n + 1, limit, p );
        }
        move_piece( l, space, p );
      }
    }
  }
}
</pre>
<p> 関数 get_lower_value は盤面 board の下限値を求めます。下限値の計算はコーナーにある黒駒を数えて 2 倍するだけです。あとは、関数 solve_id で get_lower_value を呼び出して、「手数＋下限値」が上限値 limit 以下であれば solve_id を再帰呼び出しします。プログラムの修正はこれだけです。とても簡単ですね。
</p>

<p> さっそく実行してみたところ、実行時間は約 6.5 秒まで短縮できました。簡単な方法で下限値を求めましたが、その効果は絶大ですね。M.Hiroi もちょっと驚きました。
</p>
<hr>
<h4>●斜め跳びを許可した場合</h4>
<p> 次は、斜め跳びを許可した場合の最短手順を「反復深化＋下限値枝刈り法」で求めてみましょう。プログラムは直線の定義 (line) と駒の跳び先表 (move_pattern_table) を変更するだけです。次のリストを見てください。
</p>

<pre class="list">
リスト：直線と跳び先表の変更

/* 直線 */
const char line[LINE][4] = {
  0, 1,  2,  3,   4, 5,  6,  7,   8,  9, 10, 11,  12, 13, 14, 15,  
  0, 4,  8, 12,   1, 5,  9, 13,   2,  6, 10, 14,   3,  7, 11, 15,  
  0, 5, 10, 15,   1, 6, 11, 99,   4,  9, 14, 99,  /* 追加 */  
  3, 6,  9, 12,   2, 5,  8, 99,   7, 10, 13, 99,  /* 追加 */  
};

/* 移動パターン表 (ライン番号と位置）*/
const char move_pattern_table[][SIZE] = {
  {0, 2, 0, 3, 4, 8, 4, 12, 8, 10, 8, 15, -1},   /* 0 */
  {0, 3, 5, 9, 5, 13, 9, 11, -1},                /* 1 */
  {0, 0, 6, 10, 6, 14, 12, 8, -1},               /* 2 */
  {0, 0, 0, 1, 7, 11, 7, 15, 11, 9, 11, 12, -1}, /* 3 */
  {1, 6, 1, 7, 4, 12, 10, 14, -1},               /* 4 */
  {1, 7, 5, 13, 8, 15, -1},                      /* 5 */
  {1, 4, 6, 14, 11, 12, -1},                     /* 6 */
  {1, 4, 1, 5, 7, 15, 13, 13, -1},               /* 7 */
  {2, 10, 2, 11, 4, 0, 12, 2, -1},               /* 8 */
  {2, 11, 5, 1, 11, 3, -1},                      /* 9 */
  {2, 8, 6, 2, 8, 0, -1},                        /* 10 */
  {2, 8, 2, 9, 7, 3, 9, 1, -1},                  /* 11 */
  {3, 14, 3, 15, 4, 0, 4, 4, 11, 3, 11, 6, -1},  /* 12 */
  {3, 15, 5, 1, 5, 5, 13, 7, -1},                /* 13 */
  {3, 12, 6, 2, 6, 6, 10, 4, -1},                /* 14 */
  {3, 12, 3, 13, 7, 3, 7, 7, 8, 0, 8, 5, -1},    /* 15 */
};
</pre>
<p> 配列 line に斜めの直線を 6 本追加します。99 はダミーデータです。そして、追加した直線に対する駒の移動先を move_pattern_table に追加します。たとえば、空き場所が 0 の場合、直線 8 の移動先の位置 (10 と 15) を追加します。このように、斜め跳びを許すと移動できる駒の個数が増えるので、探索する局面数は大幅に増加することになります。単純な反復深化ではめちゃくちゃ時間がかかるでしょう。ご注意くださいませ。
</p>

<p> あとのプログラムは単純な「反復深化＋下限値枝刈り法」です。難しいところはないので説明は割愛いたします。詳細は <a name="list_id_low" href="flip_sq.html#src_id_low">プログラムリスト２</a> をお読みくださいませ。
</p>

<h4>●実行結果</h4>
<p> さっそく実行してみたところ、最短手順は次のようになりました。図では黒石を 1, 白石を 2, 空き場所を 0 で表しています。
</p>
<pre class="fig">
  1 1 1 1
  1 0 1 1
  1 1 1 1
  1 1 1 1

  - 1 ---   - 2 ---   - 3 ---   - 4 ---   - 5 ---   - 6 ---  
  1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1   1 1 0 1   1 1 1 1  
  1 1 2 0   1 1 2 1   1 1 2 1   1 1 2 1   1 1 1 1   1 2 1 1  
  1 1 1 1   1 1 1 2   1 1 1 2   1 1 1 2   1 1 2 2   0 1 2 2  
  1 1 1 1   1 1 1 0   0 2 2 1   2 1 0 1   2 1 1 1   2 1 1 1  

  - 7 ---   - 8 ---   - 9 ---   - 10 --   - 11 --   - 12 --  
  0 1 1 1   1 2 2 0   1 2 2 2   1 2 2 2   0 2 2 2   2 2 2 2  
  2 2 1 1   2 2 1 1   2 2 1 2   2 2 1 2   1 2 1 2   2 2 1 2  
  1 1 2 2   1 1 2 2   1 1 2 0   0 2 1 1   1 2 1 1   2 2 1 1  
  2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   2 1 1 1   0 1 1 1  

  - 13 --   - 14 --   - 15 --   - 16 --   - 17 --   - 18 --  
  2 2 2 2   2 2 2 2   2 2 2 2   2 2 2 2   0 2 2 2   2 2 2 2  
  2 2 1 2   2 2 1 0   0 1 2 2   1 1 2 2   2 1 2 2   2 2 2 2  
  2 2 1 1   2 2 1 2   2 2 1 2   1 2 1 2   2 2 1 2   2 2 2 2  
  1 2 2 0   1 2 2 2   1 2 2 2   0 2 2 2   2 2 2 2   2 2 2 0  

          図：「フリップ・イット・スクエア」の解答
</pre>

<p> 最短手数は 18 手、斜め跳びを許した方が短い手数で解けるようです。実は、これが斜め跳びを許可した場合の最長手数になります。実行時間は M.Hiroi のオンボロマシン (Pentium 166 MHz) で約 38 秒でした。下限値の精度が低いので、「反復深化＋下限値枝刈り法」でも時間がかかりますね。「幅優先探索」を使えばもっと速くなるでしょう。
</p>

<p> ちなみに、斜め跳びを許した場合の最長手数の局面は、対称解を除くと次の 4 通りになります。
</p>

<pre class="fig">
  1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1  
  1 0 1 1   1 0 1 1   1 0 2 1   1 0 2 1  
  1 1 2 1   1 1 1 1   1 1 1 1   1 2 2 1  
  1 1 1 1   1 1 1 1   1 1 1 1   1 1 1 1  

図：「フリップ・イット・スクエア」最長手数の局面
</pre>
<p> 最長手数の局面は「幅優先探索」で簡単に求めることができます。興味のある方はプログラムを作ってみてください。
</p>
<hr>
<h4 id="src_id">●プログラムリスト１</h4>
<pre class="list">
/*
 * flip_square.c : フリップ・イット・スクエア
 *
 *             Copyright (C) 2002 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE      1
#define FALSE     0
#define SIZE     16
#define LINE      8
#define MAX_MOVE 30

/* 駒の定義 */
#define S 0
#define B 1
#define W 2

/* 直線 */
const char line[LINE][4] = {
  0, 1, 2,  3,   4, 5, 6,  7,   8, 9, 10, 11,  12, 13, 14, 15,
  0, 4, 8, 12,   1, 5, 9, 13,   2, 6, 10, 14,   3,  7, 11, 15,
};

/* 駒の跳び先表 (直線の番号と駒の位置）*/
const char move_pattern_table[][SIZE] = {
  {0, 2, 0, 3, 4, 8, 4, 12, -1},   /* 0 */
  {0, 3, 5, 9, 5, 13, -1},         /* 1 */
  {0, 0, 6, 10, 6, 14, -1},        /* 2 */
  {0, 0, 0, 1, 7, 11, 7, 15, -1},  /* 3 */
  {1, 6, 1, 7, 4, 12, -1},         /* 4 */
  {1, 7, 5, 13, -1},               /* 5 */
  {1, 4, 6, 14, -1},               /* 6 */
  {1, 4, 1, 5, 7, 15, -1},         /* 7 */
  {2, 10, 2, 11, 4, 0, -1},        /* 8 */
  {2, 11, 5, 1, -1},               /* 9 */
  {2, 8, 6, 2, -1},                /* 10 */
  {2, 8, 2, 9, 7, 3, -1},          /* 11 */
  {3, 14, 3, 15, 4, 0, 4, 4, -1},  /* 12 */
  {3, 15, 5, 1, 5, 5, -1},         /* 13 */
  {3, 12, 6, 2, 6, 6, -1},         /* 14 */
  {3, 12, 3, 13, 7, 3, 7, 7, -1},  /* 15 */
};

/* 盤面 */
char board[SIZE];

/* 移動手順 */
int line_number[MAX_MOVE + 1];
int space_position[MAX_MOVE + 1];
int piece_position[MAX_MOVE + 1];

/* 計測用 */
int start;

/* 駒を動かして新しい盤面を作る */
void move_piece( int l, int p1, int p2 )
{
  int i, temp;
  /* p1 と p2 の駒を交換 */
  temp = board[p1];
  board[p1] = board[p2];
  board[p2] = temp;
  /* 順番のチェック */
  if( p2 &lt; p1 ){
    temp = p1;
    p1 = p2;
    p2 = temp;
  }
  /* 駒の裏返し */
  for( i = 0; i &lt; 4; i++ ){
    int p3 = line[l][i];
    if( p1 &lt; p3 &amp;&amp; p3 &lt; p2 ){
      board[p3] = (board[p3] == B ? W : B);
    }
  }
}

/* 盤面を表示 */
void print_board( void )
{
  int i, j, k;
  for( k = i = 0; i &lt; 4; i++ ){
    for( j = 0; j &lt; 4; j++ ) printf(" %d", board[k++] );
    printf("\n");
  }
}

/* 手順を表示 */
void print_answer( int n )
{
  if( n &gt; 0 ){
    move_piece( line_number[n], space_position[n], piece_position[n] );
    print_answer( n - 1 );
    move_piece( line_number[n], space_position[n], piece_position[n] );
  }
  printf("----- %d 手 -----\n", n );
  print_board();
}

/* piece の個数をカウント */
int count_piece( int piece )
{
  int i, c = 0;
  for( i = 0; i &lt; SIZE; i++ ){
    if( board[i] == piece ) c++;
  }
  return c;
}

/* 反復深化による探索 */
void solve_id( int n, int limit, int space )
{
  if( n == limit ){
    if( !count_piece( B ) ){
      print_answer( n );
      printf("時間 %d\n", clock() - start );
      exit( 1 );
    }
  } else {
    int i, l, p;
    for( i = 0; (l = move_pattern_table[space][i++]) != -1; ){
      p = move_pattern_table[space][i++];
      if( l != line_number[n] || p != space_position[n] ){
        /* 移動可能 */
        move_piece( l, space, p );
        piece_position[n + 1] = p;
        space_position[n + 1] = space;
        line_number[n + 1] = l;
        solve_id( n + 1, limit, p );
        /* 元に戻す */
        move_piece( l, space, p );
      }
    }
  }
}

int main()
{
  int i, space = 5;
  /* 初期化 */
  for( i = 0; i &lt; SIZE; i++ ) board[i] = B;
  board[space] = S;
  piece_position[0] = -1;
  space_position[0] = -1;
  line_number[0] = -1;

  /* 探索 */
  start = clock();
  for( i = 1; i &lt;= MAX_MOVE ; i++ ){
    printf("----- %d 手を探索 -----\n", i );
    solve_id( 0, i, space );
  }
  return 0;
}
</pre>
<p><a href="flip_sq.html#list_id">戻る</a>
</p>
<hr>
<h4 id="src_id_low">●プログラムリスト２</h4>
<pre class="list">
/*
 * flip_square1.c : フリップ・イット・スクエア
 *                  斜め跳びを許す場合
 *
 *             Copyright (C) 2002 Makoto Hiroi
 *
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE      1
#define FALSE     0
#define SIZE     16
#define LINE     14
#define MAX_MOVE 30

/* 駒の定義 */
#define S 0
#define B 1
#define W 2

/* 直線 */
const char line[LINE][4] = {
  0, 1,  2,  3,   4, 5,  6,  7,   8,  9, 10, 11,  12, 13, 14, 15,
  0, 4,  8, 12,   1, 5,  9, 13,   2,  6, 10, 14,   3,  7, 11, 15,
  0, 5, 10, 15,   1, 6, 11, 99,   4,  9, 14, 99,  /* 追加１ */
  3, 6,  9, 12,   2, 5,  8, 99,   7, 10, 13, 99,  /* 追加２ */
};

/* 移動パターン表 (ライン番号と位置）*/
const char move_pattern_table[][SIZE] = {
  {0, 2, 0, 3, 4, 8, 4, 12, 8, 10, 8, 15, -1},   /* 0 */
  {0, 3, 5, 9, 5, 13, 9, 11, -1},                /* 1 */
  {0, 0, 6, 10, 6, 14, 12, 8, -1},               /* 2 */
  {0, 0, 0, 1, 7, 11, 7, 15, 11, 9, 11, 12, -1}, /* 3 */
  {1, 6, 1, 7, 4, 12, 10, 14, -1},               /* 4 */
  {1, 7, 5, 13, 8, 15, -1},                      /* 5 */
  {1, 4, 6, 14, 11, 12, -1},                     /* 6 */
  {1, 4, 1, 5, 7, 15, 13, 13, -1},               /* 7 */
  {2, 10, 2, 11, 4, 0, 12, 2, -1},               /* 8 */
  {2, 11, 5, 1, 11, 3, -1},                      /* 9 */
  {2, 8, 6, 2, 8, 0, -1},                        /* 10 */
  {2, 8, 2, 9, 7, 3, 9, 1, -1},                  /* 11 */
  {3, 14, 3, 15, 4, 0, 4, 4, 11, 3, 11, 6, -1},  /* 12 */
  {3, 15, 5, 1, 5, 5, 13, 7, -1},                /* 13 */
  {3, 12, 6, 2, 6, 6, 10, 4, -1},                /* 14 */
  {3, 12, 3, 13, 7, 3, 7, 7, 8, 0, 8, 5, -1},    /* 15 */
};

/* 盤面 */
char board[SIZE];

/* 移動手順 */
int line_number[MAX_MOVE + 1];
int space_position[MAX_MOVE + 1];
int piece_position[MAX_MOVE + 1];

/* 計測用 */
int start;

/* 下限値を求める */
int get_lower_value( void )
{
  int c = 0;
  if( board[0] == B ) c++;
  if( board[3] == B ) c++;
  if( board[12] == B ) c++;
  if( board[15] == B ) c++;
  return c * 2;
}

/* 駒を動かして新しい盤面を作る */
void move_piece( int l, int p1, int p2 )
{
  int i, temp;
  /* p1 と p2 の駒を交換 */
  temp = board[p1];
  board[p1] = board[p2];
  board[p2] = temp;
  /* 順番のチェック */
  if( p2 &lt; p1 ){
    temp = p1;
    p1 = p2;
    p2 = temp;
  }
  /* 駒の裏返し */
  for( i = 0; i &lt; 4; i++ ){
    int p3 = line[l][i];
    if( p1 &lt; p3 &amp;&amp; p3 &lt; p2 ){
      board[p3] = (board[p3] == B ? W : B);
    }
  }
}

/* 盤面を表示 */
void print_board( void )
{
  int i, j, k;
  for( k = i = 0; i &lt; 4; i++ ){
    for( j = 0; j &lt; 4; j++ ) printf(" %d", board[k++] );
    printf("\n");
  }
}

/* 手順を表示 */
void print_answer( int n )
{
  if( n &gt; 0 ){
    move_piece( line_number[n], space_position[n], piece_position[n] );
    print_answer( n - 1 );
    move_piece( line_number[n], space_position[n], piece_position[n] );
  }
  printf("----- %d 手 -----\n", n );
  print_board();
}

/* piece の個数をカウント */
int count_piece( int piece )
{
  int i, c = 0;
  for( i = 0; i &lt; SIZE; i++ ){
    if( board[i] == piece ) c++;
  }
  return c;
}

/* 反復深化による探索 */
void solve_id( int n, int limit, int space )
{
  if( n == limit ){
    if( !count_piece( B ) ){
      print_answer( n );
      printf("時間 %d\n", clock() - start );
      exit( 1 );
    }
  } else {
    int i, l, p;
    for( i = 0; (l = move_pattern_table[space][i++]) != -1; ){
      p = move_pattern_table[space][i++];
      if( l != line_number[n] || p != space_position[n] ){
        move_piece( l, space, p );
        piece_position[n + 1] = p;
        space_position[n + 1] = space;
        line_number[n + 1] = l;
        /* 下限値枝刈り法 */
        if( n + 1 + get_lower_value() &lt;= limit ){
          solve_id( n + 1, limit, p );
        }
        move_piece( l, space, p );
      }
    }
  }
}

int main()
{
  int i, space = 5;
  /* 初期化 */
  for( i = 0; i &lt; SIZE; i++ ) board[i] = B;
  board[space] = S;
  piece_position[0] = -1;
  space_position[0] = -1;
  line_number[0] = -1;

  /* 探索 */
  start = clock();
  for( i = get_lower_value(); i &lt;= MAX_MOVE ; i++ ){
    printf("----- %d 手を探索 -----\n", i );
    solve_id( 0, i, space );
  }
  return 0;
}
</pre>
<p><a href="flip_sq.html#list_id_low">戻る</a>
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2002-2003 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>