<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>パズルでプログラミング</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881775</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>パズルでプログラミング</h1>
<h2>第 2 回 幅優先探索と 15 パズル（後編）</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> | <a href="puzdoc03.html">PrevPage</a> | <a href="puzdoc05.html">NextPage</a> ]
<hr>
</div>
<section class="contents">
<h3 id="chap5">●パズル「おしどりの遊び」</h3>
<p> それでは実際にパズルを解いてみましょう。まずはウオーミングアップとして、石を並べ替える「おしどりの遊び」という古典的なパズルを取り上げます。このパズルは囲碁の白石と黒石を交互に並べ、それをペアで動かしながら黒石と白石とに分けるというもので、<a href="index.html#cite">文献 [4]</a> によると江戸時代からある遊びだそうです。
</p>

<pre class="fig">
┌─┬─┬─┬─┬─┬─┬─┬─┐
│黒│白│黒│白│黒│白│  │  │  初期状態  
└─┴─┴─┴─┴─┴─┴─┴─┘

┌─┬─┬─┬─┬─┬─┬─┬─┐
│黒│黒│黒│白│白│白│  │  │  ゴール
└─┴─┴─┴─┴─┴─┴─┴─┘

        図 8 : おしどりの遊び
</pre>

<p> 石はペアで空いている場所に動かすことができます。このときペアの順番を変えることはできません。たとえば、先頭にある黒白を動かすときに、白黒というように石の順番を逆にすることは許されません。この条件で並べ替えるまでの最短手順を求めます。
</p>

<p> 盤面は配列で表すことにします。黒石、白石、空き場所をそれぞれマクロで B, W, S と定義します。
</p>
<pre class="list">
/* 種別の設定 */
#define S 0
#define B 1
#define W 2
</pre>
<p> そうすると移動できる石は、連続した 2 つの場所の値が真であること、で判定することができます。具体的には、次のようなプログラムで移動できるすべての石をチェックすることができます。
</p>

<pre class="list">
int i;
for( i = 0; i &lt; SIZE - 1; i++ ){
  if( state[i] &amp;&amp; state[i + 1] ){
    /* 駒を移動できる */
  }
}
</pre>

<p> 盤面の状態（局面）を表す配列を state とし、SIZE は配列の大きさを表すマクロです。石はペアで動かすので、変数 i の範囲は 0 から 6 までということに注意してください。7 までにすると配列の範囲をオーバーしてしまいます。
</p>

<p> 今度は移動手順の管理を考えましょう。最短手順を求めるだけならば、すべての手順を記憶しておく必要はありません。n 手目の移動で作られた局面が、n 手目以前の局面で出現しているのであれば、n 手より短い手数で到達する移動手順があるはずです。したがって、この n 手の手順を記憶しておく必要はないのです。そこで、キューには局面だけを格納し、手順は番号で管理することにします。
</p>

<table border=1>
<thead>
  <tr><th>図 9 : 手順の管理</th></tr>
</thead>
<tbody>
<tr><td>
<table border=1>
<thead>
  <tr><th></th><th>state</th><th>prev_state</th>
</thead>
<tbody>
  <tr><td>0</td><td>B W B W B W S S</td><td>-1</td></tr>
  <tr><td>1</td><td>S S B W B W B W</td><td> 0</td></tr>
  <tr><td>2</td><td>B S S W B W W B</td><td> 0</td></tr>
  <tr><td>3</td><td>B W S S B W B W</td><td> 0</td></tr>
  <tr><td>4</td><td>B W B S S W W B</td><td> 0</td></tr>
  <tr><td>5</td><td>B W B W S S B W</td><td> 0</td></tr>
  <tr><td>6</td><td>W B B S S W B W</td><td> 1</td></tr>
  <tr><td>7</td><td>W B B W B S S W</td><td> 1</td></tr>
</tbody>
</table>
</td></tr>
</tbody>
</table>

<p> 図 9 を使って具体的に説明しましょう。局面は配列 state に格納します。このときの添字が、その局面の番号になります。そして、その 1 手前の局面の番号を配列 prev_state に格納します。まず最初の配置を state[0] にセットします。prev_state[0] には終端を表すため -1 をセットします。次に、石を移動して 1 手目の局面を生成します。移動できる石のペアは 5 種類あるので、新しく生成される局面は 5 つとなります。それぞれ、state[1] から state[5] にセットし、prev_state には元になった局面 state[0] の番号 0 をセットします。
</p>

<p> 次に、2 手目の局面を生成します。state[1] で石を動かして生成される局面は 5 つありますが、そのうち 3 つはいままで出現した局面と同じになるので、新しい局面は 2 つとなります。これを state[6] と state[7] にセットします。このときの prev_state には、元になった局面 state[1] の番号 1 がセットされます。あとは同様に、キューから局面を取り出して石を動かし、新しい局面であればキューに登録することを繰り返します。最終状態と同じ局面になったときは、prev_state をたどることで手順を再現することができます。
</p>

<h3 id="chap6">●おしどりの遊びを解く</h3>
<p> それではプログラムを作ります。最初に、キューの大きさを決めるため石の置き方が何通りあるか数えましょう。これは空き場所の配置から考えた方が簡単です。2 つの空き場所は離ればなれにならないのですから、7 通りの配置が考えられます。次に、残り 6 ヵ所に 3 個の黒石を置くことを考えます。これは 6 個の中から 3 個を選ぶ組み合わせと考えられるので、組み合わせの公式から (6 * 5 * 4) / (1 * 2 * 3) = 20 通りあります。黒石の置き方が決まれば、白石は残りの 3 ヵ所に置くだけです。したがって、全体では 20 * 7 = 140 通りになるので、キューの大きさは 140 に設定します。キューの構成は次のようになります。
</p>
<pre class="list">
/* キュー */
#define MAX_STATE 140
char  state[MAX_STATE + 1][SIZE];   /* +1 は ワーク領域 */
char  space_position[MAX_STATE];
short prev_state[MAX_STATE];
</pre>

<p> 配列 state は石を動かすときにワーク領域としても使うので、大きさをひとつ余分に設定します。石を動かすには空き場所の位置を求めなければいけません。配列 state を探索してもいいのですが、あらかじめ配列 space_position に空き場所の位置をセットしておけば、簡単に求めることができます。石の移動は次のようになります。
</p>

<pre class="list">
リスト : 石の移動

void move_stone( int front, int rear, int dest )
{
  int j = space_position[front];
  memcpy( state[rear], state[front], SIZE );
  state[rear][j] = state[front][dest];
  state[rear][j + 1] = state[front][dest + 1];
  state[rear][dest] = S;
  state[rear][dest + 1] = S;
  space_position[rear] = dest;
  prev_state[rear] = front;
}
</pre>

<p> 引数 dest は移動する石の位置を表します。space_position から空き場所の位置を求め変数 j にセットします。dest と dest + 1 にある石を、j と j + 1 へ移動し、dest と dest + 1 には空き場所を表す S をセットすれば、石を移動することができます。石を動かすときは、state[front] を state[rear] にコピーしてから行います。これは経路の場合と同じですね。最後に、空き場所の位置を space_position に、front を prev_state に値を書き込みます。
</p>

<p> 探索を行う関数 search は次のようになります。
</p>

<pre class="list">
リスト : おしどりの遊び

/* 初期状態 */
const char initial_state[SIZE] = {
  B, W, B, W, B, W, S, S
};
/* ゴール */
const char final_state[SIZE] = {
  B, B, B, W, W, W, S, S
};

/* 探索関数 */
void search( void )
{
  int front = 0, rear = 1;
  memcpy( state[0], initial_state, SIZE );
  prev_state[0] = -1;
  space_position[0] = 6;
  while( front &lt; rear ){
    int i;
    for( i = 0; i &lt; SIZE - 1; i++ ){
      if( state[front][i] &amp;&amp; state[front][i + 1] ){
        move_stone( rear, front, i );
        if( !memcmp( state[rear], final_state, SIZE ) ){
          print_answer( rear );
          return;
        } else if( !check_same_state( rear ) ){
          rear++;
        }
      }
    }
    front++;
  }
}
</pre>

<p> プログラムの骨格は経路の探索と同じです。move_stone で石を動かしたら、ゴールに到達したかチェックします。state[rear] が配列 final_state と同じであれば、解を見つけることができました。print_answer で最短手順を表示します。そうでなければ、同一の局面がないか check_same_state でチェックします。新しい局面であれば rear の値をインクリメントして、新しい局面をキューに追加します。move_stone で state[rear] にデータをコピーしていますが、rear の値を更新しない限りキューにデータは追加されません。
</p>

<p> 同一局面のチェックを行う関数 check_same_state は簡単です。
</p>

<pre class="list">
リスト : 同じ状態をチェックする

int check_same_state( int n )
{
  int i;
  for( i = 0; i &lt; n; i++ ){
    if( !memcmp( state[i], state[n], SIZE ) ) return TRUE;
  }
  return FALSE;
}
</pre>

<p> 配列 state を先頭から順番にチェックしていきます。これを「線形探索」といいます。このプログラムは次のように書き換えると、ループ中での変数 i の範囲チェックを省略することができます。
</p>

<pre class="list">
リスト : 番人を使う方法

int check_same_state( int n )
{
  int i = 0;
  while( memcmp( state[i], state[n], SIZE ) ) i++;
  return (i != n) ? TRUE : FALSE;
}
</pre>

<p> 検索するデータの最後にはキーデータ state[n] があるので、検索は必ず成功します。発見したデータの位置が n と等しければ、キーデータを見つけたことがわかるので、検索は失敗となります。そうでなければ検索は成功です。キーデータ自身で、検索ポイントがデータの範囲を飛び出さないように監視するわけです。このような方法を「番人」とか「番兵」と呼びます。まあ、最近のように高速 CPU を使った環境では、速度の差はほとんどありませんが、番人を使った方が簡単にプログラムできるアルゴリズムもあるので、覚えておいて損はありません。
</p>

<p> 最後に手順を表示する print_answer を作ります。
</p>

<pre class="list">
リスト : 手順の表示

void print_answer( int n )
{
  int i;
  if( n != 0 ) print_answer( prev_state[n] );
  for( i = 0; i &lt; SIZE; i++ ){
    switch( state[n][i] ){
    case S: printf("空 "); break;
    case B: printf("黒 "); break;
    case W: printf("白 "); break;
    }
  }
  printf("\n");
}
</pre>

<p> prev_state を順番にたどって出力すると、手順は逆順に表示されてしまいます。そこで、再帰呼び出しを使って最初の状態に戻り、そこから局面を順番に出力させます。
</p>

<p> 実行結果は次のようになります。
</p>
<pre class="fig">
<font color="black">黒</font> <font color="blue">白</font> <font color="black">黒</font> <font color="blue">白</font> <font color="black">黒</font> <font color="blue">白</font> <font color="red">空 空</font>
<font color="black">黒</font> <font color="blue">白</font> <font color="black">黒</font> <font color="red">空 空</font> <font color="blue">白 白</font> <font color="black">黒</font>
<font color="black">黒</font> <font color="blue">白</font> <font color="black">黒</font> <font color="blue">白 白</font> <font color="red">空 空</font> <font color="black">黒</font>
<font color="black">黒</font> <font color="red">空 空</font> <font color="blue">白 白 白</font> <font color="black">黒 黒</font>
<font color="black">黒 黒 黒</font> <font color="blue">白 白 白</font> <font color="red">空 空</font>
</pre>
<p> 4 手で解くことができました。このとき、生成した局面の総数は 64 個でした。ちなみに、黒と白の分け方を逆にした「白白白黒黒黒空空」も、4 手で解くことができます。プログラムは簡単に改造できますが、その前に自分で解いてみるのも面白いでしょう。
</p>
<ul>
  <li><a href="puz04_c.html">プログラムを読む</a>
</ul>
<h3 id="chap7">●６パズル</h3>
<p> 次は 15 パズルでお馴染みの、スライディングブロックと呼ばれるパズルを解いてみましょう。<a href="index.html#cite">文献 [4]</a> によると、15 パズルはアメリカのサム・ロイドが 1870 年代に考案したパズルで、彼はパズルの神様と呼ばれるほど有名なパズル作家だそうです。
</p>

<pre class="fig">
  ┌─┬─┬─┬─┐  
  │１│２│３│４│
  ├─┼─┼─┼─┤
  │５│６│７│８│
  ├─┼─┼─┼─┤
  │９│10│11│12│
  ├─┼─┼─┼─┤
  │13│14│15│  │
  └─┴─┴─┴─┘

  図 10 : 15 パズル
</pre>

<p> 15 パズルは図 10 に示すように、1 から 15 までの駒を並べるパズルです。駒の動かし方は、1 回に 1 個の駒を空いている隣の場所に滑らせる、というものです。駒を飛び越したり持ち上げたりすることはできません。
</p>
<p> 15 パズルの場合、駒の配置は空き場所がどこでもいいことにすると、16! (約 2e13) 通りもあります。実際には、15 パズルの性質からその半分になるのですが、それでもパソコンで扱うにはあまりにも大きすぎる数です。そこで、盤面を六角形に変形し、1 から 6 までの数字を並べる「6 パズル」を考えることにします。
</p>

<pre class="fig">
     １------５                    １------２
   ／  ＼  ／  ＼                ／  ＼  ／  ＼
 ２------６------３    ===&gt;    ３------４------５ 
   ＼  ／  ＼  ／                ＼  ／  ＼  ／ 
     ４------０                    ６------０

                                     完成形

                図 11 : 6 パズル
</pre>

<p> 図 11 は 6 パズルをグラフで表したものです。0 が空き場所を表します。ここには 3, 4, 6 の駒を動かすことができます。6 パズルは単純に考えると駒の配置は 7! = 5040 通りとなります。これならば簡単に解くことができそうです。
</p>

<p> 6 パズルの盤面は配列を使って表します。位置と配列の関係は図 12 を見てください。
</p>

<pre class="fig">
      ０------１
    ／  ＼  ／  ＼
  ２------３------４
    ＼  ／  ＼  ／ 
      ５------６

図 12 : 6 パズルの位置
</pre>
<p> 隣接リストとキューの定義は、次のようになります。
</p>

<pre class="list">
リスト : 隣接リストとキューの定義

/* 隣接リスト */
#define SIZE  7
const char adjacent[SIZE][7] = {
  1, 2, 3, -1, -1, -1, -1,  /* 0 */
  0, 3, 4, -1, -1, -1, -1,  /* 1 */
  0, 3, 5, -1, -1, -1, -1,  /* 2 */
  0, 1, 2,  4,  5,  6, -1,  /* 3 */
  1, 3, 6, -1, -1, -1, -1,  /* 4 */
  2, 3, 6, -1, -1, -1, -1,  /* 5 */
  3, 4, 5, -1, -1, -1, -1   /* 6 */
};

/* キュー */
#define MAX_STATE 5040
char  state[MAX_STATE + 1][SIZE];   /* +1 はワーク領域 */
char  space_position[MAX_STATE];
short prev_state[MAX_STATE];
</pre>

<p> 手順の管理は「おしどりの遊び」と同じです。駒の移動は、動かすことができる駒を探すよりも、空き場所を基準に考えた方が簡単です。その局面での空き場所の位置を配列 space_position に記憶しておきます。新しい局面を作るときは、空き場所に隣接している駒を隣接リストから求め、それを空き場所に移動させればいいわけです。
</p>

<p> それではプログラムを作ります。
</p>

<pre class="list">
リスト : 6 パズルの解法(1)

/* 初期状態 */
char init_state[SIZE] = {
  1, 5, 2, 6, 3, 4, 0
};

/* 最終状態 */
char final_state[SIZE] = {
  1, 2, 3, 4, 5, 6, 0
};

/* 探索 */
void search( void )
{
  int front = 0, rear = 1;
  memcpy( state[0], init_state, SIZE );
  space_position[0] = 6;
  prev_state[0] = -1;
  while( front &lt; rear ){
    int n, i, s = space_position[front];
    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){
      memcpy( state[rear], state[front], SIZE );
      state[rear][s] = state[rear][n];
      state[rear][n] = 0;
      space_position[rear] = n;
      prev_state[rear] = front;
      if( !memcmp( state[rear], final_state, SIZE ) ){
        print_answer( rear );
        return;
      } else if( !check_same_state( rear ) ){
        rear++;
      }
    }
    front++;
  }
}
</pre>

<p> プログラムの骨格は前の 2 つと同じなので、詳しく説明しなくてもいいでしょう。同一局面のチェックを行う check_same_state は単純な線形探索です。手順を出力する print_answer は、配列の内容をそのまま出力するだけです。六角形に出力するなど、工夫してみてください。
</p>

<p> 実際に実行すると (<a name="hex1" href="puz04_c.html#hex1">ソースファイル hex1.c</a>)、11 手で解くことができました。このときの実行時間は約 3.2 秒 (Pentium 166 MHz) もかかっています。簡単に解けると思っていたのですが、けっこう時間がかかりますね。
</p>

<p> 時間がかかる理由のひとつは、同一局面のチェックを行う check_same_state にあります。線形探索は配列の先頭から順番にデータを比較していくため、その実行時間はデータ数に比例します。今回生成された局面は 2818 個だったのですが、ひとつの局面から複数の局面を生成し、それを検索するのですから、データの比較回数は相当の数になるでしょう。実際に数えてみると 7,598,140 回にもなります。これでは時間がかかるのも当然ですね。
</p>

<h3 id="chap8">●６パズルの高速化</h3>
<p> このようなときの常套手段が、線形探索に代えて高速な検索アルゴリズムを使うことです。ハッシュ法や二分探索木など、優れたアルゴリズムを使うことで、実行時間を大幅に短縮することができます。ですが、いきなり使ってみましょう、といわれても困ってしまいますね。そこで、ほかの方法を採用することにします。幅優先探索の場合、出発点から探索するだけではなく、ゴール地点からも探索を行うことで、探索する局面数を減らすことができるのです。
</p>

<p> その理由を説明するために、簡単なシミュレーションをしてみましょう。たとえば、1 手進むたびに 3 つの局面が生成され、5 手で解けると仮定します。すると、n 手目で生成される局面は 3 の n 乗個になるので、初期状態から単純に探索すると、生成される局面の総数は、3 + 9 + 27 + 81 + 243 = 363 個となります。
</p>

<p> これに対し、初期状態と終了状態から同時に探索を始めた場合、お互い 3 手まで探索した時点で同じ局面に到達する、つまり、解を見つけることができます。この場合、生成される局面の総数は 3 手目までの局面数を 2 倍した 78 個となります。
</p>
<p> 生成される局面数はぐっと減りますね。局面数が少なくなると、同一局面の検索処理に有利なだけではなく、キューからデータを取り出して新しい局面を作るという根本的な処理のループ回数を減らすことになるので、処理速度は大幅に向上するのです。
</p>

<p> それではプログラムを改造しましょう。単純に考えると、2 つの探索処理を交互に行うことになりますが、そうするとプログラムの大幅な改造が必要になります。ここは、探索方向を示すフラグを用意することで、ひとつのキューだけで処理することにしましょう。メモリを余分に使うことになりますが、プログラムの改造は最小限で済みます。
</p>
<pre class="list">
/* 探索方向を格納する */
#define FORWARD  0
#define BACKWARD 1 
char    direction[MAX_STATE];
</pre>

<p> 探索方向は配列 direction に格納します。初期状態からの探索は FORWARD を、終了状態からの探索は BACKWARD をセットします。探索プログラムは次のようになります
</p>

<pre class="list">
リスト : 6 パズルの解法(2)

void search( void )
{
  int front = 0, rear = 2;
  /* キューの初期化 */
  memcpy( state[0], init_state, SIZE );
  space_position[0] = 6;
  prev_state[0] = -1;
  direction[0] = FORWARD;
  memcpy( state[1], final_state, SIZE );
  space_position[1] = 6;
  prev_state[1] = -1;
  direction[1] = BACKWARD;

  while( front &lt; rear ){
    int s = space_position[front];
    int i, j, n;
    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){
      /* ・・・駒の移動・・・（省略） */

      direction[rear] = direction[front];
      if( (j = check_same_state( rear )) &gt;= 0 ){
        if( direction[j] != direction[rear] ){
          print_answer( j, rear );
          return;
        }
      } else {
        rear++;
      }
    }
    front++;
  }
}
</pre>

<p> キューの初期化では、最初に初期状態を、次に終了状態をセットします。2 つのデータをセットしたのですから、変数 rear の値は 2 に初期化することに注意してください。最初に、初期状態から 1 手目の局面が生成され、次に最終状態から 1 手目の局面が生成されます。あとは、交互に探索が行われます。
</p>

<p> 駒の移動は同じなので省略しますが、direction の値をコピーする処理を追加していることに注意してください。direction の値を比較するため、check_same_state は見つけた局面の番号を返すように改造します。見つからない場合は -1 を返すことにします。同じ局面を見つけたとき、direction を比較して探索方向が異なっていれば、2 方向の探索で同一局面に到達したことがわかります。見つけた最短手順を print_answer で出力します。同じ探索方向であれば、キューへの追加は行いません。
</p>

<p> 手順の表示は探索方向によって処理が異なるので、print_answer で振り分けます。
</p>

<pre class="list">
リスト : 結果を出力

void print_answer( int i, int j )
{
  if( direction[i] == FORWARD ){
    print_answer_forward( i );
    print_answer_backward( j );
  } else {
    print_answer_forward( j );
    print_answer_backward( i );
  }
}
</pre>

<p> 初期状態からの手順を表示する関数が print_answer_forward です。この処理は、今までの print_answer と同じです。終了状態までの手順を表示するのが print_answer_backward です。これは prev_state を順番にたどって表示するだけなので、繰り返しで簡単にプログラムできます。これでプログラムの改造は終わりです。
</p>
<p> プログラム (<a name="hex2" href="puz04_c.html#hex2">ソースファイル hex2.c</a>) を実行してみると、生成された局面数は 342 個で、実行時間は約 60 [msec] でした。50 倍以上の高速化ですね。予想していた以上の効果に、筆者もたいへん驚きました。
</p>

<h3 id="chap9">●６パズルの最長手順は？</h3>
<p> さて、図 11 の配置は 11 手で解くことができましたが、5040 通りの配置の中では、これよりも短い手数で解けるものもあるでしょうし、もっと長い手数がかかるものもあるでしょう。そこで、今度は単純に解くのではなく、パズルが完成するまでにいちばん手数がかかる配置を求めることにします。つまり、最短手順で解いてもいちばん長い手順となる、いちばん難しい配置を求めるわけです。
</p>

<p> この場合、5040 通りの配置からその最短手順を求めていき、そのなかから最長の手順となる配置を求めることもできますが、それでは時間がとてもかかりそうです。そこで、完成形から始めていちばん長い手数の局面を生成することにします。まず、完成形から駒を動かして 1 手で到達する局面をすべて作ります。次に、これらの局面から駒を動かして新しい局面を作れば、完成形から 2 手で到達する局面となります。このように、手数を 1 手ずつ伸ばしていき、新しい局面が生成できなくなった時点での手数が求める最長手数となります。この処理は幅優先探索を使えばぴったりです。ただし、初期状態からの探索しかできないので、同一局面のチェックが線形探索のままでは時間がかかる、ということは覚悟してください。
</p>

<p> このプログラムの目的は、いちばん難しい手順となる配置を求めることなので、手順を表示することは行いません。このため、ひとつ前の局面番号を格納する配列 prev_state は定義しません。その代わり、その局面までの手数を格納する配列 move を用意します。ひとつ前の局面の手数を move から求め、それに 1 を足せば現在の局面の手数となります。
</p>

<p> それではプログラムを作ります。
</p>

<pre class="list">
リスト : 最長手数を求める

void search( void )
{
  int front = 0, rear = 1;
  memcpy( state[0], init_state, SIZE );
  space_position[0] = 6;
  move[0] = 0;
  while( front &lt; rear ){
    int n, i, s = space_position[front];
    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){
      memcpy( state[rear], state[front], SIZE );
      state[rear][s] = state[rear][n];
      state[rear][n] = 0;
      space_position[rear] = n;
      move[rear] = move[front] + 1;
      if( !check_same_state( rear ) ){
        rear++;
      }
    }
    front++;
  }
  print_answer( rear );
}
</pre>
<p> 最終状態をチェックする処理がないことに注意してください。生成できる局面がなくなるまで、つまりキューにデータがなくなるまで処理を繰り返します。最後に print_answer で最長手数とその配置を出力します。この関数は簡単なので説明は省略します。これでプログラム（<a name="hex3" href="puz04_c.html#hex3">ソースファイル hex3.c</a>）は完成です。
</p>

<p> 実際に実行すると、最長手数は 15 手で、その配置は全部で 24 通りありました。そのうちのひとつを図 13 に示します。
</p>

<pre class="fig">
          ４------６
        ／  ＼  ／  ＼
      ５------１------３
        ＼  ／  ＼  ／ 
          ２------０

図 13 : いちばん難しい配置の例
</pre>

<p> ちなみに、生成した全局面は 5040 個ありました。しがたって、6 パズルでは数字をランダムに配置しても、必ず完成形に到達できることがわかります。実行時間ですが、予想したように約 16 秒と時間がかかっています。生成した局面が 5040 個もあるのですから、データの比較回数は相当の数になります。実際に数えてみると 43,454,059 回にもなります。実行時間の短縮には、高速な検索アルゴリズムを使う必要があります。
</p>

<h3 id="chap10">●次回は？</h3>
<p> 次回はパズルから離れて、高速なデータ検索方法の中から二分探索木を中心に説明します。木構造の基本から多分木まで、ねっとりと説明する予定です。6 パズルがどこまで速くなるか、お楽しみに。
</p>
<ul>
  <li><a href="puz04_c.html">プログラムを読む</a>
</ul>
<div align="right"><cite>
＜ Oh!X 2001 春号 p226 - p231（ソフトバンク）より転載 ＞
</cite></div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2002 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> | <a href="puzdoc03.html">PrevPage</a> | <a href="puzdoc05.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>