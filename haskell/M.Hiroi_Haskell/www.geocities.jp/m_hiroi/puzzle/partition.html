<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / 分割数</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>分割数</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>パズルの説明</h3>
<p> 整数 n を 1 以上の自然数の和で表すことを考えます。これを「整数の分割」といいます。整数を分割するとき、同じ自然数を何回使ってもかまいませんが、並べる順序が違うだけのものは同じ分割とします。簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
─┬─ 6                           : 6
  │
  ├─ 5 ─ 1                      : 5 + 1
  │
  ├─ 4 ┬ 2                      : 4 + 2
  │     │
  │     └ 1 ─ 1                 : 4 + 1 + 1
  │
  ├─ 3 ┬ 3                      : 3 + 3
  │     │
  │     ├ 2 ─ 1                 : 3 + 2 + 1
  │     │
  │     └ 1 ─ 1 ─ 1            : 3 + 1 + 1 + 1
  │
  ├─ 2 ┬ 2 ┬ 2                 : 2 + 2 + 2
  │     │   │
  │     │   └ 1 ─ 1            : 2 + 2 + 1 + 1
  │     │
  │     └ 1 ─ 1 ─ 1 ─ 1       : 2 + 1 + 1 + 1 + 1
  │
  └─ 1 ─ 1 ─ 1 ─ 1 ─ 1 ─ 1  : 1 + 1 + 1 + 1 + 1 + 1

                    図 : 整数 6 の分割
</pre>
<p> 6 の場合、分割の仕方は上図のように 11 通りあります。この数を「分割数」といいます。分割の仕方を列挙する場合、整数 n から k 以下の整数を選んでいくと考えてください。まず、6 から 6 を選びます。すると、残りは 0 になるので、これ以上整数を分割することはできません。次に、6 から 5 を選びます。残りは 1 になるので、1 を選ぶしか方法はありません。
</p>
<p> 次に、4 を選びます。残りは 2 になるので、2 から 2 以下の整数を分割する方法になります。2 から 2 を選ぶと残りは 0 になるので 2 が得られます。1 を選ぶと残りは 1 になるので、1 + 1 が得られます。したがって、4 + 2, 4 + 1 + 1 となります。同様に、6 から 3 を選ぶと、残りは 3 から 3 以下の整数を選ぶ方法になります。
</p>
<p> 6 から 2 以下の整数を選ぶ方法は、残り 4 から 2 以下の整数を選ぶ方法になり、そこで 2 を選ぶと 2 から 2 以下の整数を選ぶ方法になります。1 を選ぶと 4 から 1 以下の整数を選ぶ方法になりますが、これは 1 通りしかありません。最後に 6 から 1 を選びますが、これも 1 通りしかありません。これらをすべて足し合わせると 11 通りになります。
</p>
<p> それでは問題です。
</p>
<ol>
  <li> 分割数を求めるプログラムを作ってください。
  <li> 分割の仕方をすべて求めるプログラムを作ってください。
  <li> 整数を奇数のみで分割する場合を考えます。たとえば、6 を分割すると、5 + 1, 3 + 3, 3 + 1 + 1 + 1, 1 + 1 + 1 + 1 + 1 + 1 の 4 通りになります。この制限で分割数と分割の仕方を求めるプログラムを作ってください。
</ol>
<ul>
  <li><a href="partition.html#ans01">解答１</a>
  <li><a href="partition.html#ans02">解答２</a>
  <li><a href="partition.html#ans03">解答３</a>
</ul>
<hr>
<h4 id="ans01">●解答１</h4>
<p> 整数 n を k 以下の整数で分割する総数を求める関数を p(n, k) とすると、p(n, k) は次のように定義することができます。
</p>
<pre class="item">
p(n, k) = 1                          ; n = 0 または k = 1
p(n, k) = 0                          ; n &lt; 0 または k &lt; 1
p(n, k) = p(n - k, k) + p(n, k - 1)
</pre>
<p> たとえば、p(6, 6) は次のように計算することができます。
</p>
<pre class="fig">
p(6, 6) =&gt; p(0, 6) + p(6, 5)
        =&gt; 1 + p(1, 5) + p(6, 4)
        =&gt; 1 +    1    + p(2, 4) + p(6, 3)
        =&gt; 1 + 1 + 2 + 7
        =&gt; 11

p(2, 4) =&gt; p(-2, 4) + p(2, 3)
        =&gt;    0     + p(-1, 3) + p(2, 2)
        =&gt;    0     +    0     + p(0, 2) + p(2, 1)
        =&gt; 0 + 0 + 1 + 1
        =&gt; 2

p(6, 3) =&gt; p(3, 3) + p(6, 2)
        =&gt; p(0, 3) + p(3, 2) + p(4, 2) + p(6, 1)
        =&gt;    1    + p(1, 2) + p(3, 1) + p(2, 2) + p(4, 1) + 1
        =&gt;    1    +    1    +    1    + p(0, 2) + p(2, 1) + 1 + 1
        =&gt; 1 + 1 + 1 + 1 + 1 + 1 + 1
        =&gt; 7
</pre>
<p> 分割数を求める関数を partition_number() とすると、関数 p(n, k) を使って次のようにプログラムすることができます。使用するプログラミング言語は Python (PyPy ver 4.0.1) です。
</p>
<pre class="list">
リスト : 分割数

def part_num(n, k):
    if n == 1 or k == 1:
        return 1
    if n &lt; 0 or k &lt; 1:
        return 0
    else:
        return part_num(n - k, k) + part_num(n, k - 1)

def partition_number(n):
    return part_num(n, n)

if __name__ == '__main__':
    s = time.clock()
    print partition_number(40)
    print time.clock() - s
    s = time.clock()
    print partition_number(60)
    print time.clock() - s
    s = time.clock()
    print partition_number(80)
    print time.clock() - s
</pre>
<pre>
37338
0.0596520920521
966467
0.127742740877
15796476
1.46806816342

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 関数 part_num は p(n, k) の定義をそのままプログラムしただけです。ただし、このプログラムは二重再帰で何度も同じ値を求めているため実行速度はとても遅くなります。関数 part_num() をメモ化すると高速化することができますが、大きな値を計算すると Python のスタックがオーバーフローしてしまいます。
</p>
<h4>●動的計画法による高速化</h4>
<p> 動的計画法を使うと、大きな値でも高速に計算することができます。次の図を見てください。
</p>
<pre class="fig">
k 
1 : [1,  1,  1,  1,  1,  1,  1] 

2 : [1,  1,  1+1=2, 1+1=2, 2+1=3, 2+1=3, 3+1=4]
 =&gt; [1,  1,  2,  2,  3,  3,  4]

3:  [1,  1,  2,  1+2=3, 1+3=4, 2+3=5, 3+4=7]
 =&gt; [1,  1,  2,  3,  4,  5,  7]

4:  [1,  1,  2,  3,  1+4=4, 1+5=6, 2+7=9]
 =&gt; [1,  1,  2,  3,  5,  6,  9

5:  [1,  1,  2,  3,  5,  1+6=7, 1+9=10]
 =&gt; [1,  1,  2,  3,  5,  7,  10]

6:  [1,  1,  2,  3,  5,  7,  10+1=11]
 =&gt; [1,  1,  2,  3,  5,  7,  11]
</pre>
<p> 大きさ n + 1 のベクタを用意します。ベクタの添字が n を表していて、p(n, 1) から順番に値を求めていきます。p(n, 1) の値は 1 ですから、ベクタの要素は 1 に初期化します。次に、p(n, 2) の値を求めます。定義により p(n, 2) = p(n - 2, 2) + p(n, 1) なので、2 番目以降の要素に n - 2 番目の要素を加算すれば求めることができます。あとは、k の値をひとつずつ増やして同様の計算を行えば p(n, n) の値を求めることができます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 分割数 (動的計画法)

def partition_number2(n):
    table = [1] * (n + 1)
    for k in xrange(2, n + 1):
        for m in xrange(k, n + 1):
            table[m] += table[m - k]
    return table[n]
</pre>
<p> 説明をそのままプログラムしただけなので、とくに難しいところはないと思います。</p>
<p> それでは実際に試してみましょう。1000, 2000, 4000 の分割数を求めてみました。
</p>
<pre>
24061467864032622473692149727991
0.0513870740661
4720819175619413888601432406799959512200344166
0.181650325875
1024150064776551375119256307915896842122498030313150910234889093895
0.855192145224

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 動的計画法の効果はとても高いですね。
</p>
<h4>●さらなる高速化</h4>
<p> ところで、数がもっと大きくなると動的計画法を使ったプログラムでも遅くなります。実際に 5000, 6000, 7000 の分割数を求めてみましょう。
</p>
<pre>
169820168825442121851975101689306431361757683049829233322203824652329144349
1.50930555096
46717275319702090929710246439736906433646291532700370338566055289250724053492461
29
2.37062753398
32856930803440615786280925635924166861950151574532240659699032157432236394374450
791229199
3.55832466028

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> <a href="partition.html#cite">参考 URL 1</a> によると、次の漸化式を使うと分割数を高速に求めることができるそうです。
</p>
<pre class="item">
p(k) = p(k - 1) + p(k - 2) - p(k - 5) - p(k - 7) + p(k - 12) + p(k - 15) - p(k - 22) - ...
</pre>
<p> 漸化式の説明を <a href="partition.html#cite">参考 URL 1</a> より引用します。
</p>
<p> <cite>『ここで p(0) = 1 および負の整数 k に対して p(k) = 0 とし、和は (1/2)n(3n - 1) の形（ただし n は正または負の整数全体を走る）の一般五角数全体にわたってとるものとする（順に n = 1, -1, 2, -2, 3, -3, 4, -4 ..., とすると、値として 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, ... が得られる）。和における符号は交互に +, +, -, -, +, +, ... と続く。』</cite>
</p>

<p> 分割数 p(k) は k - 1 以下の分割数がわかれば求めることができます。この漸化式も動的計画法を使えば簡単にプログラムできます。次のリストを見てください。
</p>
<pre class="list">
リスト : 分割数 (オイラーの五角数定理)

# 五角数
def pentagon(n): return n * (3 * n - 1) / 2

def partition_number3(n):
    p = [0] * (n + 1)
    p[0] = 1
    for i in xrange(1, n + 1):
        j = 1
        s = 1
        while True:
            k = pentagon(j)
            if i &lt; k: break
            p[i] += p[i - k] * s
            k = pentagon(-j)
            if i &lt; k: break
            p[i] += p[i - k] * s
            j += 1
            s *= -1
    return p[n]
</pre>
<p> リスト p は分割数 p(k) を記憶するために使います。p[0] を 1 に初期化したあと、for ループで 1 から n までの分割数を順番に求めていきます。あとは、漸化式をそのままプログラムするだけです。変数 s は符号 (+. -) を表していて、j が奇数のとき s は 1 になり、j が偶数のときは -1 になります。
</p>
<p> それでは実際に 5000, 10000, 20000 の分割数を求めてみましょう。
</p>
<pre>
169820168825442121851975101689306431361757683049829233322203824652329144349
0.0725597390947
36167251325636293988820471890953695495016030339315650422081868605887952568754066
420592310556052906916435144
0.161129830804
25211481381252969791661953323047045228132894960181159343685031410803428442380156
4956623970731689824369192324789351994903016411826230578166735959242113097
0.449506044235

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> このように、20000 の分割数でも 1 秒かからずに求めることができます。
</p>
<hr>
<h4 id="ans02">●解答２</h4>

<pre class="list">
リスト : 整数の分割

def part_int_sub(n, k, a):
    if n == 0:   print a
    elif n == 1: print a + [1]
    elif k == 1: print a + [1] * n
    else:
        if n &gt;= k:
            part_int_sub(n - k, k, a + [k])
        part_int_sub(n, k - 1, a)

def partition_of_int(n): part_int_sub(n, n, [])
</pre>
<p> 基本的な考え方は partition_number() と同じです。関数 part_int_sub() は選んだ数値を累積変数 a のリストに格納していくだけです。n が 0 の場合は a を出力し、n が 1 の場合は a に [1] を追加してから出力します。k が 1 の場合は [1] * n で要素が 1 で長さが n のリストを作成し、それを a と連結してから出力します。
</p>
<p> 5, 6, 7 の分割の仕方は次のようになります。
</p>
<pre>
[5]
[4, 1]
[3, 2]
[3, 1, 1]
[2, 2, 1]
[2, 1, 1, 1]
[1, 1, 1, 1, 1]

[6]
[5, 1]
[4, 2]
[4, 1, 1]
[3, 3]
[3, 2, 1]
[3, 1, 1, 1]
[2, 2, 2]
[2, 2, 1, 1]
[2, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1]

[7]
[6, 1]
[5, 2]
[5, 1, 1]
[4, 3]
[4, 2, 1]
[4, 1, 1, 1]
[3, 3, 1]
[3, 2, 2]
[3, 2, 1, 1]
[3, 1, 1, 1, 1]
[2, 2, 2, 1]
[2, 2, 1, 1, 1]
[2, 1, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1]
</pre>
<hr>
<h4 id="ans03">●解答３</h4>
<p> 整数を奇数で分割する場合、関数 p(n, k) の k を奇数に限定するだけで求めることができます。漸化式は次のようになります。
</p>
<pre class="item">
p(n, k) = 1                          ; n = 0 または k = 1
p(n, k) = 0                          ; n &lt; 0 または k &lt; 1
p(n, k) = p(n - k, k) + p(n, k - 2)  ; k は奇数
</pre>
<p> k は奇数なので、p(n - k, k) + p(n, k - 1) の k - 1 を k - 2 に変更するだけで OK です。これを単純にプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 奇数で分割したときの分割数

def part_num_odd(n, k):
    if n == 1 or k == 1:
        return 1
    if n &lt; 0 or k &lt; 1:
        return 0
    else:
        return part_num_odd(n - k, k) + part_num_odd(n, k - 2)

def partition_number_odd(n):
    if n % 2 == 0:
        return part_num_odd(n, n - 1)
    return part_num_odd(n, n)

if __name__ == '__main__':
    for x in xrange(1, 21): 
        print partition_number_odd(x),
    print
    print partition_number_odd(30)
    print partition_number_odd(40)
    print partition_number_odd(50)
</pre>
<pre>
1 1 2 2 3 4 5 6 8 10 12 15 18 22 27 32 38 46 54 64
296
1113
3658
</pre>

<p> 動的計画法を使ったプログラムは次のようになります。
</p>
<pre class="list">
リスト : 奇数で分割したときの分割数 (2)

def partition_number_odd2(n):
    table = [1] * (n + 1)
    for k in xrange(3, n + 1, 2):
        for m in xrange(k, n + 1):
            table[m] += table[m - k]
    return table[n]
</pre>
<p> 変数 k を奇数に限定するだけです。それでは、1000, 2000, 4000 の分割数を実際に求めてみましょう。
</p>
<pre>
8635565795744155161506
0.0283043469539
106972734349914451123354464808960
0.0850450621923
24884290037681681235695209792703824727967596678
0.374811822953

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 5000 程度の数であれば、Python (PyPy ver 4.0.1) でも高速に求めることができます。ただし、これよりも大きな数の分割数を求めるには、さらなる高速化が必要になりますが、M.Hiroi の勉強不足で漸化式がわかりません。これは今後の研究課題にしたいと思います。
</p>
<p> 分割の仕方を列挙するプログラムも簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 奇数で分割する

def part_int_odd_sub(n, k, a):
    if n == 0:   print a
    elif n == 1: print a + [1]
    elif k == 1: print a + [1] * n
    else:
        if n &gt;= k:
            part_int_odd_sub(n - k, k, a + [k])
        part_int_odd_sub(n, k - 2, a)

def partition_of_int_odd(n):
    if n % 2 == 0:
        part_int_odd_sub(n, n - 1, [])
    else:
        part_int_odd_sub(n, n, [])
</pre>
<p> 関数 part_int_odd_sub() の引数 k を奇数に限定するだけです。6, 7, 8 の分割の仕方は次のようになります。
</p>
<pre>
[5, 1]
[3, 3]
[3, 1, 1, 1]
[1, 1, 1, 1, 1, 1]

[7]
[5, 1, 1]
[3, 3, 1]
[3, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1]

[7, 1]
[5, 3]
[5, 1, 1, 1]
[3, 3, 1, 1]
[3, 1, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1, 1]
</pre>
<hr>
<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="https://ja.wikipedia.org/wiki/%E5%88%86%E5%89%B2%E6%95%B0">分割数 - Wikipedia</a>
  <li><a href="https://ja.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0%E3%81%AE%E5%88%86%E5%89%B2">自然数の分割 - Wikipedia</a>
  <li><a href="http://d.hatena.ne.jp/inamori/20121216/p1">分割数 - 桃の天然水<a/>, (inamori さん)
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>