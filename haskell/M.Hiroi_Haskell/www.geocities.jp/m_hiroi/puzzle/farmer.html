<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / 農夫と山羊と狼とキャベツの問題</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>農夫と山羊と狼とキャベツの問題</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>パズルの説明</h3>
<p> 今回は、「農夫と山羊と狼とキャベツの問題」 <sup><a href="farmer.html#note1">[*1]</a></sup> という、古典的なパズルを解いてみましょう。農夫が狼と山羊とキャベツを持って川の左岸にいます。農夫はこれらを川の右岸へ運ばなければいけませんが、ボートにはそのうちのひとつしか乗せることができません。狼は山羊を好んで食べるため、この 2 つを同じ岸に残すことはできません。また、山羊はキャベツを好んで食べるため、この 2 つも同じ岸に残すことはできません。この条件で、荷物をすべて右岸へ運ぶ手順を求めるのが問題です。
</p>
<p> このパズルを深さ優先探索と幅優先探索で解いてみましょう。使用するプログラミング言語は Perl です。コンピュータに解かせる前に、自分で考えてみるのも面白いでしょう。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> このパズルにはバリエーションがたくさんありますが、
「宣教師と人食い人」という危険な名前のパズルがとくに有名です。
</div>
<hr>
<h4>●深さ優先探索で解く場合</h4>
<p> このパズルを深さ優先探索で解く場合、同じ移動手順を何度も繰り返すことがないように注意しなければいけません。極端な例ですが、何も工夫しないと、同じ物を持って左右の岸を往復する、といったことも起こります。この場合、過去の状態を記憶しておけば、簡単にチェックすることができます。つまり、過去のある状態と同じになった場合は、そこで探索を打ち切ればいいわけです。
</p>
<p> 次はデータ構造を考えましょう。今回は Perl を使うので、データを文字列 farmer, wolf, goat, cabbage で表しても、簡単にプログラムを作ることができます。この場合、左右の岸は配列で表し、そこに文字列を格納することになります。
</p>
<p> これでもいいのですが、もっと簡単な方法がデータをビットで表すことです。過去に同じ状態があるかチェックするとき、整数値の比較をするだけで済みますし、状態の変更もビットのオン・オフだけなので簡単です。そこで、次のようなグローバル変数を定義します。
</p>

<pre class="list">
リスト：グローバル変数の定義

$farmaer = 0x01;  # 農夫
$goat    = 0x02;  # 山羊
$wolf    = 0x04;  # 狼
$cabbage = 0x08;  # キャベツ
$all     = 0x0f;  # 全部揃った状態

# 移動リスト
@move_list = ( $farmer, $goat, $wolf, $cabbage );

# 状態を保存
@left_side = ();
@right_side = ();
</pre>
<p> 移動リスト @move_list の先頭は、農夫だけ移動することを表します。これを忘れると解くことができません。ご注意くださいませ。
</p>
<p> ところで、ボートを表すデータがありませんが、ボートには必ず農夫が乗り込むので、ボートのデータは農夫で代用することができます。
</p>

<h4>●プログラム</h4>
<p> 左右の岸は配列 @left_side, @right_side で表します。ここに過去の状態を記憶します。バックトラックで探索するときに、左右の岸を区別するのは面倒なので、探索関数には農夫がいる岸を引数 $src_side に, 農夫がいない岸を引数 $dest_side に渡します。これらの変数には @left_side, @rigth_side へのリファレンスをセットします。
</p>
<p> 探索関数を search_move とすると、次のように呼び出します。
</p>
<pre class="list">
$left_side[0] = $all;
$right_side[0] = 0;
search_move( 0, \@left_side, \@right_side );
</pre>
<p> 第 2 引数に農夫のいる岸を、第 3 引数に農夫のいない岸を渡します。
</p>
プログラムは次のようになります。

<pre class="list">
リスト：深さ優先探索

sub search_move {
  my ($num, $src_side, $dest_side) = @_;
  my $src_state  = $src_side-&gt;[$num];
  my $dest_state = $dest_side-&gt;[$num];
  foreach $move (@move_list) {
    if( $move &amp; $src_state ){
      my $new_dest_state = $dest_state | $move | $farmer;
      my $new_src_state  = $new_dest_state ^ $all;
      if( &amp;check_state( $num, $new_src_state, $src_side ) ){
        # OK
        $dest_side-&gt;[$num + 1] = $new_dest_state;
        $src_side-&gt;[$num + 1] = $new_src_state;
        if( $right_side[$num + 1] == $all ){
          &amp;print_answer( $num + 1 );
        }
        # 再帰
        &amp;search_move( $num + 1, $dest_side, $src_side );
      }
    }
  }
}
</pre>
<p> @move_list から移動する物を求め、それが移動できるかチェックします。これは AND 演算で簡単にチェックすることができます。実際に移動する場合は、対岸の状態 $dest_state に $move と $farmer のビットを立てればいいわけです。この新しい状態を $new_dest_state に格納します。この変数のビットを反転させると、$src_state から $move と $farmer を取り除いた状態になります。ビットの反転は $all と排他的論理和 (xor) を取れば求めることができます。
</p>
<p> 次に、関数 check_state で条件を満たしているかチェックします。農夫のいない状態を渡して、キャベツや山羊が無事か確認し、過去に同じ状態がないかチェックします。OK ならば状態を配列に格納して、ゴールに到達したかチェックします。ゴールは右岸と決まっているので、グローバル変数 @right_side にアクセスして確認します。
</p>
<p> 関数 print_answer はゴールまでの手順を表示します。ゴールでなければ、search_move を再帰呼び出しします。このとき、$src_side と $dest_side を逆にして渡すことに注意してくださいね。
</p>
<p> 最後に、状態をチェックする関数 check_state を示します。
</p>

<pre class="list">
リスト： 状態のチェック

sub check_state {
  my ($num, $state, $side ) = @_;
  my $i;
  # 山羊と狼、または、山羊とキャベツを残してはいけない
  if( (($state &amp; $wolf) &amp;&amp; ($state &amp; $goat)) ||
      (($state &amp; $goat) &amp;&amp; ($state &amp; $cabbage)) ){
    return 0;
  }
  # 同じ状態が無いかチェック
  for( $i = 0; $i &lt;= $num; $i++ ){
    return 0 if $side-&gt;[$i] == $state;
  }
  return 1;
}
</pre>
<p> 山羊と狼が残っている、または、山羊とキャベツが残っていたら、山羊もしくはキャベツが食べられてしまいます。return で 0 を返します。この条件式の場合、3 つとも残っている場合でも、移動は失敗となります。過去の状態のチェックは、配列を検索するだけなので簡単です。
</p>

<h4>●実行結果</h4>
<p> 実行手順の表示は簡単なので、プログラムの説明は省略します。それでは実行してみましょう。
</p>
<pre>
0: [ farmer  goat  wolf  cabbage ] []
1: [ wolf  cabbage ]               [ farmer  goat ]
2: [ farmer  wolf  cabbage ]       [ goat ]
3: [ cabbage ]                     [ farmer  goat  wolf ]
4: [ farmer  goat  cabbage ]       [ wolf ]
5: [ goat ]                        [ farmer  wolf  cabbage ]
6: [ farmer  goat ]                [ wolf  cabbage ]
7: []                              [ farmer  goat  wolf  cabbage ]
</pre>
<p> 7 手で解くことができました。このプログラムでは、解をひとつ見つけたら終了します。具体的には print_answer の最後で exit します。深さ優先探索では、最初に求まる解が最短手順とはかぎりません。最短手順を求める場合、<a href="farmer.html#breadth">幅優先探索</a> の方が適しています。
</p>
<hr>
<h4>●プログラムリスト１</h4>
<pre class="list">
#
# farmer1.pl : 農夫と山羊と狼とキャベツの問題
#
#            単純なバックトラック版だよ
#

# bit で表す
$farmer  = 0x01;  # 農夫
$goat    = 0x02;  # 羊
$wolf    = 0x04;  # 狼
$cabbage = 0x08;  # キャベツ
$all     = 0x0f;  # 全員が揃った状態

# 移動リスト
@move_list = ( $farmer, $goat, $wolf, $cabbage );

# 状態を保存
@left_side = ();
@right_side = ();

sub print_state {
  my $state = shift;
  my $str ="[";
  if( $state &amp; $farmer ){
    $str .= " farmer ";
  }
  if( $state &amp; $goat ){
    $str .= " goat ";
  }
  if( $state &amp; $wolf ){
    $str .= " wolf ";
  }
  if( $state &amp; $cabbage ){
    $str .= " cabbage ";
  }
  $str .= "]";
  printf("%-32s", $str );
}


# 表示
sub print_answer {
  my $num = shift;
  my $i;
  for( $i = 0; $i &lt;= $num; $i++ ){
    print "$i: ";
    print_state( $left_side[$i] );
    print_state( $right_side[$i] );
    print "\n";
  }
  exit( 0 );
}


# 状態のチェック
sub check_state {
  my ($num, $state, $side ) = @_;
  my $i;
  # 羊と狼、または、羊とキャベツを残してはいけない
  if( (($state &amp; $wolf) &amp;&amp; ($state &amp; $goat)) ||
      (($state &amp; $goat) &amp;&amp; ($state &amp; $cabbage)) ){
    return 0;
  }
  # 同じ状態が無いかチェック
  for( $i = 0; $i &lt;= $num; $i++ ){
    return 0 if $side-&gt;[$i] == $state;
  }
  return 1;
}

# 移動手順の検索
sub search_move {
  my ($num, $src_side, $dest_side) = @_;
  my $src_state  = $src_side-&gt;[$num];
  my $dest_state = $dest_side-&gt;[$num];
  foreach $move (@move_list) {
    if( $move &amp; $src_state ){
      my $new_dest_state = $dest_state | $move | $farmer;
      my $new_src_state  = $new_dest_state ^ $all;  # ビットを反転
      if( &amp;check_state( $num, $new_src_state, $src_side ) ){
        # OK
        $dest_side-&gt;[$num + 1] = $new_dest_state;
        $src_side-&gt;[$num + 1] = $new_src_state;
        if( $right_side[$num + 1] == $all ){
          # 正解です
          &amp;print_answer( $num + 1 );
        }
        # 再帰
        &amp;search_move( $num + 1, $dest_side, $src_side );
      }
    }
  }
}

$left_side[0] = $all;
$right_side[0] = 0;
search_move( 0, \@left_side, \@right_side );
</pre>
<hr>
<h3 id="breadth">幅優先探索</h3>
<p> 今度は幅優先探索で解いてみましょう。ところで、深さ優先探索では右岸と左岸の状態を保存しましたが、一方の岸の状態だけ保存しておけば他方の状態を求めることができます。そこで、農夫がいる岸の状態だけを保存することにします。
</p>

<pre class="list">
リスト：グローバル変数の定義

$farmer =  0x01;  # 農夫
$goat    = 0x02;  # 羊
$wolf    = 0x04;  # 狼
$cabbage = 0x08;  # キャベツ
$right   = 0x10;  # 農夫は右側
$all     = 0x0f;  # 全員が揃った状態
$goal    = 0x1f;  # ゴール

@state = ();        # 農夫のいる側の状態
@prev_state = ();   # 手順表示用配列
</pre>
<p> 状態を表す数値の第 4 ビットで、農夫が右岸にいるか左岸にいるかを表します。幅優先探索は、すべての手順について平行に探索を進めていきます。配列 @state には、最初の状態、1 手目の状態、2 手目の状態、と順番に格納されます。このままでは手順の再現が出来ないので、@prev_state にひとつ前の状態を表す番号を格納することにします。
</p>
<p> 最初の状態が $state[0] だとすると、1 手目の状態は $state[1] 以降に格納されます。このとき、$prev_state[1] には 0 を格納します。これで、$state[1] のひとつ前は $state[0] であることがわかります。答えが見つかったときは、@prev_state をたどることで、手順を再現することができます。
</p>
<p> 探索プログラムは、@state からデータを取り出して、新しい状態が生成できたら、それを @state に登録します。これを解が見つかるまで繰り返します。@state の管理は <B>キュー (queue)</B> を使えば簡単です。プログラムは次のようになります。
</p>

<pre class="list">
リスト：幅優先探索

sub search_move {
  my $r = 0;
  my $w = 1;
  $state[0] = $all;
  $prev_state[0] = -1;

  for( ; $r &lt; $w; $r++ ){
    my $now_state = $state[$r];
    foreach $move (@move_list) {
      if( $now_state &amp; $move ){
        my $new_state = ($now_state ^ $goal) | $move | $farmer;
        $state[$w] = $new_state;
        $prev_state[$w] = $r;
        if( &amp;check_state( $w ) ){
          if( $state[$w] == $goal ){
            # 発見
            print_answer( $w );
            return;
          }
          $w++;        # キューに登録
        }
      }
    }
  }
}
</pre>

<p> ちょっとリストが長いですが、やっていることは簡単です。最初、@state と @prev_state に初期値をセットします。$r と $w はキューを管理する変数です。$r の位置にあるデータを取り出して、新しい状態を生成できたら、$w の位置に書き込みます。$r と $w が等しい値になると、キューは空の状態になるので探索を終了します。この場合は、解を見つけることができなかったということになります。
</p>
<p> 物の移動処理は深さ優先探索の場合とほぼ同じです。$now_state と $goal の排他的論理和を取ることで、農夫の位置が対岸に移動します。状態のチェックは、$state[$w] に書き込んでから行っていますが、$w の値を +1 していないので、まだキューには登録されていません。ご注意ください。
</p>

<p> 次は手順を表示する関数 print_answer です。
</p>

<pre class="list">
リスト：手順の表示

sub print_answer {
  my $num = shift;
  my $r;
  my $l;
  if( $prev_state[$num] != -1 ){
    &amp;print_answer( $prev_state[$num] );
  }
  if( $state[$num] &amp; $right ){
    $r = $state[$num];
    $l = $r ^ $all;
  } else {
    $l = $state[$num];
    $r = $l ^ $all;
  }
  print_state( $l );
  print_state( $r );
  print "\n";
}
</pre>
<p> 単純に @prev_state をたどると、移動手順は逆順に表示されてしまいます。そこで、再帰呼び出しで先頭まで戻り、最初から手順を表示しています。あとは難しいところはないでしょう。
</p>

<h4>●実行結果</h4>
<p> それでは実行結果を示します。
</p>
<pre>
[ farmer  goat  wolf  cabbage ] []
[ wolf  cabbage ]               [ farmer  goat ]
[ farmer  wolf  cabbage ]       [ goat ]
[ cabbage ]                     [ farmer  goat  wolf ]
[ farmer  goat  cabbage ]       [ wolf ]
[ goat ]                        [ farmer  wolf  cabbage ]
[ farmer  goat ]                [ wolf  cabbage ]
[]                              [ farmer  goat  wolf  cabbage ]
</pre>
<p> 7 手で解くことができました。深さ優先探索と同じ結果でしたね。実はこのパズル、全部で 10 通りの状態しかありません。そして、右側へ全部移動することが、いちばん手数のかかる問題だったなのです。コンピュータで解くには、ちょっと簡単なパズルでしたね。
</p>
<hr>
<h4>●プログラムリスト２</h4>
<pre class="list">
#
# farmer2.pl : 農夫と山羊と狼とキャベツの問題
#
#              幅優先探索
#

# 状態を表すビット
$farmer =  0x01;  # 農夫
$goat    = 0x02;  # 羊
$wolf    = 0x04;  # 狼
$cabbage = 0x08;  # キャベツ
$right   = 0x10;  # 農夫は右側
$all     = 0x0f;  # 全員が揃った状態
$goal    = 0x1f;  # ゴール

# 移動リスト
@move_list = ( $farmer, $goat, $wolf, $cabbage );

@state = ();        # 農夫のいる側の状態
@prev_state = ();   # 手順表示用配列

# 状態を表示
sub print_state {
  my $s = shift;
  my $str ="[";
  if( $s &amp; $farmer ){
    $str .= " farmer ";
  }
  if( $s &amp; $goat ){
    $str .= " goat ";
  }
  if( $s &amp; $wolf ){
    $str .= " wolf ";
  }
  if( $s &amp; $cabbage ){
    $str .= " cabbage ";
  }
  $str .= "]";
  printf("%-32s", $str );
}


# 表示
sub print_answer {
  my $num = shift;
  my $r;
  my $l;
  if( $prev_state[$num] != -1 ){
    &amp;print_answer( $prev_state[$num] );
  }
  if( $state[$num] &amp; $right ){
    $r = $state[$num];
    $l = $r ^ $all;
  } else {
    $l = $state[$num];
    $r = $l ^ $all;
  }
  print_state( $l );
  print_state( $r );
  print "\n";
}


# 状態のチェック
sub check_state {
  my $num = shift;
  my $now_state = $state[$num];
  my $s = $now_state ^ $all;     # 農夫がいない方のチェック
  my $i;
  # 羊と狼、または、羊とキャベツを残してはいけない
  if( (($s &amp; $wolf) &amp;&amp; ($s &amp; $goat)) ||
      (($s &amp; $goat) &amp;&amp; ($s &amp; $cabbage)) ){
    return 0;
  }
  # 同じ状態が無いかチェック
  for( $i = 0; $i &lt; $num; $i++ ){
    return 0 if $state[$i] == $state[$num];
  }
  return 1;
}


# 幅優先探索
sub search_move {
  my $r = 0;
  my $w = 1;
  $state[0] = $all;
  $prev_state[0] = -1;

  # キューにデータがある間は繰り返す
  for( ; $r &lt; $w; $r++ ){
    my $now_state = $state[$r];
    foreach $move (@move_list) {
      if( $now_state &amp; $move ){
        my $new_state = ($now_state ^ $goal) | $move | $farmer;
        # キューに登録
        $state[$w] = $new_state;
        $prev_state[$w] = $r;
        if( &amp;check_state( $w ) ){
          if( $state[$w] == $goal ){
            # 発見
            print_answer( $w );
            print "状態数 $w\n";
            return;
          }
          $w++;
        }
      }
    }
  }
}

# 実行
&amp;search_move();
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>