<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / フィボナッチ数</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881772</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>フィボナッチ数</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>パズルの説明</h3>
<p> フィボナッチ (fibonacci) 数はイタリアの数学者レオナルド・フィボナッチにちなんで名付けられた数です。今回はフィボナッチが考案したウサギの問題を解いてみましょう。
</p>
<div class="question">
<b>[問題]</b>
<p> １つがいのウサギがいます。ウサギは１ヶ月経つと１つがいの子ウサギを生みます。生まれたウサギは２ヶ月目には子ウサギを生むものとします。ウサギは死なないものとすると、１年後にウサギは何つがいになるでしょうか。
</p>
</div>
<hr>
<h4>●解答</h4>
<p> ウサギを親、子、生まれたウサギに分けて表を作ると次のようになります。
</p>
<pre class="fig">
   : 親 : 子 : 生 :  計
---+----+----+----+-----
 0 :  1 :  0 :  0 :   1
 1 :  1 :  0 :  1 :   2
 2 :  1 :  1 :  1 :   3
 3 :  2 :  1 :  2 :   5
 4 :  3 :  2 :  3 :   8
 5 :  5 :  3 :  5 :  13
 6 :  8 :  5 :  8 :  21
 7 : 13 :  8 : 13 :  34
 8 : 21 : 13 : 21 :  55
 9 : 34 ; 21 : 34 :  89
10 : 55 : 34 : 55 : 144
11 : 89 : 55 : 89 : 233
12 :144 : 89 :144 : 377
</pre>
<p> １月に子ウサギを生むとすると、答えは 377 つがいになります。１月に子を生まない (まだ親ウサギになっていない) とすると 233 つがいになります。F<sub>n</sub> を n ヵ月後のつがいの数とすると、F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> の関係が成立していることがわかります。数学では、次の漸化式で生成される数列を「フィボナッチ数列」といいます。
</p>
<pre class="fig">
       ┌ 0;               n = 0
F(n) = ┤ 1;               n = 1
       └ F(n-1) + F(n-2); n &gt; 1
</pre>
<p> フィボナッチ数列は 0, 1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列になります。
</p>
<hr>
<h4>●問題</h4>
<p> それでは、ここで問題です。
</p>
<ol>
  <li> 300,000,000 未満で最も大きいフィボナッチ数 F<sub>n</sub> を求めてください。
  <li> 初項 F<sub>0</sub> から n 番目までのフィボナッチ数の和 F<sub>0</sub> + F<sub>1</sub> + F<sub>2</sub> + ... + F<sub>n</sub> を考えます。300,000,000 未満のフィボナッチ数の総和を求めてください。
  <li> 300,000,000 未満のフィボナッチ数で、偶数になる項の総和を求めてください。
  <li> 300,000,000 を 1 つ以上の連続しない相異なるフィボナッチ数の和として表してください。たとえば、7 = 1 + 1 + 2 + 3 と表すことができますが、1 を 2 回使っていることと、1, 2, 3 は連続したフィボナッチ数 (F<sub>2</sub>, F<sub>3</sub>, F<sub>4</sub>) なので条件を満たしていません。7 = 2 + 5 とすると条件を満たします。
</ol>
<ol>
  <li><a href="fibo.html#ans01">解答</a>
  <li><a href="fibo.html#ans02">解答</a>
  <li><a href="fibo.html#ans03">解答</a>
  <li><a href="fibo.html#ans04">解答</a>
</ol>
<hr>
<h4 id="ans01">●解答１</h4>
<p> フィボナッチ数を求めるプログラムは簡単です。Python でプログラムすると次のようになります。
</p>
<pre class="list">
リスト : フィボナッチ数

def fibo(n):
    a1, a2 = 0, 1;
    while n &gt; 0:
        a1, a2 = a2, a1 + a2
        n -= 1
    return a1

i = 0
while True:
    if fibo(i) &gt;= 300000000: break
    i += 1
print(i-1)
print(fibo(i-1))
</pre>
<p> 答えは F<sub>42</sub> = 267914296 になります。また、次のようにメモ化関数を使うと二重再帰のプログラムでも高速に求めることができます。
</p>
<pre class="list">
リスト : メモ化関数

def memoize(f):
    table = {}
    def func(*args):
        if not args in table:
            table[args] = f(*args)
        return table[args]
    return func

@memoize
def fibo(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibo(n - 2) + fibo(n - 1)
</pre>
<p> メモ化関数については、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo01.html">再帰定義</a> をお読みくださいませ。
</p>

<p> さらに、次の公式を使うと筆算でも簡単に求めることができます。<a href="fibo.html#cite">参考 URL 3</a> によると、フィボナッチ数は次の近似式で求めることができるそうです。
</p>
<pre class="item">
F<sub>n</sub> = φ<SUP>n</sup> / √5  (φ = (1 + √5) / 2)
</pre>
<p> したがって、n は次の式で求めることができます。
</p>
<pre class="item">
n = floor(log(300000000) / log(φ))
</pre>
<pre>
&gt;&gt;&gt;&gt; from math import *
&gt;&gt;&gt;&gt; phi = (1 + sqrt(5)) / 2
&gt;&gt;&gt;&gt; phi
1.618033988749895
&gt;&gt;&gt;&gt; floor(log(300000000 * sqrt(5)) / log(phi))
42.0
</pre>
<p> <a href="fibo.html#cite">参考 URL 3</a> によると、上記近似式の誤差は 0.5 未満になるとのことなので、フィボナッチ数は次の式で求めることができます。
</p>
<pre class="item">
F<sub>n</sub> = floor(φ<sup>n</sup> / √5 + 0.5)
</pre>
<pre>
&gt;&gt;&gt;&gt; floor(phi ** 42 / sqrt(5) + 0.5)
267914296.0
</pre>
<h4 id="ans02">●解答２</h4>
<p> Python の場合、内包表記を使うと簡単です。
</p>
<pre>
&gt;&gt;&gt;&gt; sum([fibo(x) for x in xrange(43)])
701408732
</pre>
<p> 次の公式を使うともっと簡単に和を求めることができます。
</p>
<pre class="item">
F<sub>1</sub> + F<sub>2</sub> + ... + F<sub>n</sub> = F<sub>n+2</sub> - 1
</pre>
<p> 各項を F<sub>n</sub> = F<sub>n+2</sub> - F<sub>n+1</sub> の関係を使って書き直すと次のようになります。
</p>
<pre class="item">
F<sub>1</sub> = F<sub>3</sub> - F<sub>2</sub>
F<sub>2</sub> = F<sub>4</sub> - F<sub>3</sub>
F<sub>3</sub> = F<sub>5</sub> - F<sub>4</sub>
・・・・・
F<sub>n-2</sub> = F<sub>n</sub> - F<sub>n-1</sub>
F<sub>n-1</sub> = F<sub>n+1</sub> - F<sub>n</sub>
F<sub>n</sub> = F<sub>n+2</sub> - F<sub>n+1</sub>
--------------------------
ΣF<sub>n</sub> = F<sub>n+2</sub> - F<sub>2</sub> = F<sub>n+2</sub> - 1
</pre>
<p> 答えは F<sub>44</sub> - 1 になります。
</p>
<pre>
&gt;&gt;&gt;&gt; floor(phi ** 44 / sqrt(5) + 0.5) - 1
701408732.0
</pre>
<p> ご参考までに、偶数番目の項の総和と基数番目の項の総和の公式を示します。
</p>
<pre class="item">
F<sub>2</sub> + F<sub>4</sub> + ... + F<sub>2n</sub> = F<sub>2n+1</sub> - 1
F<sub>1</sub> + F<sub>3</sub> + F<sub>5</sub> + ... + F<sub>2n-1</sub> = F<sub>2n</sub>
</pre>
<p> これらの公式は項 F<sub>n</sub> を F<sub>n-2</sub> + F<sub>n-1</sub> に書き換えると求めることができます。
</p>
<pre class="item">
(F<sub>0</sub> + F<sub>1</sub>) + (F<sub>2</sub> + F<sub>3</sub>) + (F<sub>4</sub> + F<sub>5</sub>) + ... + (F<sub>2n-2</sub> + F<sub>2n-1</sub>) 
= F<sub>2n+1</sub> - 1 (F<sub>2n-1</sub> までの総和)

F<sub>1</sub> + (F<sub>1</sub> + F<sub>2</sub>) + (F<sub>3</sub> + F<sub>4</sub>) + ... + (F<sub>2n-3</sub> + F<sub>2n-2</sub>) 
= F<sub>2n</sub> (F<sub>2n-2</sub> までの和 + F<sub>1</sub>)
</pre>
<h4 id="ans03">●解答３</h4>
<p> フィボナッチ数列は F<sub>1</sub> = 1 (奇), F<sub>2</sub> = 1 (奇) なので、F<sub>3</sub> = 1 (奇) + 1 (奇) = 2 (偶), F<sub>4</sub> = 1 (奇) + 2 (偶) = 3 (奇), F<sub>5</sub> = 2 (偶) + 3 (奇) = 5 (奇), F<sub>6</sub> = 3 (奇) + 5 (奇) = 8 (偶) になります。つまり、n が 3 の倍数のとき項の値は偶数になるわけです。
</p>
<p> この性質を利用すると、偶数となる項の総和は次のように求めることができます。
</p>
<pre>
&gt;&gt;&gt;&gt; sum([fibo(x) for x in xrange(43) if x % 3 == 0])
350704366
</pre>
<p> 偶数の項の総和を求める公式は、次のように導出することができます。
</p>
<pre class="item">
S = F<sub>3</sub> + F<sub>6</sub> + ... + F<sub>3(n-1)</sub> + F<sub>3n</sub>
とし、各項を F<sub>n</sub> = F<sub>n-2</sub> + F<sub>n-1</sub> の関係を使って書き直すと
S = (F<sub>1</sub> + F<sub>2</sub>) + (F<sub>4</sub> + F<sub>5</sub>) + ... + (F<sub>3n-2</sub> + F<sub>3n-1</sub>)
足し算すると
2S = F<sub>1</sub> + F<sub>2</sub> + F<sub>3</sub> + ... + F<sub>3n-2</sub> + F<sub>3n-1</sub> + F<sub>3n</sub> (F<sub>3n</sub> までの総和)
   = F<sub>3n+2</sub> - 1
=&gt; S = (F<sub>3n+2</sub> - 1) / 2
</pre>
<p> このように、F<sub>3n</sub> までの偶数項の総和は F<sub>3n</sub> までの総和の半分になります。
</p>
<pre>
&gt;&gt;&gt;&gt; (floor(phi ** 44 / sqrt(5) + 0.5) - 1) / 2
350704366.0
</pre>
<h4 id="ans04">●解答４</h4>
<p> <a href="fibo.html#cite">参考 URL 4</a> によると、<cite>『ゼッケンドルフの定理は、任意の正の整数が、連続するフィボナッチ数を含まないような形で、相異なる 1 つ以上のフィボナッチ数の和として一意に表現できるというものである。』</cite> とのことです。これを「ゼッケンドルフの表現」と呼ぶそうです。正整数 N のゼッケンドルフの表現は、<cite>『各段階で可能な最大のフィボナッチ数を選ぶ貪欲法によって得ることができる。』</cite> そうです。
</p>
<p> これをそのまま単純にプログラムすると次のようになります。
</p>
<pre class="list">
リスト : ゼッケンドルフの表現

def solver(n):
    def max_fibo(n):
        i = 1
        while fibo(i) &lt;= n: i += 1
        return fibo(i - 1)

    print n, ":", 
    while n &gt; 0:
        x = max_fibo(n)
        print x,
        n -= x
</pre>
<pre class="item">
300000000 : 267914296 24157817 5702887 2178309 46368 233 89 1
</pre>
<p> 局所関数 max_fibo() で n 以下の最大のフィボナッチ数を求めます。あとは、max_fibo() でフィボナッチ数を求め、それを n から引き算していくだけです。
</p>
<hr>
<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="http://www.torito.jp/puzzles/114.shtml">１－１４．ねずみ算とフィボナッチ数列</a>, <a href="http://www.torito.jp/puzzles/puzzle_asobi.shtml">パズル遊びへの招待・オンライン版</a>, (高木茂男氏)
  <li><a href="http://www004.upp.so-net.ne.jp/s_honma/fibonacci/fibonacci.htm">フィボナッチ数を極める - So-net</a>, <a href="http://www004.upp.so-net.ne.jp/s_honma/">私的数学塾</a>
  <li><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0">フィボナッチ数 - Wikipedia</a>
  <li><a href="https://ja.wikipedia.org/wiki/%E3%82%BC%E3%83%83%E3%82%B1%E3%83%B3%E3%83%89%E3%83%AB%E3%83%95%E3%81%AE%E5%AE%9A%E7%90%86">ゼッケンドルフの定理 - Wikipedia</a>
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>