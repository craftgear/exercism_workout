<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / 約数 (divisor)</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>約数 (divisor)</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>パズルの説明</h3>
<p> 「約数 (divisor)」は整数 n を割り切る整数のことです。たとえば、24 の正の約数は 1, 2, 3, 4, 6, 8, 12, 24 の 8 個あります。ここでは正の約数を考えることにします。
</p>
<p> それでは問題です。
<ol>
  <li> 自然数 n, m の最大公約数を求めるプログラムを作ってください。
  <li> 自然数 n, m の最小公倍数を求めるプログラムを作ってください。
  <li> 自然数 n の約数の個数を求めるプログラムを作ってください。
  <li> 自然数 n の約数の和を求めるプログラムを作ってください。
  <li> 自然数 n の約数をすべて求めるプログラムを作ってください。
  <li> <a href="divisor.html#cite">参考 URL 1</a> によると、<cite>『完全数（かんぜんすう，perfect number）とは、その数自身を除く約数の和が、その数自身と等しい自然数のことである。』</cite> とのことです。10000 以下の完全数を求めてください。
  <li> <a href="divisor.html#cite">参考 URL 2</a> によると、<cite>『友愛数（ゆうあいすう）とは、異なる2つの自然数の組で、自分自身を除いた約数の和が、互いに他方と等しくなるような数をいう。』</cite> とのことです。100000 以下の友愛数を求めてください。
</ol>
<ul>
  <li><a href="divisor.html#ans01">解答１</a>
  <li><a href="divisor.html#ans02">解答２</a>
  <li><a href="divisor.html#ans03">解答３</a>
  <li><a href="divisor.html#ans04">解答４</a>
  <li><a href="divisor.html#ans05">解答５</a>
  <li><a href="divisor.html#ans06">解答６</a>
  <li><a href="divisor.html#ans07">解答７</a>
</ul>
<ul>
  <li><a href="divisor.html#ans_6_7">問題 6, 7 の別解</a>
</ul>

<hr>
<h4 id="ans01">●解答１</h4>
<p> 最大公約数は「ユークリッドの互除法」で求めることができます。
</p>
<ul>
  <li><b>ユークリッドの互除法</b><br>
負でない整数 a と b (a &gt; b) で、a を b で割った余りを r とする。<br>
このとき、a と b の最大公約数は b と r の最大公約数に等しい。
</ul>
</pre>
<p> 詳しい説明は拙作のページ <a href="../light/python03.html#chap03">Python 入門 第 3 回 再帰定義と高階関数 : ユークリッドの互除法</a> をお読みください。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 最大公約数 (末尾再帰)

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)
</pre>
<p> 関数 gcd() は引数 a と b の最大公約数を求めます。b が 0 の場合は a を返します。これが再帰呼び出しの停止条件になります。そうでなければ、gcd() を再帰呼び出しして、b と a % b の最大公約数を求めます。
</p>
<p> 残念ながら、Python は末尾再帰最適化をサポートしていません。繰り返しに変換すると次のようになります。
</p>
<pre class="list">
リスト : 最大公約数 (繰り返し)

def gcd(a, b):
    while b &gt; 0:
        a, b = b, a % b
    return a
</pre>
<p> 引数 a, b の値を書き換えることで最大公約数を求めています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
gcd(12345678, 123456789) =&gt; 9
gcd(1234321, 12345654321) =&gt;121
</pre>
<p> 複数の整数の最大公約数を Python で求める場合は reduce() を使うと簡単です。
</p>
<pre>
reduce(gcd, [123, 12345, 12345678]) =&gt; 3
</pre>
<hr>
<h4 id="ans02">●解答２</h4>
<p> 最小公倍数は最大公約数を使って簡単に求めることができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 最大公倍数

def lcm(a, b):
    return a * b / gcd(a, b)
</pre>
<p> 整数 a と b の最小公倍数は a * b / gcd(a, b) で求めることができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
lcm(5, 7) =&gt; 35
lcm(14, 35) =&gt; 70
</pre>
<p> 複数の整数の最小公倍数を Python で求める場合は reduce() を使うと簡単です。
</p>
<pre>
reduce(lcm, range(2, 21)) =&gt; 232792560
reduce(lcm, range(2, 31)) =&gt; 2329089562800
</pre>
<hr>
<h4 id="ans03">●解答３</h4>
<p> n の素因数分解ができると、約数の個数を求めるのは簡単です。n = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> とすると、約数の個数は (a + 1) * (b + 1) * (c + 1) になります。たとえば、12 は 2<sup>2</sup> * 3<sup>1</sup> になるので、約数の個数は 3 * 2 = 6 になります。実際、12 の約数は 1, 2, 3, 4, 6, 12 の 6 個です。
</p>
<p> 拙作のページ <a href="prime.html">素数</a> で作成した関数 factorization() を使うと、プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数の個数

def divisor_num(n):
    a = 1
    for _, x in factorization(n):
        a *= x + 1
    return a
</pre>
<p> 関数 divisor_num() は for ループでリストの要素 (タプル) を順番に取り出し、x + 1 を a に掛け算していくだけです。 
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
divisor_num(24)         =&gt; 8
divisor_num(12345678)   =&gt; 24
divisor_num(123456789)  =&gt; 12
divisor_num(1234567890) =&gt; 48
divisor_num(1111111111) =&gt; 16
</pre>
<hr>
<h4 id="ans04">●解答４</h4>
<p> n の素因数分解ができると、約数の合計値を求めるのは簡単です。n の素因数分解が p<sup>a</sup> だった場合、その約数の合計値は次の式で求めることができます。
</p>
<pre class="item">
σ(p, a) = p<sup>a</sup> + p<sup>a-1</sup> + ... + p<sup>2</sup> + p + 1
</pre>
<p> たとえば、8 の素因数分解は 2<sup>3</sup> になり、素数の合計値は 8 + 4 + 2 + 1 = 15 になります。
</p>
<p> p<sup>a</sup> の約数の合計値を σ(p, a) で表すことにします。n = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> の場合、n の約数の合計値は σ(p, a) * σ(q, b) * σ(r, c) になります。たとえば、12 は 2<sup>2</sup> * 3 に素因数分解できますが、その合計値は (4 + 2 + 1) * (3 + 1) = 28 となります。12 の約数は 1, 2, 3, 4, 6, 12 なので、その合計値は確かに 28 になります。
</p>
<p> 拙作のページ <a href="prime.html">素数</a> で作成した関数 factorization() を使うと、プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数の合計値

# σ(p, n) の計算
def div_sum_sub(p, n):
    a = 0
    while n &gt; 0:
        a += p ** n
        n -= 1
    return a + 1

def divisor_sum(n):
    a = 1
    for p, q in factorization(n):
        a *= div_sum_sub(p, q)
    return a
</pre>
<p> 関数 div_sum_sub() は σ(p, n) を計算します。あとは for ループで div_sum_sub() の返り値を累積変数 a に掛け算していくだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
divisor_sum(24)         =&gt; 60
divisor_sum(12345678)   =&gt; 27319968
divisor_sum(123456789)  =&gt; 178422816
divisor_sum(1234567890) =&gt; 3211610688
divisor_sum(1111111111) =&gt; 1246404096
</pre>
<hr>
<h4 id="ans05">●解答５</h4>
<p> p が素数の場合、p<sup>a</sup> の約数は次のように簡単に求めることができます。
</p>
<pre class="item">
p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1
</pre>
<p> n の素因数分解が p<sup>a</sup> * q<sup>b</sup> だったとすると、その約数は次のようになります。
</p>
<pre class="item">
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b-1</sup>,
        .....
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>2</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * 1
</pre>
<p> たとえば、12 の約数は 2<sup>4</sup> = (1, 2, 4) と 3 = (1, 3) から、(1, 2, 4) * 1 と (1, 2, 4) * 3 のすべての要素 (1, 2, 4, 3, 6, 12) になります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数をすべて求める

# p<sup>q</sup> の約数を求める
def divisor_sub(p, q):
    a = []
    for i in xrange(0, q + 1):
        a.append(p ** i)
    return a

def divisor(n):
    xs = factorization(n)
    ys = divisor_sub(xs[0][0], xs[0][1])
    for p, q in xs[1:]:
        ys = [x * y for x in divisor_sub(p, q) for y in ys]
    return sorted(ys)
</pre>
<p> 関数 divisor_sub() は p<sup>q</sup> の約数をリストに格納して返します。引数 n を factorization() で素因数分解して変数 xs にセットします。xs の先頭要素を divisor_sub() に渡してリストに変換して変数 ys にセットします。あとは for ループで xs の 1 番目から要素を順番に取り出し、p<sup>q</sup> を divisor_sub() でリストに変換して、それを内包表記で累積変数 ys のリストの要素と掛け合わせていくだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
divisor(24) =&gt; [1, 2, 3, 4, 6, 8, 12, 24]
divisor(12345678) =&gt;
[1, 2, 3, 6, 9, 18, 47, 94, 141, 282, 423, 846, 14593, 29186, 43779, 87558, 131337, 262674, 685871,
 1371742, 2057613, 4115226, 6172839, 12345678]
divisor(123456789) =&gt; [1, 3, 9, 3607, 3803, 10821, 11409, 32463, 34227, 13717421, 41152263, 123456789]
divisor(1234567890) =&gt;
[1, 2, 3, ,5 ,6 9, 10, 15, 18, 30, 45, 90, 3607, 3803, 7214, 7606, 10821, 11409, 18035, 19015, 21642,
 22818, 32463, 34227, 36070, 38030, 54105, 57045, 64926, 68454, 108210, 114090, 162315, 171135,
 324630, 342270, 13717421, 27434842, 41152263, 68587105, 82304526, 123456789, 137174210,
 205761315, 246913578, 411522630, 617283945, 1234567890]
divisor(1111111111) =&gt;
[1, 11, 41, 271, 451, 2981, 9091, 11111, 100001, 122221, 372731, 2463661, 4100041, 27100271,
 101010101, 1111111111]
</pre>
<hr>
<h4 id="ans06">●解答６</h4>
<pre class="list">
リスト : 完全数

def perfect_number(n):
    for x in xrange(2, n + 1):
        if divisor_sum(x) - x == x:
            print x,
    print

perfect_number(10000)
</pre>
<p> 完全数を求める perfect_number() は簡単です。x の約数の合計値を divisor_sum() で求め、その値から x を引いた値が x と等しければ完全数です。print で x を表示します。
</p>
<p> 実行結果を示します。
</p>
<pre>
6 28 496 8128
</pre>
<p> ところで、<a href="divisor.html#cite">参考 URL 1</a> によると、メルセンヌ素数を M<sub>n</sub> とすると、偶数の完全数は 2<sup>n-1</sup> * M<sub>n</sub> で表すことができるそうです。この式を使うと偶数の完全数は次のようになります。
</p>
<pre class="item">
 n : メルセンヌ素数 : 完全数
---+----------------+----------------------
 2 : 3              : 6
 3 : 7              : 28
 5 : 31             : 496
 7 : 127            : 8128
13 : 8191           : 33550336
17 : 131071         : 8589869056
19 : 524287         : 137438691328
31 : 2147483647     : 2305843008139952128
</pre>
<p> なお、奇数の完全数はまだ発見されておらず、偶数の完全数 (つまりメルセンヌ素数) が無数に存在するか否かも未解決な問題だそうです。
</p>

<h4>●過剰数と不足数</h4>
<p> ところで、<a href="divisor.html#cite">参考 ULR 3, 4<a> によると、『その数自身を除く約数の総和が元の数より大きい数』を「過剰数 (abundant number)」といい、『その数自身を除く約数の総和が元の数より小さい数』を「不足数 (deficient number)」というそうです。過剰数と不足数の個数を求めるプログラムも簡単に作ることができます。
</p>
<pre class="list">
リスト : 過剰数と不足数

# 過剰数
def abundant_number(n):
    count = 0
    for x in xrange(1, n + 1):
        y = divisor_sum(x) - x
        if y &gt; x: count += 1
    return count

# 不足数
def deficient_number(n):
    count = 0
    for x in xrange(1, n + 1):
        y = divisor_sum(x) - x
        if y &lt; x: count += 1
    return count

print abundant_number(1000000)
print deficient_number(1000000)
</pre>
<pre>
247545
752451
</pre>
<p> 1000000 以下の過剰数は 247545 個、不足数は 752451 個、完全数は 4 個なので、合計で 1000000 になります。<a href="divisor.html#cite">参考 URL 3</a> によると、<cite>『自然数のうち過剰数が占める割合は0.2474から0.2480の間であると証明されている。』</cite> とのことで、1000000 以下の過剰数の個数は確かにこの範囲内に入っています。
</p>
<hr>
<h4 id="ans07">●解答７</h4>
<pre class="list">
リスト : 友愛数

def yuuai_number(n):
    for x in xrange(2, n + 1):
        m = divisor_sum(x) - x
        if m &lt; x and x == divisor_sum(m) - m:
            print m, x
    print
</pre>
<p> 友愛数を求める関数 yuuai_number() も簡単です。divisor_sum() で x の約数の合計値を求め、その値から x を引いた値を変数 m にセットします。m の約数の合計値から m を引いた値が x と等しければ、x と m は友愛数です。print で x と m を表示します。同じ組を表示しないようにするため、m &lt; x を条件に入れています。
</p>
<p> 実行結果を示します。
</p>
<pre>
220 284
1184 1210
2620 2924
5020 5564
6232 6368
10744 10856
12285 14595
17296 18416
63020 76084
66928 66992
67095 71145
69615 87633
79750 88730
</pre>
<p> なお、友愛数が無数に存在するか否かは、未解決な問題だそうです。
</p>
<hr>
<h4 id="ans_6_7">●問題 6, 7 の別解</h4>
<p> perfect_number() と yuuai_number() は、divisor_sum() を呼び出して約数の和を求めていますが、あらかじめ約数の和を計算してリスト (配列) に格納しておく方法もあります。この場合、約数の和の計算にちょっと時間がかかりますが、完全数と友愛数を求める処理は高速になります。
</p>
<p> 基本的な考え方は簡単です。約数の和を格納する配列 sum_table を用意します。sum_table の要素は 1 に初期化します。2 から順番に素数 p で割り算して 1 + p<sup>1</sup> + ... + p<sup>q</sup> を求め、それを sum_table の値に掛け算します。素数は「エラトステネスの篩」と同じ方法で求めることができます。素数の倍数であれば、sum_table の値は 1 よりも大きくなっているはずです。つまり、sum_table が 1 であれば、その整数は素数であることがわかります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : n 以下の整数の約数の和をリストに格納して返す

def make_divisor_sum(n):
    def factor_sub(n, p):
        a = 1
        q = 1
        while n % p == 0:
            a += p ** q
            q += 1
            n /= p
        return a
    #
    sum_table = [1] * (n + 1)
    for i in xrange(2, n + 1):
        if sum_table[i] != 1: continue
        for j in xrange(i, n + 1, i):
            sum_table[j] *= factor_sub(j, i)
    return sum_table
</pre>
<p> 局所関数 factor_sub() は n を 素数 p で割り算して、1 + p<sup>1</sup> + ... + p<sup>q</sup> を求めます。make_divisor_sum() は sum_table を初期化してから、for ループで素数を探します。sum_table[i] が 1 でない場合、i は素数ではありません。contiune で次の数をチェックします。素数の場合は、その倍数に対応する sum_table の値を更新します。i の倍数を 変数 j にセットし、sum_table[j] に factor_sub(j, i) の値を乗算するだけです。最後に sum_table を返します。
</p>
<p> make_divisor_sum() を使うと yuuai_number() は次のようになります。
</p>
<pre class="list">
リスト : 友愛数

def yuuai_number(n):
    table = make_divisor_sum(n)
    for x in xrange(2, n + 1):
        y = table[x] - x
        if y &lt; x and table[y] - y == x:
            print y, x
</pre>
<p> 実際に 1,000,000 以下の友愛数を求めてみたところ、40 個の友愛数を出力するのに最初のプログラムでは 2.9 秒 (実行環境 : Windows 7, Core i7-2670QM 2.20GHz, PyPy 4.0.1) かかりましたが、make_divisor_sum() を使ったプログラムは約数の和を求める処理を含めて 0.28 秒ですみました。約 10 倍高速化することができました。
</p>
<hr>
<h4 id="cite">●参考 URL</h4>
<ol>
  <li> <a href="http://ja.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E6%95%B0">完全数 - Wikipedia</a>
  <li> <a href="http://ja.wikipedia.org/wiki/%E5%8F%8B%E6%84%9B%E6%95%B0">友愛数 - Wikipedia</a>
  <li> <a href="https://ja.wikipedia.org/wiki/%E9%81%8E%E5%89%B0%E6%95%B0">過剰数 - Wikipedia</a>
  <li> <a href="https://ja.wikipedia.org/wiki/%E4%B8%8D%E8%B6%B3%E6%95%B0">不足数 - Wikipedia</a>
  <li><a href="http://d.hatena.ne.jp/inamori/20091113/p1">完全数・友愛数・社交数 - 桃の天然水</a>, (inamori さん)
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>