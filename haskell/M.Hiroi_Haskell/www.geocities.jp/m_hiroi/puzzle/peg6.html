<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Puzzle DE Programming / ペグ・ソリテア・スター</title>
  <meta name="description" content="Puzzle,パズル,プログラミング,解法">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881773</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Puzzle DE Programming</h1>
<h2>ペグ・ソリテア・スター</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
<hr>
</div>
<section class="contents">
<h3>問題の説明</h3>
<p> ペグ・ソリテアは、盤上に配置されたペグ（駒）を最後にはひとつ残るように取り除いていく古典的なパズルです。ペグは次のルールに従って移動して取り除くことができます。
</p>
<ul>
  <li> ペグは隣にあるペグをひとつだけ跳び越して、空いている場所へ着地します。
  <li> 跳び越されたペグは盤上から取り除かれます。
  <li> 移動方向は、ふつう縦横のみの 4 方向ですが、
       ルールによっては斜め方向の移動を許す場合もあります。
  <li> 同じペグの連続跳び越しは 1 手と数えます。
</ul>
<p> 今回の問題は盤面を<b>六芒星</b>の形にしたペグ・ソリテアです。
</p>

<pre class="fig">
              ○
            ／  ＼
  ●───●───●───●  
    ＼  ／  ＼  ／  ＼  ／
      ●───●───●
    ／  ＼  ／  ＼  ／  ＼
  ●───●───●───●  
            ＼  ／
              ●

 問題：ペグ・ソリテア・スター
</pre>
<p> 上図では黒丸でペグを表し、白丸で空き場所を表しています。ペグは線に沿って移動することができます。最初に取り除いたペグ（白丸）と最後に残ったペグの位置が同じになる「補償型の解」の最短手順を求めてください。
</p>
<p> ところで、この六芒星盤のペグ・ソリテアですが、柏木 或 さんのホームページ <a href="http://homepage3.nifty.com/primalrain/index.html">裂け目の向こう</a> の <a href="http://homepage3.nifty.com/primalrain/puzzletopia/david_i.html">パズルトピア攻略 - [ダビデの星]</a> によると、<cite>『ちなみにこの六芒星状の配置は芦ヶ原氏によるオリジナルです。かつては東洋ガラスから同名の製品が市販されていました。』
</cite> とのことです。
</p>
<hr>
<h4>●プログラムの作成</h4>
<p> 今回はＣ言語でプログラムを作ります。このパズルはペグの個数が少ないので、単純な「反復深化」で十分です。反復深化のプログラムは今までに何度も作っているので、説明は省略いたします。反復深化の説明は拙作のページ <a href="peg1.html">ペグ・ソリテア</a> をお読みくださいませ。
</p>

<p> また、拙作のページ Common Lisp 入門：<a href="../xyzzy_lisp/abclisp24.html#yori26">ちょっと寄り道「ペグ・ソリテア・スターを解く」</a> では、同じパズルを「反復深化＋下限値枝刈り法」で解いています。Common Lisp や下限値枝刈り法に興味のある方は読んでみてください。
</p>
<p><a href="peg6.html#list">●プログラムリスト</a>
</p>
<hr>
<h4>●ペグ・ソリテア・スターの解答</h4>
<p> それでは、パズル「ペグ・ソリテア・スター」の解答を示します。
</p>

<pre class="fig">
              ○                            ０              
            ／  ＼                        ／  ＼            
  ●───●───●───●    １───２───３───４  
    ＼  ／  ＼  ／  ＼  ／        ＼  ／  ＼  ／  ＼  ／    
      ●───●───●            ５───６───７      
    ／  ＼  ／  ＼  ／  ＼        ／  ＼  ／  ＼  ／  ＼    
  ●───●───●───●    ８───９───10───11  
            ＼  ／                        ＼  ／            
              ●                            12              

                図：ペグ・ソリテア・スター
</pre>
<p> 上図のように穴に番号をつけて、ペグの移動は番号で表すことにします。移動手順は 1 手を [ 移動元 (from), 移動先 (to) ] で表し、連続跳び越しの場合は [from, to1, to2, ..., to3] とします。最短手順のひとつを次に示します。
</p>
<pre class="item">
1: [7, 0]
2: [12, 7]
3: [8, 10]
4: [11, 9, 3]
5: [4, 10]
6: [1, 9]
7: [0, 7, 12, 5, 0]
</pre>
<p> 7 手で解くことができました。「補償型の解」という条件がない場合でも最短手数は 7 手になります。また、最初に取り除くペグの位置が 2 の場合も最短手数は 7 手になります。
</p>

<p> これではもの足りないという方のために、もうひとつ問題を出しましょう。下図のように中央のペグを取り除いた盤を考えてみます。
</p>

<pre class="fig">
              ●              
            ／  ＼            
  ●───●───●───●  
    ＼  ／          ＼  ／    
      ●              ●      
    ／  ＼          ／  ＼    
  ●───●───●───●  
            ＼  ／            
              ●              

図：ペグ・ソリテア・スター（その２）
</pre>
<p> 最初にどれかひとつペグを取り除いて、最後にペグがひとつ残る最短手順を求めてください。ただし、最初に取り除くペグの位置によっては解けない場合があります。ご注意くださいませ。
</p>
<hr>
<h4>●ペグ・ソリテア・スターの偶奇性</h4>
<p> <a href="parity.html">偶奇性のお話</a> で説明しましたが、ペグ・ソリテアには「偶奇性」があります。ペグ・ソリテア・スターの場合、下図のように 3 つのグループに分けると、グループに属するペグ数と全体のペグ数の偶奇性を使って、解の有無をチェックすることができます。
</p>

<pre class="fig">
              ●                            ０              
            ／  ＼                        ／  ＼             Group 0 : 7  
  ●───●───●───●    ０───１───２───０  
    ＼  ／  ＼  ／  ＼  ／        ＼  ／  ＼  ／  ＼  ／     Group 1 : 3
      ●───●───●            ２───０───１      
    ／  ＼  ／  ＼  ／  ＼        ／  ＼  ／  ＼  ／  ＼     Group 2 : 3
  ●───●───●───●    ０───１───２───０  
            ＼  ／                        ＼  ／             Total   : 13
              ●                            ０              

             図：ペグ・ソリテア・スターの偶奇性
</pre>
<p> 最初にペグをどれかひとつ取り除いた状態で、3 つのグループのなかの 1 グループだけが全体のペグ数の偶奇性と一致していないと、そのペグ・ソリテアには解がありません。上図のペグ・ソリテア・スターの場合、最初にペグをひとつ取り除くと、そのグループのペグ数は偶数になりますが、ほかのグループは奇数のままですね。そして、全体のペグ数は偶数になるので偶奇性の条件を満たします。ただし、この関係を満たしているからといって、必ず解けるとはかぎらないことに注意してください。
</p>

<p> それでは、ペグ・ソリテア・スター（その２）の場合はどうなるでしょうか。
</p>

<pre class="fig">
              ●                            ０              
            ／  ＼                        ／  ＼             Group 0 : 6
  ●───●───●───●    ０───１───２───０  
    ＼  ／          ＼  ／        ＼  ／          ＼  ／     Group 1 : 3
      ●              ●            ２              １      
    ／  ＼          ／  ＼        ／  ＼          ／  ＼     Group 2 : 3
  ●───●───●───●    ０───１───２───０  
            ＼  ／                        ＼  ／             Total   : 12
              ●                            ０              

        図：ペグ・ソリテア・スター（その２）の偶奇性
</pre>

<p> 最初に Group 0 のペグをひとつ取り除くと、3 つのグループすべて奇数になってしまいますね。この場合、解くことはできません。では、Group 1 のペグをひとつ取り除いてみましょう。すると、全体のペグ数は奇数になり、Group 0, 1 は偶数で Group 2 は奇数なので偶奇性の条件を満たします。同様に、Group 2 のペグをひとつ取り除いた場合も条件を満たします。
</p>
<p> 最初に Group 0 のペグを取り除くと解はありませんが、Group 1 か 2 のペグを取り除く場合は解があるかもしれません。実際に解いてみると、最短手順は次のようになりました。
</p>

<pre class="fig">
              ０                   2 のペグを取り除いた場合  
            ／  ＼             1 : [7, 2]
  １───２───３───４   2 : [11, 5]
    ＼  ／          ＼  ／     3 : [10, 8]
      ５              ６       4 : [4, 9, 7]
    ／  ＼          ／  ＼     5 : [0, 6]
  ７───８───９───10   6 : [1, 3]
            ＼  ／             7 : [7, 2, 4, 9]
              11              

  図：ペグ・ソリテア・スター（その２）の解答
</pre>
<p> この場合、「補償型の解」は存在しません。これも偶奇性からわかります。最後にひとつ残るペグは、全体のペグ数の偶奇性と一致しているグループになります。つまり、最初に取り除いたペグのグループが全体のペグ数の偶奇性と一致していることが、「補償型の解」が存在する条件になるのです。
</p>
<p> 上図の場合、取り除いたペグのグループと全体のペグ数の偶奇性は一致しません。したがって、最初に Group 1 のペグを取り除くと最後に残るペグは Group 2 になり、逆に Group 2 のペグを取り除くと最後に残るペグは Group 1 になるのです。
</p>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
/*
 * peg_star.c : ペグ・ソリテア・スター
 *
 *              Copyright (C) 2002,2003 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TRUE  1
#define FALSE 0

#define SIZE     13
#define MAX_JUMP 11
#define HOLE     0

/* 跳び表 */
const char jump_table[][SIZE] = {
  {2, 5, 3, 7, -1},            /* 0 */
  {2, 3, 5, 9, -1},            /* 1 */
  {3, 4, 5, 8, 6, 10, -1},     /* 2 */
  {2, 1, 6, 9, 7, 11, -1},     /* 3 */
  {3, 2, 7, 10, -1},           /* 4 */
  {2, 0, 6, 7, 9, 12, -1},     /* 5 */
  {-1},                        /* 6 */
  {3, 0, 6, 5, 10, 12, -1},    /* 7 */
  {5, 2, 9, 10, -1},           /* 8 */
  {5, 1, 6, 3, 10, 11, -1},    /* 9 */
  {6, 2, 7, 4, 9, 8, -1},      /* 10 */
  {7, 3, 10, 9, -1},           /* 11 */
  {9, 5, 10, 7, -1},           /* 12 */
};

/* 盤面 */
char board[SIZE];

/* 跳び手順を格納 */
char move[MAX_JUMP][2];

/* 解の総数をカウント */
int count = 0;

/* ペグを動かす */
void move_piece( int n, int from, int del, int to )
{
  board[from] = 0;
  board[del] = 0;
  board[to] = 1;
  move[n][0] = from;
  move[n][1] = to;
}

/* ペグを元に戻す */
void back_piece( int from, int del, int to )
{
  board[from] = 1;
  board[del] = 1;
  board[to] = 0;
}

/* 手順を表示 */
void print_move( void )
{
  int i, j;
  for( i = 0, j = 1; i &lt; MAX_JUMP; i++, j++ ){
    printf("(%2d,%2d", move[i][0], move[i][1] );
    for( ; j &lt; MAX_JUMP; i++, j++ ){
      if( move[i][1] != move[j][0] ) break;
      printf(",%2d", move[j][1] );
    }
    printf(")");
  }
  printf("\n");
}

/* 手順の探索 */
void search_move( int n, int jc, int limit )
{
  if( jc &gt; limit ) return;
  if( n == MAX_JUMP ){
    if( board[HOLE] ){
      count++;
      print_move();
    }
  } else {
    int from, del, to, i;
    for( from = 0; from &lt; SIZE; from++ ){
      if( !board[from] ) continue;        /* ペグが無い */
      i = 0;
      while( (del = jump_table[from][i++]) != -1 ){
	to = jump_table[from][i++];
	if( board[del] &amp;&amp; !board[to] ){
	  /* 跳び越せる */
          move_piece( n, from, del, to );
          search_move( n + 1, (move[n-1][1] == from ? jc : jc + 1), limit );
          back_piece( from, del, to );
	}
      }
    }
  }
}

int main()
{
  int move, start, end;
  start = clock();
  /* 初期化 */
  memset( board, 1, SIZE );
  board[HOLE] = 0;
  for( move = 5; move &lt;= MAX_JUMP; move++ ){
    printf("・・・手数 %d を探索中・・・\n", move );
    search_move( 0, 0, move );
    if( count ) break;
  }
  end = clock();
  printf( "総数 %d 個, 時間 %d\n", count, end - start );
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2002,2003 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Puzzle</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>