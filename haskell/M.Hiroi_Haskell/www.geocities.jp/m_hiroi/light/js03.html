<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 JavaScript プログラミング超入門</title>
  <meta name="description" content="JavaScript,JavaScript入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881802</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page<br>
<div class="small">
http://www.geocities.jp/m_hiroi/<br>
</div>
<div class="ce">
<h1>JavaScript Programming</h1>
<h2>お気楽 JavaScript プログラミング超入門</h2>
<div class="small">
[ <a href="js02.html">PrevPage</a> | <a href="javascript.html">JavaScript</a> | <a href="js04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap07">高階関数</h3>
<p> JavaScript はプロトタイプベースのオブジェクト指向言語ですが、関数型言語の機能も備えています。JavaScript は関数をオブジェクトとして扱うことができるので、関数を変数に代入したり、引数として渡すことができます。また、値として関数を返すこともできるので、関数を作る関数を定義することも簡単にできます。
</p>
<p> 関数を引数として受け取る関数を「汎関数 (functional) 」とか「高階関数 (higher order function) 」と呼びます。JavaScript は高階関数を簡単に定義することができます。今回は関数型言語でよく使われている高階関数の中で、マッピング、フィルター、畳み込み (縮約) について説明します。 
</p>
<h4>●マッピング</h4>
<p> まず最初に、引数の関数 fn() に配列の要素を渡して呼び出し、その結果を配列に格納して返す関数を作ってみましょう。このような操作を「マッピング（写像）」といいます。なお、関数に引数を与えて呼び出すことを、関数型言語では「適用」といいます。本稿でも関数呼び出しの意味で適用を使うことにします。プログラムは次のようになります。
</p>
<pre class="list">
リスト : マッピング

function map(fn, ary) {
    var a = [];
    for (var i = 0; i &lt; ary.length; i++) a.push(fn(ary[i]));
    return a;
}
</pre>
<p> 受け取った関数を呼び出す場合、JavaScript では特別なことを行う必要はありません。引数 fn を fn(ary[i]) のように関数として使うと、JavaScript は fn の値を関数として呼び出します。関数を渡す場合も簡単です。関数が定義されている変数を渡すだけでいいのです。
</p>
<p> それでは実行例を示しましょう。
</p>
<pre>
&gt; function square(x) { return x * x; }
undefined
&gt; map(square, [1, 2, 3, 4, 5])
[1, 4, 9, 16, 25]
</pre>

<p> 引数を 2 乗する関数 square() を定義します。この関数を map() に渡すと、要素を 2 乗した新しい配列を返します。このように、JavaScript は高階関数を簡単に定義することができます。
</p>
<h4>●フィルター</h4>
<p> フィルター (filter) は配列の要素に関数を適用し、関数が真を返す要素を配列に格納して返す関数です。関数型言語では、真または偽を返す関数のことを「述語 (predicate) 」といいます。ここでは簡単な例題として、述語が真を返す要素を削除する関数 remove_if() を作ってみましょう。関数名は Common Lisp から拝借しました。
</p>
<pre class="list">
リスト : 要素の削除

function remove_if(fn, ary) {
    var a = [];
    for (var i = 0; i &lt; ary.length; i++) {
        if(!fn(ary[i])) a.push(ary[i]);
    }
    return a;
}
</pre>

<p> map() と同様に remove_if() も簡単です。fn(ary[i]) が真ならば x を配列 a に加えません。偽ならば ary[i] を配列に加えるだけです。簡単な実行例を示します。
</p>
<pre>
&gt; function evenp(x) {return x % 2 == 0;}
undefined
&gt; function oddp(x) {return x % 2 != 0;}
undefined
&gt; remove_if(evenp, [1,2,3,4,5,6])
[1, 3, 5]
&gt; remove_if(oddp, [1,2,3,4,5,6])
[2, 4, 6]
</pre>
<p> 最初の例では偶数の要素が削除されます。次の例では奇数の要素が削除されます。
</p>
<p> もちろん、フィルターも簡単に定義することができます。remove_if() とは逆に、述語が真を返すとき要素を配列に追加し、偽を返すときは配列に加えません。
</p>
<pre class="list">
リスト : フィルター

function filter(fn, ary) {
    var a = [];
    for (var i = 0; i &lt; ary.length; i++) {
        if(fn(ary[i])) a.push(ary[i]);
    }
    return a;
}
</pre>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
&gt; filter(evenp, [1,2,3,4,5,6])
[2, 4, 6]
&gt; filter(oddp, [1,2,3,4,5,6])
[1, 3, 5]
</pre>
<h4>●畳み込み</h4>
<p> 2 つの引数を取る関数 f() と配列を引数に受け取る関数 fold() を考えます。fold() は配列の各要素に対して関数 f() を下図のように適用します。
</p>
<pre class="fig">
(1) [a1, a2, a3, a4, a5]
    =&gt; f( f( f( f( a1, a2 ), a3 ), a4 ), a5 )

(2) [a1, a2, a3, a4, a5]
    =&gt; f( a1, f( a2, f( a3, f( a4, a5 ) ) ) )

        図 : 関数 fold() の動作
</pre>

<p> 関数 f() を適用する順番で 2 通りの方法があります。図 (1) は配列の先頭から f() を適用し、図 (2) は配列の後ろから f() を適用します。たとえば、関数 f() が単純な加算関数とすると、fold() の結果はどちらの場合も配列の要素の和になります。
</p>
<pre class="item">
f(x, y) = x + y の場合
fold() =&gt; a1 + a2 + a3 + a4 + a5
</pre>

<p> このように、fold() は配列のすべての要素を関数 f() を用いて結合します。このような操作を「縮約」とか「畳み込み」といいます。また、fold() の引数に初期値 g を指定することがあります。この場合、fold() は下図に示す動作になります。
</p>
<pre class="fig">
(1) [a1, a2, a3, a4, a5]
    =&gt; f( f( f( f( f( g, a1 ), a2 ), a3 ), a4 ), a5 )

(2) [a1, a2, a3, a4, a5]
    =&gt; f( a1, f( a2, f( a3, f( a4, f( a5, g ) ) ) ) )

        図 : fold() の動作 (2)
</pre>

<p> ここでは簡単な例題として、上図 (1) の動作を行う関数 fold_left() と、上図 (2) の動作を行う関数 fold_right() を作ってみましょう。

<p> プログラムは次のようになります。

<pre class="list">
リスト : 畳み込み

function fold_left(fn, init, ary) {
    var a = init;
    for (var i = 0; i &lt; ary.length; i++) a = fn(a, ary[i]);
    return a;
}

function fold_right(fn, init, ary) {
    var a = init;
    for  (var i = ary.length - 1; i &gt;= 0; i--) a = fn(ary[i], a);
    return a;
}
</pre>
<p> fold_left(), fold_right() の引数 fn が適用する関数、init が初期値、ary が配列です。最初にローカル変数 a を init で初期化します。次に、for ループで ary の要素を先頭から一つずつ取り出し、fn(a, ary[i]) を実行します。fold_left() は変数 a の値を fn() の返り値に更新することで、図 (1) の動作を実現しています。
</p>
<p> たとえば、配列が [1, 2, 3] で init が 0 とします。最初は fn(0, 1) が実行され、その返り値が a にセットされます。次は fn(a, 2) が実行されますが、これは fn(fn(0, 1), 2) と同じことです。そして、その結果が a にセットされます。最後に fn(a, 3) が実行されますが、これは fn(fn(fn(0, 1), 2), 3) となり、図 (1) と同じ動作になります。
</p>
<p> fold_left() の場合、配列の要素が関数 fn() の第 2 引数になり、第 1 引数にはこれまでの処理結果が渡されます。これに対し、fold_right() の場合は逆になり、関数 fn() の第 1 引数に配列の要素が渡されて、これまでの処理結果は第 2 引数に渡されます。これで図 (2) の動作を実現することができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; function add(x, y) { return x + y; }
undefined
&gt; fold_left(add, 0, [1,2,3,4,5])
15
&gt; fold_right(add, 0, [1,2,3,4,5])
15
</pre>

<p> fold_left(), fold_right() に関数 add() を渡すと、配列の要素の合計値を求めることができます。畳み込みは 2 引数の関数と組み合わせると、いろいろな処理を実現することができます。
</p>
<h4>●匿名関数</h4>
<p> 高階関数を使うようになると、数を 2 乗する square のような小さな関数をいちいち定義するのが面倒になります。とくに、その高階関数でしか使わないのであれば、なおさらそう思うでしょう。JavaScript には Lisp の「ラムダ式 (lambda) 」のような「匿名関数 (anonymous function) 」という名前のない関数が用意されています。
</p>
<p> 匿名関数は次のように定義します。
</p>
<pre class="item">
function(仮引数, ...) { 処理A; ...; 処理Z; }
</pre>
<p> 匿名関数は Lisp / Scheme のラムダ式が関数を返すのと同様に、関数オブジェクトを生成して返します。JavaScript は匿名関数をそのまま実行することができますし、関数の引数に匿名関数を渡すこともできます。簡単な例を示しましょう。
</p>
<pre>
&gt; (function(x) { return x * x; })(20)
400
&gt; map(function(x) {return x * x;}, [1, 2, 3, 4, 5])
[1, 4, 9, 16, 25]
</pre>

<p> JavaScript の場合、匿名関数をそのまま実行するときは、匿名関数をカッコで囲んでください。そのあとに引数を指定します。map 関数を使う場合、わざわざ square() を定義しなくてもいいので簡単です。このように、匿名関数は高階関数と組み合わせて使うと便利です。
</p>
<p> また、function による関数定義は、匿名関数を使って次のように書き直すことができます。
</p>
<pre class="list">
リスト : function による関数定義

function square(x) {
    return x * x;
}
</pre>
<pre class="list">
リスト : 匿名関数による関数定義

square = function(x) { return x * x; }
</pre>
<p> 匿名関数の実行例を示します。
<pre>
&gt; square = function(x) { return x * x; }
function (x) { return x * x; }
&gt; square(100)
10000
</pre>
<p> このように、匿名関数で関数オブジェクトを生成し、その値を変数 square にセットすれば、square(100) のように関数として呼び出すことができます。これは Scheme の関数定義とよく似ています。
</p>
<p> ただし、上記のプログラムは関数を定義する動作は同じですが、そのタイミングが異なります。通常の関数定義の場合、プログラムを読み込んだあと、それを実行する前に関数が定義されます。したがって、次のようなプログラムでも動作します。
</p>
<pre class="list">
リスト : 関数 square の実行 (1)

var a = square(100);
console.log(a);

function square(x) {
    return x * x;
}
</pre>
<p> 上のプログラムは正常に動作して、10000 が表示されます。ところが次のリストはエラーになります。
<pre class="list">
リスト : 関数 square の実行 (2)

var a = square(100);
console.log(a);

var square = function(x) {
    return x * x;
}
</pre>

<p> この場合、関数呼び出しでエラーが発生します。匿名関数は定義文ではないので、プログラムを実行したときに関数オブジェクトが生成されます。匿名関数で関数を定義する
場合、square(100) を実行するとき、まだ変数 square には関数オブジェクトがセットされていないのでエラーになるわけです。ご注意くださいませ。
</p>
<h4>●レキシカルスコープ</h4>
<p> ここで、もう少し詳しくローカル変数の規則を見てみましょう。変数 x を表示する関数 foo() を定義します。
</p>
<pre>
&gt; function foo() { console.log(x); }
undefined
&gt; x = 10
10
&gt; foo()
10
undefined
</pre>

<p> foo() には変数 x を定義していないので、foo() を実行した場合グローバル変数の値を探しにいきます。それでは foo1() という関数から foo() を呼び出す場合を考えてみましょう。foo1() には引数 (ローカル変数) x を定義します。この場合、foo() はどちらの値を表示するのでしょうか。実際に試してみましょう。
</p>
<pre>
&gt; function foo1(x) { foo(x); }
undefined
&gt;foo1(100)
10
</pre>

<p> グローバル変数の値を表示しました。このように、foo1() で定義されているローカル変数 x は、foo() からアクセスすることはできません。下図を見てください。
</p>
<pre class="fig">
 ┌───── JavaScript system  ─────┐
 │                                        │
 │        グローバル変数  x ←────┐  │
 │                                    │  │
 │  ┌→┌─ 関数 foo ──────┐  │  │
 │  │  │            ┌─────┼─┘  │
 │  │  │ console.log(x)         │      │
 │  │  └────────────┘      │
 │  │  ┌─ 関数 foo1: x ────┐      │
 │  │  │                        │      │
 │  └─┼─ foo()                │      │
 │      └────────────┘      │
 │                                        │
 └────────────────────┘

           図 : レキシカルスコープ
</pre>
<p> 上図では、変数の有効範囲を枠で表しています。foo1() で定義したローカル変数 x は、関数 foo1() の枠の中でのみ有効です。もしも、この枠で変数が見つからない場合は、ひとつ外側の枠を調べます。この場合、関数定義の枠しかないので、ここで変数が見つからない場合はグローバル変数を調べます。
</p>
<p> foo() は関数定義の枠しかありません。そこに変数 x が定義されていないので、グローバル変数を調べることになるのです。このように、foo() から foo1() の枠を超えて変数 x にアクセスすることはできないのです。これを「レキシカルスコープ (lexical scope) 」といいます。レキシカルには文脈上いう意味があり、変数が定義されている範囲内 (枠内) でないと、その変数にアクセスすることはできません。
</p>
<h4>●匿名関数とローカル変数</h4>
<p> それでは、匿名関数の場合はどうでしょうか。次のリストを見てください。
</p>
<pre class="list">
リスト : リストの要素を n 倍する

function times_element(n, ary) {
    return map(function(x) { return x * n; }, ary);
}
</pre>
<p> 匿名関数の仮引数は x だけですから、変数 n はグローバル変数をアクセスすると思われるかもしれません。ところが、変数 n は関数 times_element の引数 n をアクセスするのです。下図を見てください。
</p>
<pre class="fig">
┌───── JavaScript system  ────┐
│                                      │
│    ┌─ times_element : n l  ─┐    │
│    │                  ↑      │    │
│    │                  └─┐  │    │
│    │  ┌ function : x ─┐│  │    │
│    │  │            ↑  ││  │    │
│    │  │      ┌──┘  ││  │    │
│    │  │      x * n     ││  │    │
│    │  │          └──┼┘  │    │
│    │  └────────┘    │    │
│    └─────────────┘    │
│                                      │
└───────────────────┘

        図 : 匿名関数の変数
</pre>
<p> ポイントは、匿名関数が関数 times_element() 内で定義されているところです。変数 n は関数の引数として定義されていて、その有効範囲は関数の終わりまでです。匿名関数はその範囲内に定義されているため、変数 n にアクセスすることができるのです。つまり、関数内で定義された匿名関数は、そのとき有効なローカル変数にもアクセスすることができるわけです。
</p>
<p> もうひとつ簡単な例題を示しましょう。指定した文字 c が先頭にある文字列を、リストから削除する関数を作ってみましょう。最初に実行例を示します。
</p>
<pre>
&gt; remove_string("a", ["abc", "def", "agh", "ijk"])
["def", "ijk"]
</pre>

<p> 配列に格納された文字列の中で、a から始まる文字列を削除します。この処理は remove_if() と匿名関数を使うと簡単に定義できます。
</p>
<pre class="list">
リスト : 先頭文字が c の文字列を削除

function remove_string(c, ary) {
    return remove_if(function(x) { return c == x[0]; }, ary);
}
</pre>
<p> 匿名関数の中で remove_string() の引数 c をアクセスできるので、このような定義が可能になります。
</p>
<h4>●関数のネスト</h4>
<p> JavaScript は関数の中で別の関数を定義することができます。つまり、関数のネスト（入れ子）ができるわけです。入れ子の関数は局所的な関数として扱われるので、定義された関数の中でのみ有効です。他の関数から呼び出すことはできません。また、入れ子の関数は、匿名関数のように外側の関数のローカル変数にアクセスすることができます。
</p>
<p> 簡単な例として、入れ子の関数を使って times_element() を書き直してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : リストの要素を n 倍する (2)

function times_element(n, ary) {
    function _times(x) { return x * n; }
    return map(_times, ary);
}
</pre>
<p> 入れ子関数の定義は今までの関数定義と同じで、特別なことはありません。関数定義の中で、別の関数が定義されているだけです。関数 _times() は times_element() 内で定義されているので、_times() から times_element() の引数 n を参照することができます。
</p>
<p> ちなみに、この処理は匿名関数を使って次のように書き換えることもできます。
</p>
<pre class="list">
リスト : リストの要素を n 倍する (3)

function times_element(n, ary) {
    var _times = function(x) { return x * n; };
    return map(_times, ary);
}
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap08">クロージャ</h3>
<p> 今回は「クロージャ (closure) 」について説明します。
</p>
<h4>●クロージャとは？</h4>
<p> クロージャは実行する関数と参照可能なローカル変数をまとめたものです。クロージャは関数のように実行することができますが、クロージャを生成するときに参照可能なローカル変数を保存するところが異なります。参照可能なローカル変数の集合を「環境 (environment) 」と呼びます。
</p>
<p> JavaScript の場合、関数はオブジェクトですが、それがクロージャになります。トップレベルで関数を定義するとき、ローカル変数は存在しないので、クロージャに保存される環境は空になると考えてください。匿名関数や局所関数もクロージャになります。関数内で匿名関数や局所関数を定義するとき、外側の関数に引数やローカル変数が定義されていれば、それらがクロージャに保存されます。
</p>
<p> 匿名関数や局所関数は、外側の関数の引数やローカル変数にアクセスすることができましたね。これはクロージャに環境が保存されているからできることなのです。つまり、レキシカルスコープはクロージャによって実現されているわけです。ちなみに、レキシカルスコープを採用した最初の Lisp 処理系が Scheme です。拙作のページ <a href="../func/abcscm30.html">Scheme で作る micro Scheme</a> や <a href="../clisp/clispb12.html">Common Lisp で作る micro Scheme</a> では、簡単な Scheme インタプリタを作成していますが、関数をクロージャとして扱うことでレキシカルスコープを実現しています。
</p>
<p> また、Lisp / Scheme や関数型言語などは、関数内で新しい関数を生成して、それを返すことも簡単にできます。このときクロージャがとても役に立ちます。もちろん、JavaScript でも同様のことが可能です。
</p>
<h4>●関数を返す関数</h4>
<p> JavaScript で関数を返す関数を作るには、関数の中で「匿名関数」または「局所関数」を定義して、それを return で返します。たとえば、「引数を n 倍する関数」を生成する関数は、匿名関数を使うと次のようになります。
</p>
<pre>
&gt; function foo(n) { return function(x) { return x * n; }; }
undefined
&gt; foo10 = foo(10)
function (x) { return x * n; }
&gt; foo10(1)
10
&gt; foo10(10)
100
&gt; foo5 = foo(5)
function (x) { return x * n; }
&gt; foo5(1)
5
&gt; foo5(10)
50
</pre>

<p> 関数 foo() は引数を n 倍する関数を生成します。変数 foo10 に foo(10) の返り値をセットします。すると、foo10 は引数を 10 倍する関数として使うことができます。同様に、変数 foo5 に foo(5) の返り値をセットすると、foo5 は引数を 5 倍する関数になります。
</p>
<p> 匿名関数で関数を生成するとき、評価する関数のほかに、そのとき参照可能なローカル変数、つまり「環境」もいっしょに保存されます。この場合、参照可能なローカル変数は foo() の引数 n です。そして、クロージャを実行するときは、保存されているローカル変数を参照することができるのです。
</p>
<p> foo(10) を実行して匿名関数を生成するとき、定義されているローカル変数は n で、その値は 10 です。この値がクロージャに保存されているので、foo10 の関数は引数を 10 倍した結果を返します。foo(5) を評価すると n の値は 5 で、それがクロージャに保存されているので、foo5 の関数は引数を 5 倍した結果を返すのです。
</p>
<p> 局所関数を定義して返す場合は次のようになります。
</p>
<pre class="list">
リスト : マップ関数のカリー化

function map(func) {
    function _map(ary) {
        var result = [];
        for (var i = 0; i &lt; ary.length; i++) {
            result.push(func(ary[i]));
        }
        return result;
    }
    return _map;
}
</pre>
<p> 関数 map() は引数 func に関数を受け取り、その関数を呼び出すマップ関数を返します。局所関数 _map() はクロージャなので、map() の引数 func にアクセスすることができます。
</p>
<p> 簡単な実行例を示しましょう。
<pre>
&gt; map2 = map(function(x) { return x * x; })
... 省略 ...
&gt; map2([1, 2, 3, 4, 5])
[1, 4, 9, 16, 25]
&gt; map(function(x) { return x * x; })([1,2,3,4,5])
[1, 4, 9, 16, 25]
</pre>
<p> 最初の例は map() で生成した関数を変数 map2 にセットし、それから map2 を関数呼び出しします。次の例は、map() の返り値を直接関数呼び出ししています。カッコが多くなりますが、2 引数の map() と同じように呼び出すことができます。これでもリストの要素を 2 乗することができます。
</p>
<p> 2 番目の例は、最初の引数を受け取って新しい関数を生成して返し、その関数に次の引数を適用して値を求めるという動作になります。このように、関数の引数が一つでも、「関数を返す関数」を使うことで、複数の引数を処理することができます。このような関数を「カリー化関数 (curried function) 」といいます。
</p>
<p> 関数型言語には、カリー化関数をサポートしているプログラミング言語、たとえば Haskell や ML (SML/NJ, Ocaml) などがあります。これらのプログラミング言語では、高階関数はカリー化関数として定義されています。また、関数を合成して新しい関数を作ることも簡単にできます。
</p>
<h4>●ジェネレータ</h4>
<p> クロージャの応用例として「ジェネレータ (generator) 」というプログラムを紹介しましょう。ジェネレータは、呼び出されるたびに新しい値を生成していきます。たとえば、JavaScript の関数 Math.random() は実行するたびに乱数を返します。つまり、random() は乱数列を発生する「ジェネレータ」と考えることができます。
</p>
<p> 簡単な例題として、奇数列 ( 1, 3, 5, ..... ) を発生するジェネレータを作ってみます。関数名は gen_odd_number としましょう。グローバル変数を使うと、次のようになります。
</p>
<pre>
&gt; function gen_odd_number() { return prev_number += 2; }
undefined
&gt; prev_number = -1
-1
&gt; gen_odd_number()
1
&gt; gen_odd_number()
3
&gt; gen_odd_number()
5
</pre>
<p> グローバル変数 prev_number は、gen_odd_number() が返した値を記憶します。新しい値は、この prev_number に 2 を足せばいいのです。
</p>
<p> このように、グローバル変数を使うと簡単にジェネレータを作ることができますが問題点もあります。それは、複数のジェネレータが必要になる場合です。単純に考えると、必要な数だけグローバル変数と関数を用意すればいいのですが、数が増えるとグローバル変数や関数を定義するだけでも大変な作業になります。
</p>
<p> ところがクロージャを使うと、もっとスマートにジェネレータを用意できます。まず、ジェネレータを作る関数を定義します。
</p>
<pre class="list">
リスト : ジェネレータを作る関数

function make_gen_odd_number() {
    var prev_number = -1:
    return function() { return prev_number += 2; }
}
</pre>

<p> 関数 make_gen_odd_number() はクロージャを返します。そして、このクロージャがジェネレータの役割を果たすのです。それでは、実際に実行してみましょう。
</p>
<pre>
&gt; a = make_gen_odd_number()
function () { return prev_number += 2; }
&gt; a()
1
&gt; a()
3
&gt; a()
5

&gt; b = make_gen_odd_number()
function () { return prev_number += 2; }
&gt; b()
1
&gt; b()
3
&gt; b()
5
</pre>

<p> make_gen_odd_number() で作成したクロージャを変数 a にセットして実行します。実行するたびに 1, 3, 5 と奇数列を生成していますね。次に新しいクロージャを変数 b にセットします。このクロージャを実行すると、新しい奇数列を生成します。確かにジェネレータとして動作しています。
</p>
<p> このプログラムのポイントは、ローカル変数 prev_number です。クロージャで保存される環境は変数 prev_number です。この値は make_gen_odd_number が実行されたときに -1 で初期化されています。クロージャにはこの値が保存されます。次は a にセットしたクロージャを実行します。匿名関数はクロージャに保存されたローカル変数にアクセスするので、prev_number += 2 の値は 1 になり、クロージャに保持されている prev_number の値は 1 に更新されます。
</p>
<p> 環境はクロージャによって異なります。a のクロージャが評価されると、そのクロージャの環境が更新されるのであって、ほかのクロージャに影響を与えることはありません。したがって、ジェネレータが発生する奇数列が、ほかのジェネレータに影響を与えることはないのです。あとは必要な数だけジェネレータを make_gen_odd_number() で作り、そのクロージャを変数に格納しておけばいいわけです。 
</p>

<h4>●クロージャを使うときの注意点</h4>
<p> ところで、クロージャが保存するのは「環境」なので、JavaScript のように変数の値を書き換えることができるプログラミング言語でクロージャを使うときには注意が必要です。次のリストを見てください。
</p>

<pre class="list">
リスト : 繰り返しで複数の関数を生成

func = [];

function make_func() {
    for (var i = 0; i &lt; 5; i++) {
        func.push(function() { console.log("foo" + i + "call"); });
    }
}
</pre>
<p> make_func は匿名関数でクロージャを 5 つ生成し、それを配列 func に格納します。匿名関数の中ではレキシカル変数 i を参照します。配列に格納されたクロージャを実行すると、次のようになりました。
</p>
<pre>
&gt; make_func()
undefined
&gt; func[0]();
foo5call
undefined
&gt; func[1]();
foo5call
undefined
&gt; func[2]();
foo5call
undefined
&gt; func[3]();
foo5call
undefined
&gt; func[4]();
foo5call
</pre>
<p> どのクロージャも foo5call と表示されました。関数 make_func() を評価するとき、その環境にローカル変数 i が追加されます。生成する 5 つのクロージャはこの環境を保存することになります。つまり、make_func() と生成するクロージャは環境を共有しているので、変数 i は同じものになります。make_func() で変数 i の値を書き換えると、クロージャで保持している i の値も当然変わります。したがって、どのクロージャでも変数 i の値は make_func() が書き換えた 5 になるのです。
</p>
<p> この場合、再帰呼び出しを使うとうまくいきます。
</p>
<pre class="list">
リスト : 再帰呼び出しで複数の関数を生成

function make_func1(i) {
    if (i &lt; 5) {
        func.push(function() { console.log("foo" + i + "call"); });
        make_func1(i + 1);
    }
}
</pre>
<p> 関数 make_func1() を再帰呼び出しするたびに新しい環境が生成され、そこに引数 i が追加されます。クロージャはこの環境を保持するので、個々のクロージャに保存される環境は別のものになり、参照する変数 i の値は make_func1() を呼び出したときの値になります。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; make_func(1)
undefined
&gt; func[0]()
foo0call
undefined
&gt; func[1]()
foo1call
undefined
&gt; func[2]()
foo2call
undefined
&gt; func[3]()
foo3call
undefined
&gt; func[4]()
foo4call
undefined
</pre>
<p> 正常に動作していますね。
</p>
<p> なお、SML/NJ, OCaml, Haskell などの関数型言語は、関数の引数や変数の値を書き換えることができません。手続き型言語は代入により変数の値を書き換えることができますが、純粋な関数型言語に代入操作はありません。当然ですが、クロージャに保存された変数の値も書き換えることはできません。ご注意くださいませ。
</p>
<h4>●たらいまわし関数</h4>
<p> 最後に、再帰を使った面白い関数を紹介しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数

function tarai(x, y, z) {
    if (x &lt;= y) return y;
    return tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y));
}

function tak(x, y, z) {
    if (x &lt;= y) return z;
    return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y));
}
</pre>

<p> tarai や tak は「たらいまわし関数」といって、再帰的に定義されている関数です。これらの関数は Lisp などでベンチマークとして利用されることがあります。オリジナルプログラムは Web サイト <a href="http://www.nue.org/nue/index.html">ぬえ 鵺 NUE</a> の TAK Function をお読みください。
</p>
<p> tarai は通称「竹内関数」と呼ばれていて、日本の代表的な Lisper である竹内郁雄氏によって考案されたそうです。そして、tak は tarai のバリエーションで、John Macarthy 氏によって作成されたそうです。たらいまわし関数がベンチマークで使われることは M.Hiroi も知っていましたが、このような由緒ある関数だとは思ってもいませんでした。
</p>
<p> それでは、たらいまわし関数を Google Chrome で実行してみましょう。実行時間を求めるため Date.now() を使います。
</p>
<pre class="list">
リスト : 時間計測

function test(f, x, y, z) {
    var s = new Date().getTime();
    console.log(f(x, y, z));
    var e = new Date().getTime();
    console.log(e - s);
}
</pre>
<p> このメソッドは現在時刻をミリ秒単位で求めることができます。結果は次のようになりました。
</p>
<pre class="item">
tarai(14, 7, 0) : 2.69 秒
tak(22, 11, 0)  : 2.96 秒
</pre>
<p> 他の Web ブラウザでは異なる結果になるかもしれません。興味のある方は試してみてください。
</p>
<h4>●メモ化による高速化</h4>
<p> たらいまわし関数が遅いのは、同じ値を何度も計算しているためです。この場合、表 (table) を使って処理を高速化することができます。同じ値を何度も計算することがないように、計算した値は表に格納しておいて、2 回目以降は表から計算結果を求めるようにします。このような手法を「表計算法」とか「メモ化」といいます。
</p>
<p> JavaScript は関数型言語の機能を備えているので、関数を「メモ化」するメモ化関数を簡単に作成することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : メモ化関数

function memoize(func) {
    var table = {};
    function _memo_func() {
        var key = "";
        for (var i = 0; i &lt; arguments.length; i++) key += arguments[i] + ",";
            if (!table[key]) {
                table[key] = func.apply(null, arguments);
            }
        return table[key];
    }
    return _memo_func;
}
</pre>

<p> 関数 memoize() は関数 func() を引数に受け取り、それをメモ化した関数を返します。memoize() は局所関数 _memo_func() を返すので、その中で memoize() の引数 func やローカル変数 table にアクセスすることができます。
</p>
<p> arguments は配列のようなオブジェクトですが、厳密な意味で配列ではありません。このため、arguments をそのままハッシュ表 table のプロパティ名 (キー) として使うことはできません。そこで、要素を文字列に変換してカンマ ( , ) で連結したものを変数 key にセットします。JavaScript の演算子 + は文字列の連結に使うことができます。このとき、文字列以外のオブジェクトは文字列に変換されます。
</p>
<p> table[key] が偽の場合は func を呼び出して値を求めます。apply() は関数オブジェクトのメソッドで、配列の要素を引数に展開して呼び出すことができます。グローバルな関数を呼び出す場合、apply() の第 1 引数は null または undefined を指定します。メソッドを呼び出す場合は第 1 引数にオブジェクトを指定します。あとは table[key] の値を返すだけです。
</p>
<p> 関数 memoize() の使い方は簡単です。次の例を見てください。
</p>
<pre class="list">
リスト : メモ化関数の使い方

tarai = memoize(tarai);
tak = memoize(tak);
</pre>

<p> とても簡単ですね。それでは実際に実行してみましょう。
<pre class="item">
tarai(14, 7, 0)    : 0.018 秒
tarai(200, 100, 0) : 0.128 秒
tak(22, 11, 0)     : 0.015 秒
tak(200, 100, 0)   : 0.331 秒
</pre>
<p> このようにメモ化すると、たらいまわし関数はとても速くなります。
</p>
<h4>●遅延評価による高速化</h4>
<p> 関数 tarai() は「遅延評価」を行う処理系、たとえば関数型言語の Haskell では高速に実行することができます。また、Scheme でも delay と force を使って遅延評価を行うことができます。
</p>
<p> tarai のプログラムを見てください。x &lt;= y のときに y を返しますが、このとき引数 z の値は必要ありませんね。引数 z の値は x &gt; y のときに計算するようにすれば、無駄な計算を省略することができます。なお、関数 tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意くださいませ。
</p>
<p> 完全ではありませんが、JavaScript でもクロージャを使って遅延評価を行うことができます。次のリストを見てください。
</p>
<pre class="list">
リスト : クロージャによる遅延評価

function tarai(x, y, z) {
    if (x &lt;= y) return y;
    var zz = z();
    return tarai(tarai(x - 1, y, function() { return zz; }),
                 tarai(y - 1, zz, function() { return x; }),
                 function() { return tarai(zz - 1, x, function() { return y; }); });
}
</pre>
<p> 遅延評価したい処理をクロージャに包んで引数 z に渡します。そして、x &gt; y のときに引数 z を評価 (関数呼び出し) します。すると、クロージャ内の処理が実行されて z の値を求めることができます。たとえば、function(){ return 0; } を z に渡す場合、z() とすると返り値は 0 になります。function(){ return x; } を渡せば、x に格納されている値が返されます。function(){ return tarai( ... ); } を渡せば、関数 tarai が実行されてその値が返されるわけです。
</p>
<p> それでは、実際に実行してみましょう。tarai(400, 200, 0) という大きな値を与えて実行しました。
<PRE class="item">
tarai(400, 200, function() { return 0; }) : 0.015 秒
</pre>
<p> このように、たらいまわし関数は遅延評価でも高速化することができます。
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010-2015 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="js02.html">PrevPage</a> | <a href="javascript.html">JavaScript</a> | <a href="js04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>