<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / 整列 (sorting)</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881792</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>整列 (sorting) [1]</h2>
<div class="small">
[ <a href="pyalgo05.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo07.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 整列 (sorting) は、ある規則に従ってデータを順番に並べ換える操作です。たとえば、データが整数であれば大きい順に並べる、もしくは小さい順に並べます。一般に、このような操作を「ソート」と呼んでいます。ソートは昔から研究されている分野で、優秀なアルゴリズムが確立しています。このページでは単純なソートから高速なソートまで、いろいろなソートアルゴリズムを取り上げることにします。
</p>

<p> ソートは大きく分けると、内部ソート (internal sort) と外部ソート (external sort) にわかれます。内部ソートはすべてのデータをメモリに読み込んでソートします。外部ソートはメモリにすべて読み込むことができない巨大なデータをソートするときに使われ、外部記憶装置に途中経過を記憶させながらソートします。
</p>

<p> 今回作成するプログラムは内部ソートで、データは整数値とします。データは配列 (Python ではリスト) に格納します。データは乱数のほかにも、山型データ (中央のデータがいちばん大きく端にいくほど小さいデータになる)、ソート済みのデータ (昇順)、逆順にソートされたデータ (降順) の 4 種類を用意して、実行時間を比較してみましょう。これらのデータは次のプログラムで簡単に作成することができます。
</p>

<pre class="list">
リスト : データの生成

  # x は生成するデータの個数
  # 乱数
  a = [random.randint(0, 100000) for y in xrange(x)]
  # 昇順
  b = range(x)
  # 降順
  c = range(x, 0, -1)
  # 山型
  d = range(x/2) + range(x/2, 0, -1)
</pre>

<p> なお、プログラムの実行時間は、筆者のコーディング、実行したマシン、使用するプログラミング言語（またはコンパイラ）などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間は大きく左右されます。たとえば、高速なソートアルゴリズムとして有名な「クイックソート」の場合、データによっては実行時間が要素数の 2 乗に比例する最悪のケースが存在します。どのようなデータに対しても最速を誇るソートアルゴリズムは存在しません。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>

<h4>●ソートの安定性</h4>
<p> 次に、ソートの安定性について説明します。安定 (stable) なソートとは、ソートキーが等しい場合、入力された順番が崩れないソートのことです。逆に、不安定なソートとは、入力された順番とは異なる結果になるソートのことです。次の図を見てください。
</p>
<pre class="fig">
  元のデータ      安定なソート    不安定なソード

  (123, 'abc')    (123, 'abc')    (789, 'abc')
  (456, 'def')    (789, 'abc')    (123, 'abc')
  (789, 'abc')    (456, 'def')    (456, 'def')

                図 : ソートの安定性
</pre>
<p> 2 番目の要素をキーにソートした場合、1 行目と 3 行目はソートキーが等しいですね。安定なソートであればソート結果が 1, 3, 2 の順番になり、入力時の位置関係が保たれています。不安定なソートはソート結果が、たとえば 3, 1, 2 の順番となり、入力時の位置関係が崩れます。
</p>
<p> 実用的なアプリケーションを作成する場合、ソートの安定性が重要になる場合があります。一般に、単純なソート（遅いソート）は安定で、複雑なソート（高速なソート）は安定ではない、という傾向があります。
</p>
<hr>
<h4>●バブルソート</h4>
<p> 最初は、単純なソートから説明しましょう。バブルソート (buble sort) は泡がぶくぶくと浮いてくるように、いちばん小さいデータが後ろから前に浮かび上がってくるアルゴリズムです。
</p>
<p> 隣接する 2 つのデータを比較して、順序が逆であれば入れ換えます。これを順番に後ろから前に行っていけば、いちばん小さなデータは頂上に浮かび上がっているというわけです。先頭が決まったならば、残りのデータに対して同じことを行えば、2 番目には残りのデータの中でいちばん小さいものが浮かび上がってきます。これをデータ数だけ繰り返せばソートが完了します。
</p>
<pre class="fig">
 9 5 3 7 6 4 8   交換しない
           ~~~
 9 5 3 7 6 4 8   交換する
         ~~~
 9 5 3 7 4 6 8   交換する
       ~~~
 9 5 3 4 7 6 8   交換しない
     ~~~
 9 5 3 4 7 6 8   交換する
   ~~~
 9 3 5 4 7 6 8   交換する
 ~~~
 3 9 5 4 7 6 8   いちばん小さいデータが決定する
 +               残りのデータに対して同様な操作を行う

    図 : バブルソート
</pre>
<p> これをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : バブルソート

def buble_sort(buff):
    k = len(buff) - 1
    for i in xrange(k):
        for j in xrange(k, i, -1):
            if buff[j - 1] &gt; buff[j]:
                temp = buff[j]
                buff[j] = buff[j - 1]
                buff[j - 1] = temp
</pre>
<p> 最初のループで k 回 (データの個数 - 1) だけ繰り返します。2 番目のループで buff の後ろから前に向かって、確定していないデータを比較していき、もしも順番が逆になっていたら交換します。とても簡単ですね。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : buble sort の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
----------------------------------
1000 :  0.297  0.156  0.423  0.309
2000 :  1.178  0.623  1.699  1.171
4000 :  4.683  2.495  6.805  4.650
8000 : 18.743 10.016 27.145 18.642

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> バブルソートは簡単なアルゴリズムですが、データ数が多くなると時間がかかります。データ数を n とすると実行時間は n の 2 乗に比例します。バブルソートは安定なソートですが遅いアルゴリズムなのです。
</p>
<hr>
<h4>●挿入ソート</h4>
<p> 挿入ソート (insert sort) は拙作のページ <a href="python02.html">Python 入門講座第 2 回</a> で取り上げましたが、ここでも簡単に説明しておきましょう。挿入ソートはソート済みの配列に新しいデータを挿入していくことでソートします。最初は先頭のデータひとつがソート済みと考え、2 番目のデータをそこに挿入することからスタートします。データを挿入するので、そこにあるデータをどかさないといけません。そこで、挿入位置を決めるため後ろから順番に比較するとき、いっしょにデータの移動も行うことにします。
</p>
<pre class="fig">
 [9] 5 3 7 6 4 8    5 を取り出す

 [9] * 3 7 6 4 8    5 を[9]の中に挿入する

 [5 9] 3 7 6 4 8    9 をひとつずらして先頭に 5 を挿入

 [5 9] * 7 6 4 8    3 を取り出して[5 9]の中に挿入する

 [3 5 9] 7 6 4 8    先頭に 3 を挿入

 [3 5 9] * 6 4 8    7 を取り出して[3 5 9] に挿入

 [3 5 7 9] 6 4 8    9 を動かして 7 を挿入
                    残りの要素も同様に行う

        図 : 挿入ソート
</pre>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 挿入ソート

def insert_sort(buff):
    k = len(buff)
    for i in xrange(1, k):
        temp = buff[i]
        j = i - 1
        while j &gt;= 0 and temp &lt; buff[j]:
            buff[j + 1] = buff[j]
            j -= 1
        buff[j + 1] = temp
</pre>
<p> 最初のループで挿入するデータを選びます。ソート開始時は先頭のデータひとつがソート済みと考えるるので、2 番目のデータ（添字では 1）を取り出して挿入していきます。2 番目のループで挿入する位置を探しています。探索は後ろから前に向かって行います。このとき、挿入位置の検索と同時にデータの移動も行っています。ループが最後まで回れば、そのデータは先頭に挿入されることになります。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : insert sort の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
----------------------------------
1000 :  0.130  0.001  0.265  0.134
2000 :  0.543  0.001  1.067  0.535
4000 :  2.168  0.003  4.278  2.142
8000 :  8.560  0.006 17.140  8.576
</pre>
<p> 挿入ソートも実行時間はデータの個数の 2 乗に比例します。挿入ソートは遅いソートですが安定です。
</p>
<p> ところで、このソートは興味深い特性をもっています。昇順（ソート済み）データの結果をみると、とても速いことがわかります。データがソートされていれば、2 番目のループは繰り返しを行わずに終了するため、最初のループの繰り返し回数でソートが完了することになります。したがって、与えられたデータが大まかにでもソートされていれば、2 番目のループで繰り返す回数が少なくなり、挿入ソートでも高速にソートすることができます。
</p>
<hr>
<h4>●選択ソート</h4>
<p> 選択ソート (selection sort) は、ソートしていないデータの中から最小値（または最大値）を見つけ、それを先頭のデータと交換する、という手順を繰り返すことでソートを行います。最初は、すべてのデータの中から最小値を探し、それを配列の先頭 buff[0] と交換します。次は、buff[1] 以降のデータの中から最小値を探し、それを buff[1] と交換します。これを繰り返すことでソートすることができます。
</p>

<pre class="fig">
 [9 5 3 7 6 4 8]   3 と 9 を交換する
  +   +

 3 [5 9 7 6 4 8]   5 と 4 を交換する
    +       +

 3 4 [9 7 6 5 8]   9 と 5 を交換する
      +     +

 3 4 5 [7 6 9 8]   7 と 6 を交換する
        + +

 3 4 5 6 [7 9 8]   7 と 7 を交換する
          +

 3 4 5 6 7 [9 8]   9 と 8 を交換してソート終了
            + +

  図 : 選択ソート
</pre>
<p> このように、選択ソートは単純でわかりやすいアルゴリズムです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 選択ソート

def select_sort(buff):
    k = len(buff)
    for i in xrange(k - 1):
        min = buff[i]
        n = i
        for j in xrange(i + 1, k):
            if buff[j] &lt; min:
                min = buff[j]
                n = j
        buff[n] = buff[i]
        buff[i] = min
</pre>
<p> データの個数を変数 k にセットします。最初のループで変数 i の値は 0 から k - 1 まで動きます。2 番目のループで buff[i] から buff[k - 1] までの中から最小値を探し、それを buff[i] と交換します。最小値とその位置は変数 min と n に格納します。2 番目のループを終了したら、buff[i] と buff[n] の値を交換します。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : selection sort の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
----------------------------------
1000 :  0.078  0.078  0.108  0.088
2000 :  0.310  0.308  0.420  0.347
4000 :  1.234  1.227  1.679  1.387
8000 :  4.929  4.903  6.701  5.546

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 選択ソートも実行時間はデータの個数の 2 乗に比例します。選択ソートは遅いソートですが安定です。
</p>
<p> 選択ソートと挿入ソートを比較すると、データの比較回数は挿入ソートのほうが少なくなり（平均すると約半分になる）、データの移動回数は選択ソートの方が少なくなります。今回は選択ソートの方が速くなりましたが、使用するプログラミング言語やデータの種類によっては、結果が異なる場合もあるでしょう。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4>●Appendix A</h4>
<p> ご参考までにＣ言語のプログラムと実行時間を示します
</p>
<pre class="list">
リスト : Ｃ言語のプログラム

/* バブルソート */
void buble_sort(int *buff, int size)
{
  int i, j;
  for(i = 0; i &lt; size; i++){
    for(j = size - 1; j &gt; i; j-- ){
      if(buff[j] &lt; buff[j - 1]){
        int temp = buff[j];
        buff[j] = buff[j - 1];
        buff[j - 1] = temp;
      }
    }
  }
}

/* 挿入ソート */
void insert_sort(int *buff, int size)
{
  int i;
  for(i = 1; i &lt; size; i++){
    int j, temp = buff[i];
    for(j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; buff[j]; j--){
      buff[j + 1] = buff[j];
    }
    buff[j + 1] = temp;
  }
}

/* 選択ソート */
void select_sort(int *buff, int size)
{
  int i, j;
  for(i = 0; i &lt; size - 1; i++){
    int min = buff[i];
    int n = i;
    for(j = i + 1; j &lt; size; j++){
      if(buff[j] &lt; min){
        min = buff[j];
        n = j;
      }
    }
    buff[n] = buff[i];
    buff[i] = min;
  }
}
</pre>
<pre>
  表 : buble sort の結果 (単位 : 秒)

 個数   乱数   昇順   逆順   山型
----------------------------------
 5000 : 0.094  0.016  0.047  0.031
10000 : 0.344  0.094  0.172  0.125
20000 : 1.390  0.391  0.641  0.516
40000 : 5.562  1.594  2,516  2.047


  表 : insert sort の結果 (単位 : 秒)

 個数   乱数   昇順   逆順   山型
----------------------------------
 5000 : 0.016  0.000  0.032  0.016
10000 : 0.079  0.000  0.141  0.078
20000 : 0.281  0.000  0.579  0.297
40000 : 1.141  0.000  2.313  1.156


  表 : selection sort の結果 (単位 : 秒)

 個数   乱数   昇順   逆順   山型
----------------------------------
 5000 : 0.032  0.031  0.031  0.031
10000 : 0.094  0.110  0.125  0.110
20000 : 0.422  0.422  0.500  0.453
40000 : 1.703  1.703  2.000  1.797

実行環境 : Windows XP, celeron 1.40 GHz, Borland C++ 5.5.1 for Win32
</pre>
<hr>
<h4>●シェーカーソート</h4>
<p> バブルソートは泡がぶくぶくと浮いてくるように、いちばん小さいデータが後ろから前へ浮かび上がってきます。シェーカーソート (shaker sort) は、いちばん小さなデータが浮かび上がるところはバブルソートと同じですが、その次はいちばん大きなデータを沈める操作を行います。そして、これ交互に繰り返すことでデータをソートします。つまり、双方向でパブルソートを行うわけです。次の図を見てください。
</p>
<pre class="fig">
 9 5 3 7 6 4 8   交換しない | 3 9 5 4 7 6 8   交換する 
           ~~~              | + ~~~
 9 5 3 7 6 4 8   交換する   | 3 5 9 4 7 6 8   交換する 
         ~~~                | +   ~~~
 9 5 3 7 4 6 8   交換する   | 3 5 4 9 7 6 8   交換する 
       ~~~                  | +     ~~~
 9 5 3 4 7 6 8   交換しない | 3 5 4 7 9 6 8   交換する 
     ~~~                    | +       ~~~
 9 5 3 4 7 6 8   交換する   | 3 5 4 7 6 9 8   交換する 
   ~~~                      | +         ~~~
 9 3 5 4 7 6 8   交換する   | 3 5 4 7 6 8 9   決定
 ~~~                        | +           +
 3 9 5 4 7 6 8   決定       |
 +                          |

                  図：シェーカーソート
</pre>

<p> 左側の図に小さなデータが浮かび上がってくる様子を、右側の図に大きなデータが沈んでいく様子を示します。あとは、これを繰り返すだけです。とても簡単ですね。
</p>

<p> では、これで本当にバブルソートの性能を改善できるのでしょうか。答えはなんと <b>NO</b> なのです。これだけでは、実をいうと改善どころか改悪になってしまいます。シェーカーソートを有効に機能させるには、もうひとつ改良すべきポイントがあるのです。次の例を見てください。
</p>
<pre class="fig">
   4 5 6 7 8 9 3   交換する
             ~~~
   ・・省略・・

   3 4 5 6 7 8 9   3 を決定
   +

   3 4 5 6 7 8 9   交換しない
   +         ~~~

   ・・省略・・    一度もデータを交換しない

   3 4 5 6 7 8 9   4 を決定 =&gt; ソート終了
   + +
</pre>
<p> この例の場合、3 を先頭に移動すればソートが完了しますね。バブルソートの場合、データの交換がまったく行われなければ、ソートは完了したと判断することができます。この例では 3 を先頭に移動したあと、さらにバブルソートを続けますが、データの交換は行われずに次のデータ 4 が決まりますね。ここでソートを終了してよいのです。
</p>

<p> また、バブルソートの場合、最後にデータを交換した位置よりも前のデータはソート済みであることがわかります。したがって、その位置を記憶しておくことで、無駄な処理を省くことができます。シェーカーソートといっしょにこれらの改良方法もあとで試してみましょう。
</p>

<p> このように、バブルソートはデータの並び方によって高速にソートできる場合があります。それでは、次のデータはどうなるのでしょうか。
</p>
<pre class="fig">
   9 4 5 6 7 8 3   交換する
             ~~~
   ・・省略・・

   3 9 4 5 6 7 8   3 を決定
   +

   3 9 4 5 6 7 8   交換しない
   +         ~~~

   ・・省略・・    データの交換は無い

   3 9 4 5 6 7 8   データを交換するのでソートは終了しない
   + ~~~
</pre>
<p> 先頭にいちばん大きなデータ 9 があるので、途中でソートを終了することはできません。ところが、ここで 9 を最後尾に移動させればソートが完了しますね。もうお気づきだと思いますが、このような場合シェーカーソートを使えばうまくいきます。データ 3 を決定したあと、シェーカーソートではいちばん大きなデータを沈めるので、データ 9 が最後尾に移動します。そのあと、今度はいちばん小さなデータを浮かべますが、データを交換することはないのでソートを終了することができる、というわけです。
</p>
<p> たとえば、データ 9, 5, 3, 7, 6, 4, 8 をシェーカーソートすると、次のようになります。
</p>
<pre class="fig">
    9 5 3 7 6 4 8

    3 9 5 4 7 6 8   3 を決定
    +            

    3 5 4 7 6 8 9   9 を決定
    +           +

    3 4 5 6 7 8 9   4 を決定
    + +         +

    3 4 5 6 7 8 9   8 を決定、データ交換が無いので終了
    + +       + +
</pre>
<p> 双方向でバブルソートすることにより、小さなデータは左側へ、大きなデータは右側へ移動していく様子がよくわかると思います。
</p>

<h4>●シェーカーソートのプログラム</h4>
<p> まずはバブルソートの改良版から作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : バブルソートの改良

def buble_sort(buff):
    k = len(buff) - 1
    while k &gt;= 0:
        j = -1
        for i in xrange(1, k + 1):
            if buff[i - 1] &gt; buff[i]:
                j = i - 1
                temp = buff[j]
                buff[j] = buff[i]
                buff[i] = temp
        k = j
</pre>
<p> 改良版では、変数 k にデータを交換した位置を記憶しておきます。k の値が -1 であれば、データは一度も交換されなかったのでソートを終了します。
</p>

<p> 次はシェーカーソートを作ります。
</p>
<pre class="list">
リスト : シェーカーソート

def shaker_sort(buff):
    low = 0
    high = len(buff) - 1
    j = -1
    while low &lt; high:
        for i in xrange(low, high):
            if buff[i] &gt; buff[i + 1]:
                temp = buff[i]
                buff[i] = buff[i + 1]
                buff[i + 1] = temp
                j = i
        high = j
        for i in xrange(high, low, -1):
            if buff[i - 1] &gt; buff[i]:
                temp = buff[i - 1]
                buff[i - 1] = buff[i]
                buff[i] = temp
                j = i
        low = j
</pre>

<p> 変数 low と high はソートする区間を表します。low より前のデータと high より後ろのデータはソート済みです。low &lt; hight ならばデータがあるのでソートを続けます。データを交換した位置は変数 j に記憶しておきます。前半の for ループが大きなデータを沈める処理で、後半の for ループが小さなデータを浮かべる処理です。ループが終了したら、high と low の値を j に書き換えます。データが一度も交換されなかった場合、条件 low &lt; high を満たさなくなるのでソートが終了します。あとはとくに難しいところはないでしょう。
</p>

<p> それでは実行結果を示します。
</p>

<pre>
  表 : buble sort (改良版) の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
----------------------------------
1000 :  0.282  0.000  0.405  0.282
2000 :  1.137  0.001  1.640  1.132
4000 :  4.587  0.001  6.624  4.549
8000 : 18.355  0.002 26.470 18.208


  表 : shaker sort の結果

個数    乱数   昇順   逆順   山型 (単位 : 秒)
----------------------------------
1000 :  0.260  0.000  0.446  0.248
2000 :  1.007  0.001  1.783  0.985
4000 :  4.039  0.001  7.131  3.955
8000 : 16.090  0.003 28.532 15.786

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>

<p> バブルソートの改良により、昇順データは挿入ソートと同様に高速になりました。しかしながら、他のデータはほとんど変わりませんでした。シェーカーソートの場合、昇順データは挿入ソートと同様に高速になり、乱数データと山型データではバブルソートよりは少しですが高速になりました。シェーカーソートの効果は出ていると思いますが、遅いソートには変わりありません。なお、シェーカーソートは安定なソートです。
</p>
<hr>
<h4>●シェルソート</h4>
<p> シェルソート (shell sort) は挿入ソートの改良版ともいえる方法です。最初は遠く離れた要素間でソートを開始し、徐々に間隔を狭めていきます。最後は隣り合った要素間でソートします。つまり、単純挿入ソートと同じになります。
</p>
<p> 間隔が大きいときは要素の個数が少ないので、単純なアルゴリズムでもソートにかかる時間は少なくてすみます。間隔が小さくなると要素の個数は多くなりますが、大まかにソートされているので挿入ソートでも高速にソートすることが可能です。
</p>
<pre class="fig">
 9 5 3 7 6 4 2 8  最初の状態

 9       6        間隔を 4 で分割する
   5       4
     3       8
       7       2

 6       9        各群をソートする
   4       5
     3       8
       2       7

 6   3   9   8    間隔を 2 で分割する
   4   2   5   7

 3   6   8   9    各群をソートする
   2   4   5   7

 3 2 6 4 8 5 9 7  間隔を 1 で分割する（単純挿入ソートと同じ）

 2 3 4 5 6 7 8 9  ソート完了

  図 : シェルソート
</pre>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : シェルソート

def shell_sort0(buff):
    k = len(buff)
    gap = k / 2
    while gap &gt; 0:
        for i in xrange(gap, k):
            temp = buff[i]
            j = i - gap
            while j &gt;= 0 and temp &lt; buff[j]:
                buff[j + gap] = buff[j]
                j -= gap
            buff[j + gap] = temp
        gap /= 2
</pre>
<p> 最初のループで間隔を徐々に狭めていきます。ここでは単純に 2 で割っていくことにしました。次のループで比較する要素を取り出します。最後のループでこの要素を挿入する位置を探索します。このときの探索は隣り合った要素ではなく gap 離れた要素を比較します。
</p>
<p> 2 番目のループでは、各群を並列にソートしていることに注意してください。群のひとつの要素を取り出して位置を決めたら、次の群の要素を取り出して位置を決めています。最後に gap は 1 になるので、挿入ソートと同じになりソートが完了します。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : shell sort の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
----------------------------------
1000 :  0.011  0.006  0.009  0.007
2000 :  0.025  0.013  0.019  0.017
4000 :  0.057  0.030  0.044  0.037
8000 :  0.137  0.066  0.094  0.081

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 結果を見ればお分かりのように、シェルソートは速いですね。gap を常に奇数になるようにすると、シェルソートの実行速度はデータの個数 n の 1.5 乗に比例します。また、Knuth によると、gap の値に次の数列を用いると、シェルソートは n の 1.25 乗に比例するそうです。
</p>
<pre class="fig">
gap = ..., 121, 40, 13, 4, 1
</pre>
<p> この数列は 3 倍して 1 を加えることで得られる数列を逆にしたものです。これをプログラムすると、次のようになります。
</p>

<pre class="list">
リスト : シェルソートの改良版

def shell_sort(buff):
    k = len(buff)
    gap = 1
    while gap &lt; k / 9: gap = gap * 3 + 1
    while gap &gt; 0:
        for i in xrange(gap, k):
            temp = buff[i]
            j = i - gap
            while j &gt;= 0 and temp &lt; buff[j]:
                buff[j + gap] = buff[j]
                j -= gap
            buff[j + gap] = temp
        gap /= 3


</pre>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : shell sort (改良版) の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
-----------------------------------
1000 :  0.009  0.004  0.007  0.006
2000 :  0.021  0.009  0.014  0.013
4000 :  0.051  0.019  0.033  0.030
8000 :  0.117  0.041  0.075  0.064

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 少しですが速くなっていることがわかります。シェルソートは実装が簡単で、極端に要素数が大きくなければ十分実用になるソートです。なお、シェルソートは不安定なソートです。
</p>
<hr>
<h4>●コムソート</h4>
<p> コムソート (comb sort) はバブルソートの改良版といえる方法です。コームソートと呼ばれることもあります。<a href="http://www.bsdclub.org/~motoyuki/d/d200005c.html#26-1">今野氏の日記</a> より引用します。</p>

<blockquote><cite>
ソートの様子は間隔があいた櫛 (comb) ですいていくのに似ている。 
<ul>
  <li> 最初に間隔が (要素数 / 1.3) の櫛で一度すく。
  <li> 櫛の間隔を 1 / 1.3 しながら繰り返す。
  <li> 櫛の間隔が 1 になったら bubble sort
</ul>
という感じである。 1.3 というのは数多くのデータを sort して実験的に得た数値とのこと。 
</cite></blockquote>
<p> 出典は <cite>『日経バイト 1991 年 11 月号』</cite> とのことです。コムソートの考え方はシェルソートとよく似ています。シェルソートは挿入ソートの改良版といえる方法で、最初は遠く離れた要素間でソートを開始し、徐々に間隔を狭めていきます。そして、最後には隣り合った要素間でソートします。
</p>

<p> シェルソートは実装が簡単で、要素数が極端に多くなければ十分実用になるソートですが、平均すればあとで説明するクイックソートよりも遅くなります。コムソートはシェルソートと同様の手法で改良を行っているようですが、それでどの程度の速さになるのかとても興味があります。
</p>
<p> さっそくプログラムを作ってみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト：コムソート

def comb_sort(buff):
    k = len(buff)
    gap = k
    done = False
    while gap &gt; 1 or not done:
        gap = (gap * 10) / 13
        if gap == 0: gap = 1
        elif gap == 9 or gap == 10: gap = 11
        done = True
        for i in xrange(k - gap):
            if buff[i] &gt; buff[i + gap]:
                temp = buff[i]
                buff[i] = buff[i + gap]
                buff[i + gap] = temp
                done = False
</pre>
<p> gap の間隔でデータを比較していきます。データの順序が逆ならば交換するところはバブルソートと同じです。gap を 1 / 1.3 ずつ狭めていき、gap が 1 になったらバブルソートと同じになります。ここで、変数 done を終了判定のフラグとして使っていることに注意してください。ここがコムソートを理解するポイントです。
</p>
<p> バブルソートの場合、データの交換が行われないときはソートが完了しています。つまり、done が True のままであれば、ソートを終了していいわけです。櫛をすくことでデータはおおまかにソートされるため、バブルソートの途中でソートが完了する可能性は極めて高くなるでしょう。これがコムソートの原理です。
</p>
<p> それから、間隔 gap が 9, 10 の場合には強制的に 11 にすることで、速度が向上するように改良したコムソートを comb sort 11 というそうです。今回のプログラムは comb sort 11 を使っています。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : comb sort の結果 (単位 : 秒)

個数    乱数   昇順   逆順   山型
-----------------------------------
1000 :  0.010  0.007  0.008  0.009
2000 :  0.023  0.016  0.019  0.020
4000 :  0.054  0.034  0.040  0.043
8000 :  0.116  0.077  0.090  0.095

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> バブルソートやシェーカーソートと比べると、コムソートの方が断然速いですね。乱数データではシェルソート (改良版) とほぼ同じ速度になりました。他のデータでは、シェルソートよりも少しだけ遅くなるようです。
</p>
<hr>
<h4>●クイックソート</h4>
<p> 次は高速なソートアルゴリズムとして有名なクイックソート (quick sort) を取り上げます。要素数を N とすると、クイックソートの平均的な実行時間は N * log N に比例しますが、最悪の場合は N の 2 乗に比例する遅いソートになってしまいます。クイックソートは <a href="python03.html#chap03">お気楽 Python プログラミング入門第 3 回</a> で取り上げましたが、ここでも簡単に説明しておきましょう。
</p>

<p> クイックソートはある値を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。2 つに分けた各々の区間を同様に分割して 2 つの区間に分けます。最後は区間の要素がひとつになってソートが完了します。
</p>
<pre class="fig">
  9 5 3 7 6 4 2 8     最初の状態

  9 5 3 7 6 4 2 8     7 を枢軸にして左側から 7 以上の値を探し、
  L           R       右側から 7 以下の値を探す。

  2 5 3 7 6 4 9 8     交換する
  L           R

  2 5 3 7 6 4 9 8     検索する
        L   R

  2 5 3 4 6 7 9 8     交換する
        L   R

  2 5 3 4 6 7 9 8     検索する。R と L が交差したら分割終了。
          R L

  [2 5 3 4 6] [7 9 8] この 2 つの区間について再び同様な分割を行う

                図 : クイックソート
</pre>
<p>  基準になる値のことを「枢軸 (pivot) 」といいます。枢軸は要素の中から適当な値を選びます。今回は中央にある要素を選ぶことにしましょう。上図を見てください。左側から枢軸 7 以上の要素を探し、左側から 7 以下の要素を探します。探索のときは枢軸が番兵の役割を果たすので、ソート範囲外の要素を探索することはありません。見つけたらお互いの要素を交換します。探索位置が交差したら分割は終了です。
</p>
<p>  あとは同じ手順を分割した 2 つの区間に適用します。これは再帰定義を使えば簡単に実現できます。分割した区間の要素数が 1 になったときが再帰の停止条件になります。プログラムは次のようになります。
</p>
<pre class="list">
リスト : クイックソート (1)

def quick_sort(buff, low, high):
    pivot = buff[(low + high) / 2]
    i = low
    j = high
    while True:
        while pivot &gt; buff[i]: i += 1
        while pivot &lt; buff[j]: j -= 1
        if i &gt;= j: break
        temp = buff[i]
        buff[i] = buff[j]
        buff[j] = temp
        i += 1
        j -= 1
    if low &lt; i - 1: quick_sort(buff, low, i - 1)
    if high &gt; j + 1: quick_sort(buff, j + 1, high)
</pre>
<p> 関数 quick_sort の引数 buff がソートするリスト、low が区間の下限値、high が区間の上限値です。quick_sort は buff の low から high までの区間をソートします。最初に、区間の中央にあるデータを枢軸として選びます。そして、最初の while ループで pivot を基準にして区間を 2 つに分けます。
</p>

<p> 次の while ループで、左側から枢軸以上の要素を探しています。ここでは枢軸以上という条件を、枢軸より小さい間は探索位置を進める、というように置き換えています。同様に次の while ループで右側から枢軸以下の要素を探します。お互いの探索位置 i, j が交差したら分割は終了です。break 文で while ループから脱出します。そうでなければお互いの要素を交換します。交換したあとは i と j の値を更新しておくことを忘れないでください。
</p>

<p>  そして、分割した区間に対して quick_sort を再帰呼び出しします。このとき要素数をチェックして、2 個以上ある場合に再帰呼び出しを行います。この停止条件を忘れると正常に動作しません。ご注意ください。
</p>

<p>  クイックソートは、枢軸の選び方で効率が大きく左右されます。区間の中間値を枢軸に選ぶと、区間をほぼ半分に分割することができます。この場合がいちばん効率が良く、データ数を N とすると N * log N に比例する時間でソートすることができます。
</p>

<p>  逆に、区間での最大値または最小値を枢軸に選ぶと、その要素と残りの要素の 2 つに分割にされることになります。これが最悪の場合で、分割のたびに最大値もしくは最小値を選ぶと、実行時間は要素数の 2 乗に比例することになります。つまり、挿入ソートと同じくらい遅いソートになるのです。それだけでなく、要素数が多くなるとスタックがオーバーフローする危険性もあります。
</p>

<p> 今回は区間の中央に位置する要素を枢軸としたので、中央付近に大きい要素があるデータが最悪の場合にあてはまります。つまり、山型データがこのプログラムでは最悪の結果になるのです。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
  表 : quick sort (1) の結果 (単位 : 秒)

 個数   乱数   昇順   逆順   山型
-----------------------------------
 1000 : 0.006  0.002  0.003  0.049
 2000 : 0.013  0.005  0.006  -----
 4000 : 0.027  0.011  0.013  -----
 8000 : 0.058  0.024  0.027  -----
16000 : 0.122  0.052  0.058  -----
32000 : 0.260  0.109  0.121  -----

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 山型データの ----- は、スタックがオーバーフローしたことを示します。データ数が少ない場合、スタックオーバーフローは発生しませんが、実行時間はとても遅くなります。その他のデータでは、とても高速にソートすることができました。やっぱり、クイックソートは速いですね。なお、クイックソートは不安定なソートです。
</p>
<h4>●クイックソートの改良</h4>
<p> それでは、クイックソートのプログラム (1) を改良してみましょう。まずは枢軸の選び方を工夫します。区間の中からいくつかの要素を選び、その中で真ん中の値を持つ要素を枢軸とします。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、真ん中の値を選ぶのに時間がかかってしまいます。そこで、実際には 3 つから 5 つの要素を選んで、その中で真ん中の値を持つ要素を枢軸とする場合が多いようです。
</p>
<p> 次に再帰呼び出しをループに展開します。2 つに分割した区間の長い方を自分で用意したスタックに積み、短い区間からソートしていきます。そうすると、スタックの深さは要素数を N とすると log <sub>2</sub> N 程度におさまります。たとえば、100 万個の要素をソートする場合でも、スタックの大きさは 20 程度あれば十分です。ひとつの区間の処理が終わったら、スタックから次の区間を取り出して処理を行います。これを図に示すと次のようになります。
</p>
<pre class="fig">
                            スタック
 [      A      ][    B     ]  ( )   : 分割する。スタックは最初は空
                              (A)   : A をスタックに積む
                [   C   ][D]  (A)   : B を分割する
                         [D]  (C A) : C をスタックに積む
                         [ ]  (C A) : D をソートする
                [   C   ][ ]  (A)   : C をスタックから取り出す
                [  E ][F][ ]  (A)   : 分割する
                      [F][ ]  (E A) : E をスタックに積む
                      [ ][ ]  (E A) : F をソートする
                [  E ]        (A)   : E をスタックより取り出す

     ・・・・・あとはスタックが空になるまで繰り返す・・・・・

                 図 : クイックソートでのスタックの動作
</pre>
<p> 最後に、要素数が少なくなったらクイックソートを打ち切ります。そして、最後に挿入ソートで仕上げます。データ数が少ない場合は、クイックソートよりも単純なソートアルゴリズムの方が高速です。また、全体をソートする場合でも、すでに大まかにソートされているので、挿入ソートでも高速にソートすることができます。
</p>

<p> まずは枢軸を選択する関数 select_pivot を作ります。
</p>
<pre class="list">
リスト : 枢軸の選択

def select_pivot(buff, low, high):
    a = buff[low]
    b = buff[(low + high) / 2]
    c = buff[high]
    if a &gt; b:
        tmp = a
        a = b
        b = tmp
    if b &gt; c:
        b = c
        if a &gt; b: b = a
    return b
</pre>
<p> 区間 (low, high) から 3 つの要素を選びます。ここでは 先頭の位置 low、中央の位置 (low + high) / 2、最後尾の位置 high にある要素を選ぶことにしました。そして、a, b, c の中で真ん中の値を選んで返します。
</p>
<p> ところで、枢軸の選択を工夫しても、その方法に対して最悪のデータが存在します。しかしながら、最悪の場合でも再帰呼び出しの削除とスタックの積み方の工夫により、エラーが発生することはありません。ただし、実行時間が遅くなるのは仕方がないところです。なお、<a href="index.html#cite">参考文献 [2]</a> によると、枢軸を乱数で選ぶ方法もあります。興味のある方は試してみてください。
</p>
<p> それでは、クイックソート本体を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : クイックソート (2)

LIMIT = 10

def quick_sort2(buff, low, high):
    stack = []
    while True:
        if high - low &lt;= LIMIT:
            if len(stack) == 0: break
            low, high = stack.pop()
        else:
            pivot = select_pivot(buff, low, high)
            i = low
            j = high
            while True:
                while pivot &gt; buff[i]: i += 1
                while pivot &lt; buff[j]: j -= 1
                if i &gt;= j: break
                temp = buff[i]
                buff[i] = buff[j]
                buff[j] = temp
                i += 1
                j -= 1
            if i - low &gt; high - j:
                stack.append((low, i - 1))
                low = j + 1
            else:
                stack.append((j + 1, high))
                high = i - 1
    insert_sort(buff)
</pre>
<p> 最初に、high - low の値をチェックします。LIMIT (10) 以下になったらクイックソートを打ち切ります。スタック stack にデータがなければ break で while ループを脱出して、最後に挿入ソート (insert_sort) で仕上げます。スタックには区間の上限値と下限値がタプルにまとめてセットされています。スタックにデータがある場合は、それを取り出して low と high にセットし、処理を繰り返します。
</p>
<p> 区間が LIMIT より大きい場合はクイックソートを行います。区間の分割は今までのプログラムと同じです。そして、長い方の区間をスタックにセットして、短い方の区間からクイックソートします。前半部分 (i - low) が長い場合は、(low, i - 1) をスタックに積んで (j + 1, high) をソートします。low の値を j + 1 に書き換えて処理を繰り返します。後半部分が長い場合は、(j + 1, high) をスタックに積んで (low, i - 1) をソートします。この場合は high を i - 1 に書き換えて処理を繰り返します。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
  表 : quick sort (2) の結果 (単位 : 秒)

 個数   乱数   昇順   逆順   山型
-----------------------------------
 1000 : 0.006  0.002  0.003  0.008
 2000 : 0.012  0.005  0.006  0.017
 4000 : 0.025  0.011  0.013  0.039
 8000 : 0.055  0.024  0.028  0.084
16000 : 0.120  0.052  0.058  0.188
32000 : 0.246  0.108  0.120  0.413

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> このように、山型データでもエラーは発生しません。実行速度も非再帰版の方が少しだけ速くなります。
</p>
<hr>
<h4>●Appendix B</h4>
<p> ご参考までにＣ言語のプログラムと実行時間を示します
</p>
<pre class="list">
リスト : Ｃ言語のプログラム

/* シェルソート */
void shell_sort(int *buff, int size)
{
  int gap = 1;
  while(gap &lt; size / 9) gap = gap * 3 + 1;
  for(; gap &gt; 0; gap /= 3){
    int i;
    for(i = gap; i &lt; size; i++){
      int j, temp = buff[i];
      for(j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; buff[j]; j -= gap){
        buff[j + gap] = buff[j];
      }
      buff[j + gap] = temp;
    }
  }
}

/* コムソート */
void comb_sort(int *buff, int size)
{
  int gap = size;
  int done = FALSE;
  while(gap &gt; 1 || !done){
    int i;
    gap = (gap * 10) / 13;
    if(!gap){
      gap = 1;
    } else if(gap == 9 || gap == 10){
      gap = 11;
    }
    done = TRUE;
    for(i = 0; i &lt; size - gap; i++){
      if(buff[i] &gt; buff[i + gap]){
        int temp = buff[i];
        buff[i] = buff[i + gap];
        buff[i + gap] = temp;
        done = FALSE;
      }
    }
  }
}

/* クイックソート */
#define TRUE       1
#define FALSE      0
#define LIMIT      10
#define STACK_SIZE 32

/* 枢軸の選択 */
int select_pivot(int *buff, int low, int high)
{
  int a = buff[low];
  int b = buff[(low + high) / 2];
  int c = buff[high];
  if(a &gt; b){
    int temp = a;
    a = b;
    b = temp;
  }
  if(b &gt; c){
    b = c;
    if(a &gt; b) b = a;
  }
  return b;
}

void quick_sort(int *buff, int size)
{
  int low_stack[STACK_SIZE];
  int high_stack[STACK_SIZE];
  int p = 0;
  int low = 0;
  int high = size - 1;
  while(TRUE){
    if(high - low &lt;= LIMIT){
      if(!p) break;
      low = low_stack[--p];
      high = high_stack[p];
    } else {
      int pivot = select_pivot(buff, low, high);
      int i = low, j = high;
      while(TRUE){
        int temp;
        while(pivot &gt; buff[i]) i++;
        while(pivot &lt; buff[j]) j--;
        if(i &gt;= j) break;
        temp = buff[i];
        buff[i] = buff[j];
        buff[j] = temp;
        i++;
        j--;
      }
      if(i - low &gt; high - j){
        low_stack[p] = low;
        high_stack[p++] = i - 1;
        low = j + 1;
      } else {
        low_stack[p] = j + 1;
        high_stack[p++] = high;
        high = i - 1;
      }
    }
  }
  insert_sort(buff, size);
}
</pre>
<pre>
  表 : shell sort の結果 (単位 : 秒)

  個数    乱数   昇順   逆順   山型
-------------------------------------
 500000 : 0.203  0.047  0.063  0.078 
1000000 : 0.422  0.110  0.141  0.141 
2000000 : 0.984  0.218  0.344  0.328 
4000000 : 2.343  0.485  0.704  0.672 


  表 : comb sort の結果 (単位 : 秒)

  個数    乱数   昇順   逆順   山型
-------------------------------------
 500000 : 0.187  0.079  0.094  0.109 
1000000 : 0.437  0.156  0.219  0.235 
2000000 : 0.937  0.359  0.453  0.500 
4000000 : 2.015  0.781  0.968  1.063 


  表 : quick sort の結果 (単位 : 秒)

  個数    乱数   昇順   逆順   山型
-------------------------------------
 500000 : 0.078  0.016  0.031  0.094 
1000000 : 0.172  0.047  0.063  0.219 
2000000 : 0.375  0.110  0.110  0.469 
4000000 : 0.782  0.219  0.234  1.031 

実行環境 : Windows XP, celeron 1.40 GHz, Borland C++ 5.5.1 for Win32
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo05.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo07.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>