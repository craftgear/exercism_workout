<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Julia プログラミング超入門</title>
  <meta name="description" content="Julia 入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881803</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Julia Language Programming</h1>
<h2>お気楽 Julia プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
<hr>
</div>
<section class="contents">
<h3>Julia の基礎知識</h3>
<h4 id="abc22">●Expr 型と Symbol 型</h4>
<ul>
  <li>Expr は Julia の抽象構文木 (AST) を表すデータ型
  <li>Julia はプログラム (式) を抽象構文木に変換してから評価する
  <li>Expr は :( ... ) または quote ... end で生成する
  <ul>
    <li>Lisp / Scheme の quote (') と同じ意味
    <li>式を評価しないで Expr 型データを生成する
    <li>実際には Lisp / Scheme の backquote (`) と同じような働きをする
  </ul>
  <li>コンストラクタ Expr( ... ) でも生成できるが、ちょっと面倒になる
  <li>Meta.pares(文字列) でも生成できる
  <ul>
    <li>Base.pares(データ型, 文字列) は文字列をデータ型の数値に変換する
    <li>名前が同じでも機能が違うことに注意
  </ul>
  <li>データ型の構造は関数 dump() で表示できる
</ul>
<pre>
julia&gt; :((1 + 2) * (3 - 4))
:((1 + 2) * (3 - 4))

julia&gt; typeof(:((1 + 2) * (3 - 4)))
Expr

julia&gt; dump(:((1 + 2) * (3 - 4)))
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol *
    2: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2
    3: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol -
        2: Int64 3
        3: Int64 4

julia&gt; Meta.parse("(1 + 2) * (3 - 4)")
:((1 + 2) * (3 - 4))
</pre>
<ul>
  <li>Expr のメンバ変数は head と args の 2 つ
  <li>head は操作 (call は関数呼び出し), args はその引数を格納した配列
  <li>Symbol (シンボル) は識別子 (変数名や関数名など) を表すデータ型
  <ul>
    <li>Symbol は Lisp / Scheme のシンボル (symbol) みたいなもの
    <li>同じ名前の Symbol は Julia の中では唯一つしか存在しない (シングルトンオブジェクト)
  </ul>
  <li>Symbol は名前の前にコロン (:) を付ける、またはコンストラクタ Symbol(文字列) で生成する
  <li>関数 Meta.show_sexpr() は Expr を S 式のように表示する
  <ul>
    <li>S 式 (S-expression) は Lisp / Scheme の用語
    <li>Lisp のデータはアトム (atom) とリスト (list) に大別できるが、この 2 つを合わせて S 式という
    <li>Lisp のリストはカッコ (...) で記述される
    <li>show_sexpr() も Expr をカッコで表記する
  </ul>
  <li>Expr は関数 eval() で評価することができる
  <li>Expr を生成するときは $ による変数や式の展開が可能
  <ul>
    <li>$ は Lisp / Scheme の backquote (`) で使用される comma (,) に相当する
  </ul>
</ul>
<pre>
julia&gt; a = :foo
:foo

julia&gt; b = Symbol("foo")
:foo

julia&gt; a === b
true

julia&gt; Meta.show_sexpr(:((1 + 2) * (3 - 4)))
(:call, :*, (:call, :+, 1, 2), (:call, :-, 3, 4))

julia&gt; eval(:((1 + 2) * (3 - 4)))
-3

julia&gt; x = 100
100

julia&gt; :(x + 200)
:(x + 200)

julia&gt; :($x + 200)
:(100 + 200)

julia&gt; eval(:(x + 200))
300

julia&gt; x = 10
10

julia&gt; eval(:(x + 200))
210
</pre>
<ul>
  <li>Meta.parse() と eval() を使うと、REPL (Read-Eval-Print-Loop) を簡単に作ることができる
</ul>
<pre class="list">
リスト : REPL (Read - Eval - Print - Loop)

while true
    print("&gt;&gt;&gt; ")
    s = readline(stdin)
    try
        println(eval(Meta.parse(s)))
    catch e
        println(e)
    end
end
</pre>
<pre>
&gt;&gt;&gt; 1 + 2 * 3
7
&gt;&gt;&gt; a = 10
10
&gt;&gt;&gt; a * 10
100
&gt;&gt;&gt; b
UndefVarError(:b)
&gt;&gt;&gt; square(x) = x * x
square
&gt;&gt;&gt; square(1.2345)
1.5239902499999998
&gt;&gt;&gt; exit()

C&gt;
</pre>
<h4 id="abc23">●マクロの基本</h4>
<ul>
  <li>Julia のマクロ (macro) は Scheme の「健全なマクロ (Hygienic macros)」の考え方と似ている
  <li>マクロは macro 名前(仮引数, ...) ... end で定義する
  <li>マクロは @名前(実引数, ...) または @名前 実引数 ... で呼び出す
  <li>マクロを呼び出すとき、実引数は評価されずにそのままマクロに渡される
  <ul>
    <li>関数は実引数を評価することに注意
    <li>これを「正格評価」という
  </ul>
  <li>マクロは本体 (式) を評価して新しい Expr を生成し、それを再度評価 (eval) してその結果を返す
<pre class="fig">
[式 (Expr)] ─ 評価 → [新しい式] ─ 評価 → [マクロの返り値]
          （マクロ展開）

                   図 : マクロの動作
</pre>
</ul>
<ul>
  <li>マクロと関数の違いを理解するために、数を 2 乗する処理をマクロと関数で作ってみる
<pre class="list">
リスト : 数を 2 乗する関数とマクロ

# 関数
square(x) = x * x

# マクロ
macro m_square(x) :($x * $x) end
</pre>
  <li>@m_square(1 + 2) の評価は次のように行われる
<pre class="fig">
@m_square(1 + 2)

仮引数 x に :(1 + 2) がセット (評価されないことに注意)

マクロの本体 :($x * $x) を評価する

=&gt; :((1 + 2) * (1 + 2)) (式が組み立てられる)

=&gt; 9                    (式を評価した結果)

        図 : マクロの実行
</pre>
  <li>関数であれば引数 1 + 2 が評価されて、その結果である 3 が square に渡される
  <li>マクロは引数を評価しないので、仮引数 x には式である :(1 + 2) がそのままセットされる
  <li>次にマクロ本体を評価する
  <li>マクロを使いこなすポイントは、まず評価したい式を組み立てることを考える
  <li>最初の評価で式を組み立て、それを評価することで目的の処理を実現するのがマクロ
  <li>この場合、引数を 2 乗する :($x * $x) という式を作ればいい
  <li>実引数は式 1 + 2 なので、:((1 + 2) * (1 + 2)) という式が生成される
  <li>ここまでの処理を「マクロ展開」という
  <li>あとは、この式を評価して 9 という値が結果となる
</ul>
<pre>
julia&gt; macro m_square(x)
       :($x * $x)
       end
@m_square (macro with 1 method)

julia&gt; @m_square(100)
10000

julia&gt; a = 20
20

julia&gt; @m_square(a)
400

julia&gt; x = 123
123

julia&gt; @m_square(x * 2)
60516

julia&gt; square(x) = x * x
square (generic function with 1 method)

julia&gt; foo(x) = (println("foo!"); x)
foo (generic function with 1 method)

julia&gt; square(foo(10))
foo!
100

julia&gt; @m_square(foo(10))
foo!
foo!
100
</pre>
<ul>
  <li>関数 square は、引数が評価されるので foo! が 1 回だけ出力される
  <li>ところが m-square では、引数は評価されずに渡されて式 :(foo(10) * foo(10)) が組み立てられる
  <li>その後、この式が評価されるので foo! が 2 回出力される
</ul>
<ul>
  <li>マクロを使うと処理を無名関数で簡単にラップすることができる
</ul>
<pre>
julia&gt; macro chunk(expr)
       :(() -&gt; $expr)
       end
@chunk (macro with 1 method)

julia&gt; f = @chunk(1 + 2 * 3)
#3 (generic function with 1 method)

julia&gt; f()
7

julia&gt; f()
7

julia&gt; g = @chunk(x * x for x = 1 : 10)
#5 (generic function with 1 method)

julia&gt; for x = g()
       println(x)
       end
1
4
9
16
25
36
49
64
81
100

julia&gt; a = Task(@chunk(for x = 1:10; sleep(0.5); println(x); end))
Task (runnable) @0x0000000010b49430

julia&gt; schedule(a)
Task (runnable) @0x0000000010b49430

julia&gt; 1
2
3
4
5
6
7
8
9
10
</pre>
<ul>
  <li>ひとかたまりのデータや処理のことを「チャンク (chunk)」という
  <li>たとえば、Task() に渡す引数はチャンクと考えることができる
  <li>マクロ @task でも同じような処理を行っている
</ul>
<ul>
  <li>マクロ展開したあと、変数名が衝突することを「変数捕捉 (variable capture)」という
  <li>julia はマクロ内で変数を使用するとき、他の変数と名前が衝突しないように新しい名前に置き換える
  <li>このため、@chunk は処理に既存の変数の代入や参照が含まれていると、正常に動作しないことがある
  <li>マクロ展開の結果はマクロ @macroexpand で確認できる
</ul>
<pre>
julia&gt; macro chunk(expr) :(() -&gt; $expr) end
@chunk (macro with 1 method)

julia&gt; a = 1
1

julia&gt; b = 2
2

julia&gt; f = @chunk(a = b)
#3 (generic function with 1 method)

julia&gt; f()
2

julia&gt; a
1

julia&gt; @macroexpand @chunk(a = b)
:(()-&gt;begin
          #= REPL[1]:1 =#
          #2#a = Main.b    # a が #2#a に置き換えられている
      end)                 # b も大域変数のアクセスになっている

julia&gt; f = @chunk(global a = b)
#5 (generic function with 1 method)

julia&gt; f()
2

julia&gt; a
2

julia&gt; @macroexpand @chunk(global a = b)
:(()-&gt;begin
          #= REPL[1]:1 =#
          global a = Main.b     # global を付けると置換しないようだ
      end)

julia&gt; let a = 10, b = 20
       f = @chunk(a + b)        # 局所変数にはアクセスできない
       println(f())
       end
4

julia&gt; a + b
4
</pre>
<ul>
  <li>既存の変数を捕捉するには関数 esc() を使う
  <li>esc(quote ... end) とすると、quote の中で使用される変数は置換されない
</ul>
<pre>
julia&gt; macro chunk(expr) esc(:(() -&gt; $expr)) end
@chunk (macro with 1 method)

julia&gt; a = 1
1

julia&gt; b = 2
2

julia&gt; f = @chunk(a = b)
#9 (generic function with 1 method)

julia&gt; f()
2

julia&gt; a
1

julia&gt; @macroexpand @chunk(a = b)
:(()-&gt;begin
          #= REPL[15]:1 =#
          a = b                       # 無名関数の中なので a は局所変数になる
      end)

julia&gt; f = @chunk(global a = b)
#11 (generic function with 1 method)

julia&gt; f()
2

julia&gt; a
2

julia&gt; let a = 10, b = 20
       f = @chunk(a + b)
       println(f())
       end
30

julia&gt; f = @chunk(a + b)              # これは大域変数をアクセスする
#15 (generic function with 1 method)

julia&gt; f()
4

julia&gt; @macroexpand @chunk(a + b)
:(()-&gt;begin
          #= REPL[15]:1 =#
          a + b
      end)
</pre>
<ul>
  <li>quote の中でマクロの引数 var だけを置換しない場合は $(esc(var)) とする
  <li>それ以外の変数は置換される
  <li>@setf(a, b) は b を a に代入するマクロ
  <li>setf は set field の略で、Common Lisp より拝借した
</ul>
<pre>
julia&gt; macro setf1(x, y)
       :($(esc(x)) = $(esc(y)))
       end
@setf1 (macro with 1 method)

julia&gt; @macroexpand @setf1(a, b)
:(a = b)

julia&gt; macro setf2(x, y)
       quote
       z = $(esc(y))
       $(esc(x)) = z
       end
       end
@setf2 (macro with 1 method)

julia&gt; @macroexpand @setf2(a, b)
quote
    #= REPL[6]:3 =#
    #1#z = b
    #= REPL[6]:4 =#
    a = #1#z
end

julia&gt; a = 10
10

julia&gt; b = 20
20

julia&gt; @setf2 a b
20

julia&gt; a
20

julia&gt; let a = 100, b = 200
       @setf2 a b
       println(a)
       end
200
</pre>
<ul>
  <li>簡単な例として、引数 test の評価結果が負ならば引数 n を、0 ならば引数 z を、正ならば引数 p を評価するマクロ arithmeticif を示す
</ul>
<pre>
julia&gt; macro arithmeticif(test, n, z, p)
       quote
       local r = $(esc(test))
       if r == 0
       $z
       elseif r &gt; 0
       $p
       else
       $n
       end
       end
       end
@arithmeticif (macro with 1 method)

julia&gt; @arithmeticif(-1, "negative", "zero", "positive")
"negative"

julia&gt; @arithmeticif(0, "negative", "zero", "positive")
"zero"

julia&gt; @arithmeticif(1, "negative", "zero", "positive")
"positive"

julia&gt; a = 100
100

julia&gt; @arithmeticif(a, "negative", "zero", "positive")
"positive"

julia&gt; @arithmeticif(1 - 3, "negative", "zero", "positive")
"negative"

julia&gt; @arithmeticif(1 - 3 + 2, "negative", "zero", "positive")
"zero"
</pre>
<h4 id="abc24">●並列プログラミング</h4>
<ul>
  <li>Julia は標準でマルチコア CPU に対応している
  <li>ここでは基本的な機能を簡単に説明する
  <li>詳細はマニュアル <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Core-or-Distributed-Processing-1">Multi-Core or Distributed Processing</a> や <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed Computing</a> を参照
  <li>マルチコアを有効にするには、起動時に -p n でワーカープロセス数 n を指定する
  <li>このとき、自動的にモジュール Distributed がロードされる
  <li>Julia はマスタープロセス (メインプログラムのこと) から複数のワーカープロセスを生成して、それらを並列に実行する
  <li>ワーカープロセス数は関数 nworkers() で、マスターとワーカーの合計のプロセス数は関数 nprocs() で求めることができる
</ul>
<pre>
C&gt;julia -p 4

julia&gt; nworkers()
4

julia&gt; nprocs()
5
</pre>
<ul>
  <li>r = remotecall(func, n, args, ...) は n 番目のワーカープロセスで関数 func(args, ...) を実行する
  <li>ワーカープロセスの番号は 2 から指定したワーカープロセス数 + 1 まで。1 はマスタープロセス
  <li>自分のプロセス番号は関数 myid() で取得できる
  <li>返り値 r は Future 型で、fetch(r) で値を取得する
  <li>remotecall_fetch() は (r = remotecall(...); fetch(r)) と同じ動作になる
  <li>ワーカープロセスでは、メインプログラムで定義された関数や変数を認識しない
  <li>マクロ @everywhere を指定すると、どのワーカープロセスでも認識する
  <li>プログラムをロードするときは、include や using の前に @everywhere を指定する。
</ul>
<pre>
julia&gt; @everywhere include("fibo.jl")    # 二重再帰のフィボナッチ関数

julia&gt; @time fibo(42)
  1.921619 seconds (5 allocations: 176 bytes)
267914296

julia&gt; @time fibo(42) + fibo(42)
  3.830193 seconds (7 allocations: 208 bytes)
535828592

julia&gt; r = remotecall(fibo, 2, 42)
Future(2, 1, 14, nothing)

julia&gt; fetch(r)
267914296

julia&gt; remotecall_fetch(fibo, 2, 42)
267914296

julia&gt; function test()
       a = remotecall(fibo, 2, 42)
       b = remotecall(fibo, 3, 42)
       fetch(a) + fetch(b)
       end
test (generic function with 1 method)

julia&gt; @time test()
  2.098876 seconds (599 allocations: 33.234 KiB)
535828592

julia&gt; function test1()
       a = remotecall(fibo, 2, 42)
       b = remotecall(fibo, 2, 42)
       fetch(a) + fetch(b)
       end
test1 (generic function with 1 method)

julia&gt; @time test1()
  3.922970 seconds (236.36 k allocations: 12.116 MiB, 0.15% gc time)
535828592
</pre>
<ul>
  <li>関数 test() では fibo() が並列に動作するので、実行速度は約 1.8 倍になる
  <li>関数 test1() のように同じワーカープロセスを指定すると逐次実行と同じになる (a の次に b を実行) 
  <li>remotecall() のかわりにマクロ @spawnat や @spawn を使うこともできる
<pre class="item">
@spawnat n func(args, ...)   # n はワーカープロセス
@spawn func(args, ...)       # 適当なワーカープロセスを選択して実行
</pre>
</ul>
<pre>
julia&gt; function test2()
       a = @spawn fibo(42)
       b = @spawn fibo(42)
       fetch(a) + fetch(b)
       end
test2 (generic function with 1 method)

julia&gt; @time test2()
  2.050592 seconds (263 allocations: 10.047 KiB)
535828592

julia&gt; function test3()
       a = @spawnat 2 fibo(42)
       b = @spawnat 3 fibo(42)
       fetch(a) + fetch(b)
       end
test3 (generic function with 1 method)

julia&gt; @time test3()
  2.054959 seconds (230 allocations: 8.500 KiB)
535828592
</pre>
<ul>
  <li>関数 test2() の fibo() は @spawn により別々のワーカプロセスで割り当てられるので並列に動作する。
  <li>for 文の前に @distributed を付けると、ループを並列化して実行する。
  <li>@distributed の後ろに (reducer) を指定できる
  <li>各々の計算結果を reducer で結合する
  <li>たとえば、+ を指定すると足し算した結果を返す
  <li>関数 pmap() はマッピングを並列化して実行する
</ul>
<pre>
julia&gt; @time @distributed (+) for _ in 1 : 2; fibo(42); end
  2.110690 seconds (67.43 k allocations: 3.260 MiB)
535828592

julia&gt; @time @distributed (+) for _ in 1 : 3; fibo(42); end
  3.087723 seconds (67.65 k allocations: 3.290 MiB)
803742888

julia&gt; @time @distributed (+) for _ in 1 : 4; fibo(42); end
  4.021192 seconds (67.85 k allocations: 3.293 MiB)
1071657184

julia&gt; @time map(fibo, [42, 42])
  3.880537 seconds (161.13 k allocations: 8.280 MiB)
2-element Array{Int64,1}:
 267914296
 267914296

julia&gt; @time pmap(fibo, [42, 42])
  2.187594 seconds (181 allocations: 33.656 KiB)
2-element Array{Int64,1}:
 267914296
 267914296

julia&gt; @time pmap(fibo, [42, 42, 42])
  3.089446 seconds (240 allocations: 42.438 KiB)
3-element Array{Int64,1}:
 267914296
 267914296
 267914296
</pre>
<ul>
  <li>実際に並列動作するプロセスの数は CPU のコア数に依存する
  <li>未実行のプログラムはワーカープロセスがアイドルになるまで待つ
  <li>M.Hiroi のパソコンの CPU は Intel Core i5-6200U 2.30GHz
  <li>物理コア数は 2 で、1 コアにつきハイパースレッディングで 2 分割できる
  <li>Julia ver 1.0 の場合、物理コア数を超えると並列化の効果は少なくなるようだ
</ul>
<ul>
  <li>マクロ @sync は @spawn や @distributed などで起動したワーカープロセスが全て終了するのを待つ
</ul>
<pre>
julia&gt; @time @sync (@spawn fibo(42); @spawn fibo(42))
  2.284218 seconds (68.76 k allocations: 3.428 MiB, 0.40% gc time)
Future(5, 1, 81, nothing)

julia&gt; @time (@spawn fibo(42); @spawn fibo(42))
  0.000412 seconds (248 allocations: 12.953 KiB)
Future(3, 1, 85, nothing)
</pre>
<ul>
  <li>@everywhere で指定した大域変数は各プロセスごとに確保される。プロセス間で共有されることは無い。
  <li>メインプロセスで定義した配列をワーカープロセスに渡すとき、その配列はワーカープロセスに転送 (コピー) される。
</ul>
<pre>
julia&gt; @everywhere cnt = 0

julia&gt; @everywhere function test(n)
       for _ in 1 : 10
       global cnt        # ワーカープロセスで実行すると、
                         # そのワーカープロセスの大域変数 cnt にアクセスする
       cnt += n
       println(cnt)
       sleep(n)
       end
       end

julia&gt; r = @spawn test(1); fetch(r)
        From worker 3:  1
        From worker 3:  2
        From worker 3:  3
        From worker 3:  4
        From worker 3:  5
        From worker 3:  6
        From worker 3:  7
        From worker 3:  8
        From worker 3:  9
        From worker 3:  10

julia&gt; cnt
0                        # マスタープロセスの cnt は 0 のまま

julia&gt; a = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; @everywhere test1(a, n, x) = (a[n] = x; println(a))

julia&gt; r = @spawn test1(a, 3, 30); fetch(r)
      From worker 5:    [1, 2, 30, 4, 5]    # ワーカープロセスの配列を変更

julia&gt; a                 # マスタープロセスの配列は変更されていない
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap">簡単なプログラム</h3>
<h4 id="chap32">●平方根</h4>
<p> 実数 a の平方根 √a の値を求める場合、方程式 x<sup>2</sup> - a = 0 を Newton (ニュートン) 法で解くことが多いと思います。方程式を f(x), その導関数を f'(x) とすると、ニュートン法は次の漸化式の値が収束するまで繰り返す方法です。
</p>
<pre class="item">
x<sub>n+1</sub> = x<sub>n</sub> - f(x<sub>n</sub>) / f'(x<sub>n</sub>)
</pre>
<p> 平方根を求める場合、導関数は f'(x) = 2x になるので、漸化式は次のようになります。
</p>
<pre class="item">
x<sub>n+1</sub> = (x<sub>n</sub> + a / x<sub>n</sub>) / 2
</pre>
<p> <a href="juliaa05.html#cite50">参考文献 1</a> によると、√a より大きめの初期値から出発し、置き換え x &lt;- (x + a / x) / 2 を減少が止まるまで繰り返すことで √a の正確な値を求めることができるそうです。
</p>
<p> Julia でプログラムすると、次のようになります。
</p>
<pre class="list">
リスト : 平方根を求める

function sqrt1(x::Float64)
    function init(x::Float64, s = 1.0)
        while s &lt; x
            s *= 2.0
            x /= 2.0
        end
        s
    end
    if x &lt; 0; error("sqrt1: domain error"); end
    p = x &gt; 1.0 ? init(x) : 1.0
    while true
        q = (p + x / p) / 2
        if q &gt;= p; break; end
        p = q
    end
    p
end

println(sqrt1(2.0))
println(sqrt(2))
println(sqrt1(123456.0))
println(sqrt(123456))
</pre>
<pre>
1.414213562373095
1.4142135623730951
351.363060095964
351.363060095964
</pre>
<p> 局所関数 init は √x よりも大きめの初期値を求めます。たとえば、√123456 を求める場合、初期値の計算は次のようになります。
</p>
<pre class="fig">
   s         x
-------------------
  1.0  123456.0
  2.0   61728.0
  4.0   30864.0
  8.0   15432.0
 16.0    7716.0
 32.0    3858.0
 64.0    1929.0
128.0     964.5
256.0     482.25
512.0     241.125

√123456 = 351.363060095964 
</pre>
<p> s を 2 倍、x を 1 / 2 していき、s &gt;= x となったときの s が初期値 (512) となります。4, 16, 64, 256, ... 2<sup>2n</sup> の平方根はこれだけで求めることができます。
</p>
<p> あとは漸化式を計算して変数 q にセットし、q がひとつ前の値 p 以上になったら p を返すだけです。√123456 を求めたときの p と q の値を示します。
</p>
<pre class="fig">
   p                  q
--------------------------------------
512.0              376.5625
376.5625           352.20622925311204
352.20622925311204 351.3640693544162
351.3640693544162  351.3630600974135
351.3630600974135  351.363060095964
351.363060095964   351.363060095964

√123456 = 351.363060095964 
</pre>
<p> 6 回の繰り返しで √123456 を求めることができます。
</p>
<hr>
<h4 id="chap32a">●めのこ平方</h4>
<p> 平方根の整数部もニュートン法を使って求めることができますが、次の公式を使って平方根の整数部分を求めることもできます。
</p>
<pre class="item">
(1) 1 + 3 + 5 + ... + (2n - 1) = n<sup>2</sup>
(2) 1 + 3 + 5 + ... + (2n - 1) = n<sup>2</sup> &lt; m &lt; 1 + 3 + ... (2n - 1) + (2n + 1) = (n + 1)<sup>2</sup>
</pre>
<p> 式 (1) は、奇数 1 から 2n - 1 の総和は n<sup>2</sup> になることを表しています。式 (2) のように、整数 m の値が n<sup>2</sup> より大きくて (n + 1)<sup>2</sup> より小さいのであれば、m の平方根の整数部分は n であることがわかります。これは m から奇数 1, 3, 5 ... (2n - 1), (2n + 1)  を順番に引き算していき、引き算できなくなった時点の (2n + 1) / 2 = n が m の平方根になります。<a href="juliaa05.html#cite50">参考文献 2</a> によると、この方法を「めのこ平方」と呼ぶそうです。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : めのこ平方

# めのこ平方
function isqrt(n, m = 1)
    while n &gt;= m
        n -= m
        m += 2
    end
    div(m, 2)
end

println(isqrt(4))
println(isqrt(16))
println(isqrt(64))
println(isqrt(80))
println(isqrt(81))
println(isqrt(82))
println(isqrt(100))
</pre>
<pre>
2
4
8
8
9
9
10
</pre>
<p> この方法はとても簡単ですが、数が大きくなると時間がかかるようになります。そこで、整数を 2 桁ずつ分けて計算していくことにします。次の図を見てください。
</p>
<pre class="fig">
整数 6789 を 67 と 89 に分ける

1 + 3 + ... + 15 = 8<sup>2</sup> &lt; 67

両辺を 100 倍すると 80<sup>2</sup> &lt; 6700 &lt; 6789

80<sup>2</sup> = 1 + 3 + ... + 159 (= 2 * 80 - 1)

161 + 163 &lt; (6789 - 6400 = 389) &lt; 161 + 163 + 165
</pre>
<p> 整数 6789 を 67 と 89 に分けます。最初に 67 の平方根を求めます。この場合は 8 になり、8<sup>2</sup> &lt; 67 を満たします。次に、この式を 100 倍します。すると、80<sup>2</sup> &lt; 6700 になり、6700 に 89 を足した 6789 も 80<sup>2</sup> より大きくなります。80<sup>2</sup> は 1 から 159 までの奇数の総和であることはすぐにわかるので、6789 - 6400 = 389 から奇数 161, 163, ... を順番に引き算していけば 6789 の平方根を求めることができます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : めのこ平方 (改良版)

function isqrt1(n)
    if n &lt; 100
        isqrt(n)
    else
        m = 10 * isqrt1(div(n, 100))
        isqrt(n - m * m, 2 * m + 1)
    end
end

println(isqrt1(6789))
println(isqrt1(123456789))
println(isqrt1(1234567890))
</pre>
<pre>
82
11111
35136
</pre>
<p> isqrt1() は n の平方根の整数部分を求めます。n が 100 未満の場合は isqrt() で平方根を求めます。これが再帰呼び出しの停止条件になります。n が 100 以上の場合は、n の下位 2 桁を取り除いた値 div(n, 100) の平方根を isqrt1() で求め、その値を 10 倍して変数 m にセットします。そして、isqrt() で n - m * m から奇数 2 * m + 1, 2 * m + 3 ... を順番に引き算していって n の平方根を求めます。
</p>
<p> 興味のある方はいろいろ試してみてください。
</p>
<h4 id="cite50">●参考文献</h4>
<ol>
  <li>奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
  <li><a href="http://www13.plala.or.jp/isemba/">仙波一郎のページ</a>, <a href="http://www13.plala.or.jp/isemba/PROGRAM/BASIC/b121.pdf">『平方根計算法 (PDF)』</a>
</ol>
<hr>
<h4 id="chap33">●べき集合</h4>
<p> 今回は配列 xs のべき集合を求める高階関数 power_set() を作ります。たとえば配列 [1, 2, 3] のべき集合は [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] になります。
</p>
<pre class="list">
リスト : べき集合

function power_set(f, xs)
    function iter(i, a)
        if i &gt; length(xs)
            f(a)
        else
            iter(i + 1, a)
            push!(a, xs[i])
            iter(i + 1, a)
            pop!(a)
        end
    end
    a::typeof(xs) = []
    iter(1, a)
end

power_set(println, ["foo", "bar", "baz"])
power_set(println, [1,2,3,4])
</pre>
<p> power_set() は簡単です。実際の処理は局所関数 iter() で行います。xs の i 番目の要素を選択する場合は、その要素を引数 a に追加して iter() を再帰呼び出しします。選択しない場合は、引数 a に要素を追加せずに iter() を再帰呼び出しするだけです。これでべき集合の要素をすべて求めることができます。
</p>
<pre>
String[]
["baz"]
["bar"]
["bar", "baz"]
["foo"]
["foo", "baz"]
["foo", "bar"]
["foo", "bar", "baz"]
Int64[]
[4]
[3]
[3, 4]
[2]
[2, 4]
[2, 3]
[2, 3, 4]
[1]
[1, 4]
[1, 3]
[1, 3, 4]
[1, 2]
[1, 2, 4]
[1, 2, 3]
[1, 2, 3, 4]
</pre>
<hr>
<h4 id="chap34">●マスターマインドの解法</h4>
<p> 「マスターマインド」は 0 から 9 までの重複しない 4 つの数字からなる隠しコードを当てるゲームです。数字は合っているが位置が間違っている個数を cows で表し、数字も位置も合っている個数を bulls で表します。bulls が 4 になると正解です。
</p>
<pre class="fig">
   [6, 2, 8, 1] : 正解
---------------------------------
1: [0, 1, 2, 3] : cows 2 : bulls 0
2: [1, 0, 4, 5] : cows 1 : bulls 0
3: [2, 3, 5, 6] : cows 2 : bulls 0
4: [3, 2, 7, 4] : cows 0 : bulls 1
5: [3, 6, 0, 8] : cows 2 : bulls 0
6: [6, 2, 8, 1] : cows 0 : bulls 4

  図 : マスターマインドの動作例
</pre>
<p> 今回はマスターマインドを解くプログラムを作ることにします。
</p>
<h4>●推測アルゴリズム</h4>
<p> このゲームは 10 個の数字の中から 4 個選ぶわけですから、全体では 10 * 9 * 8 * 7 = 5040 通りのコードしかありません。この中から正解を見つける方法ですが、質問したコードとその結果を覚えておいて、それと矛盾しないコードを作るようにします。具体的には、4 つの数字の順列を生成し、それが今まで質問したコードと矛盾しないことを確かめます。これは生成検定法と同じですね。
</p>
<p> 矛盾しているかチェックする方法も簡単で、以前に質問したコードと比較して、bulls と cows が等しいときは矛盾していません。たとえば、次の例を考えてみてください。
</p>
<pre class="fig">
[6, 2, 8, 1] が正解の場合

[0, 1, 2, 3] =&gt; bulls = 0, cows = 2

           [0, 1, 2, 3]  と比較する
     --------------------------------------------------------
           [0, X, X, X]  0 から始まるコードは bulls = 1
                         になるので矛盾する。
           ・・・・

           [1, 0, 3, 4]  cows = 3, bulls = 0 になるので矛盾する

           ・・・・

           [1, 0, 4, 5]  cows = 2, bulls = 0 で矛盾しない。
     --------------------------------------------------------

[1, 0, 4, 5] =&gt; bulls = 0, cows = 1

次は、[0, 1, 2, 3] と [1, 0, 4, 5] に矛盾しない数字を選ぶ

        図 : マスターマインドの推測アルゴリズム
</pre>
<p> [0, 1, 2, 3] で bulls が 0 ですから、その位置にその数字は当てはまりません。したがって、[0, X, X, X] というコードは [0, 1, 2, 3] と比較すると bulls が 1 となるので、矛盾していることがわかります。
</p>
<p> 次に [1, 0, 3, 4] というコードを考えてみます。[0, 1, 2, 3] の結果は cows が 2 ですから、その中で合っている数字は 2 つしかないわけです。ところが、[1, 0, 3, 4] と [0, 1, 2, 3] と比較すると cows が 3 になります。当たっている数字が 2 つしかないのに、同じ数字を 3 つ使うのでは矛盾していることになりますね。
</p>
<p> 次に [1, 0, 4, 5] というコードと比較すると、bulls が 0 で cows が 2 となります。これは矛盾していないので、このコードを質問することにします。その結果が bulls = 0, cows = 1 となり、今度は [0, 1, 2, 3] と [1, 0, 4, 5] に矛盾しないコードを選択するのです。
</p>
<h4>●プログラムの作成</h4>
<p> それでは、プログラムを作っていきましょう。まず、質問したコードとその結果を格納するデータ型を定義します。
</p>
<pre class="list">
リスト : データ型の定義

# 定数
const CSIZE = 4

# 質問したコードとその結果
type Query
    bulls::Int
    cows::Int
    code::Array{Int, 1}
end
</pre>

<p> 型名は Query としました。bulls, cows と質問したコード code を格納します。これを大域変数 query の配列に格納します。
</p>
<p> 次は bulls を数える関数 count_bulls() を作ります。
</p>
<pre class="list">
リスト : bulls を数える

function count_bulls(xs, ys)
    c = 0
    for i = 1 : CSIZE
        if xs[i] == ys[i]; c += 1; end
    end
    c
    # 次のコードでもよい
    # count(map(==, xs, ys))
end
</pre>
<p> count_bulls() は簡単です。配列 xs, ys の要素を順番に比較して、等しい場合は変数 c の値を +1 します。この処理は関数 count() と map() を使うと 1 行で書くことができます。
</p>
<pre class="item">
count(pred, iter) =&gt; Integer
count(iter) =&gt; Integer
</pre>
<p> count(pred, iter) はイテレータから要素を取り出して、関数 pred が真を返す要素の個数を求めます。iter だけ渡すと、要素が真の個数を求めます。map() の返り値は bool 型の配列になるので、count() で等しい要素の個数を求めることができます。
</p>
<p> 次は cows を数える処理を作ります。いきなり cows を数えようとすると難しいのですが、2 つのリストに共通の数字を数えることは簡単にできます。この方法では、bulls の個数を含んだ数を求めることになりますが、そこから bulls を引けば cows を求めることができます。関数名は count_same_number() としましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 同じ数字の個数を数える

function count_same_number(xs, ys)
    c = 0
    for x = xs
        if x in ys c += 1 end
    end
    c
end
</pre>
<p> for ループで xs の要素を順番に取り出して変数 x にセットします。そして、x in ys で x が ys に含まれているかチェックします。そうであれば、変数 c の値を +1 します。
</p>

<p> 次は、今まで質問したコードと矛盾していないか調べる関数 check を作ります。
</p>

<pre class="list">
リスト : 今まで質問したコードと矛盾していないか

function check(answer, xs)
    global query
    for q = query
        b = count_bulls(q.code, xs)
        c = count_same_number(q.code, xs) - b
        if b != q.bulls || c != q.cows
            return
        end
    end
    b = count_bulls(answer, xs)
    c = count_same_number(answer, xs) - b
    q = Query(b, c, xs)
    push!(query, q)
    n = length(query)
    println("$n: $xs, bulls = $b, cows = $c")
    if b == 4
        throw("Good Job!")
    end
end
</pre>
<p> 引数 answer は正解のコード、xs は生成したコードです。最初に、大域変数 query に格納されたデータをチェックしていきます。count_bulls() と count_same_number() を使って bulls (変数 b) と cows (変数 c) を求めて、質問したときの q.bulls と q.cows に矛盾しないかチェックします。矛盾している場合は return で終了します。
</p>

<p> それから、正解のコード answer と xs を比較して bulls と cows を求め、それらを構造体 Query にまとめて query に追加します。あとは関数 permutations() で順列を生成するだけです。詳細は <a href="juliaa05.html#list52">プログラムリスト</a> をお読みください。
</p>
<h4>●何回で当たるか</h4>
<p> これでプログラムは完成です。それでは実行例を示しましょう。
</p>
<pre>
julia&gt; solver([9, 8, 7, 6])
1: [0, 1, 2, 3], bulls = 0, cows = 0
2: [4, 5, 6, 7], bulls = 0, cows = 2
3: [5, 4, 8, 9], bulls = 0, cows = 2
4: [6, 7, 9, 8], bulls = 0, cows = 4
5: [8, 9, 7, 6], bulls = 2, cows = 2
6: [9, 8, 7, 6], bulls = 4, cows = 0
Good Job!

julia&gt; solver([9, 4, 3, 1])
1: [0, 1, 2, 3], bulls = 0, cows = 2
2: [1, 0, 4, 5], bulls = 0, cows = 2
3: [2, 3, 5, 4], bulls = 0, cows = 2
4: [3, 4, 0, 6], bulls = 1, cows = 1
5: [3, 5, 6, 1], bulls = 1, cows = 1
6: [6, 5, 0, 2], bulls = 0, cows = 0
7: [7, 4, 3, 1], bulls = 3, cows = 0
8: [8, 4, 3, 1], bulls = 3, cows = 0
9: [9, 4, 3, 1], bulls = 4, cows = 0
Good Job!
</pre>

<p> 肝心の質問回数ですが、5, 6 回で当たる場合が多いようです。実際に、5040 個のコードをすべて試してみたところ、平均は 5.56 回になりました。これは <a href="juliaa05.html#cite">参考文献 1</a> の結果と同じです。質問回数の最大値は 9 回で、そのときのコードは [9 4 3 1], [9 2 4 1], [5 2 9 3], [9 2 0 4], [9 2 1 4] でした。
</p>
<p> なお、参考文献 1 には平均質問回数がこれよりも少なくなる方法が紹介されています。単純な数当てゲームだと思っていましたが、その奥はけっこう深いようです。興味のある方はいろいろ試してみてください。
</p>

<h4 id="cite">●参考文献</h4>
<ol>
  <li>田中哲郎 「数当てゲーム (MOO, マスターマインド) 」, 松原仁、竹内郁雄 編 『bit 別冊 ゲームプログラミング』 pp150 - 157, 共立出版, 1997
</ol>
<hr>
<h4 id="list52">●プログラムリスト</h4>
<pre class="list">
#
# mastermind.jl : マスターマインドの解法
#
#                 Copyright (C) 2016-2018 Makoto Hiroi
#

# 定数
const CSIZE = 4

# 質問したコードとその結果
struct Query
    bulls::Int
    cows::Int
    code::Array{Int, 1}
end

# 0 - 9 から 4 個の数字を選ぶ順列を生成
function permutations(f, xs, n = 1)
    if n &gt; CSIZE
        f(xs[1:CSIZE])
    else
        tmp = xs[n]
        for i = n : length(xs)
            xs[n] = xs[i]
            xs[i] = tmp
            permutations(f, xs, n + 1)
            xs[i] = xs[n]
            xs[n] = tmp
        end
    end
end

# bulls を数える
function count_bulls(xs, ys)
#=
    c = 0
    for i = 1 : CSIZE
        if xs[i] == ys[i]; c += 1; end
    end
    c
=#
    count(map(==, xs, ys))
end

# 同じ数字を数える
function count_same_number(xs, ys)
    c = 0
    for x = xs
        if x in ys c += 1 end
    end
    c
end

# 質問コードのチェック
function check(answer, xs)
    global query
    for q = query
        b = count_bulls(q.code, xs)
        c = count_same_number(q.code, xs) - b
        if b != q.bulls || c != q.cows
            return
        end
    end
    b = count_bulls(answer, xs)
    c = count_same_number(answer, xs) - b
    q = Query(b, c, xs)
    push!(query, q)
    n = length(query)
    println("$n: $xs, bulls = $b, cows = $c")
    if b == 4
        throw("Good Job!")
    end
end

# マスターマインドの解法
function solver(answer)
    global query
    query = Query[]
    try
        permutations(xs -&gt; check(answer, xs), collect(0 : 9))
    catch e
        println(e)
    end
end
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016-2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>