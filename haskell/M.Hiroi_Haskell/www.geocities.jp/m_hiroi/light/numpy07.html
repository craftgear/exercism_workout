<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 NumPy プログラミング超入門 </title>
  <meta name="description" content="Python,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881763</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Python3 Programming</h1>
<h2>お気楽 NumPy プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#numpy_abc">Python3</a> ]
<hr>
</div>
<section class="contents">
<h4 id="chap25">●連立方程式の解法 (2)</h4>
<p> 拙作のページ <a href="numpy03.html#chap21">連立方程式の解法</a> で説明した「ガウスの消去法」は、拡大係数行列を階段行列に変形することで解を求めています。このような方法を「直接法 (Direct Method)」といいます。これに対し、適当な初期解から始めて、繰り返し計算することで真の解に収束させていく方法が考えられます。これを「反復法 (Iterative Method)」といいます。
</p>
<p> 直接法は厳密解を求めることができますが、係数行列が大きくなると解くのに時間がかかるようになります。厳密解を求めるのが難しい場合、反復法を使うと現実的な時間で近似解を求めることが可能です。今回は基本的な反復法である「ヤコビ法」と「ガウス・ザイデル法」について簡単に説明します。
</p>

<h4>●ヤコビ法</h4>
<p> 連立方程式 Ax = b の係数行列 A を対角行列 D とそれ以外の要素を持つ行列 A' に分解します。すると、方程式は次のように変形することができます。
<pre class="item">
Ax = b =&gt; (A' + D)x = b =&gt; Dx = b - A'x =&gt; x = D<sup>-1</sup>(b - A'x)
</pre>
<p> ここで、最後の式を漸化式 x<sub>i+1</sub> = D<sup>-1</sup>(b - A'x<sub>i</sub>) と考えて、反復処理により解を求めるのが「ヤコビ法 (Jacobi Method)」です。たとえば、三元連立方程式の場合、漸化式は下図のようになります。
</p>
<pre class="fig">
  a1 * x + a2 * y + a3 * z = d1
  b1 * x + b2 * y + b3 * z = d2
  c1 * x + c2 * y + c3 * z = d3

  A' = [[ 0, a2, a3],   D = [[a1,  0,  0],   D<sup>-1</sup> = [[1/a1, 0,   0],
        [b1,  0, b3],        [ 0, b2,  0],          [ 0,  1/b2, 0],
        {c1, c2,  0]]        [ 0,  0, c3]]          [ 0,   0,  1/c3]]

  x<sub>i+1</sub> = (d1 - a2 * y<sub>i</sub> - a3 * z<sub>i</sub>) / a1
  y<sub>i+1</sub> = (d2 - b1 * x<sub>i</sub> - b3 * z<sub>i</sub>) / b2
  z<sub>i+1</sub> = (d3 - c1 * x<sub>i</sub> - c2 * y<sub>i</sub>) / c3
</pre>
<p> ヤコビ法で解が収束した場合、それが元の連立方程式の解となります。なお、行列 A によっては解が収束しない (発散する) 場合があります。収束の十分条件ですが、『係数行列 A が対角優位な行列である場合に収束する』ことが知られています。行列 A の対角成分 a<sub>ii</sub> の絶対値が、他の行の成分 a<sub>ij</sub> の絶対値の合計よりも大きいことを「対角優位」といいます。
</p>
<pre class="item">
|a<sub>ii</sub>| &gt; Σa<sub>ij</sub> (i, j = 1, 2, ..., n, j != i)
</pre>
<p> 上図の三元連立方程式でいえば、|a1| &gt; |b1| + |c1|, |b2| &gt; |a2| + |c2|, |c3| &gt; |a3| + |b3| を満たすとき、ヤコビ法の解は収束することになります。
</p>
<p> 収束の判定ですが、一般的には x<sub>i+1</sub> と x<sub>i</sub> の差分が許容誤差 ε に収まったときに収束と判定します。具体的な方法を以下に示します。
</p>
<ol>
  <li>Σ |x<sub>i+1</sub> - x<sub>i</sub>| &lt;= ε</li>
  <li>Σ |(x<sub>i+1</sub> - x<sub>i</sub>) / x<sub>i+1</sub>| &lt;= ε</li>
  <li>max |(x<sub>i+1</sub> - x<sub>i</sub>) / x<sub>i+1</sub>| &lt;= ε</li>
</ol>
<p> 1 は差分の合計値、2 は差分を解で割った値の合計値、3 は差分を解で割った値の最大値が ε 以下になったとき収束と判定します。今回は 2 の方法を使うことにします。
</p>
<h4>●ヤコビ法のプログラム</h4>
<p> それではプログラムを作りましょう。NumPy を使うとヤコビ法はとても簡単にプログラムすることができます。
</p>
<pre class="list">
リスト : ヤコビ法

def jacobi(a, b, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        x1 = (b - a1 @ x) / d
        if np.fabs((x1 - x) / x1).sum() &lt; eps:
            return x1
        x = x1
</pre>
<p> 引数 a が係数行列、b が右辺値を格納した配列、キーワード引数 max_iter は繰り返しの最大回数、eps は許容誤差を表します。最初に、a の対角成分を diag() で取り出して変数 d にセットします。そして、diag(d) で対角行列を生成し、a から引き算すれば、対角成分を 0 にした行列 a1 を生成することができます。変数 x には解を格納する配列をセットします。x は 0 で初期化します。
</p>
<p> あとは for ループで漸化式 x = D<sup>-1</sup>(b - A'x) を繰り返し計算します。NumPy の場合、行列 A, B の割り算 A / B は要素同士の割り算になるので、対角行列 d の逆行列を求める必要はありません。x1 = (b - a1 @ x) / d で漸化式を計算することができます。収束条件のチェックも簡単です。np.fabs((x1 - x) / x1).sum() で合計値を求め、それが eps よりも小さくなったならば解は収束したので x1 を返します。for ループが終了した場合、解は収束していないので None を返します。
</p>
<p> それでは実行してみましょう。次に示す方程式をヤコビ法で解きます。なお、変数 x1 の途中経過を表示するようにプログラムを修正しています。
</p>
<pre class="item">
9x +  y + 2z = 9
 x + 9y +  z = 18
2x +  y + 9z = -5
</pre>
<pre>
0 [ 0.  0.  0.]
1 [ 1.          2.         -0.55555556]
2 [ 0.90123457  1.95061728 -1.        ]
3 [ 1.00548697  2.01097394 -0.97256516]
4 [ 0.99268404  1.99634202 -1.00243865]
5 [ 1.00094836  2.00108385 -0.99796779]
6 [ 0.99942797  1.99966882 -1.00033118]
7 [ 1.00011039  2.00010036 -0.99983609]
8 [ 0.99995242  1.99996952 -1.00003568]
9 [ 1.00001132  2.00000925 -0.99998604]
10 [ 0.99999587  1.99999719 -1.00000354]
11 [ 1.0000011   2.00000085 -0.99999877]
12 [ 0.99999963  1.99999974 -1.00000034]
13 [ 1.0000001   2.00000008 -0.99999989]
[ 0.99999997  1.99999998 -1.00000003]
</pre>
<p> 厳密解は [1, -2, -1] ですが、ヤコビ法だと 13 回で収束しています。ガウス・ザイデル法を使うと、これよりも少ない階数で解を求めることができます。
</p>
<h4>●ガウス・ザイデル法</h4>
<p> ヤコビ法で漸化式を計算するとき、右辺式は x<sub>i</sub>, y<sub>i</sub> z<sub>i</sub> の値を使いますが、1 行目から順番に計算していくと、2 行目の y<sub>i+1</sub> を計算するときには x<sub>i+1</sub> の値がすでに求まっています。3 行目の z<sub>i+1</sub> を計算するときは、x<sub>i+1</sub> と y<sub>i+1</sub> の値が求まっています。これらの値を使って漸化式を計算する方法を「ガウス・ザイデル法 (Gauss-Siedel Method)」といいます。
</p>
<p> たとえば、三元連立方程式の場合、ガウス・ザイデル法の漸化式は下図のようになります。
</p>
<pre class="fig">
  a1 * x + a2 * y + a3 * z = d1
  b1 * x + b2 * y + b3 * z = d2
  c1 * x + c2 * y + c3 * z = d3

  A' = [[ 0, a2, a3],   D = [[a1,  0,  0],   D<sup>-1</sup> = [[1/a1, 0,   0],
        [b1,  0, b3],        [ 0, b2,  0],          [ 0,  1/b2, 0],
        {c1, c2,  0]]        [ 0,  0, c3]]          [ 0,   0,  1/c3]]

  x<sub>i+1</sub> = (d1 - a2 * y<sub>i</sub> - a3 * z<sub>i</sub>) / a1
  y<sub>i+1</sub> = (d2 - b1 * x<sub>i+1</sub> - b3 * z<sub>i</sub>) / b2
  z<sub>i+1</sub> = (d3 - c1 * x<sub>i+1</sub> - c2 * y<sub>i+1</sub>) / c3
</pre>
<p> ガウス・ザイデル法の解の収束条件や収束の判定方法はヤコビ法と同じです。
</p>
<h4>●ガウス・ザイデル法のプログラム</h4>
<p> それではプログラムを作りましょう。一般的なプログラミング言語の場合、ヤコビ法よりもガウス・ザイデル法のほうが簡単にプログラムできるのですが、NumPy の場合は逆にちょっとだけ複雑になります。
</p>
<pre class="list">
リスト : ガウス・ザイデル法

def gauss_seidel(a, b, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        err = 0.
        for j in range(len(x)):
            s = x[j]
            x[j] = (b[j] - a1[j] @ x) / d[j]
            err += abs((x[j] - s) / x[j])
        if err &lt; eps: return x
</pre>
<p> ポイントは 2 番目の for ループで配列 x の値を逐次的に更新していくところです。これで a1[j] @ x を計算するときに計算済みの値を用いることができます。変数 err には誤差の合計値を格納します。2 番目の for ループが終了したとき、err が eps よりも小さい場合、解は収束したので x を返します。
</p>
<p> それでは実際に試してみましょう。
<pre class="item">
9x +  y + 2z = 9
 x + 9y +  z = 18
2x +  y + 9z = -5
</pre>
<pre>
0 [ 0.  0.  0.]
1 [ 1.          1.88888889 -0.98765432]
2 [ 1.00960219  1.99756135 -1.00186286]
3 [ 1.00068493  2.00013088 -1.00016675]
4 [ 1.00002251  2.00001603 -1.00000678]
5 [ 0.99999973  2.00000078 -1.00000003]
[ 0.99999992  2.00000001 -0.99999998]
</pre>
<p> ヤコビ法だと収束するまで 13 回かかっていたのが、ガウス・ザイデル法を使うと 5 回ですみました。
</p>
<h4>●簡単なテスト</h4>
<p> それでは簡単なテストとして、ガウスの消去法、ヤコビ法、ガウス・ザイデル法の実行時間を比較してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 簡単なテスト

# テストデータの作成
def test(n):
    a = np.random.rand(n * n).reshape((n, n))
    for i in range(n):
        a[i, i] = (a[:, i].sum()) * 2
    x = np.random.rand(n)
    return a, x, a @ x

for n in [500, 1000, 1500, 2000]:
    a, x, b = test(n)
    print("-----", n, "-----")
    for f, n in [(gauss, "gauss"), (jacobi, "jacobi"), (gauss_seidel, "gauss_seidel")]:
        print(n)
        s = time.time()
        x1 = f(a, b)
        e = time.time()
        print(np.fabs(x1 - x).sum(), e - s)
</pre>
<p> 乱数でテストデータを生成します。これを関数 test() で行っています。連立方程式 Ax = b の係数行列 A と解 x を乱数で生成して、右辺値の b を計算します。係数行列は対角優位になるよう修正しています。test() は A, x, b を返すので、A と b から x を求め、その誤差と実行時間を表示します。
</p>
<p> 実行結果は次のようになりました。
</p>
<pre>
----- 500 -----
gauss
3.12370788957e-13 0.3612337112426758
jacobi
2.70284279515e-08 0.01547098159790039
gauss_seidel
7.00478601555e-09 0.022022724151611328
----- 1000 -----
gauss
8.4839817463e-13 2.0641372203826904
jacobi
2.75979188328e-08 0.06420445442199707
gauss_seidel
2.03730985771e-09 0.06721687316894531
----- 1500 -----
gauss
1.64524860749e-12 5.417415380477905
jacobi
4.37321936338e-08 0.14313483238220215
gauss_seidel
3.10799718514e-09 0.12006211280822754
----- 2000 -----
gauss
2.46680139423e-12 10.766422271728516
jacobi
2.8758863701e-08 0.2580835819244385
gauss_seidel
4.11025852704e-09 0.18568634986877441

実行環境 : Windows 10, Intel Core i5-6200U 2.30GHz
</pre>
<p> 変数の個数が増えるにしたがい、ガウスの消去法の実行時間は大幅に増加します。反復法でも遅くはなりますが、ガウスの消去法よりはずっと高速です。ヤコビ法とガウス・ザイデル法を比較した場合、変数の個数が少ないときはヤコビ法のほうが速くなりました。Python の実行速度は遅いので、二重の for ループになるガウス・ザイデル法よりも、NumPy で高速に処理できるヤコビ法のほうが速くなるのでしょう。興味のある方はいろいろ試してみてください。
</p>
<h4>●SOR 法</h4>
<p> 「SOR 法 (Successive Over-Relaxation)」は、ヤコビ法の漸化式に加速パラメータ w を導入することで収束を速くする方法です。具体的には、ヤコビ法で求めた値 x<sub>i+1</sub> と x<sub>i</sub> の差分に w を掛け算し、その値を x<sub>i</sub> に足し算します。SOR 法の漸化式は次のようになります。
</p>
<pre class="item">
x<sub>i+1</sub> = x<sub>i</sub> + w * (D<sup>-1</sup>(b - A'x<sub>i</sub>) - x<sub>i</sub>)
=&gt; x<sub>i+1</sub> = (1 - w) * x<sub>i</sub> + w * D<sup>-1</sup>(b - A'x<sub>i</sub>)
</pre>
<p> 漸化式は <a href="numpy07.html#cite">参考 URL 6</a> を参考にさせていただきました。また、w が 0 &lt; w &lt; 2 のとき SOR 法は収束するそうです。w が 1 のときはヤコビ法と同じになります。一般に、w を 1 より大きくすると収束が速くなり、1 より小さくすると遅くなるといわれています。ところが <a href="numpy07.html#cite">参考 URL 3</a> によると、1 より小さくしたほうが収束が速くなる場合もあるそうです。これは後で試してみましょう。連立方程式によって w の最適値は変化するでしょうから、w の選択はけっこう難しい問題なのかもしれません。
</p>
<h4>●SOR 法のプログラム</h4>
<p> それではプログラムを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : SOR 法

# ヤコビ法
def jacobi_sor(a, b, w, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        x1 = (1 - w) * x + w * (b - a1 @ x) / d
        if np.fabs((x1 - x) / x1).sum() &lt; eps:
            return x1
        x = x1

# ガウス・ザイデル法
def gauss_seidel_sor(a, b, w, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        err = 0.
        for j in range(len(x)):
            s = x[j]
            x[j] = (1 - w) * s + w * (b[j] - a1[j] @ x) / d[j]
            err += abs((x[j] - s) / x[j])
        if err &lt; eps: return x
</pre>
<p> 関数 jacobi_sor() と gauss_seidel_sor() の引数 w が加速パラメータを表します。どちらの関数も SOR 法の漸化式をそのままプログラムしただけなので、難しいところはないと思います。
</p>
<h4>●簡単なテスト (2)</h4>
<p> それでは実行してみましょう。次に示す方程式を SOR 法で解いたときの収束回数を示します。
</p>
<pre class="item">
9x +  y + 2z = 9
 x + 9y +  z = 18
2x +  y + 9z = -5
</pre>
<pre class="fig">
   w   |  0.9  0.925  0.95  0.975  1.0  1.025  1.05  1.075  1.1
-------+--------------------------------------------------------
Jacobi |  12    12    11     12    13    14    15     16    18
Gauss  |   8     8     7      6     5     5     6      7     8
</pre>
<p> ヤコビ法の場合、w が 0.95 のとき、収束回数が一番少なくなりました。ガウス・ザイデル法の場合、このような簡単な方程式では SOR 法の効果はほとんどないようです。
</p>
<p> 次は test() で作成した方程式を解いてみましょう。テストプログラムと実行結果を示します。
</p>
<pre class="list">
リスト : 簡単なテスト

for n in [500, 1000, 1500, 2000]:
    a, x, b = test(n)
    print("-----", n, "-----")
    for f, n, w in [(jacobi_sor, "jacobi", 0.9), (gauss_seidel_sor, "gauss_seidel", 0.95)]:
        print(n)
        s = time.time()
        x1 = f(a, b, w)
        e = time.time()
        print(np.fabs(x1 - x).sum(), e - s)
</pre>
<pre>
----- 500 -----
jacobi
2.23327647078e-08 0.011053323745727539
gauss_seidel
5.27912784798e-09 0.022308349609375
----- 1000 -----
jacobi
1.54129253341e-08 0.0484774112701416
gauss_seidel
6.8278132177e-10 0.06422185897827148
----- 1500 -----
jacobi
2.44906892969e-08 0.10906100273132324
gauss_seidel
1.11494481226e-09 0.12014651298522949
----- 2000 -----
jacobi
3.19235474893e-08 0.1821589469909668
gauss_seidel
1.37436358821e-09 0.1852719783782959
</pre>
<p> ヤコビ法の場合、w を 0.9 にすると収束回数が 10 回以上減少し、その分だけ実行速度も速くなりました。ガウス・ザイデル法の場合、w を 0.95 にすると収束回数は数回減少しますが、実行速度はほとんど変わりませんでした。今回のテストでは w を 1 より増やすと、どちらの方法でも収束回数は大幅に増加します。w の設定は教科書通りにはいきませんね。収束の判定方法や許容誤差の値を変えると、異なる結果になるかもしれません。興味のある方はいろいろ試してみてください。
</p>
<h4 id="cite">●参考文献・URL</h4>
<ol>
  <li>奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991</li>
  <li><a href="http://www.yamamo10.jp/yamamoto/lecture/2007/5E_comp_app/LinearEquations/relaxation_html/index.html">連立一次方程式(反復法)</a>, (山本昌志さん)</li>
  <li><a href="http://fussy.web.fc2.com/algo/math8_les2.htm">数値演算法 (8) 連立方程式を解く -2-</a>, (fussy さん)</li>
  <li><a href="https://ja.wikipedia.org/wiki/%E3%83%A4%E3%82%B3%E3%83%93%E6%B3%95">ヤコビ法 - Wikipedia</a></li>
  <li><a href="https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%EF%BC%9D%E3%82%B6%E3%82%A4%E3%83%87%E3%83%AB%E6%B3%95">ガウス＝ザイデル法 - Wikipedia</a></li>
  <li><a href="https://ja.wikipedia.org/wiki/SOR%E6%B3%95">SOR法 - Wikipedia</a></li>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
#
# jacobi.py : 連立方程式の解法 (反復法)
#
#             Copyright (C) 2018 Makoto Hiroi
#
import numpy as np
import time

# ガウスの消去法
def gauss(xs, ys):
    # 拡大係数行列の生成
    n = len(xs)
    zs = np.c_[xs.astype(np.float_), ys.astype(np.float_)]
    # 前進消去
    for i in range(n - 1):
        for j in range(i + 1, n):
            temp = zs[j, i] / zs[i, i]
            zs[j, i:] -= temp * zs[i, i:]
    # 後退代入
    for i in range(n - 1, -1, -1):
        zs[i, n] -= zs[i, i+1:n] @ zs[i+1:, n]
        zs[i, n] /= zs[i, i]
    return zs[:, n]

# ヤコビ法
def jacobi(a, b, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        x1 = (b - a1 @ x) / d
        if np.fabs((x1 - x) / x1).sum() &lt; eps:
            return x1
        x = x1

# ガウス・ザイデル法
def gauss_seidel(a, b, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        err = 0.
        for j in range(len(x)):
            s = x[j]
            x[j] = (b[j] - a1[j] @ x) / d[j]
            err += abs((x[j] - s) / x[j])
        if err &lt; eps: return x

# テストデータの作成
def test(n):
    a = np.random.rand(n * n).reshape((n, n))
    for i in range(n):
        a[i, i] = (a[:, i].sum()) * 2
    x = np.random.rand(n)
    return a, x, a @ x

#
# SOR 法
#

# ヤコビ法
def jacobi_sor(a, b, w, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        x1 = (1 - w) * x + w * (b - a1 @ x) / d
        if np.fabs((x1 - x) / x1).sum() &lt; eps:
            return x1
        x = x1

# ガウス・ザイデル法
def gauss_seidel_sor(a, b, w, max_iter=512, eps=1e-6):
    d = np.diag(a)
    a1 = a - np.diag(d)
    x = np.full(len(b), 0.)
    for i in range(max_iter):
        err = 0.
        for j in range(len(x)):
            s = x[j]
            x[j] = (1 - w) * s + w * (b[j] - a1[j] @ x) / d[j]
            err += abs((x[j] - s) / x[j])
        if err &lt; eps: return x
</pre>
</section>
<hr>
<section class="contents">
<h4 id="chap26">●固有値と固有ベクトル</h4>
<p> 今回は「固有値 (eigenvalue)」と「固有ベクトル (eigenvector)」について取り上げます。固有値と固有ベクトルは行列の性質を表す重要な指標のひとつで、行列を対角行列に変換する「対角化」の基礎になります。対角行列は単純な構造をしているので、いろいろな計算が簡単になるという利点があります。たとえば、対角行列 A の逆行列は対角成分を逆数にしたものですし、A の n 乗は対角成分を n 乗したものになります。また、A の行列式も対角成分を掛け算するだけで求めることができます。
</p>
<p> 与えられた行列の固有値と固有ベクトルを求める問題のことを「固有値問題」といいます。NumPy には固有値と固有ベクトルを求める関数 linalg.eig() が用意されていますが、Python (NumPy) とアルゴリズムのお勉強ということで、あえてプログラムを作ってみましょう。
</p>
<h4>●特殊な行列とその性質</h4>
<p> まず最初に、特殊な行列とその性質について簡単に説明します。行列 A の行と列を入れ替えたものを「転置行列 (transposed matrix)」といい A<sup>T</sup> と表記します。NumPy では A.T で転置行列を求めることができます。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; a.T
array([[1, 3],
       [2, 4]])
&gt;&gt;&gt; b = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; b
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; b.T
array([[0, 3, 6],
       [1, 4, 7],
       [2, 5, 8]])
&gt;&gt;&gt; c = np.arange(6).reshape((3, 2))
&gt;&gt;&gt; c
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; c.T
array([[0, 2, 4],
       [1, 3, 5]])
</pre>
<p> 転置行列の基本的な性質を以下に示します。A は正方行列を表します。
</p>
<ol>
  <li>trace(A<sup>T</sup>) = trace(A)</li>
  <li>|A<sup>T</sup>| = |A|, (|A| は A の行列式)</li>
  <li>(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup></li>
  <li>(A<sup>T</sup>)<sup>-1</sup> = (A<sup>-1</sup>)<sup>T</sup></li>
</ol>
<p> 簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; a
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; np.trace(a)
5
&gt;&gt;&gt; np.trace(a.T)
5
&gt;&gt;&gt; np.linalg.det(a)
-2.0
&gt;&gt;&gt; np.linalg.det(a.T)
-2.0
&gt;&gt;&gt; b = np.array([[5, 6], [7, 8]])
&gt;&gt;&gt; b
array([[5, 6],
       [7, 8]])
&gt;&gt;&gt; (a @ b).T
array([[19, 43],
       [22, 50]])
&gt;&gt;&gt; b.T @ a.T
array([[19, 43],
       [22, 50]])
&gt;&gt;&gt; np.linalg.inv(a.T)
array([[-2. ,  1.5],
       [ 1. , -0.5]])
&gt;&gt;&gt; np.linalg.inv(a).T
array([[-2. ,  1.5],
       [ 1. , -0.5]])
</pre>
<p> 正方行列 A とその転置行列 A<sup>T</sup> が等しい行列のことを「対称行列 (symmetric matrix)」といい、その中で対角成分 a<sub>ii</sub> 以外の要素が 0 の行列のことを「対角行列 (diagonal matrix)」といいます。単位行列は対角行列の一種です。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = np.array([[1, 3], [3, 2]])
&gt;&gt;&gt; a
array([[1, 3],
       [3, 2]])
&gt;&gt;&gt; a.T
array([[1, 3],
       [3, 2]])

&gt;&gt;&gt; b = np.array([[1, 4, 5], [4, 2, 6], [5, 6, 3]])
&gt;&gt;&gt; b
array([[1, 4, 5],
       [4, 2, 6],
       [5, 6, 3]])
&gt;&gt;&gt; b.T
array([[1, 4, 5],
       [4, 2, 6],
       [5, 6, 3]])

&gt;&gt;&gt; c = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
&gt;&gt;&gt; c
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
&gt;&gt;&gt; c.T
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
</pre>
<p> 対角行列 A の基本的な性質を以下に示します。
</p>
<ol>
  <li>|A| は対角成分 a<sub>ii</sub> を乗算した値になる</li>
  <li>A<sup>n</sup> は対角成分 a<sub>ii</sub> を n 乗したものになる</li>
  <li>A<sup>-1</sup> は対角成分 a<sub>ii</sub> を逆数にしたものになる</li>
  <li>対角行列の固有値は対角成分 a<sub>ii</sub> になる</li>
</ol>
<p> 4 はあとで説明します。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; c
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
&gt;&gt;&gt; np.linalg.det(c)
6.0
&gt;&gt;&gt; np.diag(c).prod()
6

&gt;&gt;&gt; c @ c
array([[1, 0, 0],
       [0, 4, 0],
       [0, 0, 9]])
&gt;&gt;&gt; c @ c @ c
array([[ 1,  0,  0],
       [ 0,  8,  0],
       [ 0,  0, 27]])
&gt;&gt;&gt; c ** 2
array([[1, 0, 0],
       [0, 4, 0],
       [0, 0, 9]])
&gt;&gt;&gt; c ** 3
array([[ 1,  0,  0],
       [ 0,  8,  0],
       [ 0,  0, 27]])

&gt;&gt;&gt; np.linalg.inv(c)
array([[ 1.        ,  0.        ,  0.        ],
       [ 0.        ,  0.5       ,  0.        ],
       [ 0.        ,  0.        ,  0.33333333]])
&gt;&gt;&gt; np.diag(1 / np.diag(c))
array([[ 1.        ,  0.        ,  0.        ],
       [ 0.        ,  0.5       ,  0.        ],
       [ 0.        ,  0.        ,  0.33333333]])
</pre>
<p> A<sup>T</sup> と A<sup>-1</sup> が等しい行列のことを「直交行列 (orthogonal matrix)」といいます。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; d = np.array([[0, 1], [1, 0]])
&gt;&gt;&gt; d
array([[0, 1],
       [1, 0]])
&gt;&gt;&gt; d.T
array([[0, 1],
       [1, 0]])
&gt;&gt;&gt; np.linalg.inv(d)
array([[ 0.,  1.],
       [ 1.,  0.]])

&gt;&gt;&gt; e = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; e
array([[0, 1, 0],
       [1, 0, 0],
       [0, 0, 1]])
&gt;&gt;&gt; e.T
array([[0, 1, 0],
       [1, 0, 0],
       [0, 0, 1]])
&gt;&gt;&gt; np.linalg.inv(e)
array([[ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.]])
</pre>
<p> d と e のように、各行各列にちょうど一つだけ 1 の要素を持ち、それ以外は全て 0 となるような正方行列を「置換行列」といいます。置換行列を掛け算すると、列または行を入れ替える働きをします。
</p>
<p> 直交行列の基本的な性質を以下に示します。
</p>
<ol>
  <li>直交行列の行列式は ±1</li>
  <li>直交行列の逆行列も直交行列</li>
  <li>対称行列は直交行列で対角化できる</li>
</ol>
<p> 3 はあとで説明します。簡単な例を示しましょう。
</p>
<pre class="fig">
回転行列 R は直交行列

R = [[cos(x), -sin(x)],
     [sin(x),  cos(x)]]

転置行列
R<sup>T</sup> = [[cos(x), sin(x)]
      [-sin(x), cos(x)]]

行列式 |R| = cos(x) * cos(x) + sin(x) * sin(x) = 1

逆行列
R<sup>-1</sup> = [[cos(x), sin(x)],
       [-sin(x), cos(x)]]          

逆行列の転置 (R に戻るので直交行列)
(R<sup>-1</sup>)<sup>T</sup> = [[cos(x), -sin(x)],
          [sin(x), cos(x)]]
</pre>
<h4>●固有値と固有ベクトルの定義</h4>
<p> 次は固有値と固有ベクトルの基本を簡単に説明します。n 次の正方行列 A に対して、Ax = λx を満たす数 λ を A の「固有値」、ゼロではないベクトル x を A の「固有ベクトル」といいます。このとき、固有値は |A - λI| = 0 の根になります。この式を「固有方程式」とか「特性方程式」といいます。
</p>
<p> Ax = λx を変形すると (A - λI)x = 0 になります。行列 (A - λI) に逆行列が存在する場合、両辺にその逆行列を掛け算すると x = 0 になってしまいます。つまり、ゼロではないベクトル x が存在するためには、逆行列が存在しないこと (|A - λI| = 0) が条件になるわけです。
</p>
<h4>●固有値と固有ベクトルの求め方</h4>
<p> それでは、具体的に固有値と固有ベクトルを求めてみましょう。たとえば、行列 [[1, 2], [2, 1]] の固有値は以下のようになります。
</p>
<pre class="fig">
A = [[1, 2],  A - λI = [[1 - λ, 2],
     [2, 1]]             [2, 1 - λ]]

|A - λI| = (1 - λ) * (1 - λ) - 4
          = λ<sup>2</sup> - 2 λ - 3
          = (λ- 3)(λ+ 1) = 0

固有値 λ= 3, -1
</pre>
<p> 固有値が求まったら、連立方程式 (A - λI)x = 0 を解いて固有ベクトル x を求めます。
</p>
<pre class="fig">
(1) λ= 3 の場合

[[1 - 3, 2    ], * [a, b] = 0
 [2,     1 - 3]]

-2a + 2b = 0, 2a - 2b = 0 =&gt; a = b なので x = k * [1, 1] (k は任意の数, ただし k != 0)

単位ベクトル (大きさ 1 のベクトル) で表すと

[1, 1]  / √(1<sup>2</sup> +1<sup>2</sup>) = [√2 / 2, √2 / 2]

実際に計算すると

[[1, 2], * [√2 / 2, √2 / 2] = [√2 / 2 + 2*√2 / 2, 2*√2 / 2 + √2 / 2] = 3 * [√2 / 2, √2 / 2]
 [2, 1]]

Ax = λx を満たす
</pre>
<pre class="fig">
(2) λ= -1 の場合

[[1 + 1, 2    ], * [a, b] = 0
 [2,     1 + 1]]

2a + 2b = 0, 2a + 2b = 0 =&gt; a = -b なので x = k * [-1, 1] (k は任意の数, ただし k != 0)

単位ベクトルで表すと

[-1, 1] / √(1<sup>2</sup> +1<sup>2</sup>) = [-√2 / 2, √2 / 2]

実際に計算すると

[[1, 2], * [-√2 / 2, √2 / 2] = [-√2 / 2 + 2*√2 / 2, -2*√2 / 2 + √2 / 2] = -1 * [-√2 / 2, √2 / 2]
 [2, 1]]

Ax = λx を満たす
</pre>
<p> 一般に、n 次の正方行列 A は n 個の固有値とそれに対応する固有ベクトルを持ちます。なお、固有方程式が重根を持つ場合、固有値の個数は n よりも少なくなります。
</p>
<p> それでは実際に NumPy で固有値と固有ベクトルを求めてみましょう。関数 linalg.eig() を使います。
</p>
<pre>
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.linalg.eig(np.array([[1, 2], [2, 1]]))
(array([ 3., -1.]), array([[ 0.70710678, -0.70710678],
       [ 0.70710678,  0.70710678]]))

&gt;&gt;&gt; np.linalg.eig(np.array([[4, -2], [1, 1]]))
(array([ 3.,  2.]), array([[ 0.89442719,  0.70710678],
       [ 0.4472136 ,  0.70710678]]))

&gt;&gt;&gt; np.linalg.eig(np.diag([1, 2, 3]))
(array([ 1.,  2.,  3.]), array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]]))
&gt;&gt;&gt; np.linalg.eig(np.diag([4, 3, 2, 1]))
(array([ 4.,  3.,  2.,  1.]), array([[ 1.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.],
       [ 0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  1.]]))
</pre>
<p> eig() の返り値を (xs, ys) とすると、固有値 xs[i] に対応する固有ベクトルは ys[:, i] になります。つまり、ys は固有ベクトルを列に持つ行列になります。そして、3, 4 番目の例のように、対角行列の固有値は対角成分の値となります。
</p>

<h4>●行列の対角化</h4>
<p> n 次の正方行列 A の固有ベクトル x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub> を列に持つ行列 X = [x<sub>1</sub>, x<sub>2</sub>, ...., x<sub>n</sub>] を考えます。すると、X によって行列 A を以下のように対角行列 Λ に変換することができます。
</p>
<pre class="item">
X<sup>-1</sup>AX = Λ (ただし Λ は行列 A の固有値 λ<sub>i</sub> を格納した対角行列)
</pre>
<p> 固有値と固有ベクトルの定義 Ax<sub>i</sub> = λ<sub>i</sub>x<sub>i</sub> から AX は次のように変形することができます。
</p>
<pre class="item">
AX = [Ax<sub>1</sub>, ... Ax<sub>n</sub>]
   = [λ<sub>1</sub>x<sub>1</sub>, ..., λ<sub>n</sub>x<sub>n</sub>]
   = [x<sub>1</sub>, ..., x<sub>n</sub>] @ [[λ<sub>1</sub>, 0, ...], ..., [0, ..., λ<sub>n</sub>]]
   = XΛ
</pre>
<p> 左側から両辺に X の逆行列を掛け算すれば X<sup>-1</sup>AX = Λ となります。
</p>
<p> それでは実際に NumPy で試してみましょう。
</p>
<pre>
&gt;&gt;&gt; a = np.array([[1, 2], [2, 1]])
&gt;&gt;&gt; xs, ys = np.linalg.eig(a)
&gt;&gt;&gt; xs
array([ 3., -1.])
&gt;&gt;&gt; ys
array([[ 0.70710678, -0.70710678],
       [ 0.70710678,  0.70710678]])
&gt;&gt;&gt; np.linalg.inv(ys) @ a @ ys
array([[  3.00000000e+00,   4.44089210e-16],
       [  6.66133815e-16,  -1.00000000e+00]])

&gt;&gt;&gt; b = np.array([[4, -2], [1, 1]])
&gt;&gt;&gt; xs, ys = np.linalg.eig(b)
&gt;&gt;&gt; xs
array([ 3.,  2.])
&gt;&gt;&gt; ys
array([[ 0.89442719,  0.70710678],
       [ 0.4472136 ,  0.70710678]])
&gt;&gt;&gt; np.linalg.inv(ys) @ b @ ys
array([[ 3.,  0.],
       [ 0.,  2.]])
</pre>
<p> 数学 (線形代数) の世界では、正則行列 P を用いて正方行列 A を P<sup>-1</sup>AP に変換することを「相似変換」といい、B = P<sup>-1</sup>AP が成り立つ正方行列 A, B の関係を「相似」といいます。相似な行列 A と B の間は様々な性質が保存されます。保存される主な性質を以下に示します。
</p>
<ul>
  <li>階数</li>
  <li>トレース</li>
  <li>行列式</li>
  <li>固有値</li>
</ul>
<p> つまり、相似変換を行ってもこれらの値が変化することはありません。たとえば、正方行列 A を相似変換により対角行列に変換します。対角行列は対角成分が固有値になるので、トレースは固有値の総和になります。相似変換でトレースは保存されるので、行列 A のトレースも固有値の総和であることがわかります。
</p>
<h4>●実対称行列</h4>
<p> 要素がすべて実数の対称行列を「実対称行列」といいます。実対称行列には次に示す性質があります。
</p>
<ol>
  <li>固有値はすべて実数</li>
  <li>二つの異なる固有値に対する固有ベクトルは直交する (内積が 0 になる)</li>
  <li>適当な直交行列 L によって L<sup>T</sup>AL が対角行列になるように変換できる</li>
</ol>
<p> 3 は直交行列の定義 L<sup>T</sup> = L<sup>-1</sup> から明らかです。2 は固有ベクトルが「一次独立」であることを言っています。ベクトル x<sub>1</sub>, ..., x<sub>i</sub>, ..., x<sub>n</sub> において、式 a<sub>1</sub>x<sub>1</sub> + ... + a<sub>i</sub>x<sub>i</sub> + ... + a<sub>n</sub>x<sub>n</sub> = 0 が成り立つとき、係数 a<sub>i</sub> = 0 (i = 1, ..., n) 以外の解がないことを一次独立といいます。逆に、係数 a<sub>i</sub> != 0 (i = 1, ..., n) であっても式が 0 になることを「一次従属」といいます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="fig">
[[1, 0, 0]
 [0, 2, 0],  の固有値 [1, 2, 3], 固有ベクトル [1, 0, 0], [0, 1, 0], [0, 0, 1]
 [0, 0, 3]]

      [1,         [0,         [0,    [0,
 a1 *  0,  + a2 *  1,  + a3 *  0   =  0,
       0]          0]          1]     0]

 a1 * 1 + a2 * 0 + a3 * 0 = 0 =&gt; a1 = 0
 a1 * 0 + a2 * 1 + a3 * 0 = 0 =&gt; a2 = 0
 a1 * 0 + a2 * 0 + a3 * 1 = 0 =&gt; a3 = 0
</pre>
<p> このように、実対称行列の固有ベクトルは一次独立になります。
</p>
<p> それでは実際に NumPy で試してみましょう。
</p>
<pre>
&gt;&gt;&gt; a
array([[1, 2],
       [2, 1]])
&gt;&gt;&gt; xs, ys = np.linalg.eig(a)
&gt;&gt;&gt; xs
array([ 3., -1.])
&gt;&gt;&gt; ys
array([[ 0.70710678, -0.70710678],
       [ 0.70710678,  0.70710678]])
&gt;&gt;&gt; ys[:, 0] @ ys[:, 1]
0.0
&gt;&gt;&gt; ys.T @ a @ ys
array([[  3.00000000e+00,   4.44089210e-16],
       [  6.10622664e-16,  -1.00000000e+00]])

&gt;&gt;&gt; b
array([[1, 4, 5],
       [4, 2, 6],
       [5, 6, 3]])
&gt;&gt;&gt; xs, ys = np.linalg.eig(b)
&gt;&gt;&gt; xs
array([ 12.17597107,  -2.50728797,  -3.6686831 ])
&gt;&gt;&gt; ys
array([[ 0.49659978,  0.80958546, -0.31298568],
       [ 0.57735027, -0.57735027, -0.57735027],
       [ 0.64811675, -0.10600965,  0.7541264 ]])
&gt;&gt;&gt; ys[:, 0] @ ys[:, 1]
-9.7144514654701197e-17
&gt;&gt;&gt; ys[:, 0] @ ys[:, 2]
-5.5511151231257827e-17
&gt;&gt;&gt; ys[:, 1] @ ys[:, 2]
-4.8572257327350599e-16
&gt;&gt;&gt; ys.T @ b @ ys
array([[  1.21759711e+01,  -2.99760217e-15,   0.00000000e+00],
       [ -2.02615702e-15,  -2.50728797e+00,   4.44089210e-16],
       [ -8.88178420e-16,   1.11022302e-15,  -3.66868310e+00]])
</pre>
<p> なお、NumPy の linalg.eig() は一般の行列の固有値と固有ベクトルを求める関数ですが、対称行列であれば関数 linalg.eigh() を使うこともできます。詳細はリファレンスマニュアル <a href="https://docs.scipy.org/doc/numpy/reference/routines.linalg.html">Linear algebra</a> をお読みください。
</p>
<pre>
&gt;&gt;&gt; a
array([[1, 2],
       [2, 1]])
&gt;&gt;&gt; np.linalg.eigh(a)
(array([-1.,  3.]), array([[-0.70710678,  0.70710678],
       [ 0.70710678,  0.70710678]]))

&gt;&gt;&gt; b
array([[1, 4, 5],
       [4, 2, 6],
       [5, 6, 3]])
&gt;&gt;&gt; np.linalg.eigh(b)
(array([ -3.6686831 ,  -2.50728797,  12.17597107]), array([[-0.31298568,  0.80958546, -0.49659978],
       [-0.57735027, -0.57735027, -0.57735027],
       [ 0.7541264 , -0.10600965, -0.64811675]]))

&gt;&gt;&gt; c = np.ones((5, 5))
&gt;&gt;&gt; c += np.diag([6, 7, 8, 9, 10])
&gt;&gt;&gt; c
array([[  7.,   1.,   1.,   1.,   1.],
       [  1.,   8.,   1.,   1.,   1.],
       [  1.,   1.,   9.,   1.,   1.],
       [  1.,   1.,   1.,  10.,   1.],
       [  1.,   1.,   1.,   1.,  11.]])
&gt;&gt;&gt; np.linalg.eigh(c)
(array([  6.27769582,   7.35663185,   8.43473667,   9.54039443,  13.39054123]), 
array([[ 0.91678475, -0.21893977,  0.13337217, -0.09513681,  0.29108754],
       [-0.35246548, -0.83284951,  0.22633151, -0.13258644,  0.33663729],
       [-0.14781784,  0.46166517,  0.74694901, -0.21865948,  0.39908692],
       [-0.09351905,  0.18073897, -0.57446875, -0.6232889 ,  0.4899839 ],
       [-0.06839508,  0.11236447, -0.20745782,  0.73284978,  0.63449885]]))
</pre>
<h4 id="cite26">●参考文献・URL</h4>
<ol>
  <li>奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991</li>
  <li><a href="https://www.sist.ac.jp/~suganuma/kougi/other_lecture/SE/math/linear/linear.htm">線形代数</a>, (菅沼さん)</li>
  <li><a href="http://nalab.mind.meiji.ac.jp/~mk/labo/text/eigenvalues.pdf">行列の固有値問題 (PDF)</a>, (桂田祐史さん)</li>
  <li><a href="http://dora.bk.tsukuba.ac.jp/~takeuchi/?%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0%EF%BC%A9%2F%E5%9B%BA%E6%9C%89%E5%80%A4%E3%81%A8%E5%9B%BA%E6%9C%89%E3%83%99%E3%82%AF%E3%83%88%E3%83%AB">固有値と固有ベクトル</a>, (武内修さん)</li>
  <li><a href="https://mathtrain.jp/eigenvalue">固有値，固有ベクトルの定義と具体的な計算方法 | 高校数学の美しい物語</a></li>
  <li><a href="https://ja.wikipedia.org/wiki/%E5%9B%BA%E6%9C%89%E5%80%A4">固有値 - Wikipedia</a></li>
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#numpy_abc">Python3</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>