<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / ブロックソート</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881797</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>ブロックソート (BlockSorting)</h2>
<div class="small">
[ <a href="pyalgo47.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo49.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> データ圧縮のお話です。ファイルの圧縮ツールといえば zip が標準ツールとして一般に広く普及しています。このほかに、日本では LHA を使うことも多く、UNIX 系の OS では gzip がよく使われています。gzip を使う場合、複数のファイルをアーカイバ tar でまとめてから圧縮することになるので、その場合は拡張子が tar.gz や tgz になります。
</p>

<p> 最近は、拡張子が bz2 というファイルもよく見かけるようになりました。このファイルは bzip2 というツールで圧縮されていて、一般的なファイルでは zip, LHA, gzip よりも高い圧縮率になります。bzip2 の作者は Julian Seward で、<a href="http://www.bzip.org/">bzip2 : Home</a> からダウンロードできます。
</p>

<p> bzip2 の圧縮率が高いのは「ブロックソート (BlockSorting) 」という方法を使っているからです。ブロックソート法は 1994 年に M. Burrows と D. J. Wheeler が提案した方法で、Burrows-Wheeler Transform (BWT) と呼ばれることもあります。ブロックソート法はデータを圧縮するのではなく、データを圧縮しやすい形に変換するだけです。そして、ほかの方法でいっきに圧縮するわけです。
</p>

<p> ブロックソート法を採用した圧縮ツールは bzip2 以外にもありますが、日本では <a href="http://www.emit.jp/">鶴田真一さん</a> が作成された GCA, DGCA が素晴らしい性能を発揮しているようです。今回はブロックソートを使ってファイルを圧縮してみましょう。 
</p>

<h4>●ブロックソートの符号化</h4>
<p> 最初に、ブロックソートについて簡単に説明します。ブロックソートというと、なにやら難しいソートを使うのではないか、と思われた方もいるでしょう。M.Hiroi も最初はそのように思いました。ところが、ブロックソートという特別なソートがあるわけではありません。ブロックソートの動作はとても簡単で、特別なソートを使わなくても実現できます。ただし、ソートは時間がとてもかかる処理なので、実用的なツールを作成する場合、時間を短縮するための工夫が必要になります。
</p>

<p> それでは、記号列 "aeadacab" をブロックソートしてみましょう。まず、記号列を 1 記号ずつシフトして、新しい記号列を生成します。これを記号列が 1 回転するまで続けます。生成された記号列は、次のようになります。
</p>

<pre class="fig">
0:aeadacab      0:abaeada<font color="red">c</font>
1:eadacaba      1:acabaea<font color="red">d</font>
2:adacabae      2:adacaba<font color="red">e</font>
3:dacabaea      3:aeadaca<font color="red">b</font>  &lt;- 元のデータ
4:acabaead      4:baeadac<font color="red">a</font>
5:cabaeada      5:cabaead<font color="red">a</font>
6:abaeadac      6:dacabae<font color="red">a</font>
7:baeadaca      7:eadacab<font color="red">a</font>

(1) シフト      (2)ソート      (3) 出力：<font color="red">3, cdebaaaa</font>  


        図：ブロックソートの符号化
</pre>

<p> 図 (1) に示すように、生成された記号列は元のデータを含めて 8 個になります。次に、これらの記号列をソートします。その結果は (2) のようになります。最後に、(2) から元のデータの「位置」と、各記号列の「最後の記号」を順番に取り出して出力します。これでブロックソートは終了です。記号列は 1 回転しているので、最後の記号を順番に取り出すことで記号の並びは変わりますが、記号列の中身（a が 4 個、b, c, d, e が 1 個）に変わりはありません。ようするに、ブロックソートは記号列 "aeadacab" を "cdebaaaa" に変換しているだけなのです。
</p>

<p>ここで、変換後の記号列 "cdebaaaa" に注目してください。同じ記号 a が並んでいることがわかりますね。これがブロックソートの効果です。この例では記号は 8 個しかありませんが、もっと長い記号列をブロックソートすれば、同じ記号をたくさん並べることができます。たとえば、the を多数含むテキストをブロックソートすると、"e ..... th" や "he ..... t" といった記号列が生成されます。その結果、変換後の記号列には多数の h や t が並ぶことになるわけです。
</p>

<p> このように、ブロックソートはデータを並べ替えただけなので、記号の出現頻度はまったく変わっていないことに注意してください。したがって、このデータをそのままハフマン符号やレンジコーダで圧縮しても、効果はまったくありません。それでは、連長圧縮 (ランレングス) を使ってみよう、と思われた方もいるでしょう。確かにランレングスでもある程度は圧縮できるのですが、それよりも記号の出現頻度を偏った方向へ変換できれば、高い圧縮率を達成することができるはずです。
</p>

<p> 一番簡単な方法は、ブロックソートのあとに「MTF (Move-To-Front) 法」を適用することです。MTF 法でデータを変換すると、ハフマン符号やレンジコーダでも効率よく圧縮することができます。MTF 法については、あとで詳しく説明します。
</p>

<h4>●ブロックソートの復号</h4>
<p> 次はブロックソートの復号について説明します。記号列 "aeadacab" をブロックソートで変換すると、"cdebaaaa" と元のデータの位置 3 を出力しました。この情報から元のデータを復号します。ブロックソートの復号は、パズルを解くみたいで実に面白い方法です。次の図を見てください。
</p>

<pre class="fig">
       0 1 2 3 4 5 6 7
      -----------------
       c d e b a a a a
              │
              │ ソートする
              ↓
             0: a ...... c    [4] ...... [0]    c [0] -&gt; a [4]
             1: a ...... d    [5] ...... [1]    d [1] -&gt; a [5]
             2: a ...... e    [6] ...... [2]    e [2] -&gt; a [6]
元のデータ-&gt; 3: a ...... b    [7] ...... [3]    b [3] -&gt; a [7]
             4: b ...... a    [3] ...... [4]    a [4] -&gt; b [3]
             5: c ...... a    [0] ...... [5]    a [5] -&gt; c [0]
             6: d ...... a    [1] ...... [6]    a [6] -&gt; d [1]
             7: e ...... a    [2] ...... [7]    a [7] -&gt; e [2]

           先頭の記号がわかる   位置で表す    記号（位置）の繋がり  

    3 番目の記号列 "a [7] ...... b [3]" を復号する

    [7]-[2]-[6]-[1]-[5]-[0]-[4]-[3]
     a   e   a   d   a   c   a   b


            図 : ブロックソートの復号
</pre>

<p> 最初に、記号列 "cdebaaaa" をソートします。すると、"aaaabcde" になりますね。ブロックソートは、最後の記号を順番に取り出して出力しています。したがって、出力された記号列をソートすれば、先頭の記号を求めることができます。
</p>
<p> 次に記号の繋がりを求めます。ブロックソートは記号列を 1 つずつシフトすることで、新しい記号列を生成しています。"aeadacab" を 1 つシフトすると "eadacaba" になりますね。このように、先頭の記号は末尾へ移動するので、最後の記号と先頭の記号は繋がっていることがわかります。つまり、記号 b の次は記号 a になります。同じ記号 (a) が複数あるので、位置で表した方がわかりやすいでしょう。記号 b の位置は [3] ですね。[3] の次は位置 [7] の記号 a で、[7] の次は [2] の記号 e というように、記号の繋がりを求めることができます。
</p>
<p> 記号の繋がりがわかっても、どこから始めたらいいかわかりません。そのために、元のデータの位置を出力しているわけです。この場合、元データの位置は 3 ですから、3 番目の記号列 "a ...... b" を復号します。この場合、記号 a の位置 [7] から記号の繋がりをたどっていけば、元の記号列 "aeadacab" を復号することができます。
</p>
<p> ブロックソートの場合、符号化にはソートが必要になるため時間がかかりますが、復号はとても簡単に行うことができるのです。
</p>

<h4>●ブロックソートのプログラム</h4>
<p> それでは実際に簡単なテストプログラムを作ってみましょう。ブロックソートをプログラムする場合、記号列を回転させる処理が必要になります。単純に考えると、M 個の記号列を回転させるには M * M バイトの領域が必要になりますが、下図に示すように同じ記号列を後ろにコピーすることで、簡単に実現することができます。
</p>
<pre class="fig">

 aeadacabaeadacab 
         -------- 
          コピー  
 aeadacab         
  eadacaba        
   adacabae       
    dacabaea      
     acabaead     
      cabaeada    
       abaeadac   
        baeadaca  


 図：記号列の回転
</pre>

<p> ブロックソートでいちばん時間がかかる処理がソートです。データ数が多くなると「クイックソート」や「マージソート」でも時間がかかるのです。実用的なツールでは高速にソートするための工夫が必要になります。時間を短縮するため、先頭 2 記号で分布数えソートを行い、そのあとでマージソートやクイックソートで仕上げるなど、いろいろな工夫が考えられますが、もっと高速にソートできる方法があります。
</p>
<p> 巨大なテキストデータを高速に検索するためのデータ構造に suffix array があります。suffix array の構築にはブロックソートと同様にデータのソートが必要になるため、今までに高速なアルゴリズムが研究・開発されています。これらのアルゴリズムをブロックソートに適用することで、巨大なデータでも実用的な時間でソートすることができます。興味のある方は拙作のページ <a href="pyalgo43.html">接尾辞配列 (suffix array)</a> をお読みください。
</p>
<p> ここでは簡単なテストプログラムということで、とりあえず Python のメソッド sort を使うことにします。プログラムは次のようになります。
</p>

<pre class="list">
リスト : ブロックソート

# 比較関数
def compare(x, y, size):
    for n in xrange(size):
        r = ord(buff[x + n]) - ord(buff[y + n])
        if r != 0: return r
    return 0

# 符号化
def bs_encode(data):
    global buff
    size = len(data)
    buff = data * 2
    idx = range(size)
    idx.sort(lambda x, y: compare(x, y, size))
    work = []
    for x in xrange(size):
        p = idx[x]
        if p == 0: top = x
        work.append(buff[p + size - 1])
    return top, work

# 復号
def bs_decode(top, data):
    size = len(data)
    idx = range(size)
    idx.sort(lambda x, y: ord(data[x]) - ord(data[y]))
    buff = []
    p = idx[top]
    for _ in xrange(size):
        buff.append(data[p])
        p = idx[p]
    return string.join(buff, '')

# test
if __name__ == '__main__':
    a = 'abacadaeafagahaiajakalaman'
    print a
    top, buff = bs_encode(a)
    print top, buff
    print bs_decode(top, buff)
</pre>

<p> 符号化は関数 bs_encode で行います。引数 data はブロックソートするデータ (文字列) です。data の長さを size にセットします。そして、グローバル変数 buff に data を 2 倍した文字列をセットします。buff に格納されたデータはソートできないので、配列 idx に buff への位置をセットして、idx をソートすることにします。idx の要素は 0 から size - 1 に初期化します。
</p>
<p> 次に、メソッド sort でソートします。sort の比較関数は compare を使いますが、データの大きさを引数に渡すため、lambda 関数を使っています。関数 compare の引数 x, y には配列 idx の要素が渡されるので、その位置から buff の要素を比較していくだけです。buff には data + data がセットされているので、データの終端をチェックする必要はありません。
</p>

<p> 最後にデータを出力します。idx から buff への位置を取り出して変数 p にセットします。そして、最後の文字 buff[p + size - 1] をバッファ work に書き込みます。もし、p が 0 の場合は、その位置 x を変数 top にセットしておきます。そして、最後に top と work を返します。
</p>

<p> 復号を行う関数 bs_decode も簡単です。引数 top がデータの先頭位置、data が復号するデータです。最初に、文字単位でデータをソートします。今回はテストプログラムということでメソッド sort を使いましたが、分布数えソートを使った方が高速になると思います。
</p>

<p> あとは、ブロックソートの復号で説明したことを、そのままプログラムするだけです。データの先頭位置は引数 top に渡されるので、p = idx[top] で文字の位置を取り出して、文字 data[p] をバッファ buff に書き込みます。そして、次の文字の位置を p = idx[p] で求めます。最後に、buff のデータを関数 join で連結して返します。
</p>

<p> これでプログラムは完成です。それでは実際に試してみましょう。
</p>
<pre>
abacadaeafagahaiajakalaman

0 ['n', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']

abacadaeafagahaiajakalaman
</pre>
<p> 正しく動作していますね。このように、ブロックソートすることで同じ記号を並べることができます。
</p>
<hr>
<h4>●MTF (Move-To-Front) 法</h4>
<p> 次は MTF (Move-To-Front) 法について説明します。MTF は「同じ記号がいくつ前に現れたか」を符号にする方法で、最近現れた記号ほど小さな値に変換することができます。MTF は記号の出現表を作ることで簡単に実現できます。たとえば、記号の種類が a, b, c, d の 4 つしかない場合で、記号列 "abccddddd" を MTF で符号化してみましょう。次の図を見てください。
</p>

<pre class="fig">
  baccdddd   [a, b, c, d] -&gt; [b, a, c, d]  MTF: 1
  *              * b を先頭に移動

  baccdddd   [b, a, c, d] -&gt; [a, b, c, d]  MTF: 11
   *             * a を先頭に移動

  baccdddd   [a, b, c, d] -&gt; [c, a, b, d]  MTF: 112
    *               * c を先頭に移動

  baccdddd   [c, a, b, d] -&gt; [c, a, b, d]  MTF: 1120
     *        * c を先頭に移動

  baccdddd   [c, a, b, d] -&gt; [d, c, a, b]  MTF: 11203
      *                * d を先頭に移動

  baccdddd   [d, c, a, b] -&gt; [d, c, a, b]  MTF: 112030  
       *      * d を先頭に移動

  同じことを繰り返す。 baccdddd =&gt; 11203000


        図 : MTF による符号化
</pre>

<p> まず、表を [a, b, c, d] に初期化します。MTF は、この表に現れる記号の位置を符号にします。最初の記号は b ですね。b の位置は 1 番目なので 1 を出力します。ここで、記号 b を表の先頭へ移動します。このように、記号を表の先頭へ移動することから "Move To Front" と呼ばれています。この結果、頻繁に現れる記号は表の先頭付近に集まるので、それらの記号は小さな値に変換されるわけです。
</p>

<p> この値を <a href="pyalgo30.html">γ符号やδ符号 </a> で符号化すれば、データを圧縮することは可能です。γ符号とδ符号は P. Elias が開発した正整数を表すための符号です。小さな正整数ほど短い符号が割り当てられているため、MTF で変換したデータを圧縮することができるわけです。MTF とγ符号やδ符号の組み合わせは、簡単に符号化と復号を行うことができるのですが、残念ながらこれだけでは高い圧縮率を達成することができません。
</p>

<p> MTF にはもうひとつ特徴があります。記号 d を変換するところを見てください。最初の d は表の 3 番目にあるので 3 を出力します。そして、d を表の先頭へ移動するので、残りの d は 3 つすべて 0 に変換されます。このように、MTF では同じ記号が連続していれば、それを 0 に変換することができます。この特徴がブロックソートに適しているのです。
</p>

<p> ブロックソートしたあとのデータでは、同じ記号がたくさん並びます。このデータを MTF で変換すれば、同じ記号の並びを 0 に変換することができます。つまり、t が並んでいるところも、h が並んでいるところも 0 に変換されるのです。したがって、データ全体の中で 0 の割合が著しく増加し、記号の出現頻度を偏らせることができる、圧縮しやすいデータに変換される、というわけです。
</p>

<h4>●MTF のプログラム</h4>
<p> それでは MTF のプログラムを作りましょう。MTF はブロックソートと同様にとても簡単にプログラムできます。次のリストを見てください。
</p>

<pre class="list">
リスト : Move To Front 法

# 符号化
def mtf_encode(data):
    table = range(256)
    buff = []
    for x in data:
        c = ord(x)
        j = table.index(c)
        if j &gt; 0:
            del table[j]
            table.insert(0, c)
        buff.append(j)
    return buff

# 復号
def mtf_decode(data):
    table = range(256)
    buff = []
    for x in data:
        c = table[x]
        if x &gt; 0:
            del table[x]
            table.insert(0, c)
        buff.append(chr(c))
    return buff

# test
if __name__ == '__main__':
    a = 'abacadaeafagahaiajakalaman'
    print a
    top, buff = bs_encode(a)
    print top, buff
    buff1 = mtf_encode(buff)
    print buff1
    buff2 = mtf_decode(buff1)
    print buff2
    print bs_decode(top, buff2)
</pre>

<p> 関数 mtf_encode で符号化、関数 mtf_decode で復号を行います。引数 data が入力データです。最初に、配列 table を 0 から 255 までの記号で初期化します。符号化の場合、data から記号 c を読み込み、table を線形探索します。見つけた位置 j が MTF の符号になります。復号の場合、data から符号 j を読み込み、table[j] の値が記号 c になります。そして、j が 0 よりも大きければ、記号 c を table の先頭へ移動させます。
</p>

<p> 実行結果は次のようになりました。
</p>
<pre>
abacadaeafagahaiajakalaman

0 ['n', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']

[110, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 110,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

['n', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']

abacadaeafagahaiajakalaman
</pre>
<p> ブロックソートしたあと同じ記号が並びますが、MTF によりそれらの記号が 0 に変換され、データ全体の中で 0 の割合が著しく増加していることがわかります。このように、MTF により記号の出現頻度を偏らせることができるわけです。
</p>
<hr>
<h4>●Move To Front 法の改良</h4>
<p> このように、ブロックソートのあと MTF 法を適用すると、多くの記号が 0 に変換されるため、記号の出現頻度を著しく偏らせることができます。このあと、レンジコーダを適用すると、高い圧縮率を実現することができますが、MTF 法で 0 に変換される記号の割合をもっと多くすることができれば、圧縮率もさらに向上すると思われます。MTF 法は単純なアルゴリズムなので、いろいろなバリエーションが考えられると思いますが、ここでは簡単で効果的な改良方法を紹介します。
</p>

<h4>●2 番目に移動する方法</h4>
<p> MTF 法はその名前が示すように、現れた記号を表の先頭へ移動します。ここで、この移動位置を 2 番目に変更します。そして、先頭へ移動できるのは、2 番目にある記号の場合だけに限定します。つまり、いきなり先頭へ移動するのではなく、まず 2 番目に移動しておいて、それから先頭へ移動するのです。
</p>
<p> このアルゴリズムは 1999 年に Balkenhol, Kurtz, Shtarkov が提案したもので MTF-1 と呼ばれています。このドキュメントでも MTF-1 と表記することにします。なお、MTF-1 は <a href="http://homepage3.nifty.com/DO/">DO++</a> さんのページ <a href="http://homepage3.nifty.com/DO/blocksorting.htm">BlockSorting</a> や Stephan T. Lavavej さんのページ <a href="http://nuwen.net/bwtzip.html">bwtzip - nuwen.net</a> で説明されています。DO++ さんと Stephan T. Lavavej さんに感謝いたします。
</p>

<h4>●MTF-1 の説明</h4>
<p> たとえば、記号が a, b, c の 3 種類で、記号列 "aaaacbaaaa" を MTF で変換してみましょう。単純な MTF は次のように変換されます。
</p>

<pre class="fig">
aaaacbaaaa    [a, b, c] -&gt; [c, a, b]  MTF: 00002
    *                * c を先頭に移動 

aaaacbaaaa    [c, a, b] -&gt; [b, c, a]  MTF: 000022
     *               * b を先頭に移動 

aaaacbaaaa    [b, c, a] -&gt; [a, b, c]  MTF: 0000222    
      *              * a を先頭に移動 

aaaacbaaaa =&gt; MTF: 0000222000


        図 : 単純な MTF による符号化
</pre>

<p> このように、a の途中で b と c が入っている場合、b と c を先頭へ移動すると "0000222000" に変換されます。それでは、b と c を 2 番目に移動させてみましょう。次の図を見てください。
</p>

<pre class="fig">
aaaacbaaaa    [a, b, c] -&gt; [a, c, b]  MTF-1: 00002
    *                * c を 2 番目に移動 

aaaacbaaaa    [a, c, b] -&gt; [a, b, c]  MTF-1: 000022
     *               * b を 2 番目に移動 

aaaacbaaaa    [a, b, c] -&gt; MTF-1: 0000220
      *        * a は先頭のまま

aaaacbaaaa =&gt; MTF-1: 0000220000


        図 : MTF-1 による符号化
</pre>

<p> b と c を 2 番目に移動すると、"aaaacbaaaa" は "0000220000" に変換されます。0 がひとつ増えていますね。これが MTF-1 の効果です。長い記号列をブロックソートすると同じ記号がたくさん並びますが、連続した記号の間に他の記号が入ることも多くあるはずです。したがって、MTF-1 で変換すれば、0 の個数を増やすことができると思われます。もちろん、データによっては 0 の個数が減少することもあるでしょう。ですが、大きなデータには効果を期待してもよさそうです。
</p>

<h4>●MTF-1 のプログラム</h4>
<p> プログラムはとても簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : MTF-1

# 符号化
def mtf1_encode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        c = buff[x]
        j = table.index(c)
        if j == 1:
            table[1] = table[0]
            table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = j

# 復号
def mtf1_decode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        j = buff[x]
        c = table[j]
        if j == 1:
            table[1] = table[0]
            table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = c
</pre>

<p> 符号化を行う関数が mtf1_encode で、復号を行う関数が mtf1_decode です。入力バッファ buff を直接書き換えていることに注意してください。どちらの関数でも、記号の位置 j が 1 よりも大きければ、その記号を table[1] へ移動します。そして、j が 1 の場合にのみ、その記号を先頭へ移動します。とても簡単ですね。
</p>

<h4>●さらなる改良</h4>
<p> ところで、MTF-1 にも弱点があります。次の図を見てください。
</p>

<pre class="fig">
aaaabcaaaa    [a, b, c] -&gt; [b, a, c]  MTF-1: 00001
    *             * b を 1 番目に移動 

aaaabcaaaa    [b, a, c] -&gt; [b, c, a]  MTF-1: 000012    
     *               * c を 2 番目に移動 

aaaabcaaaa    [b, c, a] -&gt; [b, a, c]  MTF-1: 0000122
      *              * a を 2 番目に移動

aaaabcaaaa    [b, a, c] -&gt; [a, b, c]  MTF-1: 00001221
       *          * a を 1 番目に移動

aaaabcaaaa =&gt; MTF-1: 0000122100


        図 : MTF-1 の弱点
</pre>
<p> 記号が a, b, c の 3 種類で、記号列 "aaaabcaaaa" を MTF-1 で変換してみましょう。この場合、a が続いたあとの記号 b が 2 番目にあるため、b を先頭へ移動します。そして、c を 2 番目に移動するので、a の位置は 3 番目になります。このあと a が続くことになると、a は 2 番目に移動してから先頭に戻るので、結果は "0000122100" になります。これでは 0 の個数が減ってしまいますね。
</p>
<p> そこで、直前に出力した記号が 0 以外の場合にのみ、1 番目の記号を先頭へ移動することにします。つまり、0 を出力した直後は、1 番目の記号を移動しないのです。この方法で "aaaabcaaaa" を変換すると、次のようになります。
</p>

<pre class="fig">
aaaabcaaaa    [a, b, c] -&gt; [a, b, c]  MTF-2: 00001
    *             * 直前に出力した記号は 0 なので
                    b は移動しない

aaaabcaaaa    [a, b, c] -&gt; [a, c, b]  MTF-2: 000012
     *               * c を 2 番目に移動 

aaaabcaaaa    [a, b, c] -&gt; MTF-2: 0000120
      *        * a は先頭

aaaacaaaa =&gt; MTF-2: 0000120000


        図 : 1 番目の記号の移動を制限する
</pre>
<p> このように、"aaaabcaaaa" は "0000120000" に変換されます。MTF-1 よりも 0 の個数を増やすことができましたね。このアルゴリズムは 1999 年に Balkenhol と Shtarkov が提案したもので MTF-2 と呼ばれています。以降このドキュメントでも MTF-2 と表記することにします。
</p>

<p> なお、MTF-2 は Stephan T. Lavavej さんのページ <a href="http://nuwen.net/bwtzip.html">bwtzip - nuwen.net</a> で説明されています。Stephan T. Lavavej さんに感謝します。
</p>

<h4>●MTF-2 のプログラム</h4>
<p> プログラムはとても簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : MTF-2

# 符号化
def mtf2_encode(buff):
    table = range(256)
    prev = 1
    for x in xrange(len(buff)):
        c = buff[x]
        j = table.index(c)
        if j == 1:
            if prev != 0:
                table[1] = table[0]
                table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = j
        prev = j

# 復号
def mtf2_decode(buff):
    table = range(256)
    prev = 1
    for x in xrange(len(buff)):
        j = buff[x]
        c = table[j]
        if j == 1:
            if prev != 0:
                table[1] = table[0]
                table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = c
        prev = j
</pre>
<p> 符号化を行う関数が mtf2_encode で、復号を行う関数が mtf2_decode です。どちらの関数も直前に出力した記号を変数 prev に格納します。このプログラムでは prev を 1 に初期化しています。この値は 0 でもかまいませんが、mtf2_encode と mtf2_decode の prev は同じ値で初期化してください。あとは、j が 1 のときに prev をチェックして、0 以外の値ならば記号を先頭へ移動します。0 ならば移動しません。とても簡単ですね。
</p>

<h4>●評価結果</h4>
<p> それでは、実際に <a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> で試してみましょう。ブロックソートと MTF 法で変換したあと、記号 0 の個数を数えてみます。そして、適応型レンジコーダで圧縮してみましょう。
</p>

<p> ブロックソートは suffix array の構築アルゴリズムである <a href="pyalgo47.html">三分割法改良版</a> を使っています。プログラムの説明は割愛いたしますので、詳細は <a href="pyalgo48.html#list1">プログラムリスト</a> をお読みください。結果は次にようになりました。
</p>
<pre>
                表 : ブロックソートの結果
            (BlockSorting + MTF + RangeCoder)

                               MTF              MTF-1             MTF-2
ファイル名      サイズ  0 の個数  サイズ  0 の個数  サイズ  0 の個数  サイズ
-----------------------------------------------------------------------------
alice29.txt    152,089    85,187  47,142    84,717  47,067    85,986  46,720
asyoulik.txt   125,179    62,815  42,930    62,819  42,798    63,601  42,573
cp.html         24,603    15,405   8,504    14,218   8,864    14,238   8,855
fields.c        11,150     7,741   3,192     7,102   3,399     6,964   3,436
grammar.lsp      3,721     2,376   1,203     2,109   1,378     2,103   1,378
kennedy.xls  1,029,744   794,903 156,091   798,091 154,758   809,174 151,892
lcet10.txt     426,754   261,044 117,767   259,027 117,746   262,183 116,775
plrabn12.txt   481,861   238,303 156,182   243,019 154,467   247,337 153,364
ptt5           513,216   448,526  57,551   454,484  53,576   455,466  52,947
sum             38,240    24,980  13,814    23,090  14,280    22,902  14,318
xargs.1          4,227     2,220   1,762     1,907   1,831     1,901   1,838
-----------------------------------------------------------------------------
合計         2,810,784 1,943,500 606,237 1,950,583 600,164 1,971,855 594,096
</pre>

<p> 結果を見ればおわかりのように、ブロックソートのあと MTF 法でデータを変換すると、記号 0 の個数が極めて多くなります。MTF-1 と MTF-2 は MTF よりも 0 の個数が増えているので、MTF を改良した効果は十分に出ていると思います。
</p>
<p> 大きなファイルの場合、MTF-1 よりも MTF-2 の方が効果が高いようです。このあと、適応型レンジコーダで圧縮すると、MTF-2 が一番高い圧縮率になりました。このほかにも、MTF 法はいろいろなバリエーションが考えられると思います。興味のある方は、MTF 法の改良に挑戦してみてください。
</p>

<p> ところで、適応型レンジコーダの代わりに <a href="pyalgo40.html">バイナリレンジコーダ</a> を使うと、圧縮率はさらに高くなります。結果は次のようになります。
</p>
<pre>
                表 : ブロックソートの結果
          (BlockSroting + MTF-2 + BinaryRangeCoder)

ファイル名      サイズ   Alpha    Gamma    Binary    LHA     bzip2
--------------------------------------------------------------------
alice29.txt    152,089   43,729   43,611   43,745   59,117   43,202
asyoulik.txt   125,179   40,087   39,966   40,061   52,341   39,569
cp.html         24,603    8,404    8,329    8,408    8,384    7,624
fields.c        11,150    3,309    3,272    3,294    3,170    3,039
grammar.lsp      3,721    1,337    1,309    1,323    1,271    1,283
kennedy.xls  1,029,744  136,047  129,415  125,891  198,342  130,280
lcet10.txt     426,754  108,926  108,660  109,141  159,558  107,706
plrabn12.txt   481,861  144,888  144,516  144,979  210,045  145,577
ptt5           513,216   49,544   49,291   50,406   52,305   49,759
sum             38,240   13,707   13,514   13,563   13,993   12,909
xargs.1          4,227    1,800    1,769    1,787    1,778    1,762
--------------------------------------------------------------------
合計         2,810,784  551,778  543,652  542,598  760,304  542,710
</pre>
<p> ブロックソート + MTF 法により記号 0 の個数が極めて多くなるので、バイナリレンジコーダのαモデル (Alpha) やγモデル (Gamma) で符号化すると、LHA を超えて bzip2 にせまる高い圧縮率を達成することができます。バイナリモデル (Binary) でも同程度の圧縮率になりました。
</p>
<p> ただし、バイナリレンジコーダは符号化・復号処理に時間がとてもかかります。次の表を見てください。
</p>

<pre>
            表 : ブロックソートの実行時間
(BlockSroting + MTF-2 + RnageCoder, BinaryRangeCoder)

                         RangeCoder      Binary
ファイル名      サイズ  符号化  復号  符号化  復号
---------------------------------------------------
alice29.txt    152,089   4.59   2.93  12.15  10.19
asyoulik.txt   125,179   3.82   2.50  10.32   8.32
cp.html         24,603   0.95   0.53   2.24   1.64
fields.c        11,150   0.53   0.23   1.12   0.75
grammar.lsp      3,721   0.31   0.08   0.50   0.25
kennedy.xls  1,029,744  36.72  35.47  84.29  67.29
lcet10.txt     426,754  12.74   8.07  35.01  28.53
plrabn12.txt   481,861  14.18   9.54  39.26  32.33
ptt5           513,216  10.96   8.57  38.04  33.36
sum             38,240   2.29   1.02   4.20   2.54
xargs.1          4,227   0.32   0.10   0.55   0.29
---------------------------------------------------
合計         2,810,784  87.41  69.04 227.68 185.49

# 符号化と復号の単位 : 秒

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> バイナリレンジコーダの場合、適応型レンジコーダの約 3 倍の時間がかかります。バイナリレンジコーダは優れた圧縮性能を持っていますが、処理時間がかかるのが欠点です。もちろん、適応型レンジコーダを使う場合でも、工夫次第でブロックソートの圧縮率を向上させることができます。一番簡単な方法は MTF 法のあとに「ランレングス」を適用することです。また、ブロックソート法に適した「情報源モデル」を作成すると圧縮率を高くすることができます。次回は、ランレングスとブロックソート法に適した情報源モデルについて説明します。
</p>
<p> なお、実行時間の結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<h4 id="cite">●参考文献</h4>
<ol>
  <li>広井誠, 『高性能圧縮ツール bsrc の理論と実装（前編, 後編）』, Interface 2003 年 12 月号, 2004 年 1 月号, ＣＱ出版社
  <li>広井誠, 『高性能圧縮ツール bsrc の改良 bsrc2（前編, 後編）』, Interface 2004 年 10 月号, 11 月号, ＣＱ出版社
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
# coding: utf-8
#
# bwt.py : ブロックソート法
#
#          Copyright (C) 2007 Makoto Hiroi
#
from array import *

# 定数
SIZE = 256 * 256
LIMIT = 10

# ソート用比較関数
def compare(x, y, n):
    for i in xrange(n, data_size - n):
        r = buff[x + i] - buff[y + i]
        if r != 0: return r
    return 0

# 挿入ソート
def insert_sort(low, high, n):
    for i in xrange(low + 1, high + 1):
        temp = idx[i]
        j = i - 1
        while j &gt;= low and compare(temp, idx[j], n) &lt; 0:
            idx[j + 1] = idx[j]
            j -= 1
        idx[j + 1] = temp

# 枢軸の選択
def select_pivot(low, high, n):
    m = (high - low) / 4
    a = buff[idx[low + m] + n]
    b = buff[idx[low + m * 2] + n]
    c = buff[idx[low + m * 3] + n]
    if a &gt; b:
        tmp = a
        a = b
        b = tmp
    if b &gt; c:
        b = c
        if a &gt; b: b = a
    return b

# マルチキークイックソート
def mqsort(low, high, n = 0):
    while True:
        if high - low &lt;= LIMIT:
            insert_sort(low, high, n)
            return
        # 枢軸
        p = select_pivot(low, high, n)
        # 4 分割
        i = m1 = low
        j = m2 = high
        while True:
            while i &lt;= j:
                k = buff[idx[i] + n] - p
                if k &gt; 0: break
                if k == 0:
                    idx[i], idx[m1] = idx[m1], idx[i]
                    m1 += 1
                i += 1
            while i &lt;= j:
                k = buff[idx[j] + n] - p
                if k &lt; 0: break
                if k == 0:
                    idx[j], idx[m2] = idx[m2], idx[j]
                    m2 -= 1
                j -= 1
            if i &gt; j: break
            idx[i], idx[j] = idx[j], idx[i]
            i += 1
            j -= 1
        # 等しいデータを中央に集める
        for k in xrange(min(m1 - low, i - m1)):
            idx[low + k], idx[j - k] = idx[j - k], idx[low + k]
        m1 = low + (i - m1)
        for k in xrange(min(high - m2, m2 - j)):
            idx[i + k], idx[high - k] = idx[high - k], idx[i + k]
        m2 = high - (m2 - j) + 1
        mqsort(low, m1 - 1, n)
        mqsort(m2, high, n)
        if m1 &gt;= m2: break
        low = m1
        high = m2 - 1
        n += 1

# Type C をソート
def sort_type_c():
    # Type C を Type D, E を分離して Type D をソート
    for x in xrange(0, 256):
        for y in xrange(x + 1, 256):
            c = (x &lt;&lt; 8) + y
            low = count_sum[c]
            high = count_sum[c + 1]
            m = low
            for n in xrange(low, high):
                i = idx[n]
                if buff[i + 1] &gt;= buff[i + 2]:
                    idx[n] = idx[m]
                    idx[m] = i
                    m += 1
            if m - low &gt; 1:
                mqsort(low, m - 1, 2)
    #
    # Type E のセット
    #
    # 累積度数表をコピー
    end = count_sum[:]
    # 記号 0, 255 の区間はスキャンする必要なし
    for x in xrange(254, 0, -1):
        for y in xrange(255, x, -1):
            c = (x &lt;&lt; 8) + y
            for n in xrange(count_sum[c + 1] - 1, count_sum[c] - 1, -1):
                i = idx[n]
                if i == 0: i = data_size
                if buff[i - 1] &lt; buff[i] &lt; buff[i + 1]:
                    # Type E をセット
                    c1 = (buff[i - 1] &lt;&lt; 8) + buff[i] + 1
                    end[c1] -= 1
                    idx[end[c1]] = i - 1

# Type A, B をセット
def set_type_ab():
    start = [0] * 256
    end = [0] * 256
    for i in xrange(0, 256):
        for j in xrange(i, 256):
            start[j] = count_sum[(j &lt;&lt; 8) + i]
            end[j] = count_sum[(j &lt;&lt; 8) + i + 1] - 1
        # 前から後ろへ
        j = count_sum[i &lt;&lt; 8]
        while j &lt; start[i]:
            x = idx[j]
            if x == 0: x = data_size
            if buff[x - 1] &gt;= buff[x]:
                c = buff[x - 1]
                idx[start[c]] = x - 1
                start[c] += 1
            j += 1
        # 後ろから前へ
        j = count_sum[(i + 1) &lt;&lt; 8] - 1
        while j &gt; end[i]:
            x = idx[j]
            if x == 0: x = data_size
            if buff[x - 1] &gt;= buff[x]:
                c = buff[x - 1]
                idx[end[c]] = x - 1
                end[c] -= 1
            j -= 1

# 三分割法改良版
def suffix_sort(data, size):
    global count_sum, buff, data_size, idx
    buff = data
    data_size = size
    idx = array('L')
    for _ in xrange(data_size): idx.append(0)
    # 分布数えソート
    count = [0] * SIZE
    count_sum = [0] * (SIZE + 1)
    for x in xrange(data_size):
        count[(buff[x] &lt;&lt; 8) + buff[x + 1]] += 1
    for x in xrange(1, SIZE + 1):
        count_sum[x] = count[x - 1] + count_sum[x - 1]
    for x in xrange(1, SIZE):
        count[x] += count[x - 1]
    for x in xrange(data_size - 1, -1, -1):
        c = (buff[x] &lt;&lt; 8) + buff[x + 1]
        count[c] -= 1
        idx[count[c]] = x
    # Type C をソート
    sort_type_c()
    # Type A, B をセット
    set_type_ab()
    # 出力
    work = array('B')
    for x in xrange(size):
        i = idx[x]
        if i == 0: top = x
        work.append(buff[i + size - 1])
    return work, top
</pre>
<pre class="list">
# coding: utf-8
#
# freq.py : 適応型レンジコーダ用の出現頻度表
#
#           Copyright (C) 2007 Makoto Hiroi
#

# 出現頻度表
class Freq:
    def __init__(self, size, inc = 4, limit = 0x4000):
        self.size = size
        self.inc = inc
        self.limit = limit
        self.count = [1] * size
        self.sum = size

    # 出現頻度表の更新
    def update(self, c):
        self.count[c] += self.inc
        self.sum += self.inc
        if self.sum &gt;= self.limit:
            n = 0
            for x in xrange(self.size):
                self.count[x] = (self.count[x] &gt;&gt; 1) | 1
                n += self.count[x]
            self.sum = n

    # 記号の累積度数を求める
    def cumul(self, c):
        n = 0
        for x in xrange(c): n += self.count[x]
        return n

    # 符号化
    def encode(self, rc, c):
        temp = rc.range / self.sum
        rc.low += self.cumul(c) * temp
        rc.range = self.count[c] * temp
        rc.encode_normalize()
        self.update(c)

    # 復号
    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            n = 0
            for c in xrange(self.size):
                if value &lt; n + self.count[c]: break
                n += self.count[c]
            return c, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.count[c]
        rc.decode_normalize()
        self.update(c)
        return c
</pre>
<pre class="list">
# coding: utf-8
#
# rangecoder.py : レンジコーダ (Range Coder)
#
#                 Copyright (C) 2007 Makoto Hiroi
#

# 定数
ENCODE = "encode"
DECODE = "decode"
MAX_RANGE = 0x100000000
MIN_RANGE = 0x1000000
MASK      = 0xffffffff
SHIFT     = 24

max_low = 0

# バイト単位の入出力
def getc(f):
    c = f.read(1)
    if c == '': return None
    return ord(c)

def putc(f, x):
    f.write(chr(x &amp; 0xff))

#
class RangeCoder:
    def __init__(self, file, mode):
        self.file = file
        self.range = MAX_RANGE
        self.buff = 0
        self.cnt = 0
        if mode == ENCODE:
            self.low = 0
        elif mode == DECODE:
            # buff の初期値 (0) を読み捨てる
            getc(self.file)
            # 4 byte read
            self.low = getc(self.file)
            self.low = (self.low &lt;&lt; 8) + getc(self.file)
            self.low = (self.low &lt;&lt; 8) + getc(self.file)
            self.low = (self.low &lt;&lt; 8) + getc(self.file)
        else:
            raise "RangeCoder mode error"

    # 符号化の正規化
    def encode_normalize(self):
        if self.low &gt;= MAX_RANGE:
            # 桁上がり
            self.buff += 1
            self.low &amp;= MASK
            if self.cnt &gt; 0:
                putc(self.file, self.buff)
                for _ in xrange(self.cnt - 1): putc(self.file, 0)
                self.buff = 0
                self.cnt = 0
        while self.range &lt; MIN_RANGE:
            if self.low &lt; (0xff &lt;&lt; SHIFT):
                putc(self.file, self.buff)
                for _ in xrange(self.cnt): putc(self.file, 0xff)
                self.buff = (self.low &gt;&gt; SHIFT) &amp; 0xff
                self.cnt = 0
            else:
                self.cnt += 1
            self.low = (self.low &lt;&lt; 8) &amp; MASK
            self.range &lt;&lt;= 8

    # 復号の正規化
    def decode_normalize(self):
        while self.range &lt; MIN_RANGE:
            self.range &lt;&lt;= 8
            self.low = ((self.low &lt;&lt; 8) + getc(self.file)) &amp; MASK

    # 終了
    def finish(self):
        c = 0xff
        if self.low &gt;= MAX_RANGE:
            # 桁上がり
            self.buff += 1
            c = 0
        putc(self.file, self.buff)
        for _ in xrange(self.cnt): putc(self.file, c)
        #
        putc(self.file, (self.low &gt;&gt; 24) &amp; 0xff)
        putc(self.file, (self.low &gt;&gt; 16) &amp; 0xff)
        putc(self.file, (self.low &gt;&gt; 8) &amp; 0xff)
        putc(self.file, self.low &amp; 0xff)
</pre>
<pre class="list">
# coding: utf-8
#
# mtf.py : Move To Front 法
#
#          Copyright (C) 2007 Makoto Hiroi
#

# 符号化
def mtf_encode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        c = buff[x]
        j = table.index(c)
        if j &gt; 0:
            del table[j]
            table.insert(0, c)
        buff[x] = j

# 復号
def mtf_decode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        j = buff[x]
        c = table[j]
        if j &gt; 0:
            del table[j]
            table.insert(0, c)
        buff[x] = c


##### MTF-1 #####

# 符号化
def mtf1_encode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        c = buff[x]
        j = table.index(c)
        if j == 1:
            table[1] = table[0]
            table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = j

# 復号
def mtf1_decode(buff):
    table = range(256)
    for x in xrange(len(buff)):
        j = buff[x]
        c = table[j]
        if j == 1:
            table[1] = table[0]
            table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = c

##### MTF-2 #####

# 符号化
def mtf2_encode(buff):
    table = range(256)
    prev = 1
    for x in xrange(len(buff)):
        c = buff[x]
        j = table.index(c)
        if j == 1:
            if prev != 0:
                table[1] = table[0]
                table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = j
        prev = j

# 復号
def mtf2_decode(buff):
    table = range(256)
    prev = 1
    for x in xrange(len(buff)):
        j = buff[x]
        c = table[j]
        if j == 1:
            if prev != 0:
                table[1] = table[0]
                table[0] = c
        elif j &gt; 1:
            del table[j]
            table.insert(1, c)
        buff[x] = c
        prev = j
</pre>
<pre class="list">
# coding: utf-8
#
# bsrc.py : ブロックソート (BlockSorting) によるファイルの圧縮
#
#           Copyright (C) 2007 Makoto Hiroi
#
import time, sys, getopt, os.path
from array import *
from bwt import *
from mtf import *
from freq import *
from rangecoder import *

# 4 バイトの正整数値を出力
def write_number(num, fout):
    putc(fout, (num &gt;&gt; 24) &amp; 0xff)
    putc(fout, (num &gt;&gt; 16) &amp; 0xff)
    putc(fout, (num &gt;&gt; 8) &amp; 0xff)
    putc(fout, num &amp; 0xff)

# 4 バイトの正整数値を入力
def read_number(fin):
    num = 0
    for _ in xrange(4):
        num = (num &lt;&lt; 8) + getc(fin)
    return num

# 符号化
def bs_encode(fin, fout, size):
    # 入力
    buff = array('B')
    buff.fromfile(fin, size)
    buff *= 2
    # BlockSorting
    work, top = suffix_sort(buff, size)
    # Move To Front
    mtf2_encode(work)
    print work.count(0)
    write_number(top, fout)
    # RangeCoder
    rc = RangeCoder(fout, ENCODE)
    freq = Freq(256)
    for x in xrange(size):
        freq.encode(rc, work[x])
    rc.finish()
    # 終了
    fin.close()
    fout.close()

# ブロックソートの復号
def bs_decode(fin, fout, size):
    top = read_number(fin)
    buff = array('B')
    # RangeCoder
    rc = RangeCoder(fin, DECODE)
    freq = Freq(256)
    for _ in xrange(size):
        buff.append(freq.decode(rc))
    # Move To Front
    mtf2_decode(buff)
    # BlockSorting
    idx = array('L')
    for _ in xrange(size): idx.append(0)
    # 分布数えソート
    count = [0] * 256
    for x in xrange(size): count[ buff[x] ] += 1
    for x in xrange(1, 256): count[x] += count[x - 1]
    for x in xrange(size - 1, -1, -1):
        c = buff[x]
        count[c] -= 1
        idx[ count[c] ] = x
    # 出力
    x = idx[top]
    for _ in xrange(size):
        putc(fout, buff[x])
        x = idx[x]


# 符号化
def encode_file(name1, name2):
    size = os.path.getsize(name1)
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    write_number(size, outfile)
    if size &gt; 0: bs_encode(infile, outfile, size)
    infile.close()
    outfile.close()

# 復号
def decode_file(name1, name2):
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    size = read_number(infile)
    if size &gt; 0: bs_decode(infile, outfile, size)
    infile.close()
    outfile.close()

#
def main():
    eflag = False
    dflag = False
    opts, args = getopt.getopt(sys.argv[1:], 'ed')
    for x, y in opts:
        if x == '-e' or x == '-E':
            eflag = True
        elif x == '-d' or x == '-D':
            dflag = True
    if eflag and dflag:
        print 'option error'
    elif eflag:
        encode_file(args[0], args[1])
    elif dflag:
        decode_file(args[0], args[1])
    else:
        print 'option error'

#
s = time.clock()
main()
e = time.clock()
print "%.3f" % (e - s)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo47.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo49.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>