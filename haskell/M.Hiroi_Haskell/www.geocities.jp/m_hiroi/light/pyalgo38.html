<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / レンジコーダ (range coder)</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881795</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>レンジコーダ (range coder) [3]</h2>
<div class="small">
[ <a href="pyalgo37.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo39.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> レンジコーダの続きです。今回は適応型レンジコーダの高速化について説明します。
</p>

<h4>●適応型レンジコーダの高速化</h4>
<p> 最初に Rick さんから教えてもらった方法を紹介します。Rick さんのプログラムは線形探索を改良したものです。次のリストを見てください。
</p>
<pre class="list">
リスト : 出現頻度表の初期化と更新

# 定数
GR = 16

# 出現頻度表
class Freq:
    def __init__(self, size):
        self.size = size
        self.count = [1] * size
        if size % GR == 0:
            self.count_group = [GR] * (size / GR)
        else:
            self.count_group = [GR] * (size / GR + 1)
        self.sum = size

    # 出現頻度表の更新
    def update(self, c):
        self.count[c] += 1
        self.count_group[c / GR] += 1
        self.sum += 1
        if self.sum &gt;= MIN_RANGE:
            n = 0
            for x in xrange(len(self.count_group)):
                self.count_group[x] = 0
            for x in xrange(self.size):
                self.count[x] = (self.count[x] &gt;&gt; 1) | 1
                self.count_group[x / GR] += self.count[x]
                n += self.count[x]
            self.sum = n
</pre>

<p> Rick さんの改良方法は記号を GR (16) 個ずつのグループに分けて、グループの出現頻度表 count_group を用意するところがポイントです。この配列 count_group を使って、記号の累積度数を高速に求めることができます。
</p>
<p> 符号化で累積度数を求める処理は次のようになります。
</p>
<pre class="list">
リスト : 記号の累積度数を求める

    def cumul(self, c):
        n = 0
        for x in xrange(c/GR): n += self.count_group[x]
        for x in xrange((c/GR)*GR, c): n += self.count[x]
        return n
</pre>
<p> たとえば、記号 c の値が 88 としましょう。この場合、グループは 5 になります。すると、記号 79 (= 5 * 16 - 1) までの累積度数は、count_group[0] から count_group[4] までの値を足し算するだけで求めることができます。あとは count[80] から count[87] までの値を足し算すれば、記号 c (88) の累積度数を求めることができます。今までの方法だと繰り返しの回数が 87 回にもなりますが、今回の方法では 5 + 8 = 13 回ですみます。
</p>

<p> 復号も同様に配列 count_group を使って高速化することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 記号の復号

    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            n = 0
            for x in xrange(len(self.count_group)):
                if value &lt; n + self.count_group[x]: break
                n += self.count_group[x]
            for c in xrange(x*GR, self.size):
                if value &lt; n + self.count[c]: break
                n += self.count[c]
            return c, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.count[c]
        rc.decode_normalize()
        self.update(c)
        return c
</pre>
<p> 最初に count_group を使って記号のグループ番号を復号します。変数 n にグループの累積度数を求めながら、復号するグループ番号を線形探索しています。次に記号を復号します。グループの先頭記号から順番に累積度数を求めながら、復号する記号を線形探索します。
</p>

<p> あとのプログラムは簡単なので説明は割愛いたします。詳細は <a href="pyalgo38.html#list1">プログラムリスト１</a> をお読みください。
</p>
<h4>●評価結果</h4>
<p> それでは、実際に <a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> で、実行時間を計測してみましょう。結果は次にようになりました。
</p>
<pre>
          表 : 高速化(1) の実行結果

                              従来版     高速化(1)
  ファイル名      サイズ  符号化  復号  符号化  復号
  ---------------------------------------------------
  alice29.txt    152,089   5.74  12.67   3,09   4.05
  asyoulik.txt   125,179   4.85  10.49   2.60   3.40
  cp.html         24,603   0.98   2.05   0.53   0.70
  fields.c        11,150   0.41   0.81   0.28   0.30
  grammar.lsp      3,721   0.14   0.28   0.08   0.10
  kennedy.xls  1,029,744  19.77  30.35  17.80  20.70
  lcet10.txt     426,754  16.61  36.63   8.78  11.52
  plrabn12.txt   481,861  18.56  41.08   9.86  12.96
  ptt5           513,216   8.48  14.38   7.23   8.78
  sum             38,240   1.21   2.29   0.76   0.92
  xargs.1          4,227   0.18   0.36   0.09   0.12
  ---------------------------------------------------
  合計         2,810,784  76.93 151.39  51.10  63.55

# 符号化と復号の単位 : 秒

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> どのファイルでも実行時間は速くなりました。特に英文テキストの場合、改良の効果は大きく、2 倍から 3 倍ほど高速になりました。それでも、静的符号化に比べると遅くなるのは仕方がないでしょう。このように、Rick さんの改良は抜群の効果を発揮していて、とても優れた方法だと思います。Rick さんに感謝いたします。
</p>

<p> なお、実行時間の結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<hr>
<h4>●二分木を使った高速化</h4>
<p> 次は <a href="http://mij4x.datacompression.jp/?date=20050109">mij4x さん</a> の「二分木を使った高速化」を説明します。簡単な例として、記号が 8 種類 (0 - 7) の場合を考えてみましょう。二分木を使う場合、二分木の葉（外部ノード）に記号の出現頻度を格納します。記号の値を基準にして二分木を構成すると、下図のようになります。
</p>
<pre class="fig">
                            ○４
                          ／  ＼
                        ／      ＼
                      ／          ＼
                    ／              ＼
                  ／                  ＼
                ○２                    ○６
              ／  ＼                  ／  ＼
            ／      ＼              ／      ＼
          ○１        ○３        ○５        ○７
        ／  ＼      ／  ＼      ／  ＼      ／  ＼
      ●      ●  ●      ●  ●      ●  ●      ●  
記号：０      １  ２      ３  ４      ５  ６      ７

      ○：内部ノード 左部分木の出現頻度の合計値を格納
      ●：外部ノード 記号の出現頻度を格納


                    図 : 二分木の構成
</pre>
<p> 葉は左から記号の順番で並べます。記号が節の記号よりも小さい場合は左部分木をたどり、そうでなければ右部分木をたどります。ここで、節に左部分木の出現頻度の合計値を格納しておくと、記号の累積度数を簡単に求めることができます。次の図を見てください。
</p>

<pre class="fig">
                                ４(26)
                              ／  ＼
                            ／      ＼
                          ／          ＼
                        ／              ＼
                      ／                  ＼
                    ２(15)                  ６(7)
                  ／  ＼                  ／  ＼
                ／      ＼              ／      ＼
              １(8)       ３(6)       ５(4)       ７(2)
            ／  ＼      ／  ＼      ／  ＼      ／  ＼
          ０      １  ２      ３  ４      ５  ６      ７
出現頻度  ８      ７  ６      ５  ４      ３  ２      １  

累積度数：０      ８  15      21  26      30  33      35


            図 : 二分木をたどって累積度数を求める
</pre>
<p> 上図では、節と葉を記号の値で表しています。節の (N) は左部分木の出現頻度の合計値を表します。記号の出現頻度を {8, 7, 6, 5, 4, 3, 2, 1} とすると、節 4 の値は葉 0 から 3 までの合計値 26 になります。節 2 の場合は葉 0 と 1 の合計値なので 15 になります。節 1 は葉 0 の値 8 になります。
</p>
<p> 記号の累積度数を求める場合、葉に到達するまで二分木をたどります。ここで、右部分木をたどるときに出現頻度の合計値 N を足し算していくと、記号の累積度数を求めることができます。たとえば、記号 5 の累積度数を求めてみましょう。最初に変数 sum を 0 に初期化して、節 4 と記号 5 を比較します。記号の方が大きいので右部分木をたどります。このとき、節 4 の値 26 を変数 sum に加算します。
</p>
<p> 次に、節 6 と比較します。今度は記号の方が小さいので左部分木をたどります。このときは出現頻度の合計値を変数 sum に加算しません。その次に、節 5 と比較します。この場合は右部分木をたどるので 4 を加算して sum の値は 30 になります。ここで葉 5 に到達したので、求める累積度数の値は 30 になります。
</p>

<p> 更新処理も簡単です。次の図を見てください。
</p>
<pre class="fig">
                                ４(26+1=27)
                              ／  ＼
                            ／      ＼
                          ／          ＼
                        ／              ＼
                      ／                  ＼
                    ２(15)                  ６(7)
                  ／  ＼                  ／  ＼
                ／      ＼              ／      ＼
              １(8)       ３(6+1=7)   ５(4)       ７(2)
            ／  ＼      ／  ＼      ／  ＼      ／  ＼
          ０      １  ２      ３  ４      ５  ６      ７
出現頻度  ８      ７  ６      ５  ４      ３  ２      １  
                      +1 = 7


                      図 : 記号 2 の更新
</pre>
<p> 実は、累積度数を求めるとき、節に格納されている出現頻度の合計値もいっしょに更新することができます。左部分木をたどる場合、更新する記号はその部分木にあります。記号の出現頻度が一つ増えると、その部分木の出現頻度の合計値も一つ増えますね。つまり、左部分木をたどるとき、出現頻度の合計値を一つ増やせばよいのです。
</p>
<p> たとえば、記号が 2 の場合を考えてみましょう。節 4 では左部分木をたどるので、合計値を +1 します。節 2 は右部分木をたどるので値を増やしません。節 3 で左部分木をたどるので、合計値を +1 します。これで、出現頻度の合計値を更新することができます。
</p>
<p> このように、二分木を使って累積度数の計算と更新処理を行うことができます。記号の種類を N とすると、木の高さは log<sub>2</sub> N になります。したがって、記号が 1 byte (0 - 255) の場合、節を 8 回たどるだけで累積度数の計算と更新処理を行うことができるのです。mij4x さんのプログラムは、二分木の代わりに配列と二分探索を使って高速な処理を実現しています。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。mij4x さんのプログラムは二分探索を使っていますが、ここでは <a href="pyalgo03.html">ヒープ</a> のように配列を二分木に見立ててプログラムを作ることにします。次の図を見てください。
</p>
<pre class="fig">
                            ○０
                          ／  ＼
                        ／      ＼
                      ／          ＼
                    ／              ＼
                  ／                  ＼
                ○１                    ○２
              ／  ＼                  ／  ＼
            ／      ＼              ／      ＼
          ○３        ○４        ○５        ○６
        ／  ＼      ／  ＼      ／  ＼      ／  ＼
      ●      ●  ●      ●  ●      ●  ●      ●
      ７      ８  ９      10  11      12  13      14
記号：０      １  ２      ３  ４      ５  ６      ７

      ○：内部ノード (配列 count_sum) 左部分木の出現頻度の合計値を格納
      ●：外部ノード (配列 count)     記号の出現頻度を格納


                     図 : 二分木の構成
</pre>
<p> 内部ノードを配列 count_sum で、外部ノードを配列 count で表します。たとえば、記号が 8 種類 (0 - 7) の場合、count_sum の大きさは 8 - 1 = 7 になります。節の親子関係は次に示す式で表すことができるので、二分木をたどる処理は簡単です。
</p>
<pre class="fig">
節 N :
  左の子 : 2 * N + 1
  右の子 : 2 * N + 2
  親     : (N - 1) / 2
</pre>
<p> 記号数を N とすると、葉の番号は記号に N - 1 を足した値になります。上図の場合、記号 4 は葉 11 に対応し、その親は (14 - 1) / 2 = 5 になります。節 5 の親は 2 で、節 2 の親はルートの 0 になります。
</p>

<p> 最初に出現頻度表と頻度の更新処理を作ります。
</p>
<pre class="list">
リスト : 出現頻度表の初期化と更新

class Freq:
    def __init__(self, size):
        self.size = size
        self.count = [0] * size
        self.count_sum = [0] * (size - 1)
        self.sum = 0
        for x in xrange(size): self.put_value(x, 1)

    # 頻度の更新
    def put_value(self, c, n):
        node = c + self.size - 1
        self.count[c] += n
        self.sum += n
        while node &gt; 0:
            parent = (node - 1) / 2
            if node &amp; 1:
                # 左の子
                self.count_sum[parent] += n
            node = parent
</pre>
<p> メソッド put_value は出現頻度表の初期化と更新処理に使います。記号 c の出現頻度と合計値 sum を +n するとともに、count_sum の値を更新します。c から葉の番号を求めて node にセットし、ルート方向へ木をたどります。node の親 parent は (node - 1) / 2 で求めることができます。そして、parent の子 node が奇数の場合、node は左の子なので count_sum[parent] を +n します。
</p>

<p> 次は記号の累積度数を求めるメソッド cumul を作ります。
</p>
<pre class="list">
リスト : 記号の累積度数を求める

    def cumul(self, c):
        n = 0
        node = c + self.size - 1
        while node &gt; 0:
            parent = (node - 1) / 2
            if node &amp; 1 == 0:
                # 右の子
                n += self.count_sum[parent]
            else:
                # 左の子
                self.count_sum[parent] += 1
            node = parent
        return n
</pre>
<p> cumul は累積度数を求めると同時に count_sum の値を更新します。木をたどる処理は put_value と同じです。node が parent の右の子であれば、累積度数 n に count_sum[parent] を加算します。左の子の場合は出現頻度の合計値 count_sum[parent] を +1 します。最後に累積度数 n を返します。
</p>

<p> 最後に、復号処理で記号を探索する関数 search_code を作ります。
</p>

<pre class="list">
リスト : 記号の復号

    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            n = 0
            node = 0
            node_size = self.size - 1
            while node &lt; node_size:
                if value &lt; n + self.count_sum[node]:
                    # 左の子をたどる
                    self.count_sum[node] += 1
                    node = 2 * node + 1
                else:
                    # 右の子をたどる
                    n += self.count_sum[node]
                    node = 2 * node + 2
            return node - node_size, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.count[c]
        rc.decode_normalize()
        self.update(c)
        return c
</pre>
<p> 内部関数 search_code は二分木をルートから葉の方向へたどり、累積度数 n を求めながら記号を探索します。value が n + count_sum[node] より小さい場合、求める記号は左部分木にあります。そうでなければ右部分木にあります。左部分木をたどる場合は、count_sum[node] を +1 して count_sum を更新します。右部分木をたどる場合は、n に count_sum[node] を加算して累積度数を求めます。node が node_size 以上になったら葉に到達しました。記号 node - node_size とその累積度数 n を返します。
</p>
<p> あとのプログラムは簡単なので説明は割愛いたします。詳細は <a href="pyalgo38.html#list2">プログラムリスト２</a> をお読みください。
</p>

<h4>●評価結果</h4>
<p> それでは、実際に <a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> で、実行時間を計測してみましょう。結果は次にようになりました。
</p>
<pre>
          表 : 二分木を使った高速化の実行結果

                              従来版     高速化(1)     高速化(2)
  ファイル名      サイズ  符号化  復号  符号化  復号  符号化  復号 
  -----------------------------------------------------------------
  alice29.txt    152,089   5.74  12.67   3,09   4.05   3.32   3.54
  asyoulik.txt   125,179   4.85  10.49   2.60   3.40   2.76   2.95
  cp.html         24,603   0.98   2.05   0.53   0.70   0.55   0.59
  fields.c        11,150   0.41   0.81   0.28   0.30   0.25   0.27
  grammar.lsp      3,721   0.14   0.28   0.08   0.10   0.09   0.09
  kennedy.xls  1,029,744  19.77  30.35  17.80  20.70  21,31  23.13
  lcet10.txt     426,754  16.61  36.63   8.78  11.52   9.38   9.96
  plrabn12.txt   481,861  18.56  41.08   9.86  12.96  10.52  11.22
  ptt5           513,216   8.48  14.38   7.23   8.78   9.23  10.71
  sum             38,240   1.21   2.29   0.76   0.92   0.86   0.90
  xargs.1          4,227   0.18   0.36   0.09   0.12   0.10   0.11
  -----------------------------------------------------------------
  合計         2,810,784  76.93 151.39  51.10  63.55  58.37  63.47

# 符号化と復号の単位 : 秒

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 高速化 (1) は Rick さんの改良方法、高速化 (2) は mij4x さんの改良方法の結果です。二分木を使った効果はとても高く、従来版に比べてとても高速になりました。符号化の場合、高速化 (1) よりも少し遅くなりますが、復号は kennedy.xls と ptt5 以外のファイルで高速化 (1) よりも速くなりました。
</p>

<p> それから、二分木を使った方法は、記号の種類を N とすると、累積度数の計算と更新処理が log<sub>2</sub> N に比例する時間で済むという特徴があります。たとえば、記号の種類が 512 に増えても、累積度数の計算と更新処理は 9 回の繰り返しですみます。とても素晴らしい方法だと思います。mij4x さんに感謝いたします。
</p>

<p> なお、実行時間の結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<hr>
<h4>●Binary Indexed Tree</h4>
<p> 次は Binary Indexed Tree (BIT) という方法を取り上げます。<a href="http://homepage3.nifty.com/wpage/">Yuta Mori さん</a> によると、<cite>『累積度数の取得・更新なら、P. Fenwick氏のBinary Indexed Tree (BIT)という方法が比較的高速』</cite> とのことです。Yuta Mori さんのプログラムは <a href="http://wpage.cocolog-nifty.com/wp/2009/07/binary-indexed-.html">Binary Indexed Treeの二分探索処理</a> で公開されています。今回は Yuta Mori さんのプログラムを参考に BIT を python でプログラムしてみましょう。
</p>

<p> BIT は二分木をベースにした方法です。簡単な例として、記号の種類が 16 (0 - 15) の場合を考えてみましょう。BIT は下図のように二分木を構成します。
</p>

<pre class="fig">
                          ○８
                        ／  ＼
                      ／      ＼
                    ／          ＼
                  ／              ＼
                ／                  ＼
              ○４                    ○12
            ／  ＼                  ／  ＼
          ／      ＼              ／      ＼
        ○２        ○６        ○10        ○14
      ／  ＼      ／  ＼      ／  ＼      ／  ＼
○  ○      ○  ○      ○  ○      ○  ○      ○    
０  １      ３  ５      ７  ９      11  13      15


            図 : Binary Indexed Tree
</pre>

<p> BIT の場合、二分木の節に記号を対応させます。ただし、記号 0 は二分木の中に入れません。そして、節には記号の出現頻度を格納するのではなく、左部分木にある記号の出現頻度とその節の記号の出現頻度の合計値を格納します。たとえば、記号の出現頻度を 0 から順番に {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16} とすると、BIT の各節の値は次のようになります。
</p>
<pre class="fig">
                           ８(44)
                         ／  ＼
                       ／      ＼
                     ／          ＼
                   ／              ＼
                 ／                  ＼
               ４(14)                  12(46)
             ／  ＼                  ／  ＼
           ／      ＼              ／      ＼
         ２(5)       ６(13)      10(21)      14(29)
       ／  ＼      ／  ＼      ／  ＼      ／  ＼
 ０  １      ３  ５      ７  ９      11  13      15   
(１)(２)    (４)(６)    (８)(10)    (12)(14)    (16)


            図 : Binary Indexed Tree の構成
</pre>
<p> 記号 0 と「葉」にあたる節はその記号の出現頻度を表します。BIT の場合、奇数の記号は葉になります。葉以外の節は、左部分木にある記号の出現頻度の合計値にその節の記号の出現頻度を足した値を保持します。たとえば、節 10 の値は記号 9 と記号 10 の出現頻度を足した 21 になります。節 12 の値は、記号 9, 10, 11 と記号 12 の出現頻度を足した 46 になります。節 8 は記号 1 から 8 の出現頻度の合計 44 になります。このように二分木を構成すると、記号の出現頻度と累積度数を簡単に求めることができます。
</p>

<h4>●累積度数の求め方</h4>
<p> それでは、記号の累積度数を求めてみましょう。記号 12 の累積度数は記号 0 から 11 までの出現頻度の合計値になります。BIT の場合、記号 1 から 11 までの出現頻度の合計値は、節 11 からルート方向に木をたどり、記号 11 以下の節の値を足し算すると求めることができます。
</p>
<p> この場合、経路は 11 - 10 - 12 - 8 で、足し算する節は 11, 10, 8 になります。節 11 は記号 11 の出現頻度、節 10 は記号 9, 10 の出現頻度の合計値、節 8 は記号 1 - 8 の出現頻度の合計値なので、これで記号 1 - 11 の出現頻度の合計値を求めることができます。あとは、記号 0 の出現頻度を足し算すれば、累積度数を求めることができます。
</p>

<p> BIT の場合、次の式を使って値を足し算する節を求めることができます。
</p>
<pre class="list">
def BACKWARD(c): return c &amp; (c - 1)
</pre>
<p> 実際に計算してみると次のようになります。
</p>
<pre>
 1 : 1
 2 : 2
 3 : 3 2
 4 : 4
 5 : 5 4
 6 : 6 4
 7 : 7 6 4
 8 : 8
 9 : 9 8
10 : 10 8
11 : 11 10 8
12 : 12 8
13 : 13 12 8
14 : 14 12 8
15 : 15 14 12 8
</pre>
<p> 上図の二分木をたどってみてください。同じ結果になります。このように、簡単な式で節をたどることができるとはちょっと驚きました。式についての説明は割愛いたしますので、興味のある方は <a href="http://www.cs.auckland.ac.nz/~peter-f/">P. Fenwick 氏</a> の論文 <cite>"A New Data Structure for Cumulative Probability Tables"</cite> をお読みください。
</p>

<p> 累積度数を求めるプログラムは次のようになります。
</p>

<pre class="list">
リスト : 累積度数を求める

    def cumul(self, c):
        n = 0
        if c &gt; 0:
            n = self.count[0]
            # c - 1 までの出現頻度を加算する
            c -= 1
            while c &gt; 0:
                n += self.count[c]
                c = c &amp; (c - 1)   # BACKWARD
        return n
</pre>
<p> 変数 n に記号 0 の累積度数 0 をセットします。そのあと、BACKWARD で節をたどりながら、sum に節の値を加算していきます。これで記号 c の累積度数を求めることができます。
</p>

<h4>●出現頻度の求め方</h4>
<p> 記号の出現頻度も簡単に求めることができます。記号 0 と記号が奇数の場合は、節の値をそのまま返せばいいですね。その他の場合、記号 c の累積度数から記号 c - 1 の累積度数を引き算すれば、記号 c の出現頻度を求めることができます。たとえば、記号 12 の出現頻度を求めてみましょう。次の式を見てください。
</p>
<pre class="fig">
  12の累積度数 - 11の累積度数
= ([12] + [8] + [0]) - ([11] + [10] + [8] + [0])
= [12] - [11] - [10]
= 46 - 12 - 21
= 13
</pre>
<p> このように、節 12 の次の節 8 以下の節は共通になるので計算する必要はありません。したがって、節 12 の値から節 11 と 10 の値を引き算すればいいわけです。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 記号の出現頻度を求める

    def get_prob(self, c):
        val = self.count[c]
        if c &gt; 0 and c &amp; 1 == 0:
            p = c &amp; (c - 1)      # BACKWARD
            c -= 1
            while c != p:
                val -= self.count[c]
                c = c &amp; (c - 1)  # BACKWARD
        return val
</pre>

<p> 節の値を変数 val にセットします。記号 0 と奇数の記号は val をそのまま返します。それ以外の場合、記号 c の次の節を変数 p にセットし、c - 1 の節の値を val から引き算します。あとは、BACKWARD で節をたどりながら、節の値を val から引き算すればいいわけです。c が p と等しくなったら for ループを終了して val を返します。
</p>

<h4>●出現頻度の更新</h4>
<p> 更新処理も簡単です。たとえば、記号 11 の出現頻度を +1 する場合、節 11 からルート方向に木をたどり、記号 11 以上の節の値を +1 します。この場合、経路は 11 - 10 - 12 - 8 で、+1 する節は 11, 12 になります。節 11 は記号 11 の出現頻度、節 12 は記号 9 から 12 の出現頻度の合計値で、他の節には記号 11 の値は含まれていません。節 11 と 12 の値を + 1 すればいいわけです。
</p>
<p> BIT の場合、次の式を使って更新する節を求めることができます。
</p>
<pre class="list">
def FORWARD(c): return c + (c &amp; (- c))
</pre>
<p> 実際に計算してみると次のようになります。
</p>
<pre>
 1 : 1 2 4 8
 2 : 2 4 8
 3 : 3 4 8
 4 : 4 8
 5 : 5 6 8
 6 : 6 8
 7 : 7 8
 8 : 8
 9 : 9 10 12
10 : 10 12
11 : 11 12
12 : 12
13 : 13 14
14 : 14
15 : 15
</pre>
<p> 上図の二分木をたどってみてください。同じ結果になることがわかります。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 出現頻度の更新

    def put_value(self, c, inc):
        if c &gt; 0:
            while c &lt; self.size:
                self.count[c] += inc
                c += (c &amp; (- c))  # FORWARD
        else:
            self.count[0] += inc
        self.sum += inc
</pre>

<p> FORWARD で節をたどりながら、節の値に inc を加算していきます。c が size 以上になったら終了です。最後に、記号の総数を表す self.sum に inc を加算します。
</p>

<h4>●出現頻度表の初期化と更新</h4>
<p> BIT の初期化と更新処理は関数 put_value を使って行います。次のリストを見てください。
</p>
<pre class="list">
リスト : BIT の初期化と更新

class Freq:
    def __init__(self, size):
        self.size = size
        self.sum = 0
        self.count = [0] * size
        self.mid = 1                                 # 修正
        while self.mid &lt; size / 2: self.mid &lt;&lt;= 1    # 2010/10/16
        for i in xrange(size): self.put_value(i, 1)

    # 出現頻度表の更新
    def update(self, c):
        self.put_value(c, 1)
        if self.sum &gt;= MIN_RANGE:
            for i in xrange(self.size):
                n = get_prob(i) &gt;&gt; 1
                if n &gt; 0: self.put_value(i, - n)
</pre>
<p> メソッド __init__ は記号の出現頻度を 1 に初期化します。配列 count は 0 で初期化されているので、put_value で各記号の出現頻度を +1 するだけです。メソッド update は記号 c の出現頻度を put_value で +1 します。そして、出現頻度の合計値 sum が MIN_RANGE 以上になったならば、各記号の出現頻度を半分にします。まず、get_prob で記号の出現頻度を求めて 値を 1/2 にします。そして、その値を put_value で引き算します。
</p>
<div class="note">
-- <b>[<a name="update">修正</a> (2010/10/16)]</b> --------<br>
size が 2 の累乗以外の場合でも正しく復号できるように修正。中央値 (ルート) を求める処理を追加します。size が 2 の累乗の場合、中央値は size / 2 で求めることができますが、それ以外の場合は size / 2 &lt;= 2<sup>n</sup> を満たす最小の 2<sup>n</sup> (n は整数) が中央値になります。
</div>
<h4>●記号の復号</h4>
<p> 最後に記号を復号するメソッド decode の内部関数 search_code を作ります。
</p>
<pre class="list">
リスト ; 記号の復号

    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            c = 0
            n = 0
            if self.count[0] &lt;= value:
                h = self.mid               # 修正 2010/10/16
                n = self.count[0]
                while h &gt; 0:
                    # 修正 2010/10/16
                    if c + h &lt; self.size and n + self.count[c + h] &lt;= value:
                        n += self.count[c + h]
                        c += h
                    h &gt;&gt;= 1
                c += 1
            return c, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.get_prob(c)
        rc.decode_normalize()
        self.update(c)
        return c
</pre>
<div class="note">
-- <b>[修正 (2010/10/16)]</b> --------<br>
size が 2 の累乗以外の場合でも正しく復号できるように修正。変数 h を self.mid で初期化して、count の値を求めるとき c + h &lt; self.size のチェックを追加しました。
</div>
<p> 内部関数 search_code は変数 n に累積度数を求め、復号する記号を二分探索します。while ループで二分探索を行い、value &lt;= 累積度数 を満たす一番大きな記号 c を探します。したがって、求める記号は c + 1 になります。最後に、c と n を返します。
</p>
<p> あとのプログラムは簡単なので説明は割愛いたします。詳細は <a href="pyalgo38.html#list3">プログラムリスト３</a> をお読みください。
</p>
<h4>●評価結果</h4>
<p> それでは、実際に <a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> で、実行時間を計測してみましょう。結果は次にようになりました。
</p>
<pre>
                        表 : BIT の実行結果

                                       高速化(1)     高速化(2)     高速化(3)
ファイル名      サイズ  符号化  復号  符号化  復号  符号化  復号  符号化  復号
-------------------------------------------------------------------------------
alice29.txt    152,089   5.74  12.67   3,09   4.05   3.32   3.54   3.62   4,49
asyoulik.txt   125,179   4.85  10.49   2.60   3.40   2.76   2.95   3.00   3.71
cp.html         24,603   0.98   2.05   0.53   0.70   0.55   0.59   0.59   0.73
fields.c        11,150   0.41   0.81   0.28   0.30   0.25   0.27   0.27   0.34
grammar.lsp      3,721   0.14   0.28   0.08   0.10   0.09   0.09   0.09   0.12
kennedy.xls  1,029,744  19.77  30.35  17.80  20.70  21,31  23.13  19.61  23.01
lcet10.txt     426,754  16.61  36.63   8.78  11.52   9.38   9.96  10.16  12.60
plrabn12.txt   481,861  18.56  41.08   9.86  12.96  10.52  11.22  11.44  14.23
ptt5           513,216   8.48  14.38   7.23   8.78   9.23  10.71   6.88   7.54
sum             38,240   1.21   2.29   0.76   0.92   0.86   0.90   0.84   0.96
xargs.1          4,227   0.18   0.36   0.09   0.12   0.10   0.11   0.11   0.13
-------------------------------------------------------------------------------
合計         2,810,784  76.93 151.39  51.10  63.55  58.37  63.47  56.61  67.86

# 符号化と復号の単位 : 秒

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.4.2
</pre>
<p> 高速化 (3) が BIT の実行結果です。BIT の効果はとても高く、従来版に比べてとても高速になりましたが、ptt5 を除いて高速化 (1) よりも少し遅くなりました。BIT のプログラムはけっこう複雑になるので、処理が単純な高速化 (1) の方が少し速くなるようです。BIT は記号 0 を二分木に含めていないので、ptt5 のように記号 0 が多いファイルでは BIT の方が高速に処理できるようです。
</p>

<p> それから、BIT は記号の種類を N とすると、累積度数の計算と更新処理が log<sub>2</sub> N に比例する時間で済むのも特徴です。たとえば、記号の種類が 512 に増えても、累積度数の計算と更新処理は 9 回の繰り返しですみます。また、メモリの消費が少ないのも長所の一つです。Binary Indexed Tree (BIT) は優れた方法だと思います。Yuta Mori さんに感謝いたします。
</p>

<p> なお、実行時間の結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
# coding: utf-8
#
# rc21.py : 適応型レンジコーダ (高速化その１)
#
#          Copyright (C) 2007 Makoto Hiroi
#
import time, sys, getopt, os.path
from rangecoder import *

# 定数
GR = 16

# 出現頻度表
class Freq:
    def __init__(self, size):
        self.size = size
        self.count = [1] * size
        if size % GR == 0:
            self.count_group = [GR] * (size / GR)
        else:
            self.count_group = [GR] * (size / GR + 1)
        self.sum = size

    # 出現頻度表の更新
    def update(self, c):
        self.count[c] += 1
        self.count_group[c / GR] += 1
        self.sum += 1
        if self.sum &gt;= MIN_RANGE:
            n = 0
            for x in xrange(len(self.count_group)):
                self.count_group[x] = 0
            for x in xrange(self.size):
                self.count[x] = (self.count[x] &gt;&gt; 1) | 1
                self.count_group[x / GR] += self.count[x]
                n += self.count[x]
            self.sum = n

    # 記号の累積度数を求める
    def cumul(self, c):
        n = 0
        for x in xrange(c/GR): n += self.count_group[x]
        for x in xrange((c/GR)*GR, c): n += self.count[x]
        return n

    # 符号化
    def encode(self, rc, c):
        temp = rc.range / self.sum
        rc.low += self.cumul(c) * temp
        rc.range = self.count[c] * temp
        rc.encode_normalize()
        self.update(c)

    # 復号
    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            n = 0
            for x in xrange(len(self.count_group)):
                if value &lt; n + self.count_group[x]: break
                n += self.count_group[x]
            for c in xrange(x*GR, self.size):
                if value &lt; n + self.count[c]: break
                n += self.count[c]
            return c, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.count[c]
        rc.decode_normalize()
        self.update(c)
        return c

# ファイルの読み込み
def read_file(fin):
    while True:
        c = getc(fin)
        if c is None: break
        yield c

# レンジコーダによる符号化
def encode(fin, fout):
    rc = RangeCoder(fout, ENCODE)
    freq = Freq(256)
    for x in read_file(fin):
        freq.encode(rc, x)
    rc.finish()

# レンジコーダによる復号
def decode(fin, fout, size):
    freq = Freq(256)
    rc = RangeCoder(fin, DECODE)
    for _ in xrange(size):
        putc(fout, freq.decode(rc))

# 符号化
def encode_file(name1, name2):
    size = os.path.getsize(name1)
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    putc(outfile, (size &gt;&gt; 24) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 16) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 8) &amp; 0xff)
    putc(outfile, size &amp; 0xff)
    if size &gt; 0: encode(infile, outfile)
    infile.close()
    outfile.close()

# 復号
def decode_file(name1, name2):
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    size = 0
    for _ in xrange(4):
        size = (size &lt;&lt; 8) + getc(infile)
    if size &gt; 0: decode(infile, outfile, size)
    infile.close()
    outfile.close()

#
def main():
    eflag = False
    dflag = False
    opts, args = getopt.getopt(sys.argv[1:], 'ed')
    for x, y in opts:
        if x == '-e' or x == '-E':
            eflag = True
        elif x == '-d' or x == '-D':
            dflag = True
    if eflag and dflag:
        print 'option error'
    elif eflag:
        encode_file(args[0], args[1])
    elif dflag:
        decode_file(args[0], args[1])
    else:
        print 'option error'

#
s = time.clock()
main()
e = time.clock()
print "%.3f" % (e - s)
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
# coding: utf-8
#
# rc22.py : 適応型レンジコーダ (二分木を使った高速化)
#
#           Copyright (C) 2007 Makoto Hiroi
#
import time, sys, getopt, os.path
from rangecoder import *

# 出現頻度表
class Freq:
    def __init__(self, size):
        self.size = size
        self.count = [0] * size
        self.count_sum = [0] * (size - 1)
        self.sum = 0
        for x in xrange(size): self.put_value(x, 1)

    # 頻度の更新
    def put_value(self, c, n):
        node = c + self.size - 1
        self.count[c] += n
        self.sum += n
        while node &gt; 0:
            parent = (node - 1) / 2
            if node &amp; 1:
                # 左の子
                self.count_sum[parent] += n
            node = parent

    # 記号の累積度数を求める
    def cumul(self, c):
        n = 0
        node = c + self.size - 1
        while node &gt; 0:
            parent = (node - 1) / 2
            if node &amp; 1 == 0:
                # 右の子
                n += self.count_sum[parent]
            else:
                # 左の子
                self.count_sum[parent] += 1
            node = parent
        return n

    # 出現頻度表の更新
    def update(self, c):
        self.count[c] += 1
        self.sum += 1
        if self.sum &gt;= MIN_RANGE:
            for x in xrange(self.size):
                n = self.count[x] &gt;&gt; 1
                if n &gt; 0: self.put_value(x, - n)

    # 符号化
    def encode(self, rc, c):
        temp = rc.range / self.sum
        rc.low += self.cumul(c) * temp
        rc.range = self.count[c] * temp
        rc.encode_normalize()
        self.update(c)

    # 復号
    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            n = 0
            node = 0
            node_size = self.size - 1
            while node &lt; node_size:
                if value &lt; n + self.count_sum[node]:
                    # 左の子をたどる
                    self.count_sum[node] += 1
                    node = 2 * node + 1
                else:
                    # 右の子をたどる
                    n += self.count_sum[node]
                    node = 2 * node + 2
            return node - node_size, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.count[c]
        rc.decode_normalize()
        self.update(c)
        return c

# ファイルの読み込み
def read_file(fin):
    while True:
        c = getc(fin)
        if c is None: break
        yield c

# レンジコーダによる符号化
def encode(fin, fout):
    rc = RangeCoder(fout, ENCODE)
    freq = Freq(256)
    for x in read_file(fin):
        freq.encode(rc, x)
    rc.finish()

# レンジコーダによる復号
def decode(fin, fout, size):
    freq = Freq(256)
    rc = RangeCoder(fin, DECODE)
    for _ in xrange(size):
        putc(fout, freq.decode(rc))

# 符号化
def encode_file(name1, name2):
    size = os.path.getsize(name1)
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    putc(outfile, (size &gt;&gt; 24) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 16) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 8) &amp; 0xff)
    putc(outfile, size &amp; 0xff)
    if size &gt; 0: encode(infile, outfile)
    infile.close()
    outfile.close()

# 復号
def decode_file(name1, name2):
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    size = 0
    for _ in xrange(4):
        size = (size &lt;&lt; 8) + getc(infile)
    if size &gt; 0: decode(infile, outfile, size)
    infile.close()
    outfile.close()

#
def main():
    eflag = False
    dflag = False
    opts, args = getopt.getopt(sys.argv[1:], 'ed')
    for x, y in opts:
        if x == '-e' or x == '-E':
            eflag = True
        elif x == '-d' or x == '-D':
            dflag = True
    if eflag and dflag:
        print 'option error'
    elif eflag:
        encode_file(args[0], args[1])
    elif dflag:
        decode_file(args[0], args[1])
    else:
        print 'option error'

#
s = time.clock()
main()
e = time.clock()
print "%.3f" % (e - s)
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
# coding: utf-8
#
# rc23.py : 適応型レンジコーダ (Binary Indexed Tree)
#
#           Copyright (C) 2007 Makoto Hiroi
#
# 修正 2010/10/16
# size が 2 の累乗でなくても正しく復号できるように修正。
#
import time, sys, getopt, os.path
from rangecoder import *

# 出現頻度表
class Freq:
    def __init__(self, size):
        self.size = size
        self.sum = 0
        self.count = [0] * size
        self.mid = 1                                 # 修正
        while self.mid &lt; size / 2: self.mid &lt;&lt;= 1    # 2010/10/16
        for i in xrange(size): self.put_value(i, 1)

    # 記号の出現頻度を求める
    def get_prob(self, c):
        val = self.count[c]
        if c &gt; 0 and c &amp; 1 == 0:
            p = c &amp; (c - 1)      # BACKWARD
            c -= 1
            while c != p:
                val -= self.count[c]
                c = c &amp; (c - 1)  # BACKWARD
        return val

    # 頻度の更新
    def put_value(self, c, inc):
        if c &gt; 0:
            while c &lt; self.size:
                self.count[c] += inc
                c += (c &amp; (- c))  # FORWARD
        else:
            self.count[0] += inc
        self.sum += inc

    # 記号の累積度数を求める
    def cumul(self, c):
        n = 0
        if c &gt; 0:
            n = self.count[0]
            # c - 1 までの頻度を加算する
            c -= 1
            while c &gt; 0:
                n += self.count[c]
                c = c &amp; (c - 1)   # BACKWARD
        return n

    # 出現頻度表の更新
    def update(self, c):
        self.put_value(c, 1)
        if self.sum &gt;= MIN_RANGE:
            for i in xrange(self.size):
                n = get_prob(i) &gt;&gt; 1
                if n &gt; 0: self.put_value(i, - n)

    # 符号化
    def encode(self, rc, c):
        temp = rc.range / self.sum
        rc.low += self.cumul(c) * temp
        rc.range = self.get_prob(c) * temp
        rc.encode_normalize()
        self.update(c)

    # 復号
    def decode(self, rc):
        # 記号の探索
        def search_code(value):
            c = 0
            n = 0
            if self.count[0] &lt;= value:
                h = self.mid       # 修正 2010/10/16
                n = self.count[0]
                while h &gt; 0:
                    # 修正 2010/10/16
                    if c + h &lt; self.size and n + self.count[c + h] &lt;= value:
                        n += self.count[c + h]
                        c += h
                    h &gt;&gt;= 1
                c += 1
            return c, n
        #
        temp = rc.range / self.sum
        c, num = search_code(rc.low / temp)
        rc.low -= temp * num
        rc.range = temp * self.get_prob(c)
        rc.decode_normalize()
        self.update(c)
        return c

# ファイルの読み込み
def read_file(fin):
    while True:
        c = getc(fin)
        if c is None: break
        yield c

# レンジコーダによる符号化
def encode(fin, fout):
    rc = RangeCoder(fout, ENCODE)
    freq = Freq(256)
    for x in read_file(fin):
        freq.encode(rc, x)
    rc.finish()

# レンジコーダによる復号
def decode(fin, fout, size):
    freq = Freq(256)
    rc = RangeCoder(fin, DECODE)
    for _ in xrange(size):
        putc(fout, freq.decode(rc))

# 符号化
def encode_file(name1, name2):
    size = os.path.getsize(name1)
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    putc(outfile, (size &gt;&gt; 24) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 16) &amp; 0xff)
    putc(outfile, (size &gt;&gt; 8) &amp; 0xff)
    putc(outfile, size &amp; 0xff)
    if size &gt; 0: encode(infile, outfile)
    infile.close()
    outfile.close()

# 復号
def decode_file(name1, name2):
    infile = open(name1, "rb")
    outfile = open(name2, "wb")
    size = 0
    for _ in xrange(4):
        size = (size &lt;&lt; 8) + getc(infile)
    if size &gt; 0: decode(infile, outfile, size)
    infile.close()
    outfile.close()

#
def main():
    eflag = False
    dflag = False
    opts, args = getopt.getopt(sys.argv[1:], 'ed')
    for x, y in opts:
        if x == '-e' or x == '-E':
            eflag = True
        elif x == '-d' or x == '-D':
            dflag = True
    if eflag and dflag:
        print 'option error'
    elif eflag:
        encode_file(args[0], args[1])
    elif dflag:
        decode_file(args[0], args[1])
    else:
        print 'option error'

#
s = time.clock()
main()
e = time.clock()
print "%.3f" % (e - s)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007-2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo37.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo39.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>