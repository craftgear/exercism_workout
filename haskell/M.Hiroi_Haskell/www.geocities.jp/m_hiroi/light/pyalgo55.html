<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / 赤黒木 (red-black tree)</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881798</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>赤黒木 (red-black tree) [4]</h2>
<div class="small">
[ <a href="pyalgo54.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo56.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 前回は 2-3 木をベースにした Left-Leaning Red Black Tree (LLRB 木) を作成しました。LLRB 木の場合、赤節は黒節の左の子にしかなれません。今回は黒節の右の子にも赤節を許す赤黒木を作ってみましょう。
</p>

<h4>●データの挿入</h4>
<p> データ挿入の基本的な考え方は簡単です。通常の赤黒木のようにデータを挿入しますが、左右の子がともに赤節になったならば、その節を分割して親節で木のバランスを修正します。プログラムの作成は簡単で、<a href="pyalgo16.html">赤黒木 [1]</a> のプログラムを少し修正するだけです。左部分木のバランスを修正する関数 balance_insert_left は次のようになります。
</p>

<pre class="list">
リスト : データの挿入

# 4node の分割
def split(node):
    node.color = RED
    node.left.color = BLACK
    node.right.color = BLACK

# 左部分木の修正
def balance_insert_left(node, flag):
    if flag: return node, flag
    if node.color == BLACK:
        if node.right.color == RED:
            # 4 node なので分割
            split(node)
        else:
            if node.left.right.color == RED:
                node.left = rotate_left(node.left)
            if node.left.left.color == RED:
                # 赤が 2 つ続く
                node = rotate_right(node)
                # 4 node になるので分割
                split(node)
            else:
                # 赤一つならば終了
                flag = True
    return node, flag

# データの挿入
def insert(node, x):
    if node is null: return Node(x), False
    if x &lt; node.data:
        node.left, flag = insert(node.left, x)
        return balance_insert_left(node, flag)
    elif x &gt; node.data:
        node.right, flag = insert(node.right, x)
        return balance_insert_right(node, flag)
    return node, True
</pre>
<p> balance_insert_left でバランスを修正する場合、node.left は赤節になります。最初に、右の子 (node.right) が赤節かチェックします。そうであれば、左右の子が赤になるので、split で節を分割して node の親節でバランスを修正します。
</p>
<p> 右の子が黒節ならば、node.left の子に赤節がないかチェックします。この処理は <a href="pyalgo16.html">赤黒木 [1]</a> のプログラムと同じですが、左右の子が赤節になった場合は split で node を分割する処理を追加します。赤節が node.left の一つだけならば、木のバランスを修正する必要はありません。
</p>
<p> 右部分木のバランスを修正する関数 balance_lnsert_right は、子のチェックと回転操作が左右対称になるだけなので説明は割愛いたします。詳細は <a href="pyalgo55.html#list1">プログラムリスト</a> をお読みください。
</p>
<h4>●補足</h4>
<p> ところで、データの挿入処理は次のようにプログラムすることもできます。
</p>
<pre class="list">
リスト : データの挿入 (2-3 木版)

# 簡単な実装方法
def insert1(node, x):
    if node is null: return Node(x)
    # 木をたどる
    if x &lt; node.data:
        node.left = insert1(node.left, x)
    elif x &gt; node.data:
        node.right = insert1(node.right, x)
    # バランスの修正
    # 左の子をチェック
    if node.left.color == RED:
        if node.left.right.color == RED:
            node.left = rotate_left(node.left)
        if node.left.left.color == RED:
            node = rotate_right(node)
    # 右の子をチェック
    if node.right.color == RED:
        if node.right.left.color == RED:
            node.right = rotate_right(node.right)
        if node.right.right.color == RED:
            node = rotate_left(node)
    # 4 node の分割
    if node.left.color == RED and node.right.color == RED:
        split(node)
    return node
</pre>
<p> 左右の子で赤節が 2 つ続いているかチェックし、そうであれば木を回転してバランスを修正します。そのあとで左右の子がともに赤節ならば split で分割します。
</p>
<p> また、<a href="pyalgo55.html#cite">参考文献, URL 1</a> によると、木をたどるときに 4 node の分割処理を行うと、通常の赤黒木の挿入処理になります。
</p>
<pre class="list">
リスト : データの挿入 (2-3-4 木版)

# 簡単な実装方法
def insert1(node, x):
    if node is null: return Node(x)
    # 4 node の分割
    if node.left.color == RED and node.right.color == RED:
        split(node)
    # 木をたどる
    if x &lt; node.data:
        node.left = insert1(node.left, x)
    elif x &gt; node.data:
        node.right = insert1(node.right, x)
    # バランスの修正
    # 左の子をチェック
    if node.left.color == RED:
        if node.left.right.color == RED:
            node.left = rotate_left(node.left)
        if node.left.left.color == RED:
            node = rotate_right(node)
    # 右の子をチェック
    if node.right.color == RED:
        if node.right.left.color == RED:
            node.right = rotate_right(node.right)
        if node.right.right.color == RED:
            node = rotate_left(node)
    return node
</pre>
<p> このように、とても簡単にプログラムできるのですが、実行速度はどちらのプログラムも LLRB 木より遅くなります。これはあとで実際に試してみましょう。
</p>
<h4>●データ挿入のテスト</h4>
<p> それでは、ここでデータ挿入のテストを行ってみましょう。テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : データ挿入の簡単なテスト

# 木の表示
def print_node(node, n):
    color = ('B', 'R')
    if node is not null:
        print_node(node.left, n + 1)
        print '    ' * n, color[node.color], node.data
        print_node(node.right, n + 1)

# 赤黒木の条件を満たしているか
def check_rb23tree(node):
    if node is not null:
        if node.color == RED:
            if node.left.color == RED or node.right.color == RED:
                raise 'rb23 error1'
        else:
            if node.left.color == RED and node.right.color == RED:
                raise 'rb23 error2'
        a = check_rb23tree(node.left)
        b = check_rb23tree(node.right)
        if a != b: raise 'rb23 error3'
        if node.color == BLACK: a += 1
        return a
    return 0

# test
if __name__ == '__main__':
    import random, time
    root = make_null()
    buff = range(8)
    print 'insert test'
    for x in buff:
        print '----- insert', x
        root = insert1(root, x)
        root.color = BLACK
        print_node(root, 0)
        check_rb23tree(root)
</pre>
<p> print_node は赤黒木を表示する関数です。黒節は B を、赤節は R をつけて表しています。終端は None ではなく null なので、node と null を比較していることに注意してください。
</p>
<p> 関数 check_rb23tree は赤黒木の条件をチェックする関数です。node が赤節の場合、その子が赤節であればエラーを送出します。node が黒節の場合、左右の子がともに赤節の場合もエラーを送出します。check_rb23tree の返り値は黒高さです。左右の部分木の黒高さを求め、それが等しくない場合はエラーを送出します。
</p>
<p> テストは 0 から 7 までの整数値を順番に赤黒木に挿入します。実行結果は次のようになります。
</p>
<pre>
insert test
----- insert 0
 B 0
----- insert 1
 B 0
     R 1
----- insert 2
     B 0
 B 1
     B 2
----- insert 3
     B 0
 B 1
     B 2
         R 3
----- insert 4
     B 0
 B 1
         B 2
     R 3
         B 4
----- insert 5
     B 0
 B 1
         B 2
     R 3
         B 4
             R 5
----- insert 6
         B 0
     B 1
         B 2
 B 3
         B 4
     B 5
         B 6
----- insert 7
         B 0
     B 1
         B 2
 B 3
         B 4
     B 5
         B 6
             R 7
</pre>
<p> どの経路でも黒高さが同じになっていることがすぐにわかると思います。また、赤節は黒節の左右のどちらかにしか存在しません。これが 2-3 木をベースにした赤黒木の特徴です。
</p>
<p> 今度は木の高さを比較してみましょう。テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : データ挿入の簡単なテスト (2)

# coding: utf-8

import node
import avlnode
import rbnode
import rb23node
import llrb23node
import random

# 木の高さを求める
def get_height(node, term = None):
    if node is not term:
        a = get_height(node.left)
        b = get_height(node.right)
        return max(a, b) + 1
    return 0

for x in [1000, 2000, 4000, 8000, 16000, 32000]:
        a = None
        b = rbnode.make_null()
        c = rb23node.make_null()
        d = llrb23node.make_null()
        buff = range(n)
        random.shuffle(buff)
        for x in buff:
            a = avlnode.insert(a, x)
            b, _ = rbnode.insert(b, x)
            b.color = rbnode.BLACK
            c, _ = rb23node.insert(c, x)
            c.color = rb23node.BLACK
            d, _ = llrb23node.insert1(d, x)
            d.color = llrb23node.BLACK
        print n,
        print get_height(a),
        print get_height(b, rbnode.null),
        print get_height(c, rb23node.null),
        print get_height(d, llrb23node.null),
        print
</pre>
<p> それでは、実行結果を示します。
</p>
<pre>
    表 : 木の高さ

  N   : AVL  RB  RB23 LLRB
---------------------------
 1000 : 12   12   12   13
 2000 : 13   14   14   16
 4000 : 14   15   15   16
 8000 : 16   16   16   18
16000 : 16   17   17   19
32000 : 18   18   19   21
</pre>
<p> RB は赤黒木 (2-3-4 木) で、RB23 は今回作成した赤黒木 (2-3 木) です。木の高さは AVL 木 &lt; RB 木 &lt; RB23 木 &lt; LLRB 木になりました。
</p>
<p> 次はソート済みデータで試してみましょう。結果は次のようになりました。
</p>
<pre>
  表 : 木の高さ
  
 (a) 昇順

  N   : AVL  RB  RB23 LLRB
---------------------------
 1000 : 10   17   15   10
 2000 : 11   19   16   11
 4000 : 12   21   17   12
 8000 : 13   23   18   13
16000 : 14   25   19   14
32000 : 15   27   20   15

 (b) 逆順

  N   : AVL  RB  RB23 LLRB
---------------------------
 1000 : 10   17   15   15
 2000 : 11   19   16   16
 4000 : 12   21   17   17
 8000 : 13   23   18   18
16000 : 14   25   19   19
32000 : 15   27   20   20
</pre>
<p> ソート済みデータの場合、木の高さは RB 木よりも RB23 木の方が低くなりました。これらの結果を見ると、2-3 木をベースにした赤黒木でも十分な性能が得られるように思います。
</p>

<h4>●データ削除のテスト</h4>
<p> データの削除は <a href="pyalgo17.html">赤黒木 [2]</a> のプログラムをそのまま使用することができます。それでは、ここでデータ削除のテストを行ってみましょう。テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : データ削除の簡単なテスト

# test
if __name__ == '__main__':
    import random, time
    root = make_null()
    buff = range(8)
    print 'insert test'
    for x in buff:
        root = insert(root, x)
        root.color = BLACK
        check_rb23tree(root)
    print 'delete test'
    print_node(root, 0)
    for x in buff:
        print '----- delete ', x
        root, _ = delete(root, x)
        root.color = BLACK
        print_node(root, 0)
        check_rb23tree(root)
</pre>
<p> 実行結果を示します。
</p>
<pre>
         B 0
     B 1
         B 2
 B 3
         B 4
     B 5
         B 6
             R 7
delete test
----- delete 0
     B 1
         R 2
 B 3
         B 4
     R 5
         B 6
             R 7
----- delete 1
     B 2
 B 3
         B 4
     R 5
         B 6
             R 7
----- delete 2
     B 3
         R 4
 B 5
     B 6
         R 7
----- delete 3
     B 4
 B 5
     B 6
         R 7
----- delete 4
     B 5
 B 6
     B 7
----- delete 5
 B 6
     R 7
----- delete 6
 B 7
----- delete 7

</pre>
<p> このように、データを削除しても赤黒木のバランスが大きく崩れることはありません。
</p>
<h4>●RB23tree クラスの作成</h4>
<p> 最後に赤黒木を表すクラスを作成します。次のリストを見てください。
</p>
<pre class="list">
# coding: utf-8
#
# rb23tree.py : 赤黒木 (2-3 木をベース)
#
#               Copyright (C) 2009 Makoto Hiroi
#
import rb23node

# 赤黒木
class RB23tree:
    def __init__(self):
        self.root = rb23node.make_null()

    # 探索
    def search(self, x):
        return rb23node.search(self.root, x)

    # 挿入
    def insert(self, x):
        self.root, _ = rb23node.insert(self.root, x)
        self.root.color = rb23node.BLACK

    # 削除
    def delete(self, x):
        self.root, _ = rb23node.delete(self.root, x)
        self.root.color = rb23node.BLACK

    # 巡回
    def traverse(self):
        for x in rb23node.traverse(self.root):
            yield x

    # 表示
    def __str__(self):
        if self.root is rb23node.null: return 'RB23tree()'
        buff = 'RB23tree('
        for x in rb23node.traverse(self.root):
            buff += '%s, ' % x
        buff = buff.rstrip(',  ')
        buff += ')'
        return buff

# テスト
if __name__ == '__main__':
    import random
    tree = RB23tree()
    data = [random.randint(0, 100) for x in range(10)]
    print data
    print tree
    for x in data: tree.insert(x)
    print tree
    for x in data:
        print 'search', x, tree.search(x)
        print 'delete', x
        tree.delete(x)
        print 'search', x, tree.search(x)
        print tree
</pre>
<p> クラス名は RB23tree としました。RB23tree のメソッドはモジュール rb23node の操作関数を呼び出すだけです。メソッド __init__ で root を初期化するとき、モジュール rb23node の関数 make_null を呼び出して、終端オブジェクトを設定することに注意してください。あとは、とくに難しいところはないでしょう。
</p>
<p> それでは、テストの実行結果を示します。
</p>
<pre>
[21, 64, 51, 35, 94, 17, 89, 35, 99, 98]
RB23tree()
RB23tree(17, 21, 35, 51, 64, 89, 94, 98, 99)
search 21 True
delete 21
search 21 False
RB23tree(17, 35, 51, 64, 89, 94, 98, 99)
search 64 True
delete 64
search 64 False
RB23tree(17, 35, 51, 89, 94, 98, 99)
search 51 True
delete 51
search 51 False
RB23tree(17, 35, 89, 94, 98, 99)
search 35 True
delete 35
search 35 False
RB23tree(17, 89, 94, 98, 99)
search 94 True
delete 94
search 94 False
RB23tree(17, 89, 98, 99)
search 17 True
delete 17
search 17 False
RB23tree(89, 98, 99)
search 89 True
delete 89
search 89 False
RB23tree(98, 99)
search 35 False
delete 35
search 35 False
RB23tree(98, 99)
search 99 True
delete 99
search 99 False
RB23tree(98)
search 98 True
delete 98
search 98 False
RB23tree()
</pre>
<h4>●RB23tree の評価</h4>
<p> それでは、赤黒木 (2-3-4木)、LLRB 木、赤黒木 (2-3 木) の性能を比較してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 赤黒木 (2-3-4 木)、LLRB 木、赤黒木 (2-3 木) のテスト

from llrb23tree import *
from rbtree import *
from rb23tree import *
import time, random

def insert_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.insert(x)
    e = time.clock()
    return e - s

def search_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.search(x)
    e = time.clock()
    return e - s

def delete_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.delete(x)
    e = time.clock()
    return e - s

for x in [1000, 2000, 4000, 8000, 16000]:
    buff = range(x)
    random.shuffle(buff)
    print x,
    for tree in [RBtree, LLRB23tree, RB23tree]:
        a = tree()
        print '%.3f' % insert_test(a, buff),
        print '%.3f' % search_test(a, buff),
        print '%.3f' % delete_test(a, buff),
    print
</pre>
<p> データを乱数で生成します。そして、木にデータを挿入する (insert_test)、データを探索する (search_test)、データを削除する (delete_test) 時間を計測します。結果は次のようになりました。
</p>
<pre>
        表 : 実行結果 (単位 : 秒)

      :       RB tree       :      LLRB tree      :      RB23 tree
 個数 : 挿入   探索   削除  : 挿入   探索   削除  : 挿入   探索   削除
-----------------------------------------------------------------------
 1000 : 0.019  0.005  0.016 : 0.021  0.006  0.016 : 0.018  0.005  0.016
 2000 : 0.039  0.012  0.034 : 0.041  0.012  0.036 : 0.039  0.012  0.035
 4000 : 0.085  0.026  0.077 : 0.087  0.026  0.077 : 0.084  0.026  0.076
 8000 : 0.188  0.058  0.167 : 0.192  0.058  0.173 : 0.184  0.059  0.169
16000 : 0.420  0.137  0.381 : 0.441  0.140  0.395 : 0.409  0.138  0.383

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
[<a href="pyalgo55.html#update">改訂</a> 2010/10/10]
</div>

<p> 通常の赤黒木と同様に、2-3 木をベースにした赤黒木も高速ですね。
</p>

<p> 次はソート済みのデータで試してみましょう。実行結果は次のようになりました。
</p>
<pre>
        表 : ソート済みデータの実行結果 (単位 : 秒)

  (a) 昇順

      :       RB tree       :      LLRB tree      :      RB23 tree
 個数 : 挿入   探索   削除  : 挿入   探索   削除  : 挿入   探索   削除
-----------------------------------------------------------------------
 1000 : 0.028  0.005  0.015 : 0.022  0.005  0.019 : 0.024  0.005  0.015
 2000 : 0.061  0.012  0.032 : 0.044  0.011  0.041 : 0.052  0.012  0.032
 4000 : 0.134  0.025  0.069 : 0.094  0.025  0.091 : 0.114  0.026  0.070
 8000 : 0.292  0.055  0.149 : 0.201  0.054  0.200 : 0.242  0.056  0.152
16000 : 0.633  0.118  0.321 : 0.430  0.115  0.433 : 0.520  0.120  0.326

  (b) 逆順

      :       RB tree       :      LLRB tree      :      RB23 tree
 個数 : 挿入   探索   削除  : 挿入   探索   削除  : 挿入   探索   削除
-----------------------------------------------------------------------
 1000 : 0.026  0.005  0.014 : 0.023  0.005  0.014 : 0.022  0.005  0.015
 2000 : 0.056  0.012  0.031 : 0.047  0.012  0.030 : 0.048  0.012  0.032
 4000 : 0.123  0.026  0.068 : 0.102  0.026  0.065 : 0.105  0.026  0.070
 8000 : 0.268  0.055  0.148 : 0.220  0.055  0.142 : 0.224  0.055  0.150
16000 : 0.578  0.118  0.316 : 0.474  0.119  0.304 : 0.479  0.118  0.324

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
-- <a name="update">改訂</a> --------<br>
2010/10/10 Python のバージョンを 2.5.2 から 2.7 に変更して実行時間を計測
</div>
<p> ソート済みデータの場合、データの挿入は RB 木よりも RB23 木の方が速くなりました。これらの結果を見ると、2-3 木をベースにした赤黒木でも十分な性能が得られることがわかります。
</p>
<p> なお、これらの結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li><a href="http://www.cs.princeton.edu/~rs/">Robert Sedgewick</a>, <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf">"Left-Leaning Red Black Trees" (PDF)</a>
</ol>
<h4>●Appendix</h4>
<p> ご参考までに、データの挿入処理で簡単な実装方法 (関数 insert1) を使用した場合の実行結果を示します。
</p>
<pre>
        表 : データ挿入の実行結果 (単位 : 秒)

      :      ランダム       :        昇順         :        逆順
  N   :  RB    LLRB   RB23  :  RB    LLRB   RB23  :  RB    LLRB   RB23
-----------------------------------------------------------------------
 1000 : 0.033  0.020  0.020 : 0.046  0.023  0.027 : 0.044  0.024  0.026
 2000 : 0.074  0.039  0.044 : 0.100  0.047  0.059 : 0.096  0.048  0.058
 4000 : 0.159  0.085  0.096 : 0.220  0.100  0.129 : 0.209  0.105  0.127
 8000 : 0.351  0.188  0.209 : 0.480  0.212  0.279 : 0.456  0.226  0.274
16000 : 0.778  0.426  0.478 : 1.037  0.453  0.602 : 0.986  0.488  0.590

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
-- 改訂 --------<br>
2010/10/10 Python のバージョンを 2.5.2 から 2.7 に変更して実行時間を計測
</div>
<p> 簡単な実装方法では LLRB 木が一番速いですね。簡単にプログラムできて処理速度も速い LLRB 木は優秀なアルゴリズムだと思います。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
# coding: utf-8
#
# rb23node.py : 赤黒木用操作関数 (2-3 木をベース)
#
#               Copyright (C) 2009 Makoto Hiroi
#

# 終端
null = None

# 色
BLACK = 0
RED = 1

# 節
class Node:
    def __init__(self, x, color = RED):
        self.data = x
        self.color = color
        self.left = null
        self.right = null

# 終端の設定
def make_null():
    global null
    if null is None:
        null = Node(None, BLACK)
        null.left = None
        null.right = None
    return null

# 右回転
def rotate_right(node):
    lnode = node.left
    node.left = lnode.right
    lnode.right = node
    lnode.color = node.color
    node.color = RED
    return lnode

# 左回転
def rotate_left(node):
    rnode = node.right
    node.right = rnode.left
    rnode.left = node
    rnode.color = node.color
    node.color = RED
    return rnode

#
# データの探索
#
def search(node, x):
    while node is not null:
        if x == node.data: return True
        elif x &lt; node.data:
            node = node.left
        else:
            node = node.right
    return False

#
# データの挿入
#

# 4node の分割
def split(node):
    node.color = RED
    node.left.color = BLACK
    node.right.color = BLACK

# 左部分木の修正
def balance_insert_left(node, flag):
    if flag: return node, flag
    if node.color == BLACK:
        if node.right.color == RED:
            # 4 node なので分割
            split(node)
        else:
            if node.left.right.color == RED:
                node.left = rotate_left(node.left)
            if node.left.left.color == RED:
                # 赤が 2 つ続く
                node = rotate_right(node)
                # 4 node になるので分割
                split(node)
            else:
                # 赤一つならば終了
                flag = True
    return node, flag

# 右部分木の修正
def balance_insert_right(node, flag):
    if flag: return node, flag
    if node.color == BLACK:
        if node.left.color == RED:
            # 4 node なので分割
            split(node)
        else:
            if node.right.left.color == RED:
                node.right = rotate_right(node.right)
            if node.right.right.color == RED:
                # 赤が 2 つ続く
                node = rotate_left(node)
                # 4node になるので分割
                split(node)
            else:
                # 赤一つならば終了
                flag = True
    return node, flag

# データの挿入
def insert(node, x):
    if node is null: return Node(x), False
    if x &lt; node.data:
        node.left, flag = insert(node.left, x)
        return balance_insert_left(node, flag)
    elif x &gt; node.data:
        node.right, flag = insert(node.right, x)
        return balance_insert_right(node, flag)
    return node, True

# 簡易バージョン (遅い)
def insert1(node, x):
    if node is null: return Node(x)
    if x &lt; node.data:
        node.left = insert1(node.left, x)
    elif x &gt; node.data:
        node.right = insert1(node.right, x)
    # バランスの修正
    if node.left.color == RED:
        if node.left.right.color == RED:
            node.left = rotate_left(node.left)
        if node.left.left.color == RED:
            node = rotate_right(node)
    if node.right.color == RED:
        if node.right.left.color == RED:
            node.right = rotate_right(node.right)
        if node.right.right.color == RED:
            node = rotate_left(node)
    if node.left.color == RED and node.right.color == RED:
        split(node)
    return node

#
# データの削除
#

# 右部分木の修正
def balance_right(node, flag):
    if flag: return node, flag
    if node.left.left.color == BLACK and node.left.right.color == BLACK:
        if node.left.color == BLACK:
            node.left.color = RED
            if node.color == BLACK: return node, False
            node.color = BLACK
        else:
            node = rotate_right(node)
            node.right, _ = balance_right(node.right, False)
    else:
        if node.left.right.color == RED:
            node.left = rotate_left(node.left)
        node = rotate_right(node)
        node.right.color = BLACK
        node.left.color = BLACK
    return node, True

# 左部分木の修正
def balance_left(node, flag):
    if flag: return node, flag
    if node.right.left.color == BLACK and node.right.right.color == BLACK:
        if node.right.color == BLACK:
            node.right.color = RED
            if node.color == BLACK: return node, False
            node.color = BLACK
        else:
            node = rotate_left(node)
            node.left, _ = balance_left(node.left, False)
    else:
        if node.right.left.color == RED:
            node.right = rotate_right(node.right)
        node = rotate_left(node)
        node.left.color = BLACK
        node.right.color = BLACK
    return node, True

# 最小値を探す
def search_min(node):
    while node.left is not null: node = node.left
    return node.data

# 削除
def delete(node, x):
    if node is null: return node, True
    if x == node.data:
        if node.left is null and node.right is null:
            return null, node.color == RED
        elif node.right is null:
            node.left.color = BLACK
            return node.left, True
        elif node.left is null:
            node.right.color = BLACK
            return node.right, True
        else:
            node.data = search_min(node.right)
            node.right, flag = delete(node.right, node.data)
            return balance_right(node, flag)
    elif x &lt; node.data:
        node.left, flag = delete(node.left, x)
        return balance_left(node, flag)
    else:
        node.right, flag = delete(node.right, x)
        return balance_right(node, flag)

#
# 巡回
#
def traverse(node):
    if node is not null:
        for x in traverse(node.left):
            yield x
        yield node.data
        for x in traverse(node.right):
            yield x

# 木の表示
def print_node(node, n):
    color = ('B', 'R')
    if node is not null:
        print_node(node.left, n + 1)
        print '    ' * n, color[node.color], node.data
        print_node(node.right, n + 1)

# 赤黒木の条件を満たしているか
def check_rb23tree(node):
    if node is not null:
        if node.color == RED:
            if node.left.color == RED or node.right.color == RED:
                raise 'rb23 error1'
        else:
            if node.left.color == RED and node.right.color == RED:
                raise 'rb23 error2'
        a = check_rb23tree(node.left)
        b = check_rb23tree(node.right)
        if a != b: raise 'rb23 error3'
        if node.color == BLACK: a += 1
        return a
    return 0

# test
if __name__ == '__main__':
    import random, time
    root = make_null()
    buff = range(1000)
    random.shuffle(buff)
    print 'insert test'
    for x in buff:
        root = insert1(root, x)
        root.color = BLACK
        check_rb23tree(root)
    print 'search test'
    random.shuffle(buff)
    for x in buff:
        if not search(root, x):
            raise 'search error'
    print 'delete test'
    for x in buff:
        root, _ = delete(root, x)
        root.color = BLACK
        check_rb23tree(root)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009-2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo54.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo56.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>