<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Julia プログラミング超入門</title>
  <meta name="description" content="Julia 入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881803</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Julia Language Programming</h1>
<h2>お気楽 Julia プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
<hr>
</div>
<section class="contents">
<h3>Julia の基礎知識</h3>
<h4 id="abc15">●配列の操作</h4>
<ul>
  <li>基本的な操作
  <ul>
    <li>eltype(a), 要素の型を返す
    <li>ndims(a), 次元数を返す
    <li>size(a), 各次元の要素数をタプルに格納して返す
    <ul>
      <li>本稿ではこれを shape または形状と記す
    </ul>
    <li>size(a, n), n 次元の要素数を返す
    <li>copy(a), コピー
    <li>deepcopy(a), 要素が配列の場合はそれも再帰的にコピーする
    <li>Vector{T}(undef, n), 大きさ n のベクトル (未初期化) を生成する
    <ul>
      <li>Vector{T} はベクトル (1 次元配列) を表すデータ型 (Array{T, 1} の別名)
    </ul>
    <li>Matrix{T}(undef, m, n) は m 行 n 列の行列 (未初期化) を生成する
    <ul>
      <li>Matrix{T} は行列を表すデータ型 (Array{T, 2} の別名)
      <li>undef の代わりに I を指定すると単位行列を生成する
    </ul>
    <li>rand(T, n, ...), 一様乱数 [0, 1) を格納した配列を生成 (T を省略すると Float64)
    <li>randn(T, n, ...), 標準正規分布の乱数を格納した配列を生成 (T を省略すると Float64)
    <li>fill(x, n, ...), 要素が x の配列を生成する
    <li>fill!(a, x), 配列 a の要素を x で埋める
    <li>reshape(a, n, ...), shape を変更した新しい配列を生成する
    <ul>
      <li>要素数が合わないとエラー
    </ul>
  </ul>
</ul>
<pre>
julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; eltype(a)
Int64

julia&gt; ndims(a)
2

julia&gt; size(a)
(2, 3)

julia&gt; size(a, 1)
2

julia&gt; size(a, 2)
3

julia&gt; b = copy(a)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b[1, 1] = 10
10

julia&gt; a
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b
2×3 Array{Int64,2}:
 10  2  3
  4  5  6

julia&gt; Vector{Int}(undef, 5)
5-element Array{Int64,1}:
 265819264
 270532560
 270712896
 270712944
 270712992

julia&gt; Matrix{Int}(undef, 3, 4)
3×4 Array{Int64,2}:
 282460656  282460704  237834560  282462464
 282460672  237835904  237834624  282462288
 282460688  237834368  282462640          1

julia&gt; Matrix{Float64}(I, 4, 4)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0

julia&gt; rand(3, 3)
3×3 Array{Float64,2}:
 0.854536  0.226064   0.226187
 0.620246  0.0206767  0.457992
 0.809142  0.517317   0.273315

julia&gt; randn(3, 3)
3×3 Array{Float64,2}:
 -1.18743    0.443415   0.0171891
  0.0478356  0.648046   0.517229
 -0.328416   0.410499  -1.61842

julia&gt; fill(10, 2, 3)
2×3 Array{Int64,2}:
 10  10  10
 10  10  10

julia&gt; fill!(b, 100)
2×3 Array{Int64,2}:
 100  100  100
 100  100  100

julia&gt; b
2×3 Array{Int64,2}:
 100  100  100
 100  100  100

julia&gt; reshape(b, 3, 2)
3×2 Array{Int64,2}:
 100  100
 100  100
 100  100

julia&gt; reshape(b, 1, 6)
1×6 Array{Int64,2}:
 100  100  100  100  100  100

julia&gt; reshape(b, 6, 1)
6×1 Array{Int64,2}:
 100
 100
 100
 100
 100
 100

julia&gt; reshape(collect(1:16), 4, 4)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16
</pre>
<ul>
  <li>配列の Indexing
  <ul>
    <li>Julia の場合、多次元配列でも 1 次元配列のように一つの添字でアクセスできる
    <li>たとえば、大きさ (n, m) の 2 次元配列の要素 [i, j] は [n * (j - 1) + i] でもOK
    <li>a = [1 2 3; 4 5 6] であれば、a[1] = 1, a[2] = 4, a[3] = 2, a[4] = 5, a[5] = 3, a[6] = 6 になる
    <li>stride(a, n) は n 次元の添字を 1 つ増やしたときの移動量を求める
    <li>strides(a) 各次元の移動量をタプルに格納して返す
    <li>eachindex(a) は 1 次元配列での添字を生成する

  </ul>
</ul>
<pre>
julia&gt; a = [11 12 13 14; 15 16 17 18; 19 20 21 22]
3×4 Array{Int64,2}:
 11  12  13  14
 15  16  17  18
 19  20  21  22

julia&gt; stride(a, 1)
1

julia&gt; stride(a, 2)
3

julia&gt; strides(a)
(1, 3)

julia&gt; a[1]
11

julia&gt; a[2]
15

julia&gt; a[3]
19

julia&gt; a[12]
22

julia&gt; a[11]
18

julia&gt; a[10]
14

julia&gt; for x = eachindex(a)
       print(x, " ")
       end
1 2 3 4 5 6 7 8 9 10 11 12
</pre>
<ul>
  <li>高度な Indexing (1)
  <ul>
    <li>Julia の配列は各次元の添字に範囲オブジェクトを指定できる
    <ul>
      <li>: は 1 : end の略記法
    </ul>
    <li>範囲オブジェクトの代わりに 1 次元配列 [idx1, idx2, ...] を使うこともできる
    <li>右辺式の場合は指定した要素を格納した新しい配列を生成する
    <li>左辺式の場合は右辺の配列を代入する (shape が合わない場合はエラー)
    <li>たとえば、shape が (5, 5) の配列 a で a[[1, 2], [3, 4, 5]] とする
    <li>最初に、[1, 2] で 1, 2 行目を取り出す
    <li>次に、[3, 4, 5] で 3, 4, 5 列目を取り出す
    <li>その結果、二次元配列 [a[1, 3] a[1, 4] a[1, 5]; a[2, 3] a[2, 4] a[2, 5]] が生成される
  </ul>
</ul>
<pre>
julia&gt; a = collect(1 : 8)
8-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
 7
 8

julia&gt; a[3 : 5]
3-element Array{Int64,1}:
 3
 4
 5

julia&gt; a[1 : 2 : end]
4-element Array{Int64,1}:
 1
 3
 5
 7

julia&gt; a[end : -1 : 1]
8-element Array{Int64,1}:
 8
 7
 6
 5
 4
 3
 2
 1

julia&gt; b = a[:]
8-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
 7
 8

julia&gt; b[1] = 10
10

julia&gt; b[2 : 4] = [11, 12, 13]
3-element Array{Int64,1}:
 11
 12
 13

julia&gt; b
8-element Array{Int64,1}:
 10
 11
 12
 13
  5
  6
  7
  8

julia&gt; a
8-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
 7
 8

julia&gt; b[[3, 2, 1]]
3-element Array{Int64,1}:
 12
 11
 10

julia&gt; c = reshape(collect(1 : 16), 4, 4)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; c[1 : 3, 2 : 4]
3×3 Array{Int64,2}:
 5   9  13
 6  10  14
 7  11  15

julia&gt; c[[1, 3], [3, 2, 1]]
2×3 Array{Int64,2}:
  9  5  1
 11  7  3

julia&gt; c[[1, 3], 4]
2-element Array{Int64,1}:
 13
 15

julia&gt; c[2, [1, 3]]
2-element Array{Int64,1}:
  2
 10

julia&gt; c[1 : 2, 1 : 2] = [100 200; 300 400]
2×2 Array{Int64,2}:
 100  200
 300  400

julia&gt; c
4×4 Array{Int64,2}:
 100  200   9  13
 300  400  10  14
   3    7  11  15
   4    8  12  16
</pre>
<ul>
  <li>高度な Indexing (2)
  <ul>
    <li>配列 a のアクセスに配列 x を使うこともできる
    <li>右辺が a[x] の場合、x と同じ shape の配列が生成される
    <li>このとき x の要素は配列 a を 1 次元配列としたときの添字を表す
    <li>左辺が a[x] の場合、x で指定した位置に右辺の配列の要素を代入する
    <li>この場合、shape が異なっていても、要素数が同じであれば大丈夫
    <li>真偽値の配列を添字に渡すと、true の要素だけを取り出すことができる
  </ul>
</ul>
<pre>
julia&gt; a = collect(11 : 18)
8-element Array{Int64,1}:
 11
 12
 13
 14
 15
 16
 17
 18

julia&gt; a[[1 3; 5 6]]
2×2 Array{Int64,2}:
 11  13
 15  16

julia&gt; a[[1 2; 3 4]] = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; a
8-element Array{Int64,1}:
  1
  2
  3
  4
 15
 16
 17
 18

julia&gt; a[[1 2; 3 4]] = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; a
8-element Array{Int64,1}:
  1
  3
  2
  4
 15
 16
 17
 18

julia&gt; b = reshape(collect(11:37), 3, 3, 3)
3×3×3 Array{Int64,3}:
[:, :, 1] =
 11  14  17
 12  15  18
 13  16  19

[:, :, 2] =
 20  23  26
 21  24  27
 22  25  28

[:, :, 3] =
 29  32  35
 30  33  36
 31  34  37

julia&gt; c = reshape(collect(1:8), 2, 2, 2)
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; b[c]
2×2×2 Array{Int64,3}:
[:, :, 1] =
 11  13
 12  14

[:, :, 2] =
 15  17
 16  18

julia&gt; b[[1 2; 3 4]]
2×2 Array{Int64,2}:
 11  12
 13  14

julia&gt; d = rand(3, 3)
3×3 Array{Float64,2}:
 0.5539    0.197074   0.891122
 0.576245  0.294106   0.331378
 0.897042  0.0410994  0.753897

julia&gt; d[[true, false, true], :]
2×3 Array{Float64,2}:
 0.5539    0.197074   0.891122
 0.897042  0.0410994  0.753897

julia&gt; d[[true false true; false true false; true false true]]
5-element Array{Float64,1}:
 0.5539000767798989
 0.8970422259778486
 0.29410576676576405
 0.8911224595713023
 0.7538967411374953
</pre>
<ul>
  <li>配列の連結
  <ul>
    <li>cat(a, ..., dims=k), 行列を k 次元方向で連結 (dims は NumPy の axis と同じ)
    <li>たとえば、shape が (x1, y1, z1) と (x2, y2, z2) の配列を連結する場合
    <ul>
      <li>dims = 1: (x1 + x2, y1, z1), 条件 y1 == y2 and z1 == z2
      <li>dims = 2: (x1, y1 + y2, z1), 条件 x1 == x2 and z1 == z2
      <li>dims = 3: (x1, y1, z1 + z2), 条件 x1 == x2 and y1 == y2
      <li>条件を満たさない場合はエラー
    </ul>
    <li>vcat(a, ...), cat(a, ..., dims=1) と同じ
    <li>hcat(a, ...), cat(a, ..., dims=2) と同じ
    <li>hvcat((n, ...), item, ...), タプルの要素数を m とすると m 行 n 列の行列を生成する
    <li>[item ...; ... ; item ...] と同じ
  </ul>
</ul>
<pre>
julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b = [11 12 13; 14 15 16]
2×3 Array{Int64,2}:
 11  12  13
 14  15  16

julia&gt; cat(a, b, dims=1)
4×3 Array{Int64,2}:
  1   2   3
  4   5   6
 11  12  13
 14  15  16

julia&gt; cat(a, b, dims=2)
2×6 Array{Int64,2}:
 1  2  3  11  12  13
 4  5  6  14  15  16

julia&gt; vcat(a, b)
4×3 Array{Int64,2}:
  1   2   3
  4   5   6
 11  12  13
 14  15  16

julia&gt; hcat(a, b)
2×6 Array{Int64,2}:
 1  2  3  11  12  13
 4  5  6  14  15  16

julia&gt; hvcat((2, 2), 1, 2, 3, 4)
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; hvcat((2, 2, 2), 1, 2, 3, 4, 5, 6)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia&gt; hvcat((3, 3), 1, 2, 3, 4, 5, 6)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; c = reshape(1:8, 2,2,2)
2×2×2 reshape(::UnitRange{Int64}, 2, 2, 2) with eltype Int64:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; d = reshape(11:18, 2,2,2)
2×2×2 reshape(::UnitRange{Int64}, 2, 2, 2) with eltype Int64:
[:, :, 1] =
 11  13
 12  14

[:, :, 2] =
 15  17
 16  18

julia&gt; cat(c, d, dims=1)
4×2×2 Array{Int64,3}:
[:, :, 1] =
  1   3
  2   4
 11  13
 12  14

[:, :, 2] =
  5   7
  6   8
 15  17
 16  18

julia&gt; cat(c, d, dims=2)
2×4×2 Array{Int64,3}:
[:, :, 1] =
 1  3  11  13
 2  4  12  14

[:, :, 2] =
 5  7  15  17
 6  8  16  18
julia&gt; cat(c, d, dims=3)
2×2×4 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

[:, :, 3] =
 11  13
 12  14

[:, :, 4] =
 15  17
 16  18
</pre>

<h4 id="abc15a">●ビュー (View)</h4>
<ul>
  <li>関数 view() またはマクロ @view は配列の「ビュー (View)」を生成する
<pre class="item">
view(A, indexing...)
@view A[indexing...]
</pre>
  <li>ビューは配列の参照みたいなもの
  <li>指定した indexing で配列 A の要素にアクセスできる
  <li>要素の書き換えも可能
  <li>参照先の配列は関数 parent() で取得できる
  <li>ビューを生成したときの indexing は関数 parentindices() で求めることができる
</ul>
<pre>
julia&gt; a = reshape(collect(1 : 16), 4, 4)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; b = view(a, :, 1)
4-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 2
 3
 4

julia&gt; b[1]
1

julia&gt; b[4]
4

julia&gt; b[4] *= 10
40

julia&gt; b
4-element view(::Array{Int64,2}, :, 1) with eltype Int64:
  1
  2
  3
 40

julia&gt; a
4×4 Array{Int64,2}:
  1  5   9  13
  2  6  10  14
  3  7  11  15
 40  8  12  16

julia&gt; c = @view a[4, :]
4-element view(::Array{Int64,2}, 4, :) with eltype Int64:
 40
  8
 12
 16

julia&gt; fill!(c, 0)
4-element view(::Array{Int64,2}, 4, :) with eltype Int64:
 0
 0
 0
 0

julia&gt; a
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 0  0   0   0

julia&gt; d = @view a[3:end, 3:end]
2×2 view(::Array{Int64,2}, 3:4, 3:4) with eltype Int64:
 11  15
  0   0

julia&gt; d[:,:] = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; a
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7   1   2
 0  0   3   4

julia&gt; parent(b)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7   1   2
 0  0   3   4

julia&gt; parentindices(b)
(Base.Slice(Base.OneTo(4)), 1)

julia&gt; @view a[parentindices(b)...]
4-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 2
 3
 0

julia&gt; parent(c)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7   1   2
 0  0   3   4

julia&gt; parentindices(c)
(4, Base.Slice(Base.OneTo(4)))

julia&gt; @view a[parentindices(c)...]
4-element view(::Array{Int64,2}, 4, :) with eltype Int64:
 0
 0
 3
 4

julia&gt; parent(d)
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7   1   2
 0  0   3   4

julia&gt; parentindices(d)
(3:4, 3:4)

julia&gt; @view a[parentindices(d)...]
2×2 view(::Array{Int64,2}, 3:4, 3:4) with eltype Int64:
 1  2
 3  4
</pre>
<h4 id="abc16">●配列の演算</h4>
<ul>
  <li>Julia の演算子は前にドット (.) を付けると、配列の要素に演算子を適用し、その結果を格納した新しい配列を返す
  <li>同様に、関数名の後ろにドット (.) を付けると、配列の要素に関数を適用することができる
  <li>配列とスカラー (数値) の演算も可能
  <li>詳細はマニュアル <a href="https://docs.julialang.org/en/v1/base/arrays/#Broadcast-and-vectorization-1">Broadcast and vectorization</a> と <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized-1">Dot Syntax for Vectorizing Functions</a> を参照
</ul>
<pre>
julia&gt; a = rand(3, 3)
3×3 Array{Float64,2}:
 0.796954  0.437371  0.00558222
 0.411225  0.953132  0.825275
 0.319387  0.970779  0.35722

julia&gt; b = rand(3, 3)
3×3 Array{Float64,2}:
 0.781649  0.376261  0.844858
 0.619159  0.924501  0.24216
 0.147665  0.549768  0.856393

julia&gt; a .+ b
3×3 Array{Float64,2}:
 1.5786    0.813632  0.85044
 1.03038   1.87763   1.06743
 0.467052  1.52055   1.21361

julia&gt; a .- b
3×3 Array{Float64,2}:
  0.0153058  0.0611106  -0.839275
 -0.207934   0.028631    0.583115
  0.171721   0.421011   -0.499172

julia&gt; a .* b
3×3 Array{Float64,2}:
 0.622938   0.164565  0.00471618
 0.254614   0.881172  0.199849
 0.0471623  0.533703  0.305921

julia&gt; a ./ b
3×3 Array{Float64,2}:
 1.01958   1.16242  0.00660729
 0.664168  1.03097  3.40797
 2.16291   1.7658   0.417122

julia&gt; a .+ 10
3×3 Array{Float64,2}:
 10.797   10.4374  10.0056
 10.4112  10.9531  10.8253
 10.3194  10.9708  10.3572

julia&gt; a .* 10
3×3 Array{Float64,2}:
 7.96954  4.37371  0.0558222
 4.11225  9.53132  8.25275
 3.19387  9.70779  3.5722

julia&gt; a .- 10
3×3 Array{Float64,2}:
 -9.20305  -9.56263  -9.99442
 -9.58877  -9.04687  -9.17473
 -9.68061  -9.02922  -9.64278

julia&gt; a ./ 10
3×3 Array{Float64,2}:
 0.0796954  0.0437371  0.000558222
 0.0411225  0.0953132  0.0825275
 0.0319387  0.0970779  0.035722

julia&gt; sin.(a)
3×3 Array{Float64,2}:
 0.715231  0.42356   0.00558219
 0.399733  0.815234  0.734734
 0.313984  0.825326  0.349671

julia&gt; square(x) = x * x
square (generic function with 1 method)

julia&gt; square.(a)
3×3 Array{Float64,2}:
 0.635136  0.191294  3.11612e-5
 0.169106  0.908461  0.681078
 0.102008  0.942412  0.127606

julia&gt; a .^ 2
3×3 Array{Float64,2}:
 0.635136  0.191294  3.11612e-5
 0.169106  0.908461  0.681078
 0.102008  0.942412  0.127606
</pre>
<ul>


</ul>
<h4 id="abc17">●基本的な線形代数</h4>
<ul>
  <li>Julia には線形代数のための関数がモジュール LinearAlgebra に用意されている
  <li>ここでは基本的な関数の使い方を簡単に説明する
  <li>詳細はマニュアル <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">Linear Algebra</a> を参照
  <li>行列の積は *, 累乗は ^, 逆行列 A<sup>-1</sup> は inv(A) を使う
  <li>A \ B は A * X == B となる X を求める
  <ul>
    <li>X は inv(A) * B でも求まるが、\ は LU 分解を使って計算する
    <li>A が特別な行列を表すデータ型 (たとえば三角行列など) であれば、もっと高速に計算できる
    <li>もちろん、LU 分解や QR 分解を行う関数も用意されている
  </ul>
  <li>行列 A の転置行列は A' または transpose(A)
</ul>
<pre>
julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = [5 6; 7 8]
2×2 Array{Int64,2}:
 5  6
 7  8

julia&gt; c = a * b
2×2 Array{Int64,2}:
 19  22
 43  50

julia&gt; inv(a)
2×2 Array{Float64,2}:
 -2.0   1.0
  1.5  -0.5

julia&gt; a * inv(a)
2×2 Array{Float64,2}:
 1.0          0.0
 8.88178e-16  1.0

julia&gt; inv(a) * a
2×2 Array{Float64,2}:
 1.0          0.0
 2.22045e-16  1.0

julia&gt; inv(a) * c
2×2 Array{Float64,2}:
 5.0  6.0
 7.0  8.0

julia&gt; a \ c
2×2 Array{Float64,2}:
 5.0  6.0
 7.0  8.0

julia&gt; [1 1; 1 0] ^ 2
2×2 Array{Int64,2}:
 2  1
 1  1

julia&gt; [1 1; 1 0] ^ 3
2×2 Array{Int64,2}:
 3  2
 2  1

julia&gt; [1 1; 1 0] ^ 4
2×2 Array{Int64,2}:
 5  3
 3  2

julia&gt; [1 1; 1 0] ^ 10
2×2 Array{Int64,2}:
 89  55
 55  34

julia&gt; [1 1; 1 0] ^ 40
2×2 Array{Int64,2}:
 165580141  102334155
 102334155   63245986

julia&gt; a'
2×2 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:
 1  3
 2  4

julia&gt; transpose(a)
2×2 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:
 1  3
 2  4

julia&gt; [1 2 3; 4 5 6; 7 8 9]'
3×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; transpose([1 2 3; 4 5 6; 7 8 9])
3×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:
 1  4  7
 2  5  8
 3  6  9
</pre>
<ul>
  <li>鶴亀算</li>
  <ol>
    <li>鶴と亀、合わせて 100 匹いる。足の合計が 272 本のとき、鶴と亀はそれぞれ何匹ずついるか</li>
    <li>鶴と亀とトンボが合わせて 10 匹いる。足の合計が 38 本で羽の合計が 14 枚であるとき、鶴と亀とトンボはそれぞれ何匹ずついるか。(トンボの足は 6 本で羽は 4 枚)</li>
  </ol>
  <ul>
    <li>問題 1 は次の連立方程式を解けば求めることができる</li>
<pre class="item">
x + y = 100
2x + 4y = 272
</pre>
<pre>
julia&gt; [1 1; 2 4] \ [100, 272]
2-element Array{Float64,1}:
 64.0
 36.0
</pre>
    <li>問題 2 は次の連立方程式を解けば求めることができる</li>
<pre class="item">
 x +  y +  z = 10
2x + 4y + 6z = 38
2x +      4z = 14
</pre>
<pre>
julia&gt; [1 1 1; 2 4 6; 2 0 4] \ [10, 38, 14]
3-element Array{Float64,1}:
 3.0
 5.0
 2.0
</pre>
  </ul>
</ul>
<ul>
  <li>以下の関数を使用するときは using LinearAlgebra が必要
  <li>行列 A の行列式 (determinant) は det(A)
  <li>行列 A のトレース (trace, 跡) は tr(A)
  <ul>
    <li>トレースは行列の対角線上にある要素の和のこと (a11 + a12 + ... + ann)
  </ul>
  <li>行列 A のランク (rank) は rank(A)
  <li>行列 A の対角線上の要素は diag(A, k = 0) で取得できる
  <ul>
    <li>k = 0 は主対角線を取り出す
    <li>K &gt; 0 は上側の、k &lt; 0 は下側の副対角線を取り出す
  </ul>
  <li>ベクトル (1 次元配列) v から対角行列を生成するには diagm(k =&gt; v) を使う
  <ul>
    <li>k は diag() と同じ意味
    <li>k =&gt; v は複数指定できる
  </ul>
  <li>ベクトル v のノルム |v| は norm(v)
  <li>ベクトル v, w の内積は dot(v, w)
</ul>
<pre>
julia&gt; a = [1 2 3; 4 5 6; 7 8 10]
3×3 Array{Int64,2}:
 1  2   3
 4  5   6
 7  8  10

julia&gt; transpose(a)
3×3 Transpose{Int64,Array{Int64,2}}:
 1  4   7
 2  5   8
 3  6  10

julia&gt; det(a)
-3.0

julia&gt; tr(a)
16

julia&gt; rank(a)
3

julia&gt; diag(a)
3-element Array{Int64,1}:
  1
  5
 10

julia&gt; diag(a, 1)
2-element Array{Int64,1}:
 2
 6

julia&gt; diag(a, 2)
1-element Array{Int64,1}:
 3

julia&gt; diag(a, -1)
2-element Array{Int64,1}:
 4
 8

julia&gt; diag(a, -2)
1-element Array{Int64,1}:
 7

julia&gt; diagm(0 =&gt; [1, 2, 3])
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  3

julia&gt; diagm(1 =&gt; [1, 2, 3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(-1 =&gt; [1, 2, 3])
4×4 Array{Int64,2}:
 0  0  0  0
 1  0  0  0
 0  2  0  0
 0  0  3  0

julia&gt; diagm(0 =&gt; [1, 1, 1, 1], -1 =&gt; [1, 2, 3])
4×4 Array{Int64,2}:
 1  0  0  0
 1  1  0  0
 0  2  1  0
 0  0  3  1

julia&gt; norm([1, 1])
1.4142135623730951

julia&gt; norm([1, 1, 1])
1.7320508075688772

julia&gt; dot([1, 2], [3, 4])
11

julia&gt; dot([1, 2, 3], [4, 5, 6])
32
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap">簡単なプログラム</h3>
<h4 id="chap21">●ソート</h4>
<pre class="list">
#
# sort.jl : ファイルのソート
#
#           Copyright 2016-2018 Makoto Hiroi
#

# 単純挿入ソート
function insert_sort!(buff::Vector{T}) where {T}
    for i = 2 : length(buff)
        temp = buff[i]
        j = i - 1
        while j &gt; 0 && temp &lt; buff[j]
            buff[j + 1] = buff[j]
            j -= 1
        end
        buff[j + 1] = temp
    end
end

# 中央値を返す
function median3(a, b, c)
    if a &gt; b
        if b &gt; c
            b
        elseif a &lt; c
            a
        else
            c
        end
    else
        if b &lt; c
            b
        elseif a &lt; c
            c
        else
            a
        end
    end
end

# 9 つの中から中央値を選ぶ
function median9(buff, low, high)
    m2 = div(high - low, 2)
    m4 = div(m2, 2)
    m8 = div(m4, 2)
    a = buff[low]
    b = buff[low + m8]
    c = buff[low + m4]
    d = buff[low + m2 - m8]
    e = buff[low + m2]
    f = buff[low + m2 + m8]
    g = buff[high - m4]
    h = buff[high - m8]
    i = buff[high]
    median3(median3(a,b,c), median3(d,e,f), median3(g,h,i))
end

# クイックソート
function quick_sort!(buff::Vector{T}) where {T}
    function qsort(low::Int, high::Int)
        if high - low &lt; 16
            return
        end
        pivot = median9(buff, low, high)
        i = low
        j = high
        while true
            while pivot &gt; buff[i]; i += 1; end
            while pivot &lt; buff[j]; j -= 1; end
            if i &gt;= j; break; end
            buff[i], buff[j] = buff[j], buff[i]
            i += 1
            j -= 1
        end
        qsort(low, i - 1)
        qsort(j + 1, high)
    end
    #
    qsort(1, length(buff))
    insert_sort!(buff)
end

# ファイルのソート
function sort(fin)
    buff = readlines(fin)
    quick_sort!(buff)
    for x = buff
        println(x)
    end
end

if length(ARGS) == 0
    sort(stdin)
elseif length(ARGS) == 1
    open(ARGS[1], "r") do fin
        sort(fin)
    end
else
    println("usage: julia sort.jl [filename]")
end
</pre>
<ul>
  <li>単純挿入ソートとクイックソートのアルゴリズムは <a href="index.html#python_algo">Alogrithms with Python</a> <a href="pyalgo06.html">整列 (sorting) [1]</a> で説明している
  <li>9 つの中から中央値を選択する方法を median-of-9 という (<a href="../memo13.html#130518">Memorudom 2013 年 5 月 13 日</a> で説明)
</ul>
<h4 id="chap22">●フィボナッチ数</h4>
<p> フィボナッチ数 F<sub>n</sub> の漸化式を行列で表すと次のようになります。
</p>
<pre class="item">
F<sub>0</sub> = 0
F<sub>1</sub> = 1
[F<sub>n</sub> F<sub>n-1</sub>] = [1 1; 1 0] * [F<sub>n-1</sub> F<sub>n-2</sub>]
</pre>
<p> したがって、F<sub>n</sub> を求める問題は行列 [1 1; 1 0] の n 乗を求める問題に帰着します。x<sup>n</sup> は log<sub>2</sub> n 程度の手間で求めることが可能です。F<sub>n</sub> を繰り返しで求めると n に比例する時間がかかるので、n が大きくなると行列を使ったほうが速くなると思われます。
</p>
<pre class="list">
リスト : フィボナッチ数

function fibo(n)
    if n == 0
        0
    elseif n == 1
        1
    else
        f = ([1 1; 1 0] ^ (n - 1)) * [1, 0]
        f[1]
    end
end

for x = 0 : 40
    print("$(fibo(x)) ")
end
</pre>
<pre>
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 
28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 
5702887 9227465 14930352 24157817 39088169 63245986 102334155
</pre>
<p> フィボナッチ数列の最初の 2 項を 2, 1 に置き換えた数列の項を「リュカ数 (Lucas number)」といいます。
</p>
<pre class="list">
リスト : リュカ数

function lucas(n)
    if n == 0
        2
    elseif n == 1
        1
    else
        f = ([1 1; 1 0] ^ (n - 1)) * [1, 2]
        f[1]
    end
end

for x = 0 : 40
    print("$(lucas(x)) ")
end
</pre>
<pre>
2 1 3 4 7 11 18 29 47 76 123 199 322 521 843 1364 2207 3571 5778 9349 15127 24476 
39603 64079 103682 167761 271443 439204 710647 1149851 1860498 3010349 4870847 
7881196 12752043 20633239 33385282 54018521 87403803 141422324 228826127
</pre>
<p> 次の漸化式で生成される数列をトリボナッチ数列といいます。
</p>
<pre class="item">
T<sub>0</sub> = T<sub>1</sub> = 0, T<sub>2</sub> = 1
T<sub>n+3</sub> = T<sub>n+2</sub> + T<sub>n+1</sub> + T<sub>n</sub>
</pre>
<pre class="list">
リスト : トリボナッチ数

function tribo(n)
    if n == 0 || n == 1
        0
    elseif n == 2
        1
    else
        t = ([1 1 1; 1 0 0; 0 1 0] ^ (n - 2)) * [1, 0, 0]
        t[1]
    end
end

for x = 0 : 30
    print("$(tribo(x)) ")
end
</pre>
<pre>
0 0 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 5768 10609 19513 35890 66012
 121415 223317 410744 755476 1389537 2555757 4700770 8646064 15902591
</pre>
<p> 次の漸化式で生成される数列をテトラナッチ数列といいます。
</p>
<pre class="item">
T<sub>0</sub> = T<sub>1</sub> = T<sub>2</sub> = 0, T<sub>3</sub> = 1
T<sub>n+4</sub> = T<sub>n+3</sub> + T<sub>n+2</sub> + T<sub>n+1</sub> + T<sub>n</sub>
</pre>
<pre class="list">
リスト : テトラナッチ数列

function tetra(n)
    if n == 0 || n == 1 || n == 2
        0
    elseif n == 3
        1
    else
        t = ([1 1 1 1; 1 0 0 0 ; 0 1 0 0; 0 0 1 0] ^ (n - 3)) * [1, 0, 0, 0]
        t[1]
    end
end

for x = 0 : 30
    print("$(tetra(x)) ")
end
</pre>
<pre>
0 0 0 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 10671 20569 39648 76424
147312 283953 547337 1055026 2033628 3919944 7555935 14564533 28074040
</pre>
<h4 id="chap23">●連結リスト (mutable)</h4>
<ul>
  <li>このプログラムは Lisp / Scheme にあわせて連結リスト (linked list) の添字を 0 から始める
  <li>連結リストの説明は拙作のページ Algorithms with Python <a href="pyalgo02.html">連結リストとキュー</a> を参照
  <li>操作関数
  <ul>
    <li>LinkedList(), 空の連結リストを生成
    <li>nth(xs, n), 連結リスト xs の n 番目の要素を求める
    <li>insert!(xs, n, x), xs の n 番目に x を挿入する
    <li>delete!(xs, n), xs の n 番目の要素を削除する
    <li>length(xs), xs の長さを求める
    <li>isempty(xs), xs が空リストならば true を返す
    <li>foreach(func, xs), xs の要素に関数 func を適用する
    <li>イテレータも実装する
  </ul>
</ul>
<pre class="list">
#
# list.jl : mutable な連結リスト
#
#           Copyright (C) 2016-2018 Makoto Hiroi
#

# 抽象型
abstract type List end

# セル
mutable struct Cell &lt;: List
    item
    next :: List
end

# 終端 
# メンバ変数の無い immutable なデータ型を生成すると
# シングルトンオブジェクトを返す
struct Nil &lt;: List
end

nil = Nil()

# アクセス関数
car(xs::Cell) = xs.item
cdr(xs::Cell) = xs.next
set_car!(xs::Cell, x) = xs.item = x
set_cdr!(xs::Cell, cp::List) = xs.next = cp
null(xs::List) = xs == nil

# 連結リスト
struct LinkedList
    top :: List
    LinkedList() = new(Cell(nil, nil))
end

# 作業用
function nth_cell(xs::List, n::Int)
    i = -1
    while !null(xs)
        if i == n; break; end
        i += 1
        xs = cdr(xs)
    end
    xs
end

# 参照
function nth(xs::LinkedList, n::Int)
    cp = nth_cell(xs.top, n)
    if null(cp) 
        error("nth: out of range")
    else
        car(cp)
    end
end

# 更新
function set!(xs::LinkedList, n::Int, x)
    cp = nth_cell(xs.top, n)
    if null(cp)
        error("set!: out of range")
    else
        set_car!(cp, x)
    end
end

# 挿入
function Base.insert!(xs::LinkedList, n::Int, x)
    cp = nth_cell(xs.top, n - 1)
    if null(cp)
        error("insert!: out of range")
    else
        set_cdr!(cp, Cell(x, cdr(cp)))
    end
end

# 削除
function Base.delete!(xs::LinkedList, n::Int)
    cp = nth_cell(xs.top, n - 1)
    if null(cp) || null(cdr(cp))
        error("delete!: out of range")
    else
        set_cdr!(cp, cdr(cdr(cp)))
    end
end

# 長さ
function Base.length(xs::LinkedList)
    n = 0
    cp = cdr(xs.top)
    while !null(cp)
        n += 1
        cp = cdr(cp)
    end
    n
end

# 空リストか？
function Base.isempty(xs::LinkedList)
    null(cdr(xs.top))
end

# 巡回
function Base.foreach(func::Function, xs::LinkedList)
    cp = cdr(xs.top)
    while !null(cp)
        func(car(cp))
        cp = cdr(cp)
    end
end

# イテレータ
function Base.iterate(xs::LinkedList, state = cdr(xs.top))
    if null(state)
        nothing
    else
       (car(state), cdr(state))
    end
end

# 表示
function Base.show(io::IO, xs::LinkedList)
    print(io, "(")
    cp = cdr(xs.top)
    while !null(cp)
        print(car(cp))
        cp = cdr(cp)
        if !null(cp); print(" "); end
    end
    print(")")
end

#
# 簡単なテスト
#
xs = LinkedList()
println(isempty(xs))
for x = 1 : 10
    insert!(xs, 0, x)
end
println(xs)
println(isempty(xs))
ys = LinkedList()
for x = 0 : 9
    insert!(ys, x, x)
end
foreach(x -&gt; print("$x "), ys)
println("")
for x = 0 : 9
    set!(xs, x, nth(xs, x) * 2)
end
println(xs)
println(length(xs))
delete!(xs, 0)
println(xs)
println(length(xs))
delete!(xs, 8)
println(xs)
println(length(xs))
delete!(xs, 3)
println(xs)
println(length(xs))
while !isempty(xs)
    delete!(xs, 0)
    println(xs)
    println(length(xs))
end
println(isempty(xs))

# イテレータ
for x = ys
    print("$x ")
end
println("")
</pre>
<ul>
  <li>show(io::IO, v::データ型) を多重定義すると、REPL, print(), println() などで v の値を表示できる
  <li>メンバ変数の無い struct の場合、生成される値はシングルトンオブジェクトになる
</ul>
<pre>
C&gt;julia mlist.jl
true
(10 9 8 7 6 5 4 3 2 1)
false
0 1 2 3 4 5 6 7 8 9
(20 18 16 14 12 10 8 6 4 2)
10
(18 16 14 12 10 8 6 4 2)
9
(18 16 14 12 10 8 6 4)
8
(18 16 14 10 8 6 4)
7
(16 14 10 8 6 4)
6
(14 10 8 6 4)
5
(10 8 6 4)
4
(8 6 4)
3
(6 4)
2
(4)
1
()
0
true
0 1 2 3 4 5 6 7 8 9
</pre>
<h4 id="chap24">●双方向リスト</h4>
<ul>
  <li>双方向リストの詳しい説明は Algorithms with Python <a href="pyalgo02.html">連結リストとキュー</a> を参照
  <li>双方向リストは直接使わずに、スタック、キュー、ディーキューとして使用する
  <li>スタック
  <ul>
    <li>Stack(), スタックの生成
    <li>push!(xs, args...), スタック xs に要素を追加
    <li>pop!(xs), xs から要素を取り出す
    <li>first(xs), xs の先頭要素を参照する
    <li>length(xs), xs の要素数を求める
    <li>isempty(xs), xs が空ならば true を返す
  </ul>
  <li>キュー
  <ul>
    <li>Queue(), キューの生成
    <li>push!(xs, args...), キュー xs に要素を追加
    <li>pop!(xs), xs から要素を取り出す
    <li>first(xs), xs の先頭要素を参照する
    <li>length(xs), xs の要素数を求める
    <li>isempty(xs), xs が空ならば true を返す
  </ul>
  <li>ディーキュー
  <ul>
    <li>Deque(), ディーキューの生成
    <li>push!(xs, args...), ディーキュー xs の末尾に要素を追加
    <li>pop!(xs), xs の末尾から要素を取り出す
    <li>pushfirst!(xs, args...), xs の先頭に要素を追加
    <li>popfirst!(xs), xs の先頭から要素を取り出す
    <li>first(xs), xs の先頭要素を参照する
    <li>last(xs), xs の末尾要素を参照する
    <li>length(xs), xs の要素数を求める
    <li>isempty(xs), xs が空ならば true を返す
  </ul>
</ul>
<pre class="list">
#
# dlist.jl : 双方向リスト (mutable)
#
#            Copyright (C) 2016-2018 Makoto Hiroi
#
import Base: first, last, push!, pop!, pushfirst!, popfirst!, isempty, length, show

# 双方向リスト (セル)
mutable struct Cell
    item
    prev::Cell
    next::Cell
    Cell(a) = (x = new(a); x.next = x; x.prev = x)
end

# 表示
function show(io::IO, head::Cell)
    xs = head.next
    print(io, "(")
    while xs !== head
        print(io, xs.item)
        xs = xs.next
        if xs !== head; print(io, " "); end
    end
    print(io, ")")
end

# 空か？
isempty(xs::Cell) = xs.next === xs

# 長さ
function length(head::Cell)
    c = 0
    xs = head.next
    while xs !== head
        c += 1
        xs = xs.next
    end
    c
end

# 参照
function first(head::Cell)
    if isempty(head)
        error("front: Empty DList")
    end
    head.next.item
end

function last(head::Cell)
    if isempty(head)
        error("back: Empty DList")
    end
    head.prev.item
end

# 先頭に挿入
function pushfirst!(xs::Cell, args...)
    for x = args
        ys = Cell(x)
        zs = xs.next
        ys.prev = xs
        ys.next = zs
        zs.prev = ys
        xs.next = ys
    end
    xs
end

# 先頭要素を取り出す
function popfirst!(xs::Cell)
    if isempty(xs)
        error("shift!: Empty DList")
    end
    ys = xs.next
    zs = ys.next
    xs.next = zs
    zs.prev = xs
    ys.item
end

# 末尾に挿入
function push!(xs::Cell, args...)
    for x = args
        ys = Cell(x)
        zs = xs.prev
        ys.next = xs
        ys.prev = zs
        xs.prev = ys
        zs.next = ys
    end
    xs
end

# 末尾要素を取り出す
function pop!(xs::Cell)
    if isempty(xs)
        error("shift!: Empty DList")
    end
    ys = xs.prev
    zs = ys.prev
    xs.prev = zs
    zs.next = xs
    ys.item
end

# スタック
mutable struct Stack
    top::Cell
    Stack() = new(Cell(nothing))
end

isempty(xs::Stack) = isempty(xs.top)
length(xs::Stack) = length(xs.top)
show(io::IO, xs::Stack) = show(io, xs.top)
first(xs::Stack) = last(xs.top)
push!(xs::Stack, args...) = push!(xs.top, args...)
pop!(xs::Stack) = pop!(xs.top)

# キュー
mutable struct Queue
    head::Cell
    Queue() = new(Cell(nothing))
end

isempty(xs::Queue) = isempty(xs.head)
length(xs::Queue) = length(xs.head)
show(io::IO, xs::Queue) = show(io, xs.head)
first(xs::Queue) = first(xs.head)
push!(xs::Queue, args...) = push!(xs.head, args...)
pop!(xs::Queue) = popfirst!(xs.head)

# ディーキュー
mutable struct Deque
    head::Cell
    Deque() = new(Cell(nothing))
end

isempty(xs::Deque) = isempty(xs.head)
length(xs::Deque) = length(xs.head)
show(io::IO, xs::Deque) = show(io, xs.head)
first(xs::Deque) = first(xs.head)
last(xs::Deque) = last(xs.head)
push!(xs::Deque, args...) = push!(xs.head, args...)
pop!(xs::Deque) = pop!(xs.head)
popfirst!(xs::Deque) = popfirst!(xs.head)
pushfirst!(xs::Deque, args...) = pushfirst!(xs.head, args...)
</pre>
<pre>
julia&gt; include("dlist.jl")
pushfirst! (generic function with 7 methods)

julia&gt; a = Stack()
()

julia&gt; push!(a, 1, 2, 3, 4, 5)
(1 2 3 4 5)

julia&gt; first(a)
5

julia&gt; length(a)
5

julia&gt; while !isempty(a); println(pop!(a)); end
5
4
3
2
1

julia&gt; b = Queue()
()

julia&gt; push!(b, 1, 2, 3, 4, 5)
(1 2 3 4 5)

julia&gt; first(b)
1

julia&gt; length(b)
5

julia&gt; while !isempty(b); println(pop!(b)); end
1
2
3
4
5

julia&gt; c = Deque()
()

julia&gt; push!(c, 1, 2, 3, 4, 5)
(1 2 3 4 5)

julia&gt; first(c)
1

julia&gt; last(c)
5

julia&gt; pushfirst!(c, 1, 2, 3, 4, 5)
(5 4 3 2 1 1 2 3 4 5)

julia&gt; pop!(c)
5

julia&gt; c
(5 4 3 2 1 1 2 3 4)

julia&gt; popfirst!(c)
5

julia&gt; c
(4 3 2 1 1 2 3 4)
</pre>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016-2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>