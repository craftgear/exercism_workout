<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / ネガマックス法とネガスカウト法</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881794</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>ネガマックス法とネガスカウト法</h2>
<div class="small">
[ <a href="pyalgo24.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo26.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> ミニマックス法の続きです。今回はミニマックス法 (アルファベータ法) の改良方法について取り上げます。題材とするゲームは前回と同じく「カラー (Kalah) 」です。
</p>
<h4>●ネガマックス法</h4>
<p> ミニマックス法の場合、先手は最も大きな評価値の手を選び、後手は最も小さな評価値の手を選びます。ここで後手番のときに評価値の符号を反転すると、先手と同様に後手でも最大な評価値の手を選べばよいことになります。つまり、手番を変えて思考ルーチンを呼び出すときは、その返り値 (評価値) にマイナス符号をつけて符号を反転させるわけです。この方法を「ネガマックス法 (nega-max method) 」といいます。
</p>
<p> ネガマックス法は、先手番でも後手番でも評価値が最大となる指し手を選ぶようになるため、プログラムはミニマックス法よりも簡単になります。なお、ネガマックス法の動作はミニマックス法とまったく同じです。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : ネガマックス法

def negamax(turn, depth, board):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
    return value, move
</pre>
<p> 前回のミニマックス法は関数 move_first と move_second の相互再帰になりましたが、ネガマックス法は関数 negamax の再帰呼び出しだけでプログラムすることができます。引数 turn は手番を表します。関数 value_func で評価値を求めたあと、手番が後手 (SECOND_KALAH) であれば、評価値 v を -v にして符号を反転します。この処理は関数 value_func に turn を渡して、その中で行ってもかまいません。その場合はモジュール board.py を修正してください。
</p>
<p> 石を動かしたあと、その結果 result が KALAH であれば、手番をそのままにして negamax を再帰呼び出しします。このとき、評価値の符号を反転する必要はありません。手番を変える場合、次の turn は (turn + 7) % 14 で求めることができます。そして、negamax を再帰呼び出しして、返り値 (評価値) v を -v にして符号を反転します。
</p>
<p> 次がネガマックス法の心臓部である指し手の選択処理です。これはとても簡単で、v が value よりも大きいときに、その指し手を選ぶだけです。このようにプログラムを簡単に記述できるのがネガマックス法の長所です。
</p>

<p> 実行結果 (勝敗と局面の評価回数) は当然ですがミニマックス法とまったく同じになります。興味のある方は実際に試してみてください。
</p>
<ul>
  <li><a href="pyalgo25.html#list1">プログラムリスト１</a>
</ul>
<h4>●ネガアルファ法</h4>
<p> 次はネガマックス法に対応したアルファベータ法のプログラムを説明します。これを「ネガアルファ法 (nega-α method) 」と呼びます。次のリストを見てください。
</p>
<pre class="list">
リスト : ネガアルファ法

def negamax(turn, depth, board, limit):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b, limit)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b, -value)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= limit: break
    return value, move
</pre>
<p> 引数 limit が基準値になります。ネガアルファ法の場合、手番を変えるときは基準値の符号を反転して渡すことに注意してください。前回のアルファベータ法の場合、基準値として value を渡しましたが、ネガアルファ法の場合は -value を渡します。そうすると、ネガアルファ法による枝刈りの条件は value &gt;= limit で表すことができます。このように、ネガアルファ法のプログラムもとても簡単になります。
</p>

<p> 実行結果 (勝敗と局面の評価回数) は当然ですがアルファベータ法とまったく同じになります。興味のある方は実際に試してみてください。
</p>
<ul>
  <li><a href="pyalgo25.html#list2">プログラムリスト２</a>
</ul>
<h4>●ネガアルファ法の改良</h4>
<p> ところで、今までのアルファベータ法のプログラムでは、次の局面の基準値となる変数 value の値を MIN_VALUE または MAX_VALUE で初期化しているため、最初に探索する局面 (最も左側の枝の局面) の評価値を求めないと、アルファベータ法による枝刈りは発生しません。α値とβ値を (α, β) で表すと、新しい局面は (-∞, β) または (α, ∞) の幅で局面を探索することになります。たとえば、左側の枝から順番に探索していく場合、最も左側の枝の評価値 value が求まると、それ以降の枝は (value, β) または (α, value) の幅で局面を探索します。
</p>

<p> これに対し、一つ前の局面で求まったα値とβ値を使っても、アルファベータ法を動作させることができます。つまり、新しい局面でも (α, β) の幅でゲーム木を探索してもいいのです。(-∞, β) または (α, ∞) で探索を始めるよりも (α, β) の方が幅が狭くなるので、枝刈り (αカット、βカット) の回数が多くなることが期待できます。
</p>
<p> これで正しく動作することを、前回示したアルファベータ法の図を使って確かめてみましょう。アルファベータ法の図を再掲します。
</p>
<pre class="fig">
                       Ｒ                        先手の局面
                     ／  ＼
                   ／      ＼
                 ／          ＼
               ／              ＼
             ／                  ＼
           Ａ(3)                   Ｂ(2)         後手の局面
         ／  ＼                  ／  ×
       ／      ＼              ／      ×
     Ｃ(3)       Ｄ(4)       Ｅ(2)       Ｆ(5)   先手の局面
   ／  ＼      ／  ×      ／  ＼      ／  ＼
 Ｇ      Ｈ  Ｉ      Ｊ  Ｋ      Ｌ  Ｍ      Ｎ  後手の局面

 １      ３  ４      ２  ２      １  ３      ５  評価値
                     ×              ×      ×


          図 : アルファベータ法 
</pre>
<p> 局面 A の評価は次の図のようになります。
</p>
<pre class="fig">
  後手の局面              Ａ
                        ／  ＼
                      ／      ＼
  先手の局面        Ｃ          Ｄ
                  ／  ＼      ／  ×
  後手の局面    Ｇ      Ｈ  Ｉ      Ｊ

  評価値        １      ３  ４

  (1) R = (-∞, ∞) -&gt; A = (-∞, ∞) -&gt; C = (-∞, ∞)
  (2) G を評価 =&gt; 1, C = (1, ∞)
  (3) H を評価 =&gt; 3, C = (3, ∞)
  (4) C の評価 =&gt; 3, A = (-∞, 3)
  (5) A = (-∞, 3) -&gt; D = (-∞, 3)
  (6) I を評価 =&gt; 4, D = (4, 3)  4 &gt;= 3 なのでβカット 
  (7) D の評価 =&gt; 4, A = (-∞, 3)
  (8) A の評価 =&gt; 3, R = (3, ∞)

          図 : ベータカット
</pre>
<p> 局面 R のα値とβ値は R = (-∞, ∞) になります。この値が渡されていくので、局面 C も C = (-∞, ∞) になります。次に、局面 G の評価値を求めると 1 になります。局面 C は先手の局面なので、α値と評価値を比較して大きな値を選びます。したがって、C = (1, ∞) になります。次に G の局面を評価して C = (3, ∞) になります。そして、局面 C の評価値はα値の 3 になります。
</p>
<p> 局面 A は後手の局面なので、評価値とβ値を比較して小さな値を選びます。C の評価値は 3 なので、A = (-∞, 3) になります。次に局面 D を評価します。α値とβ値は局面 A の値が渡されるので D = (-∞, 3) になります。そして、局面 I を評価します。I の値は 4 になるので、D = (4, 3) になり α値 &gt;= β値 の条件を満たします。ここでβカットされて、局面 D の評価値は 4 になります。
</p>
<p> 局面 A に戻って、D の評価値 4 とβ値 3 を比較します。β値のほうが小さいので、D は選択されません。 A = (-∞, 3) のままです。そして、β値 3 が返されて、局面 R に戻ります。R は先手の局面なのでα値と評価値を比較して大きな値を選択します。したがって、R = (3, ∞) になります。
</p>

<p> 次に、局面 B の評価を下図に示します。
</p>
<pre class="fig">
                    Ｒ
                  ／  ＼
                ／      ＼
  後手の局面  Ａ          Ｂ
                        ／  ×
                      ／      ×
  先手の局面        Ｅ          Ｆ
                  ／  ＼
  後手の局面    Ｋ      Ｌ

  評価値        ２      １

  (1) R = (3, ∞) -&gt; B = (3, ∞) -&gt; E = (3, ∞)
  (2) K を評価 =&gt; 2, E = (3, ∞)
  (3) L を評価 =&gt; 1, E = (3, ∞)
  (4) E の評価 =&gt; 3, B = (3, 3)  3 &gt;= 3 なのでαカット
  (5) B の評価 =&gt; 3, R = (3, ∞)
  (6) R の評価 =&gt; 3, (A を選択する)


      図 : アルファカット
</pre>
<p> R = (3, ∞) の値が渡されていくので、局面 E も E = (3, ∞) になります。次に、K を評価します。評価値は 2 でα値 3 よりも小さいので、この局面は選択されません。次に、局面 L を評価しますが、評価値が 1 なのでこの局面も選択されません。このように、α値よりも小さな評価値の局面しか存在しない場合、局面を選択することができなくなります。
</p>
<p> この場合、2 通りの方法があります。一つはα値を E の評価値として返す方法です。既にα値が 3 となる局面が見つかっているので、これよりも小さな局面が選択されることはありません。正確な評価値がわからなくても、α値以下であることがわかればアルファベータ法は動作します。評価値として 3 を返すと、上図 (4) のように B = (3, 3) になるので、条件 α値 &gt;= β値 を満たしてαカットされます。
</p>
<p> もう一つは最も大きな評価値を返す方法です。上図の場合では、局面 K の評価値 2 を返します。この方法を「fail soft <sup><a href="pyalgo25.html#note1">[*1]</a></sup> アルファベータ法」と呼びます。アルファベータ法 (ネガアルファ法) の場合、どちらの方法でも正常に動作します。前者の場合、B の評価値は 3 になり、後者の場合は 2 になりますが、どちらの場合でも局面 A が選択されます。
</p>
<p> この fail soft をうまく使った方法に window search があります。window とはα値とβ値の幅 (α, β) のことです。アルファベータ法でゲーム木を探索する場合、ルートの局面では (-∞, ∞) を指定するのが普通ですが、window search では window の幅を狭めて探索を行います。とくに、window の幅を極端に狭めて (α, α + 1) に制限する方法を null window search といいます。ネガスカウト (NegaScout) 法や MTD(f) 法は null window search を使って、アルファベータ法よりも効率よくゲーム木を探索することができます。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : ネガアルファ法の改良

def negamax(turn, depth, board, alpha, beta):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = alpha
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b, value, beta)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b, -beta, -value)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= beta: break
    return value, move
</pre>
<p> 引数 alpha がα値、beta がβ値です。変数 value は評価値を格納します。ネガアルファ法は MIN_VALUE で初期化しましたが、このプログラムでは alpha で初期化します。これにより、alpha よりも大きな値の指し手が選択されます。そして、value が beta 以上になったら枝刈りを行います。ネガアルファ法を使っているので、手番を変えるときは符号を反転するとともに、α値とβ値を逆にして渡すことに注意してください。つまり、-beta, -value の順番で渡します。手番を変えないときは value, beta の順番で渡します。
</p>
<p> ところで、このプログラムは fail soft ではありません。局面が選択されなかった場合は alpha を返します。fail soft にするには次のように修正します。
</p>

<pre class="list">
リスト : ネガアルファ法の改良 (failsoft)

def negamax(turn, depth, board, alpha, beta):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    flag = True
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b, max(alpha, value), beta)
        else:
            # 後手番
            v, _ = negamax((turn + 7) % 14, depth - 1, b, -beta, -max(alpha, value))
            v = -v
        # ネガマックス : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= beta: break
    return value, move
</pre>
<p> value は MIN_VALUE に初期化します。そして、negamax を再帰呼び出しするときは、alpha と value の大きいほうを関数 max で選んで渡します。これで、alpha よりも小さな評価値の局面しか見つからない場合でも、value にはその中の最大値がセットされます。最後に value, move を返します。
</p>

<ul>
  <li><a href="pyalgo25.html#list3">プログラムリスト３</a>
</ul>
<h4>●実行結果</h4>
<p> それでは、実行結果を示しましょう。ゲームの結果は、当然ですがアルファベータ法とネガアルファ法改良版で変わりはありません。改良版の効果を確かめるため、局面を評価した回数をカウントして比較してみましょう。改良方法が有効に機能すれば、アルファベータ法よりも局面の評価回数は少なくなるはずです。結果は次のようになりました。
</p>
<pre>
        表 : 局面の評価回数

 先手＼後手 :    2    :    3    :    4    :    5
----------------------------------------------------
     2      :    6207 :   40657 :   85880 :  226145
            :    2672 :   13450 :   39302 :  100648
     3      :    1757 :   11320 :  119750 :   65362
            :    1654 :   10122 :   37689 :   37778
     4      :   30242 :   31230 :  111266 :  238004
            :   18117 :   19860 :   58028 :  116496
     5      :  504203 :  221814 :  505170 :  815589
            :  100583 :   86327 :  183703 :  314184

  上段 : アルファベータ法
  下段 : 改良版
</pre>
<p> ほとんどの場合で評価回数は大幅に減少しています。改良版の効果はとても大きいですね。ゲーム木を探索する場合、(α, β) の範囲を狭める方法は有効であることがわかります。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> fail soft の本来の意味は、システムにエラーが発生した際に、故障した箇所を切り離すなどして、最低限のシステムの稼動を続けるための技術のことです。
</div>
<h4>●null window search</h4>
<p> 次は null window search について簡単に説明します。null window search は window の幅を (α, α + 1) のように制限してアルファベータ法による探索を行います。window の幅がとても狭いため、通常のアルファベータ法よりも多くの枝刈りが発生し、高速に探索することができます。
</p>
<p> ただし、null winodow search で正確な評価値を求めることはできません。ミニマックス法で求められる正確な評価値を v、window の幅を (a, a + 1) とすると、null window search は次の条件を満たす評価値 x を返します。
</p>
<pre class="fig">
(1) v &lt;= x &lt;= a

(2) a + 1 &lt;= x &lt;= v
</pre>
<p> (1) の場合を fail-low といい、(2) の場合を fail-high といいます。fail-low の場合、正しい評価値 v は x 以下であることがわかります。また、fail-high の場合、v は x 以上であることがわかります。つまり、null window search を使うと、評価値が a よりも大きいか小さいかを高速に判定することができるわけです。
</p>

<h4>●ネガスカウト法</h4>
<p> null window search を使った探索方法には、ネガスカウト (NegaScout) 法や MTD(f) 法などがありますが、今回はネガスカウト法を取り上げます。ネガスカウト法は null window search を使って、アルファベータ法の探索で winodw の幅を絞り込む方法です。
</p>

<p> たとえば、winodw の幅が (a, b) のときに (a, a + 1) で null window search を行ってみましょう。返り値 x が fail-low の場合、正確な評価値は a 以下であることが保障されているので、評価値はα値以下であることが確定します。したがって、この局面が選択されることはありません。探索は null window search だけでよく、正確な評価値を求める必要はありません。
</p>

<p> 次に、返り値 x が b 以上の場合、正確な評価値は x 以上であることが保障されているので、β値以上であることが確定します。したがって、ここで枝刈りすることができます。この場合も null window search で求めた評価値 x だけで十分です。
</p>
<p> 最後に、a &lt; x &lt; b の場合ですが、正確な評価値は x 以上であることが保障されているので、window の幅を (x, b) に設定してアルファベータ法で正確な評価値を求めます。幅が (x, b) と制限される分だけ、効率的に探索することができます。
</p>

<p> ネガスカウト法の場合、最初に探索する (最も左側の枝の) 局面は通常のネガアルファ法で評価値を求め、そのあとに探索する局面に対して null window search を適用します。一般に、アルファベータ法の探索では、評価値の高い局面から順番に探索すると効率が良くなります。評価値が高いほど window の幅が制限されるので、最初に高い評価値が求まると効率よく枝刈りできるわけです。
</p>

<p> これはネガスカウト法でも同じです。高い評価値の局面から順番に探索した場合、最初の評価値を求めたあと、そのあとの局面は最初の評価値よりも大きくならないことを null window search で確認するだけですみます。一般に、指し手の順番を並べ替えることでアルファベータ法の効率を改善する方法を move ordering といいます。
</p>
<p> たとえば、数レベルの浅い探索を行って評価値を求め、それに基づいて指し手の順番を並べ替えます。もちろん、完全に move ordering することは不可能ですが、指し手が多いゲームでは効果があります。ネガスカウト法の場合、move ordering と一緒に用いられることが多いようです。カラーの場合、指し手が最大でも 6 通りしかないので、move ordering は行わないことにします。
</p>

<h4>●プログラムの作成</h4>
<p> ネガスカウト法のプログラムは次のようになります。
</p>

<pre class="list">
リスト : ネガスカウト法 (failsoft)

def negascout(turn, depth, board, alpha, beta):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            # null window search は不適用
            v, m = negascout(turn, depth, b, max(alpha, value), beta)
        else:
            # 後手番
            # null window search
            a = max(alpha, value)
            v, _ = negascout((turn + 7) % 14, depth - 1, b, -(a+1), -a)
            v = -v
            if beta &gt; v &gt; a:
                # 再探索
                v, _ = negascout((turn + 7) % 14, depth - 1, b, -beta, -v)
                v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if v &gt; value:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= beta: break
    return value, move
</pre>
<p> 石を動かしたあと、手番を変えるときに null window search を適用します。result が KALAH の場合でも null window search を適用できますが、実際に試してみると効果がなかったで不適用としました。また、move ordering を行っていないので、最初に探索する局面でも null window search を適用することにします。一般的なネガスカウト法とはちょっと違いますが、カラーの場合はこれでも十分に機能するようです。
</p>
<p> 手番を変える場合、最初に alpha と value を比較して大きいほうを変数 a にセットします。そして、window の幅を (-(a+1), -a) に制限して関数 negascout を再帰呼び出しします。これで null window search が実行されます。プログラムはネガアルファ法で実装しているので、null window search の幅 (a, a+1) は、符号を反転してα値とβ値を逆にすることに注意してください。
</p>
<p> 評価値 v が a よりも大きくて beta よりも小さい場合は、window の幅を (v, beta) に設定してネガアルファ法で再探索します。これで正しい評価値を求めることができます。あとはネガアルファ法と同じで、v が value よりも大きい場合はその局面を選択し、beta 以上の場合は枝刈りを行います。
</p>

<ul>
  <li><a href="pyalgo25.html#list4">プログラムリスト４</a>
</ul>
<h4>●実行結果</h4>
<p> それでは、実行結果を示しましょう。ゲームの結果は、当然ですがネガアルファ法の改良版とネガスカウト法で変わりはありません。ネガスカウト法の効果を確かめるため、局面を評価した回数をカウントして比較してみましょう。ネガスカウト法が有効に機能すれば、ネガアルファ法の改良版よりも局面の評価回数は少なくなるはずです。結果は次のようになりました。
</p>
<pre>
        表 : 局面の評価回数

 先手＼後手 :    2    :    3    :    4    :    5
----------------------------------------------------
     2      :    2672 :   13450 :   39302 :  100648
            :    3266 :    8330 :   29077 :   61462
     3      :    1654 :   10122 :   37689 :   37778
            :    2100 :   10266 :   35313 :   36692
     4      :   18117 :   19860 :   58028 :  116496
            :   18432 :   19704 :   45380 :   86733
     5      :  100583 :   86327 :  183703 :  314184
            :   90776 :   81086 :  139925 :  273440

  上段 : ネガアルファ法改良版
  下段 : ネガスカウト法
</pre>
<p> 先手と後手の探索レベルが 4 以上になると、null window search の効果により局面の評価回数はネガスカウト法のほうが少なくなります。探索レベルが 2, 3 の場合は、ネガアルファ法改良版で十分のようです。ご参考までに、探索レベルが 6, 7, 8 の場合を示します。
</p>
<pre>
        表 : 局面の評価回数

(先手, 後手) : (6, 6) :  (7, 7) :  (8, 8)
------------------------------------------
ネガアルファ : 590188 : 4024770 : 2444127
ネガスカウト : 428581 : 1982291 : 1651417
</pre>
<p> ネガスカウト法のほうが評価回数は少なくなります。ゲーム木を深く探索する場合は、ネガアルファ法よりもネガスカウト法のほうがよさそうです。ところで、move ordering を行うと、異なる結果になるかもしれません。興味のある方は試してみてください。
</p>

<h4>●参考文献, URL</h4>
<ol>
  <li>松原仁・竹内郁雄 編著, 『bit別冊 ゲームプログラミング』, 共立出版, 1997
  <li>松原仁 編著, 『コンピュータ将棋の進歩』, 共立出版, 1996
  <li>松原仁, 『将棋とコンピュータ』, 共立出版, 1994
  <li><a href="http://ray.sakura.ne.jp/search_problem/index.html">ゲーム木の探索問題</a>
  <li><a href="http://fujitake.dip.jp/sealsoft/thell/algorithm.html">アルゴリズム解説</a>
  <li><a href="http://vivi.dyndns.org/W/269">探索アルゴリズム (RunRunDietOnline)</a>
  <li><a href="http://www.zib.de/reinefeld/Research/nsc.html">NegaScout - A Minimax Algorithm faster than AlphaBeta</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
# coding: utf-8
#
# kalah.py : カラー (ネガマックス法)
#
#            Copyright (C) 2007 Makoto Hiroi
#
from board import *


# ネガマックス法
def negamax(turn, depth, board):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
    return value, move

# 実行
def play(first_depth, second_depth):
    board = Board([6,6,6,6,6,6,0,6,6,6,6,6,6,0])    # 初期状態
    turn = FIRST_KALAH
    while True:
        if turn == FIRST_KALAH:
            value, move = negamax(turn, first_depth, board)
        else:
            value, move = negamax(turn, second_depth, board)
        # 表示
        for x in move:
            print 'move', x
            a = board.move_stone(turn, x)
            board.print_board()
            print
        if a == GAMEOVER:
            print 'Game Over'
            return
        if turn == FIRST_KALAH:
            turn = SECOND_KALAH
        else:
            turn = FIRST_KALAH

#
play(2, 2)
print_count()
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
# coding: utf-8
#
# kalah.py : カラー (ネガアルファ法)
#
#            Copyright (C) 2007 Makoto Hiroi
#
from board import *

# ネガアルファ法
def negamax(turn, depth, board, limit):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b, limit)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b, -value)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= limit: break
    return value, move

# 実行
def play(first_depth, second_depth):
    board = Board([6,6,6,6,6,6,0,6,6,6,6,6,6,0])    # 初期状態
    turn = FIRST_KALAH
    while True:
        if turn == FIRST_KALAH:
            value, move = negamax(turn, first_depth, board, MAX_VALUE)
        else:
            value, move = negamax(turn, second_depth, board, MAX_VALUE)
        # 表示
        for x in move:
            print 'move', x
            a = board.move_stone(turn, x)
            board.print_board()
            print
        if a == GAMEOVER:
            print 'Game Over'
            return
        if turn == FIRST_KALAH:
            turn = SECOND_KALAH
        else:
            turn = FIRST_KALAH

#
play(2, 2)
print_count()
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
# coding: utf-8
#
# kalah.py : カラー (ネガアルファ法の改良)
#
#            Copyright (C) 2007 Makoto Hiroi
#
from board import *

# ネガアルファ法の改良
def negamax(turn, depth, board, alpha, beta):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = alpha
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            v, m = negamax(turn, depth, b, value, beta)
        else:
            # 手番を変える
            v, _ = negamax((turn + 7) % 14, depth - 1, b, -beta, -value)
            v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if value &lt; v:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= beta: break
    return value, move

# 実行
def play(first_depth, second_depth):
    board = Board([6,6,6,6,6,6,0,6,6,6,6,6,6,0])    # 初期状態
    turn = FIRST_KALAH
    while True:
        if turn == FIRST_KALAH:
            value, move = negamax(turn, first_depth, board, MIN_VALUE, MAX_VALUE)
        else:
            value, move = negamax(turn, second_depth, board, MIN_VALUE, MAX_VALUE)
        # 表示
        for x in move:
            print 'move', x
            a = board.move_stone(turn, x)
            board.print_board()
            print
        if a == GAMEOVER:
            print 'Game Over'
            return
        if turn == FIRST_KALAH:
            turn = SECOND_KALAH
        else:
            turn = FIRST_KALAH

#
play(2, 2)
print_count()
</pre>
<hr>
<h4 id="list4">●プログラムリスト４</h4>
<pre class="list">
# coding: utf-8
#
# kalah.py : カラー (ネガスカウト法)
#
#            Copyright (C) 2007 Makoto Hiroi
#
from board import *

# ネガスカウト法 (failsoft)
def negascout(turn, depth, board, alpha, beta):
    if depth == 0:
        v = board.value_func()
        if turn == SECOND_KALAH: v = -v
        return v, []
    #
    value = MIN_VALUE
    move = []
    for pos in xrange(turn - 6, turn):
        if board[pos] == 0: continue
        b = board.copy()
        # 石を動かす
        result = b.move_stone(turn, pos)
        m = []
        if result == GAMEOVER:
            v = b.value_func()
            if turn == SECOND_KALAH: v = -v
        elif result == KALAH:
            # 手番は同じまま
            # null window search は不適用
            v, m = negascout(turn, depth, b, max(alpha, value), beta)
        else:
            # 後手番
            # null window search
            a = max(alpha, value)
            v, _ = negascout((turn + 7) % 14, depth - 1, b, -(a+1), -a)
            v = -v
            if beta &gt; v &gt; a:
                # 再探索
                v, _ = negascout((turn + 7) % 14, depth - 1, b, -beta, -v)
                v = -v
        # ネガマックス法 : 大きな値を選ぶ
        if v &gt; value:
            value = v
            move = [pos] + m
        # ネガアルファ法
        if value &gt;= beta: break
    return value, move

# 実行
def play(first_depth, second_depth):
    board = Board([6,6,6,6,6,6,0,6,6,6,6,6,6,0])    # 初期状態
    turn = FIRST_KALAH
    while True:
        if turn == FIRST_KALAH:
            value, move = negascout(turn, first_depth, board, MIN_VALUE, MAX_VALUE)
        else:
            value, move = negascout(turn, second_depth, board, MIN_VALUE, MAX_VALUE)
        # 表示
        for x in move:
            print 'move', x
            a = board.move_stone(turn, x)
            board.print_board()
            print
        if a == GAMEOVER:
            print 'Game Over'
            return
        if turn == FIRST_KALAH:
            turn = SECOND_KALAH
        else:
            turn = FIRST_KALAH

#
play(2, 2)
print_count()
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo24.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo26.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>