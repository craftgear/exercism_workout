<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Underscore.js 超入門</title>
  <meta name="description" content="JavaScript,Underscore.js,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881802</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page<br>
<div class="small">
http://www.geocities.jp/m_hiroi/<br>
</div>
<div class="ce">
<h1>JavaScript Programming</h1>
<h2>お気楽 Underscore.js 超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="javascript.html">JavaScript</a> ]
<hr>
</div>
<section class="contents">
<h2>CONTENTS</h2>
<ul>
  <li>2016/08/13 <a href="underscore.html#begin">はじめに</a>
  <li>2016/08/13 <a href="underscore.html#cite">参考文献, URL</a>
  <li>2016/08/13 <a href="underscore.html#copyright">権利・免責事項など</a>
</ul>
<ul>
  <li>2016/08/13 <a href="underscore.html#collections">Collections</a>
  <li>2016/08/13 <a href="underscore.html#arrays">Arrays</a>
  <li>2016/08/13 <a href="underscore.html#objects">Objects</a>
  <li>2016/08/13 <a href="underscore.html#functions">Functions</a>
  <li>2016/08/13 <a href="underscore.html#utility">Utility</a>
  <li>2016/08/13 <a href="underscore.html#chaining">Chaining</a>
</ul>
<hr>

<h3 id="begin">はじめに</h3>
<p> Underscore.js は <a href="https://www.documentcloud.org/home">DocumentCloud</a> と Jeremy Ashkenas 氏が開発している JavaScript で作成されたライブラリです。Underscore.js は軽量なライブラリですが、100 以上の関数が定義されています。map, filter, reduce といった関数型言語でお馴染みの高階関数も定義されているので、とても便利に使用することができます。なお、これらの関数を使いこなすには、「クロージャ (closure)」を理解しておく必要があります。高階関数とクロージャについては、拙作のページ お気楽 JavaScript プログラミング超入門 <a href="js03.html">高階関数, クロージャ</a> をお読みくださいませ。
</p>
<p> Underscore.js は次のページからダウンロードすることができます。
</p>
<ul>
  <li><a href="http://underscorejs.org/">Underscore.js</a>
</ul>
<p> Development Version と Production Version (underscore-min.js) がありますが、ライブラリとして必要なのは underscore-min.js だけです。あとは、HTML ファイルと同じディレクトリにコピーして、HTML ファイルのスクリプトタグで読み込むだけです。
</p>
<pre class="list">
リスト : underscore-min.js の読み込み

&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;お気楽 Underscore.js 超入門&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src="underscore-min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    console.log(_.VERSION);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p> unserscore-min.js を読み込むと、アンダースコア ( <b>_</b> ) というオブジェクトが生成されます。このオブジェクトに便利な関数 (メソッド) などが多数定義されています。あとは、&lt;script&gt; と &lt;/script&gt; の間に JavaScript のプログラムを記述するだけで、Underscore.js を試してみることができます。たとえば、_.VERSION は Underscore.js のバージョンを格納しているプロパティです。M.Hiroi の環境でこのプログラムを実行すると、Web ブラウザの JavaScript コンソールに 1.8.3 と表示されます。
</p>
<p> ところで、Underscore.js で関数 (メソッド) を呼び出す方法は 2 通りあります。
</p>
<ol>
  <li>_.func(引数1, 引数2, ...)
  <li>_(引数1).func(引数2, ...)
</ol>
<p> 本ページでは 1. の方法で関数 (メソッド) を呼び出すことにします。
</p>
<hr>
<h3 id="cite">参考文献, URL</h3>
<ul>
  <li><a href="http://underscorejs.org/">Underscore.js</a>, (Underscore.js 本家)
  <li><a href="https://github.com/enja-oss/Underscore">Underscoreドキュメント日本語訳</a>
  <li><a href="http://gihyo.jp/dev/serial/01/underscorejs">Underscore.jsの入り口</a>, (早瀬まことさん, <a href="http://gihyo.jp/">gihyo.jp --- 技術評論社</a>)
  <li><a href="http://dotinstall.com/lessons/basic_underscorejs">Underscore.js入門(全10回)</a>, <a href="http://dotinstall.com/">ドットインストール</a>
</ul>
<hr>

<h3 id="collections">Collections</h3>
<p> Collections に分類されている関数は配列またはオブジェクトを操作します。マッピング (map)、フィルター (filter)、畳み込み (reduce) といった高階関数も用意されています。これらの高階関数については拙作のページ お気楽 JavaScript プログラミング超入門 <a href="js03.html">高階関数</a> で説明しています。よろしければ参考にしてください。
</p>
<h4>●マッピング</h4>
<pre class="item">
_.map(array_or_object, func, [context]) =&gt new_array  // 別名 collect
_.pluck(array_or_object, propertyName =&gt; new_array
</pre>
<p> map は array_or_object の要素 (またはプロパティ) に func を適用して、その結果を格納した新しい配列を返します。配列の場合、func の引数には (要素, 添字, 配列) が渡されます。オブジェクトの場合は (値, キー, オブジェクト) が渡されます。context にオブジェクトを指定すると、func の中では this を使ってオブジェクトを参照することができます。
</p>
<pre>
&gt; _.map([1,2,3,4,5], function(n) { return n * n; })
[1, 4, 9, 16, 25]
&gt; _.map({foo: 10, bar: 20}, function(n) { return n * n; })
[100, 400]
&gt; var x = _.map({foo: 10, bar: 20}, function(n, k) { return [n * n, k]; })
undefined
&gt; x[0]
[100, "foo"]
&gt; x[1]
[400, "bar"]
</pre>
<p> pluck は array_of_object に格納されているオブジェクトのプロパティの値を取り出し、それを新しい配列に格納して返します。基本的な動作は次のプログラムと同じです。
</p>
<pre class="list">
リスト : pluck の基本的な動作

function my_pluck(ary, name) {
  return _.map(ary, funciton(obj) { return obj[name]; };
}
</pre>
<pre>
&gt; function my_pluck(ary, name) { return _.map(ary, function(obj) { return obj[name]; }); }
undefined
&gt; my_pluck([{foo: 1, bar: 2}, {foo: 10, bar: 20}], 'foo')
[1, 10]
&gt; my_pluck([{foo: 1, bar: 2}, {foo: 10, bar: 20}], 'bar')
[2, 20]
</pre>

<h4>●フィルター</h4>
<pre class="item">
_.filter(array_or_object, func, [context]) =&gt new_array
_.reject(array_or_object, func, [context]) =&gt new_array
_.where(array_or_object, object) =&gt; new_array
</pre>
<p> filter は関数 func が真を返す要素 (プロパティ) を新しい配列に格納して返します。reject は filter の逆で、func が偽を返す要素 (プロパティ) を新しい配列に格納してを返します。関数 func に渡される引数は map と同じです。
</p>
<pre>
&gt; _.filter([1,2,3,4,5], function(n) { return n % 2 == 0; })
[2, 4]
&gt; _.filter({foo: 1, bar: 2}, function(n) { return n % 2 == 0; })
[2]
&gt; _.reject([1,2,3,4,5], function(n) { return n % 2 == 0; })
[1, 3, 5]
&gt; _.reject({foo: 1, bar: 2}, function(n) { return n % 2 == 0; })
[1]
</pre>
<p> where は object で指定したプロパティと値に一致するオブジェクトを新しい配列に格納して返します。
</p>
<pre>
&gt; var x = _.where([{foo: 1, bar: 10}, {foo: 2, bar: 20}, {foo: 1, bar: 30}], {foo: 1})
undefined
&gt; x[0]
Object {foo: 1, bar: 10}
&gt; x[1]
Object {foo: 1, bar: 30}
</pre>
<h4>●畳み込み</h4>
<pre class="item">
_.reduce(array_or_object, func, init, [context]) =&gt; value      // 別名 foldl, inject 
_.reduceRight(array_or_object, func, init, [context]) =&gt; value // 別名 foldr
</pre>
<p> reduce は array_or_object の先頭 (左側) から、reduceRight は末尾 (右側) から要素を畳み込みます。関数 func の引数には (累積値, 要素, 添字、配列) または (累積値, 値, キー, オブジェクト) が渡されます。
</p>
<pre>
&gt; _.reduce([1,2,3,4,5], function(a, n) { return a + n; }, "")
"12345"
&gt; _.reduceRight([1,2,3,4,5], function(a, n) { return a + n; }, "")
"54321"
&gt; _.reduce({foo: 1, bar: 2, baz: 3} , function(a, n) { return a + n; }, "")
"123"
&gt; _.reduceRight({foo: 1, bar: 2, baz: 3} , function(a, n) { return a + n; }, "")
"321"
</pre>
<h4>●巡回</h4>
<pre class="item">
_.each(array_or_object, func, [context])
</pre>
<p> each は配列の要素またはオブジェクトのプロパティに関数 func を適用します。返り値は array_or_object です。
</p>
</p>
<pre>
&gt; _.each([1,2,3,4,5], function(n){ console.log(n); })
1
2
3
4
5
[1, 2, 3, 4, 5]
&gt; _.each({foo: 10, bar: 20}, function(n){ console.log(n); })
10
20
Object {foo: 10, bar: 20}
</pre>
<h4>●検索</h4>
<pre class="item">
_.find(array_or_object, func, [context]) =&gt; value
_.contains(array_or_object, value) =&gt; boolean
</pre>
<p> find は array_or_object を線形探索し、関数 func が真を返す最初の要素 (またはプロパティの値) を返します。見つからない場合は undefined を返します。contains は array_or_object に value が含まれていれば true を、そうでなければ false を返します。
</p>

<pre>
&gt; _.find([1,2,3,4,5], function(n) {return n % 3 == 0})
3
&gt; _.find([1,2,3,4,5], function(n) {return n % 6 == 0})
undefined
&gt; _.find({foo: 1, bar: 3, baz: 5}, function(n) {return n % 3 == 0})
3
&gt; _.find({foo: 1, bar: 3, baz: 5}, function(n) {return n % 6 == 0})
undefined

&gt; _.contains([1,3,5,7], 5);
true
&gt; _.contains([1,3,5,7], 2);
false
&gt; _.contains({foo: 1, bar: 3, baz: 5}, 3)
true
&gt; _.contains({foo: 1, bar: 3, baz: 5}, 6)
false
</pre>
<pre class="item">
_.every(array_or_object, func, [context]) =&gt; boolean    // 別名 all
_.some(array_or_object, [func], [context]) =&gt; boolean   // 別名 any
</pre>
<p> every は array_or_object の要素に関数 func を適用し、結果がすべて真ならば true を返します。some は array_or_object の要素に関数 func を適用し、true を返す要素がひとつでもあれば true を返します。結果がすべて false ならば false を返します。func を省略した場合は要素の値で真偽を判定します。
</p>
<pre>
&gt; _.every([2,4,6,8], function(n) { return n % 2 == 0; })
true
&gt; _.every([2,4,6,8,9], function(n) { return n % 2 == 0; })
false
&gt; _.some([2,4,6,8,9], function(n) { return n % 2 != 0; })
true
&gt; _.some([2,4,6,8], function(n) { return n % 2 != 0; })
false
&gt; _.some([0,0,0,0], function(n) { return n % 2 != 0; })
false
&gt; _.some([0,0,0,0])
false
&gt; _.some([0,0,1,0])
true
</pre>
<h4>●グルーピング</h4>
<pre class="item">
_.groupBy(array_or_object, func) =&gt; new_object
_.countBy(array_or_object, func) =&gt; new_object
</pre>
<p> groupBy は array_or_object の要素に関数 func を適用し、その結果でグループ分けします。func の結果が new_object のキーになり、値は要素を格納した配列になります。なお、func にはプロパティ名を指定することもできます。その場合はプロパティの値でグループ分けされます。countBy はグループ分けしたあとの要素数をカウントします。
</p>
<pre>
&gt; var x = _.groupBy([1,2,3,4,5,6,7,8,9], function(n) { return n % 4; })
undefined
&gt; x[0]
[4, 8]
&gt; x[1]
[1, 5, 9]
&gt; x[2]
[2, 6]
&gt; x[3]
[3, 7]
&gt; var y = _.countBy([1,2,3,4,5,6,7,8,9], function(n) { return n % 4; })
undefined
&gt; y[0]
2
&gt; y[1]
3
&gt; y[2]
2
&gt; y[3]
2
</pre>

<h4>●ソート, シャッフル</h4>
<pre class="item">
_.sortBy(array_or_object, [func], [context]) =&gt; new_array
_.shuffle(array_or_object) =&gt; new_array
</pre>
<p> sortBy は array_or_object を昇順にソートした新しい配列を返します。func を指定すると、要素を func に適用し、その返り値を基準にソートします。func には関数のかわりにプロパティを指定することができます。shuffle は array_or_object の要素をシャッフルした新しい配列を返します。
</p>
<pre>
&gt; _.sortBy([5,6,7,4,3,2,9,1])
[1, 2, 3, 4, 5, 6, 7, 9]
&gt; _.sortBy([5,6,7,4,3,2,9,1], function(n) { return -n; })
[9, 7, 6, 5, 4, 3, 2, 1]
&gt; _.sortBy({foo: 2, bar: 1, baz: 3})
[1, 2, 3]
&gt; _.sortBy(["foo", "a", "oops"], 'length')
["a", "foo", "oops"]
&gt; _.shuffle([1,2,3,4,5])
[4, 1, 3, 5, 2]
&gt; _.shuffle([1,2,3,4,5])
[3, 4, 5, 2, 1]
&gt; _.shuffle([1,2,3,4,5])
[3, 2, 4, 5, 1]
</pre>

<h4>●その他</h4>
<pre class="item">
_.min(array_or_object, [func], [context]) =&gt; value
_.max(array_or_object, [func], [context]) =&gt; value
</pre>
<p> min は array_or_object の中から最小値を選んで返します。max は最大値を選んで返します。func を指定した場合は、要素に func を適用して、その返り値を基準に最小値 (または最大値) を選択します。
</p>
<pre>
&gt; _.max([5,6,4,7,3,8,2,9,1])
9
&gt; _.max([5,6,4,7,3,8,2,9,1], function(n){ return -n; })
1
&gt; _.min([5,6,4,7,3,8,2,9,1])
1
&gt; _.min([5,6,4,7,3,8,2,9,1], function(n){ return -n; })
9
</pre>
<pre class="item">
_.toArray(object) =&gt; new_array
_.size(array_or_object) =&gt; number
</pre>
<p> toArray は object を配列に変換します。size は array_or_object の要素数を返します。
</p>
<pre>
&gt; _.toArray({foo: 1, bar: 2, baz: 3})
[1, 2, 3]
&gt; _.size({foo: 1, bar: 2, baz: 3})
3
</pre>
<hr>

<h3 id="arrays">Arrays</h3>
<p> Arrays には配列を操作する関数が定義されています。
</p>
<h4>●配列の分解</h4>
<pre class="item">
_.first(array, [n]) =&gt; value / new_array  // 別名 head, take
_.rest(array, [n]) =&gt; new_array           // 別名 tail, drop
</pre>
<p> first は配列の先頭要素を返します。n を指定すると、先頭から n 個の要素を配列に格納して返します。rest は先頭の要素を取り除いた新しい配列を返します。n を指定すると先頭から n 個の要素を取り除いた配列を返します。Lisp / Scheme の関数 car, cdr と似ていますが、rest は新しい配列を返すことに注意してください。
</p>
<pre>
&gt; _.first([1,2,3,4,5])
1
&gt; _.first([1,2,3,4,5], 3)
[1, 2, 3]
&gt; _.rest([1,2,3,4,5])
[2, 3, 4, 5]
&gt; _.rest([1,2,3,4,5], 3)
[4, 5]
</pre>
<pre class="item">
_.initial(array, [n]) =&gt; new_array
_.last(array, [n]) =&gt; value / new_array
</pre>
<p> initial は配列の最後の要素を取り除いた新しい配列を返します。n を指定すると、最後から n 個の要素を取り除いた新しい配列を返します。last は配列の最後の要素を返します。n を指定すると、最後から n 個の要素を新しい配列に格納して返します。
</p>
<pre>
_.initial([1,2,3,4,5])
[1, 2, 3, 4]
_.initial([1,2,3,4,5], 3)
[1, 2]
_.last([1,2,3,4,5])
5
_.last([1,2,3,4,5], 3)
[3, 4, 5]
</pre>
<h4>●配列の生成</h4>
<pre class="item">
_.range([start], end, [step]) =&gt; new_array
</pre>
<p> range は start から end - 1 までの整数を配列に格納して返します。引数が一つで start が省略された場合、リストの要素は 0 から始まり、値を +1 しながら end - 1 までの数値を生成します。引数が 2 つの場合は start から end - 1 までの数値を生成します。引数が 3 つの場合は、start から end 未満までの数値を step 分加算しながら生成します。
</p>
<pre>
&gt; _.range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt; _.range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt; _.range(1, 10, 2)
[1, 3, 5, 7, 9]
</pre>
<pre class="item">
_.zip(array, ...) =&gt; new_array
</pre>
<p> zip は複数の配列を受け取り、同じ位置にある要素を一つの配列にまとめ、それを新しい配列に格納して返します。たとえば、配列 A, B, ..., Z を zip に渡すと、i 番目の要素は [A<sub>i</sub>, B<sub>i</sub>, ..., Z<sub>i</sub>] になります。
</p>
<pre>
&gt; var x = _.zip(["foo", "bar", "baz"], [1, 2, 3])
undefined
&gt; x[0]
["foo", 1]
&gt; x[1]
["bar", 2]
&gt; x[2]
["baz", 3]
</pre>
<h4>●探索</h4>
<pre class="item">
_.indexOf(array, value, [isSorted])
_.lastIndexOf(array, value, [start])
</pre>
<p> indexOf は value と等しい要素を探索します。見つけた場合は位置 (添字) を返します。見つからない場合は -1 を返します。isSorted に true を指定すると配列を二分探索します。このとき、配列は昇順にソートしておく必要があります。lastIndexOf は配列の末尾から探索します。start は探索の開始位置を指定します。
</p>
<pre>
&gt; _.indexOf([1,2,3,4,5], 3);
2
&gt; _.indexOf([1,2,3,4,5], 10);
-1
&gt; _.lastIndexOf([1,2,1,2,3,1,2,3,4], 1)
5
&gt; _.lastIndexOf([1,2,1,2,3,1,2,3,4], 5)
-1
</pre>
<h4>●集合演算</h4>
<p> 次に示す関数は配列を集合とみなして集合演算を行います。
</p>
<pre class="item">
_.union(array, ...) =&gt; new_array
_.intersection(array, ...) =&gt; new_array
_.difference(array, ...) =&gt; new_array
_.uniq(array, [isSorted], [func]) =&gt; new_aray
</pre>
<p> union は和集合を求めます。intersection は積集合を求めます。difference は差集合を求めます。uniq は重複要素を削除した新しい配列を返します。配列をソートしておいて、isSorted を true に指定すると、高速に実行することができます。関数 func を指定すると要素に func を適用して、その返り値で等値を判定します。
</p>
<pre>
&gt; _.union([1,2,3,4], [3,4,5,6])
[1, 2, 3, 4, 5, 6]
&gt; _.intersection([1,2,3,4], [3,4,5,6])
[3, 4]
&gt; _.difference([1,2,3,4], [3,4,5,6])
[1, 2]
&gt; _.uniq([1,2,1,2,3,1,2,3,4])
[1, 2, 3, 4]
</pre>
<h4>●平坦化</h4>
<pre class="item">
_.flatten(array、[shallow]) =&gt; new_array
</pre>
<p> flatten は入れ子になった配列を平坦化します。shallow に true を指定すると、トップレベルの階層だけ平坦化します。
</p>
<pre>
&gt; _.flatten([1,[2,[3,4],5],6])
[1, 2, 3, 4, 5, 6]
&gt; _.flatten([1,[2,[3,4],5],6], true)
[1, 2, [3, 4], 5, 6]
</pre>
<h4>●その他</h4>
<pre class="item">
_.compact(array) =&gt; new_array
_.without(array, value, ...) =&gt; new_array
</pre>
<p> compact は偽と判定される要素を取り除いた新しい配列を返します。without は value 以降に指定された値を取り除いた新しい配列を返します。
</p>
<pre>
&gt; _.compact([1, 2, 3, 0, "", undefined, 4])
[1, 2, 3, 4]
&gt; _.without([1, 2, 3, 4, 5], 1, 3, 5)
[2, 4]
</pre>
<pre class="item">
_.object(array, [values]) =&gt; new_object
</pre>
<p> object は配列をオブジェクトに変換します。引数が一つの場合、配列の要素を [キー, 値] にしてください。引数が 2 つある場合は、第 1 引数にキーを、第 2 引数に値を格納した配列を渡します。
</p>
<pre>
&gt; _.object([["foo", 1], ["bar", 2]])
Object {foo: 1, bar: 2}
&gt; _.object(["foo", "bar", "baz"], [1,2,3])
Object {foo: 1, bar: 2, baz: 3}
</pre>
<hr>
<h3 id="objects">Objects</h3>
<p> Objects にはオブジェクトを操作する便利な関数 (メソッド) が定義されています。
</p>
<h4>●キーと値</h4>
<pre class="item">
_.keys(object) =&gt; new_array
_.values(object) =&gt; new_array
_.pairs(object) =&gt; new_array
_.invert(object) =&gt; new_object
_.has(object, key) =&gt; boolean
</pre>
<p> keys は object 内のキー (プロパティ名) を配列に格納して返します。values は object 内のキーの値を配列に格納して返します。pairs は object 内のキーと値を組 [key, value] にして、それを配列に格納して返します。invert はキーと値を反転した新しいオブジェクトを返します。has は object のキーに key が存在すれば true を返します。
</p>
<pre>
&gt; var obj = {foo: 1, bar: 2, baz: 3, oops: 4}
undefined
&gt; _.keys(obj)
["foo", "bar", "baz", "oops"]
&gt; _.values(obj)
[1, 2, 3, 4]
&gt; _.pairs(obj)
[Array[2], Array[2], Array[2], Array[2]]
&gt; var x = _.pairs(obj)
undefined
&gt; x[0]
["foo", 1]
&gt; x[1]
["bar", 2]
&gt; x[2]
["baz", 3]
&gt; x[3]
["oops", 4]
&gt; _.invert(obj)
Object {1: "foo", 2: "bar", 3: "baz", 4: "oops"}
_.has(obj, 'foo')
true
_.has(obj, 'Foo')
false
</pre>
<h4>●オブジェクトのコピー</h4>
<pre class="item">
_.clone(object) =&gt; new_object
</pre>
<p> clone は object のクローンを生成して返します。ただし、キーの値が配列やオブジェクトの場合、配列やオブジェクトがコピーされることはありません。
</p>
<pre>
&gt; var a = [1,2,3,4,5]
undefined
&gt; var b = {foo: a, bar: 1}
undefined
&gt; var c = _.clone(b)
undefined
&gt; c
Object {foo: Array[5], bar: 1}
&gt; a[0] = 10
10
&gt; a[0]
10
&gt; b.foo[0]
10
&gt; c.foo[0]
10
</pre>
<pre class="item">
_.pick(object, key, ...) =&gt; new_object
_.omit(object, key, ...) =&gt; new_object
</pre>
<p> pick は object から key 以降に指定したプロパティをコピーして返します。omit は逆に object から key 以降のプロパティ以外のプロパティをコピーして返します。
</p>
<pre>
_.pick({foo: 1, bar: 2, baz: 3}, 'foo', 'baz')
Object {foo: 1, baz: 3}
_.omit({foo: 1, bar: 2, baz: 3}, 'foo', 'baz')
Object {bar: 2}
</pre>
<pre class="item">
_.extend(object, source, ...) =&gt; object
_.defaults(object, default, ...) =&gt; object
</pre>
<p> extend は source 以降のオブジェクトの全プロパティを object にコピーして返します。object と source 以降のオブジェクトに同じプロパティが存在する場合、その値は書き換えられます。defaults は defulat 以降のオブジェクトのプロパティで、object に存在しないプロパティ (object で undefined のもの) を object にコピーして返します。
</p>
<pre>
_.extend({foo: 1, bar: 2}, {foo: 10, baz: 20})
Object {foo: 10, bar: 2, baz: 20}
_.defaults({foo: 1, bar: 2}, {foo: 10, baz: 20})
Object {foo: 1, bar: 2, baz: 20}
</pre>
<h4>●等値の判定</h4>
<pre class="item">
_.isEqual(object, other) =&gt; boolean
</pre>
<p> isEqual は引数の object と other が等しいか判定します。数値と文字列の場合は演算子 === で判定します。配列の場合は、大きさが等しくて、すべての要素が isEqual で真を返すとき「真」と判定します。オブジェクトの場合、すべてのキーが等しくて、その値が isEqual で真を返すとき「真」と判定します。
</p>
<pre>
&gt; _.isEqual(1, 1)
true
&gt; _.isEqual(1, "1")
false
&gt; _.isEqual("1", "1")
true
&gt; _.isEqual([1], [1])
true
&gt; _.isEqual([1], [1, 2])
false
&gt; _.isEqual([1,3], [1, 2])
false
&gt; _.isEqual([1], ["1"])
false
&gt; var a = {foo: 1, bar: 2}
undefined
&gt; var b = {foo: 1, bar: 2}
undefined
&gt; a == b
false
&gt; _.isEqual(a, b)
true
&gt; _.isEqual(a, {foo: 1})
false
&gt; _.isEqual(a, {foo: 1, bar: 3})
false
</pre>
<h4>●データ型の判定</h4>
<p> データ型を判定する関数のことを関数型言語では「型述語」と呼ぶことがあります。Objects には is で始まる型述語が多数用意されています。どの関数も返り値は boolean (true, false) になります。
</p>
<table border=1>
<caption>表 : データ型を判定する関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th><tr>
</thead>
<tbody>
  <tr><td>_.isEmpty(object)</td><td>空のオブジェクトか</td></tr>
  <tr><td>_.isArrray(object)</td><td>配列か</td></tr>
  <tr><td>_.isObject(object)</td><td>オブジェクトか</td></tr>
  <tr><td>_.isFunction(object)</td><td>関数か</td></tr>
  <tr><td>_.isString(object)</td><td>文字列か</td></tr>
  <tr><td>_.isNumber(object)</td><td>数値 (NaN を含む) か</td></tr>
  <tr><td>_.isNaN(object)</td><td>NaN か</td></tr>
  <tr><td>_.isFinite(object)</td><td>有限数か</td></tr>
  <tr><td>_.isBoolean(object)</td><td>boolean (true, false) か</td></tr>
  <tr><td>_.isNull(object)</td><td>null か</td></tr>
  <tr><td>_.isUndefined(object)</td><td>undefined か</td></tr>
  <tr><td>_.isDate(object)</td><td>日付オブジェクトか</td></tr>
  <tr><td>_.isRegExp(object)</td><td>正規表現オブジェクトか</td></tr>
  <tr><td>_.isArguments(object)</td><td>Arguments オブジェクトか</td></tr>
</tbody>
</table>
<hr>

<h3 id="functions">Functions</h3>
<p> Functions には関数を操作するための便利な関数が用意されています。
</p>
<pre class="item">
_.partial(func, *args) =&gt; new_func
</pre>
<p> partial は引数の関数 func を「部分適用」した新しい関数 new_func を返します。関数の部分適用とは、指定した引数に値を設定して、残りの引数を受け取る関数を生成することです。
</p>
<pre>
&gt; var add = function(a, b) { return a + b; }
undefined
&gt; add(1, 2)
3
&gt; var add10 = _.partial(add, 10)
undefined
&gt; add10(20)
30
&gt; var add100 = _.partial(add, 100)
undefined
&gt; add100(10)
110
</pre>
<pre class="item">
_.bind(func, object, [*args]) =&gt; new_func
</pre>
<p> bind は引数の関数 func にオブジェクト object を束縛 (bind) した新しい関数 new_func を返します。new_func 内の変数 this は束縛した object になります。引数 args が指定された場合、partial と同様に関数の部分適用が行われます。
</p>
<pre>
&gt; function hello() { return "hello " + this.name; }
undefined
&gt; hello()
"hello "
&gt; var ken = _.bind(hello, {name: "Ken"})
undefined
&gt; ken()
"hello Ken"
&gt; var bob = _.bind(hello, {name: "Bob"})
undefined
&gt; bob()
"hello Bob"
</pre>
<pre class="item">
_.memoize(func, [hashFunc]) =&gt; new_func
</pre>
<p> memoize は引数の関数 func をメモ化した関数 new_func を返します。関数の「メモ化 (memoize)」とは、計算した値を表 (ハッシュ表) に格納しておいて、2 回目以降は表から計算結果を求めることで、処理を高速化する手法のことです。詳しい説明は拙作のページ お気楽 JavaScript プログラミング超入門 <a href="js03.html#chap08">クロージャ</a> をお読みください。
</p>
<pre>
&gt; function fibo(n) { return n &lt; 2 ? n : fibo(n - 2) + fibo(n - 1); }
undefined
&gt; fibo = _.memoize(fibo)
function (e){var u=r.cache,i=""+(t?t.apply(this,arguments):e);return m.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]}
&gt; fibo(10)
55
&gt; fibo(40)
102334155
&gt; fibo(45)
1134903170
</pre>
<pre class="item">
_.compose(*func) =&gt; new_func
</pre>
<p> compose は引数に与えられた複数の関数を合成した新しい関数 new_func を返します。たとえば、_.compose(f, g, h) とすると、合成した関数は f(g(h())) になります。
</p>
<pre>
&gt; function foo() { console.log("foo"); }
undefined
&gt; function bar() { console.log("bar"); }
undefined
&gt; function baz() { console.log("baz"); }
undefined
&gt; var test = _.compose(foo, bar, baz)
undefined
&gt; test()
baz
bar
foo
undefined

&gt; function foo1(x) { return 2 * x + 1; }
undefined
&gt; function bar1(y) { return y * y + 3 * y; }
undefined
&gt; var baz1 = _.compose(bar1, foo1)
undefined
&gt; baz1(4)
108
</pre>
<hr>
<h3 id="utility">Utility</h3>
<p> 今まで説明した関数以外にも、便利な関数が Utility に用意されています。
</p>
<pre class="item">
_.identity(value) =&gt; value
</pre>
<p> identity は引数 value をそのまま返します。このような関数を「恒等関数 (identity function)」といいます。
</p>
<pre>
&gt; _.identity(1)
1
&gt; _.identity("hello")
"hello"
&gt; _.identity([1,2,3,4,5])
[1, 2, 3, 4, 5]
</pre>
<pre class="item">
_.times(n, iteratee, [context]) =&gt; array
</pre>
<p> times は引数の関数 iteratee を n 回呼び出します。iteratee の引数には 0 から n - 1 までの整数値が渡されます。返り値は iteratee の結果を格納した配列です。
</p> 
<pre>
&gt; _.times(5, function(n) { console.log(n); })
0
1
2
3
4
[undefined, undefined, undefined, undefined, undefined]
&gt; _.times(5, function(n, x) { return n; })
[0, 1, 2, 3, 4]
</pre>
<pre class="item">
_.random(min, max) =&gt; integer
</pre>
<p> random は min 以上 max 以下の乱数 (整数値) を生成します。引数が一つの場合は 0 以上引数以下の乱数を生成します。
</p>
<pre>
&gt; _.random(0, 5)
5
&gt; _.random(0, 5)
0
&gt; _.random(0, 5)
1
&gt; _.random(0, 5)
3
&gt; _.random(5)
5
&gt; _.random(5)
1
&gt; _.random(5)
4
&gt; _.random(5)
0
</pre>
<pre class="item">
_.escape(string) =&gt; string
_.unescape(string) =&gt; string
</pre>
<p> escape は引数 string の中の文字 &amp; &lt; &gt; &#x27; &quot; を &amp;amp; &amp;lt; &amp;gt; &amp;#x27; &amp;quot; に変換します。unescape は escape の逆変換を行います。
</p>
<pre>
&gt; _.escape("&amp;&lt;&gt;'`")
"&amp;amp;&amp;lt;&amp;gt;&amp;#x27;&amp;#x60;"
&gt; _.escape('&amp;&lt;&gt;`"')
"&amp;amp;&amp;lt;&amp;gt;&amp;#x60;&amp;quot;"
&gt; _.unescape("&amp;amp;&amp;lt;&amp;gt;&amp;#x27;&amp;#x60;")
"&amp;&lt;&gt;'`"
&gt; _.unescape("&amp;amp;&amp;lt;&amp;gt;&amp;#x60;&amp;quot;")
"&amp;&lt;&gt;`""
</pre>
<pre class="item">
_.template(templateString, [data], [settings]) =&gt; function
</pre>
<p> template は引数の templateString をコンパイルして関数を生成します。生成された関数は引数にオブジェクトを受け取り、それをテンプレートにあてはめ、結果を文字列にして返します。templateString の中では、次に示す特別な記号を使うことができます。
</p>
<ul>
  <li>&lt;% ... %&gt;<br>
JavaScript コードを実行する
  <li>&lt;%= ... %&gt;<br>
オブジェクトの変数の値を取り出す
  <li>&lt;%- ... %&gt;<br>
エスケープして出力する
</ul>
<pre>
&gt; var tmp1 = _.template("&lt;% console.log('hello, world') %&gt;")
undefined
&gt; tmp1()
hello, world
""
&gt; var tmp2 = _.template("hello, &lt;%= name %&gt;")
undefined
&gt; tmp2({name: "M.Hiroi"})
"hello, M.Hiroi"
&gt; var tmp3 = _.template("&lt;%- name %&gt;")
undefined
&gt; tmp3({name: "&lt;M.Hiroi&gt;"})
"&amp;lt;M.Hiroi&amp;gt;"
</pre>
<hr>

<h3 id="chaining">Chaining</h3>
<p> chain と value を使うと、Underscore.js のメソッドをドット ( . ) でつなげて記述することができます。chain はメソッドを連結し、その結果を取り出すのが value です。
</p>
<pre class="list">
リスト : chain と value の使用例

var a =_.chain(_.range(1, 10))
        .filter(function(x) { return x % 2 == 0; })
        .map(function(x) { return x * x; })
        .value()
</pre>
<pre>
&gt; var a = _.chain(_.range(1,10)).filter(function(x) { return x % 2 == 0; })
.map(function(x) { return x * x; }).value()
undefined
&gt; a
[4, 16, 36, 64]
</pre>
<p> chain と value を使わないと、プログラムは次のようになります。
</p>
<pre>
&gt; _.map(_.filter(_.range(1, 10), function(x) { return x % 2 == 0; }),
        function(x) { return x * x; })
[4, 16, 36, 64]
</pre>
<hr>

<h3 id="copyright">権利・免責事項など</h3>
<p> 『お気楽 Underscore.js 超入門』の著作権は筆者「広井誠 (Makoto Hiroi)」が保持します。無断使用や無断転載は禁止いたします。本ページで作成したプログラムはフリーソフトウェアとします。ご自由にお使いください。プログラムの改造や配布もご自由にどうぞ。その際は出典を明記してくださるようお願いいたします。
</p>
<p> ただし、これらのプログラムは無保証であり、使用したことにより生じた損害について、作者「広井誠 (Makoto Hiroi) 」は一切の責任を負いません。また、これらのプログラムを販売することで利益を得るといった商行為は禁止いたします。
</p>
<div align="right">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
</div>

</section>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="javascript.html">JavaScript</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>