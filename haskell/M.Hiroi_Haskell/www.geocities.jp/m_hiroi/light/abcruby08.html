<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby プログラミング入門</title>
  <meta name="description" content="Ruby,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881800</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Ruby プログラミング入門</h1>
<h2>第 8 回 イテレータと高階関数</h2>
<div class="small">
[ <a href="abcruby07.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcruby09.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 前回は関数の再帰定義について説明しました。今回は Ruby の特徴であるイテレータとブロックについて詳しく説明します。そして、その応用例として高階関数とクロージャについて説明します。
</p>
<p> イテレータ (Iterator) は「繰り返すもの」という意味で、元々は繰り返しを実現するための機能です。ところが、Ruby のイテレータはとても便利で強力だったため、繰り返し以外の場面でも使われるようになりました。このため、最近はイテレータとは呼ばずに「ブロック付きメソッド」と呼ばれているようです。たとえば、ファイルをオープンする open() は、繰り返しを行わなくても「ブロック」を受け取ることができます。
</p>

<h4>●イテレータとブロック</h4>
<p> Ruby のイテレータを図 1 に示します。
</p>

<pre class="fig">
object.method(a1, a2, ...) do |b1, b2, ...|
  処理A
  処理B
  ...
end


object.method(a1, a2, ...) {|b1, b2, ...|
  処理A
  処理B
  ...
}

        図 1 : イテレータの構造
</pre>

<p> Ruby では do ... end と { ... } を「ブロック」といいます。一般的なプログラミング言語では、複数の処理を一つにまとめたものをブロックといいます。たとえば、Ｃ/Ｃ++や Perl では { ... } の中に複数の処理を記述することができます。普通はこれをブロックといいます。
</p>

<p> Ruby のブロック <sup><a href="abcruby08.html#note1">[*1]</a></sup> は一般的なものとは大きく異なっていて、簡単にいえばメソッドから呼び出される関数のことです。したがって、Ruby のイテレータとは、与えられたブロックを呼び出すメソッドということになります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
irb&gt; 5.times {|x| print x, "\n"}
0
1
2
3
4
=&gt; 4
</pre>

<p> メソッド n.times() は整数 n で指定した回数だけブロックを呼び出します。このとき、ブロックには 0 から n - 1 までの整数が渡されます。ブロックの引数は | ... | の中に記述します。この引数のことを「ブロックのパラメータ」といいます。この例では引数 x に整数が渡されます。このほかに、整数 n から m までを昇順でブロックに渡すメソッド n.upto(m) や降順でブロックに渡すメソッド n.downto(m) があります。
</p>

<p> Ruby の場合、配列やハッシュなどのように複数のデータを格納するコレクションにはメソッド each() が定義されています。このメソッドは要素を順番に取り出して、それをブロックに渡して実行します。簡単な例を示しましょう。
</p>

<pre>
irb&gt; a = ["foo", "bar", "baz"]
=&gt; ["foo", "bar", "baz"]
irb&gt; a.each {|x| print x, "\n"}
foo
bar
baz
=&gt; ["foo", "bar", "baz"]
</pre>

<p> Ruby の for 文は each() を使って実装されています。したがって、each() が定義されているコレクションであれば for 文を使うことができるわけです。
</p>
<p> ところで、do ... end と { ... } は、結合規則が異なるので注意してください。たとえば、引数のカッコを省略した場合、do ... end はメソッドに渡されますが、{ ... } は最後の引数に渡されます。
</p>
<pre class="item">
foo a, b do |x| ... end  # foo の引数は a, b とブロック
bar a, b {|x| ... }      # bar の引数は a と b にブロックを渡して実行した結果
</pre>
<p> bar の場合、引数 b がブロックを受け付けるメソッドでないとエラーになります。ブロックを指定する場合、引数のカッコは省略しないほうがわかりやすいかもしれません。本稿ではブロックを渡すとき、メソッドに引数があるときはカッコを付けることにします。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> Smalltalk にもブロックがあり、Ruby のブロックは Smalltalk に近いものです。
</div>

<h4>●イテレータの作り方</h4>
<p> イテレータを作る場合、関数またはメソッドからブロックを呼び出す方法が必要になります。Ruby にはいくつかの方法が用意されていますが、一番簡単な方法は yield 文を使うことです。次の例を見てください。
</p>

<pre>
irb&gt; def foo(x)
irb&gt; yield x
irb&gt; end
=&gt; :foo
irb&gt; foo(10) {|x| print x, "\n"}
10
=&gt; nil
</pre>

<p> yield 文は与えられているブロックを実行します。yield 文に与えた引数は、そのままブロックに渡されます。なお、foo() を呼び出すときにブロックを与えないとエラーになります。ブロックの返り値は一番最後に実行した処理結果になります。なお、ブロックの途中で値を返したい場合は return ではなく next を使います。これはあとで説明します。
</p>

<p> 簡単な例として、配列を線形探索する関数 find(), position(), count() をイテレータでプログラムしてみましょう。
</p>

<pre class="list">
リスト 1 : データの探索 (イテレータ版)

# ブロックが真となる要素を探す
def find(ary)
  for x in ary
    return x if yield x
  end
  false
end

# ブロックが真となる要素の位置を返す
def position(ary)
  for x in 0...ary.size
    return x if yield ary[x]
  end
  false
end

# ブロックが真となる要素の個数を求める
def count(ary)
  c = 0
  for x in ary
    c += 1 if yield x
  end
  c
end
</pre>

<p> 簡単な実行例を示しましょう。
</p>

<pre>
irb&gt; a = [1, 2, 3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; find(a) {|x| x % 2 == 0}
=&gt; 2
irb&gt; position(a) {|x| x % 2 == 0}
=&gt; 1
irb&gt; count(a) {|x| x % 2 == 0}
=&gt; 2
</pre>
<p> このように、ブロックを使うと探索する条件を簡単に指定することができます。
</p>

<h4>●イテレータの制御</h4>
<p> イテレータは繰り返しを実現するための機能なので、ブロックの中で次に示す制御文が使用できます。
</p>

<pre class="item">
break [val] : イテレータメソッドの実行を終了する。メソッドは nil (または val) を返す。
next  [val] : そのブロックの実行を終了する。yeild は nil (または val) を返す。
redo        : そのブロックの実行を先頭からやり直す。
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
irb&gt; 10.times {|x| 
irb&gt; print x, "\n"
irb&gt; break if x == 3
irb&gt; }
0
1
2
3
=&gt; nil
irb&gt; 10.times {|x|
irb&gt; next if x == 3
irb&gt; print x, "\n"
irb&gt; }
0
1
2
4
5
6
7
8
9
=&gt; 10
</pre>
<p> メソッド 10.times() でブロックを 10 回繰り返します。ブロックの中で break を実行すると、times() の繰り返しを終了して nil を返します。これが times() の返り値になります。next を実行すると、ブロックの処理を終了して nil を返します。これが yield の返り値になります。times() の繰り返しは終了しないことに注意してください。
</p>
<p> ブロックの中で return を呼び出すと次のようになります。
<pre>
irb&gt; [1,2,3,4,5].each {|x|
irb&gt; return if x == 3
irb&gt; puts x
irb&gt; }
1
2
LocalJumpError: unexpected return
</pre>
<p> return は関数の呼び出し先から呼び出し元に戻るための命令です。戻るところがないのでエラーになるわけです。もし、次のようにメソッド foo() を定義すると、ブロックの中の return は foo() を終了して値を返すことになります。
</p>
<pre>
irb&gt; def foo(a)
irb&gt; a.each {|x|
irb&gt; return "NG" if x == 3
irb&gt; puts x
irb&gt; }
irb&gt; "OK"
irb&gt; end
=&gt; :foo
irb&gt; foo [2,4,6,8]
2
4
6
8
=&gt; "OK"
irb&gt; foo [1,3,5,7]
1
=&gt; "NG"
</pre>
<h4>●高階関数</h4>
<p> Lisp / Scheme などの関数型言語の場合、関数はほかのデータと同等に取り扱うことができます。つまり、関数を変数に代入したり、引数として渡すことができるのです。また、値として関数を返すこともできるので、関数を作る関数を定義することが簡単にできます。関数を引数として受け取る関数を「汎関数 (functional)」とか「高階関数 (higher order function)」と呼びます。
</p>

<p> Ruby は手続き型言語なので、関数型言語のように関数やメソッドをそのまま変数に代入したり、引数として渡すことはできません。そのかわり、ブロックを使うことで高階関数と同様の処理を行うことができます。イテレータはブロックを受け取るメソッドなので、高階関数の特別な形式と考えることができます。また、ブロックを「手続きオブジェクト」に変換することで高階関数を実現することもできます。
</p>

<h4>●マッピング</h4>
<p> 簡単な例として、ブロックに配列の要素を渡して呼び出し、その結果を配列に格納して返す関数を作ってみましょう。このような操作を「マッピング (写像)」といいます。なお、関数に引数を与えて呼び出すことを、関数型言語では「適用」といいます。本稿でも関数呼び出しの意味で適用を使うことにします。プログラムをリスト 2 に示します。
</p>

<pre class="list">
リスト 2 : マッピング

def mapcar(ary)
  a = []
  for x in ary
    a.push(yield x)
  end
  a
end
</pre>

<p> Ruby には同じ機能を持つメソッド map() や collect() が定義されているので、関数名は mapcar() としました。名前は Common Lisp から拝借しました。プログラムは簡単です。for 文で配列 ary の要素を順番に取り出し、それをブロックに渡して評価します。その結果を配列 a に追加します。最後に a を返します。
</p>

<p> それでは実行例を示しましょう。
</p>

<pre>
irb&gt; a = [1, 2, 3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; mapcar(a) {|x| x * x}
=&gt; [1, 4, 9, 16, 25]
irb&gt; a.map {|x| x * x}
=&gt; [1, 4, 9, 16, 25]
irb&gt; a.collect {|x| x * x}
=&gt; [1, 4, 9, 16, 25]
</pre>

<p> 引数 x を 2 乗する処理をブロックに定義します。このブロックを mapcar() に渡すと、要素を 2 乗した新しい配列を返します。Ruby のメソッド map() や collect() を使っても同じことができます。このように、ブロックを使うと Ruby でも高階関数を簡単に定義することができます。
</p>

<h4>●フィルター</h4>
<p> フィルター (filter) は配列の要素に関数 (ブロック) を適用し、ブロックが真を返す要素を配列に格納して返す関数です。ここでは簡単な例題として、ブロックが真を返す要素を削除する関数 remove_if() を作ってみましょう。関数名は Common Lisp から拝借しました。
</p>

<pre class="list">
リスト 3 : 要素の削除

def remove_if(ary)
  a = []
  for x in ary
    a.push(x) unless yield x
  end
  a
end
</pre>

<p> mapcar() と同様に remove_if() も簡単です。ブロックが偽を返したならば x を配列 a に加えるだけです。
</p>

<p> 簡単な実行例を示します。
</p>

<pre>
irb&gt; remove_if(a) {|x| x % 2 == 0}
=&gt; [1, 3, 5]
</pre>
<p> 配列を破壊的に修正してもよければ、Ruby のメソッド delete_if() や reject!() を使うことができます。
</p>
<pre>
irb&gt; b = [1,2,3,4,5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; b.delete_if {|x| x % 2 == 0}
=&gt; [1, 3, 5]
irb&gt; b
=&gt; [1, 3, 5]
</pre>
<p> もちろん、フィルターも簡単に定義することができます。remove_if() とは逆に、ブロックが真を返すとき要素を配列に追加し、偽を返すときは配列に加えません。なお、Ruby には同様の動作を行うメソッド select() があります。
</p>

<pre class="list">
リスト 4 : フィルター

def filter(ary)
  a = []
  for x in ary
    a.push(x) if yield x
  end
  a
end
</pre>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
irb&gt; filter(a) {|x| x % 2 == 0}
=&gt; [2, 4]
irb&gt; a.select {|x| x % 2 == 0}
=&gt; [2, 4]
</pre>

<h4>●畳み込み</h4>
<p> 2 つの引数を取る関数 f() と配列を引数に受け取る関数 reduce() を考えます。reduce() は配列の各要素に対して関数 f() を図 2 のように適用します。
</p>

<pre class="fig">
(1) [a1, a2, a3, a4, a5]
    =&gt; f( f( f( f( a1, a2 ), a3 ), a4 ), a5 )

(2) [a1, a2, a3, a4, a5]
    =&gt; f( a1, f( a2, f( a3, f( a4, a5 ) ) ) )


        図 2 : reduce() の動作
</pre>

<p> 関数 f() を適用する順番で 2 通りの方法があります。図 2 (1) は配列の先頭から f() を適用し、図 2 (2) は配列の後ろから f() を適用します。たとえば、関数 f() が単純な加算関数とすると、reduce() の結果はどちらの場合も配列の要素の和になります。
</p>

<pre class="item">
f(x, y) = x + y の場合
reduce() =&gt; a1 + a2 + a3 + a4 + a5
</pre>

<p> このように、reduce() は配列のすべての要素を関数 f() を用いて結合します。このような操作を「縮約」とか「畳み込み」といいます。また、reduce() の引数に初期値 g を指定することがあります。この場合、reduce() は図 3 に示す動作になります。
</p>

<pre class="fig">
(1) [a1, a2, a3, a4, a5]
    =&gt; f( f( f( f( f( g, a1 ), a2 ), a3 ), a4 ), a5 )

(2) [a1, a2, a3, a4, a5]
    =&gt; f( a1, f( a2, f( a3, f( a4, f( a5, g ) ) ) ) )


        図 3 : reduce() の動作 (2)
</pre>

<p> Ruby のメソッド inject() と reduce() は、初期値を省略すると図 2 (1) の動作になり、初期値を指定すると図 3 (1) の動作になります。ここでは簡単な例題として、図 3 (1) の動作を行う関数 reduce_left() と、図 3 (2) の動作を行う関数 reduce_right() を作ってみましょう。リスト 5 を見てください。
</p>

<pre class="list">
リスト 5 : 畳み込み

def reduce_left(ary, init)
  a = init
  for x in ary
    a = yield(a, x)
  end
  a
end

def reduce_right(ary, init)
  a = init
  ary.reverse_each {|x|
    a = yield(x, a)
  }
  a
end
</pre>

<p> reduce_left() の引数 ary が配列、init が初期値です。最初にローカル変数 a を init で初期化します。次に、for ループで ary の要素を一つずつ取り出してブロックに渡して実行します。その結果を変数 a にセットします。reduce() は変数 a の値をブロックの返り値で更新することで、図 3 (1) の動作を実現しています。
</p>

<p> たとえば、配列が [1, 2, 3] で init が 0 とします。最初は f(0, 1) が実行され、その返り値が a にセットされます。次は f(a, 2) が実行されますが、これは f(f(0, 1), 2) と同じことです。そして、その結果が a にセットされます。最後に f(a, 3) が実行されますが、これは f(f(f(0, 1), 2), 3) となり、図 3 (1) と同じ動作になります。
</p>

<p> reduce_left() の場合、配列の要素がブロックの第 2 引数になり、第 1 引数にはこれまでの処理結果が渡されます。これに対し、reduce_right() の場合は逆になり、ブロックの第 1 引数に配列の要素が渡されて、これまでの処理結果は第 2 引数に渡されます。reverse_each() は配列の後ろから順番に要素を取り出すメソッドです。
</p>

<p> それでは実行例を示します。
</p>

<pre>
irb&gt; a = [1, 2, 3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; reduce_left(a, 0) {|x, y| x + y}
=&gt; 15
irb&gt; reduce_left(a, 0) {|x, y| [x, y]}
=&gt; [[[[[0, 1], 2], 3], 4], 5]
irb&gt; reduce_right(a, 6) {|x, y| [x, y]}
=&gt; [1, [2, [3, [4, [5, 6]]]]]
irb&gt; a.reduce(0) {|x, y| x + y}
=&gt; 15
irb&gt; a.inject(0) {|x, y| x + y}
=&gt; 15
irb&gt; a.reduce(0) {|x, y| [x, y]}
=&gt; [[[[[0, 1], 2], 3], 4], 5]
irb&gt; a.inject(0) {|x, y| [x, y]}
=&gt; [[[[[0, 1], 2], 3], 4], 5]
irb&gt; a.reduce {|x, y| [x, y]}
=&gt; [[[[1, 2], 3], 4], 5]
irb&gt; a.inject {|x, y| [x, y]}
=&gt: [[[[1, 2], 3], 4], 5]
</pre>

<p> ブロックの引数を配列に格納して返すと、畳み込みの動作がよく理解できると思います。畳み込みは関数型言語でよく用いられる高階関数で、プログラミング言語によっては fold(), foldl(), foldr() などと呼ばれることもあります。畳み込みは 2 引数の関数と組み合わせることにより、いろいろな処理を簡単に実現することができます。
</p>

<h4>●手続きオブジェクト</h4>
<p> Ruby のイテレータはとても便利な機能ですが、メソッドに渡すことができるブロックは一つだけです。これに対し、ブロックを手続きオブジェクトに変換すると、複数のブロックをメソッドに渡すことができます。手続きオブジェクトは Ruby が扱うことができるデータ (オブジェクト) なので、変数に代入したり、関数の引数に渡すことができます。また、関数の返り値として手続きオブジェクトを返すこともできます。
</p>

<p> 手続きオブジェクトは Proc.new() で作成します。次の例を見てください。
</p>

<pre>
irb&gt; add = Proc.new {|x , y| x + y}
=&gt; #&lt;Proc: ... &gt;
irb&gt; add.call(1, 2)
=&gt; 3
irb&gt; mul = proc {|x, y| x * y}
=&gt; #&lt;Proc: ... &gt;
irb&gt; mul.call(11, 12)
=&gt; 132
irb&gt; sub = lambda {|x, y| x - y}
=&gt; #&lt;Proc: ... &gt;
irb&gt; sub.call(10, 5)
=&gt; 5
</pre>

<p> 手続きオブジェクトは Proc.new() にブロックを付けて呼び出すことで生成することができます。Proc は手続きオブジェクトを表すクラスです。なお、Proc.new() には lambda <sup><a href="abcruby08.html#note2">[*2]</a></sup> と proc という別名が用意されています。Proc.new(), proc, lambda はどれもクラス Proc のオブジェクトを生成しますが、その動作はちょっとした違いがあります。詳細は Ruby のリファレンスマニュアル <a href="https://docs.ruby-lang.org/ja/latest/doc/spec=2flambda_proc.html#should_use_next">手続きオブジェクトの挙動の詳細</a> をお読みください。
</p>

<p> 手続きオブジェクトを実行するにはメソッド call() を使います。call() に渡された引数はそのままブロックのパラメータに渡されます。上の例では変数 add に手続きオブジェクトをセットし、add.call(1, 2) でブロックを実行します。このとき、call() の引数 1, 2 がブロックのパラメータ x, y に渡されて、実行結果が 3 となります。
</p>
<h4>●ブロック引数</h4>
<p> イテレータはブロックを手続きオブジェクトに変換して、引数として受け取ることができます。この引数を「ブロック引数」といいます。ブロック引数は名前の先頭に &amp; をつけて表します。ブロック引数は仮引数の一番最後に定義しないといけません。
</p>

<p> たとえば、ブロック変数を使って mapcar() を書き直すと次のようになります。
</p>

<pre class="list">
リスト 6 : マッピング (その２)

def mapcar(ary, &amp;func)
  a = []
  for x in ary
    a.push(func.call(x))
  end
  a
end
</pre>

<p> mapcar() に渡されたブロックは手続きオブジェクトに変換されて引数 func に渡されます。ブロックが指定されていない場合、func には nil がセットされます。ブロック引数は、受け取ったブロックを他の関数 (メソッド) へ渡すときに使うと便利です。
</p>
<p> それでは実行してみましょう。
<pre>
irb&gt; a = [1,2,3,4,5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; mapcar(a) {|x| x * x}
=&gt; [1, 4, 9, 16, 25]
</pre>
<h4>●手続きオブジェクトとブロック</h4>
<p> 手続きオブジェクトはブロックのかわりに使うことができます。その場合、先頭に &amp; を付けてメソッドに渡します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
irb&gt; square = Proc.new {|x| x * x}
=&gt; #&lt;Proc: ...&gt;
irb&gt; mapcar(a, &amp;square)
=&gt; [1, 4, 9, 16, 25]
irb&gt; a.map &square
=&gt; [1, 4, 9, 16, 25]
irb&gt; mapcar(a, &amp;Proc.new {|x| x * x})
=&gt; [1, 4, 9, 16, 25]
</pre>
<p> 手続きオブジェクトを変数 square にセットします。mapcar() や map() に渡す場合は、変数名の前に &amp; を付けて渡します。また、Proc.new() の前に &amp; を付けて渡すこともできます。
</p>
<p> ブロックのかわりにメソッドを渡すこともできます。次の例を見てください。
</p>
<pre>
irb&gt; mapcar(a, &amp;:to_s)
=&gt; ["1", "2", "3", "4", "5"]
irb&gt; a.map &amp;:to_s
=&gt; ["1", "2", "3", "4", "5"]
</pre>
<p> ブロックの引数 (オブジェクト) のメソッドを呼び出したい場合は、メソッド名 (シンボル) の前に &amp; を付けて渡します。上記の場合、&amp;:to_s はブロック {|x| x.to_s} を渡したことと同じになります。
</p>
<p> ブロックの引数をメソッドの引数に渡す場合、次に示すような方法もあります。
</p>
<pre>
irb&gt; def cube(x) x * x * x end
=&gt; :cube
irb&gt; cube(10)
=&gt; 1000
irb&gt; m = method(:cube)
=&gt; #&lt;Method: Object#cube&gt;
irb&gt; m.call(10)
=&gt; 1000
irb&gt; a.map &amp;m
=&gt; [1, 8, 27, 64, 125]
irb&gt; mapcar(a, &amp;m)
=&gt; [1, 8, 27, 64, 125]
</pre>
<p> メソッド method() はクラス Method のオブジェクトを生成します。method() にはメソッド名を表すシンボルを渡します。このオブジェクトに &amp; を付けてメソッド (イテレータ) に渡すと、ブロックのかわりにメソッドを呼び出すことができます。これは {|x| cube(x)} を渡したことと同じです。
</p>
<p> Ruby の場合、メソッドを呼び出すだけでもいろいろな方法があります。詳しい説明は Ruby のリファレンスマニュアル <a href="https://docs.ruby-lang.org/ja/latest/doc/spec=2fcall.html">メソッド呼び出し(super・ブロック付き・yield)</a> をお読みくださいませ。
</p>
<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> lambda は Lisp / Scheme のラムダ式 (lambda expression) のことです。
</div>

<h4>●レキシカルスコープ</h4>
<p> ここで、もう少し詳しくローカル変数のスコープについて説明しましょう。変数 x を表示する関数 foo() を定義します。
</p>

<pre>
irb&gt; def foo()
irb&gt; print x
irb&gt; end
=&gt; :foo
irb&gt; x = 10
irb&gt; foo()
=&gt; エラー
</pre>

<p> foo() はローカル変数 x に値を代入していないので、foo() を実行するとエラーになります。それでは foo1() という関数から foo() を呼び出す場合を考えてみましょう。foo1() にはローカル変数 x を定義します。この場合、foo() は x の値を表示するのでしょうか。実際に試してみましょう。
</p>

<pre>
irb&gt; def foo1()
irb&gt; x = 100
irb&gt; foo()
irb&gt; end
=&gt; :foo1
irb&gt; foo1()
=&gt; エラー
</pre>

<p> この場合もエラーになります。このように、foo1() で定義したローカル変数 x は、foo() からアクセスすることはできません。図 4 を見てください。
</p>
<pre class="fig">
<img src="img/fig0801.png" alt="図 4 : ローカル変数のスコープ">
        図 4 : ローカル変数のスコープ
</pre>

<p> 図 4 では、変数の有効範囲を枠で表しています。foo1() で定義したローカル変数 x は、関数 foo1() の枠の中でのみ有効です。もしも、この枠でローカル変数が見つからない場合は、一つ外側の枠を調べます。foo() の場合、関数定義の枠しかないので、ここで変数が見つからない場合はエラーになります。
</p>

<p> このように、foo() から foo1() の枠を超えて変数 x にアクセスすることはできないのです。このようなスコープを「レキシカルスコープ (lexical scope)」といいます。レキシカルには文脈上いう意味があり、変数が定義されている範囲内 (枠内) でないと、その変数にアクセスすることはできません。
</p>

<h4>●ブロックのスコープ</h4>
<p> それでは、ブロックの場合はどうなるのでしょうか。リスト 7 を見てください。
</p>

<pre class="list">
リスト 7 : 配列の要素を n 倍する

def times_element(n, ary)
  mapcar(ary) {|x| x * n}
end
</pre>

<p> mapcar() に渡すブロックのパラメータは x だけですから、変数 n をアクセスするとエラーになると思われるかもしれません。ところが、変数 n は関数 times_element() の引数 n にアクセスできるのです。図 5 を見てください。
</p>

<pre class="fig">
<img src="img/fig0802.png" alt="図 5 : ブロックのスコープ">

        図 5 : ブロックのスコープ
</pre>

<p> ポイントは、ブロックが関数 times_element() 内で定義されているところです。変数 n は関数の引数として定義されていて、その有効範囲は関数の終わりまでです。ブロックはその範囲内に定義されているため、変数 n にアクセスすることができるのです。つまり、関数内で定義されたブロックは、そのとき有効なローカル変数にアクセスすることができるのです。
</p>

<p> もう一つ簡単な例題を示しましょう。指定した文字から始まる文字列を配列から削除する関数を作ってみましょう。最初に実行例を示します。
</p>

<pre>
irb&gt; remove_string("a", ["abc", "def", "agh", "ijk"])
=&gt; ["def", "ijk"]
</pre>

<p> 配列に格納された文字列の中で a から始まる文字列を削除します。この処理は filter() とブロックを使うと簡単に定義できます。
</p>

<pre class="list">
リスト 8 : 先頭文字が c の文字列を削除

def remove_string(c, ary)
  filter(ary) {|x| x[0] != c}
end
</pre>

<p> ブロックの中で remove_string() の引数 c をアクセスできるので、このような定義が可能になります。繰り返しを使うと、リスト 9 のようなプログラムになります。
</p>

<pre class="list">
リスト 9 : 先頭文字が c の文字列を削除

def remove_string(c, ary)
  a = []
  for x in ary
    a.push(x) if x[0] != c
  end
  a
end
</pre>

<p> 繰り返しを使う場合、配列から要素を取り出す処理をプログラムする必要があります。ブロックと高階関数をうまく組み合わせると、複雑な処理でも簡単にプログラムすることができます。
</p>

<h4>●クロージャ</h4>
<p> ここで関数型言語でよく用いられるテクニックを紹介しましょう。Lisp / Scheme などの関数型言語では、関数を生成する関数を簡単に作ることができます。このとき使われる機能が「クロージャ (closure)」です。
</p>

<p> クロージャは実行する関数とアクセス可能なローカル変数をまとめたものです。クロージャは関数のように実行することができますが、クロージャを生成するときにアクセス可能なローカル変数を保存するところが異なります。アクセス可能なローカル変数の集合を「環境」と呼ぶことがあります。
</p>

<p> Ruby でクロージャを生成するには手続きオブジェクトを使います。たとえば、「引数を n 倍する関数」を生成する関数は、手続きオブジェクトを使うと次のようになります。
</p>

<pre>
irb&gt; def foo(n)
irb&gt; Proc.new {|x| n * x}
irb&gt; end
=&gt; :foo
irb&gt; foo10 = foo(10)
=&gt; #&lt;Proc: ... &gt;
irb&gt; foo10.call(100)
=&gt; 1000
irb&gt; foo5 = foo(5)
=&gt; #&lt;Proc: ... &gt;
irb&gt; foo5.call(11)
=&gt; 55
</pre>

<p> 関数 foo() は引数を n 倍する関数 (手続きオブジェクト) を生成して返します。変数 foo10 に foo(10) の返り値をセットします。すると、foo10 は引数を 10 倍する関数として使うことができます。同様に、変数 foo5 に foo(5) の返り値をセットすると、foo5 は引数を 5 倍する関数になります。
</p>

<p> Proc.new() でブロックを生成するとき、実行する処理のほかに、そのときアクセス可能なローカル変数、つまり環境もいっしょに保存されます。この場合、アクセス可能なローカル変数は foo() の引数 n です。そして、クロージャを実行するときは、保存されているローカル変数にアクセスすることができるのです。
</p>

<p> foo(10) を実行して手続きオブジェクトを生成するとき、定義されているローカル変数は n で、その値は 10 です。この値がクロージャに保存されているので、foo10 の関数は引数を 10 倍した結果を返します。foo(5) を評価すると n の値は 5 で、それがクロージャに保存されているので、foo5 の関数は引数を 5 倍した結果を返すのです。
</p>

<h4>●ジェネレータ</h4>
<p> 最後に、クロージャの応用例として「ジェネレータ (generator)」というプログラムを紹介しましょう。ジェネレータは、呼び出されるたびに新しい値を生成していきます。たとえば、Ruby の関数 rand() は実行するたびに乱数を返します。つまり、rand() は乱数列を発生する「ジェネレータ」と考えることができます。
</p>

<p> 簡単な例題として、フィボナッチ数列 (0, 1, 1, 2, 3, 5, 8, ...) を発生するジェネレータを作ってみます。関数名は make_fibo() としましょう。ジェネレータはグローバル変数を使って実現することができますが、クロージャを使った方がスマートです <sup><a href="abcruby08.html#note3">[*3]</a></sup>。まず、ジェネレータを作る関数を定義します。
<pre class="list">
リスト 10 : ジェネレータ生成 (1)

def make_fibo
  a = 0
  b = 1
  Proc.new {
    c = a
    a, b = b, a + b
    c
  }
end
</pre>
<p> 関数 make_fibo はクロージャを返します。そして、このクロージャがジェネレータの役割を果たすのです。それでは、実際に実行してみましょう。
</p>
<pre>
irb&gt; load "makefibo.rb"
=&gt; true
irb&gt; fibo = make_fibo
=&gt; #&lt;Proc:...&gt;
irb&gt; 20.times {|x| print fibo.call, " "}
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 =&gt; 20
irb&gt; fibo1 = make_fibo
=&gt; #&lt;Proc:...&gt;
irb&gt; 20.times {|x| print fibo1.call, " "}
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 =&gt; 20
</pre>
<p> make_fibo() で作成したクロージャを変数 fibo にセットし、fibo.call で実行します。0, 1, 1, 2, 3, 5 とフィボナッチ数列を生成していますね。新しいクロージャを変数 fibo1 にセットし、このクロージャを実行すれば、新しいフィボナッチ数列が生成されます。
</p>
<p> クロージャで保存される環境は、make_fibo() で定義されたローカル変数 a, b です。これらの変数は make_fibo() が実行されたときに初期化される、つまり、クロージャを生成するときに初期化されることに注意してください。
</p>
<p> 環境はクロージャによって異なります。fibo のクロージャが実行されると、そのクロージャの環境が更新されるのであって、ほかのクロージャに影響を与えることはありません。したがって、あるジェネレータが発生するフィボナッチ数列が、ほかのジェネレータに影響を与えることはないのです。あとは必要な数だけジェネレータを make_fibo() で作り、生成したクロージャを変数に格納しておけばいいわけです。

<div class="note">
-- note --------<br>
<a name="note3">[*3]</a> Ruby の場合、このような数列の生成はクラス Enumerator を使ったほうが簡単に実装することができます。Enumerator には多数の高階関数が用意されていて、とても便利に使うことができます。ここでは Ruby の学習ということで、あえてクロージャでプログラムを作ってみました。
</div>
<h4>●ジェネレータをリセットする</h4>
<p> 次はフィボナッチ数列を最初に戻す、つまり、ジェネレータをリセットすることを考えましょう。この場合、クロージャ内の変数を書き換えるしか方法はありません。そこで、make_fibo() の返り値を 2 つに増やすことにします。最初の返り値はフィボナッチ数列を発生するジェネレータで、2 番目の返り値はジェネレータをリセットする関数とします。プログラムは次のようになります。
</p>
<pre class="list">
リスト 11 : ジェネレータ生成(2)

def make_fibo1
  a = 0
  b = 1
  value = Proc.new {
    c = a
    a, b = b, a + b
    c
  }
  reset = Proc.new {
    a = 0
    b = 1
  }
  return value, reset
end
</pre>
<p> 変数 reset にジェネレータをリセットする処理を、value にフィボナッチ数列を発生する処理をセットします。どちらの関数も手続きオブジェクトを使って簡単に定義することができます。あとは、2 つの関数を return で返すだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
irb&gt; f, r = make_fibo1
=&gt; [#&lt;Proc:...&gt;, #&lt;Proc:...&gt;]
irb&gt; 20.times {|x| print f.call, " "}
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 =&gt; 20
irb&gt; r.call
=&gt; 1
irb&gt; 20.times {|x| print f.call, " "}
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 =&gt; 20
</pre>
<p> 正常に動作していますね。
</p>


<h4>●おわりに</h4>
<p> イテレータと高階関数について説明しました。筆者は関数型言語 (Lisp / Scheme など) に興味があります。筆者の趣味でクロージャまで説明しましたが、関数型言語の機能をここまでサポートしている Ruby には大変驚きました。Ruby で関数プログラミングを試してみるのも面白いと思います。興味のある方は挑戦してみてください。次回からはいよいよ Ruby のオブジェクト指向機能について説明します。
</p>
</section>
<hr>
<div align="right">
初版 2008 年 11 月 15 日<br>
改訂 2017 年 1 月 15 日
<hr>
<div class="ce">
<b>Copyright (C) 2008-2017 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcruby07.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcruby09.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>