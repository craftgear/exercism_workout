<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Python3 プログラミング超入門 </title>
  <meta name="description" content="Python,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881761</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Lightweight Language</h1>
<h2>お気楽 Python3 プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#python3_abc">Python3</a> ]
<hr>
</div>
<section class="contents">
<h4 id="abc08">●モジュール</h4>
<ul>
  <li>Python のモジュール (module) はとても簡単で、ソースファイルが一つのモジュールになる</li>
  <li>拡張子 .py を除いたファイル名がモジュール名になる</li>
  <li>モジュールを利用する場合は import 文を使う</li>
<pre class="item">
import module_name, ...
</pre>
  <li>複数のモジュールをインポートするときはカンマ ( , ) で区切って指定する</li>
  <li>モジュールはインポートされたときにモジュール内のプログラムを実行する</li>
  <li>モジュールはモジュール sys の変数 path のリストに定義されているディレクトリに配置すること</li>
  <ul>
    <li>デフォルトではカレントディレクトリも含まれている</li>
  </ul>
  <li>モジュール内に定義された変数や関数にアクセスするには、名前の前にモジュール名とドット ( . ) を付ける</li>
<pre class="list">
リスト : モジュール foo (foo.py)

a = 10

def test():
    print('module foo')
</pre>
<pre class="list">
リスト : モジュール bar (bar.py)
a = 100

def test():
    print('module bar')
</pre>
<pre>
&gt;&gt;&gt; import foo, bar
&gt;&gt;&gt; foo.a
10
&gt;&gt;&gt; foo.test()
module foo
&gt;&gt;&gt; bar.a
100
&gt;&gt;&gt; bar.test()
module bar
</pre>
  <li>from 文を使うと他のモジュールで定義されている名前をそのまま自分のモジュールで利用することができる</li>
<pre class="item">
from module_name import name, ...
</pre>
  <li>名前の衝突がない場合、from 文を使うとモジュール名を付けなくてすむ</li>
<pre>
&gt;&gt;&gt; from foo import a, test
&gt;&gt;&gt; a
10
&gt;&gt;&gt; test()
module foo
</pre>
  <li>名前の指定にアスタリスク (*) を指定すると、モジュール内で定義されているすべての名前を利用することができる</li>
  <li>この方法はあまり推薦されていないようだ</li>
<pre>
&gt;&gt;&gt; from bar import *
&gt;&gt;&gt; a
100
&gt;&gt;&gt; test()
module bar
</pre>
  <li>モジュール名は変数 __name__ に格納される</li>
  <li>モジュールではなくスクリプトとして実行すると、__name__ の値は '__main__' になる</li>
  <li>__name__ の値をチェックすることで、スクリプトのときだけ実行する処理 (たとえばテストなど) を記述することができる</li>
<pre class="list">
リスト : モジュール baz (baz.py)

a = 10

def test():
    print('module baz')

print(__name__)

if __name__ == '__main__':
    print("Go, Go, Python3!!!")
</pre>
<pre>
&gt;&gt;&gt; import baz
baz
</pre>
<pre>
C&gt;python baz.py
__main__
Go, Go, Python3!!!
</pre>
</ul>
<h4 id="abc09">●パッケージ</h4>
<ul>
  <li>パッケージ (package) は複数のモジュールをまとめたもの</li>
  <li>Python のパッケージはディレクトリ (フォルダ) で管理する</li>
  <li>ディレクトリの中にファイル __init__.py を設置すれば、そのディレクトリがパッケージになる</li>
  <li>このとき、ディレクトリ名がパッケージ名になる</li>
  <li>ディレクトリと同様にパッケージも階層的な構造になる</li>
  <li>パッケージ内のモジュールは パッケージ1.パッケージ2.モジュール のようにドットを付けてアクセスする</li>
  <li>. (カレントパッケージ) と .. (親パッケージ) を使ってモジュールのパスを相対的に指定することもできる</li>
  <li>__init__.py はパッケージの初期化処理を記述する (空のファイルでもかまわない)</li>
  <li>たとえば、サブディレクトリ bar の中に __init__.py, foo.py, bar.py をセットする</li>
<pre>
C&gt;dir bar
C&gt;dir /B bar
bar.py
foo.py
__init__.py
</pre>
<pre>
&gt;&gt;&gt; import bar.foo, bar.bar
&gt;&gt;&gt; bar.foo.a
10
&gt;&gt;&gt; bar.foo.test()
module foo
&gt;&gt;&gt; bar.bar.a
100
&gt;&gt;&gt; bar.bar.test()
module bar
</pre>
  <li>もちろん from 文も使うことができる</li>
<pre class="item">
from パッケージ import モジュール, ...
from パッケージ.モジュール import 名前, ...
</pre>
<pre>
&gt;&gt;&gt; from bar import foo, bar
&gt;&gt;&gt; foo.a
10
&gt;&gt;&gt; foo.test()
module foo
&gt;&gt;&gt; bar.a
100
&gt;&gt;&gt; bar.test()
module bar
</pre>
<pre>
&gt;&gt;&gt; from bar.foo import a, test
&gt;&gt;&gt; a
10
&gt;&gt;&gt; test()
module foo
</pre>
  <li>from パッケージ import * でモジュールをインポートするときは __init__.py の変数 __all__ にモジュール名のリストをセットする</li>
<pre class="list">
リスト : __init__.py

__all__ = ["foo", "bar"]
</pre>
<pre>
&gt;&gt;&gt; from bar import *
&gt;&gt;&gt; foo.a
10
&gt;&gt;&gt; foo.test()
module foo
&gt;&gt;&gt; bar.a
100
&gt;&gt;&gt; bar.test()
module bar
</pre>
</ul>

<h4 id="abc10">●ファイル入出力</h4>
<ul>
  <li>標準入出力</li>
  <ul>
    <li>Python は「ファイルオブジェクト」というデータを介してファイルにアクセスする</li>
    <li>標準入出力は Python の起動時にファイルオブジェクトが自動的に生成される</li>
    <li>標準入出力に対応するファイルオブジェクトは、モジュール sys の変数に格納されている</li>
    <ul>
      <li>sys.stdin, 標準入力</li>
      <li>sys.stdout, 標準出力</li>
      <li>sys.stderr, 標準エラー出力</li>
    </ul>
    <li>関数 input() は標準入力から 1 行読み込む (改行文字は削除される)</li>
    <li>Python2 の raw_input() と同じ</li>
    <li>引数に文字列を渡すと、それをプロンプトとして表示する</li>
<pre>
&gt;&gt;&gt; input()
foo
'foo'
&gt;&gt;&gt; input()
1234
'1234'
&gt;&gt;&gt; input('&gt;&gt;&gt; ')
&gt;&gt;&gt; hello, world
'hello, world'
</pre>
    <li>関数 print() はデータを引数 file のファイルオブジェクトに出力する</li>
    <li>Python2 の print は文で、Python3 の print は関数</li>
<pre class="item">
print(*args, file=sys.stdout, sep=' ', end='\n', flush=False)
</pre>
    <li>複数のデータを渡すと、データとデータの間に引数 sep を挿入する</li>
    <li>print() はデータを出力したあと引数 end を出力する</li>
    <li>改行したくない場合は end に異なるデータ (たとえば空文字列など) を指定する</li>
<pre>
&gt;&gt;&gt; print('hello, world')
hello, world
&gt;&gt;&gt; print(1, 2, 3, 4, 5)
1 2 3 4 5
&gt;&gt;&gt; print(1, 2, 3, 4, 5, sep=',')
1,2,3,4,5
&gt;&gt;&gt; print(1, 2, 3, 4, 5, sep=',', end=' ')
1,2,3,4,5 &gt;&gt;&gt;
</pre>
  </ul>
  <li>ファイルのアクセス</li>
  <ul>
    <li>ファイルのオープン, open(filename, mode) =&gt; file_object</li>
    <li>mode はアクセスモードでＣ言語とほとんど同じ</li>
    <ul>
      <li>r, 読み込み (read) モード</li>  
      <li>w, 書き出し (write) モード</li>  
      <li>a, 追加 (append) モード</li>  
      <li>+ を付加すると更新モード</li>
      <li>b を付加するとバイナリモード</li>
    </ul>
    <li>mode を省略すると 'r' になる</li>
    <li>ファイルのクローズ, close(file_object)</li>
    <li>with 文を使うと、自動的にファイルをクローズすることができる</li>
<pre class="item">
with open(filename, mode) as 変数:
    処理
    ...
</pre>
    <li>open() で生成されたファイルオブジェクトは as の後ろの変数にセットされる</li>
    <li>with 文の処理を終了すると (エラーで抜ける場合も）ファイルはクローズされる</li>
    <li>with 文は <a href="pythonb03.html#abc17">例外処理</a> で説明する</li>
  </ul>
  <li>入出力用の主なメソッド</li>
  <ul>
    <li>read(size), size バイト読み込んで文字列にして返す</li>
    <ul>
      <li>size を省略するとファイル全体を読み込む</li>
    </ul>
    <li>readline(), 1 行読み込んで文字列にして返す (改行を含む)</li>
    <ul>
      <li>ファイルの終了は空文字列を返す</li>
    </ul>
    <li>readlines(), ファイルのすべての行を読み込んでリストに格納して返す</li>
    <li>write(s), 文字列 s をファイルに書き込む</li>
    <ul>
      <li>書き込んだ文字数を返す</li>
    </ul>
    <li>writelines(x), リスト x に格納された文字列をファイルに書き込む</li>
  </ul>
  <li>ファイルオブジェクトはイテレータ</li>
  <li>for 文 (または next()) で 1 行ずつ読み込むこともできる</li>
<pre>
&gt;&gt;&gt; with open('test.txt', 'w') as f:
...     for x in range(10):
...         f.write(str(x) + '\n')
...
2
2
2
2
2
2
2
2
2
2
&gt;&gt;&gt; with open('test.txt') as f:
...     for x in f: print(x, end='')
...
0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt; a = ['foo\n', 'bar\n', 'baz\n', 'oops\n']
&gt;&gt;&gt; with open('test1.txt', 'w') as f: f.writelines(a)
...
&gt;&gt;&gt; with open('test1.txt') as f: f.readlines()
...
['foo\n', 'bar\n', 'baz\n', 'oops\n']
</pre>
  <li>Python の場合、モジュール sys の変数 argv にコマンドラインで与えられた引数が格納される</li>
<pre class="list">
リスト : コマンドライン引数 (test01.py)

import sys

print(sys.argv)
</pre>
<pre>
C&gt;python test01.py foo bar baz
['test01.py', 'foo', 'bar', 'baz']
</pre>
  <li>リストの先頭要素は実行したスクリプト test01.py になる</li>
</ul>
<h4 id="abc11">●文字列のフォーマット</h4>
<ul>
  <li>データを整形して出力する場合、Python2 ではＣ言語によく似た書式指定を用いるが、Python3 では推薦されていない</li>
  <li>Python3 にはいくつか方法があるが、ここでは str.format() を紹介する</li>
<pre class="item">
書式文字列.format(引数, ...)
</pre>
  <li>書式文字列の {} は format() の引数を文字列に変換する</li>
  <li>{n} とすると n 番目の引数を変換する</li>
  <li>{:変換指示子}</li>
  <ul>
    <li>{:b}, 2 進数表示</li>
    <li>{:o}, 8 進数表示</li>
    <li>{:d}, 10 進数表示</li>
    <li>{:x}, {:X}, 16 進数表示 (英小文字, 英大文字)</li>
    <li>{:#}, 引数が整数で指示子が b, o, x, X の場合、接頭辞 (0b, 0o, 0x, 0X) を付ける</li>
    <li>{:e}, {:E}, 指数表示 (英小文字, 英大文字)</li>
    <li>{:f}, {:F}, 小数点表示</li>
    <li>{:g}, {:G}, 汎用フォーマット (桁数に応じて {:e} または {:f} で表示)</li>
    <li>{:c}, 文字 (数値を対応する文字 (Unicode) に変換する)</li>
    <li>{:s}, 文字列 (デフォルト値)</li>
  </ul>
  <li>: と変換指示子の間に桁数などを指定することができる</li>
  <ul>
    <li>{:n}, n 桁表示</li>
    <li>引数が数値の場合、以下のオプションがある</li>
    <ul>
      <li>{:0n}, 空欄を 0 で埋める</li>
      <li>{:.mf}, {:n.mf}, 小数点以下を m 桁表示</li>
      <li>{:+}, 先頭に符号 (+, -) を付ける</li>
      <li>{:-}, 負数の場合符号 - を付ける</li>
      <li>{: }, 正数の場合は空白を、負数の場合は符号 - を付ける</li>
    </ul>
    <li>{:&lt;n}, 左詰め</li>
    <li>{:&gt;n}, 右詰め</li>
    <li>{:^n}, 中央</li>
    <li>&lt;, &gt; ^ の前に文字を指定すると、空欄をその文字で埋める</li>
  </ul>
  <li>この他にもいろいろな機能がある</li>
  <li>詳細はライブラリリファレンス <a href="https://docs.python.jp/3/library/string.html#formatstrings">書式指定文字列の文法</a> を参照</li>
<pre>
&gt;&gt;&gt; '{} {} {}'.format(1, 2, 3)
'1 2 3'
&gt;&gt;&gt; '{1} {2} {0}'.format(1, 2, 3)
'2 3 1'
&gt;&gt;&gt; for x in range(16): print('{} {:b} {:o} {:x}'.format(x,x,x,x))
...
0 0 0 0
1 1 1 1
2 10 2 2
3 11 3 3
4 100 4 4
5 101 5 5
6 110 6 6
7 111 7 7
8 1000 10 8
9 1001 11 9
10 1010 12 a
11 1011 13 b
12 1100 14 c
13 1101 15 d
14 1110 16 e
15 1111 17 f
&gt;&gt;&gt; '{:e} {:f} {:g}'.format(1.2345, 1.2345, 1.2345)
'1.234500e+00 1.234500 1.2345'
&gt;&gt;&gt; '{:e} {:f} {:g}'.format(1.2345e10, 1.2345e10, 1.2345e10)
'1.234500e+10 12345000000.000000 1.2345e+10'
&gt;&gt;&gt; '{:9}'.format('abc')
'abc      '
&gt;&gt;&gt; '{:&lt;9}'.format('abc')
'abc      '
&gt;&gt;&gt; '{:&gt;9}'.format('abc')
'      abc'
&gt;&gt;&gt; '{:^9}'.format('abc')
'   abc   '
</pre>
</ul>
<h4 id="abc12">●簡単なプログラム (2)</h4>
<ul>
  <li>ファイルの連結</li>
<pre class="list">
リスト : cat.py 

import sys

def cat(filename):
    with open(filename) as f:
        for xs in f: print(xs, end='')

if len(sys.argv) &gt;= 2:
    for filename in sys.argv[1:]:
        cat(filename)
else:
    print('usage: python3 cat.py file ...')
</pre>
  <li>行の連結</li>
<pre class="list">
リスト paste.py

import sys

def output(f):
    for xs in f: print(xs, end='')

def paste(f1, f2):
    while True:
        xs = f1.readline().rstrip('\n')
        ys = f2.readline().rstrip('\n')
        if xs and ys:
            print(xs, ys)
        elif xs:
            print(xs)
            output(f1)
            break
        else:
            print(ys)
            output(f2)
            break

if len(sys.argv) &gt;= 3:
    with open(sys.argv[1]) as f1:
        with open(sys.argv[2]) as f2:
            paste(f1, f2)
else:
    print('usage: python3 paste.py file1 file2')
</pre>
  <ul>
    <li>改行は文字列のメソッド rstrip('\n') で削除できる</li>
    <li>拙作のページ <a href="python04.html#chap03">Python 入門 第 3 回: 文字の除去</a> を参照</li>
  </ul>
  <li>単語のカウント</li>
<pre class="list">
リスト : wc.py

import sys

def wc (fin, filename=''):
    size = 0
    word = 0
    line = 0
    for xs in fin:
        size += len(xs.encode())
        line += 1
        word += len(xs.split())
    print(line, word, size, filename)

if len(sys.argv) &lt;= 1:
    wc(sys.stdin)
else:
    with open(sys.argv[1]) as f:
        wc(f, sys.argv[1])
</pre>
  <ul>
    <li>Python3 の場合、文字列 str に len() を適用すると文字数が返る (python2 はバイト数)</li>
    <li>バイト数を求めたい場合はバイトオブジェクト (bytes) に変換する</li>
    <li>bytes はバイトシーケンスを表すデータ型</li>
    <li>bytes は b'...' のように文字列リテラルの前に b を付ける</li>
    <li>メソッド str.encode(encoding='utf-8') は文字列 str を bytes に変換する</li>
    <li>メソッド bytes.decode(encoding='utf-8') は bytes を str に変換する</li>
<pre>
&gt;&gt;&gt; a = 'あいうえお'
&gt;&gt;&gt; b = a.encode()
&gt;&gt;&gt; b
b'\xe3\x81\x82\xe3\x81\x84\xe3\x81\x86\xe3\x81\x88\xe3\x81\x8a'
&gt;&gt;&gt; b.decode()
'あいうえお'
</pre>
    <li>str.split() は文字列 str を区切り記号で分解し、リストに格納して返す</li>
    <li>拙作のページ <a href="python04.html#chap04">Python 入門 第 3 回: 文字列の分解と結合</a> を参照</li>
  </ul>
  <li>タブを空白に展開</li>
<pre class="list">
リスト : expand.py

import sys

def expand(f):
    col = 0
    while True:
        c = f.read(1)
        if c == '': break
        if c == '\t':
            while True:
                sys.stdout.write(' ')
                col += 1
                if col % 8 == 0: break
        else:
            if c == '\n':
                col = 0
            else:
                col += 1
            sys.stdout.write(c)

def expand1(f):
    pat = re.compile(b'\t+')
    for xs in f:
        xs = xs.encode()
        while True:
            m = pat.search(xs)
            if not m: break
            n = (m.end() - m.start()) * 8 - m.start() % 8
            xs = pat.sub(b' ' * n, xs, 1)
        print(xs.decode(), end='')

if len(sys.argv) &gt; 1:
    with open(sys.argv[1]) as f:
        expand1(f)
else:
    expand1(sys.stdin)
</pre>
  <ul>
    <li>ASCII コードのみ対応</li>
    <li>関数 expand() は read() と write() を使って 1 byte ずつデータを読み書きしている</li>
    <li>あまり Python らしくないプログラム</li>
    <li>関数 expand1() は 1 行ずつ読み込み、正規表現を使ってタブを展開している</li>
  </ul>
  <li>空白をタブに置換</li>
<pre class="list">
リスト : unexpand.py

import sys

def unexpand(f):
    col = 0
    while True:
        sc = 0
        c = f.read(1)
        if c == '': break
        if c == ' ':
            while True:
                sc += 1
                col += 1
                if col % 8 == 0:
                    sys.stdout.write('\t')
                    sc = 0
                c = f.read(1)
                if c != ' ': break
        for _ in range(sc): sys.stdout.write(' ')
        if c == '\n':
            col = 0
        else:
            col += 1
        sys.stdout.write(c)

def unexpand1(f):
    pat = re.compile(b' +$')
    for xs in f:
        xs = xs.rstrip('\n')
        xs = xs.encode()
        i = 0
        while i &lt; len(xs):
            ys = xs[i : i + 8]
            if len(ys) == 8:
                print(pat.sub(b'\t', ys).decode(), end='')
            else:
                print(ys.decode())
            i += 8

if len(sys.argv) &gt; 1:
    with open(sys.argv[1]) as f:
        unexpand1(f)
else:
    unexpand1(sys.stdin)
</pre>
  <ul>
    <li>ASCII コードのみ対応</li>
    <li>関数 unexpand() は read() と write() を使って 1 byte ずつデータを読み書きしている</li>
    <li>あまり Python らしくないプログラム</li>
    <li>関数 unexpand1() は 1 行ずつ読み込み、正規表現を使って空白をタブに置換している</li>
  </ul>
  <li>文字列の検索</li>
<pre class="list">
リスト : grep.py

import sys, re

if len(sys.argv) &gt;= 3:
    p = re.compile(sys.argv[1])
    with open(sys.argv[2]) as f:
        n = 1
        for x in f:
            if p.search(x): print('{:6}: {}'.format(n, x), end='')
            n += 1
else:
    print('usage: python3 grep.py str file')
</pre>
  <ul>
    <li>正規表現は拙作のページ <a href="python04.html">Python 入門 第 3 回</a> を参照</li>
  </ul>
  <li>文字列の置換</li>
<pre class="list">
リスト : gres.py

import sys, re

if len(sys.argv) &gt;= 4:
    pat1 = re.compile(sys.argv[1])
    pat2 = sys.argv[2]
    with open(sys.argv[3]) as f:
        for x in f:
            print(pat1.sub(pat2, x), end='')
else:
    print('usage: python3 gres.pl search replace file')
</pre>
  <ul>
    <li>正規表現による文字列の置換は、拙作のページ <a href="python04.html#chap20">Python 入門 第 3 回: 文字列の置換</a> を参照</li>
  </ul>
  <li>ファイルのエントロピー</li>
<pre class="list">
リスト : entoropy.py

def entoropy(name):
    count = [0] * 256
    with open(name, "rb") as f:
        while True:
            c = f.read(1)
            if not c: break
            count[ord(c)] += 1
    total = float(sum(count))
    e = 0.0
    for x in range(256):
        if not count[x]: continue
        p = count[x] / total
        e += - p * math.log(p, 2)
    return e, e * total / 8

if len(sys.argv) &gt; 1:
    print(entoropy(sys.argv[1]))
else:
    print('usage: python3 enotropy.py file')
</pre>
  <ul>
    <li>ファイルのエントロピーを計算するプログラム</li>
    <li>エントロピーは拙作のページ <a href="index.html#python_algo">Algorithms with Python</a> <a href="pyalgo31.html">シャノン・ファノ符号とハフマン符号</a> を参照</li>
  </ul>
  <li>ランレングス符号化</li>
<pre class="list">
リスト : rle.py

import sys

def rle(fin, fout):
    c = fin.read(1)
    while c:
        num = 1
        while num &lt; 256:
            c1 = fin.read(1)
            if c != c1: break
            num += 1
        fout.write(c)
        fout.write((num - 1).to_bytes(1, 'big'))
        if num == 256:
            c = fin.read(1)
        else:
            c = c1
  
if len(sys.argv) &gt; 2:
    with open(sys.argv[1], 'rb') as fin:
        with open(sys.argv[2], 'wb') as fout:
            rle(fin, fout)
else:
    print('usage: python3 rle.py input_file output_file')
</pre>
  <ul>
    <li>ランレングス符号については拙作のページ <a href="index.html#python_algo">Algorithms with Python</a> <a href="pyalgo29.html">連長圧縮</a> を参照</li>
    <li>ファイルがバイナリモードでオープンされている場合、write() の引数は文字列ではなく bytes-like object であること</li>
    <li>整数値を bytes に変換するにはメソッド to_bytes() を使う</li>
    <li>逆に、bytes を整数値に変換するには整数 (int) のクラスメソッド from_bytes() を使う</li>
<pre class="item">
num.to_bytes(length, byteorder)
int.from_bytes(bytes, byteorder)
</pre>
    <li>byteorder は 'big' (ビッグエンディアン) または 'little' (リトルエンディアン)</li>
<pre>
&gt;&gt;&gt; a = 97
&gt;&gt;&gt; a.to_bytes(1, 'big')
b'a'
&gt;&gt;&gt; int.from_bytes(b'a', 'big')
97
</pre>
  </ul>
  <li>ランレングス復号</li>
<pre class="list">
リスト : rld.py

import sys

def rld(fin, fout):
    while True:
        c = fin.read(1)
        if not c: break
        n = ord(fin.read(1)) + 1
        for _ in range(n): fout.write(c)

if len(sys.argv) &gt; 2:
    with open(sys.argv[1], 'rb') as fin:
        with open(sys.argv[2], 'wb') as fout:
            rld(fin, fout)
else:
    print('usage: python3 rld.py input_file output_file')
</pre>
</ul>
<h4 id="abc13">●クラス</h4>
<ul>
  <li>クラスの定義</li>
  <ul>
    <li>クラスは class 文で定義する</li>
<pre class="item">
class ClassName(SuperClass, ...):
    処理
    ...
</pre>
    <li>他のクラスを「継承」するときはカッコの中にクラス名を記述する</li>
    <li>継承しない場合はカッコを省略することができる</li>
    <li>省略すると、クラス object が暗黙のうちに継承される</li>
<pre>
&gt;&gt;&gt; class Foo:
...     pass
...
&gt;&gt;&gt; a = Foo()
&gt;&gt;&gt; a
&lt;__main__.Foo object at 0x0000022A4216DBA8&gt;
&gt;&gt;&gt; a.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Foo' object has no attribute 'x'
&gt;&gt;&gt; a.x = 123
&gt;&gt;&gt; a.x
123
</pre>
    <li>pass は何もしないことを表す文</li>
    <li>Python はクラスを関数と同じ形式で呼び出すと、そのクラスのインスタンス (オブジェクト) を生成して返す</li>
    <li>Python には class 文でインスタンス変数を定義する特別な構文はない</li>
    <li>変数への代入が行われると、Python はその変数をインスタンス内に生成する</li>
    <li>変数のアクセスは obj.name のようにドットを使う</li>
  </ul>
  <li>メソッドの定義</li>
  <ul>
    <li>Python の場合、class 文の中で定義された関数がメソッドになる</li>
    <li>メソッドの第 1 引数にはインスタンスが渡される</li>
    <li>Python では、この引数名を self と記述する習慣がある</li>
<pre>
&gt;&gt;&gt; import math
&gt;&gt;&gt; class Point:
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     def distance(self, p):
...         dx = self.x - p.x
...         dy = self.y - p.y
...         return math.sqrt(dx * dx + dy * dy)
...
&gt;&gt;&gt; p1 = Point(0, 0)
&gt;&gt;&gt; p2 = Point(10, 10)
&gt;&gt;&gt; p1.x
0
&gt;&gt;&gt; p2.y
10
&gt;&gt;&gt; p1.distance(p2)
14.142135623730951
</pre>
    <li>__ で始まり __ で終わる名前のメソッドには特別な機能が割り当てられる</li>
    <li>これを「特殊メソッド」という</li>
    <li>__init__() はインスタンスを生成するときに自動的に呼び出される特殊メソッド</li>
    <li>Python では __init__() で必要なインスタンス変数を初期化するのが一般的</li>
    <li>メソッドのアクセスはインスタンス変数と同じ形式で、メソッド名の後ろにカッコを付けて呼び出す</li>
  </ul>
  <li>ポリモーフィズム</li>
  <ul>
    <li>obj.method() は obj が属するクラスに定義されているメソッドを呼び出す</li>
<pre>
&gt;&gt;&gt; class Point3d:
...     def __init__(self, x, y, z):
...         self.x = x
...         self.y = y
...         self.z = z
...     def distance(self, p):
...         dx = self.x - p.x
...         dy = self.y - p.y
...         dz = self.z - p.z
...         return math.sqrt(dx * dx + dy * dy + dz * dz)
...
&gt;&gt;&gt; p3 = Point3d(0, 0, 0)
&gt;&gt;&gt; p4 = Point3d(10, 10, 10)
&gt;&gt;&gt; p3.distance(p4)
17.320508075688775
&gt;&gt;&gt; p1.distance(p2)
14.142135623730951
</pre>
    <li>Point と Point3d には同じ名前のメソッド distance() がある</li>
    <li>p3 は Point3d のインスタンスなので、p3.distance(p4) は Point3d の distance() が呼び出される</li>
    <li>p1 は Point のインスタンスなので、p1.distance(p2) は Point の distance() が呼び出される</li>
    <li>このように、ドットの左側のインスタンスによって適切なメソッドが呼び出される</li>
    <li>このような機能を「ポリモーフィズム」という</li>
    <li>ポリモーフィズムはオブジェクト指向にとってとても重要な機能</li>
  </ul>
  <li>クラス変数</li>
  <ul>
    <li>クラスで共通の変数や定数を使いたい場合は、class 文の中で変数を定義する</li>
    <li>これを「クラス変数」という</li>
    <li>クラス変数は クラス名 + ドット ( . ) + 変数名 でアクセスする</li>
<pre>
&gt;&gt;&gt; class Foo:
...     z = 1
...
&gt;&gt;&gt; Foo.z
1
&gt;&gt;&gt; Foo.z = 10
&gt;&gt;&gt; Foo.z
10
&gt;&gt;&gt; a = Foo()
&gt;&gt;&gt; b = Foo()
&gt;&gt;&gt; a.z
10
&gt;&gt;&gt; b.z
10
</pre>
    <li>クラス変数はインスタンスからも参照することができる</li>
    <li>ただし、同名のインスタンス変数があると、インスタンスからクラス変数を参照することはできない</li>
<pre>
&gt;&gt;&gt; a.z = 100
&gt;&gt;&gt; b.z
10
&gt;&gt;&gt; Foo.z
10
&gt;&gt;&gt; a.z
100
</pre>
    <li>a.z = 100 はインスタンス変数 z に 100 を代入する</li>
    <li>b.z, Foo.z はクラス変数 z を参照するので 10 のまま</li>
    <li>a.z はインスタンス変数 z を参照するので 100 になる</li>
  </ul>
  <li>クラスメソッド</li>
  <ul>
    <li>今まで定義したメソッドはインスタンスを操作する</li>
    <li>これを「インスタンスメソッド」という</li>
    <li>これに対し、クラスの動作にかかわるメソッドを定義することもできる</li>
    <li>これを「クラスメソッド」という</li>
    <li>クラスメソッドの定義はデコレータ @classmethod を使う</li>
<pre>
&gt;&gt;&gt; class Foo:
...     z = 1
...     @classmethod
...     def get_z(cls): return cls.z
...     @classmethod
...     def set_z(cls, x): cls.z = x
...
&gt;&gt;&gt; Foo.get_z()
1
&gt;&gt;&gt; Foo.set_z(10)
&gt;&gt;&gt; Foo.get_z()
10
</pre>
    <li>メソッド get_z(), set_z() の前に @classmethod を書くだけ</li>
    <li>第 1 引数の cls にドットの左側のクラスが渡される</li>
  </ul>
  <li>Python では、インスタンス変数やクラス変数、メソッドのことを「属性 (attribute)」という</li>
  <li>属性は名前で管理されていて、同じ名前のインスタンス変数とメソッドを同時に使うことはできない</li>
  <li>インスタンス変数の方が優先されるため、メソッドを呼び出すことができなくなる</li>
  <li>インスタンス変数はクラス変数やメソッドよりも優先されることに注意</li>
</ul>
<h4 id="abc14">●継承</h4>
<ul>
  <li>「継承 (inheritance : インヘリタンス)」は簡単に言うとクラスに「親子関係」を持たせる機能</li>
  <li>子供のクラス (サブクラス) は親クラス (スーパークラス) の性質を受け継ぐことができる</li>
  <li>プログラミング言語の場合、引き継ぐ性質は定義されたインスタンス変数やメソッドになる</li>
  <li>ただし、Python ではインスタンス変数の継承は行われない</li>
  <li>継承されるのはメソッドとクラス変数だけなので注意すること</li>
  <li>スーパークラスは class 文のカッコで指定する</li>
  <li>ただ一つのクラスを継承することを「単一継承」、複数のクラスを継承することを「多重継承」という</li>
  <li>Python は多重継承をサポートしているので、カッコ内に複数のスーパークラスを指定することができる</li>
  <li>多重継承はあとで説明する</li>
<pre>
&gt;&gt;&gt; class Foo:
...     def __init__(self, a, b):
...         self.a = a
...         self.b = b
...     def get_a(self): return self.a
...     def get_b(self): return self.b
...
&gt;&gt;&gt; class Bar(Foo):
...     def __init__(self, a, b, c):
...         super().__init__(a, b)
...         self.c = c
...     def get_c(self): return self.c
...
&gt;&gt;&gt; a = Foo(1, 2)
&gt;&gt;&gt; b = Bar(10, 20, 30)
&gt;&gt;&gt; a.get_a()
1
&gt;&gt;&gt; b.get_a()
10
&gt;&gt;&gt; a.get_b()
2
&gt;&gt;&gt; b.get_b()
20
&gt;&gt;&gt; b.get_c()
30
</pre>
  <li>クラス Foo にはインスタンス変数 a, b とメソッド get_a(), get_b() が定義されている</li>
  <li>Bar は Foo を継承し、Bar 固有のインスタンス変数 c とメソッド get_c() を定義する</li>
  <li>クラス Foo を継承することにより、メソッド get_a() と get_b() を利用することができる</li>
  <li>サブクラスでスーパークラスのメソッドと同名のメソッドを定義することができる</li>
  <li>これを「オーバーライド (over ride))」という</li>
  <li>オーバーライドしたメソッドからスーパークラスのメソッドを呼び出すときは super() を使う</li>
<pre class="item">
super().method(args, ...)
</pre>
  <li>super() はスーパークラスの method() を呼び出す</li>
  <li>このとき、method() の第 1 引数 (self) には、オーバーライドしたメソッドの self が渡される</li>
  <li>super().__init__(a, b) とすることで、Foo のメソッド __init__() を呼び出すことができる</li>
  <li>__init__() をオーバーライドしない場合、スーパークラスの __init__() が自動的に呼び出される</li>
<pre>
&gt;&gt;&gt; class Bar1(Foo):
...     def get_c(self): return self.a + self.b
...
&gt;&gt;&gt; c = Bar1(100, 200)
&gt;&gt;&gt; c.get_c()
300
</pre>
  <li>クラス Bar1 は __init__() をオーバーライドしていない</li>
  <li>Bar1 のインスタンスを生成すると、Foo の __init__() が呼び出されて a と b が初期化される</li>
  <li>メソッド get_c() を呼び出すと a と b を足した値を返す</li>
  <li>クラス変数は継承される</li>
<pre>
&gt;&gt;&gt; class Foo:
...     z = 1
...
&gt;&gt;&gt; class Bar(Foo):
...     pass
...
&gt;&gt;&gt; Foo.z
1
&gt;&gt;&gt; Bar.z
1
</pre>
  <li>Bar.z で Foo のクラス変数 z を参照できる</li>
  <li>Bar.z に代入すると、Bar にクラス変数 z が生成されるため、Foo のクラス変数 z は参照できなくなる</li>
  <li>インスタンスの型は関数 isinstance() で、クラスの継承関係は関数 issubclass() で調べることができる</li>
<pre class="item">
isinstance(object, cls) =&gt; bool
issubclass(cls1, cls2) =&gt; bool
</pre>
  <li>isinstance() は object のクラスが cls または cls のサブクラスであれば真を返す</li>
  <li>issubclass() は cls1 が cls2 のサブクラスであれば真を返す</li>
<pre>
&gt;&gt;&gt; class Foo: pass
...
&gt;&gt;&gt; class Bar(Foo): pass
...
&gt;&gt;&gt; class Baz(Bar): pass
...
&gt;&gt;&gt; a = Foo()
&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; c = Baz()
&gt;&gt;&gt; isinstance(c, Foo)
True
&gt;&gt;&gt; isinstance(c, Bar)
True
&gt;&gt;&gt; isinstance(c, Baz)
True
&gt;&gt;&gt; isinstance(b, Baz)
False
&gt;&gt;&gt; issubclass(Baz, Foo)
True
&gt;&gt;&gt; issubclass(Bar, Baz)
False
</pre>
</ul>
<h4 id="abc15">●連結リスト</h4>
<p> クラスと継承の簡単な例題として、「連結リスト」とそれを継承した「制限付き連結リスト」を作成します。詳しい説明は拙作のページ <a href="python05.html#chap11">Python 入門第 5 回: 連結リスト</a> と <a href="python06.html#chap08">Python 入門第 6 回: 制限付きリスト</a> をお読みください。
</p>
<table border=1>
<caption>表 : クラス LinkedList のメソッド</caption>
<thead>
  <tr><td>名前</td><td>機能</td></tr>
</thead>
<tbody>
  <tr><td>LinkedList(*args)</td><td>LinkedList の生成</td></tr>
  <tr><td>ls.insert(n, x)</td><td>連結リスト ls の n 番目に x を挿入する</td></tr>
  <tr><td>ls.at(n)</td><td>連結リスト ls の n 番目の要素を参照する</td></tr>
  <tr><td>ls.delete(n)</td><td>連結リスト ls の n 番目の要素を削除</td></tr>
  <tr><td>ls.is_empty()</td><td>連結リスト ls が空であれば真を返す</td></tr>
  <tr><td>len(ls)</td><td>連結リストの長さ (要素数)</td></tr>
  <tr><td>ls[n], ls[n] = x, del ls[n]</td><td>連結リスト ls の n 番目の要素の参照, 更新, 削除</td></tr>
  <tr><td>ls1 + ls2</td><td>連結リストの連結</td></tr>
  <tr><td>ls.each()</td><td>ジェネレータ</td></tr>
  <tr><td>iter(), next()</td><td>イテレータ</td></tr>
  <tr><td>str(), repr()</td><td>文字列に変換</td></tr>
</tbody>
</table>
<ul>
  <li>Python3 の場合、イテレータは特殊メソッド __iter__() と __next__() を実装すること</li>
  <li>Python2 は __iter__() と next() だった</li>
  <li>特殊メソッド __repr__() を実装すると、関数 repr() を使用できる</li>
  <li>対話モードで連結リストを表示できるようになる</li>
</ul>
<table border=1>
<caption>表 : クラス FixedList のメソッド</caption>
<thead>
  <tr><td>名前</td><td>機能</td></tr>
</thead>
<tbody>
  <tr><td>FixedList(size, *args)</td><td>大きさ size の FixedList を生成する</td></tr>
  <tr><td>ls.insert(n, x)</td><td>n 番目に x を挿入, 挿入できない場合は None を返す</td></tr>
  <tr><td>ls.delete(n, x)</td><td>n 番目の要素を削除する</td></tr>
  <tr><td>str(), repr()</td><td>文字列に変換</td></tr>
</tbody>
</table>
<pre class="list">
#
# linkedlist.py : 連結リスト
#
#                 Copyright (C) 2018 Makoto Hiroi
#

# 連結リストクラス
class LinkedList:
    # セル
    class Cell:
        def __init__(self, data, link = None):
            self.data = data
            self.link = link

    # 連結リストの初期化
    def __init__(self, *args):
        self.top = LinkedList.Cell(None)   # ヘッダセル
        for x in reversed(args):
            self.insert(0, x)

    # n 番目のセルを求める
    def _nth(self, n):
        i = -1
        cp = self.top
        while cp is not None:
            if i == n: return cp
            i += 1
            cp = cp.link
        return None
    
    # 挿入
    def insert(self, n, x):
        cp = self._nth(n - 1)
        if cp is not None:
            cp.link = LinkedList.Cell(x, cp.link)
            return x
        return None

    # 参照
    def at(self, n):
        cp = self._nth(n)
        if cp is not None: return cp.data
        return None

    # 削除
    def delete(self, n):
        cp = self._nth(n - 1)
        if cp is not None and cp.link is not None:
            data = cp.link.data
            cp.link = cp.link.link
            return data
        return None

    # リストは空か
    def is_empty(self): return self.top.link is None

    # イテレータ
    def __iter__(self):
        self.index = self.top.link
        return self

    def __next__(self):
        if self.index is None:
            raise StopIteration
        data = self.index.data
        self.index = self.index.link
        return data

    # ジェネレータ
    def each(self):
        cp = self.top.link
        while cp is not None:
            yield cp.data
            cp = cp.link

    # リストの長さ
    def __len__(self):
        n = 0
        for _ in self.each(): n += 1
        return n

    # [] による参照
    def __getitem__(self, n):
        cp = self._nth(n)
        if cp is not None: return cp.data
        raise IndexError

    # [] による更新
    def __setitem__(self, n, x):
        cp = self._nth(n)
        if cp is not None:
            cp.data = x
            return None
        raise IndexError

    # del []
    def __delitem__(self, n):
        if self.delete(n) is None: raise IndexError

    # +
    def __add__(self, y):
        # リストのコピー
        def copy(a):
            if not a: return None
            return LinkedList.Cell(a.data, copy(a.link))
        # リストの連結
        def append(a, b):
            if a is None: return copy(b)
            return LinkedList.Cell(a.data, append(a.link, b))
        
        if not isinstance(y, LinkedList):
            raise NotImplementedError
        z = LinkedList()
        z.top.link = append(self.top.link, y.top.link)
        return z

    # 表示
    def __repr__(self):
        if self.top.link is None: return 'LinkedList()'
        s = 'LinkedList('
        for x in self.each(): s += '{}, '.format(x)
        return s[:-2] + ')'

    def __str__(self):
        return self.__repr__()

#
# 制限付き連結リスト
#
class FixedList(LinkedList):
    def __init__(self, limit, *args):
        self.limit = limit
        self.size = 0
        super().__init__(*args[:limit])

    # データの挿入
    def insert(self, n, x):
        if self.size &lt; self.limit:
            result = super().insert(n, x)
            if result is not None: self.size += 1
            return result
        return None

    # データの削除
    def delete(self, n):
        if self.size &gt; 0:
            result = super().delete(n)
            if result is not None: self.size -= 1
            return result
        return None

    # 表示
    def __repr__(self):
        if self.top.link is None: return 'FixedList({})'.format(self.limit)
        s = 'FixedList({}, '.format(self.limit)
        for x in self.each(): s += '{}, '.format(x)
        return s[:-2] + ')'

    def __str__(self):
        return self.__repr__()
        
# 簡単なテスト
if __name__ == '__main__':
    a = LinkedList()
    print(a)
    print(len(a))
    print(a.is_empty())
    for x in range(5): a.insert(x, x)
    print(a)
    print(len(a))
    print(a.is_empty())
    for x in range(5):
        print(a.at(x), a[x])
    for x in range(5):
        a[x] = a[x] * 10
    for x in a:
        print(x)
    for x in a.each():
        print(x)
    while not a.is_empty():
        # a.delete(0)
        del a[0]
    print(a)
    a = LinkedList(1,2,3,4,5)
    b = LinkedList(6,7,8,9,10)
    c = a + b
    print(a)
    print(b)
    print(c)
    c[0] = 10
    c[5] = 60
    print(a)
    print(b)
    print(c)

    # 制限付き連結リスト
    d = FixedList(5)
    print(d)
    for x in range(6):
        print(d.insert(0, x))
    print(d)
    while not d.is_empty():
        print(d.delete(0))
    print(d)
</pre>
<pre>
C&gt;python linkedlist.py
LinkedList()
0
True
LinkedList(0, 1, 2, 3, 4)
5
False
0 0
1 1
2 2
3 3
4 4
0
10
20
30
40
0
10
20
30
40
LinkedList()
LinkedList(1, 2, 3, 4, 5)
LinkedList(6, 7, 8, 9, 10)
LinkedList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
LinkedList(1, 2, 3, 4, 5)
LinkedList(6, 7, 8, 9, 10)
LinkedList(10, 2, 3, 4, 5, 60, 7, 8, 9, 10)
FixedList(5)
0
1
2
3
4
None
FixedList(5, 4, 3, 2, 1, 0)
4
3
2
1
0
FixedList(5)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#python3_abc">Python3</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>