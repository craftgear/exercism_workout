<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Python プログラミング入門</title>
  <meta name="description" content="Python,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881792</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Lightweight Language</h1>
<h2>お気楽 Python プログラミング入門</h2>
<h3>第 1 回 データ型と制御構造</h3>
<div class="small">
[ PrevPage | <a href="index.html#python_abc">Python</a> | <a href="python02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">はじめに</h3>
<p> Python (パイソン) は Guido van Rossum によって開発されたオブジェクト指向スクリプト言語です。現時点でもっとも普及しているスクリプト言語は Perl になるでしょう。日本では知名度の低い Python ですが、海外では Perl の次に人気のあるスクリプト言語として広く普及しています。
</p>
<p> Perl はバージョン 5 から「オブジェクト指向」や「リファレンス」など高度な機能が追加され、汎用のプログラミング言語として様々な分野で使われるようになりました。しかしながら、これらの機能が追加されたことにより、Perl はよりいっそう複雑な言語になってしまったように思います。
</p>
<p> これに対し Python は、文字列、リスト、タプル、ディクショナリといった高水準のデータ型や、オブジェクト指向機能、モジュール機能、例外処理など高度な機能をサポートしていながら、シンプルでわかりやすいプログラミング言語になっています。実際、これらの機能は Perl よりも使いやすいと思います。このため、プログラミング入門に Python を勧める方も多いようです。
</p>
<p> また、Python はスクリプトだけではなく、大規模なソフトウェア開発にも対応できる実用的な言語として使用することができます。多くのライブラリが標準で添付されているので、複雑な処理でもライブラリを使って簡単にプログラムを実装することができます。ライブラリの充実ぶりは Perl に勝るとも劣らないと思います。
</p>
<p> そして、ブロック構造を表すのにインデント（字下げ）を用いるのが最大の特徴でしょう。Ｃ言語や Perl のように { ... } でブロックを表すのではなく、インデントの深さでブロックを表します。好き嫌いが分かれるところですが、誰が書いても同じようなプログラムになるので、可読性が高くなるという利点があります。慣れてしまえば問題はありません。
</p>
<p> このように、高いポテンシャルを持つ Python ですが、日本ではあまり普及していません。近年、コンピュータの性能は著しく向上しているので、大きなプログラムをスクリプト言語で開発する機会はこれからも増えていくことでしょう。プログラムの保守性を考えると、可読性の高い Python は Perl よりも有利であり、今後は日本でも普及が進むものと思われます。
</p>
<p> 本連載では、簡単なプログラムを作りながら Python の基本からオブジェクト指向機能まで、プログラミング言語としての Python の機能を一通り説明していきたいと思っております。よろしくお付き合いください。
</p>
<h4 id="chap02">●Python のインストールと起動</h4>
<p> Python の処理系は <a href="http://www.python.org/">Python Programming Language</a> や <a href="http://www.python.jp/Zope/">Python Japan User's Group</a> からダウンロードできます。Windows 用のインストーラも用意されているので簡単にインストールすることができます。
</p>
<p> Python がインストールされていれば、シェル (Windows の場合はコマンドプロンプト) で python と入力します。または、Python に付属している GUI アプリケーション IDLE を起動してください。すると、メッセージとプロンプト '&gt;&gt;&gt;' が表示され、対話モードで Python が起動されます。Python を終了するには Ctrl + D (Windows の場合は Ctrl + Z) を入力してください。
</p>

<h4 id="chap03">●Python のプログラム</h4>
<p> Python は Perl やＣ言語と同じく、手続き型のプログラミング言語です。Python も Perl と同様に、プログラムの実行を制御する「文」、データを格納する「変数」、決められた処理を行う「関数」があります。
</p>
<p> Ｃ言語や Perl は文の最後をセミコロン ( ; ) で区切りますが、Python はセミコロンを付ける必要はありません。関数は Python にあらかじめ用意されている「組み込み関数」のほかに、私達ユーザが定義することもできます。もちろん「再帰呼び出し」も可能です。
</p>
<p> Python にはいろいろなデータが用意されています。データの種類を「データ型」と呼びます。Python の場合、基本的なデータ型には「数」と「文字列」があります。高水準なデータ型として「リスト」、「タプル」、「ディクショナリ」、「セット」があります。
</p>
<p> また、Python はオブジェクト指向プログラミング (OOP) に対応しているので、「クラス」、「インスタンス」、「メソッド」、「継承」など OOP 的な機能があります。このほかに「モジュール機能」や「例外処理」といった高度な機能もサポートされています。
</p>
<p> Python のプログラムで使用される変数名、関数名などには、英数字とアンダースコア _ が使えます。英大文字と英小文字は区別されるので、FOO と Foo と foo は異なる名前と判断されます。
</p>
<p> 本稿では Python 2.4 を基準に機能を説明します。2.4 以外の Python では動作しない機能もあります。ご注意ください。
</p>

<h4 id="chap04">●Python のデータ型</h4>
<p> Python に用意されている基本的なデータ型について簡単に説明します。
</p>

<h4 id="chap05">●数</h4>
<p> Python には整数 (integer)、浮動小数点数 (floating-point number)、複素数 (complex number) という 3 種類の数が用意されてます。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; a = 100
&gt;&gt;&gt; a
100
&gt;&gt;&gt; print a
100
&gt;&gt;&gt; b = 1.234
&gt;&gt;&gt; b
1.234
&gt;&gt;&gt; c = 2 ** 100
&gt;&gt;&gt; c
1267650600228229401496703205376L
&gt;&gt;&gt; d = 1 + 2j + 3 - 4j
&gt;&gt;&gt; d
(4-2j)
</pre>

<p> Python はＣ言語と違い、あらかじめ変数やそのデータ型を宣言する必要はありません。変数に値をセットすることを「代入」といいます。代入には = を使います <sup><a href="python01.html#note1">[*1]</a></sup>。これはＣ言語や Perl と同じです。対話モードで変数名を入力するとその値が表示されます。もしくは print 文を使って表示します。print 文は指定されたデータを画面（標準出力）へ出力して改行します。
</p>

<p> 変数 a には整数 100 を代入し、変数 b には実数 1.234 を代入しています。Python の整数には桁数の制限がありません。** はべき乗を計算する演算子で、2 の 100 乗のような大きな値でも計算することができます。算術演算子を表 1 に示します。
</p>

<table border=1>
<caption>表 1 : 算術演算子</caption>
<thead>
  <tr><th>操作</th><th>結果</th></tr>
</thead>
<tbody>
  <tr><td> -x     </td><td> x を負にする</td></tr>
  <tr><td> x + y  </td><td> x と y の和</td></tr>
  <tr><td> x - y  </td><td> x と y の差</td></tr>
  <tr><td> x * y  </td><td> x と y の積</td></tr>
  <tr><td> x / y  </td><td> x 割る y の商</td></tr>
  <tr><td> x % y  </td><td> x 割る y の剰余</td></tr>
  <tr><td> x ** y </td><td> x の y 乗</td></tr>
</tbody>
</table>

<p> 浮動小数点数はＣ言語の倍精度浮動小数点数 (double) と同じで、範囲は約 1e-307 から 1e+308 までです。複素数は (実数部 + 虚数部) で表します。虚数単位は J または j を使って表します。j だけだと変数と認識されるので、1j と書くことに注意してください。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 代入は x = y = z = 0 のように、複数の変数に同じ値を代入することができます。
</div>

<h4 id="chap06">●文字列</h4>
<p> 文字列 (string) はシングルクオート ' で囲むか、ダブルクオート " で囲んで表します。
</p>
<pre>
&gt;&gt;&gt; a = 'hello, world'
&gt;&gt;&gt; a
'hello, world'
</pre>
<p> 変数 a には文字列 'hello, world' を代入しています。文字列には演算子 + と * を適用することができます。
</p>
<pre>
&gt;&gt;&gt;'abc' + 'def'
'abcdef'
&gt;&gt;&gt;'abc' * 3
'abcabcabc'
</pre>
<p> 演算子 + は文字列を連結した新しい文字列を作り、演算子 * は文字列を指定した回数だけ繰り返した新しい文字列を作ります。
</p>
<p> 文字列には「エスケープシーケンス」を含めることができます。これは、画面に表示することができない文字を表すのに用いられる方法です。よく使われる記号に改行を表す \n とタブを表す \t があります。
</p>
<pre>
&gt;&gt;&gt; print 'abc\ndef'
abc
def
&gt;&gt;&gt; print 'abc\tdef'
abc    def
</pre>
<p> この例はタブが 4 文字に設定されている場合です。エスケープシーケンスを無効にしたい場合は、文字列の前に r または R を付けます。これを raw string といいます。
</p>
<pre>
&gt;&gt;&gt; print 'abc\ndef'
abc\ndef
&gt;&gt;&gt; print 'abc\tdef'
abc\tdef
</pre>
<p> また、Python は unicode をサポートしています。文字列の前に u または U を付けると、その文字列は unicode に変換されます。
</p>
<p> 複数の行にわたって文字列を定義したい場合は継続行を使います。継続行は最後にバックスラッシュ (円記号) を付けます。
</p>
<pre>
&gt;&gt;&gt; b = 'abcdef\n\
012345\n\
ghijkl\n'
&gt;&gt;&gt; b
'abcdef\n012345\nghijkl\n'
&gt;&gt;&gt; print b
abcdef
012345
ghijkl
</pre>
<p> もうひとつ、三重のクオート """ または ''' で囲む方法 <sup><a href="python01.html#note2">[*2]</a></sup> があります。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; c = '''abcdef
012345
ghijkl
'''
&gt;&gt;&gt; c
'abcdef\n012345\nghijkl\n'
&gt;&gt;&gt; print c
abcdef
012345
ghijkl
</pre>
<p> ''' で囲まれた入力データがそのまま文字列になります。改行文字も含まれるので、継続行のように \n を付加する必要はありません。
</p>
<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> Perl や UNIX 系のシェルにあるヒアドキュメント (here-document) という機能とよく似ている方法です。
</div>

<h4 id="chap07">●リスト</h4>
<p> Python のリスト (list) <sup><a href="python01.html#note3">[*3]</a></sup> はデータを一列に並べたもので、Perl の配列やＣ言語の 1 次元配列と同様のデータ構造です。リストに格納されたデータを「要素」といいます。リストの要素は整数値で指定します。これを「添字 (subscripts) 」といいます。Python の場合、Ｃ言語と同じく添字は 0 から始まります。
</p>
<p> リストは角カッコ '[' と ']' で囲み、要素をカンマ ( , ) で区切って表します。[ ] は要素が一つもない空リストになります。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; list1 = [10, 20, 30, 40, 50]
&gt;&gt;&gt; a = list1[0]
&gt;&gt;&gt; a
10
&gt;&gt;&gt; list1[4] = 100
&gt;&gt;&gt; list1
[10, 20, 30, 40, 100]
&gt;&gt;&gt; list1[-1]
100
&gt;&gt;&gt; list1[-2]
40
</pre>
<p> Ｃ言語は配列の大きさを宣言する必要がありますが、Python のリストは大きさを宣言する必要はありません。リストの大きさは Python が自動的に調整してくれます。大きさを自由に変えることができる配列を「可変長配列」といいます。他のスクリプト言語、たとえば Perl でも可変長配列をサポートしています。
</p>
<p> リストの要素は角カッコ [ ] を使ってアクセスします。これはＣ言語や Perl と同じです。リストの要素を取り出して変数に代入することも、リストの要素を書き換えることもできます。添字に負の整数を指定すると、リストの後ろから数えます。list1[-1] は最後尾の要素 100 になり、list1[-2] は後ろから 2 番目の要素 40 になります。
</p>
<p> リストの要素には、いろいろなデータ型が混在していてもかまいません。また、要素に式を書くこともできます。
</p>
<pre>
&gt;&gt;&gt; list2 = ['a', 10, 'b', 20, 'c', 30]
&gt;&gt;&gt; list2[2]
'b'
&gt;&gt;&gt; list2[3]
20
&gt;&gt;&gt; [1 + 2, 3 - 4, 5 * 6]
[3, -1, 30]
</pre>
<p> list2 のリストは、0, 2, 4 番目の要素が文字列で、1, 3, 5 番目の要素が整数になっています。要素に式を書くと、その式の評価結果が要素になります。
</p>
<p> リストは入れ子にすることができます。つまり、リストの要素にリストを入れてもかまいません。これで多次元配列を表すことができます。
</p>
<pre>
&gt;&gt;&gt; list3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; list3[0]
[1, 2, 3]
&gt;&gt;&gt; list3[0][1]
2
</pre>
<p> list3 のように、リストの中にリストを入れることで 2 次元配列を表すことができます。list3 の 0 番目の要素はリスト [1, 2, 3] で、そのリストの 1 番目の要素は 2 です。この要素は角カッコを 2 つ使って list3[0][1] とアクセスすることができます。list3[0] で 0 番目のリストを取り出し、そのリストの 1 番目の要素を [1] で取り出します。
</p>
<div class="note">
-- note --------<br>
<a name="note3">[*3]</a> リスト操作が得意なプログラミング言語では Lisp が有名です。Lisp のリストは連結リスト (linked list) のことですが、Python のリストは可変長配列として実装されています。
</div>

<h4 id="chap08">●タプル</h4>
<p> タプル (tuple) は更新不能 (immutable) なリストのことです。リストは要素の値を書き換えることができますが、タプルはできません。タプルは丸カッコ '(' と ')' で囲み、要素をカンマ ( , ) で区切ります。( ) は空タプルを表します。リストと同様に、要素はいろいろなデータ型が混在してもかまいません。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; a = (1, 2, 3, 4)
&gt;&gt;&gt; a
(1, 2, 3, 4)
&gt;&gt;&gt; b = (5, 6, 7, 8)
&gt;&gt;&gt; b
(5, 6, 7, 8)
&gt;&gt;&gt; a[0]
1
&gt;&gt;&gt; b[1]
6
&gt;&gt;&gt; a + b
(1, 2, 3, 4, 5, 6, 7, 8)
&gt;&gt;&gt; b * 2
(5, 6, 7, 8, 5, 6, 7, 8)
</pre>
<p> タプルを生成して変数 a と b にセットします。タプルはリストと同じく角カッコ [ ] で要素を取り出すことができます。ただし、a[0] = 10 のような代入操作はできません。
</p>
<p> タプルは、丸カッコを省略しても生成できる場合があります。
</p>
<pre>
&gt;&gt;&gt; c = 1, 2, 3
&gt;&gt;&gt; c
(1, 2, 3)
&gt;&gt;&gt; d = [1, 2, (3, 4, 5)]
&gt;&gt;&gt; d
[1, 2, (3, 4, 5)]
</pre>
<p> このように、カンマで区切られたデータはタプルに格納されます。ただし、リストやタプルの中にタプルを入れる場合などでは、丸カッコで囲む必要があります。
</p>
<p> また、タプルを使って複数の変数に値を代入することができます。
</p>
<pre>
&gt;&gt;&gt; a = 1, 2, 3
&gt;&gt;&gt; a
(1, 2, 3)
&gt;&gt;&gt; x, y, z = a
&gt;&gt;&gt; x
1
&gt;&gt;&gt; y
2
&gt;&gt;&gt; z
3
</pre>
<p> 変数 x にはタプルの 0 番目の要素、y には 1 番目の要素、z には 2 番目の要素が代入されます。なお、リストを使っても変数に値を代入することができます。
</p>
<pre>
&gt;&gt;&gt; a = [10, 20, 30]
&gt;&gt;&gt; a
[10, 20, 30]
&gt;&gt;&gt; x, y, z = a
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
&gt;&gt;&gt; z
30
</pre>
<p> x, y, z はタプル (x, y, z) ですが、リスト [x, y, z] にしても動作します。
</p>
<pre>
&gt;&gt;&gt; [x, y, z] = [100, 200, 300]
&gt;&gt;&gt; x
100
&gt;&gt;&gt; y
200
&gt;&gt;&gt; z
300
</pre>
<p> 要素が一つのタプルは、要素の後ろにカンマを付ける必要があります。次の例を見てください。
</p>
<pre>
&gt;&gt;&gt; a = 1,
&gt;&gt;&gt; a
(1,)
</pre>
<p> 演算の順序を指定するための丸カッコと区別するため、要素の後ろにカンマを付けます。要素が一つのタプルを生成する場合も、a = 1, のようにカンマを付けます。
</p>

<h4 id="chap09">●シーケンス</h4>
<p> リスト、タプル、文字列はデータを一列に並べたデータ構造という共通点があります。このようなデータ型を「シーケンス(sequence) 」といいます。Python にはシーケンスに適用できる共通の操作があり、角カッコ [ ] は文字列にも適用できます。
</p>
<pre>
&gt;&gt;&gt; s = 'abcdef'
&gt;&gt;&gt; s[0]
'a'
</pre>
<p> Python には「文字」を表すデータ型がないので、s[0] の値は文字列 'a' になります。また、Python の文字列は更新不能なので、値を書き換えることはできません。s[0] = 'A' のように代入操作を行うとエラーになります。
</p>
<p> スライスはシーケンスの部分列を取り出す操作です。表 2 にスライス操作を示します。
</p>
<table border=1>
<caption>表 2 : スライス操作</caption>
<thead>
  <tr><th>操作</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td>S[start:end] </td><td> start から end - 1 まで</td></tr>
  <tr><td>S[start:]    </td><td> start から最後尾まで</td></tr>
  <tr><td>S[:end]      </td><td> 先頭から end - 1 まで</td></tr>
  <tr><td>S[:]         </td><td> 先頭から最後尾まで</td></tr>
</tbody>
</table>
<p> S はシーケンスを表します。スライスによって取り出された部分列は元のシーケンスをコピーしたものです。start と end に部分列を指定します。start の位置の要素が部分列の先頭になり、end - 1 の要素が最後尾になります。start が省略されると先頭 (0) に、end が省略されるとシーケンスの要素数に設定されます。どちらも省略するとシーケンスをコピーすることになります。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; s = [0, 1, 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; s[2:6]
[2, 3, 4, 5]
&gt;&gt;&gt; s[2:]
[2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; s[:6]
[0, 1, 2, 3, 4, 5]
</pre>
<p> 演算子 + と * はリストやタプルにも適用することができます。次の例を見てください。
</p>
<pre>
&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; [0] * 8
[0, 0, 0, 0, 0, 0, 0, 0]
</pre>
<p> シーケンスに格納されている要素数は関数 len() で求めることができます。len() は length のことで、シーケンスの要素数を「長さ」といいます。
</p>
<pre>
&gt;&gt;&gt; len([1, 2, 3])
3
&gt;&gt;&gt; len('abcde')
5
</pre>
<p> 関数 list() はシーケンスをリストに変換します。次の例を見てください。
</p>
<pre>
&gt;&gt;&gt; list([1, 2, 3])
[1, 2, 3]
&gt;&gt;&gt; list((10, 20, 30))
[10, 20, 30]
&gt;&gt;&gt; list('abcd')
['a', 'b', 'c', 'd']
&gt;&gt;&gt; list()
[]
</pre>
<p> list() の引数にリストを与えると、そのリストをコピーした新しいリストを返します。文字列の場合は、1 文字ずつ分解してリストに格納します。引数がない場合は空リストを返します。このほかに、シーケンスをタプルに変換する関数 tuple() もあります。
</p>

<h4 id="chap10">●リストだけに適用できる操作</h4>
<p> リストは文字列やタプルと違って値を更新できるので、リストにだけ適用できる操作が用意されています。主な操作を表 3 に示します。
</p>
<table border=1>
<caption>表 3 : リストに適用できる主な操作</caption>
<thead>
  <tr><th>操作</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td>L.append(x)   </td><td>最後尾に要素を追加する</td></tr>
  <tr><td>L.index(x)    </td><td>要素 x を探して位置を返す</td></tr>
  <tr><td>L.insert(i,x) </td><td>i 番目に要素 x を挿入する</td></tr>
  <tr><td>L.pop()       </td><td>最後尾から要素を削除する</td></tr>
  <tr><td>L.remove(x)   </td><td>要素 x を削除する</td></tr>
  <tr><td>del L[i]      </td><td>i 番目の要素を削除する</td></tr>
  <tr><td>L[s:e] = List </td><td>スライスへの代入</td></tr>
</tbody>
</table>
<p> L はリストを表します。リストの操作はメソッド (method) として定義されています。メソッドは次の形式で呼び出します。
</p>
<pre class="item">
object.method(args, ...)
</pre>
<p> object はデータのことで、その後ろにドット ( . ) を付けて、メソッド名と引数を続けて書きます。Python はオブジェクト指向プログラミング言語なので、すべてのデータをオブジェクトとして扱うことができます。メソッドはオブジェクトを操作する関数のことで、Python では多くの操作がメソッドとして定義されています。オブジェクト指向機能はあとで詳しく説明します。
</p>
<p> これらの操作は要素の探索を除いて、リストをコピーせずに直接書き換えることに注意してください。このような操作を「リストを破壊的に修正する」とか「破壊的な操作」といいます。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; list1 = [1, 2, 3]
&gt;&gt;&gt; list1.append(4)
&gt;&gt;&gt; list1
[1, 2, 3, 4]
&gt;&gt;&gt; list1.pop()
4
&gt;&gt;&gt; list1
[1, 2, 3]
&gt;&gt;&gt; list1.insert(0, 10)
&gt;&gt;&gt; list1
[10, 1, 2, 3]
&gt;&gt;&gt; list1.remove(2)
&gt;&gt;&gt; list1
[10, 1, 3]
&gt;&gt;&gt; list1.index(1)
1
</pre>
<p> このように、リストを破壊的に修正するので、変数 list1 の値は書き換えられたリストになります。
</p>
<p> スライスへの代入は強力な操作です。指定した部分列を削除し、その部分に右辺のリストを挿入します。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; list1 = [1, 2, 3, 4, 5]
&gt;&gt;&gt; list1[2:3]
[3]
&gt;&gt;&gt; list1[2:3] = [100, 200]
&gt;&gt;&gt; list1
[1, 2, 100, 200, 4, 5]
&gt;&gt;&gt;list1[2:2]
[]
&gt;&gt;&gt; list1[2:2] = [10, 20]
&gt;&gt;&gt; list1
[1, 2, 10, 20, 100, 200, 4, 5]
&gt;&gt;&gt; list1[2:6]
[10, 20, 100, 200]
&gt;&gt;&gt; list1[2:6] = []
[1, 2, 4, 5]
</pre>
<p> list1[2:3] は [3] になりますが、そこに [100, 200] を代入すると、3 が削除されて 100 と 200 が挿入されます。list1[2:2] は空リストになりますが、そこに [10, 20] を挿入すると、要素 2 の後ろに 10 と 20 が挿入されます。空リストを代入すると、要素を削除することができます。
</p>

<h4 id="chap11">●ディクショナリ</h4>
<p> 辞書 (ディクショナリ : dictionary) は「連想配列」のことで、Perl ではハッシュ <sup><a href="python01.html#note4">[*4]</a></sup> と呼ばれています。リストが整数値を使って要素を指定するのに対し、ディクショナリはキー (key) というデータを使って要素を指定します。一般に、連想配列のキーには文字列が用いられますが、Python では変更不能なデータ型（数値、文字列、タプル）であれば、キーとして使用することができます。
</p>
<p> ディクショナリは中カッコ '{' と '}' で囲み、要素をカンマで区切って表します。要素は「キー: データ」で指定します。{ } は空のディクショナリを表します。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; d = {'foo': 10, 'bar': 20}
&gt;&gt;&gt; d['foo']
10
&gt;&gt;&gt; d['foo'] = 100
&gt;&gt;&gt; d['foo']
100
&gt;&gt;&gt; d['baz'] = 30
&gt;&gt;&gt; d
{'baz': 30, 'foo': 100, 'bar': 20}
</pre>
<p> ディクショナリのアクセスはリストと同様に角カッコ [ ] を使います。ディクショナリを生成して変数 d にセットします。d['foo'] でキー 'foo' のデータを取り出したり、そこにデータを代入すれば、d['foo'] の値を書き換えることができます。また、新しいキー 'baz' を追加する場合は、d['baz'] に値を代入すると、ディクショナリに 'baz' とその値が追加されます。
</p>
<p> このほかにも、Python にはディクショナリを操作する関数やメソッドが用意されています。表 4 に主な関数とメソッドを示します。
</p>
<table border=1>
<caption>表 4 : ディクショナリの操作</caption>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>dict()       </td><td>ディクショナリを生成する</td></tr>
  <tr><td>del D[key]   </td><td>キーと値を削除する</td></tr>
  <tr><td>len(D)       </td><td>ディクショナリの要素数を返す</td></tr>
  <tr><td>D.clear()    </td><td>ディクショナリを空にする</td></tr>
  <tr><td>D.keys()     </td><td>ディクショナリ内のキーをリストにして返す</td></tr>
  <tr><td>D.values()   </td><td>ディクショナリ内の値をリストにして返す</td></tr>
<tr><td>D.items()    </td><td>ディクショナリ内のキーと値を連想リストにして返す</td></tr>
  <tr><td>D1.update(D2)</td><td>ディクショナリ D1 に D2 の要素を追加する</td></tr>
</tbody>
</table>

<p> D はディクショナリを表します。簡単な使用例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; d1 = dict()
&gt;&gt;&gt; d1
{}
&gt;&gt;&gt; d2 = dict([('foo', 10), ('bar', 20), ('baz', 30)])
&gt;&gt;&gt; d2
{'baz': 30, 'foo': 10, 'bar': 20}
&gt;&gt;&gt; d1.update(d2)
&gt;&gt;&gt; d1
{'bar': 20, 'foo': 10, 'baz': 30}
&gt;&gt;&gt; d1.update([('abc', 40)])
&gt;&gt;&gt; d1
{'bar': 20, 'foo': 10, 'baz': 30, 'abc': 40}
&gt;&gt;&gt; len(d1)
4
</pre>
<p> 関数 dict() はディクショナリを生成します。dict() は引数がないと空のディクショナリを返します。キーと値をタプルにセットし、それを要素とするリストを引数に渡すこともできます。このようなリストを連想リスト (association list) といいます。
</p>
<p> メソッド update() はディクショナリ D2 の要素をディクショナリ D1 に追加します。要素の追加はディクショナリだけではなく、連想リストを渡すこともできます。関数 len() を使うとディクショナリに登録されている要素数を求めることができます。
</p>
<pre>
&gt;&gt;&gt; d1.keys()
['bar, 'foo', 'baz', 'abc']
&gt;&gt;&gt; d1.values()
[20, 10, 30, 40]
&gt;&gt;&gt; d1.items()
[('bar, 20), ('foo', 10), ('baz', 30), ('abc', 40)]
</pre>
<p> keys(), values(), items() は、辞書に登録された順番でデータを取り出すわけではありません。取り出される順番は、辞書の実装方法によって左右されます。ご注意ください。
</p>
<div class="note">
-- note --------<br>
<a name="note4">[*4]</a> Perl で連想配列をハッシュと呼ぶのは、連想配列を実現するアルゴリズムに「ハッシュ法 (hashing) 」が用いられているからです。Python のディクショナリもハッシュ法を使って実装されています。
</div>

<h4 id="chap12">●セット</h4>
<p> セット (set) はリストやディクショナリのように要素を格納するデータ型です。複数の要素を格納するデータ型を「コレクション (collection) 」とか「コンテナ (container) 」と呼びます。これまでに説明したリスト、タプル、文字列、ディクショナリがコレクションになります。セットもコレクションですが、リストと違って要素に順番はなく、重複した要素を含まないところが特徴です。
</p>
<p> セットはデータの集合を表すのに便利なデータ型です。集合は要素の順番に意味はありません。たとえば集合 {1, 3, 5, 7} は {7, 5, 3, 1} や {5, 3, 1, 7} と表すこともできます。このように、要素は適当に並べてもかまわないのですが、ある規則で要素を整列させておく場合もあります。
</p>
<p> セットの基本的な操作関数とメソッドを表 5 に示します。
</p>
<table border=1>
<caption>表 5 : セットの基本操作</caption>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>set()       </td><td>セットを生成する</td></tr>
  <tr><td>len(S)      </td><td>セットの要素数を返す</td></tr>
  <tr><td>S.add(x)    </td><td>要素 x を追加する</td></tr>
  <tr><td>S.remove(x) </td><td>要素 x を削除する</td></tr>
  <tr><td>S.clear()   </td><td>セットを空にする</td></tr>
  <tr><td>S.update(xs)</td><td>コレクション xs の要素を追加する</td></tr>
</tbody>
</table>
<p> S はセットを表します。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = set([1, 2, 3])
&gt;&gt;&gt; a
set([1, 2, 3])
&gt;&gt;&gt; b = [1, 2, 3, 1, 2]
&gt;&gt;&gt; c = set( b )
&gt;&gt;&gt; c
set([1, 2, 3])
&gt;&gt;&gt; d = {'abc':10, 'def':20, 'ghi':30}
&gt;&gt;&gt; e = set( d )
&gt;&gt;&gt; e
set(['abc', 'ghi', 'def'])
&gt;&gt;&gt; len(e)
3
</pre>
<p> set() の引数にコレクションを渡すと、その要素をセットに格納します。このとき、重複した要素は取り除かれ、ユニークな要素だけがセットに格納されます。ディクショナリを渡すと、キーがセットに格納されます。また、関数 len() を使うとセットに格納されている要素数を求めることができます。
</p>
<p> 要素の追加と削除はメソッド add() と remove() を使います。メソッド clear() はセットを空にします。コレクションの要素をまとめて追加したい場合はメソッド update() を使います。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; a = set()
&gt;&gt;&gt; a
set([])
&gt;&gt;&gt; a.add(1)
&gt;&gt;&gt; a.add(2)
&gt;&gt;&gt; a
set([1, 2])
&gt;&gt;&gt; a.remove(1)
set([2])
&gt;&gt;&gt; a.clear()
&gt;&gt;&gt; a
set([])
&gt;&gt;&gt; a.update([1, 2, 3])
&gt;&gt;&gt; a
set([1, 2, 3])
</pre>
<p> セットは集合を扱うメソッドや演算子が用意されています。主なメソッドを表 6 に示します。
</p>
<table border=1>
<caption>表 6 : セットの集合演算</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>s1.issubset(s2)</td><td>s1 が s2 の部分集合であれば真を返す</td></tr>
  <tr><td>s1.issuperset(s2)</td><td>s2 が s1 の部分集合であれば真を返す</td></tr>
  <tr><td>s1.intersection(s2)</td><td>s1 と s2 の積を求める (s1 &amp; s2)</td></tr>
  <tr><td>s1.union(s2)       </td><td>s1 と s2 の和を求める (s1 | s2)</td></tr>
  <tr><td>s1.difference(s2)  </td><td>s2 に現れない s1 の要素を求める (s1 - s2)</td></tr>
  <tr><td>s1.symmetric_difference(s2)</td><td>s1 と s2 の両方にちょうど 1 つだけ現れる要素を求める (s1 ^ s2)</td></tr>
</tbody>
</table>

<p> 簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = set([1, 2, 3, 4])
&gt;&gt;&gt; b = set([1, 2, 5, 6])
&gt;&gt;&gt; a | b
set([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; a &amp; b
set([1, 2])
&gt;&gt;&gt; a - b
set([3, 4])
&gt;&gt;&gt; b - a
set([5, 6])
&gt;&gt;&gt; a ^ b
set([3, 4, 5, 6])
&gt;&gt;&gt; c = set([3, 4])
&gt;&gt;&gt; c.issubset(a)
True
&gt;&gt;&gt; c.issubset(b)
False
</pre>
<p> セットにはリストのタプルのように更新不能な frozenset が用意されています。frozenset の場合、セットを更新するメソッド add(), remove(), clear(), update() は使うことができません。
</p>

<h4 id="chap13">●Python の制御構造</h4>
<p> Python の制御構造はとてもシンプルで、プログラムの実行を制御する基本的な操作は、if 文、while 文、for 文の 3 種類しかありません。最初に if 文から説明します。
</p>

<h4 id="chap14">●if 文</h4>
<p> if 文は「条件分岐」を行います。簡単にいうと「もしも～～ならば○○をせよ」という動作です。図 1 を見てください。
</p>

<pre class="fig">
        ↓                        ↓
  ┌─────┐No          ┌─────┐No
  │  条  件  │─┐        │  条  件  │─────┐
  └─────┘  │        └─────┘          │
        ↓Yes     │              ↓Yes             ↓
  ┌─────┐  │        ┌─────┐    ┌─────┐
  │  処理Ａ  │  │        │  処理Ａ  │    │  処理Ｂ  │
  └─────┘  │        └─────┘    └─────┘
        │        │              │                │
        ├←───┘              ├←───────┘
        ↓                        ↓

       (1)                        (2)

               図 1 : if 文の動作
</pre>
<p> 図 1 (1) では、「もしも条件を満たすならば、処理 A を実行する」となります。この場合、条件が成立しない場合は何も処理を実行しませんが、図 1 (2) のように、条件が成立しない場合でも処理を実行させることができます。(2) の場合では、「もしも条件を満たすならば、処理 A を実行し、そうでなければ処理 B を実行する」となります。すなわち、条件によって処理 A か処理 B のどちらかが実行されることになります。
</p>
<p> 一般に、プログラミング言語では、条件が成立することを「真 (true)」といい、条件が不成立のことを「偽 (false) 」といいます。実際のプログラムでは真偽を表すデータが必要になります。
</p>
<p> Python では数値 0 や 0.0 は偽を表し、それ以外の数値は真となります。文字列の場合、空文字列 '' は偽を表し、それ以外の文字列は真と判断されます。また、空のコレクション、[], (), {}, set([]) や None というデータ型も偽を表します。新しいバージョンの Python では、真偽を表すデータ型 boolean が用意されていて、True と False で真と偽を表します。
</p>
<p> 図 2 に if 文の構文を示します。
</p>
<pre class="fig">
# coding: utf-8
#
# if test: then節 else: else節
#
if test:
    処理A
    処理B
    処理C
else:
    処理D
    処理E
    処理F

図 2 : if の構文 (1)
</pre>
<p> Python は Perl と同様に # から改行までが注釈文（コメント）になります。プログラムに日本語を使う場合は、ファイルの最初に文字コード方式 (coding:) に utf-8 または shift_jis, euc-jp, iso-2022-jp などを指定します。
</p>
<p> if のあとに条件部 test を書き、その後ろにコロンをつけます。このあとインデントを行って、真のときに実行する処理を書きます。処理は一つだけではなく、複数の処理を記述することができます。複数の処理をまとめたものをブロック (block) といいます。ブロックは定義された処理を順番に実行します。なお、条件部が真のときに実行されるブロックを then 節、偽のときに実行されるブロックを else 節と呼ぶ場合があります。
</p>
<p> Python はインデントが等しい処理を同じブロックとして扱います。インデントが変化した時点でブロックの定義は終了します。図 2 では 4 文字でインデントを行っていて、処理 A から処理 C は同じインデントなので、同じブロックとして扱われます。したがって、test が真の場合は処理 A から C までを実行し、else 節の処理 D から F は実行されません。
</p>
<p> test の結果が偽であれば、else 節に記述されている処理 D から F までを順番に実行します。else の後ろにもコロンをつけることを忘れないでください。なお、else 節は省略することができます。
</p>
<p> if 文は図 3 と図 4 のように入れ子（ネスト）にすることができます。
</p>
<pre class="fig">
#
# if の入れ子
#
if test_a:
    処理A
else:
    if test_b:
        処理B
    else:
        処理C

図 3 : if 文の入れ子
</pre>
<pre class="fig">
        ↓
  ┌─────┐No
  │  test_a  │─────┐
  └─────┘          │
        ↓Yes             ↓
        │          ┌─────┐No
        │          │  test_b  │─────┐
        │          └─────┘          │
        │                ↓Yes             ↓
  ┌─────┐    ┌─────┐    ┌─────┐
  │  処理Ａ  │    │  処理Ｂ  │    │  処理Ｃ  │
  └─────┘    └─────┘    └─────┘
        │                │                │
        ↓                ↓                ↓
        ├────────┴────────┘
        ↓

           図 4 : if 文の入れ子の動作
</pre>
<p> test_a が偽の場合は else 節を実行します。else 節は if 文なので、条件 test_b を実行します。この結果が真であれば処理 B を実行します。そうでなければ、else 節の処理 C を実行します。この処理は図 5 のように書き換えることができます。
</p>
<pre class="fig">
#
# if - elif - else
#
if test_a:
    処理A
elif test_b:
    処理B
else:
    処理C

図 5 : if の構文 (2)
</pre>
<p> Ｃ言語は eles if を使いますが、Python では elif を使って if 文を連結することができます。test_a が偽の場合は、次の elif の条件 test_b を実行します。この結果が真であれば処理 B を実行します。そうでなければ、else 節の処理 C を実行します。なお、elif はいくつでも繋げることができます。
</p>

<h4 id="chap15">●比較演算子と論理演算子</h4>
<p> Python には表 7 に示す比較演算子が用意されています。
</p>
<table border=1>
<caption>表 7 : 比較演算子</caption>
<thead>
  <tr><th>演算子</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td> ==      </td><td>等しい</td></tr>
  <tr><td> != , &lt;&gt; </td><td>等しくない</td></tr>
  <tr><td> &lt;       </td><td>より小さい</td></tr>
  <tr><td> &gt;       </td><td>より大きい</td></tr>
  <tr><td> &lt;=      </td><td>より小さいか等しい</td></tr>
  <tr><td> &gt;=      </td><td>より大きいか等しい</td></tr>
</tbody>
</table>
<p> Ｃ言語の比較演算子とほぼ同じですが、Python は != のかわりに &lt;&gt; を使うことができます。これらの比較演算子は数値だけではなく、文字列や他のデータ型にも用いることができます。また、Ｃ言語とは違って、x &lt; y &lt; z のように比較演算子をつなげて書くことができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; 1 &lt; 2
True
&gt;&gt;&gt; 1 &lt;= 1 &lt; 2
True
&gt;&gt;&gt; "abc" &gt; "def"
False
&gt;&gt;&gt; "abc" &lt; "def" &lt; "ghi"
True
&gt;&gt;&gt; [1, 2, 3] &gt; [1, 2, 4]
False
</pre>

<p> Python には表 8 に示す論理演算子があります。
</p>
<table border=1>
<caption>表 8 : 論理演算子</caption>
<thead>
  <tr><th>操作</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td>not x   </td><td>x の否定（真偽の反転）</td></tr>
  <tr><td>x and y </td><td>x が真かつ y が真ならば真</td></tr>
  <tr><td>x or y  </td><td>x が真まはた y が真ならば真</td></tr>
</tbody>
</table>
<p> 簡単な使用例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True and False
False
&gt;&gt;&gt; False or True
True
&gt;&gt;&gt; False or False
False
</pre>
<p> and は、左項が偽ならば右項を評価せずに偽を返します。or は左項が真ならば右項を評価せずに真を返します。
</p>

<h4 id="chap16">●in と not in</h4>
<p> 演算子 in と not in はコレクションの中に要素が含まれているか調べる演算子です。in は要素 x がコレクションに含まれていれば True を返し、そうでなければ False を返します。逆に、not in は要素 x がコレクションに含まれていなければ True を返し、そうでなければ False を返します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; 5 in [1, 2, 3, 4, 5]
True
&gt;&gt;&gt; 10 in [1, 2, 3, 4, 5]
False
&gt;&gt;&gt; 5 not in [1, 2, 3, 4, 5]
False
&gt;&gt;&gt; 10 not in [1, 2, 3, 4, 5]
True
</pre>
<p> ディクショナリの場合はキーの有無を調べます。
</p>
<pre>
&gt;&gt;&gt; dic = { 'foo': 10, 'bar': 20 }
&gt;&gt;&gt; 'foo' in d
True
&gt;&gt;&gt; 'baz' in d
False
&gt;&gt;&gt; 'foo' not in d
False
&gt;&gt;&gt; 'baz' not in d
True
</pre>

<h4 id="chap17">●while 文による繰り返し</h4>
<p> 繰り返しは同じ処理を何度も実行することです。まずは簡単な繰り返しから紹介しましょう。while 文は条件が真のあいだ、ブロックに書かれている処理を繰り返し実行します。
</p>
<pre class="fig">
#
# while test: block
#
while test:
    処理A
    処理B
    処理C
else:
    処理Z

図 6 : while 文の構文
</pre>
<pre class="fig">
                      ↓
                      ├←─────┐
          False ┌─────┐      │
        ┌───│  条件部  │      │
        │      └─────┘      │
        │            ↓True        │
        │      ┌─────┐      │
        │      │  処理Ａ  │      │
        │      └─────┘      │
        │            ↓            │
        │      ┌─────┐      │
        │      │  処理Ｂ  │      │
        │      └─────┘      │
        │            ↓            │
        │      ┌─────┐      │
        │      │  処理Ｃ  │      │
        ↓      └─────┘      │
  ┌─────┐      │            │
  │  処理Ｚ  │      │            │
  └─────┘      ↓            │
        │            └──────┘
        └──────┐
                      ↓

             図 7 : while 文の動作
</pre>
<p> 図 6, 7 を見ればおわかりのように、while 文はいたって単純です。Ｃ言語とは違い、Python の while 文は else 節を定義することができます。else 節は while ループが終了したあとに実行されます。
</p>
<p> 簡単な例を示しましょう。hello, world を 10 回表示するプログラムをリスト 1 に示します。
</p>
<pre class="list">
リスト 1 : hello. wolrd の表示

n = 0
while n &lt; 10:
    print 'hello, world'
    n += 1
</pre>
<p> 変数 n を 0 に初期化し、n の値が 10 よりも小さいあいだ処理を繰り返します。Ｃ言語と同様に、n += i は n = n + i と同じ意味です。このほかに、-=, *=, /= も使うことができます。n の値はブロックを実行するたびに +1 されていくので、n が 10 になった時点で繰り返しを終了します。
</p>

<h4 id="chap18">●for 文による繰り返し</h4>
<p> Python にはもう一つ繰り返しを行う for 文があります。for 文はコレクションから順番に要素 (ディクショナリの場合はキー) を取り出して変数に代入し、ブロックに書かれている処理を繰り返し実行します。Python の for 文は Perl の foreach と同じです。Ｃ言語の for 文とは違うことに注意してください。for 文の構文を図 8 に、動作を図 9 に示します。
</p>
<pre class="fig">
#
# for var in collection:
#     block
#
for 変数名 in コレクション:
    処理A
    処理B
    処理C
else:
    処理Z

図 8 : for文 の構文
</pre>
<pre class="fig">
                      ↓
                      ├←────┐
           False┌─────┐    │
        ┌───│要素がある│    │
        │      └─────┘    │
        │            ↓True      │
        │      ┌─────┐    │
        │      │変数←要素│    │
        │      └─────┘    │
        │            ↓          │
        │      ┌─────┐    │
        │      │  処理Ａ  │    │
        │      └─────┘    │
        │            ↓          │
        │      ┌─────┐    │
        │      │  処理Ｂ  │    │
        │      └─────┘    │
        ↓            ↓          │
  ┌─────┐┌─────┐    │
  │  処理Ｚ  ││  処理Ｃ  │    │
  └─────┘└─────┘    │
        │            └─────┘
        └──────┐
                      ↓

              図 9 : for 文の動作
</pre>

<p> for 文の構文は、for と in の間にコレクションの要素を格納する変数を指定し、in の後ろにコレクションを指定します。このあと、コロンを書いてインデントでブロックの範囲を指定します。また、for 文は while 文と同様に else 節を定義することができます。簡単な例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; for x in a:
        print x

1
2
3
&gt;&gt;&gt; d = {'foo': 10, 'bar': 20, 'baz': 30}
&gt;&gt;&gt; for x in d:
        print x

baz
foo
bar
</pre>
<p> シーケンスの場合、for 文は先頭から順番に要素を取り出します。ディクショナリの場合、キーを取り出す順番はディクショナリの実装方法に依存します。アルファベット順に取り出していくわけではありません。
</p>
<p> for 文で使用する変数は、タプルで複数個指定することができます。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; for a, b in [[1, 2], [3, 4], [5, 6]]:
        print a * b

2
12
30
</pre>
<p> リストの要素数が変数の個数と一致しないとエラーになります。ご注意ください。
</p>

<h4 id="chap19">●繰り返しの制御</h4>
<p> while 文や for 文は break 文によって繰り返しを脱出することができます。この場合、else 節が定義されていも実行されません。contiune 文は繰り返しの先頭に戻ります。break 文と continue 文の動作を図 10 に示します。
</p>
<pre class="fig">
#
# break と continue
#
while test_a: ←──────┐
    処理A                   │
    if test_b: continue ──┘
    処理B
    if test_c: break ───┐
    処理C                  │
else:                      │
    処理D                  │
 ←────────────┘
処理E

図 10 : break 文と continue 文の動作
</pre>
<p> test_b が真で continue 文が実行されると、それ以降の処理を実行せずに条件部のチェックが行われます。つまり、処理 B, test_c, 処理 C は実行されません。for 文で continue 文が実行されると、それ以降の処理は実行されずに次の要素を取り出す処理が行われます。
</p>
<p> test_c が真で break 文が実行されると、それ以降の処理を実行せずに while 文や for 文の繰り返しを脱出します。このとき、else 節が定義されていても実行されません。図 10 では、break 文で while 文の繰り返しを脱出すると、while 文の次の処理 E が実行されます。else 節の処理 D は実行されないことに注意してください。
</p>

<h4 id="chap20">●range() によるリストの生成</h4>
<p> for 文を使う場合、要素が数値のリストを生成する関数 range() を使うと便利です。
</p>
<pre class="item">
range(end)
range(start, end)
range(start, end, step)
</pre>
<p> 関数 range() の引数 start と end はスライス操作と同じ指定方法です。引数が一つで start が省略された場合、リストの要素は 0 から始まり、値を +1 しながら end - 1 までの数値を生成します。引数が 2 つの場合は start から end - 1 までの数値を生成します。引数が 3 つの場合は、start から end 未満までの数値を step 分加算しながら生成します。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; range(8)
[0, 1, 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; range(2, 8)
[2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; range(10, 100, 20)
[10, 30, 50, 70, 90]
</pre>
<p> range() を使うと、hello, world を 10 回表示するプログラムは、リスト 2 のようになります。
</p>
<pre class="list">
リスト 2 : hello, world の表示

for i in range(10):
    print 'hello, world'
</pre>
<p> while 文を使うよりも簡単です。1 から 1000 までを加算するプログラムはリスト 3 のようになります。
</p>
<pre class="list">
リスト 3 : 1 から 1000 までの合計値

total = 0
for i in range(1, 1001):
    total += i
print total
</pre>
<p> 変数 i には 1 から 1000 までの数が順番にセットされ、変数 total に加算されます。答えは 500500 になります。
</p>

<h4 id="chap21">●リストの内包表現</h4>
<p> Ptyhon はリストの中に for 文を書いて、リストを生成することができます。これを「リストの内包表現」といいます。基本的な構文を次に示します。
</p>
<pre class="item">
[式 for 変数, ... in コレクション]
</pre>
<p> 最初に要素の値を計算する式を書き、次に for 文を書きます。この後ろに for 文または if 文を続けることができます。簡単な例を示します。
</p>
<pre>
&gt;&gt;&gt; list1 = [1, 2, 3, 4, 5]
&gt;&gt;&gt; [x * x for x in list1]
[1, 4, 9, 16, 25]
&gt;&gt;&gt; [(x, x * x) for x in list1]
[(1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
&gt;&gt;&gt; [x * x for x in list1 if x % 2 == 0]
[4, 16]
&gt;&gt;&gt; [x + y for x in range(3) for y in range(10, 13)]
[10, 11, 12, 11, 12, 13, 12, 13, 14]
</pre>
<p> for 文の後ろに if 文を続けると、条件部が真のときに式を評価してリストを生成します。上の例では、x が偶数のときに式が評価されて要素 4 と 16 のリストが生成されます。for 文の後ろに for 文を続けると二重ループになります。上の例では、リストには 9 個の要素が格納されます。
</p>

<h4 id="chap22">●for 文と組み合わせて使うと便利な関数</h4>
<p> range() のほかにも、for 文は関数 enumerate(), zip(), メソッド iteritems() と組み合わせて使うと便利です。
</p>
<p> 関数 enumerate() は、要素の位置が必要なときに使うと便利です。
</p>
<pre>
&gt;&gt;&gt; for n, m in enumerate(['abc', 'def', 'ghi']):
        print n, m


0 abc
1 def
2 ghi
</pre>
<p> print で複数のデータを表示する場合は、引数をカンマで区切ります。データとデータの間には空白が挿入されます。
</p>
<p> 最初の変数 n に要素の位置（添え字）がセットされ、2 番目の変数 m に要素がセットされます。これはリスト 4 に示す処理と同じです。
</p>
<pre class="list">
リスト 4 : enumerate と同じ処理

n = 0
for m in ['abc', 'def', 'ghi']:
    print n, m
    n += 1
</pre>

<p> 変数 n を 0 に初期化する処理と 1 を加算する処理が不要になる分だけ、enumerate() を使ったほうが簡単になります。
</p>
<p> iteritems() はディクショナリのメソッドで、キーと値を同時に取り出すことができます。
</p>
<pre>
&gt;&gt;&gt; dic1 = {'foo':10, 'bar':20, 'baz':30 }
&gt;&gt;&gt; for key, value in dic1.iteritems():
        print key, value


bar 20
foo 10
bar 30
</pre>
<p> 最初の変数 key にディクショナリのキーがセットされ、2 番目の変数 value に値がセットされます。メソッド items() はキーと値をタプルに格納したリストを生成して返しますが、iteritems() はリストを生成しないので効率的です。
</p>
<p> zip() は引数に複数のリストを受け取り、各リストの要素をタプルに詰め込み、それをリストに格納して返します。複数のリストを操作する場合、zip() はとても便利です。
</p>
<pre>
&gt;&gt;&gt; zip(['a', 'b', 'c'], [1, 2, 3])
[('a', 1), ('b', 2), ('c', 3)]
&gt;&gt;&gt; for x, y in zip([1, 2, 3]. [10, 20, 30]):
        print x + y


11
22
33
</pre>

<h4 id="chap23">●素数を求める</h4>
<p> 最後に簡単な例題として、素数を求めるプログラムを作ってみましょう。いちばん簡単な方法は、奇数 3, 5, 7, 9, ...をそれまでに見つかった素数で割ってみることです。見つかった素数はリストに格納しておけばいいでしょう。プログラムをリスト 5 に示します。
</p>
<pre class="list">
リスト 5 : 素数を求める(1)

prime_list = [2]

for x in range(3, 100, 2):
    for y in prime_list:
        if x % y == 0: break
    else:
        prime_list.append(x)

print prime_list
</pre>
<p> 変数 prime_list は素数のリストで [2] に初期化します。奇数の生成は range を使うと簡単です。最初の for 文で奇数を取り出して変数 x にセットします。次の for 文で prime_list から素数を取り出して変数 y にセットします。
</p>
<p> x % y が 0 であれば、x は素数 y で割り切れたので x は素数ではありません。break 文で for ループを脱出します。このとき else 節は実行されないので、x が prime_list に追加されることはありません。
</p>
<p> for が最後まで終了すれば x は素数です。この場合は else 節が実行されるので、素数 x は append で prime_list に追加されます。最後 に print で prime_list を表示します。
</p>
<p> それでは実行してみましょう。プログラムを prime.py に保存して、シェルで python prime.py を実行してください。
</p>
<pre>
C&gt;python prime.py
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 
53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
</pre>
<p> 100 以下の素数は全部で 25 個あります。
</p>
<p> ところで、この方法には無駄があります。x が素数か判別するため、x より小さい素数で割り切れるか調べていますが、実は√x より小さい素数を調べるだけでいいのです。リスト 5 をむりやり改造すると、リスト 6 のようになります。
</p>
<pre class="list">
リスト 6 : 素数を求める(2)

prime_list = [2]

for x in range(3, 100, 2):
    a = False
    for y in prime_list:
        if y * y &gt; x:
            a = True
            break
        if x % y == 0: break
    if a:
        prime_list.append(x)

print prime_list
</pre>
<p> 変数 a の使い方がポイントです。x が素数の場合は a をTrue にセットします。最初に a を False に初期化しておきます。y &gt; √y のかわりに y * y &gt; x をチェックし、真であれば a に True をセットして break します。x % y が 0 ならば、a は False のままで break します。そして、for ループが終了した後、変数 a をチェックして True であれば x を prime_list に追加します。
</p>
<p> これでリスト 5 よりも高速に素数を求めることができますが、リスト 6 のプログラムはちょっとわかりにくいのが欠点です。この場合、関数を使うとわかりやすいプログラムを作ることができます。関数は次回で詳しく説明します。
</p>

<h4 id="chap24">●おわりに</h4>
<p> Python の基本的なデータ型とデータ構造と制御構造について説明しました。Python はオブジェクト指向言語ですが、無理にオブジェクト指向機能を使わなくても、いろいろなプログラムを作ることができます。特に Python の関数は柔軟性があり、関数を使いこなすとちょっと複雑なプログラムでも簡単に作ることができます。次回は関数とファイル入出力について説明します。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="index.html#python_abc">Python</a> | <a href="python02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>