<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Julia プログラミング超入門</title>
  <meta name="description" content="Julia入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881803</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Julia Language Programming</h1>
<h2>お気楽 Julia プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
<hr>
</div>
<section class="contents">
<h3>Julia の基礎知識</h3>
<h4 id="abc08a">●内包表記とジェネレータ式</h4>
<ul>
  <li>Julia は角カッコの中に for 文を書いて配列を生成することができる
  <li>これを「内包表記 (comprehension)」という
  <li>基本的な構文を示す
<pre class="item">
[式 for 変数 = コレクション, ...]
</pre>
  <li>最初に要素の値を計算する式を書き、次に for 文を書く
  <li>そのあとに if 文を続けることもできる
  <li>for 文は多重ループにしてもよい
  <ul>
    <li>for x = ... for y = ... のように for 文でつなげると結果は 1 次元配列に格納される
    <li>for x = ..., y = ... のようにカンマでつなげると多次元配列になる
    <li>後ろに if 文があって多次元配列に格納できない場合は 1 次元配列になる
  </ul>
</ul>
<pre>
julia> a = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> [x * x for x = a]
5-element Array{Int64,1}:
  1
  4
  9
 16
 25

julia> [(x, x * x) for x = a]
5-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 4)
 (3, 9)
 (4, 16)
 (5, 25)

julia> [x * x for x = a if x % 2 == 0]
2-element Array{Int64,1}:
  4
 16

julia> [x + y for x = 1 : 3, y = 10 : 13]
3×4 Array{Int64,2}:
 11  12  13  14
 12  13  14  15
 13  14  15  16

julia> [x + y for x = 1 : 3 for y = 10 : 13]
12-element Array{Int64,1}:
 11
 12
 13
 14
 12
 13
 14
 15
 13
 14
 15
 16

julia> [x + y for x = 1 : 3, y = 10 : 13 if (x + y) % 2 == 0 ]
6-element Array{Int64,1}:
 12
 12
 14
 14
 14
 16
</pre>
<ul>
  <li>内包表記は角カッコで囲むが、丸カッコで囲んだものを「ジェネレータ式 (generator expressions)」という
  <li>基本的な構文は内包表記と同じ
  <li>配列を返さずに Generator オブジェクトを返す
  <li>配列の生成が不要な場合、たとえばコレクションにデータを追加するときはジェネレータ式のほうが効率的
</ul>
<pre>
julia> a
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> b = (x * x for x = a)
Base.Generator{Array{Int64,1},getfield(Main, Symbol("##35#36"))}(getfield(Main, Symbol("##35#36"))(), [1, 2, 3, 4, 5])

julia> for x in b
       println(x)
       end
1
4
9
16
25

julia> collect(b)
5-element Array{Int64,1}:
  1
  4
  9
 16
 25

julia> k = ["foo", "bar", "baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> v = [10, 20, 30]
3-element Array{Int64,1}:
 10
 20
 30

julia> d = Dict(key => val for (key, val) = zip(k, v))
Dict{String,Int64} with 3 entries:
  "bar" => 20
  "baz" => 30
  "foo" => 10

julia> Set(x * x for x = 1 : 10)
Set([4, 9, 25, 100, 81, 16, 36, 64, 49, 1])
</pre>
<ul>
  <li>Julia では、コレクションを生成する関数の引数にジェネレータを渡すことができる
  <li>このほかにも、<a href="juliaa02.html#abc14">イテレータ</a> を引数に受け取る関数でジェネレータを使うことができる
</ul>
<h4 id="abc09">●データ型の定義</h4>
<ul>
  <li>データ型は struct で定義する
<pre class="list">
struct 名前 &lt;: supertype
    変数1 :: データ型1
    変数2 :: データ型2
    ...
    変数n :: データ型n
end
</pre>
  <li>struct はメンバ変数の値を変更できない (immutable)
  <li>mutable struct はメンバ変数の値を変更できる
  <li>&lt;::supertype や ::データ型 を省略すると Any になる
  <li>コンストラクタは 名前(値1, 値2, ..., 値n)
  <li>メンバ変数のアクセスはドット ( . ) を使う
</ul>
<pre>
julia&gt; struct Foo
       a::Int
       b::Float64
       end

julia&gt; x = Foo(1, 1.23456)
Foo(1, 1.23456)

julia&gt; typeof(x)
Foo

julia&gt; x.a
1

julia&gt; x.b
1.23456

julia&gt; x.a = 10
ERROR: type Foo is immutable

julia&gt; mutable struct Bar
       a::Int
       b::Float64
       end

julia&gt; y = Bar(100, 123.456)
Bar(100, 123.456)

julia&gt; typeof(y)
Bar

julia&gt; y.a
100

julia&gt; y.a = 200
200

julia&gt; y
Bar(200, 123.456)
</pre>
</ul>
<ul>
  <li>コンストラクタを自作するときは struct の中で型名と同じ関数を定義し、その中で new() を呼び出す
</ul>
<pre>
julia&gt; struct Foo1
       a::Int
       Foo1(x) = x &gt; 0 ? new(x) : new(-x)
       end

julia&gt; foo1 = Foo1(10)
Foo1(10)

julia&gt; foo2 = Foo1(-10)
Foo1(10)
</pre>
<ul>
  <li>抽象型の定義は abstract を使う
<pre class="item">
abstract type 名前 end
abstract type 名前 &lt;: supertype end
</pre>
  <li>Union{型1, 型2, ...} は指定した型をすべて含むデータ型を表す (型の和集合)
  <li>name = Union{型1, 型2, ...} とすると、name をデータ型として使用できる
  <li>型1 &lt;: name, 型2 &lt;: name, ... はすべて true になる
</ul>
<pre>
julia&gt; Foo = Union{Int, Nothing}
Union{Nothing, Int64}

julia&gt; Int &lt;: Foo
true

julia&gt; Nothing &lt;: Foo
true

julia&gt; struct Baz
       x::Foo
       end

julia&gt; Baz(123)
Baz(123)

julia&gt; Baz(nothing)
Baz(nothing)
</pre>
<ul>
  <li>Union{Int, Nothing} は Int 型または Nothing 型を表す
  <li>Nothing 型の値は nothing だけ (シングルトンオブジェクト)
  <li>メンバ変数 x には整数 (Int32) と nothing しか格納できない
</ul>
<h4 id="abc10">●型パラメータ</h4>
<ul>
  <li>Julia でデータ型を定義するとき型パラメータを渡すことができる
  <li>型パラメータは struct name{T, U, V, ...} ... end のように { ... } の中で指定する
  <li>値を生成するときは name{型1, 型2, ...}(実引数1, 実引数2, ...) のように、{ ... } の中でデータ型を指定する
</ul>
<pre>
julia&gt; struct Foo{T}
       x::T
       end

julia&gt; Foo{Int}(123)
Foo{Int64}(123)

julia&gt; Foo{Float64}(1.2345)
Foo{Float64}(1.2345)
</pre>
<ul>
  <li>関数を定義するときも型パラメータを渡すことができる
  <li>funcname(仮引数1, 仮引数2, ...) where {T, U, V, ...} のように、where の後ろの { ... } の中で型パラメータを指定する
</ul>
<pre>
julia&gt; foo(a::Foo{T}) where {T} = a.x
foo (generic function with 1 method)

julia&gt; x = Foo{Int}(123)
Foo{Int64}(123)

julia&gt; y = Foo{Float64}(1.2345)
Foo{Float64}(1.2345)

julia&gt; foo(x)
123

julia&gt; foo(y)
1.2345
</pre>
<ul>
  <li>U &lt;: Type とすると型パラメータ U を Type のサブタイプに制限することができる
</ul>
<pre>
julia&gt; struct Bar{T &lt;: Integer}
       x::T
       end

julia&gt; Bar{Int}(123)
Bar{Int64}(123)

julia&gt; Bar{Int128}(123)
Bar{Int128}(123)

julia&gt; Bar{Float64}(1.23)
ERROR: TypeError: in Bar, in T, expected T&lt;:Integer, got Type{Float64}
</pre>
<h4 id="abc11">●ファイル入出力</h4>
<ul>
  <li>標準入出力は stdin, stdout, stderr
  <li>open(filename, mode) =&gt; IOStream, ファイルのオープン (Ｃ言語の fopen() と同じ)
  <li>mode を省略すると "r" になる
  <li>close(IOStream), ファイルのクローズ
  <li>read(IOStream, Type) =&gt; 値, Type 型のデータを読み込んで返す
  <li>write(IOStream, x) =&gt; 書き込んだバイト数, x を IOStream に書き込む
  <li>readline(IOStream) で 1 行読み込む (改行は削除されない)
  <li>ファイルから 1 行ずつ読み込む場合は eachline(IOStream) が便利 (改行は削除される)
</ul>
<pre class="list">
open("test.txt", "r") do fin
    for s = eachline(fin)
        println(s)
    end
end
</pre>
<ul>
  <li>open() は do block (Ruby 風のブロック) を受け取ることができる
  <li>ブロックの引数には open() でオープンしたストリームが渡される
  <li>ブロックの処理が終了するとファイルは自動的にクローズされる
  <li>read(IOStream, String) はファイルのすべての文字を読み込み、それを文字列に格納して返す
  <li>readlines() はファイルのすべての行を読み込み、それを配列に格納して返す
</ul>
<pre>
julia&gt; open("test.txt", "w") do fout
       for i = 1 : 5
       write(fout, "hello, Julia!\n")
       end
       end

julia&gt; open("test.txt") do fin
       for line = eachline(fin)
       println(line)
       end
       end
hello, Julia!
hello, Julia!
hello, Julia!
hello, Julia!
hello, Julia!

julia&gt; fin = open("test.txt")
IOStream(&lt;file test.txt&gt;)

julia&gt; read(fin, String)
"hello, Julia!\nhello, Julia!\nhello, Julia!\nhello, Julia!\nhello, Julia!\n"

julia&gt; close(fin)

julia&gt; fin = open("test.txt")
IOStream(&lt;file test.txt&gt;)

julia&gt; readlines(fin)
5-element Array{String,1}:
 "hello, Julia!"
 "hello, Julia!"
 "hello, Julia!"
 "hello, Julia!"
 "hello, Julia!"

julia&gt; close(fin)

</pre>
<ul>
  <li>コマンドライン引数は大域変数 ARGS に格納される
</ul>
<pre>
C&gt;julia test.jl abc def ghi
["abc", "def", "ghi"]
</pre>
<h4 id="abc12">●例外処理</h4>
<ul>
  <li>例外は error() または throw() で送出する
  <li>例外の捕捉は try ... catch ... finally ... end を使う
</ul>
<pre>
julia&gt; try
       error("oops!")
       catch err
       print(err)
       finally
       print("finish!!")
       end
ErrorException("oops!")finish!!
</pre>
<ul>
  <li>catch の引数には例外を表すデータがセットされる
  <li>finally 節は Python と同じ
  <li>例外を表すデータ型は Exception を継承している
  <li>例外の値は 型名(引数, ...) で生成する
  <li>error() は引数を ErrorException に格納して送出する
  <li>throw() は引数をそのまま例外として送出する
</ul>
<pre>
julia&gt; try
       throw("oops")
       catch err
       println(err)
       end
oops

julia&gt; try
       throw(ErrorException("oops"))
       catch err
       println(err)
       end
ErrorException("oops")
</pre>
<ul>
  <li>catch と throw を使えば「大域脱出 (global exit)」も実現できる
</ul>
<pre>
julia&gt; foo() = println("foo!")
foo (generic function with 1 method)

julia&gt; bar() = (println("bar!"); throw("Global Exit!!"))
bar (generic function with 1 method)

julia&gt; baz() = println("baz!")
baz (generic function with 1 method)

julia&gt; test() = (foo(); bar(); baz())
test (generic function with 1 method)

julia&gt; try
       test()
       catch err
       println(err)
       end
foo!
bar!
Global Exit!!
</pre>
<ul>
  <li>通常の関数呼び出しでは、呼び出し元の関数に制御が戻る
  <li>ところが bar() で throw() が実行されると、呼び出し元の関数 test() を飛び越えて、制御が try 文の catch 節に移る
  <li>このように、例外処理を使って関数を飛び越えて制御を移すことができるが、多用すべきではない
</ul>
<h4 id="abc13">●モジュール</h4>
<ul>
  <li>モジュールは module モジュール名 ... end で定義する
  <li>モジュール内で定義された名前 (変数名や関数名など) は モジュール名.名前 でアクセスする
  <li>import Foo.名前 はモジュール Foo で定義された名前をインポートする
  <li>import Foo.名前1, Foo.名前2, ... は import Foo: 名前1, 名前2, ... と記述することができる
  <li>import のかわりに using を使ってもよい
  <li>モジュールの外部に公開する名前は export で宣言する
  <li>using モジュール名 とすると export された名前をすべてインポートする
</ul>
<pre>
julia&gt; module Foo
       a, b, c, d = 1, 2, 3, 4
       export a, b
       end
Main.Foo

julia&gt; Foo.a
1

julia&gt; Foo.b
2

julia&gt; Foo.c
3

julia&gt; Foo.d
4

julia&gt; using .Foo

julia&gt; a
1

julia&gt; b
2

julia&gt; c
ERROR: UndefVarError: c not defined

julia&gt; import .Foo.c

julia&gt; c
3
julia&gt; c = 10
ERROR: cannot assign variable Foo.c from module Main
</pre>
<ul>
  <li>Main はトップレベルのモジュール
  <li>Julia の基本機能はモジュール Core に、標準ライブラリは Base に格納されている
  <li>モジュールは入れ子にすることができる
  <li>モジュールのパスの区切り記号はドット ( . )
  <li>REPL で定義したモジュールは Main の中に作成される
  <li>. はカレントモジュールを表す
  <li>..Module は一つ外側のモジュール, ...Module は 2 つ外側のモジュールを表す
  <li>import や using を使う場合、モジュールは絶対パスまたは相対パスで指定する
  <li>たとえば、カレントモジュールが Main で import Foo とすると、絶対パス Foo と認識する
  <li>絶対パス Main.Foo または相対パス .Foo を使って指定すること
  <li>モジュールで定義された大域変数は、他のモジュールから書き換えることはできない
</ul>
<pre class="list">
リスト : モジュールの簡単な使用例 (test_mod.jl)

module Foo
    a = 1
    set_a(x) = global a = x
    function show_a()
        println("Foo.a = $a")
        println("Foo.Bar.a = $(Bar.a)")
        println("Foo.Bar.Baz.a = $(Bar.Baz.a)")
    end

    module Bar 
        a = 10
        set_a(x) = global a = x
        import ..Foo             # 一つ外側のモジュール Foo をインポート
        function show_a()
            println("Foo.a = $(Foo.a)")
            println("Foo.Bar.a = $a")
            println("Foo.Bar.Baz.a = $(Baz.a)")
        end

        module Baz
            a = 100
            set_a(x) = global a = x
            import ..Bar
            import ...Foo        # 二つ外側のモジュール Foo をインポート
            function show_a()
                println("Foo.a = $(Foo.a)")
                println("Foo.Bar.a = $(Bar.a)")
                println("Foo.Bar.Baz.a = $a")
            end
        end
    end
end
</pre>
<pre>
julia&gt; include("test_mod.jl")
Main.Foo

julia&gt; Foo.Bar.Baz.show_a()
Foo.a = 1
Foo.Bar.a = 10
Foo.Bar.Baz.a = 100

julia&gt; Foo.set_a(123)
123

julia&gt; Foo.Bar.Baz.show_a()
Foo.a = 123
Foo.Bar.a = 10
Foo.Bar.Baz.a = 100
</pre>
<ul>
  <li>プログラムファイルの読み込みは include("ファイル名") 
  <li>モジュールファイル (またはパッケージファイル) の読み込みは import または using を使う
  <li>using Foo または import Foo は大域変数 LOAD_PATH に定義されているパスからファイル "Foo/src/Foo.jl" をロードする
  <li>Windows の場合、カレントディレクトリにサブディレクトリ Foo を作成し、Foo\src\Foo.jl にモジュール Foo を定義する
  <li>そして、カレントディレクトリのパスを LOAD_PATH に追加すると、using Foo で Foo.jl がロードされる
  <li>カレントディレクトリのパスは push!(LOAD_PATH, pwd()) で LOAD_PATH に追加できる
  <li>なお、Julia にはパッケージを管理するツール pkg やモジュール Pkg が用意されている
  <li>REPL で ] を入力すると pkg が起動する
  <li>実際にパッケージを作成するのであれば、これらツールを使ったほうがよいだろう
</ul>
<h4 id="abc14">●イテレータ</h4>
<ul>
  <li>データ型にイテレータを実装すると、for 文など便利な機能が利用できるようになる
  <li>イテレータを実装するには Base.iterate() を多重定義する
  <li>iterate(iter) =&gt; (item, state), イテレータの初期化, item は先頭要素, state は状態を表す
  <li>iterate(iter, state) =&gt; (item, state), 要素と次の状態を返す
  <li>要素がなくなったら nothing を返す
  <li>Base.length() を多重定義すると collect() で配列に格納できる
</ul>
<pre>
julia&gt; struct Fibo
       end

julia&gt; Base.iterate(::Fibo, state=(0, 1)) =
       if state[1] &lt; 0
       nothing
       else
       (state[1], (state[2], state[1] + state[2]))
       end

julia&gt; for x = Fibo()
       print(x, " ")
       end
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 
317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 
165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 
20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 
1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288 44945570212853 
72723460248141 117669030460994 190392490709135 308061521170129 498454011879264 806515533049393 1304969544928657 
2111485077978050 3416454622906707 5527939700884757 8944394323791464 14472334024676221 23416728348467685 
37889062373143906 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673 
679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120 4660046610375530309 
7540113804746346429

julia&gt; Base.length(::Fibo) = 93

julia&gt; collect(Fibo())
93-element Array{Any,1}:
                   0
                   1
                   1
                   2
                   3
                   5
                   8
                  13
                  21
                  34
                  55
                  89
                 144
                   ⋮
   37889062373143906
   61305790721611591
   99194853094755497
  160500643816367088
  259695496911122585
  420196140727489673
  679891637638612258
 1100087778366101931
 1779979416004714189
 2880067194370816120
 4660046610375530309
 7540113804746346429
</pre>
<ul>
  <li>モジュール Iterators にはイテレータを使うときに便利な関数が用意されている
  <li>これらの関数は新しいイテレータを返す
  <ul>
    <li>enumerate(iter), インデックスと要素をタプルに格納する
    <li>zip(iter, ...), イテレータの要素をタプルに格納する
    <li>take(iter, n), 先頭から n 個の要素を取り出す
    <li>drop(iter, n), 先頭から n 個の要素を取り除く
    <li>cycle(iter), iter を永遠に繰り返す
    <li>repeated(x [, n]), 要素 x を n 回繰り返す (n を省略すると無限回)
    <li>product(iter, ...), 直積集合
    <li>flatten(iter), 平坦化
    <li>partition(collection, n), 要素を n 個に分ける
    <li>filter(pred, iter), pred(x) が真を返す x を取り出す
    <li>reverse(iter), 要素を逆順に取り出す
    <li>rest(iter, state), iter の状態が state から始まるイテレータを返す
    <li>isempty(iter), iter が空であれば true を返す
  </ul>
</ul>
<pre>
julia&gt; for x = Iterators.enumerate(11 : 15)
       print(x, " ")
       end
(1, 11) (2, 12) (3, 13) (4, 14) (5, 15)
julia&gt; for x = Iterators.zip(1 : 5, 11 : 15)
       print(x, " ")
       end
(1, 11) (2, 12) (3, 13) (4, 14) (5, 15)
julia&gt; collect(Iterators.take(Fibo(), 10))
10-element Array{Any,1}:
  0
  1
  1
  2
  3
  5
  8
 13
 21
 34

julia&gt; collect(Iterators.take(Iterators.drop(Fibo(), 10), 5))
5-element Array{Any,1}:
  55
  89
 144
 233
 377

julia&gt; collect(Iterators.take(Iterators.cycle(1 : 4), 10))
10-element Array{Int64,1}:
 1
 2
 3
 4
 1
 2
 3
 4
 1
 2

julia&gt; collect(Iterators.take(Iterators.repeated(0), 5))
5-element Array{Int64,1}:
 0
 0
 0
 0
 0

julia&gt; collect(Iterators.product(1 : 3, 4 : 6))
3×3 Array{Tuple{Int64,Int64},2}:
 (1, 4)  (1, 5)  (1, 6)
 (2, 4)  (2, 5)  (2, 6)
 (3, 4)  (3, 5)  (3, 6)

julia&gt; for x = Iterators.product(1 : 3, 4 : 6)
       print(x, " ")
       end
(1, 4) (2, 4) (3, 4) (1, 5) (2, 5) (3, 5) (1, 6) (2, 6) (3, 6)
julia&gt; collect(Iterators.flatten(Iterators.product(1 : 3, 4 : 6)))
18-element Array{Int64,1}:
 1
 4
 2
 4
 3
 4
 1
 5
 2
 5
 3
 5
 1
 6
 2
 6
 3
 6

julia&gt; collect(Iterators.partition(1 : 10, 3))
4-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8, 9]
 [10]

julia&gt; collect(Iterators.filter(isodd, 1 : 10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia&gt; for x = Iterators.reverse(1 : 10)
       print(x, " ")
       end
10 9 8 7 6 5 4 3 2 1

julia&gt; collect(Iterators.take(Iterators.rest(Fibo(), (55, 89)), 10))
10-element Array{Any,1}:
   55
   89
  144
  233
  377
  610
  987
 1597
 2584
 4181
</pre>
<ul>
  <li>基本的にイテレータは immutable なデータ構造
  <li>変数 iter に格納されたイテレータから要素を取り出しても、iter の状態は変化しない
  <li>要素を取り出したあと、iter の状態を更新したい場合は Stateful(iter) を使う
  <li>popfirst!() も使えるようになる
</ul>
<pre>
julia&gt; a = 1 : 5
1:5

julia&gt; for x = a
       if x == 3 break end
       println(x)
       end
1
2

julia&gt; x
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; b = Iterators.Stateful(a)
Base.Iterators.Stateful{UnitRange{Int64},Union{Nothing, Tuple{Int64,Int64}}}(1:5, (1, 1), 0)

julia&gt; for x = b
       if x == 3 break end
       println(x)
       end
1
2

julia&gt; collect(b)
2-element Array{Int64,1}:
 4
 5

julia&gt; isempty(b)
true
</pre>
<hr>
<h3 id="chap">簡単なプログラム</h3>
<h4 id="chap11">●経路の探索</h4>
<pre class="list">
リスト : 経路の探索

#=
     ２───４───６ 
   ／│      │
 １  │      │
   ＼│      │
     ３───５───７

        経路図
=#

# 隣接リスト (配列の配列)
adjacent = [
    [2, 3],
    [1, 3, 4],
    [1, 2, 5],
    [2, 5, 6],
    [3, 4, 7],
    [4],
    [5]
]

# 深さ優先探索
function dfs(goal, xs)
    if xs[end] == goal
        println(xs)
    else
        for p = adjacent[xs[end]]
            if p in xs; continue; end
            push!(xs, p)
            dfs(goal, xs)
            pop!(xs)
        end
    end
end

# 幅優先探索
function bfs(start, goal)
    que = Array{Int,1}[[1]]
    while length(que) &gt; 0
        xs = popfirst!(que)
        if xs[end] == goal
            println(xs)
        else
            for p = adjacent[xs[end]]
                if p in xs; continue; end
                ys = copy(xs)
                push!(ys, p)
                push!(que, ys)
            end
        end
    end
end

# 反復進化

function ids(start, goal)
    function dfs(xs, limit)
        if length(xs) == limit
            if xs[end] == goal
                println(xs)
            end
        else
            for p = adjacent[xs[end]]
                if p in xs; continue; end
                push!(xs, p)
                dfs(xs, limit)
                pop!(xs)
            end
        end
    end

    for limit = 1 : length(adjacent)
      println("----- $limit -----")
      dfs([1], limit)
    end
end

println("----- dfs -----")
dfs(6, [1])
println("----- bfs -----")
bfs(1, 6)
println("----- ids -----")
ids(1, 6)
</pre>
<pre>
C&gt;julia keiro.jl
----- dfs -----
[1, 2, 3, 5, 4, 6]
[1, 2, 4, 6]
[1, 3, 2, 4, 6]
[1, 3, 5, 4, 6]
----- bfs -----
[1, 2, 4, 6]
[1, 3, 2, 4, 6]
[1, 3, 5, 4, 6]
[1, 2, 3, 5, 4, 6]
----- ids -----
----- 1 -----
----- 2 -----
----- 3 -----
----- 4 -----
[1, 2, 4, 6]
----- 5 -----
[1, 3, 2, 4, 6]
[1, 3, 5, 4, 6]
----- 6 -----
[1, 2, 3, 5, 4, 6]
----- 7 -----

</pre>
<h4 id="chap12">●ナンバープレース</h4>
<pre class="list">
リスト : ナンバープレースの解法

function check(board, x, y, n)
    # 縦横のチェック
    for i = 1 : 9
        if board[x, i] == n || board[i, y] == n
            return false
        end
    end
    # 枠のチェック
    x1 = div(x - 1, 3) * 3 + 1
    y1 = div(y - 1, 3) * 3 + 1
    for i = 0 : 2, j = 0 : 2
        if board[x1 + i, y1 + j] == n
            return false
        end
    end
    true
end

function solver(board, x, y)
    if y == 10
        println(board)
    elseif x == 10
        solver(board, 1, y + 1)
    elseif board[x, y] != 0
        solver(board, x + 1, y)
    else
        for n = 1 : 9
            if !check(board, x, y, n); continue; end
            board[x, y] = n
            solver(board, x + 1, y)
            board[x, y] = 0
        end
    end
end

# 問題 (出典: 数独 - Wikipedia の問題例)
q00 = [
    5 3 0  0 7 0  0 0 0;
    6 0 0  1 9 5  0 0 0;
    0 9 8  0 0 0  0 6 0;

    8 0 0  0 6 0  0 0 3;
    4 0 0  8 0 3  0 0 1;
    7 0 0  0 2 0  0 0 6;

    0 6 0  0 0 0  2 8 0;
    0 0 0  4 1 9  0 0 5;
    0 0 0  0 8 0  0 7 9
]

println(q00)
println("--------")
@time solver(copy(q00), 1, 1)
println("--------")
</pre>
<pre>
C&gt;julia numplace.jl
[5 3 0 0 7 0 0 0 0;
 6 0 0 1 9 5 0 0 0;
 0 9 8 0 0 0 0 6 0;
 8 0 0 0 6 0 0 0 3;
 4 0 0 8 0 3 0 0 1;
 7 0 0 0 2 0 0 0 6;
 0 6 0 0 0 0 2 8 0;
 0 0 0 4 1 9 0 0 5;
 0 0 0 0 8 0 0 7 9]
--------
[5 3 4 6 7 8 9 1 2;
 6 7 2 1 9 5 3 4 8;
 1 9 8 3 4 2 5 6 7;
 8 5 9 7 6 1 4 2 3;
 4 2 6 8 5 3 7 9 1;
 7 1 3 9 2 4 8 5 6;
 9 6 1 5 3 7 2 8 4;
 2 8 7 4 1 9 6 3 5;
 3 4 5 2 8 6 1 7 9]
  0.043059 seconds (47.90 k allocations: 2.449 MiB)
--------
</pre>
<h4 id="chap13">●小町算</h4>
<p> 1 から 9 までの数字を順番に並べ、間に + と - を補って 100 になる式を作ってください。ただし、1 の前に - 符号はつけないものとします。
</p>
<pre class="item">
例：1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
</pre>

<pre class="list">
リスト : 小町算

# 計算
function calc_expr(nums, ops)
    a = nums[1]
    i = 2
    for op = ops
        a += op == '+' ? nums[i] : -nums[i]
        i += 1
    end
    a
end

# 表示
function print_expr(nums, ops)
    print(nums[1])
    i = 2
    for op = ops
        print(op == '+' ? " + " : " - ")
        print(nums[i])
        i += 1
    end
    println(" = 100")
end

# 小町算の解法
function komachi(n, nums, ops)
    if n == 10
        if calc_expr(nums, ops) == 100
            print_expr(nums, ops)
        end
    else
        for op = ['+', '-']
            push!(ops, op)
            push!(nums, n)
            komachi(n + 1, nums, ops)
            pop!(nums)
            pop!(ops)
        end
        m = nums[end]
        nums[end] = m * 10 + n
        komachi(n + 1, nums, ops)
        nums[end] = m
    end
end

komachi(2, [1], [])
</pre>
<pre>
C&gt;julia komachi.jl
1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
1 + 2 + 34 - 5 + 67 - 8 + 9 = 100
1 + 23 - 4 + 5 + 6 + 78 - 9 = 100
1 + 23 - 4 + 56 + 7 + 8 + 9 = 100
12 + 3 + 4 + 5 - 6 - 7 + 89 = 100
12 + 3 - 4 + 5 + 67 + 8 + 9 = 100
12 - 3 - 4 + 5 - 6 + 7 + 89 = 100
123 + 4 - 5 + 67 - 89 = 100
123 + 45 - 67 + 8 - 9 = 100
123 - 4 - 5 - 6 - 7 + 8 - 9 = 100
123 - 45 - 67 + 89= 100
</pre>
<h4 id="chap14">●ファイルの連結</h4>
<pre class="list">
#
# cat.jl : ファイルの連結
#
#          Copyright (C) 2016-2018 Makoto Hiroi
#

function cat(fin)
    for line = eachline(fin)
        println(line)
    end
end

#
if length(ARGS) == 0
    cat(stdin)
else
    for name = ARGS
        open(name, "r") do fin
            cat(fin)
        end
    end
end
</pre>
<h4 id="chap15">●単語のカウント</h4>
<pre class="list">
#
# wc.jl : 単語のカウント
#
#         Copyright (C) 2016-2018 Makoto Hiroi
#
function wc(fin)
    word = 0
    inword = false
    while !eof(fin)
        c = read(fin, Char)
        if isspace(c)
            inword = false
        elseif !inword
            inword = true
            word += 1
        end
    end
    word
end

if length(ARGS) == 0
    println(wc(stdin))
else
    open(ARGS[1], "r") do fin
        println(wc(fin))
    end
end
</pre>
<ul>
  <li>read(IOStream, Char) は ASCII コードだけではなく UTF-8 も 1 文字として返す
  <li>関数 eof() はストリームが終端 (end-of-file) に達していれば true を返す
  <li>isspace() は空白文字 (全角の空白文字も含む) を判定する
  <li>split(string) で単語に切り分けることもできる
</ul>
<pre>
julia&gt; split("foo bar baz oops!")
4-element Array{SubString{String},1}:
 "foo"
 "bar"
 "baz"
 "oops!"
</pre>

<h4 id="chap16">●文字列の検索</h4>
<pre class="list">
#
# grep.jl : 文字列の検索
#
#           Copyright (C) 2016-2018 Makoto Hiroi
#
function grep(fin, key)
    for line = eachline(fin)
        if occursin(key, line)
            println(line)
        end
    end
end

if length(ARGS) == 1
    # 検索文字列のみ
    grep(stdin, ARGS[1])
elseif length(ARGS) &gt;= 2
    open(ARGS[2]) do fin
        grep(fin, ARGS[1])
    end
else
    println("usage: julia grep.jl key [filename]")
end
</pre>
<ul>
  <li>occursin(key, line) は line の先頭から key を検索し、見つけたら true を返す
</ul>
<pre>
julia&gt; occursin("hello", "hello, Julia!")
true

julia&gt; occursin("julia", "hello, Julia!")
false
</pre>

<h4 id="chap17">●文字の置換</h4>
<pre class="list">
#
# tr.jl : 文字の置換
#
#         Copyright (C) 2016-2018 Makoto Hiroi
#
function tr(fin, s1, s2)
    while !eof(fin)
        c = read(fin, Char)
        n = findfirst(isequal(c), s1)
        if n != nothing
            c = s2[n]
        end
        print(c)
    end
end

if length(ARGS) &gt;= 2
    if length(ARGS[1]) == length(ARGS[2])
        if length(ARGS) == 2
            tr(stdin, ARGS[1], ARGS[2])
        else
            open(ARGS[3], "r") do fin
                tr(fin, ARGS[1], ARGS[2])
            end
        end
    else
        println("第 1 引数と第 2 引数の長さが異なる")
    end
else
    println("usage: julia tr str1 str2 [filename]")
end
</pre>
<ul>
  <li>文字列は角カッコ str[n] で n 番目にある文字を取り出すことができる (書き換えはできない)
  <li>範囲オブジェクトで部分文字列を取り出すこともできる
</ul>
<pre>
julia&gt; a = "abcde"
"abcde"

julia&gt; a[1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; a[5]
'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)

julia&gt; a[2:4]
"bcd"
</pre>
<ul>
  <li>findfirst(pred, array_or_string) は関数 pred が真を返す要素の位置 (添字) を返す
  <li>findfirst(key, string) は string から key を検索し、見つけたら範囲オブジェクトを返す
  <li>見つからない場合は nothing を返す
  <li>findnext(pred, array_or_string, n), findnext(key, string, n) は n 番目の要素から検索を開始する
  <li>isequal(x, y) は x と y が等しいとき true を返す
  <li>isequal(x) は y -&gt; isequal(x, y) と同等の関数を返す
</ul>
<pre>
julia&gt; findfirst(isequal('J'), "hello, Julia!")
8

julia&gt; findfirst(isequal('j'), "hello, Julia!")

julia&gt; findfirst("Julia", "hello, Julia!")
8:12

julia&gt; findfirst("JuliA", "hello, Julia!")

</pre>
<h4 id="chap18">●文字列の置換</h4>
<pre class="list">
#
# gres.jl : 文字列の置換
#
#           Copyright (C) 2016-2018 Makoto Hiroi
#
function gres(fin, pat, r)
    for line = eachline(fin)
        print(replace(line, pat =&gt; r))
    end
end

if length(ARGS) == 2
    gres(STDIN, ARGS[1], ARGS[2])
elseif length(ARGS) == 3
    open(ARGS[3], "r") do fin
        gres(fin, ARGS[1], ARGS[2])
    end
else
    println("usage: julia gres.jl pattern replace [filename]")
end
</pre>
<ul>
  <li>関数 replace(string, pat =&gt; r, count=n) は文字列 string から pat を検索し、それを r に置き換える
  <li>count=n は置換回数で、省略すると pat と一致する部分文字列をすべて置換する
</ul>
<pre>
julia&gt; replace("foo bar baz foo bar baz oops", "foo" =&gt; "FOO")
"FOO bar baz FOO bar baz oops"

julia&gt; replace("foo bar baz foo bar baz oops", "foo" =&gt; "FOO", count=1)
"FOO bar baz foo bar baz oops"
</pre>

<h4 id="chap19">●ファイルのコピー</h4>
<pre class="list">
#
# cp.jl : ファイルのコピー
#
#         Copyright (C) 2016-2018 Makoto Hiroi
#

# バイト単位のコピー
function cp(fin, fout)
    while !eof(fin)
        write(fout, read(fin, UInt8))
    end
end

# バッファに読み込む
function cp1(fin, fout)
    local n
    buff = Array{UInt8, 1}(undef, 16)
    while (n = readbytes!(fin, buff)) == 16
        write(fout, buff)
    end
    write(fout, buff[1 : n])
end

if length(ARGS) == 2
    open(ARGS[1], "r") do fin
        open(ARGS[2], "w") do fout
            cp(fin, fout)
        end
    end
else
    println("usage: julia cp.jl src dst")
end
</pre>
<ul>
  <li>read(IOStream, UInt8) はストリームが終端に達していればエラーを送出する
  <li>バッファに読み込みたい場合は readbytes!() を使う
  <li>返り値は読み込んだバイト数
</ul>

<h4 id="chap20">●ファイルのエントロピー</h4>
<pre class="list">
#
# entoropy.jl : ファイルのエントロピーを求める
#
#               Copyright (C) 2016-2018 Makoto Hiroi
#
function entoropy(fin)
    count = zeros(Int, 256)
    while !eof(fin)
        c = read(fin, UInt8)
        count[c + 1] += 1
    end
    total = sum(count)
    e = 0.0
    for x = count
        if x == 0; continue; end
        p = x / total
        e += - p * log(2, p)
    end
    e, e * total / 8
end

if length(ARGS) == 1
    open(ARGS[1], "r") do fin
        println(entoropy(fin))
    end
else
    println("usage: julia entoropy.jl filename")
end
</pre>
<ul>
  <li>エントロピーについては <a href="index.html#python_algo">Algorithms with Python</a> <a href="pyalgo31.html">シャノン・ファノ符号とハフマン符号</a> で説明している
  <li>log(b, x) は log<sub>b</sub> x を計算する
  <li>log(x) は log<sub>e</sub> x を計算する (e =  2.7182818284590...)
</ul>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016-2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>