<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby プログラミング入門</title>
  <meta name="description" content="Ruby,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881800</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Ruby プログラミング入門</h1>
<h2>付録</h2>
<div class="small">
[ <a href="abcruby14.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcrubyz2.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">Enumerator</h3>
<ul>
  <li>Enumerator はオブジェクトの要素を列挙するためのクラス
  <li>Enumerable をインクルードしているので、Enumerable のメソッドを利用できる
  <li>Enumerator の生成にはメソッド Object#to_enum (または Object#enum_for) を使う
<pre class="item">
object.to_enum(method, *args) =&gt; Enumerator
</pre>
  <ul>
    <li>method は object から要素を取得するためのメソッドをシンボルで指定する
    <li>args には method に渡す引数を指定する
    <li>method を省略すると each() が使用される
    <li>Ruby 2.3 ではブロックを省略すると Enumerator を返すメソッドがたくさん用意されている
  </ul>
  <li>要素を返すメソッドは next(), next_values(), peek(), peek_values() がある
  <li>next 系はイテレータを次の要素に進めるが、peek 系は進めない
  <li>values 系は要素を配列に格納して返す
  <li>メソッド rewind() は最初の状態に巻き戻す
  <li>メソッド with_index() はインデックス付きの each()
<pre class="item">
with_index(offset=0) {|(*args), idx| ... } =&gt; object
</pre>
  <ul>
    <li>メソッド each_with_index() と違って offset を指定できる
  </ul>
</ul>
<pre>
irb&gt; class Foo
irb&gt; def each
irb&gt; yield 1
irb&gt; yield 2
irb&gt; yield 3
irb&gt; end
irb&gt; end
=&gt; :each
irb&gt; a = Foo.new
=&gt; #&lt;Foo: ... &gt;
irb&gt; a.map {|x| x * x}
NoMethodError: undefined method `map' for #&lt;Foo: ... &gt;
・・・省略・・・

irb&gt; e = a.to_enum
=&gt; #&lt;Enumerator: #&lt;Foo: ... &gt;:each&gt;
irb&gt; e.map {|x| x * x}
=&gt; [1, 4, 9]
irb&gt; e.next
=&gt; 1
irb&gt; e.next
=&gt; 2
irb&gt; e.next
=&gt; 3
irb&gt; e.next
StopIteration: iteration reached an end

irb&gt; e.rewind
=&gt; #&lt;Enumerator: #&lt;Foo: ... &gt;:each&gt;
irb&gt; e.peek
=&gt; 1
irb&gt; e.peek
=&gt; 1
irb&gt; e.peek_values
=&gt; [1]
irb&gt; e.next_values
=&gt; [1]
irb&gt; e.next_values
=&gt; [2]
irb&gt; [1,2,3,4,5].to_enum.with_index{|k, i| print i, " ", k, "\n"}
0 1
1 2
2 3
3 4
4 5
=&gt; [1, 2, 3, 4, 5]
irb&gt; [1,2,3,4,5].to_enum.with_index(1){|k, i| print i, " ", k, "\n"} 
1 1
2 2
3 3
4 4
5 5
=&gt; [1, 2, 3, 4, 5]
irb&gt; [1,2,3,4,5].each_with_index{|k, i| print i, " ", k, "\n"}
0 1
1 2
2 3
3 4
4 5
=&gt; [1, 2, 3, 4, 5]
</pre>
<ul>
  <li>Enumerator のオブジェクトは new() でも生成できる
<pre class="item">
1. Enumerator.new(object, method, *args) =&gt; Enumerator
2. Enumerator.new(size=nil) {|y| ... }  =&gt; Enumerator
</pre>
  <ul>
    <li>1. は to_eum() と同じ
    <li>2. はブロックでデータを生成する
    <li>ブロックの引数 y には Enumerator::Yielder オブジェクトが渡される
    <li>生成した要素 (item) は y &lt;&lt; item で出力する
    <li>引数 size は  Integer、Float::INFINITY、手続きオブジェク ト、nil のいずれかを指定する
    <li>size はメソッド size() で参照 (手続きオブジェクトの場合はそのときに実行される)
  </ul>
</ul>
<pre>
irb&gt; ints = Enumerator.new(Float::INFINITY) {|y|
irb&gt; n = 1
irb&gt; loop {
irb&gt; y &lt;&lt; n
irb&gt; n += 1
irb&gt; }
irb&gt; }
=&gt; #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;
irb&gt; ints.next
=&gt; 1
irb&gt; ints.next
=&gt; 2
irb&gt; ints.next
=&gt; 3
irb&gt; ints.next
=&gt; 4
irb&gt; ints.next
=&gt; 5
irb&gt; ints.rewind
=&gt; #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;
irb&gt; ints.next
=&gt; 1
irb&gt; ints.next
=&gt; 2
irb&gt; ints.next
=&gt; 3
irb&gt; ints.size
=&gt; Infinity
</pre>
<ul>
  <li>ints は無限の整数列 (1, 2, 3, ...) を生成する
  <li>無限リストの場合、map(), select(), drop() など配列を返すメソッドは使用できない (無限の配列を返そうとするため)
  <li>無限リストを取り扱うにはメソッド Enumerable#lazy で Enumerator を Enumerator::Lazy に変換する
  <li>本稿では Enumerator::Lazy のオブジェクトを「遅延リスト」と呼ぶことにする
</ul>
<h4>●参考 URL</h4>
<ul>
  <li><a href="http://magazine.rubyist.net/?0011-BundledLibraries">Rubyist Magazine - 標準添付ライブラリ紹介 【第 5 回】enumerator</a>, (西山さん)
</ul>
<hr>
<h3 id="chap02">Enumerator::Lazy</h3>
<ul>
  <li>Enumerator::Lazy は遅延リストを表すクラス
  <li>map(), select(), drop() などのメソッドが遅延評価版に切り替わる
  <li>遅延リストはメソッド Enumerable#lazy で生成する
  <li>遅延リストから値を取り出すにはメソッド force() か first() を使う
  <li>first() は先頭要素を取り出す
  <li>first(n) は先頭から n 個の要素を取り出して配列に格納して返す
</ul>
<pre>
irb&gt; intslazy = ints.lazy
=&gt; #&lt;Enumerator::Lazy: #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;&gt;
irb&gt; intslazy.next
=&gt; 1
irb&gt; intslazy.next
=&gt; 2
irb&gt; intslazy.next
=&gt; 3
irb&gt; intslazy.drop(100)
=&gt; #&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;&gt;:drop(100)&gt;
irb&gt; intslazy.drop(100).first
=&gt; 101
irb&gt; intslazy.drop(100).first(10)
=&gt; [101, 102, 103, 104, 105, 106, 107, 108, 109, 110]
irb&gt; intslazy.map {|x| x * 2}
=&gt; #&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;&gt;:map&gt;
irb&gt; intslazy.map {|x| x * 2}.take(10).force
=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
irb&gt; intslazy.map {|x| x * 2}.first(10)
=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</pre>
<ul>
  <li>無限の整数列は (1..Float::INFINITY).lazy でも生成できる
  <li>Enumerator や Enumerator::Lazy は immutable ではない (メソッド next() は状態を変化させている)
  <li>また、実行結果もキャッシュしていない
  <li>一般に、関数型言語の「遅延ストリーム」は immutable なので、それとは使い勝手が異なることに注意
</ul>
<h4>●簡単な例題</h4>
<pre class="list">
リスト : 無限数列の生成

def iterate(a, &amp;func)
  Enumerator.new(Float::INFINITY) {|y|
    n = a
    loop {
      y &lt;&lt; n
      n = func.call(n)
    }
  }.lazy
end

def tabulate(a = 0, &amp;func)
  Enumerator.new(Float::INFINITY) {|y|
    n = a
    loop {
      y &lt;&lt; func.call(n)
      n += 1
    }
  }.lazy
end
</pre>
<pre>
irb&gt; iterate(1, &amp;:itself).first(10)
=&gt; [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
irb&gt; iterate(2, &amp;:itself).first(10)
=&gt; [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
irb&gt; iterate(1){|x| x + 1}.first(10)
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
irb&gt; iterate(1){|x| x + 2}.first(10)
=&gt; [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
irb&gt; iterate([0, 1]){|x, y| [y, y + x]}.first(10)
=&gt; [[0, 1], [1, 1], [1, 2], [2, 3], [3, 5], [5, 8], [8, 13], [13, 21], [21, 34], [34, 55]]
irb&gt; iterate([0, 1]){|x, y| [y, y + x]}.map{|x| x[0]}.first(10)    # フィボナッチ数
=&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
irb&gt; iterate([2, 1]){|x, y| [y, y + x]}.map{|x| x[0]}.first(10)    # リュカ数
=&gt; [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
irb&gt; iterate([0, 0, 1]){|x, y, z| [y, z, z + y + x]}.map{|x| x[0]}.first(20)  # トリボナッチ数
=&gt; [0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513]

irb&gt; tabulate(&amp;:itself).first(10)
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb&gt; tabulate(10, &amp;:itself).first(10)
=&gt; [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
irb&gt; tabulate(1){|x| x * (x + 1) / 2}.first(10)     # 三角数
=&gt; [1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
irb&gt; tabulate(1){|x| x * x}.first(10)               # 四角数
=&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
irb&gt; tabulate(1){|x| x * (3 * x - 1) / 2}.first(10) # 五角数
=&gt; [1, 5, 12, 22, 35, 51, 70, 92, 117, 145]

irb&gt; def to_fizzbuzz(n)
irb&gt; if n % 15 == 0
irb&gt; "FizzBuzz"
irb&gt; elsif n % 3 == 0
irb&gt; "Fizz"
irb&gt; elsif n % 5 == 0
irb&gt; "Buzz"
irb&gt; else
irb&gt; n.to_s
irb&gt; end
irb&gt; end
=&gt; :to_fizzbuzz
irb&gt; tabulate(1){|x| to_fizzbuzz(x)}.first(100)
=&gt; ["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", 
"13", "14", "FizzBuzz", "16", "17", "Fizz", "19", "Buzz", "Fizz", "22", "23", "Fizz", 
"Buzz", "26", "Fizz", "28", "29", "FizzBuzz", "31", "32", "Fizz", "34", "Buzz", 
"Fizz", "37", "38", "Fizz", "Buzz", "41", "Fizz", "43", "44", "FizzBuzz", "46", "47", 
"Fizz", "49", "Buzz", "Fizz", "52", "53", "Fizz", "Buzz", "56", "Fizz", "58", "59", 
"FizzBuzz", "61", "62", "Fizz", "64", "Buzz", "Fizz", "67", "68", "Fizz", "Buzz", 
"71", "Fizz", "73", "74", "FizzBuzz", "76", "77", "Fizz", "79", "Buzz", "Fizz", "82", 
"83", "Fizz", "Buzz", "86", "Fizz", "88", "89", "FizzBuzz", "91", "92", "Fizz", "94", 
"Buzz", "Fizz", "97", "98", "Fizz", "Buzz"]

irb&gt; def newton(n)
irb&gt; iterate(n) {|x| (x + n / x) / 2.0}
irb&gt; end
=&gt; :newton
irb&gt; newton(2).first(10)
=&gt; [2, 1.5, 1.4166666666666665, 1.4142156862745097, 1.4142135623746899, 
1.414213562373095, 1.414213562373095, 1.414213562373095, 1.414213562373095, 
1.414213562373095]
irb&gt; newton(3).first(10)
=&gt; [3, 2.0, 1.75, 1.7321428571428572, 1.7320508100147274, 1.7320508075688772, 
1.7320508075688772, 1.7320508075688772, 1.7320508075688772, 1.7320508075688772]
</pre>
<pre class="list">
リスト : 素数列 (myprime.rb)

class Myprime
  @@primes = [2, 3, 5]    # 求めた素数を格納

  # 次の素数を求める
  def Myprime.next_prime(n)
    while true
      for p in @@primes
        return n if p * p > n
        break if n % p == 0
      end
      n += 2
    end
  end

  # 素数列の生成
  def Myprime.make
    Enumerator.new(Float::INFINITY) {|y|
      n = 0
      while true
        if n == @@primes.size
          @@primes.push Myprime.next_prime(@@primes[-1] + 2)
        end
        y &lt;&lt; @@primes[n]
        n += 1
      end
    }.lazy
  end
end
</pre>
<pre>
irb&gt; load "myprime.rb"
=&gt; true
irb&gt; ps = Myprime.make
=&gt; #&lt;Enumerator::Lazy: #&lt;Enumerator: #&lt;Enumerator::Generator: ... &gt;:each&gt;&gt;
irb&gt; ps.first(25)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 
79, 83, 89, 97]
irb&gt; ps.first(100)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 
79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 
173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 
269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 
373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 
467, 479, 487, 491, 499, 503, 509, 521, 523, 541]
irb&gt; ps.drop(1000).first(10)
=&gt; [7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017]
</pre>
<h4>●参考 URL</h4>
<ul>
  <li><a href="http://magazine.rubyist.net/?0041-200Special-lazy">Rubyist Magazine - 無限リストを map 可能にする Enumerable#lazy</a>, (原悠さん)
</ul>
<hr>
<h3 id="chap03">Fiber</h3>
<ul>
  <li>概要
  <ul>
    <li>Ruby の Fiber はコルーチン (co-routine) のこと
    <li>関数 (サブルーチン, sub-routine) は call してから return するまで途中で処理を中断することはできない
    <li>コルーチンは途中で処理を中断し、そこから実行を再開することができる
    <li>Ruby のコルーチンは「セミコルーチン (semi-coroutine)」が基本
    <li>セミコルーチンには親子関係があり、コルーチン A からコルーチン B を呼び出した場合、A が親で B が子になる
    <li>本稿では Fiber をコルーチンと記述する
  </ul>
  <li>コルーチン は Fiber.new { ... } で生成する
  <li>コルーチンを実行 (または再開) するにはメソッド resume() を使う
  <li>rensume() を呼び出したほうが親、呼び出されたほうが子になる
  <li>子コルーチンの中でクラスメソッド Fiber.yield() を実行すると、そこでプログラムの実行を中断して親コルーチンに戻る
  <li>yield() の引数が親コルーチンで呼び出した resume() の返り値になる
  <li>resume() に引数を渡して実行を再開すると、それが Fiber.yield() の返り値となる
</ul>
<pre>
irb(main)&gt; co = Fiber.new {
irb(main)&gt; for x in 1 .. 4
irb(main)&gt; Fiber.yield x
irb(main)&gt; end
irb(main)&gt; 5
irb(main)&gt; }
=&gt; #&lt;Fiber:0x834bd24&gt;
irb&gt; co.resume
=&gt; 1
irb&gt; co.resume
=&gt; 2
irb&gt; co.resume
=&gt; 3
irb&gt; co.resume
=&gt; 4
irb&gt; co.resume
=&gt; 5
irb&gt; co.resume
FiberError: dead fiber called

</pre>
<ul>
  <li>resume() が返す値は Fiber.yield() だけではなくブロックの実行結果も返す
  <li>終了したコルーチンに resume() を適用するとエラーになる
</ul>
<h4>●簡単な例題</h4>
<pre class="list">
リスト : 複数のコルーチン

def print_code(code)
  loop {
    print code
    Fiber.yield true
  }
end

def test_a(n)
  xs = ["h", "e", "y", "!", " "].map {|x| Fiber.new {print_code(x)}}
  n.times {
    xs.each {|co| co.resume}
  }
end
</pre>
<pre>
irb&gt; test_a(5)
hey! hey! hey! hey! hey! =&gt; 5
irb&gt; test_a(10)
hey! hey! hey! hey! hey! hey! hey! hey! hey! hey! =&gt; 10
</pre>
<pre class="list">
リスト : 順列の生成

def perm_sub(xs, n)
  if xs.size == n
    Fiber.yield []
  else
    co = Fiber.new { perm_sub(xs, n + 1) }
    while ys = co.resume
      for x in xs
        if not ys.member? x
          Fiber.yield(ys + [x])
        end
      end
    end
  end
end

def permutation(xs)
  Fiber.new { perm_sub(xs, 0) }
end
</pre>
<pre>
irb&gt; co = permutation([1,2,3])
=&gt; #&lt;Fiber: ... &gt;
irb&gt; while xs = co.resume
irb&gt; print xs, "\n"
irb&gt; end
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
=&gt; nil
</pre>
<pre class="list">
リスト : エラトステネスの篩

# n から始まる整数列
def integers(n)
  Fiber.new {
    loop {
      Fiber.yield n
      n += 1
    }
  }
end

# フィルター
def filter(src)
  Fiber.new {
    while m = src.resume
      Fiber.yield(m) if yield(m)
    end
  }
end

def sieve(x)
  nums = integers(2)
  x.times {
    n = nums.resume
    print n, " "
    nums = filter(nums) {|x| x % n != 0}
  }
end
</pre>
<pre>
irb&gt; sieve 25
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 =&gt; 25
irb&gt; sieve 100
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 
109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 
229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 
353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 
479 487 491 499 503 509 521 523 541 =&gt; 100
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcruby14.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcrubyz2.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>