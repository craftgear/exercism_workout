<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 NumPy プログラミング超入門 </title>
  <meta name="description" content="Python,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881762</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Python3 Programming</h1>
<h2>お気楽 NumPy プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#numpy_abc">Python3</a> ]
<hr>
</div>
<section class="contents">
<h4 id="chap01">●Hello, NumPy!!</h4>
<ul>
  <li>NumPy は数値計算を効率的に行うための拡張モジュール</li>
  <li>多次元配列のサポートとそれを操作するための高度な数学関数が提供される</li>
  <li>本ページでは基本的な使い方を簡単に説明する</li>
  <li>インストールは pip を使うと簡単</li>
<pre class="item">
python -m pip install numpy
</pre>
  <li>pip は Python で書かれたパッケージ管理ツール</li>
  <li>最新の Python は pip を同梱している</li>
  <li>あとは numpy をインポートするだけ</li>
<pre class="item">
import numpy as np
</pre>
  <li>as を使うとモジュールに別名を付けることができる</li>
  <li>下記の参考 URL を読むと、別名に np を付けるのが一般的なようである</li>
  <li>参考 URL</li>
  <ul>
    <li><a href="http://www.numpy.org/">NumPy</a>, (本家)</li>
    <li><a href="https://docs.scipy.org/doc/">Numpy and Scipy Documentation</a>, (本家)</li>
    <li><a href="http://rest-term.com/archives/2999/">Pythonの数値計算ライブラリ NumPy入門</a>, (rest term さん)</li>
    <li><a href="http://www.python.ambitious-engineer.com/numpy-index">Numpy入門 - Python学習講座</a>, (Kuro さん)</li>
    <li><a href="http://ibisforest.org/index.php?python%2Fnumpy">python/numpy</a>, (朱鷺の杜Wiki さん)</li>
  </ul>
</ul>
<ul>
  <li>計算結果を画像で表示したい場合は matplotlib を使うとよい</li>
  <li>次のコマンドで必要なパッケージをすべてインストールできる</li>
<pre class="item">
pip install matplotlib
</pre>
  <li>本ページでは matplotlib の説明は割愛する</li>
  <li>基本的な使い方は下記参考 URL を参照</li>
  <li>参考 URL</li>
  <ul>
    <li><a href="https://matplotlib.org/">Matplotlib</a>, (本家)</li>
    <li><a href="https://matplotlib.org/users/index.html">User's Guide</a>, (本家)</li>
    <li><a href="http://yubais.net/doc/matplotlib/">matplotlib 入門</a>, (柞刈湯葉さん)</li>
    <li><a href="http://bicycle1885.hatenablog.com/entry/2014/02/14/023734">matplotlib入門 - りんごがでている</a>, (bicycle1885 さん)</li>
  </ul>
</ul>
<pre class="list">
リスト : numpy と matplotlib の簡単な使用例

import math
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 2 * np.pi, 100)
plt.plot(x, np.sin(x))
plt.plot(x, np.cos(x))

# plt.savefig("testplt.png", dpi=50)
plt.show()
</pre>
<p><img src="img/testplt.png">
</p>
<h4 id="chap02">●配列 ndarray</h4>
<ul>
  <li>NumPy の多次元配列は ndarray というクラス</li>
  <ul>
    <li>固定長配列</li>
    <li>要素は同じデータ型</li>
  </ul>
  <li>基本的なコンストラクタは array(初期値, [dtype=型を表す値])</li>
  <li>初期値はリストやタプルで指定する</li>
  <li>dtype を省略すると、データ型は初期値の要素の型で決める</li>
  <li>dtype で指定する値は、データ型、文字列、Data Type Object (クラス numpy.dtype のインスタンス)</li>
  <li>NumPy で定義されているデータ型</li>
  <ul>
    <li>bool_, 真偽値</li>
    <li>int_, 符号付整数 (int8, int16, int32, int64)</li>
    <li>uint, 無符号整数 (uint8, uint16, uint32, uint64)</li>
    <li>float_, 浮動小数点数 (float16, float32, float64)</li>
    <li>complex_, 複素数 (complex64, complex128)</li>
  </ul>
  <li>これらのデータ型は NumPy のクラスとして定義されている</li>
  <li>クラス名(初期値) でも配列を生成できる</li>
  <li>dtype にはデータ型名 (文字列) や次に示す文字列を渡してもよい</li>
  <ul>
    <li>?, 真偽値</li>
    <li>i, 符号付整数 (i1, i2, i4, i8)</li>
    <li>I, 無符号整数 (u1, u2, u4, u8)</li>
    <li>f, 浮動小数点数 (f2, f4, f8)</li>
    <li>c8, c16, 複素数</li>
    <li>U, ユニコード文字列 (U の後ろに長さを指定する)</li>
    <li>O, Python のオブジェクト</li>
  </ul>
</ul>
<pre>
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; a.dtype
dtype('int32')

&gt;&gt;&gt; b = np.array([1, 2, 3, 4, 5], np.float_)
&gt;&gt;&gt; b
array([1., 2., 3., 4., 5.])
&gt;&gt;&gt; b.dtype
dtype('float64')

&gt;&gt;&gt; c = np.array([1, 2, 3, 4, 5], 'u1')
&gt;&gt;&gt; c
array([1, 2, 3, 4, 5], dtype=uint8)

&gt;&gt;&gt; d = np.array([1, 2, 3, 4], dtype = np.complex_)
&gt;&gt;&gt; d
array([1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j])
</pre>
<ul>
  <li>ndarray の属性 dtype は要素のデータ型を表すオブジェクト (Data Type Object) が格納されている</li>
  <li>ndarray の主な属性</li>
  <ul>
    <li>flags, メモリレイアウト情報</li>
    <li>ndim, 次元数</li>
    <li>size, 要素数</li>
    <li>shape, 各次元の要素数</li>
    <li>itemsize, 要素のバイト数</li>
    <li>strides, 各次元で次の要素に移るためのバイト数</li>
    <li>nbytes, 配列全体のバイト数</li>
    <li>dtype, Data Type Object</li>
  </ul>
</ul>
<pre>
&gt;&gt;&gt; a.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
&gt;&gt;&gt; a.ndim
2
&gt;&gt;&gt; a.size
9
&gt;&gt;&gt; a.shape
(3, 3)
&gt;&gt;&gt; a.itemsize
4
&gt;&gt;&gt; a.strides
(12, 4)
&gt;&gt;&gt; a.nbytes
36
</pre>
<ul>
  <li>array() 以外の主なコンストラクタ</li>
  <ul>
    <li>zeros(n or (n, m, ...)), 値が 0 の配列を作る</li>
    <li>ones(n or (n, m, ...)), 値が 1 の配列を作る</li>
    <li>full(n or (n, m, ...), value), 値が value の配列を作る</li>
    <li>A.fill(value), 配列 A の要素を value で埋める</li>
    <li>empty(n or (n, m, ...)), 未初期化の配列を作る</li>
    <li>arange(start, end, step), start から step 刻みで end 未満の配列を作る (range() の ndarray 版)</li>
    <li>linspace(start, end, n), start から end を等間隔で n - 1 分割した要素を配列に格納する</li>
    <li>tile(xs, n), xs を n 回繰り返した配列を生成する</li>
    <li>identity(n), eye(n [, m]), 単位行列の生成</li>
    <li>tri(n), 三角行列の生成</li>
    <li>diag(ary), 配列 ary の対角要素を抜き出した配列を返す</li>
    <li>diag(vec), ベクトル vec の要素を対角線上に配置した行列 (対角行列) を返す</li>
    <li>fromfunction(func, shape), 関数 func に配列の添字を渡し、func の返り値を格納した配列を生成する</li>
  </ul>
</ul>
<pre>
&gt;&gt;&gt; np.zeros(4)
array([0., 0., 0., 0.])
&gt;&gt;&gt; np.zeros((3, 3), 'i')
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]], dtype=int32)
&gt;&gt;&gt; np.ones((2, 2, 2), 'i')
array([[[1, 1],
        [1, 1]],

       [[1, 1],
        [1, 1]]], dtype=int32)
&gt;&gt;&gt; np.empty(5)
array([0., 0., 0., 0., 0.])
&gt;&gt;&gt; np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.arange(0, 10, 2)
array([0, 2, 4, 6, 8])
&gt;&gt;&gt; np.linspace(1, 10, 10)
array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
&gt;&gt;&gt; np.linspace(0, 1, 9)
array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ])
&gt;&gt;&gt; np.linspace(0, 1, 11)
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])
&gt;&gt;&gt; np.tile([1, 2, 3], 4)
array([1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])
&gt;&gt;&gt; np.identity(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
&gt;&gt;&gt; np.eye(3, 4)
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.]])
&gt;&gt;&gt; np.tri(4)
array([[1., 0., 0., 0.],
       [1., 1., 0., 0.],
       [1., 1., 1., 0.],
       [1., 1., 1., 1.]])
&gt;&gt;&gt; np.diag(np.tri(4))
array([1., 1., 1., 1.])
&gt;&gt;&gt; np.diag([1, 1, 1])
array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1]])
&gt;&gt;&gt; np.fromfunction(lambda x: x, (10,), dtype='int_')
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.fromfunction(lambda x, y: x + y, (4, 4), dtype='int_')
array([[0, 1, 2, 3],
       [1, 2, 3, 4],
       [2, 3, 4, 5],
       [3, 4, 5, 6]])
</pre>
<h4 id="chap03">●配列のアクセス</h4>
<ul>
  <li>配列の要素のアクセスは Python と同じ</li>
  <li>スライス操作もできる</li>
  <ul>
    <li>このとき、配列はコピーされるのではなく「ビュー (View)」が生成される</li>
    <li>View は元の配列本体を参照している</li>
    <li>View の値を変更すると元の配列も変更される</li>
    <li>配列をコピーしたい場合はメソッド copy() を使う</li>
  </ul>
  <li>Python の場合、リスト xs のスライス xs[s:e] に代入できるのはリストだけ</li>
  <li>NumPy の場合、配列 xs のスライス xs[s:e] に値を代入することもできる</li>
  <ul>
    <li>指定した要素の値が更新される</li>
    <li>xs[s:e:step] = value のように、step を指定することもできる</li>
  </ul>
  <li>多次元配列の場合、[x, y, z, ...] のように添字をカンマで区切って指定することも可能</li>
</ul>
<pre>
&gt;&gt;&gt; xs = np.arange(10)
&gt;&gt;&gt; xs
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; xs[0]
0
&gt;&gt;&gt; xs[9]
9
&gt;&gt;&gt; xs[2:8]
array([2, 3, 4, 5, 6, 7])
&gt;&gt;&gt; xs[::2] = 0
&gt;&gt;&gt; xs
array([0, 1, 0, 3, 0, 5, 0, 7, 0, 9])

&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; a[0]
array([1, 2, 3])
&gt;&gt;&gt; a[0, 0]
1
&gt;&gt;&gt; a[2]
array([7, 8, 9])
&gt;&gt;&gt; a[2, 2]
9

&gt;&gt;&gt; a[:2, :2]
array([[1, 2],
       [4, 5]])
&gt;&gt;&gt; a[1:, 1:]
array([[5, 6],
       [8, 9]])
&gt;&gt;&gt; a[1:, :]
array([[4, 5, 6],
       [7, 8, 9]])

&gt;&gt;&gt; a[1, 1] = 100
&gt;&gt;&gt; a
array([[  1,   2,   3],
       [  4, 100,   6],
       [  7,   8,   9]])
&gt;&gt;&gt; a[:2, :2] = 0
&gt;&gt;&gt; a
array([[0, 0, 3],
       [0, 0, 6],
       [7, 8, 9]])
&gt;&gt;&gt; a[:2, :2] = np.array([[10, 20], [40, 50]])
&gt;&gt;&gt; a
array([[10, 20,  3],
       [40, 50,  6],
       [ 7,  8,  9]])
</pre>
<h4 id="chap04">●基本的な演算処理</h4>
<ul>
  <li>配列 A とスカラー n の計算 A op n (n op A) は、配列の各要素 a ごとに a op n (n op a) を計算する</li>
  <li>配列 A, B の計算 A op B は配列の各要素 a, b ごとに a op b を計算する</li>
  <li>計算結果は新しい配列に格納して返す</li>
  <li>演算子 op は Python と同じものが使える (ビット演算子と比較演算子も使える)</li>
  <li>行列 A, B の積 (内積) は演算子 @, 関数 numpy.dot(A, B), メソッド A.dot(B) を使う</li>
  <li>ベクトル (一次元配列) の内積も演算子 @ や dot() でできる</li>
  <li>専用の関数 vdot() も用意されている</li>
  <li>行列 A の行列は A の属性 T または関数 numpy.transpose(A) で求めることができる</li>
  <li>行列 A とベクトル V の積は A @ V で計算できる</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; a + 10
array([[11, 12, 13],
       [14, 15, 16]])
&gt;&gt;&gt; a * 10
array([[10, 20, 30],
       [40, 50, 60]])
&gt;&gt;&gt; a - 10
array([[-9, -8, -7],
       [-6, -5, -4]])
&gt;&gt;&gt; a / 10
array([[0.1, 0.2, 0.3],
       [0.4, 0.5, 0.6]])

&gt;&gt;&gt; b = np.array([[3, 2, 1], [6, 5, 4]])
&gt;&gt;&gt; b
array([[3, 2, 1],
       [6, 5, 4]])
&gt;&gt;&gt; a + b
array([[ 4,  4,  4],
       [10, 10, 10]])
&gt;&gt;&gt; a - b
array([[-2,  0,  2],
       [-2,  0,  2]])
&gt;&gt;&gt; a * b
array([[ 3,  4,  3],
       [24, 25, 24]])
&gt;&gt;&gt; a / b
array([[0.33333333, 1.        , 3.        ],
       [0.66666667, 1.        , 1.5       ]])

&gt;&gt;&gt; b.T
array([[3, 6],
       [2, 5],
       [1, 4]])
&gt;&gt;&gt; c = a @ b.T
&gt;&gt;&gt; c
array([[10, 28],
       [28, 73]])
&gt;&gt;&gt; i = np.identity(2, 'int')
&gt;&gt;&gt; i
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; c @ i
array([[10, 28],
       [28, 73]])
&gt;&gt;&gt; i @ c
array([[10, 28],
       [28, 73]])

&gt;&gt;&gt; x = np.array([1, 2, 3])
&gt;&gt;&gt; y = np.array([4, 5, 6])
&gt;&gt;&gt; x @ y
32
&gt;&gt;&gt; x.dot(y)
32
&gt;&gt;&gt; np.vdot(x, y)
32
&gt;&gt;&gt; z = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; z
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; z @ x
array([14, 32, 50])
</pre>
<ul>
  <li>行列 A の n 乗 (A<sup>n</sup>) は演算子 ** で求めることができない</li>
  <ul>
    <li>線形代数関連のモジュール numpy.linalg の関数 matrix_power(M, n) を使う</li>
  </ul>
  <li>NumPy には行列専用のクラス matrix が用意されている</li>
  <li>コンストラクタは matrix()</li>
  <li>matrix の場合、行列の積は演算子 * を使う</li>
  <li>演算子 ** を使って行列の累乗を計算することもできる</li>
  <li>ndarray と matrix は相互に変換可能</li>
  <ul>
    <li>配列 A, 行列 M とすると array(M) =&gt; A, matrix(A) =&gt; M</li>
    <li>行列 M の属性 A で配列を求めることもできる</li>
  </ul>
</ul>
<pre>
&gt;&gt;&gt; f = np.matrix([[1, 1], [1, 0]], 'int64')
&gt;&gt;&gt; f
matrix([[1, 1],
        [1, 0]], dtype=int64)
&gt;&gt;&gt; np.array(f)
array([[1, 1],
       [1, 0]], dtype=int64)
&gt;&gt;&gt; f.A
array([[1, 1],
       [1, 0]], dtype=int64)
&gt;&gt;&gt; np.matrix(f.A)
matrix([[1, 1],
        [1, 0]], dtype=int64)
&gt;&gt;&gt; f ** 10
matrix([[89, 55],
        [55, 34]], dtype=int64)
&gt;&gt;&gt; f ** 20
matrix([[10946,  6765],
        [ 6765,  4181]], dtype=int64)
&gt;&gt;&gt; f ** 40
matrix([[165580141, 102334155],
        [102334155,  63245986]], dtype=int64)
&gt;&gt;&gt; def fibo(n):
...     if n == 0 or n == 1: return n
...     else:
...         f = np.matrix([[1, 1], [1, 0]], 'int64')
...         return (f ** (n - 1))[0, 0]
...
&gt;&gt;&gt; for x in range(20): print(fibo(x))
...
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
&gt;&gt;&gt; fibo(40)
102334155
&gt;&gt;&gt; fibo(50)
12586269025
&gt;&gt;&gt; fibo(60)
1548008755920
</pre>
<ul>
  <li>簡単な例題として、数値積分で円周率を求めるプログラムを示す</li>
</ul>
<pre class="list">
リスト : 数値積分 (中点則で円周率を求める)

import numpy as np

n = 100
for _ in range(5):
    w = 1 / n
    a = (np.arange(1, n + 1) - 0.5) * w
    b = 4.0 / (1.0 + a * a)
    print(n, np.sum(b) * w)
    n *= 10
</pre>
<pre>
C&gt;python test.py
100 3.1416009869231245
1000 3.1415927369231267
10000 3.1415926544231265
100000 3.1415926535981273
1000000 3.1415926535898775
</pre>
<ul>
  <li>sum() は配列の要素の合計値を求める関数 (Python の sum() を使ってもよい)</li>
</ul>
<h4 id="chap05">●データ型と形状 (shape) の変更</h4>
<ul>
  <li>データ型は astype() で、形状は reshape(), resize(), flatten() などで変更できる</li>
<pre class="item">
A.astype(type), 配列 A の要素のデータ型を type に変更した新しい配列を返す
A.reshape(shape), 配列 A の形状を shape に変更した View を返す (値はコピーされない)
A.resize(shape), 配列 A の形状を shape に変更する (破壊的な修正)
A.flatten(), A.flat, 配列 A の平坦化
</pre>
  <li>要素の数が合わないとエラー</li>
  <li>flatten() は新しい配列を作り、元の配列の要素をコピーする</li>
  <li>A.flat はイテレータを返す</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.arange(1, 10)
&gt;&gt;&gt; a
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; b[0, 0] += 10
&gt;&gt;&gt; a
array([11,  2,  3,  4,  5,  6,  7,  8,  9])
&gt;&gt;&gt; b
array([[11,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9]])
&gt;&gt;&gt; a[8] += 20
&gt;&gt;&gt; a
array([11,  2,  3,  4,  5,  6,  7,  8, 29])
&gt;&gt;&gt; b
array([[11,  2,  3],
       [ 4,  5,  6],
       [ 7,  8, 29]])

&gt;&gt;&gt; c = np.arange(1, 10)
&gt;&gt;&gt; c
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; c.resize((3, 3))
&gt;&gt;&gt; c
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; d = c.flatten()
&gt;&gt;&gt; d
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; c
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; d[0] = 10
&gt;&gt;&gt; d
array([10,  2,  3,  4,  5,  6,  7,  8,  9])
&gt;&gt;&gt; c
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; d
array([10,  2,  3,  4,  5,  6,  7,  8,  9])
&gt;&gt;&gt; e = d.astype(np.float_)
&gt;&gt;&gt; e
array([10.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])
</pre>
<ul>
  <li>形状の変更は属性 shape を書き換えることでもできる (resize() と同じ)</li>
  <li>shape の要素に -1 を指定すると、その次元の要素数を自動的に計算する</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.arange(1, 10)
&gt;&gt;&gt; a
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; a.shape = 3, 3
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; a.shape = 9
&gt;&gt;&gt; a
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; a.shape = 3,-1
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; b = np.arange(1, 9)
&gt;&gt;&gt; b
array([1, 2, 3, 4, 5, 6, 7, 8])
&gt;&gt;&gt; b.shape = 2, 4
&gt;&gt;&gt; b
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
&gt;&gt;&gt; b.shape = 2, 2, -1
&gt;&gt;&gt; b
array([[[1, 2],
        [3, 4]],

       [[5, 6],
        [7, 8]]])
</pre>
<ul>
  <li>次元数を増やすには numpy.newaxis を使う</li>
  <li>たとえば、ベクトル array([1, 2, 3]) のスライス操作で newaxis を使う</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; a
array([1, 2, 3])
&gt;&gt;&gt; a.shape
(3,)
&gt;&gt;&gt; b = a[np.newaxis, :]
&gt;&gt;&gt; b
array([[1, 2, 3]])
&gt;&gt;&gt; b.shape
(1, 3)
&gt;&gt;&gt; c = a[:, np.newaxis]
&gt;&gt;&gt; c
array([[1],
       [2],
       [3]])
&gt;&gt;&gt; c.shape
(3, 1)

&gt;&gt;&gt; d = np.arange(8).reshape(2,2,2)
&gt;&gt;&gt; d
array([[[0, 1],
        [2, 3]],

       [[4, 5],
        [6, 7]]])
&gt;&gt;&gt; d[..., 0]
array([[0, 2],
       [4, 6]])
&gt;&gt;&gt; d[1, ...]
array([[4, 5],
       [6, 7]])
</pre>
<ul>
  <li>a[np.newaxis, :] とするとベクトルを 1 行 3 列の行列に変換する</li>
  <li>a[:, np.newaxis] とするとベクトルを 3 行 1 列の行列に変換する</li>
  <li>多次元配列の場合、[:, :, 0] のように : を連続で指定することがある</li>
  <li>この場合、連続する : を ... でまとめることができる (Ellipsisオブジェクト)</li>
  <li>つまり、[..., 0] のように記述することができる</li>
</ul>
<h4 id="chap06">●配列のアクセス (2)</h4>
<ul>
  <li>複数の添字をリストや配列に格納し、それを添字として使用することができる</li>
  <li>この場合、指定した添字の要素を格納した一次元配列を生成して返す</li>
  <li>N 次元配列の場合、各次元の位置を格納した配列を N 個格納した配列 (またはタプル) になる</li>
  <li>これを「インデックス配列」という</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.array([9, 8, 7, 6, 5, 4, 3, 2, 1])
&gt;&gt;&gt; a
array([9, 8, 7, 6, 5, 4, 3, 2, 1])
&gt;&gt;&gt; a[[5, 1, 3]]
array([4, 8, 6])

&gt;&gt;&gt; b = a.reshape(3, 3)
&gt;&gt;&gt; b
array([[9, 8, 7],
       [6, 5, 4],
       [3, 2, 1]])
&gt;&gt;&gt; b[([0, 1, 2], [2, 1, 0])]
array([7, 5, 3])
&gt;&gt;&gt; b[[0, 1, 2], [2, 1, 0]]
array([7, 5, 3])
</pre>
<ul>
  <li>インデックス配列を添字に指定するとき、各次元の配列をカンマで区切るだけでもよい </li>
  <li>配列 A に比較演算子を適用すると、結果 (真偽値) を格納した配列を返す</li>
  <li>真偽値の配列を添字に渡すと、True の要素だけを格納した一次元配列を返す</li>
  <li>角カッコの中に条件式を直接記述することもできる</li>
  <li>該当する要素の値を書き換えることも可能</li>
</ul>
<pre>
&gt;&gt;&gt; x = a % 2 == 0
&gt;&gt;&gt; x
array([False,  True, False,  True, False,  True, False,  True, False])
&gt;&gt;&gt; a[x]
array([8, 6, 4, 2])

&gt;&gt;&gt; y = b > 4
&gt;&gt;&gt; y
array([[ True,  True,  True],
       [ True,  True, False],
       [False, False, False]])
&gt;&gt;&gt; b[y]
array([9, 8, 7, 6, 5])
&gt;&gt;&gt; b[b % 2 != 0]
array([9, 7, 5, 3, 1])

&gt;&gt;&gt; c = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; c
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; c[c % 2 == 0] = 0
&gt;&gt;&gt; c
array([[0, 1, 0],
       [3, 0, 5],
       [0, 7, 0]])
</pre>
<ul>
  <li>簡単な例題として、素数を求めるプログラムを示す</li>
</ul>
<pre class="list">
リスト : 素数 (prime.py)

import numpy as np
import time

# Python のリストを使用する
def prime(n):
    ps = [2]
    xs = list(range(3, n + 1, 2))
    while True:
        p = xs[0]
        if p * p &gt; n:
            return ps + xs
        ps.append(p)
        xs = list(filter(lambda x: x % p != 0, xs))

# NumPy バージョン
def prime_np(n):
    ps = [2]
    xs = np.arange(3, n + 1, 2)
    while True:
        p = xs[0]
        if p * p &gt; n:
            return ps + list(xs)
        ps.append(p)
        xs = xs[xs % p != 0]

s = time.time()
print(len(prime(1000000)))
print(time.time() - s)
s = time.time()
print(len(prime_np(1000000)))
print(time.time() - s)
</pre>
<pre>
C&gt;python prime.py
78498
2.76664662361145
78498
0.1401984691619873

実行環境 : Windows 10, Intel Core i5-6200U 2.30GHz
</pre>
<h4 id="chap07">●ユニバーサル関数</h4>
<ul>
  <li>ユニバーサル関数は、配列の要素に演算処理を行い、その結果を配列に格納して返す関数のこと</li>
  <li>NumPy ではユニバーサル関数を ufunc と呼ぶ</li>
  <li>関数型言語のマッピングと同じ動作だが、汎用的ではなく処理ごとに専用の関数が多数用意されている</li>
  <li>演算子に対応する関数、たとえば　+, -, *, / に対応する add, subtract, multiply, divide もある</li>
  <li>ユニバーサル関数の一覧はリファレンスマニュアル <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html#available-ufuncs">Available ufuncs</a> を参照</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.square(a)
array([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81], dtype=int32)
&gt;&gt;&gt; np.sqrt(a)
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

&gt;&gt;&gt; b = np.linspace(0, np.pi/2, 7)
&gt;&gt;&gt; b
array([0.        , 0.26179939, 0.52359878, 0.78539816, 1.04719755,
       1.30899694, 1.57079633])
&gt;&gt;&gt; np.sin(b)
array([0.        , 0.25881905, 0.5       , 0.70710678, 0.8660254 ,
       0.96592583, 1.        ])
</pre>
<ul>
  <li>frompyfunc() は Python の関数を ufunc に変換する</li>
<pre class="item">
frompyfunc(関数, 引数の個数, 返り値の個数) =&gt; ufunc
</pre>
  <li>Python は遅いので、データ数が多くなると時間がかかる場合もある</li>
</ul>
<pre class="list">
リスト : frompyfunc() の簡単な使用例 (test.py)

import time, math
import numpy as np

def mysqrt(n): return math.sqrt(n)

ufunc_mysqrt = np.frompyfunc(mysqrt, 1, 1)

s = time.time()
np.sqrt(np.arange(10000000))
print(time.time() - s)
s = time.time()
ufunc_mysqrt(np.arange(10000000))
print(time.time() - s)
</pre>
<pre>
C&gt;python test.py
0.06250596046447754
2.765178680419922

実行環境 : Windows 10, Intel Core i5-6200U 2.30GHz
</pre>
<ul>
  <li>ユニバーサル関数には便利なメソッドがいくつか用意されている</li>
  <li>ここでは、reduce() と accumulate() を紹介する</li>
<pre class="item">
ufunc.reduce(A, axis=0)
ufunc.accumulate(A, axis=0)
</pre>
  <li>reduce() は畳み込みを行い、accumulate() は畳み込みの途中経過を配列に格納して返す</li>
  <li>ufunc と reduce() を組み合わせることで、いわゆる MapReduce のような処理ができる</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.arange(1, 10)
&gt;&gt;&gt; a
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.add.reduce(a)
45
&gt;&gt;&gt; np.add.accumulate(a)
array([ 1,  3,  6, 10, 15, 21, 28, 36, 45], dtype=int32)
&gt;&gt;&gt; np.multiply.reduce(a)
362880
&gt;&gt;&gt; np.multiply.accumulate(a)
array([     1,      2,      6,     24,    120,    720,   5040,  40320,
       362880], dtype=int32)
</pre>
<ul>
  <li>総和であれば関数 sum() を使ったほうが簡単</li>
  <li>キーワード引数 axis は「軸 (axis)」を指定する</li>
  <li>軸は配列を走査する方向みたいなもの</li>
  <li>axis に None を指定すると、配列を平坦化して処理を行う</li>
  <li>二次元配列の場合、axis = 0 は A[0,:] op A[1,:] op ... op A[N,:] を計算する</li>
  <li>axis = 1 は A[:,0] op A[:,1] op ... op A[:,N] を計算する</li>
</ul>
<pre>
&gt;&gt;&gt; b = np.arange(1, 26).reshape((5, 5))
&gt;&gt;&gt; b
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20],
       [21, 22, 23, 24, 25]])
&gt;&gt;&gt; np.add.reduce(b, axis=0)
array([55, 60, 65, 70, 75])
&gt;&gt;&gt; np.add.reduce(b, axis=1)
array([ 15,  40,  65,  90, 115])
</pre>
<ul>
  <li>三次元配列の場合、axis は 2 まで指定できる</li>
  <li>axis = 0 は A[n-1,...] op A[n,...] の計算</li>
  <li>axis = 1 は A[:,n-1,:] op A[:,n,:] の計算</li>
  <li>axis = 2 は A[...,n-1] op A[...,n] の計算</li>
  <li>つまり、平面 (行列) を指定した方向に動かしながら演算する、と考えればよい</li>
</ul>
<pre>
&gt;&gt;&gt; c = np.arange(1, 28).reshape((3, 3, 3))
&gt;&gt;&gt; c
array([[[ 1,  2,  3],
        [ 4,  5,  6],
        [ 7,  8,  9]],

       [[10, 11, 12],
        [13, 14, 15],
        [16, 17, 18]],

       [[19, 20, 21],
        [22, 23, 24],
        [25, 26, 27]]])
&gt;&gt;&gt; np.add.reduce(c, axis=0)
array([[30, 33, 36],
       [39, 42, 45],
       [48, 51, 54]])
&gt;&gt;&gt; c[0,...] + c[1,...] + c[2,...]
array([[30, 33, 36],
       [39, 42, 45],
       [48, 51, 54]])
&gt;&gt;&gt; np.add.reduce(c, axis=2)
array([[ 6, 15, 24],
       [33, 42, 51],
       [60, 69, 78]])
&gt;&gt;&gt; c[...,0] + c[...,1] + c[...,2]
array([[ 6, 15, 24],
       [33, 42, 51],
       [60, 69, 78]])
</pre>
<h4 id="chap08">●検索</h4>
<ul>
  <li>配列からデータを探索する基本的な関数を紹介する</li>
  <ul>
    <li>argmin(), 最小値のインデックスを返す</li>
    <li>argmax(), 最大値のインデックスを返す</li>
    <li>nonzero(), 非零の要素のインデックス配列を返す</li>
    <li>where(条件式), 条件を満たす要素のインデックス配列を返す</li>
    <li>where(条件式, then式, else式), 条件式が真の場合は then 式の値を、偽の場合は else 式の値をセットした新し配列を返す</li>
    <li>all(), すべての要素が真のとき True を返す</li>
    <li>any(), すべての要素が偽のとき False を返す</li>
    <li>真偽の判定は Python と同じ (0 や 0.0 も偽と判定される)</li>
  </ul>
</ul>
<pre>
&gt;&gt;&gt; a = np.array([0, 1, 2, 4, 3, 4, 2, 1, 0])
&gt;&gt;&gt; a
array([0, 1, 2, 4, 3, 4, 2, 1, 0])
&gt;&gt;&gt; a.argmin()
0
&gt;&gt;&gt; a.argmax()
3
&gt;&gt;&gt; b = a.reshape((3,3))
&gt;&gt;&gt; b
array([[0, 1, 2],
       [4, 3, 4],
       [2, 1, 0]])
&gt;&gt;&gt; b.argmin(axis=0)
array([0, 0, 2], dtype=int64)
&gt;&gt;&gt; b.argmin(axis=1)
array([0, 1, 2], dtype=int64)
&gt;&gt;&gt; b.argmax(axis=0)
array([1, 1, 1], dtype=int64)
&gt;&gt;&gt; b.argmax(axis=1)
array([2, 0, 0], dtype=int64)

&gt;&gt;&gt; a.nonzero()
(array([1, 2, 3, 4, 5, 6, 7], dtype=int64),)
&gt;&gt;&gt; b.nonzero()
(array([0, 0, 1, 1, 1, 2, 2], dtype=int64), array([1, 2, 0, 1, 2, 0, 1], dtype=int64))
&gt;&gt;&gt; np.where(a % 2 == 0)
(array([0, 2, 3, 5, 6, 8], dtype=int64),)
&gt;&gt;&gt; np.where(b % 2 == 1)
(array([0, 1, 2], dtype=int64), array([1, 1, 1], dtype=int64))
&gt;&gt;&gt; c = np.where(b % 2 == 1,b,b+ 1)
&gt;&gt;&gt; c
array([[1, 1, 3],
       [5, 3, 5],
       [3, 1, 1]])

&gt;&gt;&gt; np.all(a)
False
&gt;&gt;&gt; np.any(a)
True
&gt;&gt;&gt; np.any(np.array([0, 0, 0, 0, 0]))
False
&gt;&gt;&gt; np.all(b)
False
&gt;&gt;&gt; np.all(b, axis=0)
array([False,  True, False])
&gt;&gt;&gt; np.all(c)
True
&gt;&gt;&gt; np.all(c, axis=0)
array([ True,  True,  True])
</pre>
<ul>
  <li>簡単な例題として、エラトステネスの篩とナンバープレースの解法プログラムを示す
  </li>
</ul>
<pre class="list">
リスト : エラトステネスの篩 (sieve.py)

import numpy as np
import time

# Python のリストを使用
def sieve(n):
    ps = [True] * (n + 1)
    ps[0] = False
    ps[1] = False
    for i in range(2 + 2, n + 1, 2): ps[i] = False
    x = 3
    while x * x &lt;= n:
        if ps[x]:
            for i in range(x + x, n + 1, x): ps[i] = False
        x += 2
    for i in range(2, n + 1):
        if ps[i]: yield i

# NumPy バージョン
def sieve_np(n):
    ps = np.ones(n + 1, 'u1')
    ps[0] = 0
    ps[1] = 0
    ps[2+2::2] = 0
    x = 3
    while x * x &lt;= n:
        if ps[x]: ps[x + x::x] = 0
        x += 2
    return np.where(ps == 1)[0]

s = time.time()
print(len(list(sieve(10000000))))
print(time.time() - s)
print(sieve_np(100))
s = time.time()
print(len(sieve_np(10000000)))
print(time.time() - s)
</pre>
<pre>
C&gt;python sieve.py
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
664579
2.124438762664795
[ 2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]
664579
0.15421748161315918

実行環境 : Windows 10, Intel Core i5-6200U 2.30GHz
</pre>
<pre class="list">
リスト : ナンバープレースの解法 (numplace.py)

import numpy as np

# 問題 (出典: 数独 - Wikipedia の問題例)
sudoku_board = np.array([
    [5, 3, 0,  0, 7, 0,  0, 0, 0],
    [6, 0, 0,  1, 9, 5,  0, 0, 0],
    [0, 9, 8,  0, 0, 0,  0, 6, 0],

    [8, 0, 0,  0, 6, 0,  0, 0, 3],
    [4, 0, 0,  8, 0, 3,  0, 0, 1],
    [7, 0, 0,  0, 2, 0,  0, 0, 6],

    [0, 6, 0,  0, 0, 0,  2, 8, 0],
    [0, 0, 0,  4, 1, 9,  0, 0, 5],
    [0, 0, 0,  0, 8, 0,  0, 7, 9]
])

# 条件のチェック
def check_number(x, y, n, board):
    if np.any(board[x, :] == n) or np.any(board[:, y] == n):
        return False
    x1 = (x // 3) * 3
    y1 = (y // 3) * 3
    if np.any(board[x1:x1+3, y1:y1+3] == n):
        return False
    return True

# 深さ優先探索による解法
def numplace(x, y, board):
    if y >= 9:
        print(board)
    elif x >= 9:
        numplace(0, y + 1, board)
    elif board[x, y]:
        numplace(x + 1, y, board)
    else:
        for n in range(1, 10):
            if not check_number(x, y, n, board): continue
            board[x, y] = n
            numplace(x + 1, y, board)
            board[x, y] = 0

print(sudoku_board)
print('----------')
numplace(0, 0, sudoku_board)
</pre>
<pre>
C&gt;python numplace.py
[[5 3 0 0 7 0 0 0 0]
 [6 0 0 1 9 5 0 0 0]
 [0 9 8 0 0 0 0 6 0]
 [8 0 0 0 6 0 0 0 3]
 [4 0 0 8 0 3 0 0 1]
 [7 0 0 0 2 0 0 0 6]
 [0 6 0 0 0 0 2 8 0]
 [0 0 0 4 1 9 0 0 5]
 [0 0 0 0 8 0 0 7 9]]
----------
[[5 3 4 6 7 8 9 1 2]
 [6 7 2 1 9 5 3 4 8]
 [1 9 8 3 4 2 5 6 7]
 [8 5 9 7 6 1 4 2 3]
 [4 2 6 8 5 3 7 9 1]
 [7 1 3 9 2 4 8 5 6]
 [9 6 1 5 3 7 2 8 4]
 [2 8 7 4 1 9 6 3 5]
 [3 4 5 2 8 6 1 7 9]]
</pre>
<h4 id="chap09">●基本的な統計処理</h4>
<ul>
  <li>NumPy には統計処理用の関数 (メソッド) が用意されている</li>
  <li>統計学の基本については拙作のページ <a href="index.html#python_algo_x">統計学の基礎知識</a> を参照</li>
  <li>以下に主な関数を示す</li>
  <ul>
    <li>sum(), 合計値</li>
    <li>min(), 最小値</li>
    <li>max(), 最大値</li>
    <li>mean(), 平均値</li>
    <li>median(), 中央値</li>
    <li>std(), 標準偏差</li>
    <li>var(), 分散</li>
    <li>histogram(), ヒストグラムを求める</li>
    <ul>
      <li>matplotlib の関数 pyplot.hist() でも求めることができる</li>
    </ul>
    <li>cumsum(), 累積和 (累積度数) を求める</li>
    <li>cumprod(), 累積積を求める</li>
    <li>corrcoef(), 相関係数を求める</li>
    <li>polyfit(xs, ys, n), n 次式で 2 変数の回帰分析</li>
  </ul>
  <li>この他にも便利な関数が用意されている</li>
  <li>詳細はリファレンスマニュアル <a href="https://docs.scipy.org/doc/numpy/reference/routines.statistics.html">Statistics</a> を参照</li>
</ul>
<pre>
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; a.sum()
45
&gt;&gt;&gt; np.sum(a)
45
&gt;&gt;&gt; np.sum(a, axis=0)
array([12, 15, 18])
&gt;&gt;&gt; np.sum(a, axis=1)
array([ 6, 15, 24])
&gt;&gt;&gt; np.min(a, axis=1)
array([1, 4, 7])
&gt;&gt;&gt; np.max(a, axis=1)
array([3, 6, 9])
</pre>
<ul>
  <li>以下に統計処理の簡単な例題を示す</li>
</ul>
<pre class="list">
リスト : 統計処理の簡単な例

import numpy as np
import matplotlib.pyplot as plt

# 身長のデータ
height = [
    148.7, 149.5, 133.7, 157.9, 154.2, 147.8, 154.6, 159.1, 148.2, 153.1,
    138.2, 138.7, 143.5, 153.2, 150.2, 157.3, 145.1, 157.2, 152.3, 148.3,
    152.0, 146.0, 151.5, 139.4, 158.8, 147.6, 144.0, 145.8, 155.4, 155.5,
    153.6, 138.5, 147.1, 149.6, 160.9, 148.9, 157.5, 155.1, 138.9, 153.0,
    153.9, 150.9, 144.4, 160.3, 153.4, 163.0, 150.9, 153.3, 146.6, 153.3,
    152.3, 153.3, 142.8, 149.0, 149.4, 156.5, 141.7, 146.2, 151.0, 156.5,
    150.8, 141.0, 149.0, 163.2, 144.1, 147.1, 167.9, 155.3, 142.9, 148.7,
    164.8, 154.1, 150.4, 154.2, 161.4, 155.0, 146.8, 154.2, 152.7, 149.7,
    151.5, 154.5, 156.8, 150.3, 143.2, 149.5, 145.6, 140.4, 136.5, 146.9,
    158.9, 144.4, 148.1, 155.5, 152.4, 153.3, 142.3, 155.3, 153.1, 152.3
]

h = np.array(height)
print('sum = {}, max = {}, min = {}'.format(h.sum(), h.max(), h.min()))
print('mean = {}, var = {}, std = {}'.format(h.mean(), h.var(), h.std()))
print(np.histogram(h, bins=np.arange(130, 171, 5)))
print(plt.hist(h, bins=np.arange(130, 171, 5)))
# plt.savefig("hist.png", dpi=50)
plt.show()
</pre>
<pre>
sum = 15062.699999999999, max = 167.9, min = 133.7
mean = 150.62699999999998, var = 41.389571000000025, std = 6.433472701426503
(array([ 1,  6, 12, 25, 32, 17,  6,  1], dtype=int64), 
 array([130, 135, 140, 145, 150, 155, 160, 165, 170]))
(array([ 1.,  6., 12., 25., 32., 17.,  6.,  1.]), 
 array([130, 135, 140, 145, 150, 155, 160, 165, 170]), 
 &lt;a list of 8 Patch objects&gt;)
</pre>
<p><img src="img/hist.png">
</p>
<pre class="list">
リスト : 東京の年平均気温 (1975 - 2014)

import numpy as np
import matplotlib.pyplot as plt

data = np.array([
    15.6, 15.0, 15.8, 16.1, 16.9, 15.4, 15.0, 16.0, 15.7, 14.9,
    15.7, 15.2, 16.3, 15.4, 16.4, 17.0, 16.4, 16.0, 15.5, 16.9,
    16.3, 15.8, 16.7, 16.7, 17.0, 16.9, 16.5, 16.7, 16.0, 17.3,
    16.2, 16.4, 17.0, 16.4, 16.7, 16.9, 16.5, 16.3, 17.1, 16.6
])

x = np.arange(1975, 2015)

# 散布図
plt.plot(x, data, 'o')

# 相関係数
print(np.corrcoef(x, data))

# 回帰直線
a, b = np.polyfit(x, data, 1)
print(a, b)
plt.plot(x, x * a + b)

# plt.savefig('tokyo.png', dpi=50)
plt.show()
</pre>
<pre>
[[1.         0.62750348]
 [0.62750348 1.        ]]
0.03442776735459678 -52.43618198874326
</pre>
<p><img src="img/tokyo.png">
</p>
<h4 id="chap10">●乱数</h4>
<ul>
  <li>NumPy のモジュール random には乱数を生成する関数が多数用意されている</li>
  <li>rand(), [0.0, 1.0) の一様乱数を生成する</li>
  <li>randn(), 標準正規分布に従う乱数を生成する</li>
  <li>引数に d0, d1, ..., dn を指定すると、乱数を格納した配列を返す</li>
  <li>randint(low[, high, size, dtype]), [low, high) の一様乱数 (整数) を生成する</li>
  <li>size は整数値またはタプル (shape)</li>
  <li>このほかにも、いろいろな分布の乱数を生成する関数が多数用意されている</li>
  <li>詳細はリファレンスマニュアル <a href="https://docs.scipy.org/doc/numpy/reference/routines.random.html">Random sampling</a> を参照</li>
</ul>
<pre>
&gt;&gt;&gt; np.random.rand()
0.047653528033401504
&gt;&gt;&gt; np.random.rand(10)
array([0.7378687 , 0.24128895, 0.70803174, 0.70097538, 0.39710067,
       0.18238028, 0.7943424 , 0.12147911, 0.51665823, 0.68891523])
&gt;&gt;&gt; np.random.randn()
-0.3073797959407569
&gt;&gt;&gt; np.random.randn(10)
array([ 0.79187796,  0.00350009, -0.01247469, -0.59927661, -0.35585297,
        0.81813222, -0.09386419, -1.58999999, -1.43327989, -2.98426565])
&gt;&gt;&gt; np.random.randint(0, 10)
7
&gt;&gt;&gt; np.random.randint(0, 10, 20)
array([8, 9, 2, 5, 7, 9, 9, 9, 0, 1, 4, 4, 7, 2, 0, 4, 3, 9, 2, 9])
&gt;&gt;&gt; np.random.randint(0, 10, (5, 5))
array([[0, 7, 7, 4, 3],
       [6, 0, 3, 1, 5],
       [6, 1, 0, 8, 4],
       [3, 2, 3, 9, 7],
       [7, 4, 1, 5, 9]])
</pre>
<pre class="list">
リスト : 一様分布

import numpy as np
import matplotlib.pyplot as plt

a = np.random.rand(100000)
plt.hist(a, bins=50)
# plt.savefig('rand.png', dpi=50)
plt.show()
</pre>
<p><img src="img/rand.png">
</p>
<pre class="list">
リスト : 正規分布

import numpy as np
import matplotlib.pyplot as plt

a = np.random.randn(100000)
plt.hist(a, bins=50)
# plt.savefig('randn.png', dpi=50)
plt.show()
</pre>
<p><img src="img/randn.png">
</p>
<pre class="list">
リスト : モンテカルロ法で円周率を求める (test.py)

import numpy as np

n = 1000000
x, y = np.random.rand(2, n)
c = x ** 2 + y ** 2 &lt;= 1
print(len(x[c]) / n * 4.0)
</pre>
<pre>
C&gt;python test.py
3.142276
</pre>
<ul>
  <li>メソッド choice() はランダムにシーケンスの要素を選択する</li>
  <li>選択する要素の個数や、キーワード引数 p で確率を指定することができる</li>
  <li>shuffle() は配列をシャッフルする</li>
  <li>シード (種) の設定は関数 seed() で行う</li>
</ul>
<pre>
&gt;&gt;&gt; a = ['foo', 'bar', 'baz', 'oops']
&gt;&gt;&gt; a
['foo', 'bar', 'baz', 'oops']
&gt;&gt;&gt; np.random.choice(a)
'oops'
&gt;&gt;&gt; np.random.choice(a)
'oops'
&gt;&gt;&gt; np.random.choice(a)
'foo'
&gt;&gt;&gt; np.random.choice(a, 2)
array(['bar', 'foo'], dtype='&lt;U4')
&gt;&gt;&gt; np.random.choice(a, 2)
array(['oops', 'foo'], dtype='&lt;U4')
&gt;&gt;&gt; np.random.choice(a, p=[1/2, 1/6, 1/6, 1/6])
'foo'
&gt;&gt;&gt; np.random.choice(a, p=[1/2, 1/6, 1/6, 1/6])
'oops'
&gt;&gt;&gt; np.random.choice(a, p=[1/2, 1/6, 1/6, 1/6])
'foo'
&gt;&gt;&gt; np.random.choice(a, p=[1/2, 1/6, 1/6, 1/6])
'foo'
&gt;&gt;&gt; np.random.choice(a, p=[1/2, 1/6, 1/6, 1/6])
'baz'

&gt;&gt;&gt; b = np.arange(10)
&gt;&gt;&gt; b
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.random.shuffle(b)
&gt;&gt;&gt; b
array([0, 2, 8, 5, 7, 1, 4, 6, 3, 9])
&gt;&gt;&gt; np.random.shuffle(b)
&gt;&gt;&gt; b
array([7, 8, 6, 1, 4, 9, 0, 3, 2, 5])

&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; np.random.rand(10)
array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ,
       0.64589411, 0.43758721, 0.891773  , 0.96366276, 0.38344152])
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; np.random.rand(10)
array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ,
       0.64589411, 0.43758721, 0.891773  , 0.96366276, 0.38344152])
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#numpy_abc">Python3</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>