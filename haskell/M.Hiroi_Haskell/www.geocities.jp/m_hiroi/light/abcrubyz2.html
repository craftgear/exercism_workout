<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby プログラミング入門</title>
  <meta name="description" content="Ruby,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881800</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Ruby プログラミング入門</h1>
<h2>付録</h2>
<div class="small">
[ <a href="abcrubyz1.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h3>簡単なプログラム</h3>
<ul>
  <li><a href="abcrubyz2.html#chap01">九九表の作成</a>
    / <a href="abcrubyz2.html#chap02">整数列の和</a>
    / <a href="abcrubyz2.html#chap03">度数分布表</a>
    / <a href="abcrubyz2.html#chap04">総和、最大値、最小値、平均値</a>
  <li><a href="abcrubyz2.html#chap05">累乗</a>
    / <a href="abcrubyz2.html#chap06">フィボナッチ数</a>
    / <a href="abcrubyz2.html#chap07">組み合わせの数</a>
    / <a href="abcrubyz2.html#chap08">パスカルの三角形</a>
    / <a href="abcrubyz2.html#chap09">組み合わせの生成</a>
  <li><a href="abcrubyz2.html#chap10">順列の生成</a>
    / <a href="abcrubyz2.html#chap11">完全順列の生成</a>
    / <a href="abcrubyz2.html#chap12">素数</a>
    / <a href="abcrubyz2.html#chap13">双子素数</a>
    / <a href="abcrubyz2.html#chap14">素因数分解</a>
    / <a href="abcrubyz2.html#chap15">約数の個数</a>
  <li><a href="abcrubyz2.html#chap16">約数の和</a>
    / <a href="abcrubyz2.html#chap17">約数</a>
    / <a href="abcrubyz2.html#chap18">べき集合</a>
</ul>
<hr>
<h4 id="chap01">●九九表の作成</h4>
<p> 九九表は for 文による二重ループで作成することができます。
</p>
<pre>
irb&gt; for x in 1..9
irb&gt; for y in 1..9
irb&gt; printf "%2d ", x * y
irb&gt; end
irb&gt; print "\n"
irb&gt; end
 1  2  3  4  5  6  7  8  9 
 2  4  6  8 10 12 14 16 18 
 3  6  9 12 15 18 21 24 27 
 4  8 12 16 20 24 28 32 36 
 5 10 15 20 25 30 35 40 45 
 6 12 18 24 30 36 42 48 54 
 7 14 21 28 35 42 49 56 63 
 8 16 24 32 40 48 56 64 72 
 9 18 27 36 45 54 63 72 81 
=> 1..9
</pre>
<p> for 文のかわりにメソッド each() を使う方法です。
</p>
<pre>
irb&gt; (1..9).each{|x|
irb&gt; (1..9).each{|y|
irb&gt; printf "%2d ", x * y
irb&gt; }
irb&gt; print "\n"
irb&gt; }
・・・省略・・・
</pre>
</p>
<p> 配列に格納する場合は map() を使うと簡単です。
</p>
<pre>
irb&gt; (1..9).map {|x| (1..9).map {|y| x * y}}
=&gt; [[1, 2, 3, 4, 5, 6, 7, 8, 9], 
[2, 4, 6, 8, 10, 12, 14, 16, 18], 
[3, 6, 9, 12, 15, 18, 21, 24, 27], 
[4, 8, 12, 16, 20, 24, 28, 32, 36], 
[5, 10, 15, 20, 25, 30, 35, 40, 45], 
[6, 12, 18, 24, 30, 36, 42, 48, 54], 
[7, 14, 21, 28, 35, 42, 49, 56, 63], 
[8, 16, 24, 32, 40, 48, 56, 64, 72], 
[9, 18, 27, 36, 45, 54, 63, 72, 81]]
</pre>
<hr>
<h4 id="chap02">●整数列の和</h4>
<p> 整数 n から m までの数列の和、二乗の和、三乗の和を求めることを考えます。この場合、高階関数 sum_of() を作ると簡単です。
</p>
<pre>
irb&gt; def sum_of(n, m, &amp;func)
irb&gt; (n..m).reduce(0) {|m, x| m + func.call(x)}
irb&gt; end
=&gt; :sum_of
irb&gt; sum_of(1, 100){|x| x}
=&gt; 5050
irb&gt; sum_of(1, 100){|x| x * x}
=&gt; 338350
irb&gt; sum_of(1, 100){|x| x * x * x}
=&gt; 25502500
irb&gt; sum_of(1, 100, &amp;:itself)
=&gt; 5050
</pre>
<p> sum_of() のブロックに引数をそのまま返す関数、二乗する関数、三乗する関数を渡すだけです。メソッド object.itself はレシーバーの object をそのまま返します。関数型言語では、引数をそのまま返す関数を「恒等関数 (identity function)」といいます。
</p>
<p> ところで、次に示す数列の和を求める公式を使うと、もっとスマートに値を求めることができます。
</p>
<ul>
  <li>1 + 2 + 3 + ... + n = n(n+1)/ 2
  <li>1 + 2<sup>2</sup> + 3<sup>2</sup> + ... + n<sup>2</sup> = n(n+1)(2n+1)/6
  <li>1 + 2<sup>3</sup> + 3<sup>3</sup> + ... + n<sup>3</sup> = n<sup>2</sup>(n+1)<sup>2</sup>/4
</ul>
<p> 興味のある方はプログラムを作ってみてください。
</p>
<hr>
<h4 id="chap03">●度数分布表</h4>
<p> 下記に示すデータの度数分布表と累積度数表を求めるプログラムを作ります。
</p>
<pre class="list">
リスト : 身長のデータ

height = [
  148.7, 149.5, 133.7, 157.9, 154.2, 147.8, 154.6, 159.1, 148.2, 153.1,
  138.2, 138.7, 143.5, 153.2, 150.2, 157.3, 145.1, 157.2, 152.3, 148.3,
  152.0, 146.0, 151.5, 139.4, 158.8, 147.6, 144.0, 145.8, 155.4, 155.5,
  153.6, 138.5, 147.1, 149.6, 160.9, 148.9, 157.5, 155.1, 138.9, 153.0,
  153.9, 150.9, 144.4, 160.3, 153.4, 163.0, 150.9, 153.3, 146.6, 153.3,
  152.3, 153.3, 142.8, 149.0, 149.4, 156.5, 141.7, 146.2, 151.0, 156.5,
  150.8, 141.0, 149.0, 163.2, 144.1, 147.1, 167.9, 155.3, 142.9, 148.7,
  164.8, 154.1, 150.4, 154.2, 161.4, 155.0, 146.8, 154.2, 152.7, 149.7,
  151.5, 154.5, 156.8, 150.3, 143.2, 149.5, 145.6, 140.4, 136.5, 146.9,
  158.9, 144.4, 148.1, 155.5, 152.4, 153.3, 142.3, 155.3, 153.1, 152.3
]
</pre>
<pre class="fig">
   階級   度数 累積度数
------------------------
130 - 135   1      1
135 - 140   6      7
140 - 145  12     19
145 - 150  25     44
150 - 155  32     76
155 - 160  17     93
160 - 165   6     99
165 - 170   1    100
</pre>
<p> 階級はデータの範囲を表します。この表では x cm 以上 y cm 未満を x - y で表しています。度数はその階級に出現したデータの個数です。度数を示してある表のことを「度数分布表」といいます。累積度数はその階級までの度数を全部加えたものです。累積度数を示してある表を「累積度数分布表」といいます。
</p>
<pre class="list">
リスト : 度数分布表と累積度数表

M = 8
freq = [0] * M  # 度数分布表
cum  = [0] * M  # 累積度数表
low = 130.0
z = 5.0

# 度数分布表の作成
for x in height
  for j in 0 ... M
    if x &lt; low + z * (j + 1)
      freq[j] += 1
      break
    end
  end
end

# 累積度数表の作成
cum[0] = freq[0]
for i in 1 ... M
  cum[i] = cum[i - 1] + freq[i]
end

# 表示
for i in 0 ... M
  printf "%.1f - %.1f | ", low + z * i, low + z * (i + 1)
  printf "%3d %3d\n", freq[i], cum[i]
end
</pre>
<p> 配列 freq が度数分布表、cum が累積度数表、変数 low が階級の下限値、z が階級の幅を表します。freq は 0 で初期化します。度数分布表の作成は簡単です。最初の for ループで height の要素を取り出します。次の for ループで階級を求めます。変数 j が階級を表し、その上限値は low + z * (j + 1) で求めることができます。height[i] がこの値よりも小さい場合、その要素は階級 j であることがわかります。freq[j] の値を +1 して、for ループを脱出します。
</p>
<p> 累積度数表の作成も簡単です。cum[0] を freq[0] で初期化します。あとは、度数分布表の値 freq[i] と累積度数表の値 cum[i - 1] を足し算していくだけです。最後に、for ループで 2 つの表を出力します。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
$ ruby problem03.rb
130.0 - 135.0 |   1   1
135.0 - 140.0 |   6   7
140.0 - 145.0 |  12  19
145.0 - 150.0 |  25  44
150.0 - 155.0 |  32  76
155.0 - 160.0 |  17  93
160.0 - 165.0 |   6  99
165.0 - 170.0 |   1 100
</pre>
<hr>
<h4 id="chap04">●総和、最大値、最小値、平均値</h4>
<p> 総和、最小値、最大値は reduce() を使うと簡単です。
<pre>
irb&gt; def sum(a)
irb&gt; a.reduce {|m, x| m + x}
irb&gt; end
=&gt; :sum
irb&gt; def min(a)
irb&gt; a.reduce {|m, x| m &gt; x ? x : m}
irb&gt; end
=&gt; :min
irb&gt; def max(a)
irb&gt; a.reduce {|m, x| m &lt; x ? x : m}
irb&gt; end
=&gt; :max
irb&gt; a = [5,6,4,7,3,8,2,9,1,0,10]
=&gt; [5, 6, 4, 7, 3, 8, 2, 9, 1, 0, 10]
irb&gt; sum(a)
=&gt; 55
irb&gt; min(a)
=&gt; 0
irb&gt; a.min
=&gt; 0
irb&gt; max(a)
=&gt; 10
irb&gt; a.max
=&gt; 10
irb&gt; def average(a)
irb&gt; sum(a) / a.size
irb&gt; end
=&gt; :average
irb&gt; average(a)
=&gt; 5
</pre>
<p> Ruby の Enumerable モジュールには最大値と最小値を求めるメソッド max(), min() があります。Ｃ言語のような三項演算子 ?, : もあります。
</p>
<hr>
<h4 id="chap05">●累乗</h4>
<p> ここでは x<sup>n</sup> の n を整数とします。一番簡単な方法は x を n 回乗算することです。
</p>
<pre>
irb&gt; def power(x, n)
irb&gt; (1..n).reduce(1) {|m, _| m * x}
irb&gt; end
=&gt; :power
irb&gt; power 2, 32
=&gt; 4294967296
irb&gt; power 2, 64
=&gt; 18446744073709551616
irb&gt; power 2, 128
=&gt; 340282366920938463463374607431768211456
</pre>

<p> 式を変形するともっと少ない回数で求めることができます。
</p>
<pre class="fig">
x ** 4  = (x ** 2) ** 2 -> 2 回
x ** 8  = (x ** 4) ** 2 -> 3 回
x ** 16 = (x ** 8) ** 2 -> 4 回

  一般化すると

x ** n = (x ** (n / 2)) ** 2; （n は偶数）

x ** n = ((x ** (n / 2)) ** 2) * x; （n は奇数）

  図 : 累乗を求める式の変形
</pre>
<p> 階乗の計算では n を n - 1 の計算に置き換えていきますが、累乗の場合は n を n / 2 に置き換えていくことができます。n が半分になっていくので、ひとつずつ n を減らすよりも減少の度合いは大きくなります。その分だけ計算回数が少なくなるわけです。
</p>
<p> これを再帰呼び出しでプログラムすると次のようになります。
</p>
<pre>
irb&gt; def power1(x, n)
irb&gt; return 1 if n == 0
irb&gt; value = power1(x, n / 2)
irb&gt; value *= value
irb&gt; value *= x if n % 2 == 1
irb&gt; value
irb&gt; end
=&gt; :power1
irb&gt; power1 2, 128
=&gt; 340282366920938463463374607431768211456
</pre>
<p> 最初の if 文が再帰呼び出しの停止条件です。次に、n を 2 で割った値で power1() を再帰呼び出しします。この返り値を 2 乗して、n が奇数ならば x をさらに掛け算します。最後に計算結果 value を返します。
</p>
<hr>
<h4 id="chap06">●フィボナッチ数</h4>
<p> n 番目のフィボナッチ数 F(n) は次の数式で定義されます。
</p>
<pre class="fig">
       ┌ 0                n = 0
F(n) = ┤ 1                n = 1
       └ F(n-1) + F(n-2)  n &gt; 1

0, 1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

    図 : フィボナッチ数の定義
</pre>
<p> フィボナッチ数も再帰呼び出しを使えば簡単にプログラムできます。
</p>
<pre>
irb&gt; def fibo(n)
irb&gt; return n if n &lt; 2
irb&gt; fibo(n - 1) + fibo(n - 2)
irb&gt; end
=&gt; :fibo
irb(main):050:0> 20.times {|n| puts fibo(n)}
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
=&gt; 20
</pre>
<p> 関数 fibo() は自分自身を 2 回呼び出しています。これを「二重再帰」といいます。fibo() は同じ値を何回も求めているため、効率はとても悪いのです。この場合、二重再帰を「末尾再帰」に変換すると高速化することができます。
</p>
<pre>
irb&gt; def fibo1(n, a = 0, b = 1)
irb&gt; return a if n == 0
irb&gt; fibo1(n - 1, b, a + b)
irb&gt; end
=&gt; :fibo1
irb&gt; fibo(30)
=&gt; 832040
irb&gt; fibo1(30)
=&gt; 832040
irb&gt; fibo1(50)
=&gt; 12586269025
irb&gt; fibo1(100)
=&gt; 354224848179261915075
</pre>
<p> 累算変数 a と b の使い方がポイントです。現在のフィボナッチ数を変数 a に、ひとつ先の値を変数 b に格納しておきます。あとは a と b を足し算して、新しいフィボナッチ数を計算すればいいわけです。
</p>
<p> フィボナッチ数列を生成するジェネレータはクラス Enumerator を使うと簡単です。
</p>
<pre>
irb&gt; fibos = Enumerator.new {|y|
irb&gt; a, b = 0, 1
irb&gt; loop {
irb&gt; y &lt;&lt; a
irb&gt; a, b = b, a + b
irb&gt; }
irb&gt; }
=&gt; #&lt;Enumerator: #&lt;Enumerator::Generator:0x88d3e2c&gt;:each&gt;
irb&gt; 20.times {|_| puts fibos.next}
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
=&gt; 20
irb&gt; fibos.first(20)
=&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]
irb&gt; fibos.lazy.drop(20).first(20)
=&gt; [6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 
1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986]
</pre>
<p> Enumerator で作成したジェネレータはメソッド next() で値を順番に取得することができます。また、メソッド first() や take() で先頭から n 個の要素を取り出すことができます。
</p>
<p> ただし、このプログラムは無限数列になっているので、先頭から n 個の要素を取り除くメソッド drop() を使うと、要素を n 個取り除いたあとの配列 (無限個) を生成しようとするため、irb がフリーズしてしまいます。この場合、メソッド Enumerable#lazy を使って遅延リストに変換すると動作します。
</p>
<hr>
<h4 id="chap07">●組み合わせの数</h4>
<p> 組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> を求めるには、次の公式を使えば簡単です。
</p>
<pre class="item">
<sub>n</sub>Ｃ<sub>r</sub> = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>
<p> 皆さんお馴染みの公式ですね。ところが、整数値の範囲が限られているプログラミング言語では、この公式を使うと乗算で「桁あふれ」を起こす恐れがあります。Ruby は多倍長演算をサポートしているので、桁あふれを心配する必要はありません。
</p>
<p> この公式をそのままプログラムすることもできますが、次の式を使うともっと簡単にプログラムできます。
</p>
<pre class="item">
<sub>n</sub>Ｃ<sub>r</sub> = <sub>n</sub>Ｃ<sub>r-1</sub> * (n - r + 1) / r
<sub>n</sub>Ｃ<sub>0</sub> = <sub>n</sub>Ｃ<sub>n</sub> = 1
</pre>
<p> この式は <sub>n</sub>Ｃ<sub>r</sub> と <sub>n</sub>Ｃ<sub>r-1</sub> の関係を表しています。あとは、再帰定義を使って簡単にプログラムできます。
</p>
<pre>
irb&gt; def comb(n, r)
irb&gt; return 1 if n == r || r == 0
irb&gt; comb(n, r - 1) * (n - r + 1) / r
irb&gt; end
=&gt; :comb
irb&gt; comb(10, 5)
=&gt; 252
irb&gt; comb(30, 15)
=&gt; 155117520
irb&gt; comb(50, 25)
=&gt; 126410606437752
</pre>
<hr>
<h4 id="chap08">●パスカルの三角形</h4>
<p> 下図に「パスカルの三角形」を示します。
</p>
<pre class="fig">
                １                                 0Ｃ0
              ／  ＼                              ／  ＼
            １      １                         1Ｃ0    1Ｃ1
          ／  ＼  ／  ＼                      ／  ＼  ／  ＼
        １      ２      １                 2Ｃ0    2Ｃ1    2Ｃ2
      ／  ＼  ／  ＼  ／  ＼              ／  ＼  ／  ＼  ／  ＼
    １      ３      ３      １         3Ｃ0    3Ｃ1    3Ｃ2    3Ｃ3
  ／  ＼  ／  ＼  ／  ＼  ／  ＼      ／  ＼  ／  ＼  ／  ＼  ／  ＼
１      ４      ６      ４      １ 4Ｃ0    4Ｃ1    4Ｃ2    4Ｃ3    4Ｃ4 

                        図 : パスカルの三角形
</pre>
<p> パスカルの三角形は、左側の図のように両側がすべて 1 で、内側の数はその左上と右上の和になっています。これは式 (a + b)<sup>n</sup> を展開したときの各項の係数を表しています。そして、その値は右側の図のように組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> に対応しています。
</p>
<p> きれいな三角形にはなりませんが、簡単なプログラムを示します。
</p>
<pre>
irb&gt; def pascal(x)
irb&gt; for n in 0..x
irb&gt; for r in 0..n
irb&gt; print comb(n, r), " "
irb&gt; end
irb&gt; print "\n"
irb&gt; end
irb&gt; end
=&gt; :pascal
irb&gt; pascal(16)
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 
1 10 45 120 210 252 210 120 45 10 1 
1 11 55 165 330 462 462 330 165 55 11 1 
1 12 66 220 495 792 924 792 495 220 66 12 1 
1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1 
1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1 
1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1 
1 16 120 560 1820 4368 8008 11440 12870 11440 8008 4368 1820 560 120 16 1 
=&gt; 0..16
</pre>
<p> for ループで二重ループを構成しています。最初の for ループで変数 n の値を 0 から x まで +1 ずつ増やし、次の for ループで変数 r の値を 0 から n まで +1 ずつ増やします。あとは comb() で <sub>n</sub>Ｃ<sub>r</sub> の値を計算するだけです。
</p>
<p> comb() を使わないでプログラムを作ることもできます。
</p>
<pre>
irb&gt; def pascal1(x)
irb&gt; a = [1]
irb&gt; (x + 1).times {|_|
irb&gt; print a, "\n"
irb&gt; a.push 0
irb&gt; a = a.zip(a.reverse).map {|xs| xs[0] + xs[1]}
irb&gt; }
irb&gt; end
=&gt; :pascal1
irb&gt; pascal1(16)
[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]
[1, 5, 10, 10, 5, 1]
[1, 6, 15, 20, 15, 6, 1]
[1, 7, 21, 35, 35, 21, 7, 1]
[1, 8, 28, 56, 70, 56, 28, 8, 1]
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
[1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]
[1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1]
[1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1]
[1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1]
[1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1]
[1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1]
[1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1]
=&gt; 17
</pre>
<p> 前段の値を配列 a に格納します。a に 0 を追加して、それを反転した配列の要素と足し算すれば、次段の値を求めることができます。もちろん、配列を一つで済ますことも可能です。興味のある方は挑戦してみてください。
</p>
<hr>
<h4 id="chap09">●組み合わせの生成</h4>
<p> たとえば、1 から 5 までの数字の中から 3 個を選ぶ組み合わせは次のようになります。
</p>
<pre class="fig">
(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),
(2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)
</pre>
<p> 最初に 1 を選択した場合、次は (2, 3, 4, 5) の中から 2 個を選べばいいですね。2 番目に 2 を選択したら、次は (3, 4, 5) の中から 1 個を選べばいいわけです。これで、(1, 2, 3), (1, 2, 4), (1, 2, 5) が生成されます。(2, 3, 4, 5) の中から 2 個選ぶとき、2 を選ばない場合があります。この場合は (3, 4, 5) の中から 2 個を選べばいいわけです。ここで 3 を選ぶと (1, 3, 4), (1, 3, 5) が生成できます。同様に、3 を除いた (4, 5) の中から 2 個を選ぶと (1, 4, 5) を生成することができます。
</p>
<p> これで 1 を含む組み合わせを生成したので、次は 1 を含まない組み合わせ、つまり (2, 3, 4, 5) から 3 個を選ぶ組み合わせを生成すればいいわけです。けっきょく、この処理の考え方は次に示す組み合わせの公式と同じです。
</p>
<pre class="item">
<sub>n</sub>Ｃ<sub>0</sub> = <sub>n</sub>Ｃ<sub>n</sub> = 1
<sub>n</sub>Ｃ<sub>r</sub> = <sub>n-1</sub>Ｃ<sub>r-1</sub> + <sub>n-1</sub>Ｃ<sub>r</sub>
</pre>
<p> Ruby でプログラムを作ると次のようになります。
</p>
<pre>
irb&gt; def combination(n, xs, ys = [], &amp;func)
irb&gt; if n == 0
irb&gt; func.call(ys)
irb&gt; elsif xs.size == n
irb&gt; func.call(ys + xs)
irb&gt; else
irb&gt; combination(n - 1, xs[1..-1], ys + [xs[0]], &amp;func)
irb&gt; combination(n, xs[1..-1], ys, &amp;func)
irb&gt; end
irb&gt; end
=&gt; :combination
irb&gt; combination(3, [1,2,3,4,5]){|xs| print xs, "\n"}
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 4]
[1, 3, 5]
[1, 4, 5]
[2, 3, 4]
[2, 3, 5]
[2, 4, 5]
[3, 4, 5]
=&gt; nil
</pre>
<p> combination() は引数 xs の配列から n 個を選ぶ組み合わせを生成し、それをブロック func に渡して実行します。選んだ要素は第 3 引数 ys に格納します。n が 0 になったら組み合わせを一つ生成できたので、func.call(ys) を実行します。
</p>

<p> 次の節で、配列 xs の長さが n と等しくなったならば、xs の要素を全て選択します。ys + xs で配列を連結してブロック func を呼び出します。あとは combination() を再帰呼び出しするだけです。最初の呼び出しは先頭の要素を選択する場合です。先頭要素 xs[0] を ys に追加して、xs[1..-1] の中から n - 1 個を選びます。最後の呼び出しが先頭の要素を選ばない場合です。xs[1..-1] の中から n 個を選びます。
</p>
<p> なお、Ruby には組み合わせを生成するメソッド combination() が用意されています。
</p>
<pre>
irb&gt; [1,2,3,4,5].combination(3) {|xs| print xs, "\n"}
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 4]
[1, 3, 5]
[1, 4, 5]
[2, 3, 4]
[2, 3, 5]
[2, 4, 5]
[3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; c = [1,2,3,4,5].combination(3)
=&gt; #&lt;Enumerator: [1, 2, 3, 4, 5]:combination(3)&gt;
irb&gt; c.next
=&gt; [1, 2, 3]
irb&gt; c.next
=&gt; [1, 2, 4]
irb&gt; c.next
=&gt; [1, 2, 5]
</pre>
<p> メソッド combination() はブロックを省略すると、Enumerator のオブジェクトを返します。Ruby の高階関数はブロックを省略すると Enumerator のオブジェクトを返すものが多くあります。
</p>
<hr>
<h4 id="chap10">●順列の生成</h4>
<p> 配列 xs の中から n 個の要素を選択する順列を生成します。プログラムは次のようになります。
</p>
<pre>
irb&gt; def permutation(n, xs, ys = [], &amp;func)
irb&gt; if n == 0
irb&gt; func.call(ys)
irb&gt; else
irb&gt; xs.each {|x|
irb&gt; next if ys.member? x
irb&gt; permutation(n - 1, xs, ys + [x], &amp;func)
irb&gt; }
irb&gt; end
irb&gt; end
=&gt; :permutation
irb&gt; permutation(4, [1,2,3,4]) {|xs| print xs, "\n"}
[1, 2, 3, 4]
[1, 2, 4, 3]
[1, 3, 2, 4]
[1, 3, 4, 2]
[1, 4, 2, 3]
[1, 4, 3, 2]
[2, 1, 3, 4]
[2, 1, 4, 3]
[2, 3, 1, 4]
[2, 3, 4, 1]
[2, 4, 1, 3]
[2, 4, 3, 1]
[3, 1, 2, 4]
[3, 1, 4, 2]
[3, 2, 1, 4]
[3, 2, 4, 1]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 1, 2, 3]
[4, 1, 3, 2]
[4, 2, 1, 3]
[4, 2, 3, 1]
[4, 3, 1, 2]
[4, 3, 2, 1]
=&gt; [1, 2, 3, 4]
</pre>
<p> なお、Ruby には組み合わせを生成するメソッド permutationa() が用意されています。
</p>
<pre>
irb&gt; [1,2,3,4].permutation(3) {|xs| print xs, "\n"}
[1, 2, 3]
[1, 2, 4]
[1, 3, 2]
[1, 3, 4]
[1, 4, 2]
[1, 4, 3]
[2, 1, 3]
[2, 1, 4]
[2, 3, 1]
[2, 3, 4]
[2, 4, 1]
[2, 4, 3]
[3, 1, 2]
[3, 1, 4]
[3, 2, 1]
[3, 2, 4]
[3, 4, 1]
[3, 4, 2]
[4, 1, 2]
[4, 1, 3]
[4, 2, 1]
[4, 2, 3]
[4, 3, 1]
[4, 3, 2]
=&gt; [1, 2, 3, 4]
irb&gt; ps = [1,2,3,4].permutation(3)
=&gt; #&gt;Enumerator: [1, 2, 3, 4]:permutation(3)&gt;
irb&gt; ps.next
=&gt; [1, 2, 3]
irb&gt; ps.next
=&gt; [1, 2, 4]
irb&gt; ps.next
=&gt; [1, 3, 2]
irb&gt; ps.next
=&gt; [1, 3, 4]
</pre>
<hr>
<h4 id="chap11">●完全順列の生成</h4>
<p> N 個の整数 1, 2, ..., N の順列を考えます。このとき、i 番目 (先頭が 1 番目) の要素が整数 i ではない順列を完全順列 (derangement) といいます。
</p>
<pre>
irb&gt; def derangement(n, xs = [], &amp;func)
irb&gt; if xs.size == n
irb&gt; func.call(xs)
irb&gt; else
irb&gt; (1..n).each {|x|
irb&gt; next if (xs.size + 1 == x) || (xs.member? x)
irb&gt; derangement(n, xs + [x], &amp;func)
irb&gt; }
irb&gt; end
irb&gt; end
=&gt; :derangement
irb&gt; derangement(3) {|xs| print xs, "\n"}
[2, 3, 1]
[3, 1, 2]
=&gt; 1..3
irb&gt; derangement(4) {|xs| print xs, "\n"}
[2, 1, 4, 3]
[2, 3, 4, 1]
[2, 4, 1, 3]
[3, 1, 4, 2]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 1, 2, 3]
[4, 3, 1, 2]
[4, 3, 2, 1]
=&gt; 1..4
</pre>
<p> 1 から n までの数字を n 個選ぶ順列を生成する処理で、数字 x が xs.size + 1 と等しい場合は数字 x を選択しません。xs.size が n と等しい場合は n 個の数字を選んだので func.call(xs) を実行します。これで完全順列を生成することができます。
</p>
<hr>
<h4 id="chap12">●素数</h4>
<p> 整数 n 以下の素数を求めるいちばん簡単な方法は、奇数 3, 5, 7, 9, ... をそれまでに見つけた素数で割ってみることです。この方法は Ruby 入門講座でプログラムを作ったことがあります。ここでは別の方法を紹介しましょう。
</p>
<p> 最初に、2 から n までの整数列を生成します。先頭の 2 は素数なので、この整数列から 2 で割り切れる整数を取り除き除きます。2 で割り切れる整数が取り除かれたので、残った要素の先頭が素数になります。先頭要素は 3 になるので、今度は 3 で割り切れる整数を取り除けばいいのです。このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩 (ふるい)」といいます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : エラトステネスの篩

def sieve(n)
  primes = [2]
  table = Array.new(n / 2) { true }
  x = 3
  while x * x &lt;= n
    y = (x - 3) / 2
    if table[y]
      primes.push x
      (y + x).step(table.size, x) {|i|
        table[i] = false
      }
    end
    x += 2
  end
  while x &lt;= n
    primes.push x if table[(x - 3) / 2]
    x += 2
  end
  primes
end
</pre>
<p> 配列 primes に素数を格納し、table で奇数列 (3, 5, 7, ... ) を表します。true で素数を表し、素数でない場合は false に書き換えます。配列の生成は Array.new() で行うことができます。
</p>
<pre class="item">
Array.new(size) {|index| ... }
</pre>
<p> 引数 size は配列の大きさです。ブロックの引数 index には配列の添字 (0 から size - 1 まで) が渡され、ブロックの返り値が配列の要素になります。ブロックを省略した場合は nil に初期化されます。
</p>
<p> 奇数を変数 x とし、それに対応する table の添字を変数 y とすると、変数 x は 3, 5, 7, 9, ... に、それに対応する変数 y は 0, 1, 2, 3, ... になります。この場合、x の倍数に対応する y の値は y + x, y + x * 2, y + x * 3, ... になります。たとえば、3, 5, 7 の倍数は次のようになります。
</p>
<pre class="item">
x :  3  5  7  9 11 13 15 17 19 21 23 25
y :  0  1  2  3  4  5  6  7  8  9 10 11
--+-------------------------------------
3 |  O        0        O        0
5 |     0              0              0
7 |        0                    0
</pre>
<p> プログラムは簡単です。最初の while ループで、x を √n まで +2 ずつ増やして素数かチェックします。table の添字 y は (x - 3) / 2 で求めることができます。table[y] が true ならば x は素数です。x の倍数を table から削除します。step() はブロックを繰り返し実行するメソッドです。
</p>
<pre class="item">
num.step(limit, step) {|n| ... }
</pre>
<p> step() は num からはじめ step を足しながら limit を越える前までブロックを繰り返します。ブロックの引数 n には数値が渡されます。times() と違って、step() は整数だけではなく浮動小数点でも動作します。
</p>
<p> 最後に、while ループで √n よりも大きい素数を求めます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
irb&gt; sieve(100)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 
79, 83, 89, 97]
irb&gt; sieve(500)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 
79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 
173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 
269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 
373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 
467, 479, 487, 491, 499]
</pre>
<p> ところで、エラトステネスの篩は次のようにプログラムすることもできます。
</p>
<pre class="list">
リスト : エラトステネスの篩 (2)

def sieve1(n)
  ps = [2]
  xs = Array.new((n + 1) / 2 - 1) {|x| x * 2 + 3}
  while true
    p = xs[0]
    break if p * p > n
    ps.push p
    xs.delete_if {|x| x % p == 0}
  end
  ps + xs
end
</pre>
<p> xs に奇数を格納した配列をセットします。あとは while 文の中で、xs から素数で割り切れるものを delete_if() で削除していくだけです。ただし、配列を破壊的に修正するので、sieve() よりも時間がかかると思います。興味のある方は試してみてください。
</p>
<p> なお、Rubyには素数を扱うライブラリ prime が用意されています。
</p>
<pre>
irb&gt; require 'prime'
=&gt; true
irb&gt; Prime.each(100) {|n| print n, " "}
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 =&gt; nil
irb&gt; Prime.first(20)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
</pre>
<p> 詳しい説明は Ruby のリファレンス <a href="https://docs.ruby-lang.org/ja/latest/class/Prime.html">class Prime</a> をお読みください。
</p>
<hr>
<h4 id="chap13">●双子素数</h4>
<p> 差が 2 である素数の組を「双子素数 (twin prime)」といいます。あらかじめ素数表が用意されていれば、Ruby のメソッド each_cons() を使うと双子素数は簡単に求めることができます。
</p>
<pre class="item">
obj.each_cons(n) {|xs| ... }
obj.each_slice(n) {|xs| ... }
</pre>
<p> どちらのメソッドも obj から n 個ずつ要素を取り出し、それらを配列に格納してブロックの引数 xs に渡します。たとえば、[1, 2, 3, 4] から要素を 2 つ取り出す場合、each_slice() は [1, 2], [3, 4] のように先頭から 2 つずつ順番に取り出しますが、each_cons() は [1, 2], [2, 3], [3, 4] のように、隣り合った要素を順番に取り出します。
</p>
<p> 簡単な使用例を示しましょう。
</p>
<pre>
irb&gt; (1..10).each_cons(2) {|a| print a}
[1, 2][2, 3][3, 4][4, 5][5, 6][6, 7][7, 8][8, 9][9, 10]=&gt; nil
irb&gt; (1..10).each_cons(3) {|a| print a}
[1, 2, 3][2, 3, 4][3, 4, 5][4, 5, 6][5, 6, 7][6, 7, 8][7, 8, 9][8, 9, 10]=&gt; nil
irb&gt; (1..10).each_slice(2) {|a| print a}
[1, 2][3, 4][5, 6][7, 8][9, 10]=&gt; nil
irb&gt; (1..10).each_slice(3) {|a| print a}
[1, 2, 3][4, 5, 6][7, 8, 9][10]=&gt; nil
</pre>
<p> 双子素数は次のようになります。
</p>
<pre>
irb&gt; sieve(1000).each_cons(2) {|xs| print xs if xs[1] - xs[0] == 2}
[3, 5][5, 7][11, 13][17, 19][29, 31][41, 43][59, 61][71, 73][101, 103][107, 109]
[137, 139][149, 151][179, 181][191, 193][197, 199][227, 229][239, 241][269, 271]
[281, 283][311, 313][347, 349][419, 421][431, 433][461, 463][521, 523][569, 571]
[599, 601][617, 619][641, 643][659, 661][809, 811][821, 823][827, 829][857, 859]
[881, 883]=&gt; nil
</pre>
<p> もちろん、Ruby の Prime を使っても簡単に求めることができます。
</p>
<pre>
irb&gt; Prime.each(1000).each_cons(2) {|xs| print xs if xs[1] - xs[0] == 2}
・・・省略・・・
</pre>
<hr>
<h4 id="chap14">●素因数分解</h4>
<p> 素因数分解はエラトステネスの篩と同じ考え方で行うことができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 素因数分解

def factor_sub(n, m)
  c = 0
  while n % m == 0
    c += 1
    n /= m
  end
  return c, n
end

def factorization(n)
  buff = []
  c, m = factor_sub(n, 2)
  buff.push [2, c] if c &gt; 0
  x = 3
  while x * x &lt;= m
    c, m = factor_sub(m, x)
    buff.push [x, c] if c &gt; 0
    x += 2
  end
  buff.push [m, 1] if m &gt; 1
  buff
end
</pre>
<p> 最初に 2 で割り算します。割り算するときは、その数で割り切れるあいだは割り算を続けることに注意してください。たとえば、27 を素因数分解すると 3 * 3 * 3 になりますが、3 を一回だけしか割り算しないと、結果は 3 * 9 のように素数ではない数が含まれてしまいます。この処理を関数 factor_sub() で行っています。
</p>
<p> あとは、factor_sub() の返り値をチェックして、割り算した回数 c が 0 よりも大きければ、素数と c を配列に格納して、それを buff に追加します。これを変数 m が x * x 以下のあいだ繰り返します。最後に m が 1 よりも大きければ、(m, 1) を buff に追加して、return で buff を返します。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
irb&gt; factorization(24)
=&gt; [[2, 3], [3, 1]]
irb&gt; factorization(12345678)
=&gt; [[2, 1], [3, 2], [47, 1], [14593, 1]]
irb&gt; factorization(123456789)
=&gt; [[3, 2], [3607, 1], [3803, 1]]
irb&gt; factorization(1234567890)
=&gt; [[2, 1], [3, 2], [5, 1], [3607, 1], [3803, 1]]
irb&gt; factorization(1111111111)
=&gt; [[11, 1], [41, 1], [271, 1], [9091, 1]]
</pre>
<p> なお、これはとても単純なアルゴリズムなので、大きな整数の素因数分解には適していません。巨大な合成数の素因数分解はとても難しい問題です。興味のある方は素因数分解について調べてみてください。
</p>
<p> また、Ruby の prime には素因数分解を行うメソッド prime_division() が用意されています。
</p>
<pre>
irb&gt; Prime.prime_division(24)
=&gt; [[2, 3], [3, 1]]
irb&gt; Prime.prime_division(123456789)
=&gt; [[3, 2], [3607, 1], [3803, 1]]
</pre>
<hr>
<h4 id="chap15">●約数の個数</h4>
<p> n の素因数分解ができると、約数の個数を求めるのは簡単です。n = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> とすると、約数の個数は (a + 1) * (b + 1) * (c + 1) になります。たとえば、12 は 2<sup>2</sup> * 3<sup>1</sup> になるので、約数の個数は 3 * 2 = 6 になります。実際、12 の約数は 1, 2, 3, 4, 6, 12 の 6 個です。
</p>
<p> プログラムは reduce() を使うと簡単です。
</p>
<pre>
irb&gt; def divisor_num(n)
irb&gt; factorization(n).reduce(1) {|m, xs| m *= xs[1] + 1}
irb&gt; end
=&gt; :divisor_num
irb&gt; divisor_num(24)
=&gt; 8
irb&gt; divisor_num(12345678)
=&gt; 24
irb&gt; divisor_num(123456789)
=&gt; 12
irb&gt; divisor_num(1234567890)
=&gt; 48
irb&gt; divisor_num(1111111111)
=&gt; 16
</pre>
<hr>
<h4 id="chap16">●約数の和</h4>
<p> n の素因数分解ができると、約数の合計値を求めるのは簡単です。n の素因数分解が p<sup>a</sup> だった場合、その約数の合計値は次の式で求めることができます。
</p>
<pre class="item">
σ(p, a) = p<sup>a</sup> + p<sup>a-1</sup> + ... + p<sup>2</sup> + p + 1
</pre>
<p> たとえば、8 の素因数分解は 2<sup>3</sup> になり、素数の合計値は 8 + 4 + 2 + 1 = 15 になります。これは reduce() を使うと簡単にプログラムできます。
</p>
<pre class="list">
(0..a).reduce(0) {|m, x| m + p ** x}
</pre>
<p> p<sup>a</sup> の約数の合計値を σ(p, a) で表すことにします。n = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> の場合、n の約数の合計値は σ(p, a) * σ(q, b) * σ(r, c) になります。たとえば、12 は 2<sup>2</sup> * 3 に素因数分解できますが、その合計値は (4 + 2 + 1) * (3 + 1) = 28 となります。12 の約数は 1, 2, 3, 4, 6, 12 なので、その合計値は確かに 28 になります。
</p>
<p> プログラムは次のようになります。。
</p>
<pre>
irb&gt; def divisor_sum(n)
irb&gt; factorization(n).reduce(1) {|m, xs| m * (0..xs[1]).reduce(0) {|a, x| a + xs[0] ** x}}
irb&gt; end
=&gt; :divisor_sum
irb&gt; divisor_sum(24)
=&gt; 60
irb&gt; divisor_sum(12345678)
=&gt; 27319968
irb&gt; divisor_sum(123456789)
=&gt; 178422816
irb&gt; divisor_sum(1234567890)
=&gt; 3211610688
irb&gt; divisor_sum(1111111111)
=&g; 1246404096
</pre>
<hr>
<h4 id="chap17">●約数</h4>
<p> p が素数の場合、p<sup>a</sup> の約数は次のように簡単に求めることができます。
</p>
<pre class="item">
p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1
</pre>
<p> n の素因数分解が p<sup>a</sup> * q<sup>b</sup> だったとすると、その約数は次のようになります。
</p>
<pre class="item">
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b-1</sup>,
        .....
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>2</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * 1
</pre>
<p> たとえば、12 の約数は 2<sup>4</sup> = (1, 2, 4) と 3 = (1, 3) から、(1, 2, 4) * 1 と (1, 2, 4) * 3 のすべての要素 (1, 2, 4, 3, 6, 12) になります。この処理はメソッド product() を使うと簡単です。product() は 2 つの配列から直積集合を求めます、簡単な例を示しましょう。
</p>
<pre>
irb&gt; [1,2,3].product([4,5,6])
=&gt; [[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]]
irb&gt; [1,2,3].product([4,5,6]).map {|x, y| x * y}
=&gt; [4, 5, 6, 8, 10, 12, 12, 15, 18]
</pre>
<p> プログラムは次のようになります。
</p>
<pre>
irb&gt; def divisor_sub(p, q)
irb&gt; (0..q).reduce([]) {|xs, i| xs + [p ** i]}
irb&gt; end
=&gt; :divisor_sub
irb&gt; def divisor(n)
irb&gt; factorization(n).reduce([1]) {|ys, xs|
irb&gt; ys.product(divisor_sub(*xs)).map {|x, y| x * y}
irb&gt; }.sort()
irb&gt; end
=&gt; :divisor
</pre>
<p> 関数 divisor_sub() は p<sup>q</sup> の約数を配列に格納して返します。引数 n を factorization() で素因数分解して、その結果を reduce() に渡します。引数 ys が累積変数、xs は p, q を格納した配列です。xs を divisor_sub() に渡して配列に変換し、product() で直積集合を生成し、それから map() で要素 x, y を掛け算します。最後に sort() で配列をソートします。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
irb&gt; divisor(24)
=&gt; [1, 2, 3, 4, 6, 8, 12, 24]
irb&gt; divisor(12345678)
=&gt; [1, 2, 3, 6, 9, 18, 47, 94, 141, 282, 423, 846, 14593, 29186, 43779, 87558, 
131337, 262674, 685871, 1371742, 2057613, 4115226, 6172839, 12345678]
irb&gt; divisor(123456789)
=&gt; [1, 3, 9, 3607, 3803, 10821, 11409, 32463, 34227, 13717421, 41152263, 123456789]
irb&gt; divisor(1234567890)
=&gt; [1, 2, 3, 5, 6, 9, 10, 15, 18, 30, 45, 90, 3607, 3803, 7214, 7606, 10821, 11409, 
18035, 19015, 21642, 22818, 32463, 34227, 36070, 38030, 54105, 57045, 64926, 68454, 
108210, 114090, 162315, 171135, 324630, 342270, 13717421, 27434842, 41152263, 
68587105, 82304526, 123456789, 137174210, 205761315, 246913578, 411522630, 617283945, 
1234567890]
irb&gt; divisor(1111111111)
=&gt; [1, 11, 41, 271, 451, 2981, 9091, 11111, 100001, 122221, 372731, 2463661, 
4100041, 27100271, 101010101, 1111111111]
</pre>
<hr>
<h4 id="chap18">●べき集合</h4>
<p> 配列 xs のべき集合を求める関数 power_set(xs) を作ります。たとえば、配列 [1, 2, 3] のべき集合は [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] になります。
</p>
<p> プログラムは次のようになります。
</p>
<pre>
irb&gt; def power_set(xs)
irb&gt; if xs == []
irb&gt; return [[]]
irb&gt; else
irb&gt; ys = power_set(xs[1..-1])
irb&gt; ys + ys.map {|zs| [xs[0]] + zs}
irb&gt; end
irb&gt; end
=&gt; :power_set
irb(main):009:0> power_set([1,2,3])
=&gt; [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
irb&gt; power_set([1,2,3,4])
=&gt; [[], [4], [3], [3, 4], [2], [2, 4], [2, 3], [2, 3, 4], [1], [1, 4], [1, 3],
 [1, 3, 4], [1, 2], [1, 2, 4], [1, 2, 3], [1, 2, 3, 4]]
</pre>
<p> xs が空の場合は [] を格納した配列を返します。そうでなければ power_set() を再帰呼び出しして xs[1..-1] のべき集合 ys を求め、ys に先頭要素 xs[0] を追加します。そして、その集合と ys を演算子 + で連結します。
</p>
<p> ところで、べき集合は再帰呼び出しを使わなくても、繰り返しでも簡単にプログラムすることができます。配列 xs のべき集合の要素は 2 ** xs.size 個あります。これらの要素を 0 から 2 ** xs.size - 1 まで整数に対応させ、ビットが 1 の位置の要素を選んでいくとべき集合を求めることができます。
</p>
<p> Ruby の場合、整数 n に角カッコをつけると、その位置にあるビットの値を求めることができます。
</p>
<pre>
irb&gt; 0xf0[0]
=&gt; 0
irb&gt; 0xf0[4]
=&gt; 1
irb&gt; 0xf0[7]
=&gt; 1
</pre>
<p> プログラムは次のようになります。
</p>
<pre>
irb&gt; def power_set1(xs, &amp;func)
irb&gt; n = 2 ** xs.size
irb&gt; for x in 0 ... n
irb&gt; ys = []
irb&gt; for i in 0 ... n
irb&gt; ys.push xs[i] if x[i] == 1
irb&gt; end
irb&gt; func.call(ys)
irb&gt; end
irb&gt; end
=&gt; :power_set1
irb&gt; power_set1([1,2,3]) {|xs| print xs, " "}
[] [1] [2] [1, 2] [3] [1, 3] [2, 3] [1, 2, 3] => 0...8
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcrubyz1.html">PrevPage</a> | <a href="ruby.html#ruby_abc">R u b y</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>