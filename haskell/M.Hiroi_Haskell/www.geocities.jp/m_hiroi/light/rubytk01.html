<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby/Tk 超入門</title>
  <meta name="description" content="Ruby,Tk,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881801</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Lightweigth Language</h1>
<h2>お気楽 Ruby/Tk 超入門</h2>
<div class="small">
[ PrevPage | <a href="ruby.html#ruby_tk">Ruby</a> | <a href="rubytk02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">はじめに</h3>
<p> Ruby はシンプルでわかりやすいスクリプト言語です。シンプルといっても簡易言語ではありません。ハッシュ、モジュール、例外処理、オブジェクト指向など高度な機能を備えていて、大規模なソフトウェアでも開発できる汎用のプログラミング言語として、さまざまな分野で使われています。
</p>

<p> GUI (Graphical User Interface) アプリケーションの作成もそのひとつです。GUI に対応したアプリケーションを作ることは、CUI (Character User Interface) で動作するプログラムを作るよりも相当の労力を必要とします。さらに、GUI はユーザーの使い勝手に直結しているため、プログラムの改良を頻繁に行うことがあります。このため、GUI の開発は簡単にプログラムの修正と実行が行えるスクリプト言語が適しているといわれています。
</p>

<p> GUI 用のスクリプト言語で有名なのが Tcl/Tk です。拙作のページ <a href="../tcl_tk.html">Tcl/Tk GUI Programming</a> では入門記事やミニゲーム集を公開しています。Tcl/Tk は優れた開発環境ですが、実際に使っていると Tcl 言語に不満が出てきます。Tcl はシェルスクリプトを拡張したコマンド言語、つまり簡易言語に過ぎません。簡単なアプリケーションならば、数行から数十行でプログラムを記述できますが、数百行以上のプログラムを作るのには適していません。
</p>

<p> Tcl は好まないが Tk を愛してやまない人々が、自分の好みの言語に Tk を移植する試みが行われました。もちろん、Ruby でも Tk を使うことができます。それが Ruby/Tk です。Ubuntu 系の OS で、Ruby (ver 2.3) と Tcl/Tk (ver 8.6) がインストールされている場合、次のコマンドで Ruby/Tk を簡単にインストールすることができます。
</p>
<pre class="item">
$ sudo apt-get install ruby2.3-tcltk
</pre>
<p> 本稿では、簡単なプログラムを作りながら Ruby/Tk の使い方を説明していく予定です。実行環境は Lubuntu 16.04 on VirtualBox です。とりあえず、<a href="../tcl_tk_doc/tcltk_doc.html">Tcl/Tk お気楽 GUI プログラミング入門編</a>、<a href="../tcl_tk_doc/tcltk_doc.html#def">Tcl/Tk お気楽 GUI プログラミング応用編</a> と同じ例題を Ruby/Tk で作ってみようと思います。たいしたことはできませんが、よろしければお付き合いくださいませ。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">Ruby/Tk の基礎知識</h3>
<h4>●イベント駆動方式</h4>
<p> GUI アプリケーションの場合、ユーザーからの入力やシステムの状態変化など、ある出来事をきっかけにプログラムが実行されます。この出来事を「イベント(event)」といい、イベントをきっかけにしてプログラムが起動されることを「イベントドリブン (イベント駆動, eventdriven)」といいます。イベントドリブン型のアプリケーションは、一般に次のようなメインルーチンを持っています。
</p>
<ol>
  <li> 初期化
  <li> イベントを取得する
  <li> イベントの種類に応じて処理を振り分ける
  <li> 2 に戻る
</ol>
<p> 2 から 4 を「イベントループ」と呼び、アプリケーションはユーザーからの入力などのイベントを待ちます。そして、3 の処理に対応する機能が「バインディング(binding)」です。バインディングは、ウィンドウでイベントが発生したときに、それに応じて定義したプログラムを実行します。このプログラムを「イベントハンドラ」とか「コールバック関数」と呼びます。
</p>
<p> GUI アプリケーションとしての最低限の機能は Ruby/Tk が面倒を見てくれるので、私達はアプリケーション固有の処理をプログラミングするだけで済みます。
</p>

<h4>●Ruby/Tk で必要な手順</h4>
<p> Ruby/Tk で GUI アプリケーションを作る場合、次のような手順が必要になります。
</p>
<ol>
  <li>トップレベルのウィンドウ（メインウィンドウ）を作る。
  <li>ウィジェットを設定してウィンドウに配置する。
  <li>イベントループを開始してユーザーからの要求（イベント）を処理する。
</ol>
<p> このほかに、必要に応じてコールバック関数を作成します。Tcl/Tk の場合、1 と 3 の処理はプログラムする必要はありませんが、Ruby/Tk では 2 と 3 の処理を自分でプログラムする必要があります。
</p>
<p> それでは実際にプログラムを作ってみましょう。ボタンをひとつ表示します。
</p>
<pre class="list">
リスト：ボタンの表示

require 'tk'

button = TkButton.new(text: "Hello, Ruby/Tk")
button.pack

Tk.mainloop
</pre>
<p> 最初にモジュール tk をロードしてください。次に、メインウィンドウを作成しますが、Ruby/Tk では自動的に作成されるので、私たちがプログラムする必要はありません。次にボタンを作ります。Tk では GUI 用の部品のことを「ウィジェット (widget)」と呼びます。Tk にはたくさんのウィジェットが用意されていて、それをウィンドウに配置することで簡単に GUI アプリケーションを作成することができます。
</p>
<p> Ruby/Tk の場合、ウィジェットに対応するクラスが用意されていて、名前は Tk + ウィジェット になります。ボタン (Button) を作る場合、TkButton.new() でボタンのオブジェクトを生成します。引数 text: 'Hello, Ruby/Tk' は、ボタンに表示されるテキストを指定します。name: value は :name =&gt; value と同じで、Ruby ver 1.9 から導入された表記法です。
</p>
<p> この段階では、ボタンはまだ配置されていません。ボタンの配置はメソッド pack で行います。Tk の場合、ウィジェットの配置はジオメトリマネージャが行います。3 種類のマネージャがあって、pack はそのうちのひとつです。button.pack が実行されると、ウィンドウにボタンが配置されます。最後にメソッド mainloop() を呼び出して、イベントループを開始します。
</p>

<p> 簡単なプログラムですが、Ruby/Tk で GUI アプリケーションを作る場合の基本的な構造を表しています。あとは、イベントに対応するコールバック関数を作ります。この例題ではボタンを表示しただけですが、押したときの動作をプログラムすることができます。
</p>
<p><img src="ruby_img/button0.png" alt="Hello, Ruby/Tk"> Ruby/Tk のウィンドウ
</p>
<h4>●ウィジェットの種類</h4>
<p> Ruby/Tk に用意されている主なウィジェットを表に示します。
</p>
<table border=1>
<caption>表：Tk に用意されている主なウィジェット</caption>
<thead>
  <tr><th>ウィジェット名</th><th>クラス名</th><th>概要</th></tr>
</thead>
<tbody>
  <tr><td>フレーム</td><td>TkFrame</td><td>ウィジェットを格納する枠組みを作る</td></tr>
  <tr><td>ラベル</td><td>TkLabel</td><td>文字列やイメージを表示する</td></tr>
  <tr><td>メッセージ</td><td>TkMessage</td><td>複数行の文字列を表示する</td></tr>
  <tr><td>ボタン</td><td>TkButton</td><td>ボタンを作る</td></tr>
  <tr><td>ラジオボタン</td><td>TkRadiobutton</td><td>ラジオボタンを作る</td></tr>
  <tr><td>チェックボタン</td><td>TkCheckbutton</td><td>チェックボタンを作る</td></tr>
  <tr><td>リストボックス</td><td>TkListbox</td><td>リストボックスを作る</td></tr>
  <tr><td>スクロールバー</td><td>TkScrollbar</td><td>スクロールバーを作る</td></tr>
  <tr><td>スケール</td><td>TkScale</td><td>スケールを作る</td></tr>
  <tr><td>エントリー</td><td>TkEntry</td><td>1 行の文字列の入力と編集</td></tr>
  <tr><td>メニュー</td><td>TkMenu</td><td>メニューを作る</td></tr>
  <tr><td>メニューボタン</td><td>TkMenubutton</td><td>メニューボタンを作る</td></tr>
  <tr><td>ビットマップ</td><td>TkBitmap</td><td>ビットマップを作る</td></tr>
  <tr><td>キャンバス</td><td>TkCanvas</td><td>キャンバスを作る</td></tr>
  <tr><td>テキスト</td><td>TkText</td><td>テキストの入力と編集</td></tr>
  <tr><td>ラベルフレーム</td><td>TkLabelFrame</td><td>ラベル付きフレーム</td></tr>
  <tr><td>スピンボックス</td><td>TkSpinbox</td><td>スピンボックスを作る</td></tr>
  <tr><td>ペインウィンドウ</td><td>TkPanedWindow</td><td>ペインウィンドウを作る
</td></tr>
</tbody>
</table>
<p> なかにはあまり見かけないものもありますが、大部分はお馴染みのウィジェットだと思います。
</p>
<p> ウィジェットは次の形式で生成します。
</p>
<pre class="item">
widget = widgetClass.new(parent, args, ..., option: value, ...) { ... }
</pre>
<p> parent は widget を配置するウィンドウやウィジェットのオブジェクトを指定します。省略するか nil を渡すと、widget はメインウィンドウに配置されます。args はメソッド固有の引数です。ごく一部のメソッドでは、この引数が必要になることがあります。返り値は生成したウィジェットのオブジェクトです。メインウィンドウもウィジェットのひとつです。
</p>

<p> ボタンの例題のように、ウィジェットにはユーザーがデータを設定することができます。これを「オプション」または「属性」といいます。Ruby/Tk では属性と呼ぶことが多いようです。本稿では Tcl/Tk に合わせてオプションと呼ぶことにします。なお、メソッド new はブロックを受け取ることができます。その中でオプションの値を設定することもできますが、本稿では new の引数で指定することにします。
</p>
<p> 最初に、ほとんどのウィジェットで共通するオプションを説明します。
</p>
<table border=1>
<caption>表：ほとんどのウィジェットで共通のオプション</caption>
<tbody>
<tr><td>foreground (fg)   </td><td>文字や線を描くのに使用する色を指定</td></tr>
<tr><td>background (bg)   </td><td>背景色の指定</td></tr>
<tr><td>text              </td><td>ウィジェット内に表示されるテキスト</td></tr>
<tr><td>textvariable      </td><td>テキストを格納するオブジェクトを指定</td></tr>
<tr><td>image             </td><td>ウィジェット内に表示されるイメージ</td></tr>
<tr><td>bitmap            </td><td>ウィジェット内に表示されるビットマップ</td></tr>
<tr><td>borderwidth (bd) </td><td>ウィジェットの枠の幅</td></tr>
<tr><td>relief            </td><td>ウィジェットの枠のスタイル</td></tr>
<tr><td>height            </td><td>ウィジェットの高さ</td></tr>
<tr><td>width             </td><td>ウィジェットの幅</td></tr>
<tr><td>anchor            </td><td>ウィジェットや表示されるデータの位置を指定</td></tr>
</tbody>
</table>
<p> ウィジェットの幅と高さは、テキストを表示するウィジェットでは文字数、それ以外のウィジェットはピクセル単位となります。Ruby/Tk の場合、オプションは文字列またはシンボルで指定します。
</p>

<h4>●オプションの指定と参照</h4>
<p> オプションはウィジェットを生成するときに指定しますが、あとからオプションの値を変更することもできます。これにはメソッド configure() を使います。また、オプションの値を参照するにはメソッド cget() を使います。Rub/Tk の場合、オプション名と同じメソッドが定義されていて、このメソッドを使ってアクセスすることもできます。
</p>
<p> <a href="ruby.html#cite">参考 URL 2</a> によると、オプションの値を更新するには以下の方法があるそうです。
</p>
<ol>
  <li>widget.configure(option: value, ...)
  <li>widget.configure(option, value)
  <li>widget.option(value)
  <li>widget.option = value
  <li>widget[option] = value
</ol>
<p> 1, 2, 3 の返り値は widget で、4, 5 の返り値は value になります。
<p> <a href="ruby.html#cite">参考 URL 2</a> によると、オプションの値を参照するには以下の方法があるそうです。
</p>
<ol>
  <li>widget.cget(option)
  <li>widget.option
  <li>widget[option]
</ol>

<p> configure() と cget() は全てのウィジェットで共通に使用することができます。Ruby/Tk では、このようなウィジェットを操作するメソッドが多数用意されています。ちなみに、Tcl/Tk ではウィジェットを操作するメソッドのことを、「ウィジェットコマンド」と呼びます。
</p>

<h4>●ボタンとラベル</h4>
<p> 最初は簡単に扱えるボタン (Button) とラベル (Label) から始めましょう。ラベルはウィンドウに文字列を表示するウィジェットです。まず、テキストを表示するウィジェットでよく使用されるオプションを示します。
</p>
<table border=1>
<caption>表：テキスト表示のオプション</caption>
<tbody>
<tr><td>font</td><td>使用するフォント</td></tr>
<tr><td>underline</td><td>下線つき表示する文字位置</td></tr>
<tr><td>padx</td><td>水平方向の詰めもの</td></tr>
<tr><td>pady</td><td>垂直方向の詰めもの</td></tr>
</tbody>
</table>

<p> ボタンにはもうひとつ重要なオプションがあります。
</p>
<pre class="item">
command    押したときに実行する関数を指定
</pre>
<p> Ruby/Tk の場合、実行する関数を手続きオブジェクトで包んで指定することに注意してください。この手続きオブジェクトがコールバック関数になります。たとえば、command に proc { exit } を指定した場合、そのボタンを押すとアプリケーションが終了することになります。次の例を見てください。
</p>
<pre class="list">
button = TkButton.new(text: "Hello, Ruby/Tk", command: proc { exit })
</pre>
<p> このように、コールバック関数は proc { } を使って指定してください。
</p>
<h4>●ジオメトリマネージャ</h4>
<p> ボタンを作ったら、それをウィンドウに配置しないといけません。Tk ではジオメトリマネージャ (Geometry Manager) がウィジェットの配置を担当し、3 種類のマネージャが用意されています。
</p>
<ul>
  <li>Placer<br>
  メソッド place() はウィジェットを指定した座標に配置します。
  <li>Packer<br>
  メソッド pack() はウィンドウにウィジェットを詰め込みます。
ウィジェットの数や大きさによって、ウィンドウの大きさも変化します。
  <li>Gridder<br>
  メソッド grid() はウィジェットを格子状に配置します。
ウィジェットの数や大きさによって、ウィンドウの大きさも変化します。
</ul>
<p> いちばんよく使われるマネージャが Packer です。Placer はウィジェットの位置を座標で指定するため、並べて表示する場合には設定が少々面倒です。たいていの場合は Packer で用が足りるので、Placer を使う機会はあまりないでしょう。電卓やマインスイーパーのように、ボタンを格子状に配置する場合は Gridder が便利です。
</p>

<h4>●ラベルの作成</h4>
<p> それでは簡単な例題として、押したボタンの番号をラベルに表示するプログラムを作ります。最初にラベルを定義します。
</p>
<pre class="list">
リスト : ラベルの定義

# coding: utf-8
require 'tk'

# ラベルの生成
$buff = TkVariable.new('')
label = TkLabel.new(textvariable: $buff)
label.pack
</pre>

<p> Ruby/Tk の場合、オプション textvariable にはクラス TkVariable のオブジェクトを指定します。データが文字列の場合、メソッド value=() でデータをセットし、メソッド value() でデータを得ることができます。value=() で値を書き換えることで、ラベルの表示を変更することができます。
</p>
<p> TkVariable のアクセスメソッドを以下に示します。
<ul>
  <li>value, value=<br>
文字列として読み書きする
  <li>numeric, numeric=<br>
数値として読み書きする
  <li>bool, bool=<br>
真偽値として読み書きする
  <li>list, list=<br>
Tcl/Tk のリスト (Ruby では Array) として読み書きする
</ul>

<h4>●ボタンの作成</h4>
<p> 次はボタンを作ります。複数のボタンを作る場合、それに対応するコールバック関数を同じ数だけ作るのでは面倒です。そこで、コールバック関数を生成する関数をひとつだけ作成し、それにボタンの番号を渡すことにします。プログラムは次のようになります。
</p>
<pre class="list">
リスト：ボタンの定義

# コールバック関数の生成
def make_cmd(n)
  proc { $buff.value=("button #{n} pressed") }
end

# ボタンの生成
for n in 1..4
  button = TkButton.new(text: "Button #{n}", command: make_cmd(n))
  button.pack
end

Tk.mainloop()
</pre>
<p> 関数 make_cmd() でコールバック関数を生成します。make_cmd() はクロージャを返すことに注意してください。make_cmd() の引数 n にボタン番号を渡すことで、ボタン番号がクロージャに保存されます。したがって、コールバック関数を実行すると、押したボタンの番号を表示することができます。
</p>

<p>それでは実行してみてください。
</p>

<p><img src="ruby_img/button1.png" alt="ボタンの画面"> button 1 を押した動作
</p>

<p>ボタンが縦に 4 つ表示されましたね。そして、ボタンを押すといちばん上に文字列が表示されます。つまり、ボタンを押すという動作によってプログラムが実行されたわけです。
</p>

<h4>●Pack マネージャ</h4>
<p> 次は、pack() について説明しましょう。pack() はウィジェットを上から順に詰め込み、ウィンドウに配置するパッケージマネージャです。例題ではボタンの幅がウィンドウより小さいですが、これをいっぱいに広げるには fill オプションを使います。方向は 'x', 'y' で指定します。両方向に広げるには 'both' を指定します。実際に fill を 追加して確かめてください。
</p>

<p><img src="ruby_img/button2.png" alt="ボタンの画面"> fill: 'both' を指定し、button 4 を押した動作
</p>

<p> 詰め込む方向を変えるにはオプション side を使います。指定できる値は 'top', 'bottom', 'left', 'right' の 4 つです。ウィジェットによって詰め込む方向を変えてもかまいません。ボタンを配置する pack に side: 'left' を追加して実行してみましょう。一番上にラベルが配置され、その下にボタンが 4 つ左から順番に並べられます。
</p>

<p><img src="ruby_img/button3.png" alt="ボタンの画面"> side: 'left' を指定し、button 3 を押した動作
</p>

<p> このとき、ラベルはウィンドウの中央に表示されます。これを左側に寄せるには anchor オプションを設定します。指定が省略された場合は中央になります。指定方法は次の記号を使います。
</p>
<pre class="fig">
   nw --- n --- ne
   |             |
   w      c      e
   |             |
   sw --- s --- se

図：-anchor の指定方法
</pre>

<p> 記号はそれぞれ 'e' (East), 'w' (West), 's' (South), 'n' (North), 'c' (Center) を表します。ラベルを pack するときに、オプション anchor: 'w' を指定すると左寄せに表示します。
</p>

<p><img src="ruby_img/button4.png" alt="ボタンの画面"> anchor: 'w' を指定し、button 1 を押した動作
</p>

<p>このほかにも、 pack() にはいろいろなオプションが用意されています。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap03">色とスケール</h3>
<h4>●色の指定</h4>
<p> 今回はテキストやボタンに色をつけてみましょう。Tk の場合、色の指定は名前または数値で行います。名前は red, green, blue のように指定します。色の名前は大文字小文字の区別をしません。red と RED は同じ色を表します。数値の場合は、赤、緑、青の三原色を 16 進数で指定します。指定方法には、次の 4 通りの形式があります。
</p>
<ol>
  <li>#RGB
  <li>#RRGGBB
  <li>#RRRGGGBBB
  <li>#RRRRGGGGBBBB
</ol>
<p> 色の指定は # から始まり、R, G, B はそれぞれ赤、緑、青の強度を表す数値です。それぞれの色を表す桁数は同じでなければいけません。1. では、R, G, B が 16 段階なので 4096 色の指定ができます。2. は 256 段階なので、約 1600 万色の指定ができます。3. 4. はほとんど使われることはないでしょう。実際の表示は使用しているハードウェアの環境に依存します。
</p>
<h4>●scaleウィジェット(スライダ)</h4>
<p> それでは、R, G, B の値で色がどのように変化するか、サンプルプログラムを作って確かめてみましょう。数値の入力はキーボードから行ってもいいのですが、ここではスケール (scale) というウィジェットを使いましょう。スケールは整数値を表示し、スライダをドラッグするかスケールをクリックすることで、その値を更新することができます。スケールで使用する主なオプションを表に示します。
</p>
<table border=1>
<caption>表：TkScale の主なオプション</caption>
<tbody>
<tr><td>label</td><td>スケールのラベル</td></tr>
<tr><td>from</td><td>スケールの最小値</td></tr>
<tr><td>to</td><td>スケールの最大値</td></tr>
<tr><td>orient</td><td>スケールの方向</td></tr>
<tr><td>showvalue</td><td>値を表示するか</td></tr>
<tr><td>variable</td><td>スケールの値を格納するオブジェクトを指定</td></tr>
<tr><td>command</td><td>値が変化したときに実行するコマンド</td></tr>
<tr><td>resolution</td><td>解像度</td></tr>
</tbody>
</table>

<p> label はスケールの隣に表示する文字列を指定し、form と to で値の範囲を指定します。orient はスケールの方向を指定するもので、orizontal または h を指定すると水平になり、vertical または v で垂直になります。デフォルトでは垂直に設定されます。
</p>
<p> showvalue は現在の値を表示するかを設定します。variable はスケールの値を格納する変数を指定しますが、Ruby/Tk の場合はクラス TkVariable のオブジェクトを指定します。
</p>
<p> command は、スケールの値が変更されたときに実行する関数を指定します。このとき、スケールの値が引数として関数に渡されます。たとえば、関数 foo() を指定した場合、呼び出されるときは foo(128) となります。このほかにも、ウィジェットの大きさを設定するオプションがあります。
</p>
<p> スケールには configure() や cget() のほかに、次に示すメソッドが用意されています。
</p>
<ul>
  <li>coords(value)<br>
      指定した値 (value) に対応するグライダの座標をタプル (x, y) で返す。
  <li>get(x, y)<br>
      指定した座標に対応するスケールの値を返す。座標を省略した場合は現在値を返す。
  <li>set(value)<br>
      スケールの値を value に変更する。
  <li>identify(x, y)<br>
      指定した座標にスライダがあれば文字列 slider を返す。
スライダより上（左）にあれば trough1 を返し、下（右）にあれば trough2 を返す。
</ul>
<p> get() と set() 以外のメソッドは使う機会はあまりないでしょう。
</p>
<h4>●スケールの使用例</h4>
<p> それでは、ボタンの背景色を変化させるプログラムを作ります。
</p>
<pre class="list">
リスト：スケールの使用例

# coding: utf-8
require 'tk'

# スケールの値を格納する
$red = TkVariable.new(0)
$blue = TkVariable.new(0)
$green = TkVariable.new(0)

# ボタン
$button = TkButton.new(text: 'button', bg: '#000')
$button.pack(fill: 'both');

# ボタンの背景色を変更
def change_color(n)
  color = sprintf("#%02x%02x%02x", $red.numeric, $green.numeric, $blue.numeric)
  $button.configure(bg: color)
end

# スケール
s1 = TkScale.new(label: 'red', orient: 'h', from: 0, to: 255,
                 variable: $red, command: proc {|n| change_color(n)})

s2 = TkScale.new(label: 'blue', orient: 'h', from: 0, to: 255,
                 variable: $blue, command: proc {|n| change_color(n)})

s3 = TkScale.new(label: 'green', orient: 'h', from: 0, to: 255,
                 variable: $green, command: proc {|n| change_color(n)})

# ウィジェットの配置
s1.pack(fill: 'both')
s2.pack(fill: 'both')
s3.pack(fill: 'both')

# メインループ
Tk.mainloop()
</pre>
<p> スケールの値を格納する TkVariable のオブジェクトは、それぞれ $red, $blue, $green というグローバル変数にセットします。値は 0 に初期化しておきます。ボタンのオブジェクトは背景色を変更するときに必要になるので、グローバル変数 $button に格納しておきます。値が変化したときに実行する関数が change_color() です。
</p>

<p> 関数 sprintf を使って $red, $green, $blue の値をカラーコードに変換します。数値を 2 桁にそろえるため書式は %02x としています。その後、ボタンの背景色を configure メソッドで変更します。これで、スライダの動きによってボタンの色を変化させることができます。
</p>
<p><img src="ruby_img/color.png" alt="スライダの画面"> スライダで RGB を指定する
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap04">フォントの指定</h3>
<h4>●フォントの形式</h4>
<p> 今度は色だけではなくフォントも変更してみましょう。テキストを表示するウィジェットは、オプション font で使用するフォントを指定することができます。フォントの指定にはいくつかの方法があるのですが、ここでは Tcl/Tk と同様に文字列で行うことにします。
</p>
<pre class="item">
'family size style1 style2'
</pre>
<p> family はフォント名を表します。今あなたが使っているパソコンで使用できるフォント名は、メソッド TkFont.families で求めることができます。size はフォントの大きさを表し数値で指定します。style1 と style2 はフォントのスタイルで、次の中から選びます。
</p>
<pre class="item">
style1 : normal, bold, roman, italic
style2 : underline, overstrike
</pre>
<p> style1 と style2 は省略することができます。それでは、フォントを変更してみましょう。次のプログラムを見てください。
</p>

<pre class="list">
リスト：フォントの変更

# coding: utf-8
require 'tk'

str = 'Hello, world, こんにちは世界'
TkLabel.new(text: str, font: 'Takaoゴシック 12').pack
TkLabel.new(text: str, font: 'Takao明朝 12 italic').pack
TkLabel.new(text: str, font: 'Takaoゴシック 16 underline').pack

Tk.mainloop()
</pre>
<p> オプション font にフォントを表す文字列を指定するだけです。Ruby/Tk の場合、フォントの操作にはクラス TkFont を使うこともできます。フォントを変更するときは、new () でオブジェクトを生成して、ウィジェットのオプション font にセットします。次の例を見てください。
</p>
<pre class="list">
リスト：フォントの変更 (2)

# coding: utf-8
require 'tk'

str = 'Hello, world, こんにちは世界'

font1 = TkFont.new('Takaoゴシック 12')
font2 = TkFont.new('Takao明朝 12 italic')
font3 = TkFont.new('Takaoゴシック 16 underline')

TkLabel.new(text: str, font: font1).pack
TkLabel.new(text: str, font: font2).pack
TkLabel.new(text: str, font: font3).pack

Tk.mainloop()
</pre>
<p> TkFont.new() でフォントオブジェクトを生成して、それをウィジェットのオプション font にセットするだけです。それでは実行してみましょう。
</p>

<p> <img src="ruby_img/font1.png" alt="フォントの画面"> フォントをいろいろ変えてみる
</p>
<h4>●オプションの設定</h4>
<p> このように、個々のウィジェットのフォントはオプション font で変更できますが、すべてのラベルウィジェットで使用する共通のフォントを設定したい場合もあるでしょう。Tk は各オプションのデフォルト値を持っています。このため、ユーザーは必要なオプションを指定するだけで、簡単にプログラミングすることができます。このデフォルト値はクラス TkOptionDB のメソッド add() を使って変更することができます。
</p>
<p> たとえば、アプリケーションで使用するフォントを変更する場合は、次のように行います。
</p>
<pre class="list">
リスト : デフォルト値の設定

TkOptionDB.add('*font', 'Takaoゴシック 14')
</pre>
<p> これで、テキストを表示するウィジェットは、指定したフォントを使って表示されます。第 1 引数はデフォルト値を設定するウィジェットを表すパターンです。第 2 引数が設定する値です。第 3 引数は省略していますが、優先順位 (priority) を設定することができます。
</p>
<p> パターンは、アプリケーション名、ウィジェット名、オプション名をドットで区切って表しますが、ワイルドカード * を指定することもできます。*font の場合は、アプリケーションで使用するフォントを指定することになります。ラベルに対してフォントを設定したい場合は *Label.font となります。Ruby/Tk の場合、クラス名 TkLabel を渡しても動作しないようです。ご注意ください。
</p>
<p>  たとえば、前回作成したボタンを表示するプログラムに次の 2 行を加えてください。 
</p>
<pre class="item">
TkOptionDB.add('*Button.font', 'Takaoゴシック 14')
TkOptionDB.add('*Button.background', 'green')
</pre>
<p> これで、表示されるボタンのフォントと背景色は、設定された値となります。
</p>
<p> <img src="ruby_img/font2.png" ALT="フォントの画面"> ボタンのフォントと背景色を変更
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="ruby.html#ruby_tk">Ruby</a> | <a href="rubytk02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>