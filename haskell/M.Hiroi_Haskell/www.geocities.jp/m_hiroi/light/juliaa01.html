<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Julia プログラミング超入門</title>
  <meta name="description" content="Julia 入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881802</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Julia Language Programming</h1>
<h2>お気楽 Julia プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
<hr>
</div>
<section class="contents">
<h3>Julia の基礎知識</h3>
<h4 id="abc01">●Julia のデータ型</h4>
<p> Julia のデータ型は階層構造 (木構造) になっていて、ルートのデータ型が Any になります。型の名前は先頭が英大文字になります。すべての型は Any を継承していると考えてください。
</p>
<p> 型は抽象型と具象型の二種類があり、実際のデータ (値) に対応するのが具象型で、抽象型は値を生成することはできません。木構造でいえば、「葉」に相当する型が具象型、それ以外の「節」に相当する型が抽象型となります。抽象型を継承して新しい型を作ることはできますが、逆に具象型を継承して新しい型を作ることはできません。
</p>
<p> 値の型は関数 typeof() や isa() で、上位の型は関数 supertype() で、下位の型 (サブタイプ) は関数 subtypes() で調べることができます。また、Type1 &lt;: Type2 で Type1 が Type2 のサブタイプか調べることもできます。
</p>
<pre>
julia&gt; typeof(12345)
Int64

julia&gt; typeof(1.2345)
Float64

julia&gt; isa(1, Int64)
true

julia&gt; isa(1, Float64)
false

julia&gt; subtypes(Number)
2-element Array{Any,1}:
 Complex
 Real

julia&gt; subtypes(Real)
4-element Array{Any,1}:
 AbstractFloat
 AbstractIrrational
 Integer
 Rational

julia&gt; supertype(Int64)
Signed

julia&gt; supertype(Signed)
Integer

julia&gt; Int64 <: Number
true

julia&gt; Int64 <: Any
true
</pre>
<h4 id="abc02">●基本的なデータ型</h4>
<ul>
  <li>整数
    <ul>
      <li>Int8, Int16, Int32, Int64, Int128 (数字はビット数)
      <li>UInt8, UInt16, UInt32, UInt64, UInt128 (無符号整数)
      <li>Int (Int32 または Int64, 処理系依存)
      <li>UInt (UInt32 または UInt64, 処理系依存)
      <li>BigInt (多倍長整数)
      <li>数字の先頭に 0b, 0o, 0x を付けると 2 進数, 8 進数, 16 進数になり、無符号整数として扱われる
    </ul>
  <li>浮動小数点数
    <ul>
      <li>Float16 (半精度)
      <li>Float32 (単精度)
      <li>Float64 (倍精度)
      <li>BigFloat (任意精度, デフォルトは 256 ビット)
    </ul>
  <li>複素数, X + Yim 
    <ul>
      <li>Complex{T} (実数部 X と虚数部 Y が T 型の数)
      <li>Complex32 (実数部 X と虚数部 Y が Float32)
      <li>Complex64 (実数部 X と虚数部 Y が Float64)
    </ul>
  <li>有理数 (分数), P // Q
    <ul>
      <li>Rational{T} (分子 P と分母 Q が T 型 の整数)
    </ul>
  <li>真偽値 Bool (true, false)
  <li>文字 Char, ' で囲む ('a', 'A' など)
  <li>文字列 String, " で囲む
    <ul>
      <li>""" で囲むとヒアドキュメント
      <li>\n (改行) や \t (タブ) といったエスケープシーケンスを含めることができる
      <li>演算子 * で文字列を連結できる
      <li>変数展開 $var, 変数 var の値に置き換える
      <li>式展開 $(expr), 式 expr を計算した値に置き換える
      <li>文字列の前に r を付けると、エスケープシーケンスや変数 (式) 展開が無効になる
      <li>length(str), 文字数を返す
      <li>"" は空文字列
      <li>isempty("") は true を返す
    </ul>
</ul>
<pre>
julia&gt; 12345
12345

julia&gt; typeof(12345)
Int64

julia&gt; 1.2345
1.2345

julia&gt; typeof(1.2345)
Float64

julia&gt; 1//2
1//2

julia&gt; typeof(1//2)
Rational{Int64}

julia&gt; 1 + 2im
1 + 2im

julia&gt; typeof(1 + 2im)
Complex{Int64}

julia&gt; true
true

julia&gt; typeof(true)
Bool

julia&gt; 'a'
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; typeof('a')
Char

julia&gt; "hello, julia!"
"hello, julia!"

julia&gt; typeof("hello, julia!")
String

julia&gt; "abc" * "def"
"abcdef"

julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"

julia&gt; r"1 + 2 = $(1 + 2)"
r"1 + 2 = $(1 + 2)"

julia&gt; isempty("")
true

julia&gt; isempty("oops!")
false
</pre>

<h4 id="abc03">●基本的な演算子</h4>
<ul>
  <li>算術演算子 (+, -, *, /, %, div(), \, ^)
  <li>除算 / の結果は浮動小数点数、div() の結果は整数
  <li>x \ y は y / x, x ^ y は x の y 乗 (べき乗)
  <li>2 * x や 2 * (x + 1) は 2x や 2(x + 1) のように * を省略できる
  <li>比較演算子 (==, !=, ===, !==, &lt;, &gt;, &lt;=, &gt;=)
  <ul>
    <li>比較演算子は a &lt; b &lt; c のようにつなげて使うことができる
    <li>=== と !== はオブジェクトのアドレスを比較する (Python の is, Lisp の関数 eq みたいなもの)
    <li>同じ値のオブジェクトでも === で比較すると false を返す場合がある
    <li>シングルトンオブジェクトであれば必ず true を返す
  </ul>
  <li>論理演算子 (!, &amp;&amp;, ||)
  <li>ビット演算子 (~, &amp;, |, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;)
  <li>&gt;&gt;&gt; は論理右シフト, &gt;&gt; は算術右シフト
  <li>排他的論理和は関数 xor() を使う
  <li>代入演算子 (=, +=, *=, -=, /=, %=, \=, ^=, &amp;=, |=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=)
  <li>Julia の場合、変数の宣言は不要、必要なときに値を代入すればよい
  <li>変数の型は 名前 :: データ型 で指定する (省略すると Any になる)
  <li>トップレベルで使用される変数は大域変数になる
</ul>
<pre>
julia&gt; 1 + 2
3

julia&gt; 1 - 2
-1

julia&gt; 2 * 3
6

julia&gt; 4 / 2
2.0

julia&gt; div(4, 2)
2

julia&gt; 5 / 2
2.5

julia&gt; div(5, 2)
2

julia&gt; 5 \ 2
0.4

julia&gt; 2 ^ 8
256

julia&gt; 1 &lt; 2
true

julia&gt; 1 &gt; 2
false

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 &lt; 2 &lt; 3
true

julia&gt; 1 &lt; 2 &gt; 3
false

julia&gt; !true
false

julia&gt; true &amp;&amp; true
true

julia&gt; true &amp;&amp; false
false

julia&gt; true || false
true

julia&gt; 0b0101 & 0b0011
0x01

julia&gt; 0b0101 | 0b0011
0x07

julia&gt; xor(0b0101, 0b0011)
0x06

julia&gt; 1 &lt;&lt; 8
256

julia&gt; 256 &gt;&gt; 8
1

julia&gt; a = 10
10

julia&gt; a += 10
20

julia&gt; a
20

julia&gt; a -= 1
19

julia&gt; a
19

julia&gt; a &lt;&lt;= 1
38

julia&gt; a
38
</pre>
<h4 id="abc04">●基本的なデータ構造</h4>
<ul>
  <li>配列
    <ul>
      <li>データ型は Array{T, n}, T は要素のデータ型, n は次元数
      <li>汎用のコンストラクタは Array{T, n}(undef , x1, x2, ..., xn)
      <ul>
        <li>第 1 引数は UndefInitializer 型のオブジェクトを渡す
        <li>undef は UndefInitializer のシングルトンオブジェクト
        <li>要素は初期化されない
        <li>xi は各次元の大きさ
        <li>次元数 n は省略してもよい
      </ul>
      <li>1 次元配列は [item1, item2, ..., itemN] でも生成できる
      <li>[] は空の配列
      <li>要素の区切りはセミコロン ( ; ) でもよい
      <li>要素のデータ型は角カッコの前で指定できる, Int128[ ... ] など
      <li>要素のアクセスは角カッコ [ ] を使う
      <li>添字は 1 から始まる、末尾の要素は end で指定できる
      <li>2 次元配列は [x11 x12 x13; x21 x22 x23; x31 x32 x33] のように、要素を空白で、行をセミコロン ( ; ) で区切る
      <li>添字は [x, y] のようにカンマで区切って指定する
      <li>x in xs で配列 xs の中に x が含まれているか検索できる
      <li>[[x11, x12, x13], [x21, x22, x23], [x31, x32, x33]] は 1 次元配列を格納した 1 次元配列になる
      <li>この場合は 2 つの角カッコ [][] を使って要素にアクセスする
      <li>主要な関数
      <ul>
        <li>zeros(T, n1, ...), 要素が 0 の配列を生成する, T を省略すると 0.0 (Float64)
        <li>ones(T, n1, ...), 要素が 1 の配列を生成する, T を省略すると 1.0 (Float64)
        <li>falses(n1, ...), 要素が false のビット配列 (BitArray) を生成する
        <li>trues(n1, ...), 要素が true のビット配列を生成する
        <li>length(a), 配列 a の要素数を求める
        <li>sum(a), 配列 a の総和を求める
        <li>isempty(a), 配列 a が空であれば true を返す
      </ul>
      <li>1 次元配列の操作
      <ul>
        <li>first(a), 配列 a の先頭要素を返す
        <li>last(a), 配列 a の末尾要素を返す
        <li>push!(a, x), 配列 a の末尾に x を追加する
        <li>pop!(a), 配列 a の末尾から要素を取り除いて返す
        <li>pushfirst!(a, x), 配列 a の先頭に x を追加する
        <li>popfirst!(a), 配列 a の先頭から要素を取り除いて返す
        <li>insert!(a, i, x), 配列 a の i 番目に x を挿入する
      </ul>
      <li>Julia の場合、データ構造を破壊的に修正する関数には名前の後ろに ! を付ける習慣がある
      <li>これは Scheme と同じ
    </ul>
</ul>
<pre>
julia&gt; a = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; a[1]
1

julia&gt; a[5]
5

julia&gt; a[1] = 10
10

julia&gt; a
5-element Array{Int64,1}:
 10
  2
  3
  4
  5

julia&gt; []
0-element Array{Any,1}

julia&gt; Int[]
0-element Array{Int64,1}

julia&gt; isempty([1, 2, 3])
false

julia&gt; isempty(Int[])
true

julia&gt; b = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; b[1, 1]
1

julia&gt; b[2, 1]
4

julia&gt; b[3, 3]
9

julia&gt; b[2, 2] *= 10
50

julia&gt; b
3×3 Array{Int64,2}:
 1   2  3
 4  50  6
 7   8  9

julia&gt; 1 in b
true

julia&gt; 10 in b
false

julia&gt; c = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]
3-element Array{Array{Int64,1},1}:
 [1, 2]
 [3, 4, 5]
 [6, 7, 8, 9]

julia&gt; c[1][1]
1

julia&gt; c[3][4]
9
</pre>
<ul>
  <li>タプル
    <ul>
      <li>データ型は Tuple{T, U, V, ...}, T, U, V, ... は要素のデータ型
      <li>タプルは immutable なデータ構造
      <li>タプルは丸カッコ (item1, item2, ...) で生成する (丸カッコは省略可)
      <li>() は空のタプル
      <li>isempty(tup), tup が空ならば true を返す
      <li>length(tup), 要素数を返す
      <li>要素のアクセスは角カッコ [ ] を使う
      <li>変数の多重代入や関数で多値を返すときにも使える
    </ul>
</ul>
<pre>
julia&gt; ()
()

julia&gt; typeof(())
Tuple{}

julia&gt; isempty(())
true

julia&gt; isempty((1, 2, 3))
false

julia&gt; (1,)
(1,)

julia&gt; typeof((1,))
Tuple{Int64}

julia&gt; a = (1, 2, 3)
(1, 2, 3)

julia&gt; a[1]
1

julia&gt; a[2]
2
</pre>
<ul>
  <li>辞書
    <ul>
      <li>データ型は Dict{K, V}, K はキーのデータ型、V は値のデータ型
      <li>辞書は Dict{K, V}(k1=&gt;v1, k2=&gt;v2, ...) で生成する (型指定は省略可)
      <li>key =&gt; val は Pair(key, val) を生成する
      <li>Dict{K, V}() は空の辞書を生成する
      <li>要素のアクセスは角カッコ [ ] を使う
      <li>キーの有無は haskey(dic, key) で判定する
      <li>delete!(dic, key), 辞書 dic からキー key とその値を削除する
      <li>keys(dic), KeySet (キーを格納した集合) を返す
      <li>values(dic), 値のイテレータ (ValueIterator) を返す
      <li>isempty(dic), dic が空であれば true を返す
      <li>length(dic), 要素数を返す
    </ul>
</ul>
<pre>
julia&gt; d = Dict("foo"=&gt;100, "bar"=&gt;200, "baz"=&gt;300)
Dict{String,Int64} with 3 entries:
  "bar" =&gt; 200
  "baz" =&gt; 300
  "foo" =&gt; 100

julia&gt; typeof(d)
Dict{String,Int64}

julia&gt; d["foo"]
100

julia&gt; d["foo"] = 1000
1000

julia&gt; d
Dict{String,Int64} with 3 entries:
  "bar" =&gt; 200
  "baz" =&gt; 300
  "foo" =&gt; 1000

julia&gt; d["oops"] = 2000
2000

julia&gt; d
Dict{String,Int64} with 4 entries:
  "bar"  =&gt; 200
  "baz"  =&gt; 300
  "oops" =&gt; 2000
  "foo"  =&gt; 1000

julia&gt; haskey(d, "foo")
true

julia&gt; haskey(d, "Foo")
false

julia&gt; keys(d)
Base.KeySet for a Dict{String,Int64} with 4 entries. Keys:
  "bar"
  "baz"
  "oops"
  "foo"

julia&gt; values(d)
Base.ValueIterator for a Dict{String,Int64} with 4 entries. Values:
  200
  300
  2000
  1000

julia&gt; isempty(d)
false

julia&gt; for k = keys(d)
       delete!(d, k)
       end

julia&gt; isempty(d)
true
</pre>
<ul>
  <li>集合
    <ul>
      <li>データ型は Set{T}, T は要素のデータ型
      <li>Set{T}([item1, item2, ..., itemN]) で生成する, {T} は省略可
      <li>Set{T}() は空の集合を生成する
      <li>isempty(set), set が空であれば true を返す
      <li>length(set), 要素数を返す
      <li>x in xs で集合 xs に x があるかチェックできる
      <li>和集合 union(), 積集合 intersect(), 差集合 setdiff()
    </ul>
</ul>
<pre>
julia&gt; a = Set([1, 2, 3, 4])
Set([4, 2, 3, 1])

julia&gt; typeof(a)
Set{Int64}

julia&gt; 1 in a
true

julia&gt; 10 in a
false

julia&gt; isempty(a)
false

julia&gt; length(a)
4

julia&gt; isempty(Set())
true

julia&gt; length(Set())
0

julia&gt; b = Set([3, 4, 5, 6])
Set([4, 3, 5, 6])

julia&gt; union(a, b)
Set([4, 2, 3, 5, 6, 1])

julia&gt; intersect(a, b)
Set([4, 3])

julia&gt; setdiff(a, b)
Set([2, 1])

julia&gt; setdiff(b, a)
Set([5, 6])
</pre>
<h4 id="abc05">●範囲オブジェクト (range object)</h4>
<ul>
  <li>start : stop で start から 1 刻みで stop までの列を表す
  <li>start : step : stop で start から step 刻みで stop までの列を表す
  <li>配列に格納する場合は collect() を使う, collect(1:3) =&gt; [1, 2, 3]
  <li>配列の部分列を指定するときにも使える
</ul>
<pre>
julia&gt; 1 : 10
1:10

julia&gt; typeof(1 : 10)
UnitRange{Int64}

julia&gt; 1 : 2 : 10
1:2:9

julia&gt; typeof(1 : 2 : 10)
StepRange{Int64,Int64}

julia&gt; collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; collect(1:2:5)
3-element Array{Int64,1}:
 1
 3
 5
</pre>
<h4 id="abc06">●制御構造</h4>
<ul>
  <li>コメントは # から改行まで
  <li>#= と =# に囲まれた範囲もコメントになる (入れ子にしてもよい)
  <li>if test1 ... elseif test2 ... else ... end
  <li>三項演算子 ?, :
  <li>while test ... end
  <li>for 変数 = range_or_collection ... end
  <ul>
    <li>= のかわりに in や ∈ を使用できる
    <li>for (変数, ...) = collection ... end  (変数を複数定義するときはカッコが必要)
    <li>for var1 = range_or_collection1, ..., varN = range_or_collectionN ... end で N 重のループになる
  </ul>
  <li>繰り返しの制御に break と continue が使える
  <li>begin ... end または (...; ...; ...), 最後に評価した式の値を返す
  <li>1 行に書くときは式をセミコロン ( ; ) で区切る
  <li>内包表記
    <ul>
      <li>[x * x for x = [1, 2, 3]] =&gt; [2, 6, 9]
      <li>[x for x = 1 : 10 if x % 2 == 0] =&gt: [2, 4, 6, 8, 10]
    </ul>
</ul>
<pre>
julia&gt; if true 1 else 0 end
1

julia&gt; if false 1 else 0 end
0

julia&gt; a = true ? 1 : 0
1

julia&gt; a
1

julia&gt; a = false ? 1 : 0
0

julia&gt; a
0
julia&gt; for i = 1:10 println("hello, Julia") end
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia

julia&gt; for i = 1:3, j = 4:6 println("$i, $j") end
1, 4
1, 5
1, 6
2, 4
2, 5
2, 6
3, 4
3, 5
3, 6

julia&gt; i = 0
0

julia&gt; while i &lt; 10
       println("hello, Julia")
       global i += 1            # global 宣言は <a href="juliaa01.html#abc08">変数</a> を参照
       end
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia
hello, Julia

julia&gt; [x * x for x = 1:5]
5-element Array{Int64,1}:
  1
  4
  9
 16
 25

julia&gt; [x for x = 1:10 if x % 2 == 0]
5-element Array{Int64,1}:
  2
  4
  6
  8
 10
</pre>
<ul>
  <li>print() でデータを表示、println() は改行する
</ul>
<h4 id="abc07">●関数</h4>
<ul>
  <li>関数のデータ型は Function
  <li>関数定義は function 関数名(仮引数::データ型, ...) ... end
  <li>関数名(仮引数::データ型, ...) = 式 でも定義できる
  <li>局所関数も定義できる
  <li>引数のデータ型は省略可 (Any になる)
  <li>関数は最後に評価した式の値を返す (return で返すこともできる)
  <li>関数呼び出しは 関数名(実引数, ...)
  <li>foo(引数, ..., 引数 = 値, ...) オプショナル引数
  <li>foo(引数, ...; 名前 = 値, ...) セミコロン以降はキーワード引数
  <li>foo(引数, ..., 引数...) 引数... は可変長引数 (タプルに格納されて引数にセット)
  <li>タプル tup や配列の要素を関数 foo() の引数に渡すときは foo(tup...) とする
  <li>Julia の関数は first class object
  <li>高階関数は map, filter, reduce など多数用意されている
  <li>func(...) do 引数 ... end, do block (Ruby のブロックと同じ)
  <li>無名関数は function(仮引数, ...) ... end または (仮引数, ...) -&gt; 式
  <li>もちろんクロージャもサポートされている
  <li>末尾再帰最適化はサポートされていない
  <li>julia の関数は総称関数 (generic function) で、引数の個数が異なるか引数のデータ型が異なれば多重定義できる
  <li>呼び出される関数は引数の個数および個々のデータ型により選択される (多重ディスパッチ)
</ul>
<pre>
julia&gt; foo(x) = x^2
foo (generic function with 1 method)

julia&gt; foo(x, y) = x^2 + y^2
foo (generic function with 2 methods)

julia&gt; foo(x, y, z) = x^2 + y^2 + z^2
foo (generic function with 3 methods)

julia&gt; foo(3)
9

julia&gt; foo(3, 4)
25

julia&gt; foo(3, 4, 5)
50

julia&gt; bar(x::Int) = println("bar:Int")
bar (generic function with 1 method)

julia&gt; bar(x::Float64) = println("bar:Float64")
bar (generic function with 2 methods)

julia&gt; bar(1)
bar:Int

julia&gt; bar(1.2345)
bar:Float64

julia&gt; baz(x::Int, y::Int) = println("baz, Int, Int")
baz (generic function with 1 method)

julia&gt; baz(x::Int, y::Float64) = println("baz, Int, Float")
baz (generic function with 2 methods)

julia&gt; baz(x::Float64, y::Float64) = println("baz, Float, Float")
baz (generic function with 3 methods)]

julia&gt; baz(1, 2)
baz, Int, Int

julia&gt; baz(1, 0.1)
baz, Int, Float

julia&gt; baz(1.1, 1.2)
baz, Float, Float

julia&gt; baz(1.1, 2)
ERROR: MethodError: no method matching baz(::Float64, ::Int64)
Closest candidates are:
  baz(::Float64, ::Float64) at REPL[186]:1
  baz(::Int64, ::Int64) at REPL[184]:1

julia&gt; map(x -&gt; x * x, [1, 2, 3, 4, 5])
5-element Array{Int64,1}:
  1
  4
  9
 16
 25

julia&gt; map([1, 2, 3, 4, 5]) do x x * x end
5-element Array{Int64,1}:
  1
  4
  9
 16
 25

julia&gt; function adder(n) x -&gt; n + x end
adder (generic function with 1 method)

julia&gt; add10 = adder(10)
#23 (generic function with 1 method)

julia&gt; add10(100)
110

julia&gt; add100 = adder(100)
#23 (generic function with 1 method)

julia&gt; add100(100)
200
</pre>

<h4 id="abc08">●変数と有効範囲</h4>
<ul>
  <li>変数の宣言は不要、必要なときに値を代入すればよい
  <li>関数の引数や関数の中で値を代入した変数は「局所変数 (local variable)」になる
  <li>関数の引数やその中の局所変数の有効範囲 (スコープ, scope) は関数の終わり (end) まで
  <li>変数の型は 名前 :: データ型 で指定する (省略可 Any になる)
  <li>トップレベルで値を代入された変数は「大域変数 (global variable)」になる
  <li>変数を参照するときは局所変数から探索する
  <li>見つからない場合は大域変数を参照する (それでも見つからない場合はエラー)
</ul>
<pre class="list">
リスト : 大域変数と局所変数 (test01.jl)

function foo(n)
    x = 0           # n, x は局所変数
    while x &lt; n
        x += 1
        println(x)
    end
    println(x)
    println(y)      # y は大域変数を参照する
    # println(z)      z は定義されていないのでエラーになる
end

x = 100  # x, y は大域変数
y = 200

foo(5)
</pre>
<pre>
$ julia test01.jl
1
2
3
4
5
5
200
</pre>

<ul>
  <li>for で宣言した変数は新しい局所変数になる
  <li>同名の局所変数は隠蔽される
  <li>このときの局所変数の有効範囲は for の終わり (end) まで
  <li>このあと説明する let ... end と同じ
  <li>for や while ループの中だけで使用される局所変数の有効範囲もループの終わりまでになる
</ul>
<pre class="list">
リスト : for 文と変数の有効範囲 (test02.jl)

function foo(n)
    x = 0             # x は局所変数 (x_1 とする)
    for x = 0 : n - 1 # 新しい局所変数 x (x_2 とする)
        x += 1
        println(x)
        z = x * 2     # 新しい局所変数 z
        println(z)
    end               # x_2 と z の有効範囲はここまで
    println(x)        # x_1 を参照する
    println(y)        # y は大域変数を参照する
    # println(z)        z は定義されていないのでエラーになる
end

x = 100  # x, y は大域変数
y = 200

foo(5)
</pre>
<pre>
$ julia test02.jl
1
2
2
4
3
6
4
8
5
10
0
200
</pre>
<ul>
  <li>局所変数は local で、大域変数は global で宣言できる
  <li>関数やループの中で大域変数を書き換えたい場合は global 宣言が必要になる
  <li>for 文の変数で、外側の局所変数を使用したい場合は outer を付ける
</ul>
<pre>
julia&gt; x = 0
0

julia&gt; while x &lt; 5; println("hello, world"); global x += 1 end
hello, world
hello, world
hello, world
hello, world
hello, world

julia&gt; x
5

julia&gt; (local x; for outer x = 1:10 println(x) end; println(x))
1
2
3
4
5
6
7
8
9
10
10

julia&gt; x
5
</pre>
<ul>
  <li>局所変数は let ... end でも定義できる
  <li>このときの局所変数の有効範囲は end まで
</ul>
<pre>
julia&gt; x, y = 1, 2            # 大域変数
(1,2)

julia&gt; let x = 10, y = 20     # (A)
       let x = 100, y = 200   # (B)
       println(x, y)          # (B) の x, y を表示
       end                    # (B) で定義した変数の有効範囲はここまで
       println(x, y)          # (A) の x, y を表示
       end                    # (A) で定義した変数の有効範囲はここまで
100200
1020

julia&gt; println(x ,y)          # 大域変数を表示
12
</pre>
<hr>
<h3 id="chap">簡単なプログラム</h3>
<h4 id="chap01">●FizzBuzz</h4>
<pre class="list">
リスト : FizzBuzz 問題

function fizzbuzz()
    for x = 1 : 100
        if x % 15 == 0
            print("FizzBuzz")
        elseif x % 3 == 0
            print("Fizz")
        elseif x % 5 == 0
            print("Buzz")
        else
            print(x)
        end
        print(" ")
    end
end

fizzbuzz()
</pre>
<pre>
C&gt;julia fizzbuzz.jl
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 
22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz
 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 
FizzBuzz 61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 
Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz
 97 98 Fizz Buzz
</pre>
<h4 id="chap02">●数値積分</h4>
<pre class="list">
リスト : 中点則で円周率を求める

function midpoint(n)
    w = 1.0 / n
    s = 0.0
    for i = 1 : n
        x = (i - 0.5) * w;
        s += 4.0 / (1.0 + x * x);
    end
    s * w
end

print(midpoint(10000))
</pre>
<ul>
  <li>0 - 9 の数字は整数 (Int32 または Int64) に、小数点数は指数付きの数字は浮動小数点数 (Float64) になる
  <li>他のデータ型に変換するには データ型(値) とする (BigInt(123) など)
</ul>
<pre>
C&gt;julia midpoint.jl
3.141592654423134
</pre>
<h4 id="chap03">●平均値と標準偏差</h4>
<pre class="list">
リスト : 平均値と標準偏差

# 乱数で生成した身長のデータ
# データ型は Array{Float64, 1} になる
height = [
    148.7, 149.5, 133.7, 157.9, 154.2, 147.8, 154.6, 159.1, 148.2, 153.1,
    138.2, 138.7, 143.5, 153.2, 150.2, 157.3, 145.1, 157.2, 152.3, 148.3,
    152.0, 146.0, 151.5, 139.4, 158.8, 147.6, 144.0, 145.8, 155.4, 155.5,
    153.6, 138.5, 147.1, 149.6, 160.9, 148.9, 157.5, 155.1, 138.9, 153.0,
    153.9, 150.9, 144.4, 160.3, 153.4, 163.0, 150.9, 153.3, 146.6, 153.3,
    152.3, 153.3, 142.8, 149.0, 149.4, 156.5, 141.7, 146.2, 151.0, 156.5,
    150.8, 141.0, 149.0, 163.2, 144.1, 147.1, 167.9, 155.3, 142.9, 148.7,
    164.8, 154.1, 150.4, 154.2, 161.4, 155.0, 146.8, 154.2, 152.7, 149.7,
    151.5, 154.5, 156.8, 150.3, 143.2, 149.5, 145.6, 140.4, 136.5, 146.9,
    158.9, 144.4, 148.1, 155.5, 152.4, 153.3, 142.3, 155.3, 153.1, 152.3,
]

# 平均値と標準偏差
function meansd(xs)
    m = sum(xs) / length(xs)
    s = 0.0
    for x = xs
        s += (x - m) * (x - m)
    end
    m, sqrt(s / length(xs))
end

# 1 回の読み込みで求める
function meansd2(xs)
    m, s = 0.0, 0.0
    k = length(xs)
    for i = 1 : k
        x = xs[i] - m
        m += x / i
        s += (i - 1) * x * x / i
    end
    m, sqrt(s / k)
end

println(meansd(height))
println(meansd2(height))
</pre>
<pre>
C&gt;julia mean.jl
(150.62699999999998, 6.433472701426501)
(150.62699999999998, 6.433472701426506)
</pre>
<h4 id="chap04">●パスカルの三角形</h4>
<pre class="list">
リスト : パスカルの三角形

# 2 次元配列版
function pascal(n)
    table = ones(Int, n, n)
    for i = 3 : n, j = 2 : i - 1
        table[i, j] = table[i - 1, j - 1] + table[i - 1, j]
    end
    for i = 1 : n
        for j = 1 : i
            print(table[i, j], " ")
        end
        println("")
    end
end

# 1 次元配列版
function pascal1(n)
    table = ones(Int, n)
    println(table[1])
    println(table[1], " ", table[2])
    for i = 3 : n
        for j = i - 1 : -1 : 2
            table[j] += table[j - 1]
        end
        # 表示
        for j = 1 : i
            print(table[j], " ")
        end
        println("")
    end
end

pascal(15)
# pascal1(15)
</pre>
<pre>
C&gt;julia pascal.jl
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
1 10 45 120 210 252 210 120 45 10 1
1 11 55 165 330 462 462 330 165 55 11 1
1 12 66 220 495 792 924 792 495 220 66 12 1
1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1
1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1
</pre>
<h4 id="chap05">●素数</h4>
<pre class="list">
リスト : 素数

# 単純版
function checkPrime(ps, x)
    for p = ps
        if p * p &gt; x; break; end
        if x % p == 0; return false; end
    end
    true
end

function makePrimes(n)
    ps = [2]
    x = 1
    for x = 3 : 2 : n
        if checkPrime(ps, x); push!(ps, x); end
    end
    ps
end

# エラトステネスの篩 (1)
function sieve(n)
    ps = [2]
    xs = collect(3 : 2 : n)
    while xs[1] * xs[1] &lt;= n
        p = xs[1]
        push!(ps, p)
        filter!(x -&gt; x % p != 0, xs)
    end
    append!(ps, xs)
end

# エラトステネスの篩 (2)
function sieve1(n)
    ps = [2]
    k = div(n, 2)
    xs = trues(k)
    x = 3
    while x * x &lt;= n
        i = div(x, 2)
        if xs[i]
            push!(ps, x)
            for j = i + x : x : k; xs[j] = false; end
        end
        x += 2
    end
    while x &lt;= n
        i = div(x, 2)
        if xs[i]; push!(ps, x); end
        x += 2
    end
    ps
end

println(makePrimes(1000))
# println(sieve(1000))
# println(sieve1(1000))
</pre>
<ul>
  <li>1 行に複数の処理を記述するときはセミコロン (;) で区切る
  <li>filter!(func, xs) は関数 func が偽を返す要素を取り除く (xs を破壊的に修正する)
</ul>
<pre>
C&gt;julia prime.jl
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,
107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,
223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,
337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,
457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,
593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,
719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,
857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,
997]
</pre>
<h4 id="chap06">●素因数分解</h4>
<pre class="list">
リスト : 素因数分解 (試し割り)

function factorSub(n, m)
    c = zero(n)
    while n % m == 0
        c += 1
        n = div(n, m)
    end
    c, n
end

function factorization(n)
    x::typeof(n) = 2
    xs = Pair{typeof(n), typeof(n)}[]
    c, m = factorSub(n, x)
    if c &gt; 0
        push!(xs, x =&gt; c)
    end
    x = 3
    while x * x &lt;= m
        c, m = factorSub(m, x)
        if c &gt; 0
            push!(xs, x =&gt; c)
        end
        x += 2
    end
    if m &gt; 1
        push!(xs, m =&gt; one(n))
    end
    xs
end

println(factorization(24))
println(factorization(12345678))
println(factorization(123456789))
println(factorization(1234567890))
println(factorization(1111111111))
for x = 2 : 31
    println(factorization(2 ^ x - 1))
end
</pre>
<ul>
  <li>typeof() の結果はデータ型の指定にも使える
</ul>
<pre>
C&gt;julia factor.jl
[2=&gt;3,3=&gt;1]
[2=&gt;1,3=&gt;2,47=&gt;1,14593=&gt;1]
[3=&gt;2,3607=&gt;1,3803=&gt;1]
[2=&gt;1,3=&gt;2,5=&gt;1,3607=&gt;1,3803=&gt;1]
[11=&gt;1,41=&gt;1,271=&gt;1,9091=&gt;1]
[3=&gt;1]
[7=&gt;1]
[3=&gt;1,5=&gt;1]
[31=&gt;1]
[3=&gt;2,7=&gt;1]
[127=&gt;1]
[3=&gt;1,5=&gt;1,17=&gt;1]
[7=&gt;1,73=&gt;1]
[3=&gt;1,11=&gt;1,31=&gt;1]
[23=&gt;1,89=&gt;1]
[3=&gt;2,5=&gt;1,7=&gt;1,13=&gt;1]
[8191=&gt;1]
[3=&gt;1,43=&gt;1,127=&gt;1]
[7=&gt;1,31=&gt;1,151=&gt;1]
[3=&gt;1,5=&gt;1,17=&gt;1,257=&gt;1]
[131071=&gt;1]
[3=&gt;3,7=&gt;1,19=&gt;1,73=&gt;1]
[524287=&gt;1]
[3=&gt;1,5=&gt;2,11=&gt;1,31=&gt;1,41=&gt;1]
[7=&gt;2,127=&gt;1,337=&gt;1]
[3=&gt;1,23=&gt;1,89=&gt;1,683=&gt;1]
[47=&gt;1,178481=&gt;1]
[3=&gt;2,5=&gt;1,7=&gt;1,13=&gt;1,17=&gt;1,241=&gt;1]
[31=&gt;1,601=&gt;1,1801=&gt;1]
[3=&gt;1,2731=&gt;1,8191=&gt;1]
[7=&gt;1,73=&gt;1,262657=&gt;1]
[3=&gt;1,5=&gt;1,29=&gt;1,43=&gt;1,113=&gt;1,127=&gt;1]
[233=&gt;1,1103=&gt;1,2089=&gt;1]
[3=&gt;2,7=&gt;1,11=&gt;1,31=&gt;1,151=&gt;1,331=&gt;1]
[2147483647=&gt;1]
</pre>
<h4 id="chap07">●再帰定義</h4>
<pre class="list">
リスト : 再帰定義

# 階乗
function fact(n)
    if n == 0
        BigInt(1)    # one(n) とすると引数 n のデータ型で値を求める
    else
       n * fact(n - 1)
    end
end

# 階乗 (繰り返し版)
function facti(n)
    a = BigInt(1)    # a::BigInt = 1 でもよい
    for x = 2 : n
      a *= x
    end
    a
end

# フィボナッチ数 (二重再帰)
function fibo(n)
    if n == 0
        0
    elseif n == 1
        1
    else
        fibo(n - 2) + fibo(n - 1)
    end
end

# フィボナッチ数 (繰り返し版)
function fiboi(n)
    a = BigInt(0)    # zero(n)
    b = BigInt(1)    # one(n) とすると引数のデータ型で値を求める
    for _ = 1 : n
        a, b = b, a + b
    end
    a
end

for x = 0:20
    println(fact(x))
end
println(facti(50))
for x = 0:20
    print(fibo(x), " ")
end
println("")
println(fiboi(50))
println(fiboi(100))
</pre>
<ul>
  <li>BigInt() や BigFloat() のかわりに関数 big() が使える
  <li>Julia には階乗を求める関数 factorial() がある
  <li>factorial() でオーバーフローするときは引数を big() で変換する
  <li>zero(x) は引数 x のデータ型の 0 を返す
  <li>one(x) は引数 x のデータ型の 1 を返す
</ul>
<pre>
C&gt;julia fact.jl
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
2432902008176640000
30414093201713378043612608166064768844377641568960512000000000000
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
12586269025
354224848179261915075
</pre>
<h4 id="chap08">●高階関数</h4>
<pre class="list">
リスト : 高階関数

# マッピング
function map1(fn, xs)
    a::typeof(xs) = []
    for x = xs
        push!(a, fn(x))
    end
    a
end

# フィルター
function filter1(fn, xs)
    a::typeof(xs) = []
    for x = xs
        if fn(x)
            push!(a, x)
        end
    end
    a
end

# 畳み込み
function foldleft(fn, a, xs)
    for x = xs
        a = fn(a, x)
    end
    a
end

xs = collect(1:10)
println(map1(x -&gt; x * x, xs))
println(map(x -&gt; x * x, xs))
println(filter1(x -&gt; x % 2 == 0, xs))
println(filter(x -&gt; x % 2 == 0, xs))
println(foldleft(+, 0, xs))
println(reduce(+, xs, init=0))
</pre>
<ul>
  <li>配列 a のデータ型を指定しないと Array{Any, 1} になる
  <li>Any でもよければデータ型の指定は不要 (どんなデータでも格納できる)
  <li>マッピングは内包表記のほうが簡単 [fn(x) for x = xs]
  <li>map() と filter() には引数 xs を破壊的に修正する map!() と filter!() がある
  <li>reduce() は初期値 (init) を省略すると先頭要素が初期値となる
</ul>
<pre>
C&gt;julia higher.jl
[1,4,9,16,25,36,49,64,81,100]
[1,4,9,16,25,36,49,64,81,100]
[2,4,6,8,10]
[2,4,6,8,10]
55
55
</pre>
<pre>
julia&gt; reduce((x, y) -&gt; (x, y), [1,2,3])
((1, 2), 3)

julia&gt; reduce((x, y) -&gt; (x, y), [1,2,3], init=0)
(((0, 1), 2), 3)
</pre>
<h4 id="chap09">●組み合わせの数</h4>
<pre class="list">
リスト : 組み合わせの数

# 二重再帰 (とても遅い)
function combination_number(n, r)
    if r == 0 || n == r
        BigInt(1)
    else
        combination_number(n - 1, r) + combination_number(n - 1, r - 1)
    end
end

# 末尾再帰
function combination_number1(n, r)
    if n == 0 || r == 0
        BigInt(1)
    else
        div(combination_number1(n, r - 1) * (n - r + 1), r)
    end
end

println(combination_number(22, 11))
println(combination_number1(26, 13))
println(combination_number1(50, 25))
</pre>
<pre>
C&gt;julia comb.jl
705432
10400600
126410606437752
</pre>

<h4 id="chap10">●順列と組み合わせ</h4>
<pre class="list">
リスト : 順列と組み合わせ

# xs の中から n 個を選ぶ順列
function permutation(fn, n, xs)
    ys::typeof(xs) = []

    function perm()
        if length(ys) == n
            fn(ys)
        else
            for x = xs
                if x in ys; continue; end
                push!(ys, x)
                perm()
                pop!(ys)
            end
        end
    end

    perm()
end

# xs の中から n 個を選ぶ組み合わせ
function combination(fn, n, xs)
    ys::typeof(xs) = []

    function comb(m)
        if length(ys) == n
            fn(ys)
        elseif m &lt;= length(xs)
            push!(ys, xs[m])
            comb(m + 1)
            pop!(ys)
            comb(m + 1)
        end
    end

    comb(1)
end

permutation(print, 4, [1, 2, 3, 4])
println("")
combination(print, 3, [1, 2, 3, 4, 5])
println("")
</pre>
<pre>
C&gt;julia perm.jl
[1, 2, 3, 4][1, 2, 4, 3][1, 3, 2, 4][1, 3, 4, 2][1, 4, 2, 3][1, 4, 3, 2][2, 1, 3, 4][2, 1, 4, 3]
[2, 3, 1, 4][2, 3, 4, 1][2, 4, 1, 3][2, 4, 3, 1][3, 1, 2, 4][3, 1, 4, 2][3, 2, 1, 4][3, 2, 4, 1]
[3, 4, 1, 2][3, 4, 2, 1][4, 1, 2, 3][4, 1, 3, 2][4, 2, 1, 3][4, 2, 3, 1][4, 3, 1, 2][4, 3, 2, 1]
[1, 2, 3][1, 2, 4][1, 2, 5][1, 3, 4][1, 3, 5][1, 4, 5][2, 3, 4][2, 3, 5][2, 4, 5][3, 4, 5]
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016-2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="julia.html">Julia</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>