<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 JavaScript プログラミング超入門</title>
  <meta name="description" content="JavaScript,JavaScript入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881802</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page<br>
<div class="small">
http://www.geocities.jp/m_hiroi/<br>
</div>
<div class="ce">
<h1>JavaScript Programming</h1>
<h2>お気楽 JavaScript プログラミング超入門</h2>
<div class="small">
[ <a href="js03.html">PrevPage</a> | <a href="javascript.html">JavaScript</a> | <a href="js05.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap09">JavaScript のオブジェクト指向</h3>
<p> 今回は JavaScript の特徴である「プロトタイプベース」のオブジェクト指向機能について説明します。現在のオブジェクト指向はクラスでインスタンス変数やメソッドを定義する「クラスベース」が主流です。ところがプロトタイプベースにはクラスが存在しません。このため、「雛形 (プロトタイプ) 」となるオブジェクトから、新しいオブジェクトを生成する方法が必要になります。この場合、次の 2 通りの方法が考えられます。
</p>
<ol>
  <li>空のオブジェクトを生成して、プロトタイプへの参照を持たせる。
  <li>プロトタイプをコピーする。
</ol>
<p> 2 の方法はクローン (clone) と呼ばれることもあります。JavaScript の場合、基本的には 1 の方法を使います。まず最初にオブジェクトの生成から説明します。
</p>
<h4>●オブジェクトの生成</h4>
<p> JavaScript では、new 演算子を使って空のオブジェクトを生成し、それを関数に渡してオブジェクトに必要なデータをセットします。この関数を「コンストラクタ (constructor) 」と呼びます。JavaScript の場合、オブジェクトはハッシュで実装されています。ハッシュのキーのことを「プロパティ (property) 」と呼びます。プロパティは「属性」という意味で、クラスベースのオブジェクト指向では「インスタンス変数」に相当します。
</p>
<p> たとえば、コンストラクタを Foo とすると、new Foo() で新しいオブジェクトが生成されます。次の例を見てください。
</p>
<pre class="list">
リスト : コンストラクタ

function Foo(a, b) {
    this.a = a;
    this.b = b;
}
</pre>
<p> JavaScript の場合、コンストラクタの中ではキーワード this を使ってオブジェクトを参照することができます。new Foo() の場合、new で生成されたオブジェクトが this に渡されるので、関数 Foo の中では this を使ってオブジェクトのプロパティにアクセスすることができます。
</p>
<p> プロパティのアクセス方法は [ ] だけではなく、object.name でもアクセスすることができます。this.a は this["a"] と同じ意味です。ただし、this.1 のように数値を直接指定することはできません。この場合は [ ] を使って this[1] とします。
</p>
<p> それでは実際にオブジェクトを生成してみましょう。
</p>
<pre>
&gt; x = new Foo(10, 20)
Foo {a: 10, b: 20}
&gt; x.a
10
&gt; x.b
20
&gt; y = new Foo(100, 200)
Foo {a: 100, b: 200}
&gt; y.a
100
&gt; y.b
200
</pre>
<p> JavaScript の場合、プロパティのアクセスを制限する機能はありません。どこからでもアクセスすることができます。
</p>

<h4>●メソッドの定義</h4>
<p> JavaScript の場合、オブジェクトのプロパティに関数オブジェクトをセットすれば、それをメソッドとして呼び出すことができます。メソッドの呼び出しは object.method() とします。このとき、メソッドの中ではキーワード this を使って呼び出したオブジェクト (object) を参照することができます。次の例を見てください。
</p>
<pre class="list">
リスト : メソッドの定義 (1)

function Foo(a, b) {
    this.a = a;
    this.b = b;
    this.get_a = function() { return this.a; };
    this.get_b = function() { return this.b; };
    this.set_a = function(x) { this.a = x; };
    this.set_b = function(x) { this.b = x; };
}
</pre>
<p> コンストラクタ Foo の中でメソッド get_a(), get_b(), set_a(), set_b() を定義します。匿名関数で関数オブジェクトを生成してプロパティにセットするだけなので簡単です。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
&gt; x = new Foo(10, 20)
Foo {a: 10, b: 20, get_a: function, get_b: function, set_a: function…}
&gt; x.get_a()
10
&gt; x.get_b()
20
&gt; x.set_a(100)
undefined
&gt; x.get_a()
100
&gt; x.set_b(200)
undefined
&gt; x.get_b()
200
</pre>
<p> このように、関数オブジェクトをプロパティにセットすれば、それをメソッドとして呼び出すことができます。
</p>
<p> ところで、この方法ではオブジェクトを生成するたびに、新たな関数オブジェクトが生成されてプロパティにセットされます。同じ処理を行う関数をいくつも作るのは無駄ですね。そこで、メソッド用の関数を定義して、それをプロパティにセットすることにしましょう。次の例を見てください。
</p>
<pre class="list">
リスト : メソッドの定義 (2)

function Foo(a, b) {
    function get_a() { return this.a; };
    function get_b() { return this.b; };
    function set_a(x) { this.a = x; };
    function set_b(x) { this.b = x; };
    this.a = a;
    this.b = b;
    this.get_a = get_a
    this.get_b = get_b
    this.set_a = set_a
    this.set_b = set_b
}
</pre>
<p> Foo の中で局所関数 get_a(), get_b(), set_a(), set_b() を定義し、それをプロパティにセットします。これで、無駄な関数オブジェクトの生成を抑えることができます。ただし、この方法でもメソッドは個々のオブジェクトに格納されるので、メモリを余分に使うことになります。この問題は「プロトタイプチェーン」という機能を使うと解決することができます。
</p>
<h4>●プロトタイプチェーン</h4>
<p> JavaScript の場合、new 演算子でオブジェクトを生成するとき、プロトタイプとなるオブジェクトを指定することができます。もし、オブジェクトの中でプロパティが見つからない場合はプロトタイプからプロパティを探します。そのプロトタイプにも、プロトタイプとなるオブジェクトが存在する場合があります。つまり、複数のプロトタイプがつながっている場合があるのです。これをプロトタイプチェーンといいます。
</p>
<p> ようするに、JavaScript はプロトタイプをコピーするのではなく、プロトタイプをリンクでつないでおくわけです。そして、プロトタイプチェーンをたどってプロパティを探します。また、プロトタイプチェーンを使って「継承」を実現することもできます。
</p>
<p> コンストラクタで生成されるオブジェクトのプロトタイプは、コンストラクタ (関数オブジェクト) のプロパティ prototype で指定します。次の例を見てください。
</p>

<pre class="list">
リスト : メソッドの定義 (3)

function Foo(a, b) {
    this.a = a;
    this.b = b;
}

Foo.prototype.get_a = function() { return this.a; };
Foo.prototype.get_b = function() { return this.b; };
Foo.prototype.set_a = function(x) { this.a = x; };
Foo.prototype.set_b = function(x) { this.b = x; };
</pre>

<p> 関数はコンストラクタになる可能性があるので、関数オブジェクトにはプロパティ prototype が必ず用意され、その値は空オブジェクトで初期化されています。たとえば上記プログラムの場合、コンストラクタ Foo の prototype には空オブジェクトがセットされています。そして、演算子 new でオブジェクトを生成するとき、新しいオブジェクトのプロトタイプチェーンに Foo.prototype のオブジェクトがリンクされます。
</p>
<p> ここで、Foo.prototype で設定するオブジェクトは、new 演算子で生成されるオブジェクトのプロトタイプを指定するものであり、Foo のプロトタイプではないことに注意してください。プロトタイプチェーンを表すプロパティ名は処理系に依存していて、Google Chrome の場合は __proto__ になります。つまり、new 演算子は生成したオブジェクトの __proto__ に、コンストラクタの prototype の値をセットするわけです。これを図に示すと次のようになります。
</p>
<pre class="fig">
┌─Constructor ─┐                      ┌── object ──┐
│                │                      │                │
│prototype: {...}│─ new Constructor()→│__proto__: {...}│
│            │  │                      │            ↑  │
└──────┼─┘                      └──────┼─┘
          │  │                                        │
          │  └────────────────────┤
          │                                            │
          │                              ┌── object ┼─┐
          │                              │            ↓  │
          └───── new Constructor()→│__proto__: {...}│
                                          │                │
                                          └────────┘

                図 : プロトタイプチェーンの設定
</pre>

<p> したがって、Foo.prototype にセットされているオブジェクトにメソッドを追加すれば、new Foo() で生成したオブジェクトからそれらのメソッドを呼び出すことができるわけです。また Foo.prototype には、次のように { } でオブジェクトを生成してセットすることもできます。
</p>
<pre class="list">
リスト : メソッドの定義 (4)

function Foo(a, b) {
    this.a = a;
    this.b = b;
}

Foo.prototype = {
    get_a: function() { return this.a; },
    get_b: function() { return this.b; },
    set_a: function(x) { this.a = x; },
    set_b: function(x) { this.b = x; }
}
</pre>
<p> { } の中では name: value でプロパティ名とその値を設定することができます。このように、prototype のオブジェクトでメソッドを設定すると、コンストラクタで生成されたオブジェクトからそのメソッドを呼び出すことができます。メソッドを持っているオブジェクトは一つだけなので、メモリを余分に使うこともありません。
</p>
<h4>●ポリモーフィズム</h4>
<p> それでは簡単な例題として、点と表すオブジェクトを作ってみましょう。コンストラクタ Point で作成するオブジェクトは 2 次元座標を表し、Point3D で作成するオブジェクトは 3 次元座標を表します。それぞれ、2 点間の距離を計算するメソッド distance() を定義します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 座標を表すオブジェクト

// 2 次元座標
function Point(x, y) {
    this.x = x;
    this.y = y;
}

// 距離を求める
Point.prototype.distance = function(p) {
    var dx = this.x - p.x;
    var dy = this.y - p.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// 3 次元座標
function Point3D(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}

// 距離を求める
Point3D.prototype.distance = function(p) {
    var dx = this.x - p.x;
    var dy = this.y - p.y;
    var dz = this.z - p.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
</pre>

<p> コンストラクタ Point, Point3D は座標を受け取り、それをオブジェクトにセットします。メソッド distance() は引数 p にオブジェクトを受け取り、this と p の距離を計算します。sqrt() は平方根を求める関数で、JavaScript のグローバルオブジェクト Math に定義されています。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; p1 = new Point(0, 0)
Point {x: 0, y: 0, distance: function}
&gt; p2 = new Point(10, 10)
Point {x: 10, y: 10, distance: function}
&gt; p3 = new Point3D(0, 0, 0)
Point3D {x: 0, y: 0, z: 0, distance: function}
&gt; p4 = new Point3D(10, 10, 10)
Point3D {x: 10, y: 10, z: 10, distance: function}
&gt; p1.distance(p2)
14.142135623730951
&gt; p3.distance(p4)
17.32050807568877
</pre>
<p> このように、ドットの左側のオブジェクトによって適切なメソッドが呼び出され、ポリモーフィズム (polymorphism) がきちんと働いていることがわかります。
</p>
<h4>●プロトタイプのクラス的な使い方</h4>
<p> クラスベースのオブジェクト指向に慣れている方ならば、prototype で指定したオブジェクトを「クラス」と考えるとわかりやすいかもしれません。たとえば、オブジェクトで共通に使用する変数が必要な場合、prototype のオブジェクトに変数を定義することで実現することができます。これはクラスベースでいうところの「クラス変数」と同じ機能です。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; function Foo() {}
undefined
&gt; Foo.prototype = {bar: 1}
Object {bar: 1}
&gt; a = new Foo()
Foo {bar: 1}
&gt; b = new Foo();
Foo {bar: 1}
&gt; a.bar
1
&gt; b.bar
1
</pre>

<p> プロパティ bar がクラス変数になります。new Foo() でオブジェクトを生成して、変数 a, b にセットします。a.bar と b.bar は同じプロパティ bar を参照するので、同じ値 1 になります。
</p>
<p> bar の値を書き換える場合は注意が必要です。次の例を見てください。
</p>
<pre>
&gt; Foo.prototype.bar = 10
10
&gt; a.bar
10
&gt; b.bar
10
&gt; a.bar = 20
20
&gt; a.bar
20
&gt; b.bar
10
</pre>
<p> 最初の例は prototpye のオブジェクトを指定して、プロパティ bar の値を書き換えています。この場合、a.bar と b.bar は書き換えた値 10 になります。次に、a.bar = 20 を実行します。このとき、オブジェクト a にプロパティ bar が存在しないことに注意してください。
</p>
<p> JavaScript の場合、オブジェクトにプロパティが存在しない場合、そのオブジェクトにプロパティを登録し、そこに値を代入します。つまり、オブジェクト a にプロパティ bar が作られて、そこに 20 がセットされるのです。この場合、prototype の bar は 10 のままなので、b.bar の値は 10 になります。a.bar の値は a のプロパティ bar を参照するので 20 になります。
</p>
<p> このため、クラス変数を使用する場合は、prototype のオブジェクトに直接アクセスするよりも、次のようにアクセサを定義した方がよいでしょう。
</p>
<pre class="list">
リスト : クラス変数のアクセスメソッド

function Foo() {}

Foo.prototype = {
    bar: 1,
    show: function() { return Foo.prototype.bar; },
    update: function(x) { Foo.prototype.bar = x; }
}
</pre>

<p> メソッド show() で Foo.prototype の bar の値を参照し、update() で bar の値を更新します。簡単な例を示しましょう。
</p>
<pre>
&gt; a = new Foo();
Foo {bar: 1, show: function, update: function}
&gt; b = new Foo()
Foo {bar: 1, show: function, update: function}
&gt; a.show()
1
&gt; b.show()
1
&gt; a.update(10)
undefined
&gt; a.show()
10
&gt; b.show()
10
Foo.prototype.show()
10
Foo.prototype.update(100)
undefined
Foo.prototype.show()
100
a.show()
100
b.show()
100
</pre>
<p> show() と update() は new Foo() で生成したオブジェクトから呼び出すことができますし、Foo.prototype に格納されたオブジェクトからも呼び出すこともできます。show() と update() は、クラスベースオブジェクト指向でいうところの「クラスメソッド」という機能に相当します。
</p>
<p> クラスメソッドを定義するとき、this の使用には十分に注意してください。Foo.prototype からメソッドを呼び出すと、this の値は Foo.prototype のオブジェクトになります。ところが、オブジェクト a から呼び出すと this の値は a になります。たとえば、update() の処理を this.bar = x; とした場合、オブジェクト a から呼び出すと a のプロパティ bar に x の値を代入することになり、Foo.prototype の bar の値を書き換えることはできません。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap10">連結リスト</h3>
<p> 今回は簡単な例題として、「連結リスト (Linked List) 」という基本的なデータ構造を作ってみましょう。なお、今回のプログラムは <a href="index.html#python_abc">お気楽 Python プログラミング入門</a> <a href="python05.html#chap11">連結リスト</a> のプログラムを JavaScript で書き直したものです。内容は重複していますが、あしからずご了承ください。
</p>
<p> 連結リストはデータを一方向につなげたデータ構造です。リストを操作するプログラミング言語では Lisp が有名ですが、Lisp で扱うリストが連結リストです。下図に連結リストの構造を示します。
</p>
<pre class="fig">
(1)変数
  ┌─┐    ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  
  │・┼─→│10│・┼→│20│・┼→│30│／│ ／：終端(null)
  └─┘    └─┴─┘  └─┴─┘  └─┴─┘  

(2)ヘッダセル
  ┌─┬─┐    ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  
  │  │・┼─→│10│・┼→│20│・┼→│30│／│ ／：終端(null)
  └─┴─┘    └─┴─┘  └─┴─┘  └─┴─┘  

                図 : 連結リスト
</pre>
<p> 連結リストはセル (cell) というデータを繋げて作ります。セルにはデータを格納する場所と、次のセルを指し示す場所から構成されます。上図でいうと、箱がひとつのセルを表していて、左側にデータを格納し、右側に次のセルへの参照を格納します。リストの終わりを示すため、最後のセルの右側には特別な値（たとえば null）を格納します。そして、図 (1) のように先頭セルへの参照を変数に格納しておけば、この変数を使って連結リストにアクセスすることができます。また、図 (2) のようにヘッダセルを用意する方法もあります。
</p>
<h4>●コンストラクタの定義</h4>
<p> それではプログラムを作りましょう。まずは、セル Cell と連結リスト List のコンストラクタを作成します。
</p>
<pre class="list">
リスト : コンストラクタの定義

// セル
function Cell(data, link) {
    this.data = data;
    this.link = link;
}

// 連結リスト
function List() {
    var cp = new Cell(null, null);
    this.top = cp;
    for(var i = 0; i &lt; arguments.length; i++) {
        cp.link = new Cell(arguments[i], null);
        cp = cp.link;
    }
}
</pre>
<p> Cell はセルを作成します。プロパティ data にデータを格納し、link に接続するセルへの参照を格納します。List は連結リストのオブジェクトを生成します。今回は図 (2) の方法でプログラムします。List が生成したオブジェクトのプロパティ top にはヘッダーセルを格納します。List() は可変個の引数を受け取るようにすると便利です。配列 arguments から要素 x を取り出し、連結リストの最後尾に x を追加していきます。
</p>
<h4>●メソッドの定義 (1)</h4>
<p> あとはメソッドを定義するだけです。今回作成するメソッドを下表に示します。
</p>
<table border=1>
<caption>表 : List の操作メソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>ls.at(n)  </td><td>n 番目の要素を求める</td></tr>
  <tr><td>ls.insert(n, x) </td><td>n 番目の位置にデータ x を挿入する</td></tr>
  <tr><td>ls.remove(n) </td><td>n 番目の要素を削除する</td></tr>
  <tr><td>ls.isEmpty() </td><td>連結リストが空の場合は真を返す</td></tr>
  <tr><td>ls.each(func)</td><td>要素に関数 func を適用する</td></tr>
</tbody>
</table>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : メソッドの定義 (1)

List.prototype = {
    // 作業用メソッド : n 番目のセルを返す
    _nth: function(n) {
        var cp = this.top;
        var i = -1;
        while(cp != null){
            if(n == i) return cp;
            cp = cp.link;
            i += 1;
        }
        return null;
    },

    // n 番目の要素を返す
    at: function(n) {
        var cp = this._nth(n);
        if(cp) return cp.data;
        return null;
    },
  
      // n 番目にデータを挿入
    insert: function(n, x) {
        var cp = this._nth(n - 1);
        if (cp) {
            cp.link = new Cell(x, cp.link);
            return x;
        }
        return null;
    },

    // n 番目の要素を削除
    remove: function(n) {
        var cp = this._nth(n - 1);
        if (cp &amp;&amp; cp.link) {
            var data = cp.link.data;
            cp.link = cp.link.link;
            return data;
        }
        return null;
    },

    // イテレータ
    each: function(func) {
        var cp = this.top.link;
        while (cp != null) {
            func(cp.data);
            cp = cp.link;
        }
    },

    // 空リストか
    isEmpty: function() { return this.top.link == null; }
}
</pre>
<p> メソッドはオブジェクト { } の中で定義して、それを List.prototype にセットします。_nth() は n 番目のセルを求める作業用のメソッドです。at(), insert(), remove() は _nth() を使うと簡単にプログラムすることができます。詳しい説明は <A href="index.html#python_abc">お気楽 Python プログラミング入門</A> <A href="python05.html#chap11">連結リスト</A> をお読みください。
</p>
<p> それでは、簡単な実行例を示しましょう。
<pre>
&gt; a = new List()
List {top: Cell, _nth: function, at: function, insert: function, remove: function…}
&gt; for (i = 0; i &lt; 5; i++) a.insert(0, i)
4
&gt; a.at(0)
4
&gt; a.at(4)
0
&gt; a.each(function(x){ console.log(x); })
4
3
2
1
0
undefined
&gt; a.remove(0)
4
&gt; a.each(function(x){ console.log(x); })
3
2
1
0
undefined
</pre>
<p> 正常に動作していますね。
</p>
<h4>●データの変換</h4>
<p> このほかに、連結リストを配列に変換するメソッド toArray() と文字列に変換するメソッド toString() を定義すると便利です。次のリストを見てください。
</p>
<pre class="list">
リスト : データの変換

　   // 配列への変換
    toArray: function(){
        var ary = [];
        this.each(function(x){ ary.push(x); });
        return ary;
    },

    // 文字列への変換
    toString: function(){
        return "(" + this.toArray().join(", ") + ")";
    }
</pre>
<p> toArray() はメソッド each() を使うと簡単です。each() で先頭から順番に要素にアクセスし、それを配列 ary に push() で追加するだけです。最後に配列を返します。
</p>
<p> toString() も簡単です。連結リストを toArray() で配列に変換し、要素を配列のメソッド join() で連結します。各要素は join() で文字列に変換され、カンマ ( , ) をはさんで連結されます。
</p>
<p> それでは簡単な実行例を示しましょう。
</p>
<pre>
&gt; a = new List(1,2,3,4,5)
List {top: Cell, _nth: function, at: function, insert: function, remove: function…}
&gt; a.toArray()
[1, 2, 3, 4, 5]
&gt; a.toString()
"(1,2,3,4,5)"
</pre>
<h4>●メソッドの定義 (2)</h4>
<p> ところで、今回のプログラムは作業用の関数 _nth() をメソッドとしてオブジェクトに登録したので、次のように呼び出すことが可能です。
</p>
<pre>
&gt; x = a._nth(0)
Cell {data: 1, link: Cell}
&gt; x.data
1
&gt; x.link
Cell {data: 2, link: Cell}
</pre>
<p> クロージャを使うと作業用の関数を隠蔽することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : メソッドの定義 (2)

List.prototype = function() {
    // n 番目のセルを返す
    function nth(cp, n){
        var i = -1;
        while(cp != null){
            if (n == i) return cp;
            cp = cp.link;
            i += 1;
        }
        return null;
    };
    var obj = {
        // n 番目の要素を返す
        at: function(n) {
            var cp = nth(this.top, n);
            if(cp) return cp.data;
            return null;
        },

        // n 番目にデータを挿入
        insert: function(n, x) {
            var cp = nth(this.top, n - 1);
            if (cp) {
                cp.link = new Cell(x, cp.link);
                return x;
            }
            return null;
        },

        // n 番目の要素を削除
        remove: function(n) {
            var cp = nth(this.top, n - 1);
            if (cp &amp;&amp; cp.link) {
                var data = cp.link.data;
                cp.link = cp.link.link;
                return data;
            }
            return null;
        },

        // イテレータ
        each: function(func) {
            var cp = this.top.link;
            while (cp != null) {
                func(cp.data);
                cp = cp.link;
            }
        },

        // 空リストか
        isEmpty: function() { return this.top.link == null; },

        // 配列への変換
        toArray: function() {
            var ary = [];
            this.each(function(x){ ary.push(x); });
            return ary;
        },

        // 文字列への変換
        toString: function() {
            return "(" + this.toArray().join(", ") + ")";
        }
    };
    return obj;
}();
</pre>
<P> 匿名関数の中で作業用関数 nth() を局所関数として定義します。そして、{ } の中でメソッドを定義します。メソッドは匿名関数を使って定義しているので、当然ですが局所関数 nth() にアクセスすることができます。そして、最後に生成したオブジェクトを返せばいいわけです。
</p>
<p> なお、この匿名関数を実行しないと List.prototype にオブジェクトがセットされません。function(){ ... } の後ろに () を付けることをお忘れなく。
</p>
<hr>
<h4><A name="list1">●プログラムリスト１</A></h4>
<pre class="list">
//
// list.js : 連結リスト
//
//           Copyright (C) 2010 Makoto Hiroi
//

// セル
function Cell(data, link) {
    this.data = data;
    this.link = link;
}

// 連結リスト
function List() {
    var cp = new Cell(null, null);
    this.top = cp;
    for (var i = 0; i &lt; arguments.length; i++) {
        cp.link = new Cell(arguments[i], null);
        cp = cp.link;
    }
}

// メソッドの定義
List.prototype = {
    // 作業用メソッド : n 番目のセルを返す
    _nth: function(n) {
        var cp = this.top;
        var i = -1;
        while (cp != null) {
            if (n == i) return cp;
            cp = cp.link;
            i += 1;
        }
        return null;
    },

    // n 番目の要素を返す
    at: function(n) {
        var cp = this._nth(n);
        if (cp) return cp.data;
        return null;
    },
    
    // n 番目にデータを挿入
    insert: function(n, x) {
        var cp = this._nth(n - 1);
        if (cp) {
            cp.link = new Cell(x, cp.link);
            return x;
        }
        return null;
    },

    // n 番目の要素を削除
    remove: function(n) {
        var cp = this._nth(n - 1);
        if (cp &amp;&amp; cp.link) {
            var data = cp.link.data;
            cp.link = cp.link.link;
            return data;
        }
        return null;
    },

    // イテレータ
    each: function(func) {
        var cp = this.top.link;
        while (cp != null) {
            func(cp.data);
            cp = cp.link;
        }
    },

    // 空リストか
    isEmpty: function() { return this.top.link == null; },

    // 配列への変換
    toArray: function() {
        var ary = [];
        this.each(function(x) { ary.push(x); });
        return ary;
    },

    // 文字列への変換
    toString: function() {
        return "(" + this.toArray().join(",") + ")";
    }
}
</pre>
<hr>
<h4><A name="list2">●プログラムリスト２</A></h4>
<pre class="list">
//
// list.js : 連結リスト
//
//           Copyright (C) 2010 Makoto Hiroi
//

// セル
function Cell(data, link) {
    this.data = data;
    this.link = link;
}

// 連結リスト
function List() {
    var cp = new Cell(null, null);
    this.top = cp;
    for (var i = 0; i &lt; arguments.length; i++) {
        cp.link = new Cell(arguments[i], null);
        cp = cp.link;
    }
}

// メソッドの定義
List.prototype = function() {
    // n 番目のセルを返す
    function nth(cp, n) {
        var i = -1;
        while (cp != null) {
            if (n == i) return cp;
            cp = cp.link;
            i += 1;
        }
        return null;
    };
    var obj = {
        // n 番目の要素を返す
        at: function(n) {
            var cp = nth(this.top, n);
            if (cp) return cp.data;
            return null;
        },
    
        // n 番目にデータを挿入
        insert: function(n, x) {
            var cp = nth(this.top, n - 1);
            if (cp) {
                cp.link = new Cell(x, cp.link);
                return x;
            }
            return null;
        },

        // n 番目の要素を削除
        remove: function(n) {
            var cp = nth(this.top, n - 1);
            if (cp &amp;&amp; cp.link) {
                var data = cp.link.data;
                cp.link = cp.link.link;
                return data;
            }
            return null;
        },

        // イテレータ
        each: function(func) {
            var cp = this.top.link;
            while (cp != null) {
                func(cp.data);
                cp = cp.link;
            }
        },

        // 空リストか
        isEmpty: function() { return this.top.link == null; },

        // 配列への変換
        toArray: function() {
            var ary = [];
            this.each(function(x) { ary.push(x); });
            return ary;
        },

        // 文字列への変換
        toString: function() {
            return "(" + this.toArray().join(",") + ")";
        }
    };
    return obj;
}();
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010-2015 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="js03.html">PrevPage</a> | <a href="javascript.html">JavaScript</a> | <a href="js05.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>