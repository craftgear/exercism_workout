<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Python3/Tkinter 超入門 </title>
  <meta name="description" content="Python3,Tkinter,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881762</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Python3 Programming</h1>
<h2>お気楽 Python3/Tkinter 超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#python3_tkinter">Python3</a> ]
<hr>
</div>
<section class="contents">
<h4 id="chap10">●エントリーウィジェット</h4>
<ul>
  <li>エントリー (entry) は 1 行の文字列を入力、または編集することができるウィジェット</li>
  <li>エントリーオブジェクトは Entry() で生成する</li>
  <li>よく使うオプションは textvariable で、入力されたデータは指定したオブジェクトに格納される</li>
  <li>オブジェクトの値が変更されると、エントリーの内容も変更される</li>
  <li>オプション show はパスワードのように画面に見えてはいけない文字列を打ち込むときに使う</li>
  <li>たとえば、show = '*' とすれば、入力された文字は * として表示される</li>
  <li>メソッドも多数用意されているが、文字列の入力だけならば、それらを使う機会はあまりないと思われる</li>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : 式入力電卓

import tkinter as tk
from math import *

root = tk.Tk()
root.option_add('*font', ('', 14))

# 式を格納するオブジェクト
buffer = tk.StringVar()
buffer.set("")

# 計算
def calc(event):
    if buffer.get():
        value = eval(buffer.get())
        buffer.set(str(value))

# エントリー
e = tk.Entry(root, textvariable = buffer)
e.pack()
e.focus_set()

# バインディング
e.bind('&lt;Return&gt;', calc)

root.mainloop()
</pre>
  <ul>
    <li> 計算は関数 eval() を使えば簡単</li>
    <li>eval() は与えられた文字列を Python の式として評価する</li>
    <li>モジュール math をインポートしておけば、sin(), cos(), tan() などの関数を呼び出すことができる</li>
    <li>一般の GUI アプリケーションの場合、キー入力はアクティブになっているウィンドウに渡される</li>
    <li>Tk では、これを「フォーカスウィンドウ (focus window)」という</li>
    <li>フォーカスはメソッド focus_set() によってプログラムで設定することができる</li>
<pre class="item">
widget.focus_set()
</pre>
    <li> e.focus_set() でフォーカスウィンドウをエントリーに設定する</li>
    <li>bind() はあとで説明する</li>
  </ul>
</ul>
<p> <img src="py3_img/entry0.png" ALT="電卓入力の画面"> 数式を入力する
</p>
<p> <img src="py3_img/entry1.png" ALT="計算結果の画面"> リターンキーで計算する
</p>

<h4 id="chap11">●イベント処理</h4>
<ul>
  <li>式入力電卓のポイントはメソッド bind()</li>
<pre class="item">
widget.bind(eventsequence, callback)
</pre>
  <li>すでにバインドされているコールバック関数がある場合、新しい関数に差し替えられる</li>
  <li>callback を省略すると、そのイベントにバインドされている関数が返される</li>
  <li>引数を省略すると、そのウィジェットにバインドされているすべてのイベントをタプルに格納して返す</li>
  <li>コールバック関数の引数にはイベントを表すオブジェクト（クラス Event のインスタンス）が渡される</li>
  <li>このオブジェクトからイベントの詳細情報を取得することができる</li>
</ul>
<ul>
  <li>イベントの指定方法</li>
<pre class="item">
&lt;modifier-modifier-type-detail&gt;
</pre>
  <li>type は GUI 環境上で発生するイベントタイプを表す
  <li>ユーザーが操作するときに発生する主なイベントタイプには次のようなものがある</li>
</ul>
<table border=1>
<caption>表：イベントタイプ</caption>
<tbody>
<tr><td>Key, KeyPress</td><td>キーが押された</td></tr>
<tr><td>KeyRelease</td><td>キーが離された</td></tr>
<tr><td>Button, ButtonPress</td><td>マウスのボタンが押された</td></tr>
<tr><td>ButtonRelease</td><td>マウスのボタンが離された</td></tr>
<tr><td>Motion</td><td>マウスの移動</td></tr>
<tr><td>Enter</td><td>マウスカーソルがウィンドウの中に入った</td></tr>
<tr><td>Leave</td><td>マウスカーソルがウィンドウから出た</td></tr>
</tbody>
</table>
<ul>
  <li>このほかにも、ウィンドウが破棄されたときに発生するイベントなど、様々なイベントタイプがある</li>
  <li>マウスとキーのイベントには、ボタンやキーの種類を detail で指定する</li>
  <li>マウスでは左ボタンが 1 となる</li>
  <li>キーの種類は名前で指定する</li>
  <li>英数字はその文字がそのまま名前となる</li>
  <li>このほかに、改行キーに対する Return、バックスペースキーに対する BackSpace などがある</li>
  <li>detail を指定する場合は type を省略することができる</li>
  <ul>
    <li>&lt;1&gt; という指定は &lt;KeyPress-1&gt; ではなく &lt;Button-1&gt; となるので注意</li>
    <li>通常の英数字の場合、&lt;&gt; も省略することができる</li>
    <li>つまり、&lt;KeyPress-a&gt; は a と書くことができる</li>
  </ul>
  <li>&lt;KeyPress&gt; のように detail を省略すると、種類によらずキーが押されたときにバインドされたコマンドが実行される</li>
</ul>
<ul>
  <li>イベントタイプの前にはモディファイア (modifier) をつけることができる</li>
  <ul>
    <li>たとえば、&lt;Control-d&gt; はコントロールキーと d キーを同時に押したときのイベントを表す
  </ul>
  <li>主なモディファイアを下表に示す
</ul>
<table border=1>
<caption>表：モデファイア</caption>
<tbody>
<tr><td>Control</td><td>Ctrl キーを押しながらの入力</td></tr>
<tr><td>Shift</td><td>Shift キーを押しながらの入力</td></tr>
<tr><td>Alt</td><td>Alt キーを押しながらの入力</td></tr>
<tr><td>Button1, B1</td><td>マウスの左ボタンを押しながらの入力</td></tr>
<tr><td>Button3, B3</td><td>マウスの右ボタンを押しながらの入力</td></tr>
<tr><td>Double</td><td>ダブルクリック</td></tr>
<tr><td>Triple</td><td>トリプルクリック</td></tr>
</tbody>
</table>
<ul>
  <li>Tk の出身地である X Window は 3 ボタンマウスを使う</li>
  <li>Button2 は右ボタンではなく中ボタンとなる</li>
  <ul>
    <li>たとえば、左ボタンのダブルクリックに対応するイベントは &lt;Double-1&gt; となる</li>
  </ul>
  <li>イベントタイプは複数個指定することができる</li>
  <ul>
    <li>たとえば、&lt;Escape&gt;a はEsc キーが押されたあとで a キーを押したイベントに対応する
  </ul>
</ul>
<ul>
  <li>イベントの詳細情報はイベントオブジェクトのインスタンス変数にセットされてコールバック関数に渡される</li>
  <li>たとえば、下表に示すようなイベント情報がある</li>
</ul>
<table border=1>
<caption>表 : イベントの詳細情報</caption>
<thead>
  <tr><th>変数名</th><th>データ</th></tr>
</thead>
<tbody>
  <tr><td>num</td><td>マウスボタンの番号</td></tr>
  <tr><td>x,y</td><td>マウスカーソルの座標</td></tr>
  <tr><td>time</td><td>イベントの発生時刻</td></tr>
  <tr><td>char</td><td>キーに対応する文字</td></tr>
  <tr><td>keysym</td><td>キーに対応する名前</td></tr>
</tbody>
</table>
<ul>
  <li>これ以外にも、いろいろな情報がある</li>
  <li>詳細は Tkinter のマニュアルを参照</li>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : キーの名前を表示

import tkinter as tk

root = tk.Tk()
root.option_add('*font', ('', 14))

buffer = tk.StringVar()
buffer.set('')

# キーの表示
def print_key(event):
    key = event.keysym
    buffer.set('push key is {}'.format(key))

# ラベルの設定
tk.Label(root, text = '*** push any key ***').pack()
a = tk.Label(root, textvariable = buffer)
a.pack()
a.bind('&lt;Any-KeyPress&gt;', print_key)
a.focus_set()

root.mainloop()
</pre>
  <ul>
    <li>関数 print_key() にはイベントオブジェクト event が渡される</li>
    <li>event.keysym で押されたキーの名前を求めることができる</li>
    <li>実際に試してみると、F1 や F2 キーには F1, F2 という名前が割り当てられていることがわかる</li>
  </ul>
</ul>
<p><img src="py3_img/keyname.png" alt="キー入力の表示"> F1 キーを押したときの動作
</p>

<h4 id="chap12">●リストボックス</h4>
<ul>
  <li>リストボックスは複数の文字列を表示し、ユーザーはその中からひとつ以上の文字列を選択することができる</li>
  <li>リストボックスのオブジェクトは Listbox() で生成する</li>
  <li>Listbox() で指定する主なオプションを下表に示す</li>
</ul>
<table border=1>
<caption>表 : Listbox() の主なオプション</caption>
<tbody>
<tr><td>xscrollcommand</td><td>x 方向のスクロールメソッドを指定</td></tr>
<tr><td>yscrollcommand</td><td>y 方向のスクロールメソッドを指定</td></tr>
<tr><td>selectmode</td><td>セレクションモード</td></tr>
</tbody>
</table>
<ul>
  <li>xscrollcommand/yscrollcommand にはスクロールバーウィジェットのメソッド set() を指定する</li>
  <ul>
    <li>リストボックスの表示範囲が変更されたとき、指定したメソッド set() が呼び出される</li>
    <li>これは Scrollbar() と一緒に説明する</li>
  </ul>
  <li>セレクションには以下のモードが用意されている</li>
  <ul>
    <li>single<br>ひとつの行をマウスの左クリックで選択する。
    <li>browse<br>single と同じだが、ドラッグによって選択される行が変化し、
ボタンを離したところの行が選択される。
    <li>multiple<br>左クリックで複数行を選択する（ドラッグは不可）。
    <li>extended<br>
ドラッグで複数行を選択するが、左クリックではいままで選択した行はキャンセルされ、クリックした行のみ選択される。
CTRL キーを押しながら左クリックするとトグル動作（結果が反転）となり、
シフトキーを押しながら左クリックすると直前に左クリックした行から現在の行までが選択される。
    <li>デフォルト値は browse</li>
  </ul>
  <li>データの挿入、削除、取得は次のメソッドで行う</li>
  <ul>
    <li>insert(index, *element)<br> 指定した位置の直前に文字列を挿入
    <li>delete(first, last)<br> 指定した範囲の行を削除する
    <li>get(first, last)<br> 指定した範囲の行をリストに格納して返す
    <li>index(index)<br> 指定した位置の行番号を返す
    <li>curselection()<br> 選択された行番号をリストにして返す
    <li>see(index)<br> 指定した位置が見えるようにスクロールする
    <li>このほかに、スクロールバーに関係する xview/yview メソッドが重要</li>
    <li>これはスクロールバーのところで説明する</li>
  </ul>
  <li>位置の指定方法</li>
  <ul>
    <li>n (数値) : n 行目      
    <li>active : 左ボタンを離したときの行
    <li>anchor : 左ボタンを押したときの行
    <li>end : 最後の行、insert() で指定すると最終行の次にデータが追加される
    <li>@x,y : 指定した座標に最も近い行
  </ul>
  <li>セレクションモードが extended のときにドラッグで選択した場合、最初の行が anchor で最後の行が active となる</li>
  <li>したがって、delete に anchor と active を指定すると、選択した行をリストボックスから削除することになる</li>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : 色の選択

import tkinter as tk

root = tk.Tk()
root.option_add('*font', ('', 12))

buff = tk.StringVar()
buff.set("")

# 色の選択
def get_color(event):
    xs = lb.curselection()
    if len(xs) != 0:
        color = lb.get(xs[0])
        buff.set(color)
        la.configure(bg = color)

# ラベルの生成
la = tk.Label(root, textvariable = buff)
la.pack(fill = tk.X)

# リストボックスの生成
lb = tk.Listbox(root)
lb.pack()

# バインディング
lb.bind('&lt;ButtonRelease-1&gt;', get_color)

for x in ['red', 'green', 'blue', 'yellow', 'cyan', 'pink', 'white', 'black']:
    lb.insert('end', x)

root.mainloop()
</pre>
  <ul>
    <li>リストボックスに表示された色を選択してラベルの背景色を変更する</li>
    <li>関数 get_color() で選択した色を取得する</li>
    <li>curselection() の返り値 xs が空リストの場合は未選択</li>
    <li>xs の先頭に選択した行の番号が格納されている</li>
    <li>get_color() はリストボックスのイベント ButtonRelease-1 にバインドする</li>
    <li>イベントには &lt;ListboxSelect&gt; があるので、それにバインドしてもよい</li>
    <ul>
      <li>具体的には lb.bind('&lt;&lt;ListboxSelect&gt;&gt;', get_color) とする</li>
    </ul>
    <li>&lt;ListboxSelect&gt; はリストボックス上でマウスをドラッグしている間も発生する</li>
    <li>その間ラベルの背景色が変わることになる</li>
    <li>&lt;ListboxSelect&gt; にバインドするときは selectmode を single に設定したほうが使いやすいかもしれない</li>
  </ul>
</ul>
<p><img src="py3_img/listbox1.png"> 初期状態</p>
<p><img src="py3_img/listbox2.png"> yellow を選択</p>
<p><img src="py3_img/listbox3.png"> pink を選択</p>
<h4 id="chap13">●スクロールバー</h4>
<ul>
  <li>スクロールバーはほかのウィジェットの表示範囲を制御するウィジェット</li>
  <ul>
    <li>スクロールバーはその両端に矢印がつき、中央付近には四角いスライダが表示される</li>
    <li>矢印を左クリックするか、スライダをドラッグすることで表示位置を変更する</li>
    <li>また、矢印とスライダの隙間をクリックすると 1 画面分スクロールする</li>
  </ul>
  <li>スクロールバーは Scrollbar() でオブジェクトを生成する</li>
  <li>Scrollbar() で主に使用されるオプションを下表に示す</li>
</ul>
<table border=1>
<caption>表：Scrollbar() の主なオプション</caption>
<tbody>
<tr><td>orient</td><td>スクロールバーの方向</td></tr>
<tr><td>troughcolor</td><td>矢印とスクロールの隙間の色</td></tr>
<tr><td>command</td><td>スクロールバーが動いたときに実行するメソッド</td></tr>
</tbody>
</table>
<ul>
  <li>orient で horizontal または h を指定すると水平になり、vertical または v で垂直になる</li>
  <li>command はスクロールバーを動かしたときに実行する関数を指定する</li>
  <li>リストボックスと連動させる場合、ここにリストボックスの表示位置を制御するメソッド xview() や yview() を指定する</li>
</ul>
<ul>
  <li>スクロールバーのメソッド set() はリストボックスのオプション xscrollcommand / yscrollcommand で使用する</li>
<pre class="item">
xscrollcommand = scrollbar_widget.set
</pre>
  <li>リストボックスで表示範囲が変更されると set() が実行される</li>
  <li>このとき、リストボックスの表示範囲 (first, last) が引数として渡される</li>
  <li>first と last は 0 から 1 の間の実数で、表示されている範囲を表す</li>
  <li>たとえば、リストボックスの全体の行数が 100 行で 20 行目から 30 行分表示されているとすると、set(0.2, 0.5) となる</li>
  <li>つまり、データ全体の 20 % の位置から 50 % の位置まで表示されていることを表す</li>
</ul>
<ul>
  <li>スクロールバーを変更したとき、それをリストボックスに反映させるためのオプションが command</li>
  <li>ここにリストボックスのメソッド xview や yview を指定する</li>
<pre class="item">
command = listbox_widget.yview
</pre>
  <li>スクロールバーの操作によって、メソッドには次に示す文字列が引数として渡される</li>
  <ul>
    <li>'moveto', 数値<br>指定した数値 (0 - 1.0) の位置までスクロール
    <li>'scroll', n, unit<br>上または下に n 単位スクロールする
    <li>'scroll', n, pages<br>上または下に n ページスクロールする
  </ul>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : フォントの表示

import tkinter as tk
import tkinter.font as font

root = tk.Tk()

# フォントの選択
def get_font(event):
    xs = lb.curselection()
    if len(xs) != 0:
        la.configure(font = (lb.get(xs[0]), 12))

# ラベルの生成
la = tk.Label(root, text = "Hello, world!, こんにちは世界!!", font = ('', 12))
la.pack(fill = tk.X)

# リストボックスの生成
lb = tk.Listbox(root, selectmode = 'single', height = 20, width = 40)
lb.pack(side = 'left')

# スクロールバーの生成
sb = tk.Scrollbar(root, command = lb.yview)
sb.pack(side = 'left', fill = 'y')

lb.configure(yscrollcommand = sb.set)

# バインディング
lb.bind('&lt;&lt;ListboxSelect&gt;&gt;', get_font)

for x in sorted(font.families()):
    lb.insert('end', x)

root.mainloop()
</pre>
  <ul>
    <li>使用できるフォント名は tkinter.font.families() で取得できる (返り値はリスト)</li>
    <li>フォント名をリストボックスに入れて、右横にスクロールバーを付ける</li>
    <li>lb と sb の pack() には side = 'left' を指定する</li>
    <li>sb.pack() には fill = 'y' の指定も必要になる</li>
    <li>リストボックスを生成するとき、まだ Scrollbar() は実行されていない</li>
    <li>Scrollbar() を実行してから configure() で yscrollcommand に sb.set をセットする</li>
    <li>関数 get_font() で選択したフォント名を取得し、ラベルの font を変更する</li>
  </ul>
</ul>
<p><img src="py3_img/scrollbar1.png"> 初期状態</p>
<p><img src="py3_img/scrollbar2.png"> Consolas を選択</p>
<p><img src="py3_img/scrollbar3.png"> Ricty Diminished を選択</p>
<p><img src="py3_img/scrollbar4.png"> メイリオを選択</p>

<h4 id="chap14">●Gridder</h4>
<ul>
  <li>メソッド grid() はウィジェットを格子状に配置するジオメトリーマネージャ (Gridder)</li>
  <li>ウィンドウを M 行 N 列のセルに分割し、そこにウィジェットを配置する</li>
  <li>x 方向の位置はオプション column で指定する</li>
  <li>y 方向の位置は row で指定する</li>
  <li>オプション columnspan() と rowspan() は、複数のセルにまたがってウィジェットを配置するために使う</li>
  <ul>
    <li>columnspan は x 方向にまたがるセルの数を指定する</li>
    <li>rowspan は y 方向にまたがるセルの数を指定する</li>
  </ul>
  <li>grid() はオプション sticky でウィジェットを引き伸ばす</li>
</ul>
<table border=1>
<caption>表：sticky オプション</caption>
<tbody>
<tr><td>n</td><td>上寄せ</td></tr>
<tr><td>s</td><td>下寄せ</td></tr>
<tr><td>e</td><td>右寄せ</td></tr>
<tr><td>w</td><td>左寄せ</td></tr>
<tr><td>ns</td><td>上下方向に引き伸ばす</td></tr>
<tr><td>ew</td><td>左右方向に引き伸ばす</td></tr>
</tbody>
</table>
<ul>
  <li>sticky は pack() のオプション anchor と同じ機能もあわせ持っている</li>
</ul>
<ul>
  <li>簡単な使用例 (1)</li>
<pre class="list">
リスト : ボタンを格子状に配置

import tkinter as tk

root = tk.Tk()

for x in range(5):
    for y in range(5):
        tk.Button(text = ' {} '.format(y * 5 + x + 1)).grid(column = x, row = y, sticky = 'ew')

root.mainloop()
</pre>
</ul>
<p><img src="py3_img/gridder.png"></p>
<ul>
  <li>簡単な使用例 (2)</li>
<pre class="list">
リスト : 履歴付き式入力電卓

import tkinter as tk
from math import *

root = tk.Tk()
root.option_add("*font", ('', 14))

# 式を格納するオブジェクト
buffer = tk.StringVar()
buffer.set("")

# Entry の生成
e = tk.Entry(root, width = 30, textvariable = buffer)

# Listbox の生成
lb = tk.Listbox(root, width = 30, selectmode = 'single')

# Scrollbar の生成
sb1 = tk.Scrollbar(root, orient = 'v', command = lb.yview)
sb2 = tk.Scrollbar(root, orient = 'h', command = lb.xview)

# Listbox の設定
lb.configure(yscrollcommand = sb1.set)
lb.configure(xscrollcommand = sb2.set)

# 計算
def calc(event):
    expr = buffer.get()
    lb.insert('end', expr)
    lb.see('end')
    value = eval(expr)
    buffer.set(str(value))
    e.icursor(0)

# 式の取り出し
def get_expr(event):
    xs = lb.curselection()
    if len(xs) != 0:
        buffer.set(lb.get(xs[0]))
        e.focus_set()

# バインディング
e.bind('&lt;Return&gt;', calc)
lb.bind('&lt;Double-1&gt;', get_expr)

# grid による配置
e.grid(row = 0, columnspan = 2, sticky = 'ew')
lb.grid(row = 1, column = 0, sticky = 'nsew')
sb1.grid(row = 1, column = 1, sticky = 'ns')
sb2.grid(row = 2, column = 0, sticky = 'ew')

# フォーカスの設定
e.focus_set()

root.mainloop()
</pre>
  <ul>
    <li>エントリーは 2 つのセル (0, 0) と (0, 1) にまたがって配置するので columnspan を 2 に設定する</li>
    <li>リストボックスはセル (1, 0) に配置する</li>
    <li>リストボックスの右側のセル (1, 1) と下側のセル (2, 0) にスクロールバーをセットする</li>
    <li>エントリーではリターンキーが入力されると関数 calc() が実行される</li>
    <li>calc() では式をリストボックスに代入し、計算結果を buffer にセットする</li>
    <li>メソッド see() を使ってセットした計算式が見えるようにスクロールする</li>
    <li>エントリーのメソッド icursor(index) はカーソルを index の位置に移動する</li>
    <li>今回は先頭 (0) に移動する (最後尾の場合は 'end' または tk.END を指定する)</li>
    <li>リストボックスで行をダブルクリックすると関数 get_expr() が実行される</li>
    <li>選択した式を取り出して buffer にセットし、フォーカスをエントリーにセットする</li>
  </ul>
</ul>
<p> <img src="py3_img/calc1.png" ALT="履歴が残る電卓"> 式の履歴が残るように改造した電卓
</p>
<p> <img src="py3_img/calc2.png" ALT="履歴が残る電卓"> リターンキーを押せば計算結果も履歴に入る
</p>
<p> <img src="py3_img/calc3.png" ALT="履歴が残る電卓"> 式の選択
</p>
<h4 id="chap15">●チェックボタンとラジオボタン</h4>
<ul>
  <li>チェックボタンは Checkbutton() で生成し、ON / OFF のような二者択一の情報を設定するために使う</li>
  <li>ラジオボタンは Radiobutton() で生成し、複数の値からひとつを選ぶ場合に使う</li>
  <li>どちらのウイジェットもオプション text でボタンの名前を指定する</li>
  <li>Radiobutton() は選択する値をオプション value で指定する</li>
  <li>その値を格納するオブジェクトをオプション variable で指定する</li>
  <li>また、オプション command でコールバック関数を指定することもできる</li>
  <li>CheckButton() は値が ON /OFF の 2 通りしかない</li>
  <li>variable には BooleanVar のオブジェクトを指定するといい</li>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : チェックボタンとラジオボタン

import tkinter as tk

root = tk.Tk()
root.option_add('*font', ('', 14))

opts1 = tk.BooleanVar()
opts1.set(True)
opts2 = tk.BooleanVar()
opts2.set(False)
opts3 = tk.BooleanVar()
opts3.set(True)

action = tk.IntVar()
action.set(1)

tk.Label(text ='Check Button').pack()
tk.Checkbutton(text = 'option 1', variable = opts1).pack()
tk.Checkbutton(text = 'option 2', variable = opts2).pack()
tk.Checkbutton(text = 'option 3', variable = opts3).pack()

tk.Label(text ='Radio Button').pack()
tk.Radiobutton(text = 'action A', variable = action, value = 0).pack()
tk.Radiobutton(text = 'action B', variable = action, value = 1).pack()
tk.Radiobutton(text = 'action C', variable = action, value = 2).pack()

root.mainloop()
</pre>
</ul>
<p><img src="py3_img/check.png" alt="チェックボタンとラジオボタン"> チェックボタンとラジオボタン
</p>
<h4 id="chap16">●イメージ</h4>
<ul>
  <li>Tk は標準で GIF, PNG, PPM / PGM 形式の画像ファイルを扱うことがでる</li>
  <ul>
    <li>PNG は Tk 8.6 からサポートされた</li>
    <li>PPM はカラー、PGM はグレイスケールの画像を扱う、UNIX で標準的に用いられるベタフォーマット</li>
  </ul>
  <li>Tkinter の場合、クラス Image を使って画像を取り扱う</li>
  <li>Image のサブクラス BitmapImage が白黒のビットマップ</li>
  <li>サブクラス PhotoImage がカラーイメージを表す</li>
  <li>そのオブジェクトをラベルやボタンなどのウィジェットに使うことができる</li>
  <li>簡単な使用例
<pre class="list">
リスト：画像の表示

import tkinter as tk

root = tk.Tk()

image1 = tk.PhotoImage(file = 'earth.gif')
tk.Label(root, image = image1).pack()

root.mainloop()
</pre>
  <ul>
    <li>PhotoImage() は画像を表すオブジェクトを返す</li>
    <li>オプション file は読み込む画像ファイルを指定する</li>
    <li>earth.gif は Python/Tkinter の配布パッケージに含まれている画像ファイル</li>
    <li>このプログラムでは earthris.gif がカレントディレクトリにあることを仮定している</li>
    <li>ファイルがカレントディレクトリにないとエラーが表示されて動作しないので注意すること</li>
    <li>生成した画像は、次のメソッドを利用することができる</li>
    <ul>
      <li>type(), イメージの種別を返す</li>
      <li>height(), イメージの高さを返す</li>
      <li>weight(), イメージの幅を返す</li>
    </ul>
    <li>ラベルやボタンにイメージを表示するには、オプション image に画像のオブジェクトをセットする</li>
    <li>image は PhotoImage() で作成した画像専用のオプション</li>
    <li>BitmapImage() で作成した画像はオプション bitmap にセットすること</li>
  </ul>
</ul>
<p><img src="py3_img/image1.png"> earth.gif の表示
</p>
<p><img src="py3_img/image2.png"> 上のキャプチャー画像 (image1.png) の表示
</p>
<h4 id="chap17">●ファイルの選択</h4>
<ul>
  <li>Tkinter にはファイルを選択するためのモジュール filedialog が用意されている</li>
  <ul>
    <li>Python2 は tkFileDialog だったが、Ptyhon3 からは filedialog になった</li>
  </ul>
  <li>いろいろな関数が用意されているが、次の関数を使うのが簡単</li>
  <ul>
    <li>askopenfilename(), 入力ファイルを選択
    <li>asksaveasfilename(), 出力ファイルを選択
  </ul>
  <li>これらの関数を実行すると、ファイル選択のウィンドウ (ダイアログ) が開かれる</li>
  <li>ウィンドウ上の操作でディレクトリをたどりファイルを選ぶことができる</li>
  <li>使用できるオプションを示す</li>
  <ul>
    <li>initialdir = ディレクトリ<br>
最初に選択されているディレクトリ
    <li>initialfile = ファイル<br>
最初に選択されているファイル（出力ファイルのみ有効）
    <li>defaultextension = 拡張子<br>
最初に選択されている拡張子
    <li>filetypes = パターン<br>
使用可能なファイル種別と拡張子を指定
    <li>title = 文字列<br>
ダイアログボックスのタイトル
  </ul>
  <li>filetypes はアプリケーションで扱うことができるファイル種別を拡張子で指定し、そのファイルだけを表示する</li>
  <li>指定はリストとタプルで行う</li>
<pre class="item">
filetypes = [ファイル種別, ... ]
ファイル種別 := (名前, (拡張子, ...))
</pre>
  <li>たとえば、GIF/PPM ファイルを指定する場合は次のようになる</li>
<pre class="item">
filetypes = [('Image Files', ('.gif', '.ppm'))]
</pre>
  <li>この場合は GIF と PPM ファイルが一緒に表示される</li>
  <li>次のように指定すると、表示するファイルをダイアログの操作で切り替えることができる</li>
<pre class="item">
filetypes = [('GIF Files', '.gif'),
             ('PPM Files', '.ppm'),
             ('ALL Files', '*')]
</pre>
  <li>指定する拡張子がひとつしかない場合はタプルを使う必要はない</li>
  <li>すべてのファイルを表示する場合はワイルドカード * を使う</li>
  <li>空文字列 '' を指定すると、拡張子のないファイルを表示する</li>
  <li>ファイルを選択すると、ファイル名をフルパス形式で返す</li>
  <li>選択しない (キャンセルした) 場合は、空文字列が返される</li>
</ul>
<ul>
  <li>簡単な使用例</li>
<pre class="list">
リスト : 画像ローダー

import tkinter as tk
import tkinter.filedialog as fd
import sys, os.path

# ファイルの選択
def load_file():
    global image_data, path_name
    filename = fd.askopenfilename(filetypes = [('Image Files', ('.gif', '.png', '.ppm')),
                                               ('GIF Files', '.gif'),
                                               ('PNG Files', '.png'),
                                               ('PPM Files', '.ppm')],
                                  initialdir = path_name)
    if filename != "":
        path_name = os.path.dirname(filename)
        image_data = tk.PhotoImage(file = filename)
        label.configure(image = image_data)

# トップウィンドウ
root = tk.Tk()

# グローバル変数
path_name = os.getcwd()
image_data = tk.PhotoImage(width = 64, height = 64)

# ラベル
label = tk.Label(root, image = image_data)
label.pack()

# メニュー
m0 = tk.Menu(root);
root.configure(menu = m0);

m1 = tk.Menu(m0, tearoff = 0)
m1.add_command(label = 'Open', under = 0, command = load_file)
m1.add_separator
m1.add_command(label = 'Exit', under = 0, command = sys.exit)
m0.add_cascade(label = 'File', under = 0, menu = m1 )

root.mainloop()
</pre>
  <ul>
    <li>メニュー File の下に、ファイルを選択する Open とアプリケーションを終了する Exit の 2 つのメニューを設定する</li>
    <li>グローバル変数 path_name は選択されたファイルのパスを格納する</li>
    <li>askopenfilename() にこのパスを指定することで、次にファイルを選ぶときは同じディレクトリから始めることができる</li>
    <li>初期値はカレントディレクトリ、関数 os.getcwd() で取得する</li>
    <li>アプリケーションの開始時にはファイルは指定されていないので、空のイメージを作って表示しておく</li>
    <li>画像ファイルのロードは関数 load_file() で行う</li>
    <li>askopenfilename() でファイル名を取得する</li>
    <li>モジュール os.path の関数 dirname() でパスを取り出してグローバル変数 path_name にセットする</li>
    <li>dirname() はファイル名からパス部分を取り出して返す</li>
    <li>ファイル名をゲットしたら、それが空文字列でないことを確認する</li>
    <li>新しいイメージを PhotoImage() で生成し、ラベルの configure() で表示するイメージを変更する</li>
  </ul>
</ul>
<p> <img src="py3_img/loadfile1.png" ALT="ファイル選択ダイアログ"> 表示するファイルの選択
</p>
<p> <img src="py3_img/loadfile2.png" ALT="ファイル選択ダイアログ"> GIF ファイルの選択
</p>
<p> <img src="py3_img/loadfile3.png" ALT="ファイル選択ダイアログ"> PNG ファイルの選択
</p>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2019 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Light</a> | <a href="python3.html#python3_tkinter">Python3</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>