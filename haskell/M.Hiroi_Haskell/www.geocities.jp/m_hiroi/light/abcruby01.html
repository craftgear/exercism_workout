<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby プログラミング入門</title>
  <meta name="description" content="Ruby,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881800</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Ruby プログラミング入門</h1>
<h2>第 1 回 Ruby の基礎知識 データ構造編</h2>
<div class="small">
[ PrevPage | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcruby02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> Ruby はまつもとゆきひろ氏によって開発されたオブジェクト指向スクリプト言語です。現在、スクリプト言語と呼ばれているプログラミング言語は、JavaScript, Perl, PHP, Python, Ruby などが有名ですが、その中で Ruby は日本人が設計・開発した唯一のスクリプト言語です。Ruby on Rails (RoR) という Web アプリケーションフレームワークがブレークしたことにより、日本国内にとどまらず全世界に普及しています。
</p>

<p> 現在、最も普及しているスクリプト言語は Web ブラウザ上で動作する JavaScript になりますが、以前は Perl が絶大な人気を誇っていました。Perl はバージョン 5 からオブジェクト指向やリファレンスなど高度な機能が追加され、汎用のプログラミング言語として様々な分野で使われるようになりました。しかしながら、これらの機能が追加されたことにより、Perl はよりいっそう複雑な言語になってしまったように思います。
</p>

<p> これに対し、Ruby は初めからオブジェクト指向言語として設計されているので、すべてのデータをオブジェクトとして統一的に扱うことができます。また、文字列、配列、ハッシュといった高水準のデータだけではなく、モジュール、例外処理、マルチスレッドといった高度な機能がサポートされています。このように多くの機能があるにもかかわらず、Ruby はシンプルでわかりやすいプログラミング言語になっています。
</p>

<p> まつもとゆきひろ氏によると Ruby のポリシーは「ストレスなくプログラミングを楽しむこと (enjoy programming)」とのことです。このため、Ruby には楽しくプログラミングできるような機能がたくさん盛り込まれています。また、バージョン 1.9 になると、笹田耕一氏が開発された YARV (Yet Another Ruby VM) が搭載され、遅いといわれていた Ruby の処理速度もずいぶん速くなりました。今後も幅広い分野で Ruby の普及が進むものと思われます。
</p>

<p> 本稿では、簡単なプログラムを作りながら Ruby の基本からオブジェクト指向機能まで、プログラミング言語としての Ruby の基本的な機能を一通り説明していきたいと思っております。たいしたことはできませんが、お付き合いのほどよろしくお願いいたします。
</p>

<h4>●Ruby のインストール</h4>
<p> Ruby の処理系は公式サイト「オブジェクト指向言語 Ruby (<a href="http://www.ruby-lang.org/ja/">http://www.ruby-lang.org/ja/)</a>」からダウンロードすることができます。Windows 用のバイナリも用意されているので、簡単にインストールすることができます。また、Debian GNU/Linux および Ubuntu 系の OS では下記のコマンドで Ruby 2.3 をインストールすることができます。
</p>
<pre class="item">
sudo apt-get install ruby2.3
</pre>
<p> Ruby を学ぶ場合、irb (interactive ruby) というツールを使うと大変便利です。irb は Ruby の配布パッケージに含まれています。irb を起動すると、メッセージとプロンプトが表示されて、対話モードで Ruby が起動されます。その状態で Ruby の式を入力して簡単に実行することができます。
</p>
<pre>
$ irb
irb(main):001:0&gt; 1 + 2 * 3
=&gt; 7
irb(main):002:0&gt;
</pre> 
<p> 終了する場合は exit と入力してください。本稿は Lubuntu 16.04 on VirtualBox 上で irb を使って Ruby (version 2.3) の基本的な機能を説明します。
</p>

<h4>●Ruby のプログラム</h4>
<p> Ruby は Perl と同じく手続き型のプログラミング言語です。Perl と同様に、Ruby にはプログラムの実行を制御する「文」、データを格納する「変数」、決められた処理を行う「関数」<sup><a href="abcruby01.html#note1">[*1]</a></sup> があります。変数と関数は名前をつけて区別します。名前には、英数字とアンダースコア _ が使えます。英大文字と英小文字は区別されるので、FOO と Foo と foo は異なる名前と判断されます。
</p>

<p> Perl は文の最後をセミコロン ( ; ) で区切りますが、Ruby はセミコロンを付ける必要はありません。関数は Ruby にあらかじめ用意されている「組み込み関数」のほかに、私達ユーザが定義することもできます。もちろん「再帰呼び出し」も可能です。
</p>

<p> Ruby にはいろいろなデータが用意されています。データの種類を「データ型 (data type)」と呼びます。Ruby の場合、基本的なデータ型には「数」と「文字列」があります。高水準なデータ型として「配列」や「ハッシュ」などがあります。
</p>

<p> また、Ruby はオブジェクト指向プログラミングに対応しているので、クラス、メソッド、継承などのオブジェクト指向機能があります。とくに、継承で使われる Mix-in という機能は Ruby の大きな特徴になっています。このほかにも例外処理やマルチスレッドといった高度な機能もサポートされています。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> Ruby の場合、関数はすべてメソッドになります。Ruby は関数のようなメソッドも定義することができるので、ここでは簡単に関数と呼ぶことにします。
</div>

<h4>●Ruby のデータ型</h4>
<p> あらかじめ Ruby に用意されている基本的なデータ型について簡単に説明します。
</p>

<h4>●数</h4>
<p> 数の基本は整数 (integer) と浮動小数点数 (floating point number) です。さっそく irb を使って簡単な例を示しましょう。本稿では irb のプロンプトを irb&gt; で表すことにします。
</p>

<pre>
irb&gt; a = 100
=&gt; 100
irb&gt; a
=&gt; 100
irb&gt; print a
100=&gt; nil
irb&gt; puts a
100
=&gt; nil
irb&gt; b = 1.234
=&gt; 1.234
irb&gt; b
=&gt; 1.234
irb&gt; c = 2 ** 100
=&gt; 1267650600228229401496703205376
irb&gt; c
=&gt; 1267650600228229401496703205376
</pre>

<p> Ruby はＣ/Ｃ++や Java と違い、あらかじめ変数やそのデータ型を宣言する必要はありません。Ruby では変数に値をセットするだけで、その変数を使用することができます。変数に値をセットすることを「代入」といいます。代入には = を使います <sup><a href="abcruby01.html#note2">[*2]</a></sup>。= は代入した値を返します。irb で変数名を入力するとその値が表示されます。また、関数 print() または puts() を使って値を表示することもできます。なお、値をセットしていない変数にアクセスするとエラーになります。
</p>

<p> print() と puts() は指定されたデータを画面 (標準出力) へ出力します。データを出力したあと、puts() は改行しますが print() は改行しません。これらの関数は nil を返します。nil は Ruby のデータの一種で、中身がないことを表す特別なデータです。print() や puts() はデータを表示することが本来の目的で、その返り値に意味はありません。このような場合、Ruby では nil を返すことがよくあります。
</p>

<p> 変数 a には整数 100 を代入し、変数 b には浮動小数点数 1.234 を代入しています。Ruby の整数には桁数の制限がありません。** はべき乗を計算する演算子で、2 の100 乗のような大きな値でも計算することができます。主な算術演算子を表 1 に示します。
</p>

<table border=1>
<caption>表 1 : 算術演算子</caption>
<thead>
  <tr><th>演算子</th><th>操作</th></tr>
</thead>
<tbody>
  <tr><td>-x     </td><td> x の符号を反転</td></tr>
  <tr><td>x + y  </td><td> x と y の和</td></tr>
  <tr><td>x - y  </td><td> x と y の差</td></tr>
  <tr><td>x * y  </td><td> x と y の積 </td></tr>
  <tr><td>x / y  </td><td> x と y の商</td></tr>
  <tr><td>x % y  </td><td> x と y の剰余</td></tr>
  <tr><td>x ** y </td><td> x の y 乗</td></tr>
</tbody>
</table>

<p> 浮動小数点数はＣ言語の倍精度浮動小数点数と同じで、範囲は約 1e-307 から 1e+308 までです。このほかに、有理数 (分数) を扱う Rational と、複素数を扱う Complex があります。
</p>

<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> 代入は x = y = z = 0 のように、複数の変数に同じ値を代入することができます。
</div>

<h4>●文字列</h4>
<p> 文字列 (string) はシングルクオート ' で囲むか、ダブルクオート " で囲んで表します。
</p>

<pre>
irb&gt; a = "hello, world"
=&gt; "hello, world"
</pre>

<p> 文字列には「エスケープシーケンス」を含めることができます。これは、画面に表示することができない文字を表すのに用いられる方法です。よく使われる記号に改行を表す \n とタブを表す \t があります。
</p>

<pre>
irb&gt; print "abc\ndef"
abc
def=&gt; nil
irb&gt; print "abc\tdef"
abc    def=&gt; nil
</pre>

<p> ダブルクオートの場合、エスケープシーケンスの解釈が行われますが、シングルクオートの場合は '\\' と '\'' 以外のエスケープシーケンスは解釈されません。また、ダブルクオートでは「式展開」を行うことができます。"#{ }" で囲まれた部分の式は、その式の結果が文字列に埋め込まれます。シングルクオートの場合、式展開は行われません。
</p>

<pre>
irb&gt; "1 + 2 = #{1 + 2}"
=&gt; "1 + 2 = 3"
</pre>

<p> Ruby では、バッククオート (`) で囲まれた文字列はコマンドとして扱われます。まず最初に変数展開が行われ、その結果がシェルに渡されます。コマンドの実行によって得られた出力が、その文字列の値となります。コマンドの終了ステータスは特殊変数 $? に格納されます。この動作は Perl と同じです。たとえば UNIX 系 OS の場合、print `ls` を実行するとカレントディレクトリの内容が表示されます。
</p>

<p> このほかにも、% を使った文字列表現があります。詳細は Ruby のリファレンス <a href="https://docs.ruby-lang.org/ja/latest/doc/spec=2fliteral.html#percent">％記法</a> をお読みください。
</p>

<h4>●ヒアドキュメント</h4>
<p> ヒアドキュメント (here-document) とは UNIX 系 OS のシェルにある機能で、&lt;&lt; と次に書かれた記号 (終端記号) を指定すると、次の行から終端記号までの複数行を一つの文字列として扱います。簡単な例を示しましょう。
</p>

<pre>
print &lt;&lt;EOF
hello, world
EOF
</pre>

<p> 画面には hello, world と表示されます。&lt;&lt; と EOF の間には空白を入れてはいけません。空白は空の識別子とみなされ、最初に現れる空行までが文字列として扱われます。また、終端記号だけが現れる行までを文字列として扱うので、終端記号の前後に空白を入れてはいけません。
</p>

<p> &lt;&lt; の後ろに定義する終端記号は " や ' や ` で囲むことができます。" で囲まれた場合はヒアドキュメント中で変数展開が行われます。なにも囲まない場合も同じです。' で囲んだ場合は変数展開は行われません。これは文字列の場合と同じです。
</p>

<p> ` で囲んだ場合は、各行をコマンドとして実行し、その実行結果 (コマンドが標準出力へ出力したデータ) がドキュメントの内容になります。たとえば、UNIX 系 OS でカレントディレクトリの内容を取り込みたい場合は、次のようにすればいいでしょう。
</p>

<pre>
print &lt;&lt;`EOF`
ls *.txt
EOF
</pre>

<p> これで拡張子が txt のファイル情報を取り込むことができます。 
</p>

<h4>●配列</h4>
<p> Ruby の配列 (array) はデータを一列に並べたもので、Ｃ/Ｃ++の 1 次元配列や Perl の配列と同様のデータ構造です。配列に格納されたデータを要素といいます。配列の要素は整数値で指定します。これを添字といいます。Ruby の場合、Perl やＣ/Ｃ++と同じく添字は 0 から始まります。
</p>

<p> 配列は角カッコ '[' と ']' で囲み、要素をカンマ ( , ) で区切って表します。[ ] は要素が一つもない空の配列になります。
</p>
<p> 簡単な例を示します。
</p>
<pre>
irb&gt; ary1 = [10, 20, 30, 40, 50]
=&gt; [10, 20, 30, 40, 50]
irb&gt; a = ary1[0]
=&gt; 10
irb&gt; a
=&gt; 10
irb&gt; ary1[4] = 100
=&gt; 100
irb&gt; ary1
=&gt; [10, 20, 30, 40, 100]
irb&gt; ary1[-1]
=&gt; 100
irb&gt; ary1[-2]
=&gt; 40
</pre>

<p> Ｃ/Ｃ++の場合、配列の大きさを宣言する必要がありますが、Ruby の配列は大きさを宣言する必要はありません。配列の大きさは Ruby が自動的に調整してくれます。大きさを自由に変えることができる配列を「可変長配列」といいます。Perl や Python も可変長配列をサポートしています。
</p>

<p> 配列の要素は角カッコ [ ] を使ってアクセスします。これはＣ/Ｃ++や Perl と同じです。配列の要素を取り出して変数に代入することも、配列の要素を書き換えることもできます。添字に負の整数を指定すると、配列の後ろから数えます。ary1[-1] は最後尾の要素 100 になり、ary1[-2] は後ろから 2 番目の要素 40 になります。
</p>

<p> 配列の要素には、いろいろなデータ型が混在していてもかまいません。また、要素に式を書くこともできます。
</p>

<pre>
irb&gt; ary2 = ["a", 10, "b", 20, "c", 30]
=&gt; ["a", 10, "b", 20, "c", 30]
irb&gt; ary2[2]
=&gt; "b"
irb&gt; ary2[3]
=&gt; 20
irb&gt; [1 + 2, 3 - 4, 5 * 6]
=&gt; [3, -1, 30]
</pre>

<p> ary2 の配列は、0, 2, 4 番目の要素が文字列で、1, 3, 5 番目の要素が整数になっています。要素に式を書くと、その式の評価結果が要素になります。
</p>

<p> 配列は入れ子にすることができます。つまり、配列の要素に配列を入れてもかまいません。これで多次元配列を表すことができます。
</p>

<pre>
irb&gt; ary3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
=&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
irb&gt; ary3[0]
=&gt; [1, 2, 3]
irb&gt; ary3[0][1]
=&gt; 2
</pre>

<p> ary3 は配列の中に配列を入れることで 2 次元配列を表しています。ary3 の 0 番目の要素は配列 [1, 2, 3] で、その配列の 1 番目の要素は 2 です。この要素は角カッコを 2 つ使って ary3[0][1] とアクセスすることができます。ary3[0] で 0 番目の配列を取り出し、その配列の 1 番目の要素を [1] で取り出します。
</p>

<h4>●シーケンス</h4>
<p> 配列と文字列にはデータを一列に並べたデータ構造という共通点があります。このようなデータをシーケンス (sequence) と呼びます。Ruby にはシーケンスに適用できる共通の操作があります。角カッコ [ ] は文字列にも適用できます。
</p>

<pre>
irb&gt; s = "abcdef"
=&gt; "abcdef"
irb&gt; s[0]
=&gt; "a"
</pre>

<p> Ruby には「文字」を表すデータ型がないので、s[0] の値は文字列 "a" になります。s[0] = "A" のように代入操作 <sup><a href="abcruby01.html#note3">[*3]</a></sup> を行うこともできます。
</p>

<p> シーケンスには演算子 + と * を適用することができます。
</p>

<pre>
irb&gt; "abc" + "def"
=&gt; "abcdef"
irb&gt; "abc" * 3
=&gt; "abcabcabc"
irb&gt; [1, 2, 3] + [4, 5, 6]
=&gt; [1, 2, 3, 4, 5, 6]
irb&gt; [0] * 8
=&gt; [0, 0, 0, 0, 0, 0, 0, 0]
</pre>

<p> 演算子 + はシーケンスを連結した新しいシーケンスを作り、演算子 * はシーケンスを指定した回数だけ繰り返した新しいシーケンスを作ります。
</p>

<p> Ruby はシーケンスの部分列を簡単に取り出すことができます。この操作を「スライス」と呼びます。表 2 にスライス操作を示します。
</p>

<table border=1>
<caption>表 2 : スライス操作</caption>
<thead>
  <tr><th>操作</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td>seq[s..e]         </td><td>s から e - 1 までのコピー</td></tr>
  <tr><td>seq[s, len]       </td><td>s から s + len - 1 までのコピー</td></tr>
  <tr><td>seq[s..e] = seq   </td><td>スライスへの代入</td></tr>
  <tr><td>seq[s, len] = seq </td><td>同上</td></tr>
</tbody>
</table>

<p> seq はシーケンスを表します。スライスによって取り出された部分列は元のシーケンスをコピーしたものです。整数値 s と e で部分列を指定します。s 番目の要素が部分列の先頭になり、e 番目の要素が最後尾になります。また、開始位置 s と長さ len を指定して、部分列を取り出すこともできます。
</p>

<p> 簡単な例を示します。
</p>

<pre>
irb&gt; ary = [0, 1, 2, 3, 4, 5, 6, 7]
=&gt; [0, 1, 2, 3, 4, 5, 6, 7]
irb&gt; ary[2..6]
=&gt; [2, 3, 4, 5, 6]
irb&gt; ary[2..-1]
=&gt; [2, 3, 4, 5, 6, 7]
irb&gt; str = "abcdefg"
=&gt; "abcdefg"
irb&gt; str[2..4]
=&gt; "cde"
irb&gt; str[0..-1]
=&gt; "abcdefg"
</pre>

<p> 範囲指定を s..-1 にすると、s 番目から最後尾までの部分列を取り出すことができます。
</p>

<p> スライスへの代入は強力な操作です。指定した部分列を削除し、その部分に右辺のシーケンスを挿入します。簡単な例を示します。
</p>

<pre>
irb&gt; ary = [1, 2, 3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; ary[2..2]
=&gt; [3]
irb&gt; ary[2..2] = [100, 200]
=&gt; [100, 200]
irb&gt; ary
=&gt; [1, 2, 100, 200, 4, 5]
irb&gt;ary[2, 0]
=&gt; []
irb&gt; ary[2, 0] = [10, 20]
=&gt; [10, 20]
irb&gt; ary
=&gt; [1, 2, 10, 20, 100, 200, 4, 5]
irb&gt; ary[2..5]
=&gt; [10, 20, 100, 200]
irb&gt; ary[2..5] = []
=&gt; []
irb&gt; ary
=&gt; [1, 2, 4, 5]
</pre>

<p> ary[2..2] は [3] になりますが、そこに [100, 200] を代入すると、3 が削除されて 100 と 200 が挿入されます。ary[2, 0] は空の配列になりますが、そこに [10, 20] を挿入すると、要素 2 の後ろに 10 と 20 が挿入されます。空の配列を代入すると、要素を削除することができます。同様の操作は mutable (書き換え可) な文字列でも行うことができます。
</p>
<div class="note">
-- note --------<br>
<a name="note3">[*3]</a> Ruby 3.0 になると文字列リテラルは immutable (書き換え不可) なデータになるそうです。Ruby 2.3 の場合、メソッド freeze を実行すると、その文字列は immutable になります。また、ファイルの先頭でマジックコメント # frozen_string_literal: true を記述すると、文字列リテラルは immutable になります。Ruby では # からその行の最後までがコメントになります。
</div>
<h4>●メソッドの呼び出し方法</h4>
<p> Ruby の場合、文字列や配列の操作はメソッドとして定義されています。メソッドは次の形式で呼び出します。
</p>
<pre class="item">
object.method(args, ...)
</pre>
<p> object はデータのことで、その後ろにドット ( . ) を付けて、メソッド名と引数を続けて書きます。Ruby はオブジェクト指向プログラミング言語なので、すべてのデータをオブジェクトとして扱うことができます。メソッドはオブジェクトを操作する関数のことで、Ruby では多くの操作がメソッドとして定義されています。オブジェクト指向機能は本連載の後半で詳しく説明します。
</p>

<p> たとえば、シーケンスに格納されている要素数はメソッド size() または length() で求めることができます。一般に、シーケンスの要素数を「長さ」といいます。簡単な例を示しましょう。
</p>

<pre>
irb&gt; ary = [1, 2, 3, 4, 5]
=&gt; [1, 2, 3, 4, 5]
irb&gt; ary.size
=&gt; 5
irb&gt; "abcdefg".size
=&gt; 7
</pre>

<p> Ruby では関数 (メソッド) を呼び出すとき、引数を囲うカッコを省略することができます。
</p>

<h4>●配列の操作メソッド</h4>
<p> 配列には便利なメソッドが多数用意されています。主なメソッドを表 3 に示します。
</p>

<table border=1>
<caption>表 3 : 配列を操作する主なメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>操作</th></tr>
</thead>
<tbody>
  <tr><td>ary.push(x)     </td><td>ary の最後尾に要素 x を追加する</td></tr>
  <tr><td>ary.pop         </td><td>ary の最後尾から要素を取り出す</td></tr>
  <tr><td>ary.unshift(x)  </td><td>ary の先頭に要素 x を追加する</td></tr>
  <tr><td>ary.shift       </td><td>ary の先頭の要素を取り出す</td></tr>
  <tr><td>ary.index(x)    </td><td>ary の要素 x を探して位置を返す</td></tr>
  <tr><td>ary.insert(i,x) </td><td>ary の i 番目に要素 x を挿入する</td></tr>
  <tr><td>ary.delete(x)   </td><td>ary から要素 x をすべて削除する</td></tr>
  <tr><td>ary.delete_at(i)</td><td>ary の i 番目の要素を削除する</td></tr>
</tbody>
</table>

<p> ary は配列を表します。これらの操作は要素の探索を除いて、配列をコピーせずに直接書き換えることに注意してください。このような動作を「破壊的に修正する」とか「破壊的な操作」といいます。簡単な例を示します。
</p>

<pre>
irb&gt; ary = [1, 2, 3]
=&gt; [1, 2, 3]
irb&gt; ary.push 4
=&gt; [1, 2, 3, 4]
irb&gt; ary
=&gt; [1, 2, 3, 4]
irb&gt; ary.pop
=&gt; 4
irb&gt; ary
=&gt; [1, 2, 3]
irb&gt; ary.insert 0, 10
=&gt; [10, 1, 2, 3]
irb&gt; ary
[10, 1, 2, 3]
irb&gt; ary.delete 2
=&gt; 2
irb&gt; ary
=&gt; [10, 1, 3]
irb&gt; ary.index 3
=&gt; 2
</pre>

<p> このように、配列は破壊的に修正されるので、変数 ary の値は書き換えられた配列になります。
</p>

<h4>●集合演算</h4>
<p> Ruby の配列は集合 (set) として用いることもできます。集合はいくつかの要素を集めたものです。一般に、集合は重複した要素を含まず、要素の順番に意味はありません。なお、要素の重複を許す集合は多重集合 (multi set) と呼ばれます。たとえば、集合 {1, 3, 5, 7} は {7, 5, 3, 1} や {5, 3, 1, 7} と表すこともできます。このように、要素は適当に並べてもかまわないのですが、ある規則で要素を整列させておく場合もあります。
</p>

<p> 配列を集合として扱う演算子を表 4 に示します。
</p>

<table border=1>
<caption>表 4 : 配列の集合演算</caption>
<thead>
  <tr><th>演算子</th><th>操作</th></tr>
</thead>
<tbody>
  <tr><td>ary1 &amp; ary2 </td><td> ary1 と ary2 の積を求める (積集合)</td></tr>
  <tr><td>ary1 | ary2 </td><td> ary1 と ary2 の和を求める (和集合)</td></tr>
  <tr><td>ary1 - ary2 </td><td> ary2 に現れない ary1 の要素を求める (差集合)</td></tr>
</tbody>
</table>

<p> 簡単な例を示しましょう。
</p>
<pre>
irb&gt; a = [1, 2, 3, 4]
=&gt; [1, 2, 3, 4]
irb&gt; b = [1, 2, 5, 6]
=&gt; [1, 2, 5, 6]
irb&gt; a | b
=&gt; [1, 2, 3, 4, 5, 6]
irb&gt; a &amp; b
=&gt; [1, 2]
irb&gt; a - b
=&gt; [3, 4]
irb&gt; b - a
=&gt; [5, 6]
</pre>
<p> このほかにも配列には便利なメソッドが多数ありますが、使うときに詳しく説明することにします。
</p>

<h4>●ハッシュ</h4>
<p> ハッシュ (hashing) は連想配列のことで、Perlでもハッシュ <sup><a href="abcruby01.html#note4">[*4]</a></sup> と呼ばれています。配列が整数値を使って要素を指定するのに対し、ハッシュはキー (key) というデータを使って要素を指定します。一般に、連想配列のキーには文字列が用いられますが、Ruby では他のデータもキーとして用いることができます。
</p>

<p> ハッシュは中カッコ '{' と '}' で囲み、要素をカンマで区切って表します。要素は「キー =&gt; データ」で指定します。{ } は空のディクショナリを表します。
</p>
<p> 簡単な例を示します。
</p>

<pre>
irb&gt; h = {"foo"=&gt;10, "bar"=&gt;20}
=&gt; {"foo"=&gt;10, "bar"=&gt;20}
irb&gt; h["foo"]
=&gt; 10
irb&gt; h["foo"] = 100
=&gt; 100
irb&gt; h["foo"]
=&gt; 100
irb&gt; h["baz"] = 30
=&gt; 30
irb&gt; h
=&gt; {"foo"=&gt;100, "bar"=&gt;20, "baz"=&gt;30}
</pre>

<p> ハッシュのアクセスは配列と同様に角カッコ [ ] を使います。最初に、ハッシュを生成して変数 h にセットします。h["foo"] でキー "foo" のデータを取り出したり、そこにデータを代入すれば、h["foo"] の値を書き換えることができます。また、新しいキー "baz" を追加する場合は、h["baz"] に値を代入すると、ハッシュに "baz" とその値が追加されます。
</p>

<p> このほかにも、Ruby にはハッシュを操作するメソッドが用意されています。表 5 に主なメソッドを示します。
</p>

<table border=1>
<caption>表 5 : ハッシュの主なメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>操作</th></tr>
</thead>
<tbody>
  <tr><td>h.size        </td><td>ハッシュの要素数を返す</td></tr>
  <tr><td>h.delete(key) </td><td>キー key を削除する</td></tr>
  <tr><td>h.clear       </td><td>ハッシュを空にする</td></tr>
  <tr><td>h.keys        </td><td>ハッシュ内のキーを配列に格納して返す</td></tr>
  <tr><td>h.values      </td><td>ハッシュ内の値を配列に格納にして返す</td></tr>
  <tr><td>h.to_a        </td><td>[キー, 値] を格納した配列を返す</td></tr>
</tbody>
</table>

<p> h はハッシュを表します。簡単な使用例を示しましょう。
</p>

<pre>
irb&gt; h = {"foo"=&gt;10, "bar"=&gt;20, "baz"=&gt;30}
=&gt; {"foo"=&gt;10, "bar"=&gt;20, "baz"=&gt;30}
irb&gt; h.keys
=&gt; ["foo", "bar", "baz"]
irb&gt; h.values
=&gt; [10, 20, 30]
irb&gt; h.to_a
=&gt; [["foo", 10]. ["bar", 20], ["baz", 30]]
</pre>

<p> keys(), values(), to_a() において、データの列挙はキーがハッシュに登録された順番で行われます。
</p>

<div class="note">
-- note --------<br>
<a name="note4">[*4]</a> Perl や Ruby で連想配列をハッシュと呼ぶのは、連想配列を実現するアルゴリズムに「ハッシュ法 (hashing)」が用いられているからです。
</div>
<h4>●シンボル</h4>
<p> Ruby の場合、名前の前にコロン ( : ) をつけると、名前を「シンボル (Symbol)」<sup><a href="abcruby01.html#note5">[*5]</a></sup> という immutable (書き換え不可) なデータに変換します。シンボルは文字列や変数名を特定の数値に変換したものです。同じ内容の文字列は同一のシンボルに変換されます。つまり、Ruby の中で同じ名前のシンボルはひとつしか存在しません。文字列からシンボルを得るにはメソッド intern() や to_sym() を使います。
</p>
<pre>
irb&gt; :foo
=&gt; :foo
irb&gt; :bar
=&gt; :bar
irb&gt; "foo".intern
=&gt; :foo
irb&gt; "bar".to_sym
=&gt; :bar
</pre>
<p> ハッシュのキーにシンボルを使う場合は次のように指定することができます。
</p>
<pre class="item">
{名前1: 値1, 名前2: 値2, ... } 
</pre>
<p> { ... }  の中で、名前の後ろにコロン ( : ) を付けると、それをシンボルとして扱います。簡単な例を示しましょう。
</p>
<pre>
irb&gt; h = {foo: 10, bar: 20, baz: 30}
=&gt; {:foo=&gt;10, :bar=&gt;20, :baz=&gt;30}
irb&gt; h[:foo]
=&gt; 10
irb&gt; h[:foo] = 100
=&gt; 100
irb&gt; h
=&gt; {:foo=&gt;100, :bar=&gt;20, :baz=&gt;30}
</pre>
<div class="note">
-- note --------<br>
<a name="note5">[*5]</a> Lisp / Scheme にもシンボルというデータ型があります。ここでは名前 (識別子) を表すデータ型と考えてください。
</div>
<div class="column">
<h4>●コラム TMTOWTDI</h4>
<p> TMTOWTDI (ティムトアディ) は Perl のポリシーで、There's More Than One Way To Do It (やり方はいくらでもある) という意味です。このポリシーにより、Perl のプログラムは様々なスタイルで記述することができるようになっています。このポリシーは Ruby にも影響を与えていて、あるプログラムを作るのに何通りもの方法が用意されています。はじめのうちはどの方法を使ったらよいか混乱するかもしれませんが、プログラムを作っていくうちに、自分にとって使いやすい方法が見つかると思います。やり方は一通りではないので、自分なりの方法でプログラムを作ってみてください。
</p>
</div>
<h4>●おわりに</h4>
<p> 今回は Ruby に用意されている基本的なデータ型について簡単に説明しました。次回は Ruby の基本的な制御構造について説明します。
</p>
</section>
<hr>
<div align="right">
初版 2008 年 10 月 11 日<br>
改訂 2017 年 1 月 15 日
</div>
<hr>
<div class="ce">
<b>Copyright (C) 2008-2017 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="ruby.html#ruby_abc">R u b y</a> | <a href="abcruby02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>