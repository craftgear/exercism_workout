<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / ハッシュ法</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881760</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>ハッシュ法 (hashing)</h2>
<div class="small">
[ <a href="pyalgo03.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo05.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 今回は高速な探索アルゴリズムである「ハッシュ法 (hashing) 」を取り上げます。ハッシュ法は、コンパイラやインタプリタなどで予約語、関数名、変数名などの管理に使われている方法です。また、Perl, Python, Ruby など連想配列（辞書）をサポートしているスクリプト言語では、その実装にハッシュ法が使われています。
</p>

<p> ハッシュ法は、設計をうまく行えば 1 回の比較でデータを見つけることができます。実際、コンパイラの予約語のように探索するデータが固定されている場合は、そのように設計することが可能です。不特定多数のデータが探索対象になる場合は、すべてのデータを 1 回の比較で見つけることはできませんが、数回程度の比較で見つけるように設計することは可能です。 
</p>

<p> Python には辞書 (dictionary) がありますが、今回はアルゴリズムの勉強としてハッシュ法のプログラムを作ってみましょう。
</p>

<h4>●ハッシュ法の仕組み</h4>
<p> ハッシュ法は「ハッシュ表 (hash table) 」と呼ばれるデータを格納する配列と、データを数値に変換する「ハッシュ関数 (hash function) 」を用意します。たとえば、ハッシュ表の大きさを M とすると、ハッシュ関数はデータを 0 から M - 1 までの整数値に変換します。この値を「ハッシュ値 (hash value) 」と呼びます。ハッシュ値はハッシュ表の添字に対応し、この位置にデータを格納します。つまり、ハッシュ関数によってデータを格納する位置を決める探索方法がハッシュ法なのです。
</p>

<p> ハッシュ法で不特定多数のデータを扱う場合、異なるデータでも同じハッシュ値が生成される可能性があります。これをハッシュ値の「衝突 (collision) 」といいます。つまり、データをハッシュ表に登録しようとしても、すでに先客が居座っているわけです。この場合、2 種類の解決方法があります。
</p>

<p> 第 1 の方法はハッシュ表に複数のデータを格納することです。配列には一つのデータしか格納できないので、複数個のデータをまとめて格納する工夫が必要になります。このときよく利用されるデータ構造が「連結リスト (linked list) 」です。ハッシュ表からデータを探索する場合、まずハッシュ値を求め、そこに格納されている連結リストの中からデータを探索します。これを「チェイン法 (chaining) 」といいます。連結リストのほかに二分木を使う方法もあります。
</p>

<p> 第 2 の方法は空いている場所を探して、そこにデータを入れる方法です。この場合、最初とは違うハッシュ関数を用意して、新しくハッシュ値を計算させて場所を決めます。この処理を空いている場所が見つかるまで繰り返します。空き場所が見つからない場合、つまりハッシュ表が満杯の場合はデータを挿入することはできません。この方法を「オープンアドレス法 (open addressing) 」といいます。
</p>

<h4>●チェイン法</h4>
<p> それでは、チェイン法から説明します。チェイン法の場合、ハッシュ表にはデータをそのまま格納しないで、連結リストへの参照を格納します。ハッシュ表からデータを探索する場合、まずハッシュ値を求め、そこに格納されている連結リストの中からデータを探索します。
</p>
<p> 簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
     ハッシュ値 0 1 2 3 4 5 6
    --------------------------
                A B C D E F G
                H I J K L M N
                O P Q R S T U
                V W X Y Z

HASH TABLE 0 [        ] -&gt; [O] -&gt; [H] -&gt; [A] -&gt; None
           1 [        ] -&gt; [B] -&gt; None
           2 [  None  ]
           3 [        ] -&gt; [Y] -&gt; [D] -&gt; None
           4 [  None  ]
           5 [        ] -&gt; [M] -&gt; [F] -&gt; None
           6 [        ] -&gt; [G] -&gt; None

                図 : チェイン法
</pre>
<p> たとえば、上図のようにハッシュ関数とハッシュ表が構成されているとします。データ A の場合、ハッシュ値は 0 なのでハッシュ表の 0 の位置に格納されている連結リストを探索します。A は連結リストの中に登録されているので探索は成功です。データ C の場合、ハッシュ値は 2 ですが、ハッシュ表に連結リストがないので探索は失敗です。データ U の場合、ハッシュ値は 6 ですが、連結リストの中に U が登録されていないので探索は失敗です。
</p>
<p> ところで、チェイン法はハッシュ値の衝突が頻繁に発生すると、データを格納する連結リストが長くなるので、探索に時間がかかることになります。効率良く探索するには、うまくハッシュ値を分散させることが必要になります。
</p>

<h4>●チェイン法のプログラム</h4>
<p> それでは、チェイン法のプログラムを作りましょう。今回はオーソドックスに連結リストを使います。Python の場合、リスト（可変長配列）を使った方が簡単にプログラムできると思いますが、連結リストでも難しくはありません。
</p>
<p> 最初にクラスを定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : ハッシュ表の定義

class HashTable:
    class Cell:
        def __init__(self, key, value, cp = None):
            self.key = key
            self.value = value
            self.next = cp

    def __init__(self, func, size):
        self.size = 0
        self.hash_size = size
        self.hash_table = [None] * size
        self.hash_func = func
</pre>
<p> クラス名は HashTable とし、その中で連結リストのセル (Cell) を定義します。Cell のインスタンス変数 key はキーを、value は値を、next は次のセルへの参照を格納します。
</p>
<p> HashTable を生成するときは、キーを整数値に変換する関数 func とハッシュ表の大きさ size を渡します。この func と size からハッシュ値を計算します。func はインスタンス変数 hash_func に、size は hash_size に格納します。そして、ハッシュ表を生成して hash_table にセットします。hash_table の要素は None に初期化しておくことをお忘れなく。
</p>

<p> 次は HashTable の中で使用するメソッドを定義します。
</p>

<pre class="list">
リスト : HashTable で使用するメソッド

    # ハッシュ値の計算
    def _hash_func(self, x):
        return self.hash_func(x) % self.hash_size

    # キーの探索
    def _search(self, key):
        n = self._hash_func(key)
        cp = self.hash_table[n]
        while cp:
            if cp.key == key: return (True, cp)
            cp = cp.next
        return (False, n)
</pre>
<p> メソッド _hash_fucn はハッシュ値を計算して返します。これは与えられた関数 hash_func を呼び出して、hash_size との剰余を計算するだけです。ところで、<a href="index.html#cite">参考文献 [2]</a> ではハッシュ表の大きさを M とすると、<cite>『M を素数にしておくと安心である』</cite> とのことです。
</p>
<p> メソッド _search はハッシュ表から key を探索します。最初に _hash_func でハッシュ値 n を求め、hash_table[n] から先頭のセルを取り出します。あとは、セルを順番にたどっていき、key と等しいセルを見つけたら (True, cp) を返します。見つからない場合は (False, n) を返します。_search は 2 つの値をタプルにまとめて返すことに注意してください。
</p>
<h4>●データの探索と挿入</h4>
<p> データの探索と挿入を行うメソッドは _search を使うと簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : データの探索と挿入

    # データの探索
    def search(self, key):
        x, y = self._search(key)
        if x: return y.value
        return None

    # データの挿入
    def insert(self, key, value):
        x, y = self._search(key)
        if x:
            y.value = value
        else:
            cp = HashTable.Cell(key, value, self.hash_table[y])
            self.hash_table[y] = cp
            self.size += 1
        return value
</pre>
<p> メソッド search はハッシュ表から key を探索し、その値 value を返します。_search を呼び出して、その結果を x, y に受け取ります。x が真ならば key が見つかったので、その値 y.value を返します。そうでなければ None を返します。
</p>
<p> データを挿入するメソッド insert は key を探索し、見つかればその値を value に置き換えます。見つからない場合は key と value をハッシュ表に挿入します。最初に _search を呼び出して key を探索します。x が真ならば key が見つかったので、y.value の値を value に書き換えます。そうでなければ、新しいセルを生成して連結リストの先頭に挿入します。この場合、y はハッシュ値であることに注意してください。
</p>
<h4>●データの削除</h4>
<p> データを削除するメソッド delete はちょっとだけ複雑です。次のリストを見てください。
</p>
<pre class="list">
リスト : データの削除

    def delete(self, key):
        n = self._hash_func(key)
        cp = self.hash_table[n]
        value = None
        if cp:
            if cp.key == key:
                value = cp.value
                self.hash_table[n] = cp.next
                self.size -= 1
            else:
                while cp.next:
                    if cp.next.key == key:
                        value = cp.next.value
                        cp.next = cp.next.next
                        self.size -= 1
                        break
                    cp = cp.next
        return value
</pre>
<p> まず、_hash_func でハッシュ値を求め、ハッシュ表 hash_table から先頭のセルを取り出します。cp が None の場合はデータが見つからないので None を返します。連結リストがある場合は、その中から key を探索します。cp.key と key が等しい場合は、先頭のセルを削除します。これは hash_table[n] の値を cp.next に書き換えるだけです。そうでなければ、連結リストをたどって key を探索します。見つけた場合は、cp.next の値を cp.next.next に書き換えてセルを削除します。最後に削除したキーの値 value を返します。
</p>

<p> あとのプログラムは簡単なので説明を割愛いたします。詳細は <a href="pyalgo04.html#list1">プログラムリスト１</a> をお読みください。
</p>
<h4>●実行例１</h4>
<p> それでは実際に実行してみましょう。次に示す簡単なテストを行ってみました。
</p>

<pre class="list">
# 簡単なテスト
if __name__ == '__main__':
    import random
    hs = 11
    # 適当なハッシュ関数
    def hf(key):
        value = 0
        for x in key:
            value = (value &lt;&lt; 3) + x
        return value

    ht = HashTable(hf, hs)
    count = 1
    keys = [(random.randint(0, 255),random.randint(0, 255)) for x in xrange(15)]
    print keys
    for x in keys:
        if not ht.search(x):
            ht.insert(x, count)
            count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        ht.insert(x, count)
        count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        print ht.search(x),
        print ht.delete(x),
        print ht.search(x),
        print len(ht)
</pre>
<p> ハッシュ関数 hf は単純ですが、これでもハッシュ法は十分に機能します。ハッシュ表のサイズが小さい場合は、要素の和をハッシュ値としてもよいでしょう。ところで、ハッシュ法はハッシュ関数やハッシュ表の大きさによって、性能が大きく左右されます。興味のある方はいろいろ試してみてください。
</p>

<p> 実行結果を示します。
</p>
<pre>
[(246, 26), (179, 39), (200, 51), (124, 137), (4, 31), (153, 234),
 (146, 205), (229, 183), (108, 30), (108, 85), (158, 144), (88, 131),
 (38, 136), (171, 170), (118, 58)]
(38, 136) 13
(158, 144) 11
(118, 58) 15
(200, 51) 3
(229, 183) 8
(108, 85) 10
(108, 30) 9
(246, 26) 1
(153, 234) 6
(124, 137) 4
(4, 31) 5
(179, 39) 2
(171, 170) 14
(146, 205) 7
(88, 131) 12
-----
(38, 136) 28
(158, 144) 26
(118, 58) 30
(200, 51) 18
(229, 183) 23
(108, 85) 25
(108, 30) 24
(246, 26) 16
(153, 234) 21
(124, 137) 19
(4, 31) 20
(179, 39) 17
(171, 170) 29
(146, 205) 22
(88, 131) 27
-----
16 16 None 14
17 17 None 13
18 18 None 12
19 19 None 11
20 20 None 10
21 21 None 9
22 22 None 8
23 23 None 7
24 24 None 6
25 25 None 5
26 26 None 4
27 27 None 3
28 28 None 2
29 29 None 1
30 30 None 0
</pre>

<h4>●実行例２</h4>
<p> もう一つ簡単な例題として、3 次元空間の異なる点 (x, y, z) を n 個作る関数を作ります。要素 x, y, z は 0 から 255 までの整数値とし、乱数で生成することにします。生成する点の個数が少なければ、ハッシュ法を使わなくても線形探索で十分です。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 乱数による座標の生成 (1)

import random, time

def make_data(n):
    buff = []
    while len(buff) &lt; n:
        key = (random.randint(0,255),random.randint(0,255),random.randint(0,255))
        if key not in buff: buff.append(key)
    return buff

# test
for x in [2000, 4000, 8000]:
    start = time.clock()
    make_data(x)
    print time.clock() - start
</pre>
<p> 関数 make_data は乱数で点を一つ生成し、それが今まで生成した点と異なることを in 演算子でチェックします。同じ点がなければ buff にセットします。Python の場合、リストの in 演算子は線形探索なので、点の個数が増えると時間がかかるようになります。実際に 2000, 4000, 8000 個の点を作ったときの実行時間を示します。Windows XP, celeron 1.40 GHz, Python 2.4.2 で実行しました。
</p>
<table border=1>
<caption>表 : 実行時間 (単位 : 秒)</caption>
<thead>
  <tr><th></th><th>2000</th><th>4000</th><th>8000</th></tr>
</thead>
<tbody>
  <tr><td>線形探索</td><td>0.264</td><td>0.983</td><td>3.800</td></tr>
</tbody>
</table>

<p> 点の個数が増えると実行時間が大幅に増加することがわかります。それでは線形探索の代わりにハッシュ法を使ってみましょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 乱数による座標の生成 (2)

import time, random
from hash1 import *

hs = 8191

def hf(key):
    value = 0
    for x in key:
        value = (value <&lt; 3) + x
    return value

def make_data(n):
    ht = HashTable(hf, hs)
    while len(ht) &lt; n:
        key = (random.randint(0,255),random.randint(0,255),random.randint(0,255))
        ht.insert(key, True)
    return ht

for x in [2000, 4000, 8000]:
    start = time.clock()
    make_data(x)
    print time.clock() - start
</pre>
<p> ハッシュ表の大きさは 8191 (素数) としました。実行結果は次のようになります。
</p>
<table border=1>
<caption>表 : 実行時間 (単位 : 秒)</caption>
<thead>
  <tr><th></th><th>2000</th><th>4000</th><th>8000</th></tr>
</thead>
<tbody>
  <tr><td>線形探索</td><td>0.264</td><td>0.983</td><td>3.800</td></tr>
  <tr><td>ハッシュ法</td><td>0.055</td><td>0.112</td><td>0.235</td></tr>
</tbody>
</table>
<p> ハッシュ法の方が速いですね。簡単なハッシュ関数を使いましたが、ハッシュ法の効果は十分に出ています。もちろん、Python の辞書を使った方が速くなります。興味のある方は試してみてください。
</p>
<hr>
<h4>●オープンアドレス法</h4>
<p> 次はオープンアドレス法について説明します。オープンアドレス法の場合、チェイン法とは違ってハッシュ表に直接データをセットするので、衝突が発生したとき別の空き場所を探す手順が必要になります。この手順のことを｢再ハッシュ (rehashing) 」といいます。
</p>
<p> 再ハッシュの手順はいくつかの方法がありますが、その中で最も簡単な方法が「線形走査法 (linear probing) 」です。ハッシュ関数を h(x)、ハッシュ表の大きさを M とすると、k 回目の再ハッシュ関数 h<sub>k</sub>(x) は次の式で表すことができます。
</p>
<pre class="fig">
h<sub>k</sub>(x) = (h(x) + k) mod M
</pre>
<p> 最初の再ハッシュ関数 h<sub>1</sub>(x) は (h(x) + 1) mod M で、2 回目の再ハッシュ関数 h<sub>2</sub>(x) は (h(x) + 2) mod M になります。つまり、線形走査法はハッシュ表の空き場所を順番に調べていく「線形探索」と同じです。本ページでは線形走査法でオープンアドレス法の仕組みを説明することにします。このほかに「二重ハッシュ法 (double hashing) 」という方法がありますが、これはあとで取り上げることにします。
</p>

<h4>●データの挿入と探索</h4>
<p> 最初にデータの挿入から説明します。下図を見てください。
</p>
<pre class="fig">
   ハッシュ表                    ハッシュ表
   ┌───┐                    ┌───┐
   │  ／  │                    │  ／  │
   ├───┤                    ├───┤
   │  Ａ  │                    │  Ａ  ┼─┐ 衝突 (E)
   ├───┤                    ├───┤  │
   │  ／  │                    │  Ｅ  │←┘
   ├───┤                    ├───┤
   │  ／  │                    │  ／  │
   ├───┤                    ├───┤
   │  Ｂ  │                    │  Ｂ  ┼─┐ 衝突 (D, F)
   ├───┤                    ├───┤  │
   │  ／  │                    │  Ｄ  ┼←┤ 衝突 (F)
   ├───┤                    ├───┤  │
   │  Ｃ  │                    │  Ｃ  ┼←┤ 衝突 (F)
   ├───┤                    ├───┤  │
   │  ／  │                    │  Ｆ  │←┘
   └───┘                    └───┘

  A (1), B (4), C (6) を挿入    D (4), E (1), F (4) を挿入

    図 : オープンアドレス法（線形走査法）
</pre>
<p> 最初にデータ A, B, C を挿入します。ハッシュ値の場所 (1, 4, 6 番目) にデータをセットします。次に、データ D を挿入します。ハッシュ値は 4 ですが、B と衝突しています。線形走査法の場合、次の場所は (4 + 1) mod 8 で 5 になります。そこで、D を 5 番目にセットします。同様に E を挿入しますが A と衝突しているので、その隣の場所 (2) に E をセットします。
</p>
<p> 最後に F を挿入しますが、B と衝突しています。そこで再ハッシュを行いますが、1 回目は (4 + 1) mod 8 = 5 で D と衝突します。2 回目は (4 + 2) mod 8 = 6 ですが、C と衝突します。3 回目で (4 + 3) mod 8 = 7 になり、この場所に F を挿入します。
</p>

<p> データの探索も簡単です。データのハッシュ値 n を求め、ハッシュ表の n 番目に格納されているデータと比較します。等しい場合は探索成功です。そうでなければ、再ハッシュを行って次のデータと比較します。そこが空き場所ならば、探索は失敗となります。
</p>
<p> たとえば B を探す場合、ハッシュ値は 4 なので、ハッシュ表の 4 番目に格納されている値と比較します。この場合は等しいので探索成功です。F を探索する場合、最初に B と比較します。次に、再ハッシュを行い 5, 6, 7 番目と順番にデータを比較していきます。そして、7 番目の F で探索成功となります。ハッシュ値が 1 のデータ G を探索する場合は、最初に A と比較し、次に E と比較します。その次に 3 番目のデータと比較しますが、空き場所なので探索は失敗となります。
</p>

<h4>●データの削除</h4>
<p> オープンアドレス法の場合、データの探索と挿入だけならば簡単なのですが、データの削除処理がからむとちょっと複雑になります。次の図を見てください。
</p>
<pre class="fig">
   ハッシュ表            ハッシュ表
   ┌───┐            ┌───┐
   │  ／  │            │  ／  │
   ├───┤            ├───┤
   │  Ａ  │            │  Ａ  │
   ├───┤            ├───┤
   │  Ｅ  │            │  Ｅ  │
   ├───┤            ├───┤
   │  ／  │            │  ／  │
   ├───┤            ├───┤
   │  Ｂ  │            │  Ｂ  ┼─┐Ｆの探索
   ├───┤            ├───┤  │
   │  Ｄ  │            │  Ｄ  ┼←┤探索継続
   ├───┤            ├───┤  │
   │  Ｃ  │─Ｃを削除→│  ／  │←┘終了（失敗）
   ├───┤            ├───┤
   │  Ｆ  │            │  Ｆ  │
   └───┘            └───┘

  データを挿入した順番
  A (1), B (4), C (6), D (4), E (1), F (4)

    図 : データの削除 (1)
</pre>
<p> データ C を削除します。単純に考えると、ハッシュ表の 6 番目を空き場所にすればよさそうですが、実はそうはいかないのです。6 番目を空き場所にした状態で、データ F を探索してみましょう。F のハッシュ値は 4 で B と衝突します。そこで、再ハッシュを行うと (4 + 1) mod 8 = 5 になりますが、ここでも D と衝突します。そして、再ハッシュを行い (4 + 2) mod 8 = 6 になりますが、この場所は空き場所なので探索は失敗となります。
</p>
<p> このように、データを単純に削除すると、再ハッシュを行ったデータをたどることができなくなるのです。そこで、削除したことを表すデータ DEL を用意します。そして、データが DEL のときは探索を続けるように手順を変更します。次の図を見てください。
</p>
<pre class="fig">
   ハッシュ表            ハッシュ表
   ┌───┐            ┌───┐
   │  ／  │            │  ／  │
   ├───┤            ├───┤
   │  Ａ  │            │  Ａ  │
   ├───┤            ├───┤
   │  Ｅ  │            │  Ｅ  │
   ├───┤            ├───┤
   │  ／  │            │  ／  │
   ├───┤            ├───┤
   │  Ｂ  │            │  Ｂ  ┼─┐Ｆの探索
   ├───┤            ├───┤  │
   │  Ｄ  │            │  Ｄ  ┼←┤探索継続
   ├───┤            ├───┤  │
   │  Ｃ  │─Ｃを削除→│ＤＥＬ┼←┤探索継続
   ├───┤            ├───┤  │
   │  Ｆ  │            │  Ｆ  │←┘成功
   └───┘            └───┘

  データを挿入した順番
  A (1), B (4), C (6), D (4), E (1), F (4)

    図 : データの削除 (2)
</pre>
<p> データ C を削除する場合、その場所に DEL を書き込みます。そのあと、データ F を探索する場合、D と衝突したあとの再ハッシュで (4 + 2) mod 8 = 6 になります。今度は空き場所ではなく DEL になっているので、再ハッシュを行って探索を続けます。今度はデータ F を見つけることができます。
</p>
<p> なお、新しいデータを挿入する場合は、空き場所または削除した場所を探して、そこにデータを書き込むだけです。
</p>

<h4>●オープンアドレス法の問題点</h4>
<p> オープンアドレス法の場合、データの最大数はハッシュ表の大きさに制限されます。また、データ数が多くなるとハッシュ値の衝突が頻発するため、その性能は劣化してしまいます。とくに線形走査法の場合、再ハッシュのたびに連続した領域を使用するため、データがハッシュ表に分散するのではなく、特定の領域に偏って存在するようになります。このような現象を「クラスター (clustering) 」といいます。これがハッシュ値の衝突をさらに増やすことになり、線形走査法では性能が急激に悪くなります。<a href="index.html#cite">参考文献 [3]</a> によると、線形走査法の場合ハッシュ表の最大使用率は 80 % を目安にするとよいそうです。
</p>
<p> それから、データの削除を行う場合、データだけではなく削除データ (DEL) が増えても性能が劣化することに注意してください。ようするに、オープンアドレス法の場合、ハッシュ表の空き場所が少なくなると性能が劣化するのです。データの挿入と削除を繰り返すと空き場所は減少していくので、データ数が少ない状態でも探索が遅くなる場合もあるのです。このため、オープンアドレス法で削除処理を行うときは、ハッシュ表の再構築を考慮する必要があると思われます。削除処理を行う場合は、チェイン法を使ったほうが簡単かもしれません。
</p>

<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。今回はキー (key) と値 (value) をタプル (key, value) にまとめてハッシュ表に格納します。そして、削除データ (DEL) は空タプル () で表すことにしましょう。空き場所は None で表すことにします。
</p>
<p> 最初にクラスと内部で使用するメソッドを定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : クラスと内部メソッドの定義

class HashTable2:
    def __init__(self, func, size):
        self.size = 0
        self.hash_size = size
        self.hash_func = func
        self.hash_table = [None] * size

    def _hash_func(self, key):
        return self.hash_func(key) % self.hash_size

    def _search_key(self, key):
        n = self._hash_func(key)
        count = 0
        while count &lt; self.hash_size:
            data = self.hash_table[n]
            if data is None:
                break
            if data and data[0] == key:
                return n
            # linear probing
            n = (n + 1) % self.hash_size
            count += 1
        return -1
</pre>
<p> クラス名は HashTable2 としました。インスタンス変数はチェイン法と同じです。メソッド _hash_func はハッシュ値を計算します。これもチェイン法と同じです。メソッド _search_key はハッシュ表からキーを探索し、見つけたキーの位置を返します。
</p>
<p> _search_key では、最初にハッシュ値を求め変数 n にセットします。そして、hash_table[n] からデータを求め変数 data にセットします。data が None であれば探索は失敗です。データが空タプルではなく、data[0] が key に等しい場合は探索成功です。return で位置 n を返します。そうでなければ、再ハッシュ (n + 1) % self.hash_size を行って探索を続行します。count が self.hash_size 以上になる、または空き場所 None を見つけた場合は探索失敗なので -1 を返します。
</p>

<p> データの探索は _search_key を使うと簡単です。
</p>
<pre class="list">
リスト : データの探索

    def search(self, key):
        n = self._search_key(key)
        if n &gt;= 0: return self.hash_table[n][1]
        return None
</pre>
<p> _search_key を呼び出して、返り値 n が 0 以上であれば、その位置に格納されているタプル (key, value) の value を返します。そうでなければ None を返します。
</p>

<p> 次はデータを挿入するメソッド insert を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : データの挿入

    def insert(self, key, value):
        n = self._search_key(key)
        if n &lt; 0:
            n = self._hash_func(key)
            count = 0
            while count &lt; self.hash_size:
                if not self.hash_table[n]:
                    self.size += 1
                    break
                # linear probing
                n = (n + 1) % self.hash_size
                count += 1
            else:
                raise IndexError
        # insert
        self.hash_table[n] = (key, value)
        return value
</pre>
<p> 最初に _search_key を呼び出して同じキーがないか調べます。同じキーが見つかった場合は、キーに対応する値を value に書き換えます。見つからない場合は、空き場所または削除した場所を探して、そこにデータを書き込みます。Python の場合、None も空タプルも偽と判定されるので、not self.hash_table[n] が真ならば、その場所にデータをセットします。
</p>
<p> データがセットされていれば再ハッシュ (n + 1) % self.hash_size を行って、空き場所または削除した場所を探します。count が self.hash_size 以上になったら、空き場所がないので raise でエラー IndexError を送出します。あとは、self.hash_talbe[n] にデータ (key, value) をセットします。Python の場合、タプルは書き換えができないことに注意してください。
</p>

<p> 次はデータの削除を行うメソッド delete を作ります。
</p>
<pre class="list">
リスト : データの削除

    def delete(self, key):
        n = self._search_key(key)
        value = None
        if n &gt;= 0:
            value = self.hash_table[n][1]
            self.hash_table[n] = ()
            self.size -= 1
        return value
</pre>
<p> メソッド _search_key でハッシュ表からキー (key) を探します。見つかった場合は、その値を取り出して value にセットし、ハッシュ表 self.hash_table[n] に空タプル () をセットします。最後に return で value を返します。
</p>
<p> あとはとくに難しいところはないので説明は割愛いたします。詳細は <a href="pyalgo04.html#list2">プログラムリスト２</a> をお読みください。
</p>
<h4>●実行例</h4>
<p> それでは簡単な例題として、3 次元空間の異なる点 (x, y, z) を n 個作ってみましょう。要素 x, y, z は 0 から 255 までの整数値とし、乱数で生成することにします。プログラムは次のようになります。
</p>
<pre class="list">
import time, random
from hash2 import *

hs = 10007

def hf(key):
    value = 0
    for x in key:
        value = (value <&lt; 3) + x
    return value

def make_data(n):
    ht = HashTable2(hf, hs)
    while len(ht) &lt; n:
        key = (random.randint(0,255),random.randint(0,255),random.randint(0,255))
        ht.insert(key, True)
    return ht

for x in [5000, 6000, 7000, 8000, 9000, 10000]:
    start = time.clock()
    make_data(x)
    print x, time.clock() - start
</pre>
<p> ハッシュ表の大きさは 10007 (素数) とし、作成するデータ数を 5000, 6000, 7000, 8000, 9000, 10000 個と増やして実行時間を計測します。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。結果は次のようになりました。
</p>
<table border=1>
<caption>表 : 実行時間 (単位 : 秒)</caption>
<thead>
  <tr><th></th><th>5000</th><th>6000</th><th>7000</th><th>8000</th><th>9000</th><th>10000</th></tr>
</thead>
<tbody>
  <tr><td>チェイン法</td><td>0.144</td><td>0.170</td><td>0.204</td><td>0.236</td><td>0.285</td><td>0.301</td></tr>
  <tr><td>線形走査法</td><td>0.140</td><td>0.167</td><td>0.210</td><td>0.425</td><td>3.937</td><td>11.514</td></tr>
</tbody>
</table>
<p> ハッシュ表の大きさはチェイン法も同じです。オープンアドレス法の場合、ハッシュ表に占めるデータ数が少ないうちはチェイン法と同等以上の性能を発揮しますが、80 % あたりから性能は劣化していき、90 % を超えると急速に悪くなります。そこで、次は｢二重ハッシュ法」を試してみましょう。
</p>
<HR>
<h4>●二重ハッシュ法</h4>
<p> 「二重ハッシュ法 (double hashing) 」は二種類のハッシュ関数を使う方法です。最初のハッシュ関数を h(x), 二番目のハッシュ関数を g(x), ハッシュ表の大きさを M とすると、二重ハッシュ法は次のような手順になります。
</p>
<pre class="fig">
h<sub>0</sub>(x) = h(x) mod M
h<sub>1</sub>(x) = (h(x) + 1 * g(x)) mod M
h<sub>2</sub>(x) = (h(x) + 2 * g(x)) mod M
h<sub>3</sub>(x) = (h(x) + 3 * g(x)) mod M
   ・・・・・・・・
h<sub>k</sub>(x) = (h(x) + k * g(x)) mod M
</pre>
<p> 二重ハッシュ法で g(x) = 1 とすると線形走査法になります。g(x) は簡単な関数にしないと時間がかかってしまいます。実際、g(x) は次に示すような簡単な関数で十分なようです。
</p>
<pre class="fig">
g(x) = q - (h(x) mod q)
</pre>
<p> q は M よりも小さな非負整数値が選ばれます。たとえば、q = 7 とすると、g(x) の値は 1 から 7 までの範囲になります。つまり、二重ハッシュ法は n (1 &lt;= n &lt;= q) 個おきにハッシュ表を調べていくことになります。そして、ハッシュ値によって n の値を変えることで、クラスターの発生を回避することができます。
</p>
<p> ただし、M と n は互いに素になっていないと、ハッシュ表をすべて調べることはできません。このため、M は素数とするのが普通です。また、g(x) の値が 1 にならないように、値を +1 する方法もあります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 二重ハッシュ法

    def _hash_func(self, key):
        n = self.hash_func(key)
        return (n % self.hash_size, 8 - n % 7)

    def _search_key(self, key):
        n, i = self._hash_func(key)
        count = 0
        while count &lt; self.hash_size:
            data = self.hash_table[n]
            if data is None:
                break
            if data and data[0] == key:
                return n
            # double hashing
            n = (n + i) % self.hash_size
            count += 1
        return -1
</pre>
<p> メソッド _hash_func は 2 つのハッシュ値をタプルに格納して返します。2 番目のハッシュ関数は 1 + (7 - n % 7) としました。メソッド _search_key は、_hash_func でハッシュ値を求めて、変数 n と i にセットします。i がハッシュ表を探索するときの増分値になります。したがって、再ハッシュの計算は (n + i) % self.hash_size になります。
</p>
<p> 再ハッシュの計算が異なるだけで、あとは線形走査法のプログラムと同じです。プログラムの説明は割愛しますので、詳細は <a href="pyalgo04.html#list3">プログラムリスト３</a> をお読みください。
</p>
<h4>●実行結果</h4>
<p> それでは、3 次元空間の異なる点 (x, y, z) を n 個作るプログラムで二重ハッシュ法を試してみましょう。ハッシュ表の大きさは 10007 (素数) とし、作成するデータ数を 5000, 6000, 7000, 8000, 9000, 10000 個と増やして実行時間を計測します。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。結果は次のようになりました。
</p>
<table border=1>
<caption>表 : 実行時間 (単位 : 秒)</caption>
<thead>
  <tr><th></th><th>5000</th><th>6000</th><th>7000</th><th>8000</th><th>9000</th><th>10000</th></tr>
</thead>
<tbody>
  <tr><td>チェイン法</td><td>0.144</td><td>0.170</td><td>0.204</td><td>0.236</td><td>0.285</td><td>0.301</td></tr>
  <tr><td>線形走査法</td><td>0.140</td><td>0.167</td><td>0.210</td><td>0.425</td><td>3.937</td><td>11.514</td></tr>
  <tr><td>二重ハッシュ法</td><td>0.144</td><td>0.173</td><td>0.213</td><td>0.317</td><td>1.165</td><td>3.334</td></tr>
</tbody>
</table>
<p> 8000, 9000, 10000 個の場合、線形走査法よりも二重ハッシュ法の方が速くなりました。二重ハッシュ法は簡単な関数でも大きな効果を発揮するようです。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
#
# hash1.py : hashing (chaining)
#
#            Copyright (C) 2006 Makoto Hiroi
#
class HashTable:
    class Cell:
        def __init__(self, key, value, cp = None):
            self.key = key
            self.value = value
            self.next = cp

    def __init__(self, func, size):
        self.size = 0
        self.hash_size = size
        self.hash_table = [None] * size
        self.hash_func = func

    def _hash_func(self, x):
        return self.hash_func(x) % self.hash_size

    def _search(self, key):
        n = self._hash_func(key)
        cp = self.hash_table[n]
        while cp:
            if cp.key == key: return (True, cp)
            cp = cp.next
        return (False, n)

    def search(self, key):
        x, y = self._search(key)
        if x: return y.value
        return None

    def insert(self, key, value):
        x, y = self._search(key)
        if x:
            y.value = value
        else:
            cp = HashTable.Cell(key, value, self.hash_table[y])
            self.hash_table[y] = cp
            self.size += 1
        return value

    def delete(self, key):
        n = self._hash_func(key)
        cp = self.hash_table[n]
        value = None
        if cp:
            if cp.key == key:
                # delete top
                value = cp.value
                self.hash_table[n] = cp.next
                self.size -= 1
            else:
                while cp.next:
                    if cp.next.key == key:
                        value = cp.next.value
                        cp.next = cp.next.next
                        self.size -= 1
                        break
                    cp = cp.next
        return value

    def traverse(self):
        for cp in self.hash_table:
            while cp:
                yield (cp.key, cp.value)
                cp = cp.next

    def __len__(self): return self.size


# test
if __name__ == '__main__':
    import random
    hs = 11
    def hf(key):
        value = 0
        for x in key:
            value = (value &lt;&lt; 3) + x
        return value

    ht = HashTable(hf, hs)
    count = 1
    keys = [(random.randint(0, 255),random.randint(0, 255)) for x in xrange(15)]
    print keys
    for x in keys:
        if not ht.search(x):
            ht.insert(x, count)
            count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        ht.insert(x, count)
        count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        print ht.search(x),
        print ht.delete(x),
        print ht.search(x),
        print len(ht)
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
#
# hash2.py : hashing (open addressing, linear probing)
#
#            Copyright (C) 2006 Makoto Hiroi
#
# None : empty
# ()   : delete
# data : (key, value)

class HashTable2:
    def __init__(self, func, size):
        self.size = 0
        self.hash_size = size
        self.hash_func = func
        self.hash_table = [None] * size

    def _hash_func(self, key):
        return self.hash_func(key) % self.hash_size

    def _search_key(self, key):
        n = self._hash_func(key)
        count = 0
        while count &lt; self.hash_size:
            data = self.hash_table[n]
            if data is None:
                break
            if data and data[0] == key:
                return n
            # linear probing
            n = (n + 1) % self.hash_size
            count += 1
        return -1

    def search(self, key):
        n = self._search_key(key)
        if n &gt;= 0: return self.hash_table[n][1]
        return None

    def insert(self, key, value):
        n = self._search_key(key)
        if n &lt; 0:
            n = self._hash_func(key)
            count = 0
            while count &lt; self.hash_size:
                if not self.hash_table[n]:
                    self.size += 1
                    break
                # linear probing
                n = (n + 1) % self.hash_size
                count += 1
            else:
                raise IndexError
        # insert
        self.hash_table[n] = (key, value)
        return value

    def delete(self, key):
        n = self._search_key(key)
        value = None
        if n &gt;= 0:
            value = self.hash_table[n][1]
            self.hash_table[n] = ()
            self.size -= 1
        return value

    def traverse(self):
        for data in self.hash_table:
            if data: yield data

    def __len__(self): return self.size



# test
if __name__ == '__main__':
    import random
    hs = 11
    def hf(key):
        value = 0
        for x in key:
            value = (value &lt;&lt; 3) + x
        return value

    ht = HashTable2(hf, hs)
    count = 1
    keys = [(random.randint(0, 255),random.randint(0, 255)) for x in xrange(11)]
    print keys
    for x in keys:
        if not ht.search(x):
            ht.insert(x, count)
            count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        ht.insert(x, count)
        count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        print ht.search(x),
        print ht.delete(x),
        print ht.search(x),
        print len(ht)
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
#
# hash3.py : hashing (open addressing, double hashing)
#
#            Copyright (C) 2006 Makoto Hiroi
#
# None : empty
# ()   : delete
# data : (key, value)

class HashTable3:
    def __init__(self, func, size):
        self.size = 0
        self.hash_size = size
        self.hash_func = func
        self.hash_table = [None] * size

    def _hash_func(self, key):
        n = self.hash_func(key)
        return (n % self.hash_size, 7 - n % 7)

    def _search_key(self, key):
        n, i = self._hash_func(key)
        count = 0
        while count &lt; self.hash_size:
            data = self.hash_table[n]
            if data is None:
                break
            if data and data[0] == key:
                return n
            # double hashing
            n = (n + i) % self.hash_size
            count += 1
        return -1

    def search(self, key):
        n = self._search_key(key)
        if n &gt;= 0: return self.hash_table[n][1]
        return None

    def insert(self, key, value):
        n = self._search_key(key)
        if n &lt; 0:
            n, i = self._hash_func(key)
            count = 0
            while count &lt; self.hash_size:
                if not self.hash_table[n]:
                    self.size += 1
                    break
                # double hashing
                n = (n + i) % self.hash_size
                count += 1
            else:
                raise IndexError
        # insert
        self.hash_table[n] = (key, value)
        return value

    def delete(self, key):
        n = self._search_key(key)
        value = None
        if n &gt;= 0:
            value = self.hash_table[n][1]
            self.hash_table[n] = ()
            self.size -= 1
        return value

    def traverse(self):
        for data in self.hash_table:
            if data: yield data

    def __len__(self): return self.size

if __name__ == '__main__':
    import random
    hs = 11
    def hf(key):
        value = 0
        for x in key:
            value = (value &lt;&lt; 3) + x
        return value

    ht = HashTable3(hf, hs)
    count = 1
    keys = [(random.randint(0, 255),random.randint(0, 255)) for x in xrange(11)]
    print keys
    for x in keys:
        if not ht.search(x):
            ht.insert(x, count)
            count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        ht.insert(x, count)
        count += 1
    for x, y in ht.traverse():
        print x, y
    print '-----'
    for x in keys:
        print ht.search(x),
        print ht.delete(x),
        print ht.search(x),
        print len(ht)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo03.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo05.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>