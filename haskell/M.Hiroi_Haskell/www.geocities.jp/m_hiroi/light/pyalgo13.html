<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / AVL 木</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881793</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>AVL 木 (AVL tree) [2]</h2>
<div class="small">
[ <a href="pyalgo12.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo14.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> AVL 木の続きです。前回はデータを挿入したあとで木のバランスを修正する処理を説明しました。今回はデータを削除したあとで木のバランスを修正する処理を詳しく説明します。
</p>

<h4>●データの削除</h4>
<p> それでは AVL 木からデータを削除するとき、どのように木の構成を修正するのか見ていくことにしましょう。
</p>

<p> 二分木からデータを削除する場合、その処理はデータを挿入するよりも複雑です。削除する節が葉の場合や子が一つしかない場合は簡単ですが、子が二つある場合はちょっと面倒です。この場合、削除するデータの右部分木から最小値のデータを探して、その値と交換します。そのようにしても、二分木の条件は崩れません。そして、最小値を格納していた節を削除します。この節は葉か右の子があるだけなので、削除するのは簡単です。詳しい説明は拙作のページ <a href="pyalgo03.html">二分木とヒープ</a> をお読みください。
</p>

<p> AVL 木でデータを削除する場合、データを削除する方法は二分木と同じですが、節を削除したあとで木のバランスをチェックします。節を挿入するときとは逆に、左部分木の節を削除したときは平衡度を一つ減らし、右部分木の節を削除するときは平衡度を一つ増やします。木のバランスをチェックする処理も、データ挿入時のバランスチェックとは異なります。
</p>
<p> たとえば、平衡度が 0 の節から子を削除してみましょう。次の図を見てください。
</p>

<pre class="fig">
    Ｐ                            Ｐ
      ＼          平衡度            ＼        平衡度
        Ａ        Ａ：1               Ａ      Ａ：1
      ／  ＼                        ／  ＼
    Ｂ      Ｃ    Ｂ：0           Ｂ      Ｃ  Ｂ：1
  ／  ＼                        ／  ＼
Ｄ      Ｅ        Ｄ：0       Ｄ      Ｘ      Ｄ：0

              図 : データの削除 (1)
</pre>
<p> 節 E を削除します。E は親節 B の右の子なので、B の平衡度は一つ増えて 1 になります。この場合、B の木の高さは変化しないので、ここで木の修正は終了です。逆に、節 D を削除する場合も、B の平衡度は一つ減って -1 になりますが、木の高さは変化しないので、木の修正は終了です。挿入のときは、平衡度が 0 になったときに木の修正を終了しましたが、削除のときは平衡度が 0 から 1 または -1 になったときに木の修正を終了します。
</p>
<p> 次に、続けて節 D を削除します。次の図を見てください。
</p>
<pre class="fig">
    Ｐ                            Ｐ
      ＼          平衡度            ＼        平衡度
        Ａ        Ａ：1               Ａ      Ａ：0
      ／  ＼                        ／  ＼
    Ｂ      Ｃ    Ｂ：1           Ｂ      Ｃ  Ｂ：0
  ／  ＼                        ／  ＼
Ｄ      Ｘ        Ｄ：0       Ｘ      Ｘ

              図 : データの削除 (2)
</pre>
<p> D は B の左の子なので、B の平衡度を一つ減らして 0 になります。このとき、B の木の高さが一つ減っていることに注目してください。つまり、平衡度が 0 になる場合は、その節の木の高さが一つ減るときなのです。この場合は、B の親節 A の平衡度をチェックします。B は A の左の子なので、A の平衡度は一つ減って 0 になります。この場合も A の高さが一つ減っているので、次は A の親節 P の平衡度をチェックします。
</p>
<p> このように、平衡度が 0 になった場合は、親節の平衡度をチェックするのです。挿入処理とは異なり、平衡度が 0 になっても木の修正処理は終了しません。ご注意ください。
</p>
<p> このあと根の方向に向かって平衡度が崩れていないかチェックしていきます。そして、平衡度が -2 または 2 になったら、左右の部分木の高さを修正します。
</p>

<h4>●木の修正</h4>
<p> それでは、木の修正が必要な場合を考えていきましょう。次の図を見てください。
</p>
<pre class="fig">
                    高さ 平衡度                      高さ 平衡度
    Ａ          Ａ：h+1  -2              Ｃ      Ａ：h    -1
  ／  ＼        Ｂ：h-2  --            ／  ＼    Ｂ：h-2  --
Ｂ      Ｃ      Ｃ：h     0          Ａ      Ｅ  Ｃ：h+1   1
      ／  ＼    Ｄ：h-1  --        ／  ＼        Ｄ：h-1  --
    Ｄ      Ｅ  Ｅ：h-1  --      Ｂ      Ｄ      Ｅ：h-1  --

        (1) 修正前                       (2) 修正後

              図 : １重回転 (その１)
</pre>

<p> 上図は節 A の左部分木 B の高さが一つ減って A の平衡度が -2 になった状態です。節 C の高さを h とすると、B の高さは h - 2 になります。この場合は C の平衡度によって処理を場合わけします。C の平衡度が 0 の場合は A を左回転します。節 D と E の高さは h - 1 なので、A の平衡度は右部分木 D の方が高くなり -1 となります。そして、C の平衡度は A の方が高くなるので 1 になります。これで木の修正は終わりになります。
</p>
<p> C の平衡度が -1 の場合も A を左回転します。次の図を見てください。
</p>
<pre class="fig">
                    高さ 平衡度                      高さ 平衡度
    Ａ          Ａ：h+1  -2              Ｃ      Ａ：h-1   0
  ／  ＼        Ｂ：h-2  --            ／  ＼    Ｂ：h-2  --
Ｂ      Ｃ      Ｃ：h    -1          Ａ      Ｅ  Ｃ：h     0
      ／  ＼    Ｄ：h-2  --        ／  ＼        Ｄ：h-2  --
    Ｄ      Ｅ  Ｅ：h-1  --      Ｂ      Ｄ      Ｅ：h-1  --

        (1) 修正前                       (2) 修正後

              図 : １重回転 (その２)
</pre>
<p> この場合、B と D の高さは同じ (h - 2) になるので、A の平衡度は 0 で高さは h - 1 になります。A の高さは E と同じなので、C の平衡度は 0 で高さは h になります。この場合、さらに親節の平衡度をチェックする必要があります。
</p>
<p> C の平衡度が 1 の場合は２重回転になります。次の図を見てください。
</p>
<pre class="fig">
                   高さ 平衡度                            高さ 平衡度
    Ａ         Ａ：h+1  -2               Ｄ           Ａ：h-1   0
  ／  ＼       Ｂ；h-2  --             ／  ＼         Ｂ：h-2  --
Ｂ      Ｃ     Ｃ：h     1           ／      ＼       Ｃ：h-1   0
      ／  ＼   Ｄ：h-1   0         Ａ          Ｃ     Ｄ：h     0
    Ｄ      Ｅ Ｅ：h-2  --       ／  ＼      ／  ＼   Ｅ：h-2  --
  ／  ＼       Ｆ：h-2  --     Ｂ      Ｆ  Ｇ      Ｅ Ｆ：h-2  --
Ｆ      Ｇ     Ｇ：h-2  --                            Ｇ：h-2  --

    (1) 修正前                  (2) 修正後

    (a) D の平衡度が 0 の場合


                   高さ 平衡度                            高さ 平衡度
    Ａ         Ａ：h+1  -2               Ｄ           Ａ：h-1   0
  ／  ＼       Ｂ；h-2  --             ／  ＼         Ｂ：h-2  --
Ｂ      Ｃ     Ｃ：h     1           ／      ＼       Ｃ：h-1  -1
      ／  ＼   Ｄ：h-1   1         Ａ          Ｃ     Ｄ：h     0
    Ｄ      Ｅ Ｅ：h-2  --       ／  ＼      ／  ＼   Ｅ：h-2  --
  ／  ＼       Ｆ：h-2  --     Ｂ      Ｆ  Ｇ      Ｅ Ｆ：h-2  --
Ｆ      Ｇ     Ｇ：h-3  --                            Ｇ：h-3  --

    (1) 修正前                  (2) 修正後

    (b) D の平衡度が 1 の場合


                   高さ 平衡度                            高さ 平衡度
    Ａ         Ａ：h+1  -2               Ｄ           Ａ：h-1   1
  ／  ＼       Ｂ；h-2  --             ／  ＼         Ｂ：h-2  --
Ｂ      Ｃ     Ｃ：h     1           ／      ＼       Ｃ：h-1   0
      ／  ＼   Ｄ：h-1  -1         Ａ          Ｃ     Ｄ：h     0
    Ｄ      Ｅ Ｅ：h-2  --       ／  ＼      ／  ＼   Ｅ：h-2  --
  ／  ＼       Ｆ：h-3  --     Ｂ      Ｆ  Ｇ      Ｅ Ｆ：h-3  --
Ｆ      Ｇ     Ｇ：h-2  --                            Ｇ：h-2  --

    (1) 修正前                  (2) 修正後

    (c) D の平衡度が -1 の場合

              図 : ２重回転
</pre>
<p> この場合は節 C を右回転してから節 A を左回転します。そして、平衡度の修正は節 D の平衡度により 3 通りに場合分けされます。これは挿入処理で２重回転を行ったとき、平衡度の修正処理と同じになります。
</p>
<p> (a) は D の平衡度が 0 の場合です。F と G の高さが同じ (h - 2) なので、A, C, D の平衡度は 0 になります。(b) は D の平衡度が 1 の場合です。G の高さが一つ低いので、C の平衡度が -1 で、A と D の平衡度は 0 になります。(c) は D の平衡度が -1 の場合です。今度は F の高さが一つ低いので、A の平衡度が 1 になり、C と D の平衡度が 0 になります。どの場合も節 D の平衡度は 0 になるので、さらに親節の平衡度をチェックする必要があります。
</p>

<p> 右部分木が一つ低くなる場合も同様の処理になります。１重回転と２重回転の様子を下図に示します。
</p>
<pre class="fig">
                    高さ 平衡度                      高さ 平衡度
        Ａ      Ａ：h+1   2          Ｂ          Ａ：h     1
      ／  ＼    Ｂ：h     0        ／  ＼        Ｂ：h+1  -1
    Ｂ      Ｃ  Ｃ：h-2  --      Ｄ      Ａ      Ｃ：h-2  --
  ／  ＼        Ｄ：h-1  --            ／  ＼    Ｄ：h-1  --
Ｄ      Ｅ      Ｅ：h-1  --          Ｅ      Ｃ  Ｅ：h-1  --

        (1) 修正前                       (2) 修正後

              図 : １重回転 (その１)


                    高さ 平衡度                      高さ 平衡度
        Ａ      Ａ：h+1   2          Ｂ          Ａ：h-1   0
      ／  ＼    Ｂ：h     1        ／  ＼        Ｂ：h     0
    Ｂ      Ｃ  Ｃ：h-2  --      Ｄ      Ａ      Ｃ：h-2  --
  ／  ＼        Ｄ：h-1  --            ／  ＼    Ｄ：h-1  --
Ｄ      Ｅ      Ｅ：h-2  --          Ｅ      Ｃ  Ｅ：h-2  --

        (1) 修正前                       (2) 修正後

              図 : １重回転 (その２)
</pre>
<pre class="fig">
                   高さ 平衡度                            高さ 平衡度
        Ａ      Ａ：h+1   2               Ｅ           Ａ：h-1   0
      ／  ＼    Ｂ；h    -1             ／  ＼         Ｂ：h-2   0
    Ｂ      Ｃ  Ｃ：h-2  --           ／      ＼       Ｃ：h-2  --
  ／  ＼        Ｄ：h-2  --         Ｂ          Ａ     Ｄ：h-2  --
Ｄ      Ｅ      Ｅ：h-1   0       ／  ＼      ／  ＼   Ｅ：h     0
      ／  ＼    Ｆ：h-2  --     Ｄ      Ｆ  Ｇ      Ｃ Ｆ：h-2  --
    Ｆ      Ｇ  Ｇ：h-2  --                            Ｇ：h-2  --

    (1) 修正前                  (2) 修正後

    (a) E の平衡度が 0 の場合


                   高さ 平衡度                            高さ 平衡度
        Ａ      Ａ：h+1   2               Ｅ           Ａ：h-1  -1
      ／  ＼    Ｂ；h    -1             ／  ＼         Ｂ：h-1   0
    Ｂ      Ｃ  Ｃ：h-2  --           ／      ＼       Ｃ：h-2  --
  ／  ＼        Ｄ：h-2  --         Ｂ          Ａ     Ｄ：h-2  --
Ｄ      Ｅ      Ｅ：h-2   1       ／  ＼      ／  ＼   Ｅ：h     0
      ／  ＼    Ｆ：h-2  --     Ｄ      Ｆ  Ｇ      Ｃ Ｆ：h-2  --
    Ｆ      Ｇ  Ｇ：h-3  --                            Ｇ：h-3  --

    (1) 修正前                  (2) 修正後

    (b) E の平衡度が 1 の場合


                   高さ 平衡度                            高さ 平衡度
        Ａ      Ａ：h+1   2               Ｅ           Ａ：h-1   0
      ／  ＼    Ｂ；h    -1             ／  ＼         Ｂ：h-1   1
    Ｂ      Ｃ  Ｃ：h-2  --           ／      ＼       Ｃ：h-2  --
  ／  ＼        Ｄ：h-2  --         Ｂ          Ａ     Ｄ：h-2  --
Ｄ      Ｅ      Ｅ：h-2  -1       ／  ＼      ／  ＼   Ｅ：h     0
      ／  ＼    Ｆ：h-3  --     Ｄ      Ｆ  Ｇ      Ｃ Ｆ：h-3  --
    Ｆ      Ｇ  Ｇ：h-2  --                            Ｇ：h-2  --

    (1) 修正前                  (2) 修正後

    (c) E の平衡度が -1 の場合

              図 : ２重回転
</pre>
<h4>●プログラムの作成</h4>
<p> それでは、データを削除する関数 delete を作成します。節を削除した場合、根の方に向かって平衡度をチェックしていく処理が必要になります。二分木では、データの削除を再帰呼び出しでプログラムしましたが、平衡度のチェックを組み込むには少々面倒なので、ループに展開することにします。単純なループでは、たどってきた経路がわからなくなるので、配列 path を用意して通過した節を記憶します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : データの削除

def delete(root, x):
    if root is None: return None    # 空の木
    path = []                       # 経路
    node = _search(root, x, path)   # 探索
    if node is None: return root    # 削除データなし
    if node.left is not None and node.right is not None:
        # 子が二つある場合
        # 右部分木の最小値を探して置き換える
        path.append((node, RIGHT))
        min_node = _search_min(node.right, path)
        node.data = min_node.data
        node = min_node
    if len(path) &gt; 0:
        pnode, dir = path[len(path) - 1]
    else:
        pnode = None
    # 節を削除する
    if node.left is None:
        cnode = node.right
    else:
        cnode = node.left
    if pnode is None:
        return cnode                 # root の削除
    elif dir == LEFT:
        pnode.left = cnode
    else:
        pnode.right = cnode
    return balance_delete(root, path)
</pre>
<p> 引数 root が None の場合は空の木なので削除するデータはありません。None を返します。経路は配列 path に格納します。次に、関数 _search でデータ x を格納している節を探します。このとき、たどった節を path に格納します。path の要素は節と部分木の種別 (LEFT or Right) をタプルにまとめたものです。返り値が None の場合は x が見つからないので、root をそのまま返します。
</p>
<p> 削除する節 node に子が二つある場合は、右部分木 node.right から最小値を探して、node.data と置き換えます。最小値を格納している節は関数 _serach_min で求めます。このときも、たどった節を path に格納します。関数 _serach_min を呼び出す前に、(node, RIGHT) を path に追加することをお忘れなく。そして、node.data の値を min_node.data に書き換えて、削除する節 node に min_node をセットします。
</p>
<p> 次は node を削除します。まず、node の親節と削除した部分木の種別を pnode と dir にセットします。そして、node の子を cnode にセットします。ここでは、node の子は多くても一つしかないことに注意してください。
</p>
<p> もしも pnode が None であれば、ルートの節を削除するので cnode を返します。この場合、AVL 木は cnode だけしかありません。cnode が None であれば、最後のデータを削除したので空の木になります。どちらの場合でも、木のバランスを修正する必要はありません。
</p>
<p> そうでなければ、pnode の子を cnode に書き換えます。dir が LEFT であれば pnode.left に cnode をセットし、そうでなければ pnode.right に cnode をセットします。最後に、木のバランスをチェックする関数 balance_delete を呼び出します。
</p>

<p> 次は、データを探索する関数 _search と最小値を探す関数 _search_min を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : データと最小値の探索

# データを探す
def _search(node, x, path):
    while node is not None:
        if node.data == x: return node
        if x &lt; node.data:
            path.append((node, LEFT))
            node = node.left
        else:
            path.append((node, RIGHT))
            node = node.right
    return None

# 最小値を探す
def _search_min(node, path):
    while node.left is not None:
        path.append((node, LEFT))
        node = node.left
    return node
</pre>
<p> どちらの関数も繰り返しでプログラムしています。たどった経路を path に格納する処理を追加しただけなので、難しいところはないでしょう。
</p>

<p> 次は、木のバランスを修正する関数 balance_delete を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : バランスの修正

def balance_delete(root, path):
    while len(path) &gt; 0:
        new_node = None
        pnode, dir = path.pop()  # pnode = 節, dir = 削除した部分木
        if dir == LEFT:
            pnode.balance -= 1   # left が -1, right が +1
        else:
            pnode.balance += 1
        b = pnode.balance
        if b &gt; 1:
            if pnode.left.balance &lt; 0:
                # ２重回転
                pnode.left = rotate_left(pnode.left)
                new_node = rotate_right(pnode)
                update_balance(new_node)
            else:
                # １重回転
                new_node = rotate_right(pnode)
                if new_node.balance == 0:
                    new_node.balance = -1
                    pnode.balance = 1
                else:
                    new_node.balance = 0
                    pnode.balance = 0
        elif b &lt; -1:
            if pnode.right.balance &gt; 0:
                # ２重回転
                pnode.right = rotate_right(pnode.right)
                new_node = rotate_left(pnode)
                update_balance(new_node)
            else:
                # １重回転
                new_node = rotate_left(pnode)
                if new_node.balance == 0:
                    new_node.balance = 1
                    pnode.balance = -1
                else:
                    new_node.balance = 0
                    pnode.balance = 0
        elif b != 0:
            break      # b == 1 or b == -1 は修正終了
        # 子の付け替え
        if new_node is not None:
            if len(path) == 0: return new_node   # root になる
            gnode, gdir = path[len(path) - 1]    # pnode の親
            if gdir == LEFT:
                gnode.left = new_node
            else:
                gnode.right = new_node
            if new_node.balance != 0: break      # 修正終了
    return root
</pre>
<p> path にデータがある間はバランスのチェックを行います。変数 new_node は回転操作した節 (部分木) をセットします。変数 pnode は平衡度をチェックする節、変数 dir は節を削除した部分木の種別を表します。path からデータを取り出して pnode と dir にセットします。dir が LEFT ならば pnode.balance を一つ減らし、RIGHT ならば一つ増やします。そして、平衡度を変数 b にセットします。
</p>
<p> b が 1 よりも大きい場合は右部分木の高さが 2 つ低くなったので、木の修正を行います。pnode.left の平衡度が -1 の場合は２重回転を行います。pnode.left を左回転して、pnode を右回転します。回転した木は new_node にセットします。そして、平衡度を関数 update_balance で修正します。
</p>
<p> pnode.left の平衡度が 0 か 1 の場合は１重回転を行います。pnode を右回転して new_node にセットします。new_node の平衡度が 0 の場合は、new_node.balance を -1 に、pnode.balance を 1 に書き換えます。そうでなければ、new_node と pnode の平衡度を 0 に書き換えます。
</p>

<p> b が -1 よりも小さい場合は左部分木の高さが 2 つ低くなったので、木の修正を行います。pnode.right の平衡度が -1 の場合は２重回転を行います。pnode.right を右回転して、pnode を左回転します。回転した木は new_node にセットします。そして、平衡度を関数 update_balance で修正します。
</p>
<p> pnode.right の平衡度が 0 か 1 の場合は１重回転を行います。pnode を左回転して new_node にセットします。new_node の平衡度が 0 の場合は、new_node.balance を 1 に、pnode.balance を -1 に書き換えます。そうでなければ、new_node と pnode の平衡度を 0 に書き換えます。
</p>

<p> 次に、b が 0 でない場合 (b == 1 または b == -1 の場合) は、修正は必要ないので break で while ループを脱出します。最後に root を返します。b が 0 の場合はバランスのチェックを続行することに注意してください。
</p>

<p> 次に、回転操作を行った場合は子の付け替え処理を行います。もしも、path にデータがなければ、new_node がルートになります。return で new_node を返します。次に、path より親節を取り出して gnode と gdir にセットします。gdir が LEFT の場合は gnode.left に、RIGTH の場合は gnode.right に new_node をセットします。そして、new_node の平衡度をチェックし、0 であればバランスのチェックを続行し、そうでなければ break で while ループを脱出して修正処理を終了します。
</p>
<ul>
  <li><a href="pyalgo12.html#list1">プログラムリスト</a>
</ul>
<h4>●データ削除のテスト</h4>
<p> それでは、ここでデータ削除のテストを行ってみましょう。テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : データ削除の簡単なテスト

import avlnode

# 木の表示
def print_node(node, n):
    if node:
        print_node(node.left, n + 1)
        print '    ' * n, node.data
        print_node(node.right, n + 1)

a = None   # AVL tree

for x in range(7):
    a = avlnode.insert(a, x)
print_node(a, 0)

for x in range(7):
    print 'delete', x
    a = avlnode.delete(a, x)
    print_node(a, 0)
    print '-----'
</pre>
<p> 実行結果を示します。
</p>
<pre>
         0
     1
         2
 3
         4
     5
         6
-----
delete 0
     1
         2
 3
         4
     5
         6
-----
delete 1
     2
 3
         4
     5
         6
-----
delete 2
     3
         4
 5
     6
-----
delete 3
     4
 5
     6
-----
delete 4
 5
     6
-----
delete 5
 6
-----
delete 6
-----
</pre>
<p> このように、データを削除しても木のバランスは崩れません。
</p>
<h4>●AVLtree クラスの作成</h4>
<p> 最後に AVL 木を表すクラスを作成します。次のリストを見てください。
</p>
<pre class="list">
# coding: utf-8
#
# avltree.py : AVL tree (平衡木)
#
#               Copyright (C) 2007 Makoto Hiroi
#
import avlnode

# AVL 木
class AVLtree:
    def __init__(self):
        self.root = None

    # 探索
    def search(self, x):
        return avlnode.search(self.root, x)

    # 挿入
    def insert(self, x):
        self.root = avlnode.insert(self.root, x)

    # 削除
    def delete(self, x):
        self.root = avlnode.delete(self.root, x)

    # 巡回
    def traverse(self):
        for x in avlnode.traverse(self.root):
            yield x

    # 表示
    def __str__(self):
        if self.root is None: return 'AVLtree()'
        buff = 'AVLtree('
        for x in avlnode.traverse(self.root):
            buff += '%s, ' % x
        buff = buff.rstrip(',  ')
        buff += ')'
        return buff

# テスト
if __name__ == '__main__':
    import random
    tree = AVLtree()
    data = [random.randint(0, 100) for x in range(10)]
    print data
    print tree
    for x in data: tree.insert(x)
    print tree
    for x in data:
        print 'search', x, tree.search(x)
        print 'delete', x
        tree.delete(x)
        print 'search', x, tree.search(x)
        print tree
</pre>
<p> クラス名は AVLtree としました。AVLtree のメソッドは avlnode の操作関数を呼び出すだけです。とくに難しいところはないでしょう。
</p>
<p> それでは、テストの実行結果を示します。
</p>
<pre>
[35, 8, 10, 96, 90, 92, 60, 90, 28, 26]
AVLtree()
AVLtree(8, 10, 26, 28, 35, 60, 90, 92, 96)
search 35 True
delete 35
search 35 False
AVLtree(8, 10, 26, 28, 60, 90, 92, 96)
search 8 True
delete 8
search 8 False
AVLtree(10, 26, 28, 60, 90, 92, 96)
search 10 True
delete 10
search 10 False
AVLtree(26, 28, 60, 90, 92, 96)
search 96 True
delete 96
search 96 False
AVLtree(26, 28, 60, 90, 92)
search 90 True
delete 90
search 90 False
AVLtree(26, 28, 60, 92)
search 92 True
delete 92
search 92 False
AVLtree(26, 28, 60)
search 60 True
delete 60
search 60 False
AVLtree(26, 28)
search 90 False
delete 90
search 90 False
AVLtree(26, 28)
search 28 True
delete 28
search 28 False
AVLtree(26)
search 26 True
delete 26
search 26 False
AVLtree()
</pre>
<h4>●AVL 木の評価</h4>
<p> それでは、二分木と AVL 木の性能を比較してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 二分木と AVL 木のテスト

from bintree import *
from avltree import *
import time, random

def insert_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.insert(x)
    e = time.clock()
    return e - s

def search_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.search(x)
    e = time.clock()
    return e - s

def delete_test(tree, buff):
    s = time.clock()
    for x in buff:
        tree.delete(x)
    e = time.clock()
    return e - s

for x in [1000, 2000, 4000, 8000, 16000]:
    buff = [random.randint(0, 100000) for _ in xrange(x)]
#    buff.sort()
    print x,
    for tree in [BinaryTree, AVLtree]:
        a = tree()
        print '%.3f' % insert_test(a, buff),
        print '%.3f' % search_test(a, buff),
        print '%.3f' % delete_test(a, buff),
    print
</pre>
<p> データは乱数で生成します。そして、木にデータを挿入する (insert_test)、データを探索する (search_test)、データを削除する (delete_test) 時間を計測します。二分木のプログラム (<a href="pyalgo12.html#list2">node.py</a>) は再帰呼び出しをループに展開したものを使いました。結果は次のようになります。
</p>
<pre>
          表 : 実行結果 (単位 : 秒)

      :    Binary tree      :      AVL tree
 個数 : 挿入   探索   削除  : 挿入   探索   削除
-------------------------------------------------
 1000 : 0.010  0.006  0.013 : 0.021  0.005  0.015
 2000 : 0.021  0.013  0.028 : 0.039  0.011  0.033
 4000 : 0.048  0.031  0.061 : 0.083  0.024  0.070
 8000 : 0.104  0.066  0.126 : 0.180  0.054  0.150
16000 : 0.247  0.160  0.278 : 0.390  0.124  0.322

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
[<a href="pyalgo13.html#update">改訂</a> 2010/10/10]
</div>
<p> データの挿入と削除は二分木の方が速いですが、データの探索は AVL 木の方が速くなりました。AVL 木の効果は十分に出ていると思います。
</p>
<p> AVL 木はバランスを修正する分だけデータの挿入や削除には時間がかかりますが、そのかわりにデータの探索は高速になります。データの挿入や削除を行う回数が少なく、データの探索回数が多い場合は、AVL 木を使ってみるとよいかもしれません。
</p>
<p> 次はソート済みのデータで試してみました。実行結果は次のようになりました。
</p>
<pre>
  表 : ソート済みデータの実行結果 (単位 : 秒)

      :     Binary tree     :     AVL tree
 個数 : 挿入   探索   削除  : 挿入   探索   削除
--------------------------------------------------
 1000 :  0.31   0.21  0.003 : 0.022  0.005  0.013
 2000 :  1.21   0.82  0.006 : 0.041  0.011  0.028
 4000 :  4.76   3.24  0.012 : 0.086  0.023  0.058
 8000 : 19.67  13.67  0.025 : 0.183  0.051  0.124
16000 : 81.73  58.75  0.048 : 0.374  0.107  0.252

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
[<a href="pyalgo13.html#update">改訂</a> 2010/10/10]
</div>
<p> ソート済みデータの場合、二分木は線形探索と同じになるため、その性能は著しく劣化します。AVL 木は平衡木なので、ソート済みデータの場合でも性能は劣化しません。
</p>
<p> なお、これらの結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<div class="note">
-- <a name="update">改訂</a> --------<BR>
2010/10/10 Python のバージョンを 2.4.2 から 2.7 に変更して実行時間を計測
</div>
<hr>
<h4>●Appendix</h4>
<p> ところで、今回のプログラムは節に平衡度を持たせました。この方法は GLib と同じですが、プログラムはけっこう複雑になります。もう少し簡単な実装方法はないか調べてみたところ、節に木の高さを持たせる方法がありました。木の高さから平衡度を求めるようにすると、プログラムはもう少し簡単になります。ただし、実行時間は遅くなってしまいました。
</p>
<p> ご参考までに、プログラムリストと実行結果を示します。
</p>
<ul>
  <li><a href="pyalgo13.html#list1">avlnode1.py (再帰版)</a>
  <li><a href="pyalgo13.html#list2">avlnode2.py (非再帰版)</a>
</ul>
<pre>
                        表 : 実行結果 (単位 : 秒)

      :    avlnode.py       :    avlnode1.py      :    avlnode2.py
 個数 : 挿入   探索   削除  : 挿入   探索   削除  : 挿入   探索   削除
-----------------------------------------------------------------------
 1000 : 0.019  0.005  0.016 : 0.042  0.005  0.034 : 0.027  0.005  0.017
 2000 : 0.040  0.011  0.033 : 0.089  0.011  0.076 : 0.057  0.011  0.036
 4000 : 0.085  0.024  0.071 : 0.197  0.024  0.171 : 0.119  0.024  0.077
 8000 : 0.184  0.053  0.153 : 0.431  0.054  0.382 : 0.256  0.055  0.167
16000 : 0.409  0.126  0.336 : 0.969  0.130  0.864 : 0.548  0.127  0.367

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<div class="note">
[<a href="pyalgo13.html#update">改訂</a> 2010/10/10]
</div>
<p> avlnode1.py は再帰版で、avlnode2.py は再帰を繰り返しに変換したものです。avlnode1.py は木の高さのチェックと修正をルートまで無条件に行っています。プログラムは簡単になるのですが、挿入と削除の実行時間は平衡度を使った方法 (avlnode.py) の 2 倍以上遅くなりました。
</p>
<p> avlnode2.py は木の高さに変化がない場合は処理を終了するように工夫したものです。実行時間は avlnode1.py よりも速くなりましたが、それでも avlnode.py よりは遅くなります。AVL 木を実装する場合、実行速度の点では平衡度を使った方法が優れているようです。
</p>
<p> なお、これらの結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<hr>
<h4 id="list1">●Appendix : プログラムリスト１</h4>
<pre class="list">
# coding: utf-8
#
# avlnode1.py : AVL tree 操作関数 (再帰版)
#
#               Copyright (C) 2007 Makoto Hiroi
#

# 節の定義
class Node:
    def __init__(self, x):
        self.data = x
        self.left = None
        self.right = None
        self.height = 1     # 木の高さ

# 木の高さを求める
def get_height(node):
    if node.left is not None:
        a = node.left.height
    else:
        a = 0
    if node.right is not None:
        b = node.right.height
    else:
        b = 0
    return max(a, b) + 1

# バランスを求める
def get_balance(node):
    if node.left is not None:
        a = node.left.height
    else:
        a = 0
    if node.right is not None:
        b = node.right.height
    else:
        b = 0
    return a - b

# 右回転
def rotate_right(node):
    lnode = node.left
    node.left = lnode.right
    lnode.right = node
    node.height = get_height(node)
    lnode.height = get_height(lnode)
    return lnode

# 左回転
def rotate_left(node):
    rnode = node.right
    node.right = rnode.left
    rnode.left = node
    node.height = get_height(node)
    rnode.height = get_height(rnode)
    return rnode

# バランスが崩れていたら修正する
def balance(node):
    if node is not None:
        b = get_balance(node)
        if b &gt; 1:
            if get_balance(node.left) &lt; 0:
                # LR 2 重回転
                node.left = rotate_left(node.left)
            return rotate_right(node)
        elif b &lt; -1:
            if get_balance(node.right) &gt; 0:
                # RL 2 重回転
                node.right = rotate_right(node.right)
            return rotate_left(node)
        # 修正不要
        node.height = get_height(node)
    return node

# 探索
def search(node, x):
    while node is not None:
        if node.data == x: return True
        if x &lt; node.data:
            node = node.left
        else:
            node = node.right
    return False

# 挿入
def insert(node, x):
    if node is None: return Node(x)
    elif x == node.data: return node
    elif x &lt; node.data:
        node.left = insert(node.left, x)
    else:
        node.right = insert(node.right, x)
    return balance(node)

# 最小値を探す
def search_min(node):
    if node.left is None: return node.data
    return search_min(node.left)

# 最小値を削除する
def delete_min(node):
    if node.left is None: return node.right
    node.left = delete_min(node.left)
    return balance(node)

# 削除
def delete(node, x):
    if node is not None:
        if x == node.data:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                node.data = search_min(node.right)
                node.right = delete_min(node.right)
        elif x &lt; node.data:
            node.left = delete(node.left, x)
        else:
            node.right = delete(node.right, x)
    return balance(node)

# 巡回
def traverse(node):
    if node is not None:
        for x in traverse(node.left):
            yield x
        yield node.data
        for x in traverse(node.right):
            yield x
</pre>
<hr>
<h4 id="list2">●Appendix : プログラムリスト２</h4>
<pre class="list">
# coding: utf-8
#
# avlnode2.py : AVL 木の操作関数 (非再帰版)
#
#               Copyright (C) 2007 Makoto Hiroi
#

# 節の定義
class Node:
    def __init__(self, x):
        self.data  = x
        self.left  = None
        self.right = None
        self.height = 1        # 木の高さ

# 木の高さを求める
def get_height(node):
    if node.left is not None:
        a = node.left.height
    else:
        a = 0
    if node.right is not None:
        b = node.right.height
    else:
        b = 0
    return max(a, b) + 1

# 平衡度を求める
def get_balance(node):
    if node.left is not None:
        a = node.left.height
    else:
        a = 0
    if node.right is not None:
        b = node.right.height
    else:
        b = 0
    return a - b

# 右回転
def rotate_right(node):
    lnode = node.left
    node.left = lnode.right
    lnode.right = node
    node.height = get_height(node)
    lnode.height = get_height(lnode)
    return lnode

# 左回転
def rotate_left(node):
    rnode = node.right
    node.right = rnode.left
    rnode.left = node
    node.height = get_height(node)
    rnode.height = get_height(rnode)
    return rnode

# 探索
def search(node, x):
    while node is not None:
        if node.data == x: return True
        if x &lt; node.data:
            node = node.left
        else:
            node = node.right
    return False

#
# データの挿入
#
LEFT = 0
RIGHT = 1

# バランスのチェック
def balance(root, path):
    while len(path) &gt; 0:
        new_node = None
        node, dir = path.pop()
        h = get_height(node)
        if h == node.height: return root   # 高さに変化なし
        b = get_balance(node)
        if b &gt; 1:
            if get_balance(node.left) &lt; 0:
                # ２重回転
                node.left = rotate_left(node.left)
            new_node = rotate_right(node)
        elif b &lt; -1:
            if get_balance(node.right) &gt; 0:
                # ２重回転
                node.right = rotate_right(node.right)
            new_node = rotate_left(node)
        else:
            node.height = h
        if new_node is not None:
            # 子の付け替え
            if len(path) &gt; 0:
                # node の親節を求める
                pnode, pdir = path[len(path) - 1]
                if pdir == LEFT:
                    pnode.left = new_node
                else:
                    pnode.right = new_node
            else:
                return new_node
    return root


# 挿入
def insert(root, x):
    if root is None: return Node(x)
    path = []
    p = root
    while True:
        if p.data == x: return root
        elif x &lt; p.data:
            path.append((p, LEFT))
            if p.left is None:
                p.left = Node(x)
                break
            p = p.left
        else:
            path.append((p, RIGHT))
            if p.right is None:
                p.right = Node(x)
                break
            p = p.right
    return balance(root, path)

# データを探す
def _search(node, x, path):
    while node is not None:
        if node.data == x: return node
        if x &lt; node.data:
            path.append((node, LEFT))
            node = node.left
        else:
            path.append((node, RIGHT))
            node = node.right
    return None

# 最小値を探す
def _search_min(node, path):
    while node.left is not None:
        path.append((node, LEFT))
        node = node.left
    return node

# 削除
def delete(root, x):
    if root is None: return None    # 空の木
    path = []                       # 経路
    node = _search(root, x, path)   # 探索
    if node is None: return root    # 削除データなし
    if node.left is not None and node.right is not None:
        # 子が二つある場合
        # 右部分木の最小値を探して置き換える
        path.append((node, RIGHT))
        min_node = _search_min(node.right, path)
        node.data = min_node.data
        node = min_node
    if len(path) &gt; 0:
        pnode, dir = path[len(path) - 1]
    else:
        pnode = None
    # 節を削除する
    if node.left is None:
        cnode = node.right
    else:
        cnode = node.left
    if pnode is None:
        return cnode        # root の削除
    elif dir == LEFT:
        pnode.left = cnode
    else:
        pnode.right = cnode
    return balance(root, path)

# 巡回
def traverse(node):
    if node is not None:
        for x in traverse(node.left):
            yield x
        yield node.data
        for x in traverse(node.right):
            yield x
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007-2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo12.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo14.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>