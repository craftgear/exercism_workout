<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Ruby/Tk 超入門</title>
  <meta name="description" content="Ruby,Tk,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881801</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Lightweigth Language</h1>
<h2>お気楽 Ruby/Tk 超入門</h2>
<div class="small">
[ <a href="rubytk02.html">PrevPage</a> | <a href="ruby.html#ruby_tk">Ruby</a> | <a href="rubytk04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap08">チェックボタンとラジオボタン</h3>
<p> メニューバーでチェックボタン (check button) とラジオボタン (radio button) を使いましたが、これはメニューだけではなくウィジェットとしても用意されています。チェックボタンは TkCheckbutton.new() で生成し、ON / OFF のような二者択一の情報を設定するために使います。ラジオボタンは TkRadiobutton.new() で生成し、複数の値からひとつを選ぶ場合に使います。
</p>

<p> チェックボタンとラジオボタンはオプション text でボタンの名前を指定します。ラジオボタンを使う場合は、選択する値をオプション value で指定し、その値を格納するオブジェクトをオプション variable で指定します。また、オプション command を設定することもできます。この場合、ボタンの値が更新されると指定した関数が実行されます。チェックボタンは値が ON /OFF の 2 通りしかないので、variable に指定する TkVariable には真偽値を格納するといいでしょう。
</p>

<p> 簡単なプログラムと実行例を示します。
</p>
<pre class="list">
リスト : チェックボタンとラジオボタン

# coding: utf-8
require 'tk'

# フォントの設定
TkOptionDB.add('*font', 'Takaoゴシック 14')

opts1 = TkVariable.new(true)
opts2 = TkVariable.new(false)
opts3 = TkVariable.new(true)

action = TkVariable.new(1)

TkLabel.new(text: 'Check Button').pack
TkCheckbutton.new(text: 'option 1', variable: opts1).pack
TkCheckbutton.new(text: 'option 2', variable: opts2).pack
TkCheckbutton.new(text: 'option 3', variable: opts3).pack

TkLabel.new(text: 'Radio Button').pack
TkRadiobutton.new(text: 'action A', variable: action, value: 0).pack
TkRadiobutton.new(text: 'action B', variable: action, value: 1).pack
TkRadiobutton.new(text: 'action C', variable: action, value: 2).pack

Tk.mainloop
</pre>
<p><img src="ruby_img/crbutton.png" alt="チェックボタンとラジオボタン"> チェックボタンとラジオボタン
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap09">イメージとファイルの選択</h3>
<p> 今度は画像の取り扱いについて説明しましょう。Tk は GIF, PNG や PPM / PGM 形式の画像ファイルを扱うことができます。PPM はカラー、PGM はグレイスケールの画像を扱う、UNIX で標準的に用いられるベタフォーマットです。
</p>

<h4>●画像の生成</h4>
<p> Ruby/Tk の場合、クラス TkBitmapImage が白黒のビットマップを表し、TkPhotoImage がカラーイメージを表します。そして、そのオブジェクトをラベルやボタンなどのウィジェットに使うことができます。たとえば、画像ファイルからイメージを作るには次のように行います。
</p>

<pre class="list">
リスト：画像の表示

require 'tk'

image1 = TkPhotoImage.new(file: 'earthris.gif')
TkLabel.new(image: image1).pack

Tk.mainloop
</pre>

<p> TkPhotoImage.new() は画像を表すオブジェクトを返します。オプション file は読み込む画像ファイルを指定します。earthris.gif は Tcl/Tk の配布パッケージに含まれている画像ファイルです。なお、このプログラムでは earthris.gif がカレントディレクトリにあることを仮定しています。ファイルがカレントディレクトリにないとエラーが表示されて動作しません。earthris.gif をカレントディレクトリにコピーするか、ファイル名の指定にパスを追加してください。
</p>

<p> ラベルやボタンにイメージを表示するには、オプション image に画像のオブジェクトをセットします。image は TkPhotoImage.new() で作成した画像専用のオプションで、メソッド TkBitmapImage.new() で作成した画像はオプション bitmap にセットしてください。これでラベルにイメージが表示されます。
</p>

<h4>●ファイルの選択</h4>
<p> それでは簡単な例題として、GIF / PPM の画像を表示するプログラムを作ります。Tk にはファイルを選択するためのコマンドが用意されていて、Ruby/Tk からも呼び出すことができます。
</p>
<pre class="item">
Tk.getOpenFile()  入力ファイルを選択
Tk.getSaveFile()  出力ファイルを選択
</pre>
<p> これらのメソッドを実行すると、ファイル選択のウィンドウ (ダイアログ) が開かれ、ウィンドウ上の操作でディレクトリをたどり、ファイルを選ぶことができます。使用できるオプションは次の通りです。
</p>
<ul>
  <li>initialdir: ディレクトリ<br>
最初に選択されているディレクトリ
  <li>initialfile: ファイル<br>
最初に選択されているファイル（出力ファイルのみ有効）
  <li>defaultextension: 拡張子<br>
最初に選択されている拡張子
  <li>filetypes: パターン<br>
使用可能なファイル種別と拡張子を指定
  <li>title: 文字列<br>
ダイアログボックスのタイトル
</ul>
<p> このなかで重要なオプションが filetypes です。アプリケーションで扱うことができるファイル種別を拡張子で指定し、そのファイルだけを表示します。指定は文字列で行いますが、その表記法は Tcl/Tk とほぼ同じです。
</p>
<pre class="item">
filetypes: " ファイル種別 ... "
ファイル種別 := {名前 {拡張子 ... }}
</pre>
<p> 名前に空白を入れたい場合は { } で囲ってください。たとえば、GIF / PPM ファイルを指定する場合は、次のようになります。
</p>
<pre class="list">
filetypes: "{{画像 Files} {.gif .ppm}}"
</pre>
<p> この場合は GIF と PPM ファイルが一緒に表示されます。次のように指定すると、表示するファイルをダイアログの操作で切り替えることができます。
</p>
<pre class="list">
filetypes: "{GIF {.gif}} {PPM {.ppm}} {ALL {*}}"
</pre>
<p> すべてのファイルを表示する場合は * を使います。また、空文字列 "" を指定すると、拡張子のないファイルを表示します。ファイルを選択すると、ファイル名をフルパス形式で返します。選択しない (キャンセル) 場合は、空文字列が返されます。
</p>

<h4>●画像ローダーの制作</h4>
<p>  それでは、簡単な画像ローダーを作ってみましょう。まず、メニューとラベルを設定します。
</p>

<pre class="list">
リスト : 画像ローダー (1)

# coding: utf-8
require 'tk'

# グローバル変数
$path_name = ""
$image_data = TkPhotoImage.new(width: 64, height: 64)

# ラベル
$label = TkLabel.new(image: $image_data)
$label.pack

# メニュー
m0 = TkMenu.new
Tk.root.configure(menu: m0)

m1 = TkMenu.new(m0, tearoff: false)
m1.add_command(label: 'Open', under: 0, command: proc { load_file })
m1.add_separator
m1.add_command(label: 'Exit', under: 0, command: proc { exit })
m0.add_cascade(label: 'File', under: 0, menu: m1)

Tk.mainloop
</pre>
<p> メニュー File の下に、ファイルを選択する Open とアプリケーションを終了する Exit の 2 つのメニューを設定します。次に、イメージとグローバル変数を定義します。$path_name は選択されたファイルのパスを格納しておきます。getOpenFile() にこのパスを指定することで、次にファイルを選ぶときは同じディレクトリから始めることができます。アプリケーションの開始時にはファイルは指定されていないので、空のイメージを作って表示しておきます。あとは、画像ファイルをロードする本体を作ります。
</p>

<pre class="list">
リスト：GIF/PPM ローダー(2)

# ファイルの選択
def load_file()
  filetype = "{{Image Files} {.gif .png .ppm}} {{GIF Files} {.gif}} {{PNG Files} {.png}} {{PPM Files} {.ppm}} {{All Files} {*}}"
  filename = Tk.getOpenFile(filetypes: filetype, initialdir: $path_name)
  if filename != ""
    $path_name = File::dirname(filename)
    p $path_name
    $image_data = TkPhotoImage.new(file: filename)
    $label.configure(image: $image_data)
  end
end
</pre>

<p> getOpenFile() でファイル名を取得したら、関数 File::dirname() でパスを取り出してグローバル変数 $path_name にセットします。dirname() はファイル名からパス部分を取り出して返します。
</p>

<p> ファイル名をゲットしたら、それが空文字列でないことを確認します。次に、新しいイメージを TkPhotoImage.new() で生成します。最後に、ラベルの configure() で表示するイメージを変更します。これで選択した画像ファイルを表示することができます。
</p>
<p> <img src="ruby_img/image.png" ALT="ファイル選択ダイアログ"> 表示するファイルの選択
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap10">ダイアログ</h2>
<p> GUI アプリケーションの場合、ボタンを押すとかメニューを選ぶといった操作は、基本的にはユーザーが自由に行うことができます。ところが、ある操作をしないと次の処理に進めない場合があります。たとえば、画像を表示する場合、表示するファイル名をユーザーから入力してもらわないと、画像ファイルを表示することはできません。このときによく使われるのが ダイアログ (dialog) です。
</p>

<p> 前回はファイル選択を行うメソッド getOpenFile() を使いましたが、このとき表示されたウィンドウがダイアログです。ダイアログは重要なメッセージを表示するために開かれるウィンドウで、画面の前面に表示され、ユーザーがダイアログに応答しないかぎり、そのアプリケーションではほかの操作を行うことはできません。
</p>

<h4>●メッセージボックス</h4>
<p> Ruby/Tk の場合、メソッド Tk.messageBox() を使うと簡単にダイアログを表示することができます。ダイアログの種別はオプション icon (アイコン) と type (キー種別) で指定します。
</p>
<pre class="item">
icon : error, info, question, warning
type : abortretryignore, ok, okcancel, retrycancel, yesno, yesnocancel
</pre>
<p> Tk.messageBox() を実行すると、メッセージを表示してユーザーがボタンを押すまで待ちます。オプション title でダイアログのタイトルを、オプション message でダイアログに表示する文字列を指定します。Tk.messageBox() は押したボタンの種別を文字列で返します。
</p>
<p> 簡単なプログラムを示します。
</p>

<pre class="list">
リスト：messageBox のサンプル

# coding: utf-8
require 'tk'

$type = TkVariable.new(0)
$type_table = ['abortretryignore', 'ok', 'okcancel',
              'retrycancel', 'yesno', 'yesnocancel']

$icon = TkVariable.new(0)
$icon_table = ['error', 'info', 'question','warning']

TkLabel.new(text: 'TYPE').pack
for x in 0..5
  TkRadiobutton.new(text: $type_table[x], variable: $type, value: x).pack(anchor: 'w')
end
TkLabel.new(text: 'ICON').pack
for x in 0..3
  TkRadiobutton.new(text: $icon_table[x], variable: $icon, value: x).pack(anchor: 'w')
end

def message_box
  p Tk.messageBox(title: 'about',
                  type: $type_table[$type.numeric],
                  icon: $icon_table[$icon.numeric],
                  message: "messageBox のサンプルです")
end

TkButton.new(text: "Open message box",
             command: proc {message_box}).pack

Tk.mainloop
</pre>
<p><img src="ruby_img/dialog0.png" alt="メインウィンドウ"> メインウィンドウの画像
</p>
<p><img src="ruby_img/dialog1.png" alt="メッセージボックス"> メッセージボックス info, ok の画像
</p>
<p><img src="ruby_img/dialog2.png" alt="メッセージボックス"> メッセージボックス warning, retrycancel の画像
</p>
<h4>●ダイアログの作成</h4>
<p> このほかに Ruby/Tk には、ダイアログを生成するクラス TkDialog が用意されています。ダイアログは TkDialog.new() で生成します。TkDialog の主なオプションを表に示します。
</p>
<table border=1>
<caption>表 : TkDialog の主なオプション</caption>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>title</td><td>ダイアログのタイトルを指定</td></tr>
  <tr><td>message</td><td>ダイアログに表示する文字列</td></tr>
  <tr><td>bitmap</td><td>ダイアログに表示するビットマップ</td></tr>
  <tr><td>buttons</td><td>ボタン名 (文字列) を格納した配列</td></tr>
  <tr><td>default</td><td>デフォルトボタンを指定</td></tr>
</tbody>
</table>

<p> 一般に、bitmap には Tk で用意されているビットマップを指定します。イメージを指定することはできないので注意してください。ボタンはいくつでも設定することができ、配列に格納した順番で表示されます。TkDialog.new() は TkDialog のオブジェクトを返します。インスタンスメソッド value を呼び出すと押されたボタンの番号を求めることができます。たとえば、buttons に ['yes', 'no'] を指定した場合、yes を押すと 0 がセットされ、no を押すと 1 がセットされます。
</p>

<p> それでは、TkDialog を使ってメッセージを表示してみましょう。
</p>

<pre class="list">
リスト : TkDialog のサンプル

require 'tk'

# フォントの指定
TkOptionDB.add('*font', 'Takaoゴシック 14')

# ダイアログの生成
def message_window
  TkDialog.new(title: 'About',
               bitmap: 'info',
               message: 'Dialog のテストです',
               buttons: ['Yes', 'No'],
               default: 0).value
end

# メニューの設定
m = TkMenu.new
Tk.root.configure(menu: m)
m.add_command(label: 'About', under: 0,
              command: proc { p message_window })

# ラベルの設定
TkLabel.new(text: 'メニュー About を選んでね').pack

Tk.mainloop
</pre>

<p> メニュー About が選択されたら、関数 message_window() を実行してダイアログを表示します。bitmap には info を指定しました。このほかに、error, hourglass, questhead, question, warning などがあります。ボタンは Yes と No のふたつです。default には 0 を指定したので、Yes のボタンがデフォルトになります。
</p>

<p><img src="ruby_img/dialog3.png" alt="メインウィンドウ"> メインウィンドウの画像
</p>
<p><img src="ruby_img/dialog4.png" alt="TkDialog"> TkDialog の画像
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap11">キャンパス</h3>
<p> 今度は図形を表示する キャンバス (canvas) ウィジェットを説明します。キャンバスは、矩形、直線、楕円などの図形のほかに、イメージ、文字列、任意のウィジェットを表示することができます。キャンバスウィジェットは TkCanvas.new() で生成します。次のプログラムを実行すると、空のウィンドウが表示されます。
</p>
<pre class="list">
リスト：キャンバスウィジェット

require 'tk'

TkCanvas.new(width: 150, height: 150).pack

Tk.mainloop
</pre>
<p> これで図形を表示するキャンバスをウィンドウに配置したことになります。また、キャンバスとスクロールバーを組み合わせて、表示範囲を変更することもできます。
</p>

<h4>●図形の生成</h4>
<p> キャンバスを配置しただけでは、なにも図形は描かれていません。図形を生成するには次表に示すクラスを使います。
</p>
<table border=1>
<caption>表：図形クラス</caption>
<tbody>
  <tr><td>TkcLine</td><td>直線（折れ線）</td></tr>
  <tr><td>TkcOval</td><td>楕円</td></tr>
  <tr><td>TkcArc</td><td>円弧（楕円の円周の一部）</td></tr>
  <tr><td>TkcRectangle</td><td>矩形</td></tr>
  <tr><td>TkcPolygon</td><td>多角形</td></tr>
  <tr><td>TkcImage</td><td>イメージ</td></tr>
  <tr><td>TkcBitmap</td><td>ビットマップ</td></tr>
  <tr><td>TkcText</td><td>文字列</td></tr>
  <tr><td>TkcWindow</td><td>任意のウィジェット</td></tr>
</tbody>
</table>
<p> 実際にはメソッド new を使って図形を生成します。第 1 引数には図形を配置するキャンバスオブジェクトを指定します。あとは描画クラス固有の引数とオプションを指定します。
</p>
<h4>●楕円を描く</h4>
<p> それでは実際に図形を表示してみましょう。
</p>
<pre class="list">
リスト：楕円の描画

require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
ov = TkcOval.new(c0, 10, 10, 140, 140)
c0.pack

Tk.mainloop
</pre>
<p> <img src="ruby_img/oval1.png" ALT="楕円 1"> 楕円の描画
</p>
<p> ウィンドウに楕円が描画されました。楕円の場合、指定した矩形に内接するように描画されます。TkcOval.new() の返り値は図形を表すオブジェクトです。これを使って図形を操作することができます。Ruby/Tk の場合、図形オブジェクトでもメソッド cget() や configure() を使うことができます。また、キャンバスのメソッド itemcget() と itemconfigure() でも同じことができます。たとえば、楕円の中を赤色に塗りつぶしてみましょう。次の 1 行を追加してください。
</p>
<pre class="item">
ov.configure(fill: 'red')  # c0.itemconfigure(ov, fill: 'red') でも可能
</pre>
<p> <img src="ruby_img/oval2.png" ALT="楕円 2"> 楕円の描画 (塗りつぶし)
</p>
<p> 楕円の中が赤くなりました。よく使われるオプションには次のものがあります。
</p>
<ul>
  <li>fill: 色<br>               内部を塗りつぶす色
  <li>stipple: ビットマップ<br>  内部を塗りつぶすときの模様になるビットマップ
  <li>outline: 色<br>            枠の色
  <li>width: 幅<br>              枠の幅（デフォルトは 1.0）
</ul>
<p> なお、M.Hiroi が使用しているバージョン (Ruby 2.3) では、図形クラスの new() の引数でオプションを指定するとエラーになります。この場合、オプションは他の方法で指定してください。たとえば、ブロックの中で指定する場合は次のようになります。
</p>
<pre class="list">
リスト : ブロックでオプションを指定する方法

# (1)
widgetClass.new(args, ...) {
  option1 value1
  option2 value2
    ...
}

# (2)
widgetClass.new(args, ...) {|obj|
  obj.option1 value1
  obj.option2 value2
    ...
}
</pre>
<p> (1) の場合、ブロックの中では変数 self で widgetClass のオブジェクトにアクセスすることができます。option1 value1 は self.option1 value1, self.option1(value1), self.option1 = value1 のように記述してもかまいません。(2) の場合、ブロックの引数 obj に widgetClass のオブジェクトが渡されます。
</p>
<h4>●矩形を描く</h4>
<p> 矩形も楕円と同じ指定方法です。stipple には、Tk に標準で組み込まれているビットマップを指定するのが一般的です。よく使うビットマップが灰色の模様を表す gray12, gray25, gray50, gray75 です。それでは実際に描画してみましょう。
</p>
<pre class="list">
リスト：矩形の描画

require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
TkcRectangle.new(c0, 10, 10, 140, 140) {
  fill 'green'
  stipple 'gray25'
}
c0.pack

Tk.mainloop
</pre>
<p> <img src="ruby_img/rect.png" ALT="矩形"> 矩形の描画
</p>
<h4>●直線を描く</h4>
<p> 次は直線です。2 点間だけではなく複数の点を指定すると、その間を直線で結びます。では、直線を描画してみましょう。
</p>
<pre class="list">
リスト：直線の描画

require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
ln = TkcLine.new(c0, 10, 10, 140, 10, 10, 140, 140, 140)
c0.pack()

Tk.mainloop
</pre>
<p> <img src="ruby_img/line1.png" ALT="直線 1"> 直線の描画
</p>
<p> 画面に Z 字型の線が描かれましたね。線の色を指定するオプションは、直線の場合は outline ではなくて fill で指定します。fill: 'green' で線を緑色に、width: 2.0 で線を太くしてみましょう。
</p>
<p> <img src="ruby_img/line2.png" ALT="直線 2"> 直線の色と太さを変更
</p>
<p> オプション smooth を真 (true) に指定すると、滑らかな曲線を描画することができます。
</p>
<p> <img src="ruby_img/line3.png" ALT="直線 3"> 直線の描画 (smooth 指定)
</p>
<p> このほかにも、矢印の設定や折り返しのときの形など、いろいろなオプションが用意されています。
</p>
<h4>●多角形を描く</h4>
<p> 次は多角形です。五角形を作ってみましょう。各頂点の座標を指定しますが、最初の点と最後の点が結ばれて閉じた図形となります。
</p>
<pre class="list">
リスト：多角形の描画

require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
TkcPolygon.new(c0, 75, 10, 140, 70, 110, 140, 40, 140, 10, 70)
c0.pack()

Tk.mainloop
</pre>
<p> polygon では、デフォルトで fill オプションが黒、outline は描画されません。それから、line と同様に smooth を真 (true) に指定すると、多角形の角を丸めます。実際に試してみてください。
</p>
<p> <img src="ruby_img/poly.png" ALT="多角形"> 多角形の描画
</p>
<h4>●円弧を描く</h4>
<p> 次は円弧です。楕円の円周の一部分を表示します。座標の指定は oval と同じですが、オプションで表示する範囲を指定します。
</p>
<ul>
    <li>start: 角度<br>    開始位置を角度で指定
    <li>extent: 角度<br>   終了位置を開始位置からの角度で指定
    <li>style: 種別<br>    arc : 円周のみ描画<br>
                   chord : 円周と始点終点を結ぶ線分<br>
                   pieslice : 円周と中心から始点、終点を結ぶ線分
</ul>
<p> 角度は度数でプラスが反時計回り、マイナスが時計回りとなります。また、oval と同じオプションが使えます。ただし、style が arc の場合、fill で色を指定しても表示されません。chord か pieslice に変更すると表示されます。
</p>
<h4>●イメージの表示</h4>
<p> キャンバスはイメージとビットマップも表示することができます。
</p>
<pre class="item">
TkcImage.new(canvas, x, y, オプション, ... )
TkcBitmap.new(canvas, x, y, オプション, ... )
</pre>
<p> x, y は表示する座標を表します。イメージのどの位置に対応させるかは、オプション anchor で指定します。これは pack() と同じ指定方法です。データとの対応は image と bitmap で指定します。たとえば、earthris.gif (Tcl/Tk 配布パッケージ内のファイル) を表示するには、次のようにプログラムします。
</p>
<pre class="list">
リスト：イメージの表示</th></tr>

require 'tk'

c0 = TkCanvas.new(width: 400, height: 300)
c0.pack()

image_data = TkPhotoImage.new(file: 'earthris.gif')
TkcImage.new(c0, 200, 150){
  image image_data
}

Tk.mainloop
</pre>
<p> これでキャンバスの中央にイメージが描画されます。
</p>
<h4>●文字列の表示</h4>
<p> 次は文字列です。当然ですがキャンバスに文字を描くことができます。
</p>
<pre class="item">
TkcText.new(canvas, x, y, オプション, ...)
</pre>
<p> x, y は座標で、オプションには次のものが使えます。
</p>
<ul>
  <li>anchor: 位置<br>    座標とテキストの位置関係
  <li>font: フォント<br>  文字のフォント
  <li>fill: 色<br>        文字の色
  <li>justify: mode<br>   center:中揃え, left:左揃え, right:右揃え
  <li>text: 文字列<br>    表示する文字列
  <li>width: 長さ<br>     1 行の長さ
</ul>
<p> それでは実際に試してみましょう。
</p>
<pre class="list">
リスト：テキストの表示

# coding: utf-8
require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
TkcText.new(c0, 75, 75){
  text 'hello, world!'
  font 'Takaoゴシック 14'
}
c0.pack

Tk.mainloop
</pre>
<p> <img src="ruby_img/text.png" ALT="テキスト"> テキストの描画
</p>
<p>これでウィンドウの中央に hello, world! が表示されます。
</p>
<h4>●ウィジェットの挿入</h4>
<p> キャンバス中にほかのウィジェットを表示させる場合は TkcWindow.new() を使います。
</p>
<ul>
  <li>anchor: 位置<br>         座標とウィジェットの位置関係
  <li>window: ウィジェット<br> 表示するウィジェット
  <li>width: 幅<br>            ウィジェットの幅
  <li>height: 高さ<br>         ウィジェットの高さ
</ul>
<p> たとえば、ラベルを表示させてみましょう。
</p>
<pre class="list">
リスト：ラベルウィジェットの表示

# coding: utf-8
require 'tk'

c0 = TkCanvas.new(width: 150, height: 150)
a0 = TkLabel.new(text: 'hello, world!', bg: 'green',
                 font: 'Takaoゴシック 14')
TkcWindow.new(c0, 75, 75) {|w|
  w.window a0
}
c0.pack

Tk.mainloop
</pre>
<p> <img src="ruby_img/window.png" ALT="ラベル"> ラベルの描画
</p>
<p> 今度は背景色が緑の hello, world! が表示されました。
</p>
<h4>●図形操作用メソッド</h4>
<p> キャンバスで使用できる図形を一通り説明したところで、図形を操作するときによく使うメソッドを示します。
</p>

<table border=1>
<caption>表：図形操作用メソッド</caption>
<tbody>
<tr><td>c.bbox(item, ...)</td><td>指定した図形を囲む領域 (矩形) を配列に格納して返す</td></tr>
<tr><td>c.coords(item, x0, y0, ...)</td><td>図形の座標の設定や問い合わせ</td></tr>
<tr><td>c.delete(item, ...)</td><td>図形の削除</td></tr>
<tr><td>c.move(item, dx, dt)</td><td>図形の移動</td></tr>
<tr><td>c.lower(item1, item2)</td><td>重なり順を低くする</td></tr>
<tr><td>c.raise(item1, item2)</td><td>重なり順を高くする</td></tr>
<tr><td>c.itembind(item, event, callback, args, ...)</td><td> バインディングの設定</td></tr>
</tbody>
</table>
<p> c はキャンパスウィジェットのオブジェクト、item は図形オブジェクト表します。ウィジェットと同様に、図形に対してもバインディングを設定することができます。また、item には「タグ (tag)」を指定することもできます。バインディングはタグと一緒に詳しく説明します。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap12">タグとバインド</h3>
<h4>●バインディングの設定</h4>
<p> キャンバスで作成した図形にはバインディングを設定することができます。簡単な例題として、作成した矩形をドラッグで移動させてみましょう。次のプログラムを実行してください。
</p>
<pre class="list">
リスト：バインディングの設定 (1)

# coding: utf-8
require 'tk'

$c0 = TkCanvas.new(width: 200, height: 150)
$c0.pack()
$rc = TkcRectangle.new($c0, 10, 10, 20, 20) {
  fill 'brown'
}

# 移動
def move_rect(x, y)
  $c0.coords($rc, x - 5, y - 5, x + 5, y + 5)
end

# バインディング
$rc.bind('Button1-Motion', proc {|x, y| move_rect(x, y) }, '%x %y')

Tk.mainloop
</pre>

<p> 最初に、一辺の長さが 10 の矩形を作ります。次に、その矩形に対してバインディングを設定します。イベント 'B1-Motion' は、左ボタンを押した状態でマウスを動かした場合、つまりドラッグに対応します。関数 move_rect() は新しい座標を計算して、図形の位置を coords() で変更します。
</p>
<p> なお、bind() のほかにキャンバスのメソッド itembind() を使っても同じことができます。
</p>
<pre class="list">
$c0.itembind($rc, 'Button1-Motion', proc {|x, y| move_rect(x, y) }, '%x %y') 
</pre>
<h4>●タグの設定</h4>
<p> それでは、操作する矩形を 3 つに増やしてみましょう。それぞれの矩形にバインディングを設定してもいいのですが、同じようなプログラムをいくつも書くのは面倒です。このような場合、タグ (tag) を設定すると簡単にプログラムを記述することができます。タグには荷札という意味があり、図形に識別子をつける働きをします。
</p>

<p>図形には複数のタグを設定することができます。そして、図形を操作するメソッドは、操作対象となる図形の指定を、オブジェクトのほかにもタグを使って行うことができるのです。タグの設定は図形を生成するときにオプション tags で行います。それでは矩形にタグをセットして 3 つ作ります。
</p>

<pre class="list">
リスト：バインディングの設定 (2)</th></tr>

# coding: utf-8
require 'tk'

$c0 = TkCanvas.new(width: 200, height: 150)
$c0.pack

TkcRectangle.new($c0, 10, 10, 20, 20) {
  fill 'brown'
  tags 'brown'
}
TkcRectangle.new($c0, 20, 10, 30, 20) {
  fill 'brown'
  tags 'brown'
}
TkcRectangle.new($c0, 30, 10, 40, 20) {
  fill 'brown'
  tags 'brown'
}

# 移動
def move_rect(x, y)
  $c0.coords('current', x - 5, y - 5, x + 5, y + 5)
end

# バインディング
$c0.itembind('brown', 'Button1-Motion',
             proc {|x, y| move_rect(x, y)}, '%x %y')

Tk.mainloop
</pre>

<p> タグは文字列で指定します。今回は brown としました。このタグに対して itembind() でバインディングを設定します。この場合、図形オブジェクトではなくタグ brown を指定します。ただし、このままでは関数 move_rect() で操作対象となる矩形がわかりません。この場合、特別なタグ current を使います。
</p>
<p> current は Ruby/Tk が設定するタグで、マウスカーソルがある図形上にくると、その図形にタグ current を設定し、その図形からマウスカーソルから出るとタグ current を削除します。つまり、マウスカーソルが指している図形はタグ current で指定することができるのです。これで、複数の矩形をひとつの関数で操作することができます。
</p>

<p> このほかにも、タグには図形をまとめて操作することができる、という利点があります。たとえば、矩形の色をまとめて変更する場合は、タグを使って行えばいいのです。
</p>
<pre class="item">
$c0.itemconfigure('brown', fill: 'green')
</pre>
<p> これでタグ brown の図形の色を green に変更することができます。削除する場合もタグを使えば簡単です。
</p>
<pre class="item">
$c0.delete('brown')
</pre>
<p> これでタグ brown の図形をすべて削除することができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="rubytk02.html">PrevPage</a> | <a href="ruby.html#ruby_tk">Ruby</a> | <a href="rubytk04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>