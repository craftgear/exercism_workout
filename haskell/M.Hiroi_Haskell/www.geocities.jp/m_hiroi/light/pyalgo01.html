<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / 再帰定義</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881761</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>再帰定義 (recursive definition)</h2>
<div class="small">
[ PrevPage | <a href="index.html#python_algo">Python</a> | <a href="pyalgo02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> プログラミングの経験がある人ならば、「再帰」という言葉はご存じだと思います。関数定義の中で、その関数自身を呼び出すことを「再帰呼び出し (recursive call) 」とか「再帰定義 (recursive definition) 」といいます。
</p>
<p>  関数の定義に自分自身を使うことができるなんて、何か特別な仕掛があるのではないかと思われるかもしれません。ところが、再帰定義は特別なことではありません。大昔のプログラミング言語ならばいざしらず、今では再帰呼び出しができないプログラミング言語のほうが珍しいでしょう。
</p>
<p>  再帰定義というと、Scheme (Lisp), ML, Haskell など「関数型言語」の専売特許だと思われている方もいるでしょう。実際、Ｃ / Ｃ++ などの手続き型言語の場合、初心者の方は再帰定義を難しいテクニックのひとつと思い込んでしまい、避けて通ることが多いように思います。再帰定義は、通常の関数呼び出しとまったく同じなので、難しく考える必要はありません。慣れるまでちょっと苦労するかもしれませんが、ポイントさえつかめば簡単に使いこなすことができます。
</p>
<p> 拙作のページ <a href="index.html">お気楽 Python プログラミング入門</a> <a href="python03.html">第 3 回 再帰定義と高階関数</a> では、階乗の計算、ユークリッドの互除法、順列の生成などを例題にして、再帰定義の基本を説明しています。よろしければ参考にしてください。本ページでは「お気楽 Python プログラミング入門」で取り上げることのできなかった再帰プログラミングについて紹介します。
</p>

<h4>●フィボナッチ関数</h4>
<p>  最初は簡単な数値計算の例を示しましょう。フィボナッチ関数は階乗と同様に再帰的に定義される関数です。
</p>
<pre class="fig">
          ┌ 1;                     n = 0
fibo(n) = ┤ 1;                     n = 1
          └ fibo(n-1) + fibo(n-2); n &gt; 1

1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

    図 : フィボナッチ関数の定義
</pre>
<p> フィボナッチ関数も再帰呼び出しを使えば簡単にプログラムできます。
</p>
<pre class="list">
リスト : フィボナッチ関数

def fibo(n):
    if n == 0 or n == 1: return 1
    return fibo(n - 1) + fibo(n - 2)
</pre>
<p> 関数 fibo は階乗の計算を行う関数 fact とは違い、自分自身を 2 回呼び出しています。これを「二重再帰」といいます。fibo の呼び出しをトレースすると下図のようになります。
</p>
<pre class="fig">
  fibo(5) ┬ fibo(4) ┬ fibo(3) ┬ fibo(2) ┬ fibo(1)  
          │         │         │         │
          │         │         │         └ fibo(0)
          │         │         └ fibo(1)
          │         └ fibo(2) ┬ fibo(1)
          │                    │
          │                    └ fibo(0)
          │
          └ fibo(3) ┬ fibo(2) ┬ fibo(1)
                     │         │
                     │         └ fibo(0)
                     └ fibo(1)

  図 : 関数 fibo のトレース
</pre>
<p> 同じ値を何回も求めているため、関数 fibo の効率はとても悪いのです。この場合、二重再帰を「末尾再帰」に変換すると高速化することができます。そこで累算変数を使って、二重再帰を末尾再帰へ変換してみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : フィボナッチ関数（末尾再帰）

def fibo(n, a1 = 1, a2 = 0):
    if n &lt; 1: return a1
    return fibo(n - 1, a1 + a2, a1)
</pre>
<p> 累算変数 a1 と a2 の使い方がポイントです。現在のフィボナッチ数を変数 a1 に、ひとつ前の値を変数 a2 に格納しておきます。あとは a1 と a2 を足し算して、新しいフィボナッチ数を計算すればいいわけです。fibo の呼び出しを下図に示します。
</p>
<pre class="fig">
fibo(5)
  fibo(4, 1, 1)
    fibo(3, 2, 1)
      fibo(2, 3, 2)
        fibo(1, 5, 3)
          fibo(0, 8, 5)
          =&gt; a1 の値 8 を返す
        =&gt; 8
      =&gt; 8
    =&gt; 8
  =&gt; 8
=&gt; 8

  図 : 関数 fibo の呼び出し
</pre>
<p> 二重再帰では、同じ値を何回も求めていたため効率がとても悪かったのですが、このプログラムでは無駄な計算を行っていないので、値を高速に求めることができます。もちろん、末尾再帰になっているので、末尾再帰最適化を行う処理系では、プログラムをより高速に実行することができます。
</p>
<p> Python の場合、末尾再帰最適化はサポートされていませんが、末尾再帰を繰り返しに変換することは簡単です。関数 fibo を繰り返しに変換すると次のようになります。
</p>
<pre class="list">
リスト : フィボナッチ関数（繰り返し）

def fibo(n):
    a1, a2 = 1, 0
    while n &gt; 0:
        a1, a2 = a1 + a2, a1
        n -= 1
    return a1
</pre>
<p> このように、末尾再帰は簡単に繰り返しに変換することができます。
</p>

<h4>●累乗の計算</h4>
<p> もう一つ、簡単な数値計算の例を紹介しましょう。累乗は下図のように x の n 乗という x を n 回掛ける計算です。Python には累乗を計算する演算子 ** がありますが、繰り返しでも再帰定義でも簡単にプログラムすることができます。
</p>
<pre class="fig">
x ** 3 = x * x * x
x ** 4 = x * x * x * x
x ** 5 = x * x * x * x * x

  図 : 累乗の計算
</pre>
<p> 累乗を単純な繰り返しで実装すると、次のようになります。
</p>
<pre class="list">
リスト : 累乗の計算 (1)

def pow(x, n):
    value = 1
    while n &gt; 0:
        value *= x
        n -= 1
    return value
</pre>
<p> この場合、n 回の乗算が必要になります。ところが、式を変形するともっと少ない回数で求めることができます。
</p>
<pre class="fig">
x ** 4  = (x ** 2) ** 2 -&gt; 2 回
x ** 8  = (x ** 4) ** 2 -&gt; 3 回
x ** 16 = (x ** 8) ** 2 -&gt; 4 回

  一般化すると

x ** n = (x ** (n / 2)) ** 2; （n は偶数）

x ** n = ((x ** (n / 2)) ** 2) * x; （n は奇数）

  図 : 累乗を求める式の変形
</pre>
<p> 階乗計算では n を n - 1 の計算に置き換えていきますが、累乗の場合は n を n / 2 に置き換えていくことができます。n が半分になっていくので、ひとつずつ n を減らすよりも減少の度合いは大きくなります。その分だけ計算回数が少なくなるわけです。
</p>
<p> それでは、この考え方をプログラムしてみましょう。x ** (n / 2) を計算する部分は、再帰を使えば簡単です。
</p>
<pre class="list">
リスト : 累乗の計算 (2)

def pow1(x, n):
    if n == 0: return 1
    value = pow1(x, n / 2)
    value *= value
    if n % 2 == 1: value *= x
    return value
</pre>
<p> 関数 pow1 は一般化した累乗の定義をそのままプログラムしただけです。最初の if 文が再帰呼び出しの停止条件です。次に、n を 2 で割った値で pow1 を再帰呼び出しします。この返り値を 2 乗して、n が奇数ならば x をさらに掛け算します。最後に計算結果 value を return で返します。
</p>
<p> ところで、関数 pow1 も繰り返しに変換することができます。整数 n は下図のように 2 ** i の和の形で表せることを利用します。
</p>
<pre class="fig">
11 = 1 + 2 + 8     (2**0 + 2**1 + 2**3)
15 = 1 + 2 + 4 + 8 (2**0 + 2**1 + 2**2 + 2**3)

        図 : 整数の 2 進数表現
</pre>
<p> これは整数 n の下位ビットから順番にビットをチェックしていけば簡単に求めることができます。これを利用すると x ** n は下図のように求めることができます。
</p>
<pre class="fig">
x ** 11 = x * x ** 2 * x ** 8
x ** 15 = x * x ** 2 * x ** 4 * x ** 8

x ** 2 = x * x
x ** 4 = x ** 2 * x ** 2
x ** 8 = x ** 4 * x ** 4
  .....

        図 : 累乗の計算
</pre>
<p> x ** 2, x ** 4, x ** 8, ... は値を次々に 2 乗していけば簡単に求めることができます。これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 累乗の計算 (3)

def pow2(x, n):
    value = 1
    while n &gt; 0:
        if n &amp; 1: value *= x
        n &gt;&gt;= 1
        x *= x
    return value
</pre>
<p> 最初に局所変数 value を 1 に初期化します。そして、n が 0 よりも大きいあいだ、つまり 1 のビットがあるあいだ処理を繰り返します。最下位ビットが 1 の場合は value に x を掛け算します。そして、n を 1 ビット右へシフトします。x の値は x *= x で自乗されていくので、x, x ** 2, x ** 4, x ** 8, x ** 16 と増えていきます。繰り返しを終了したら value を返します。
</p>
<p> それでは、実際に実行速度を比較して見ましょう。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。
</p>
<pre>
pow(2, 100000)  :  1.855 [s]
pow1(2, 100000) :  0.003 [s]
pow2(2, 100000) :  0.005 [s]
</pre>
<p> pow と比べて pow1 と pow2 はとても速いですね。そして、pow2 よりも pow1 の方が少しだけ速くなったのには驚きました。pow1 のような再帰定義でも十分実用的といえるでしょう。
</p>

<h4>●ハノイの搭</h4>
<p> 再帰といえば忘れてはいけないのが「ハノイの塔」でしょう。ハノイの塔は、棒に刺さっている大きさが異なる複数の円盤を、次の規則に従ってほかの棒に移動させるパズルです。
</p>
<ol>
  <li>一回に一枚の円盤しか移動できない。
  <li>小さな円盤の上に大きな円盤を置くことはできない。
  <li>最初すべての円盤は一本の棒に刺さっていて、各円盤はそれより大きな円盤の上に置かれている。
</ol>
<p> ハノイの塔は、再帰を使えば簡単に解ける問題です。たとえば、3 枚の円盤が左の棒に刺さっているとします。この場合、いちばん大きな円盤を中央の棒に移すには、その上の 2 枚の円盤を右の棒に移しておけばいいですね。いちばん大きな円盤を中央に移したら、右の棒に移した 2 枚の円盤を中央の棒に移すことを考えればよいわけです。したがって、n 枚の円盤を左から中央の棒に移すプログラムは次のように定義できます。
</p>
<ol>
  <li>ｎ－１枚の円盤を左から右に移す
  <li>ｎ枚目の円盤を左から中央へ移す
  <li>ｎ－１枚の円盤を右から中央へ移す
</ol>
<p> これを素直にプログラムすると次のようになります。
</p>
<pre class="list">
リスト : ハノイの塔

def hanoi(n, from_, to, via):
    if n == 1:
        print "%s =&gt; %s" % (from_, to)
    else:
        hanoi(n - 1, from_, via, to)
        print "%s =&gt; %s" % (from_, to)
        hanoi(n - 1, via, to, from_)
</pre>
<p> n は動かす円盤の枚数、from_ は移動元の棒、to は移動先の棒、via は残りの棒を示します。棒は文字列で表します。円盤の枚数が 1 枚の場合は簡単ですね。from_ にある円盤を to へ移すだけです。これが再帰の停止条件になります。この動作を print で表示します。
</p>
<p> 円盤が複数枚ある場合、from_ にある円盤の n - 1 枚を via に移します。この処理は hanoi を再帰呼び出しすればいいですね。次に、残りの 1 枚を to に移します。これを print で表示します。そして、via に移した n - 1 枚の円盤を to に移します。この処理も hanoi を再帰呼び出しするだけです。これでプログラムは完成です。それでは実行してみましょう。
</p>
<pre>
&gt;&gt;&gt; hanoi(3, "a", "b", "c")

a =&gt; b
a =&gt; c
b =&gt; c
a =&gt; b
c =&gt; a
c =&gt; b
a =&gt; b
</pre>

<h4>●組み合わせの数</h4>
<p> 次は組み合わせの数を求めるプログラムを作ってみましょう。ここでは組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> を (n, r) と表記します。(n, r) を求めるには、次の公式を使えば簡単です。
</p>
<pre class="fig">
(n, r) = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>
<p> 皆さんお馴染みの公式ですね。ところが、整数値の範囲が限られているプログラミング言語では、この公式を使うと乗算で<B>桁あふれ</B>を起こす恐れがあります。Python は多倍長演算をサポートしているので、桁あふれを心配する必要はありません。
</p>
<p> この公式をそのままプログラムすることもできますが、次の式を使うともっと簡単にプログラムできます。
</p>
<pre class="fig">
(n, r) = (n, r - 1) * (n - r + 1) / r
(n, 0) = (n, n) = 1
</pre>
<p> この式は (n, r) と (n, r - 1) の関係を表しています。あとは階乗と同じように、再帰定義を使って簡単にプログラムできます。次のリストを見てください。
</p>
<pre class="list">
リスト : 組み合わせの数を求める

def comb(n, r):
    if n == 0 or r == 0: return 1
    return comb(n, r - 1) * (n - r + 1) / r 
</pre>
<p> とても簡単ですね。ところで、整数値の範囲が限られているプログラミング言語では、この方法でも桁あふれする場合があるので注意してください。それでは、関数 comb を使って<b>パスカルの三角形</b>を作ってみましょう。次の図を見てください。
</p>
<pre class="fig">
                 １                                 0Ｃ0
               ／  ＼                              ／  ＼
             １      １                         1Ｃ0    1Ｃ1
           ／  ＼  ／  ＼                      ／  ＼  ／  ＼
         １      ２      １                 2Ｃ0    2Ｃ1    2Ｃ2
       ／  ＼  ／  ＼  ／  ＼              ／  ＼  ／  ＼  ／  ＼
     １      ３      ３      １         3Ｃ0    3Ｃ1    3Ｃ2    3Ｃ3
   ／  ＼  ／  ＼  ／  ＼  ／  ＼      ／  ＼  ／  ＼  ／  ＼  ／  ＼
 １      ４      ６      ４      １ 4Ｃ0    4Ｃ1    4Ｃ2    4Ｃ3    4Ｃ4 

                       図 : パスカルの三角形
</pre>
<p> パスカルの三角形は、左側の図のように両側がすべて 1 で、内側の数はその左上と右上の和になっています。これは (a + b)<sup>n</sup> を展開したときの各項の係数を表しています。そして、その値は右側の図のように組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> に対応しています。
</p>
<p> きれいな三角形にはなりませんが、簡単なプログラムを示します。
</p>
<pre class="list">
リスト : パスカルの三角形

def pascal(x):
    for n in xrange(0, x + 1):
        for r in xrange(0, n + 1):
            print comb(n, r),
        print
</pre>

<p> 実行結果は次のようになります。
</p>
<pre>
&gt;&gt;&gt; pascal(10)
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
1 10 45 120 210 252 210 120 45 10 1
</pre>
<p> 図のように、きれいな三角形を出力するプログラムは、皆さんにお任せいたします。また、関数 comb を使わないでパスカルの三角形を出力するプログラムを作ってみるのも面白いでしょう。
</p>

<h4>●組み合わせの生成 (1)</h4>
<p> 今度は <sub>n</sub>C<sub>r</sub> 個の組み合わせを全て生成するプログラムを作ってみましょう。たとえば、1 から 5 までの数字の中から 3 個を選ぶ組み合わせは次のようになります。
</p>
<pre class="fig">
[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5],
[2, 3, 4], [2, 3, 5], [2, 4, 5],
[3, 4, 5],
</pre>
<p> 最初に 1 を選択した場合、次は [2, 3, 4, 5] の中から 2 個を選べばいいですね。2 番目に 2 を選択したら、次は [3, 4, 5] の中から 1 個を選べばいいわけです。これで、[1, 2, 3], [1, 2, 4], [1, 2, 5] が生成されます。[2, 3, 4, 5] の中から 2 個選ぶとき、2 を選ばない場合があります。この場合は [3, 4, 5] の中から 2 個を選べばいいわけです。ここで 3 を選ぶと [1, 3, 4], [1, 3, 5] が生成できます。同様に、3 を除いた [4, 5] の中から 2 個を選ぶと [1, 4, 5] を生成することができます。
</p>
<p> これで 1 を含む組み合わせを生成したので、次は 1 を含まない組み合わせ、つまり [2, 3, 4, 5] から 3 個を選ぶ組み合わせを生成すればいいわけです。けっきょく、この処理の考え方は次に示す組み合わせの公式と同じです。
</p>
<pre class="fig">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r-1</sub> + <sub>n-1</sub>C<sub>r</sub>
</pre>
<p> Python でプログラムを作ると次のようになります。
</p>
<pre class="list">
リスト : 組み合わせの生成

def comb1(n, m, a = []):
    if m == 0:
        print a
    elif n == m:
        print range(1, m + 1) + a
    else:
        comb1(n - 1, m, a)
        comb1(n - 1, m - 1, [n] + a)
</pre>
<p> 関数 comb1 は、1 から n までの数字の中から m 個を選ぶ組み合わせを表示します。選んだ要素は変数 a のリストに格納します。m が 0 になったら組み合わせを一つ生成できたので、print で a を出力します。n が m と等しくなったならば、残りの数字 (1 から m まで) を全て選択します。range で 1 から m までの数字をリストに格納し、a と連結してから print で出力します。
</p>
<p> この 2 つの条件が再帰呼び出しの停止条件になります。あとは comb1 を再帰呼び出しするだけです。最初の呼び出しは数字 n を選ばない場合です。残りの数字の中から m 個の数字を選びます。最後の呼び出しが数字 n を選択する場合です。数字 n を a に追加して、残りの数字の中から m - 1 個を選びます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt;&gt;&gt; comb1(5, 3)
[1, 2, 3]
[1, 2, 4]
[1, 3, 4]
[2, 3, 4]
[1, 2, 5]
[1, 3, 5]
[2, 3, 5]
[1, 4, 5]
[2, 4, 5]
[3, 4, 5]
</pre>
<p> 正常に動作していますね。Python らしくジェネレータを使うと、次のようなプログラムになります。
</p>
<pre class="list">
リスト : 組み合わせの生成

def comb2(n, m):
    if m == 0:
        yield []
    elif n == m:
        yield range(1, m + 1)
    else:
        for a in comb2(n - 1, m):
            yield a
        for a in comb2(n - 1, m - 1):
            yield a + [n]
</pre>
<p> 実行例は次のようになります。
</p>
<pre>
&gt;&gt;&gt; for x in comb2(5, 3): print x
[1, 2, 3]
[1, 2, 4]
[1, 3, 4]
[2, 3, 4]
[1, 2, 5]
[1, 3, 5]
[2, 3, 5]
[1, 4, 5]
[2, 4, 5]
[3, 4, 5]
</pre>

<h4>●組み合わせの生成 (2)</h4>
<p> ところで、n 個の中から m 個を選ぶ組み合わせは、ビットのオンオフで表すことができます。たとえば、5 個の数字 (0 - 4) から 3 個を選ぶ場合、数字を 0 bit から 4 bit に対応させます。すると、1, 3, 4 という組み合わせは 11010 と表すことができます。
</p>
<p> これを Python でプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 組み合わせの生成

def comb3(n, m, a = 0):
    if m == 0:
        print "%x" % a
    elif m == n:
        print "%x" % (a | ((1 &lt;&lt; m) - 1))
    else:
        comb3(n - 1, m, a)
        comb3(n - 1, m - 1, a | (1 &lt;&lt; (n - 1)))
</pre>

<p> 関数 comb3 は n 個の中から m 個を選ぶ組み合わせを生成して出力します。組み合わせは引数 a にセットします。m が 0 になったら、組み合わせがひとつできたので a を出力します。n が m と等しくなったならば、残り m 個を全て選びます。(1 &lt;&lt; m) - 1 で m 個のビットをオンにして出力します。
</p>
<p> あとは comb3 を再帰呼び出しします。最初の呼び出しは n 番目の数字を選ばない場合です。n - 1 個の中から m 個を選びます。次の呼び出しが n 番目の数字を選ぶ場合で、a の n - 1 ビットをオンにします。そして、n - 1 個の中から m - 1 個を選びます。
</p>
<p> それでは 5 個の中から 3 個を選ぶ comb3(5, 3) の実行例を示します。
</p>
<pre>
 7 (00111)
 b (01011)
 d (01101)
 e (01110)
13 (10011)
15 (10101)
16 (10110)
19 (11001)
1a (11010)
1c (11100)
</pre>
<p> この場合、最小値は 0x07 (00111) で最大値は 0x1c (11100) になります。このように、comb3 は組み合わせを表す数を昇順で出力します。ところで、<a href="index.html#cite">参考文献 [2]</a> の「組み合わせの生成」には、再帰呼び出しを使わずに同じ結果を得る方法が解説されてます。とても巧妙な方法なので、興味のある方は読んでみてください。
</p>

<h4>●組み合わせに番号を付ける方法</h4>
<p> 次は、N 通りある組み合わせに 0 から N - 1 までの番号を付ける方法を紹介しましょう。たとえば、6 個の中から 3 個を選ぶ組み合わせは 20 通りありますが、この組み合わせに 0 から 19 までの番号を付けることができます。1 1 1 0 0 0 を例題に考えてみましょう。次の図を見てください。
</p>
<pre class="fig">
  5 4 3 2 1 0
  ─────────
  0 0 0 1 1 1    ↑
  0 0 1 0 1 1    │
  0 0 1 1 0 1    │
  0 0 1 1 1 0    │
  0 1 0 0 1 1    │
  0 1 0 1 0 1   5Ｃ3 = 10 通り
  0 1 0 1 1 0    │
  0 1 1 0 0 1    │
  0 1 1 0 1 0    │
  0 1 1 1 0 0    ↓
  ─────────
  1 0 0 0 1 1    ↑
  1 0 0 1 0 1    │
  1 0 0 1 1 0    │
  1 0 1 0 0 1   4Ｃ2 = 6 通り
  1 0 1 0 1 0    │
  1 0 1 1 0 0    ↓
    ────────
  1 1 0 0 0 1    ↑
  1 1 0 0 1 0   3Ｃ1 = 3 通り
  1 1 0 1 0 0    ↓
      ───────
  1 1 1 0 0 0    19 番目
  ─────────

  図：6Ｃ3 の組み合わせ
</pre>
<p> 最初に 5 をチェックします。5 を選ばない場合は <sub>5</sub>Ｃ<sub>3</sub> = 10 通りありますね。この組み合わせに 0 から 9 までの番号を割り当てることにすると、5 を選ぶ組み合わせの番号は 10 から 19 までとなります。
</p>
<p> 次に、4 をチェックします。4 を選ばない場合は、<sub>4</sub>Ｃ<sub>2</sub> = 6 通りあります。したがって、5 を選んで 4 を選ばない組み合わせに 10 から 15 までの番号を割り当てることにすると、5 と 4 を選ぶ組み合わせには 16 から 19 までの番号となります。
</p>
<p> 最後に、3 をチェックします。同様に 3 を選ばない場合は 3 通りあるので、これに 16 から 18 までの番号を割り当て、5, 4, 3 を選ぶ組み合わせには 19 を割り当てます。これで組み合わせ 1 1 1 0 0 0 の番号を求めることができました。
</p>
<p> では、0 0 0 1 1 1 はどうなるのでしょうか。左から順番にチェックしていくと、最初の 1 が見つかった時点で、その数字を選ばない組み合わせは存在しません。つまり、残りの数字をすべて選ぶしかないわけです。したがって、これが 0 番目となります。
</p>
<p> このように、数字を選ぶときに、数字を選ばない場合の組み合わせの数を足し算していけば、その組み合わせの番号を求めることができるのです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組み合わせを番号に変換

def comb_to_num(c, n, r, value = 0):
    if r == 0 or n == r: return value
    if c &amp; (1 &lt;&lt; (n - 1)):
        return comb_to_num(c, n - 1, r - 1, value + comb(n - 1, r))
    else:
        return comb_to_num(c, n - 1, r, value)
</pre>
<p> 引数 c はビットのオンオフで表した組み合わせ、引数 n と r は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。引数 value は求める番号を表します。n と r の値が同じになるか、もしくは r が 0 になれば、組み合わせの番号を計算できたので value を返します。
</p>
<p> そうでない場合、c の n - 1 ビットの値を調べます。ビットがオンであれば、value に comb(n - 1, r) の値を足し算し、r を -1 して comb_to_num を再帰呼び出しします。そうでなければ、value と r の値はそのままで comb_to_num を再帰呼び出しします。
</p>
<p> 逆に、番号から組み合わせを求めるプログラムも簡単に作ることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 番号を組み合わせに変換

def num_to_comb(value, n, r, c = 0):
    if r == 0:
        return c
    elif n == r:
        return c | ((1 &lt;&lt; n) - 1)
    else:
        k = comb(n - 1, r)
        if value &gt;= k:
            return num_to_comb(value - k, n - 1, r - 1, c | 1 &lt;&lt; (n - 1))
        else:
            return num_to_comb(value, n - 1, r, c)
</pre>
<p> 引数 value が番号で、引数 n と r は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。引数 c が求める組み合わせです。たとえば、n = 5, r = 3 の場合、ビットが 1 になるのは <sub>4</sub>C<sub>2</sub> = 6 通りあり、0 になるのは <sub>4</sub>C<sub>3</sub> = 4 通りあります。したがって、数値が 0 - 3 の場合はビットを 0 にし、4 - 9 の場合はビットを 1 にすればいいわけです。
</p>
<p> ビットを 0 にした場合、残りは <sub>4</sub>C<sub>3</sub> = 4 通りになるので、同様に次のビットを決定します。ビット 1 にした場合、残りは <sub>4</sub>C<sub>2</sub> = 6 通りになるので、value から 4 を引いて num_to_comb を再帰呼び出しして次のビットを決定します。
</p>
<p> r が 0 の場合は、組み合わせが完成したので c を返します。n と r が等しい場合は、残りのビットをすべて 1 にセットしてから c を返します。それ以外の場合は、<sub>n-1</sub>C<sub>r</sub> の値を comb(n - 1, r) で求めて変数 k にセットします。value が k 以上であれば変数 c のビットを 1 にセットし、value から k を引き算して comb_to_num を再帰呼び出しします。そうでなければ、num_to_comb を再帰呼び出しするだけです。
</p>
<p> それでは、n = 5, r = 3 の場合の実行例を示します。
</p>
<pre>
&gt;&gt;&gt; for x in range(10):
    y = num_to_comb(x, 5, 3)
    z = comb_to_num(y, 5. 3)
    print "%d =&gt; %x =&gt; %d" % (x, y, z)

0 =&gt; 7 =&gt; 0
1 =&gt; b =&gt; 1
2 =&gt; d =&gt; 2
3 =&gt; e =&gt; 3
4 =&gt; 13 =&gt; 4
5 =&gt; 15 =&gt; 5
6 =&gt; 16 =&gt; 6
7 =&gt; 19 =&gt; 7
8 =&gt; 1a =&gt; 8
9 =&gt; 1c =&gt; 9
</pre>
<p> 正常に動作していますね。この方法を使うと、n 個ある組み合わせの中の i 番目 (0 &lt;= i &lt n) の組み合わせを簡単に求めることができます。
</p>

<h4>●たらいまわし関数</h4>
<p> 最後に、再帰を使った面白い関数を紹介しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数

def tarai(x, y, z):
    if x &lt;= y: return y
    return tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))

def tak(x, y, z):
    if x &lt;= y: return z
    return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))
</pre>
<p> 関数 tarai や tak は「たらいまわし関数」といい、再帰的に定義されています。これらの関数は、引数の与え方によっては実行に時間がかかるため、Lisp などのベンチマークに利用されることがあります。Common Lisp のプログラムは <a href="http://www.nue.org/nue/index.html">ぬえ 鵺 NUE</a> の <a href="http://www.nue.org/nue/index.html#tak-function">TAK Function</a> にあります。
</p>

<p> 関数 tarai は通称「竹内関数」と呼ばれていて、日本の代表的な Lisper である竹内郁雄氏によって考案されたそうです。そして、関数 tak は関数 tarai のバリエーションで、John Macarthy 氏によって作成されたそうです。たらいまわし関数が Lisp のベンチマークで使われていたことは知っていましたが、このような由緒ある関数だとは思ってもいませんでした。
</p>
<p> それでは、さっそく実行してみましょう。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。
</p>
<pre>
tarai(12, 6, 0) : 6.72 [s]
tak(18, 9, 0)   : 8.40 [s]
</pre>
<p> このように、たらいまわし関数は引数の値が小さくても実行に時間がかかります。Python 2.5 では、もう少し速くなるかもしれません。興味のある方は試してみてください。
</p>

<h4>●メモ化による高速化</h4>
<p> たらいまわし関数が遅いのは、同じ値を何度も計算しているためです。この場合、表 (table) を使って処理を高速化することができます。同じ値を何度も計算することがないように、計算した値は表に格納しておいて、2 回目以降は表から計算結果を求めるようにします。このような手法を「表計算法」とか「メモ化」といいます。
</p>
<p> Python の場合、辞書 (ハッシュ表) を使うと簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数のメモ化

table = {}    # メモ用の辞書

def tarai(x, y, z):
    global table
    key = (x, y, z)
    if not key in table:
        if x &lt;= y:
            table[key] = y
        else:
            table[key] = tarai(tarai(x - 1, y, z),
                               tarai(y - 1, z, x),
                               tarai(z - 1, x, y))
    return table[key]
</pre>
<p> 関数 tarai の値を格納する辞書をグローバル変数 table に用意します。関数 tarai では、引数 x, y, z を要素とするタプルを作り、それをキーとして辞書 table を検索します。table に key があれば、その値を返します。そうでなければ、値を計算して table にセットして、その値を返します。
</p>
<p> このようにメモ化のプログラムは簡単にできますが、メモ化を行うたびに関数を修正するのは面倒ですね。そこで、<a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs (SICP)</a> <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.3">3.3.3  Representing Tables</a> を参考に、関数をメモ化する「メモ化関数」を作成してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : メモ化関数 (1)

def memoize(f):
    table = {}
    def func(*args):
        if not args in table:
            table[args] = f(*args)
        return table[args]
    return func
</pre>

<p> 関数 memoize は関数 f を引数に受け取り、それをメモ化した関数を返します。memoize が返す関数はクロージャなので、memoize の引数 f や局所変数 table にアクセスすることができます。詳しい説明は拙作のページ <a href="python03.html">お気楽 Python プログラミング入門 第 3 回</a> をお読みください。また、関数 func の引数を *args で定義することで、複数の引数を持つ関数にも対応していることに注意してください。
</p>
<p> args の値は引数を格納したタプルになるので、これをキーとして扱います。table に キー args がなければ、関数 f を呼び出して値を計算し、それを table にセットします。最後に table[args] の値を返すだけです。
</p>
<p> 関数をメモ化する場合、Python では次のようにデコレータ表記を使うと簡単です。
</p>
<pre class="list">
リスト : たらいまわし関数のメモ化 (1)

@memoize
def tarai(x, y, z):
    if x &lt;= y: return y
    return tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))
</pre>
<p> これは次に示すように tarai の値をメモ化した関数に書き換える動作になります。
</p>
<pre class="list">
リスト : たらいまわし関数のメモ化 (2)

def tarai(x, y, z):
    if x &lt;= y: return y
    return tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))

tarai = memoize(tarai)
</pre>
<p> tarai の値を書き換えないと、関数 tarai の中で再帰呼び出しするとき、メモ化した関数を呼び出すことはできません。ご注意ください。
</p>
<p> また、メモ化関数は Python らしくクラスを使っても実装することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : メモ化関数 (2)

class Memoize:
    def __init__(self, func):
        self.table = {}
        self.f = func

    def __call__(self, *args):
        if not args in self.table:
            self.table[args] = self.f(*args)
        return self.table[args]
</pre>
<p> クラス Memoize のインスタンス変数 table にメモ用の辞書を、f に関数 func をセットします。あとは、メソッド __call__ で関数 memoize と同様の処理を行うだけです。関数のメモ化は memoize と同様にデコレータ表記を使うと簡単です。
</p>
<pre class="list">
リスト : たらいまわし関数のメモ化 (3)

@Memoize
def tarai(x, y, z):
    if x &lt;= y: return y
    return tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))
</pre>
<p> これで関数をメモ化することができます。この場合、変数 tarai には Memoize のインスタンスが格納され、それを関数呼び出しすることでメソッド __call__ が呼び出され、関数のメモ化が機能します。
</p>
<p> それでは実際に実行してみましょう。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。
</p>
<pre>
@memoize
tarai(12, 6, 0) : 0.0010 [s]
tak(18, 9, 0)   : 0.0022 [s]

@Memoize
tarai(12, 6, 0) : 0.0015 [s]
tak(18, 9, 0)   : 0.0035 [s]
</pre>
<p> とても速くなりましたね。Python 2.4 の場合、__call__ メソッドの呼び出しは通常の関数呼び出しよりも時間が少しかかるため、関数 memoize によるメモ化の方が少し速くなりました。興味のある方は Python 2.5 でも試してみてください。
</p>

<h4>●遅延評価による高速化</h4>
<p> 関数 tarai は「遅延評価」を行う処理系、たとえば関数型言語の Haskell では高速に実行することができます。また、Scheme でも delay と force を使って遅延評価を行うことができます。tarai のプログラムを見てください。x &lt;= y のときに y を返しますが、このとき引数 z の値は必要ありませんね。引数 z の値は x &gt; y のときに計算するようにすれば、無駄な計算を省略することができます。
</p>
<p> なお、関数 tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意ください。
</p>
<p> 完全ではありませんが、Python でもクロージャを使って遅延評価を行うことができます。<a href="http://www.shiro.dreamhost.com/scheme/index-j.html">Shiro さん</a> の <a href="http://www.shiro.dreamhost.com/scheme/wiliki/wiliki.cgi">WiLiKi</a> にある <a href="http://practical-scheme.net/wiliki/wiliki.cgi?Scheme%3A%A4%BF%A4%E9%A4%A4%A4%DE%A4%EF%A4%B7%A4%D9%A4%F3%A4%C1">Scheme:たらいまわしべんち</a> を参考に、プログラムを作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : クロージャによる遅延評価

def tarai(x, y, z):
    if x &lt;= y: return y
    zz = z()
    return tarai(tarai(x - 1, y, lambda : zz),
                 tarai(y - 1, zz, lambda : x),
                 lambda : tarai(zz - 1, x, lambda : y))
</pre>
<p> 遅延評価したい処理をクロージャに包んで引数 z に渡します。そして、x &gt; y のときに引数 z を評価 (関数呼び出し) します。すると、クロージャ内の処理が実行されて z の値を求めることができます。たとえば、lambda : 0 を z に渡す場合、z() とすると返り値は 0 になります。lambda : x を渡せば、x に格納されている値が返されます。lambda : tarai( ... ) を渡せば、関数 tarai が実行されてその値が返されるわけです。
</p>
<p> それでは、実際に実行してみましょう。実行環境は Windows XP, celeron 1.40 GHz, Python 2.4.2 です。
</p>
<pre>
tarai(192, 96, 0)
メモ化   : 0.26 [s]
遅延評価 : 0.048 [s]
</pre>
<p> tarai 関数の場合、遅延評価の効果はとても大きいですね。ところで、クロージャを使わなくても、tarai 関数を高速化する方法があります。<a href="http://www.tietew.jp/cppll/">C++:language&libraries (cppll)</a> で <a href="http://www.tietew.jp/cppll/archive/10669">Akira Higuchi さん</a> が書かれたＣ言語の tarai 関数はとても高速です。Python でプログラムすると次のようになります。
</p>
<pre class="list">
リスト : tarai 関数の遅延評価 (2)

def tarai_lazy(x, y, xx, yy, zz):
    if x &lt;= y: return y
    z = tarai(xx, yy, zz)
    return tarai_lazy(tarai(x - 1, y, z), tarai(y - 1, z, x), z - 1, x, y)

def tarai(x, y, z):
    if x &lt;= y: return y
    return tarai_lazy(tarai(x - 1, y, z), tarai(y - 1, z, x), z - 1, x, y)
</pre>
<p> 関数 tarai_lazy の引数 xx, yy, zz で z の値を表すところがポイントです。つまり、z の計算に必要な値を引数に保持し、z の値が必要になったときに tarai(xx, yy, zz) で計算するわけです。実際に実行してみると tarai(192, 96, 0) は 0.018 [s] になりました。このような簡単な方法で tarai 関数を高速化できるとは驚きました。Akira Higuchi さんに感謝いたします。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="index.html#python_algo">Python</a> | <a href="pyalgo02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>