<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Algorithms with Python / ヒープ</title>
  <meta name="description" content="Python,アルゴリズム,データ構造,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881799</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Algorithms with Python</h1>
<h2>ヒープ [2]</h2>
<div class="small">
[ <a href="pyalgo65.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo67.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 拙作のページ <a href="pyalgo03.html">二分木とヒープ</a> で説明した「ヒープ (heap) 」は、「優先度つき待ち行列 (プライオリティキュー : priority queue) 」の実装でよく使われるデータ構造です。プライオリティキューはとても便利なデータ構造で、拙作のページ <a href="pyalgo28.html">ヒューリスティック探索</a> では「最良優先探索」と「A* アルゴリズム」を実装するときに使いました。このほかに、グラフ理論のアルゴリズムでもプライオリティキューはよく使われています。
</p>
<p> 今回は MST (Minimum Spanning Tree) を求める「プリムのアルゴリズム」にプライオリティキューを適用して、どのくらい処理を高速化できるか試してみましょう。
</p>

<h4>●Euclidean MST</h4>
<p> MST を求める「プリムのアルゴリズム」と「クラスカルのアルゴリズム」は拙作のページ <a href="pyalgo23.html">欲張り法 [2]</a> で詳しく説明しました。頂点の個数を N, 辺の総数を E とすると、プリムのアルゴリズムの場合、単純な実装方法だと実行時間は N<sup>2</sup> に比例し、クラスカルのアルゴリズムは E * log<sub>2</sub> E に比例します。頂点に接続されている辺の本数が少ない場合、クラスカルのアルゴリズムのほうが速いのですが、辺の総数が増えると、プリムのアルゴリズムのほうが速くなる場合もあります。
</p>
<p> そこで、辺の総数が多い例として Euclidean MST を取り上げることにします。Euclidean MST は平面上に与えられた N 個の頂点の MST を求める問題です。一つの頂点には N - 1 本の辺が接続されていて、各辺のコストは 2 点間の直線距離 (Euclidean distance) になります。この場合、辺の総数 E は N<sup>2</sup> に比例するので、クラスカルのアルゴリズムでは N<sup>2</sup> * log<sub>2</sub> N に比例する時間がかかることになり、プリムのアルゴリズムよりも遅くなると思われます。
</p>

<h4>●プログラムの作成</h4>
<p> それでは実際にプログラムを作って確かめてみましょう。データの形式と読み込みは拙作のページ <a href="pyalgo62.html">巡回セールスマン問題</a> と同じで、読み込んだデータは大域変数 point_table にセットされます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : Euclidean MST

# 距離の計算
def dis(p1, p2):
    dx = p1[0] - p2[0]
    dy = p1[1] - p2[1]
    return int(math.sqrt(dx * dx + dy * dy) + 0.5)

##
## 辺の定義
##
class Edge:
    def __init__(self, p1, p2, weight):
        self.p1 = p1
        self.p2 = p2
        self.weight = weight    # 整数値

    def __cmp__(x, y):
        return x.weight - y.weight

##
## クラスカルのアルゴリズム
##
def kruskal(size):
    q = pqueue.PQueue()
    s = []
    u = UnionFind(size)
    # 辺をヒープに追加
    for i in xrange(size - 1):
        for j in xrange(i + 1, size):
            q.push(Edge(i, j, dis(point_table[i], point_table[j])))
    i = 0
    while i &lt; size - 1:
        e = q.pop()
        if u.find(e.p1) != u.find(e.p2):
            u.union(e.p1, e.p2)
            s.append(e)
            i += 1
    return s

##
## プリムのアルゴリズム
##
def prim(size):
    closest = [0] * size
    low_cost = [0] * size
    s = []
    # 初期化
    for i in xrange(size):
        low_cost[i] = dis(point_table[0], point_table[i])
    # 頂点の選択
    for i in xrange(1, size):
        min = low_cost[1]
        k = 1
        for j in xrange(2, size):
            if min &gt; low_cost[j]:
                min = low_cost[j]
                k = j
        s.append(Edge(k, closest[k], min))
        low_cost[k] = INF
        for j in xrange(1, size):
            l = dis(point_table[k], point_table[j])
            if low_cost[j] &lt; INF and low_cost[j] &gt; l:
                low_cost[j] = l
                closest[j] = k
    return s
</pre>
<p> 関数 dis は 2 点間の距離を計算して整数値に変換して返します。0.5 を加算しているのは小数点第 1 位で四捨五入するためです。クラスカルのアルゴリズムはモジュール pqueue と unionfind を使っています。最初にすべての辺をプライオリティキューに登録し、短い辺から順番に取り出していきます。 UnionFind のメソッド find で閉路ができないことを確認し、選んだ辺を配列 s に追加します。N - 1 本の辺を選んだら配列 s を return で返します。
</p>
<p> プリムのアルゴリズムも簡単です。low_cost に最小のコストを、closest に最小のコストになる頂点を記憶します。最初、closest は 0 に、low_cost は 0 と他の頂点の距離に初期化します。あとは、low_cost の中で最小値の頂点 k を選び、辺 Edge を生成して配列 s に追加します。そして、low_cost と closest の値を更新します。最後に選択した辺を格納した配列 s を返します。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="pyalgo66.html#list1">プログラムリスト１</a> をお読みください。
</p>
<h4>●実行結果</h4>
<p> それでは実行してみましょう。乱数で適当に作成したデータ (500 個, 1000 個, 1500 個) の場合、結果は次のようになりました。
</p>

<p><img src="img/emst0.png"> N = 500
</p>
<p><img src="img/emst1.png"> N = 1000
</p>
<p><img src="img/emst2.png"> N = 1500
</p>
<pre>
    表 : 実行結果 (単位 秒)

 個数 : 距離  :    krus      :     prim
------+-------+--------------+--------------
  500 :  7803 :  2.72 (1.00) :  0.64 (1.00)
 1000 : 11418 : 11.55 (4.24) :  2.55 (3.98)
 1500 : 14739 : 25.39 (9.33) :  5.75 (8.98)

krus: クラスカルのアルゴリズム
prim: プリムのアルゴリズム

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<p> 結果を見ればおわかりのように、プリムのアルゴリズムのほうが高速になりました。500 個の実行時間を 1.00 とすると、プリムのアルゴリズムがだいたい N<sup>2</sup> に比例しているのに対し、クラスカルのアルゴリズムはそれ以上の時間がかかっていることがわかります。
</p>

<h4>●プリムのアルゴリズムの改良</h4>
<p> プリムのアルゴリズムはプライオリティキューを使って改良することができます。一番簡単な方法は、頂点を選択したとき、それにつながる辺をすべてプライオリティキューに追加することです。次のリストを見てください。
</p>
<pre class="list">
リスト : プリムのアルゴリズム (改良版)

def prim0(size):
    q = pqueue.PQueue()
    v = [False] * size
    s = []
    q.push(Edge(0, 0, 0))
    #
    i = 0
    while i &lt; size:
        e = q.pop()
        if v[e.p2]: continue
        v[e.p2] = True
        s.append(e)
        # e.p2 につながる辺を追加
        for j in xrange(size):
            if not v[j]:
                q.push(Edge(e.p2, j, dis(point_table[e.p2], point_table[j])))
        i += 1
    return s[1:]
</pre>
<p> プライオリティキューは変数 q にセットします。配列 v は頂点を選択したとき True をセットします。最初は False に初期化します。配列 s は選んだ辺を格納します。最初、ダミーで頂点 0 から 0 までの辺 (長さ 0) をキューにセットします。そして、while ループでダミーの辺を入れて size 本の辺を選択します。
</p>
<p> 頂点の選択は簡単です。キューから辺を pop() で取り出します。辺 e を生成する場合、辺の両端 p1, p2 のうち　p1 は選択済みの頂点、p2 は未選択の頂点、weight が p1 から p2 までの距離とします。キューから辺を取り出したとき、p2 は既に選択されている場合があるので、それを v[e.p2] でチェックします。False の場合、頂点 e.p2 を選択して、辺を s に追加します。そして、e.p2 につながる辺の中で、未選択の頂点につながる辺をすべてキューに追加します。
</p>

<p> この方法は辺をすべてキューに追加することになるので、実行時間はクラスカルのアルゴリズムと同じく E * log<sub>2</sub> E となります。辺の総数が少ない場合、クラスカルのアルゴリズムと同じく高速に動作しますが、辺の総数が増えると遅くなってしまいます。そこで、各頂点の最短距離を配列に格納しておいて、それよりも短い辺をキューに追加することにします。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : プリムのアルゴリズム (改良版１)

def prim1(size):
    q = pqueue.PQueue()
    v = [False] * size
    d = [INF] * size
    s = []
    q.push(Edge(0, 0, 0))
    #
    i = 0
    while i &lt; size:
        e = q.pop()
        if v[e.p2]: continue
        v[e.p2] = True
        s.append(e)
        # e.p2 につながる辺を追加
        for j in xrange(size):
            if not v[j]:
                l = dis(point_table[e.p2], point_table[j])
                if l &lt; d[j]:
                    d[j] = l
                    q.push(Edge(e.p2, j, l))
        i += 1
    return s[1:]
</pre>
<p> 配列 d に各頂点の最短距離を格納します。最初は INF (999999999) で処理化します。そして、辺 e.p2 - j をキューに追加するとき、距離を計算して変数 l にセットします。l &lt; d[j] であれば d[j] を l に書き換えて、辺 e.p2 - j をキューに追加します。これで、プライオリティキューに追加される辺の個数が抑えれれるので、実行速度も速くなると思われます。
</p>

<h4>●実行結果 (2)</h4>
<p> それでは実行してみましょう。
</p>
<pre>
                表 : 実行結果 (単位 秒)

      : 距離  : krus  : prim  : prim0 : prim1 
------+-------+-------+-------+-------+-------
  500 :  7803 :  2.72 :  0.64 :  2.84 :  0.78 
 1000 : 11418 : 11.55 :  2.55 : 11.91 :  2.55 
 1500 : 14739 : 25.39 :  5.75 : 26.59 :  4.69 

krus : クラスカルのアルゴリズム
prim : プリムのアルゴリズム
prim0: プリムのアルゴリズム (改良版)
prim1: プリムのアルゴリズム (改良版１)

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<p> prim0 はクラスカルのアルゴリズムと同じで、実行時間は prim よりも遅くなりました。辺の総数が少なければ prim よりも速くなると思います。prim1 の場合、頂点の個数が少ないと prim よりも少し遅くなりましたが、頂点の個数が多くなると prim よりも速くなりました。
</p>
<p> ところで、プリムのアルゴリズムは選択済みの頂点から最短距離の頂点を選べばいいのですから、プライオリティキューに格納するのは未選択の頂点と最短距離でいいはずです。そうすると、キューの大きさは最大で N に抑えることができます。ただし、キューにあるデータの最短距離を書き換える、つまり優先順位 (プライオリティ) を変更する操作が必要になります。この操作を「キー値の減算 (decrease key) 」といいます。
</p>
<p> <a href="http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95">プリム法 - Wikipedia</a> によると、decrease key の操作が log<sub>2</sub> N に比例する時間で実行できる場合、プリムのアルゴリズムは (N + E) * log<sub>2</sub> N =&gt; E * log<sub>2</sub> N に比例する時間で実行することができる、とのことです。
</p>

<h4>●キー値の減算処理</h4>
<p> それではプライオリティキューにメソッド decrease_key(x, d) を追加しましょう。x はキューに格納するオブジェクト、d がキーから減算する値です。配列に格納されているオブジェクト x の位置 (添字) がわかれば、プライオリティの変更操作は log<sub>2</sub> N に比例する時間で行うことができます。そこで、オブジェクトの位置 (添字) を辞書に格納しておくことにします。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : プライオリティキュー (decrease_key の追加)

# 葉の方向へ
def _downheap(buff, n, idx):
    size = len(buff)
    while True:
        c = 2 * n + 1
        if c &gt;= size: break
        if c + 1 &lt; size:
            if not buff[c] &lt;= buff[c + 1]: c += 1
        if buff[n] &lt;= buff[c]: break
        temp = buff[n]
        buff[n] = buff[c]
        buff[c] = temp
        idx[buff[c]] = c
        idx[buff[n]] = n
        n = c

# 根の方向へ
def _upheap(buff, n, idx):
    while True:
        p = (n - 1) / 2
        if p &lt; 0 or buff[p] &lt;= buff[n]: break
        temp = buff[n]
        buff[n] = buff[p]
        buff[p] = temp
        idx[buff[n]] = n
        idx[buff[p]] = p
        n = p

class PQueue:
    def __init__(self, buff = []):
        self.buff = buff[:]   # コピー
        self.idx = {}
        for x in xrange(len(buff)):
            self.idx[buff[x]] = x
        for n in xrange(len(self.buff) / 2 - 1, -1, -1):
            _downheap(self.buff, n, self.idx)

    # 最小値を取り出す
    def pop(self):
        if len(self.buff) == 0: raise IndexError
        value = self.buff[0]
        del self.idx[value]
        last = self.buff.pop()
        if len(self.buff) &gt; 0:
            # ヒープの再構築
            self.buff[0] = last
            self.idx[last] = 0
            _downheap(self.buff, 0, self.idx)
        return value

    # データの挿入
    def push(self, data):
        self.buff.append(data)
        self.idx[data] = len(self.buff) - 1
        _upheap(self.buff, len(self.buff) - 1, self.idx)

    # 最小値を求める
    def peek(self): return self.buff[0]

    # 空か
    def isEmpty(self): return len(self.buff) == 0

    # 格納されているデータを返す
    def content(self): return self.buff

    # キー値の減算
    def decrease_key(self, x, d):
        x.decrease_key(d)
        if d &gt; 0:
            _upheap(self.buff, self.idx[x], self.idx)
        else:
            _downheap(self.buff, self.idx[x], self.idx)
</pre>
<p> 関数 _upheap, _downheap の引数 idx は、オブジェクトの添字を格納する辞書です。オブジェクトを移動したら、idx にその位置をセットします。__init__() では、オブジェクトを配列に格納して与えられたとき、オブジェクトの位置を idx にセットする処理を追加します。メソッド pop() はオブジェクトを削除したとき、idx のデータも削除するようにします。最後尾のデータを先頭に移動したとき、idx の値も書き換えることに注意してください。メソッド push() も簡単です。配列の最後尾に data を追加したとき、idx にその位置をセットします。メソッド content はデータを格納している配列 buff を返します。
</p>

<p> x の位置がわかると、メソッド decrease_key は簡単です。最初に、オブジェクト x のメソッド decrease_key を呼び出して、キーの値から d を減算します。次に、d の値が正であればキーの値は減少しているので、_upheap() を呼び出してオブジェクト x がヒープの条件を満たすように修正します。逆に、d が負の値であればキーの値は増加しているので _downheap() を呼び出して x の位置を修正します。
</p>

<p> このように辞書の操作が加わるため、今までよりも push(), pop() の操作が遅くなるのは仕方がありません。decrease_key の操作が必要ない場合は、今までのプライオリティキューを使ったほうがよいでしょう。
</p>

<h4>●簡単なテスト</h4>
<p> それではここで decrease_key の簡単なテストを行ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 簡単なテスト

if __name__ == '__main__':
    class Num:
        def __init__(self, n):
            self.n = n

        def __cmp__(x, y):
            return x.n - y.n

        def decrease_key(self, d):
            self.n -= d

        def __str__(self):
            return "(%d)" % self.n

        def __hash__(self):
            return id(self)
    
    a = [Num(x) for x in xrange(10)]
    q = PQueue(a)
    for x in xrange(10):
        print x, ":", q.peek(), a[x],
        q.decrease_key(a[x], 20)
        print q.peek(), a[x],
        q.decrease_key(a[x], -20)
        print q.peek(), a[x]
    while not q.isEmpty():
        print q.pop(),
    print
</pre>
<p> 整数値を格納するクラス Num を定義します。この中で必要なメソッド __cmp__(), decrease_key(), __hash__() を定義します。辞書にオブジェクトを格納する場合、__hash__() の定義が必要になります。
</p>
<p> テストは簡単で、0 - 9 を格納した Num のオブジェクトを生成してキューに追加します。そして a[x] のデータを decrease_key で -20 したあと、+20 して元に戻します。そのとき、peek() で最小値を求めて表示します。実行結果は次のようになります。
</p>

<pre>
0 : (0) (0) (-20) (-20) (0) (0)
1 : (0) (1) (-19) (-19) (0) (1)
2 : (0) (2) (-18) (-18) (0) (2)
3 : (0) (3) (-17) (-17) (0) (3)
4 : (0) (4) (-16) (-16) (0) (4)
5 : (0) (5) (-15) (-15) (0) (5)
6 : (0) (6) (-14) (-14) (0) (6)
7 : (0) (7) (-13) (-13) (0) (7)
8 : (0) (8) (-12) (-12) (0) (8)
9 : (0) (9) (-11) (-11) (0) (9)
(0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
</pre>
<p> a[0] の値は 0 で、それが最小値になります。0 から 20 減算すると、最小値は -20 になり、a[0] の値も -20 になります。20 を加算すると元の値に戻ります。次に、a[1] の値は 1 で最小値は 0 です。1 から 20 減算すると、最小値は -19 になり、a[1] の値も -19 になります。20 を加算すると元の値に戻り、最小値も 0 になります。あとは同じ動作で、最後にデータを pop() で取り出していくと、小さな値から順番に出力されます。
</p>

<h4>●プリムのアルゴリズムの改良 (2)</h4>
<p> それでは decrease_key を使ってプリムのアルゴリズムを改良しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : プリムのアルゴリズム (改良版２)

# 辺の定義
class Edge:
    def __init__(self, p1, p2, weight):
        self.p1 = p1
        self.p2 = p2
        self.weight = weight    # 整数値

    def decrease_key(self, x):
        self.weight -= x

    def __cmp__(x, y):
        return x.weight - y.weight

    def __hash__(self):
        return id(self)

# プリムのアルゴリズム (E * log N)
def prim2(size):
    q = pqueuedk.PQueue()
    s = []
    for i in xrange(1, size):
        q.push(Edge(0, i, dis(point_table[0], point_table[i])))
    #
    while not q.isEmpty():
        e = q.pop()
        s.append(e)
        for x in q.content():
            l = dis(point_table[e.p2], point_table[x.p2])
            if l &lt; x.weight:
                # 値の書き換え
                x.p1 = e.p2
                q.decrease_key(x, x.weight - l)
    return s
</pre>
<p> クラス Edge にはメソッド decrease_key() と __hash__() を追加します。関数 prim2 は、最初に頂点 0 と他の頂点を結ぶ辺を生成し、それをプライオリティキュー q にセットします。あとは、キューからデータを取り出して、decrease_key でキーの値を書き換えていくだけです。このとき、キューに残っているデータがまだ選択していない頂点になります。メソッド content() でキュー内のデータを取り出し、距離を比較して値が小さければ、辺の値を書き換えます。
</p>
<p> decrease_key を実行すると、データ x が配列の前方へ移動し、配列の値が書き換えられます。x よりも前にあるデータはチェック済みなので、for 文の中で配列の値を書き換えても問題なく動作します。逆に、x よりも後ろにあるデータと交換する場合は正常に動作しません。ご注意ください。
</p>
<h4>●実行結果 (3)</h4>
<p> それでは実行してみましょう。結果は次のようになりました。
</p>
<pre>
                表 : 実行結果 (単位 秒)

      : 距離  : krus  : prim  : prim0 : prim1 : prim2
------+-------+-------+-------+-------+-------+-------
  500 :  7803 :  2.72 :  0.64 :  2.84 :  0.78 :  0.50
 1000 : 11418 : 11.55 :  2.55 : 11.91 :  2.55 :  1.82
 1500 : 14739 : 25.39 :  5.75 : 26.59 :  4.69 :  3.72

実行環境 : Windows XP, celeron 1.40 GHz, Python 2.7
</pre>
<p> decrease_key を使うことで、prim, prim1 よりも速くなりました。辺の総数が多い Euclidean MST の場合、decrease_key の効果は大きいようです。辺の総数が少ない場合、prim1 で十分かもしれません。
</p>

<p> なお、これらの結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>

<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
# coding: utf-8
#
# emst.py : ユークリッド距離による MST
#
#           Copyright (C) 2012 Makoto Hiroi
#

import sys
import math
import time
import pqueue
import pqueuedk
from unionfind import *
from Tkinter import *

# 無限大
INF = 999999999

# 標準入力よりデータを読み込む
def read_data():
    buff = []
    for a in sys.stdin:
        b = a.split()
        buff.append((int(b[0]), int(b[1])))
    return buff

# 距離の計算
def dis(p1, p2):
    dx = p1[0] - p2[0]
    dy = p1[1] - p2[1]
    return int(math.sqrt(dx * dx + dy * dy) + 0.5)

# 距離の計算
def edge_length(select_edge):
    n = 0
    for e in select_edge:
        n += e.weight
    return n

##
## 辺の定義
##
class Edge:
    def __init__(self, p1, p2, weight):
        self.p1 = p1
        self.p2 = p2
        self.weight = weight    # 整数値

    def decrease_key(self, x):
        self.weight -= x

    def __cmp__(x, y):
        return x.weight - y.weight

    def __hash__(self):
        return id(self)

##
## クラスカルのアルゴリズム
##
def kruskal(size):
    q = pqueue.PQueue()
    s = []
    u = UnionFind(size)
    # 辺をヒープに追加
    for i in xrange(size - 1):
        for j in xrange(i + 1, size):
            q.push(Edge(i, j, dis(point_table[i], point_table[j])))
    i = 0
    while i &lt; size - 1:
        e = q.pop()
        if u.find(e.p1) != u.find(e.p2):
            u.union(e.p1, e.p2)
            s.append(e)
            i += 1
    return s

##
## プリムのアルゴリズム
##
def prim(size):
    closest = [0] * size
    low_cost = [0] * size
    s = []
    # 初期化
    for i in xrange(size):
        low_cost[i] = dis(point_table[0], point_table[i])
    # 頂点の選択
    for i in xrange(1, size):
        min = low_cost[1]
        k = 1
        for j in xrange(2, size):
            if min &gt; low_cost[j]:
                min = low_cost[j]
                k = j
        s.append(Edge(k, closest[k], min))
        low_cost[k] = INF
        for j in xrange(1, size):
            l = dis(point_table[k], point_table[j])
            if low_cost[j] &lt; INF and low_cost[j] &gt; l:
                low_cost[j] = l
                closest[j] = k
    return s


def prim0(size):
    q = pqueue.PQueue()
    v = [False] * size
    s = []
    q.push(Edge(0, 0, 0))
    #
    i = 0
    while i &lt; size:
        e = q.pop()
        if v[e.p2]: continue
        v[e.p2] = True
        s.append(e)
        # e.p2 につながる辺を追加
        for j in xrange(size):
            if not v[j]:
                q.push(Edge(e.p2, j, dis(point_table[e.p2], point_table[j])))
        i += 1
    return s[1:]

def prim1(size):
    q = pqueue.PQueue()
    v = [False] * size
    d = [INF] * size
    s = []
    q.push(Edge(0, 0, 0))
    #
    i = 0
    while i &lt; size:
        e = q.pop()
        if v[e.p2]: continue
        v[e.p2] = True
        s.append(e)
        # e.p2 につながる辺を追加
        for j in xrange(size):
            if not v[j]:
                l = dis(point_table[e.p2], point_table[j])
                if l &lt; d[j]:
                    d[j] = l
                    q.push(Edge(e.p2, j, l))
        i += 1
    return s[1:]

def prim2(size):
    q = pqueuedk.PQueue()
    s = []
    for i in xrange(1, size):
        q.push(Edge(0, i, dis(point_table[0], point_table[i])))
    #
    while not q.isEmpty():
        e = q.pop()
        s.append(e)
        for x in q.content():
            l = dis(point_table[e.p2], point_table[x.p2])
            if l &lt; x.weight:
                # 値の書き換え
                x.p1 = e.p2
                q.decrease_key(x, x.weight - l)
    return s

##
## 実行
##
point_table = read_data()
point_size = len(point_table)

s = time.clock()
es = kruskal(point_size)
print edge_length(es)
print time.clock() - s

s = time.clock()
es = prim(point_size)
print edge_length(es)
print time.clock() - s

s = time.clock()
es = prim0(point_size)
print edge_length(es)
print time.clock() - s

s = time.clock()
es = prim1(point_size)
print edge_length(es)
print time.clock() - s

s = time.clock()
es = prim2(point_size)
print edge_length(es)
print time.clock() - s

##
## 経路の表示
##

# 辺の表示
def draw_edge(edge):
    global point_table
    for e in edge:
        x0, y0 = point_table[e.p1]
        x1, y1 = point_table[e.p2]
        id = c0.create_line(x0, y0, x1, y1)

# 都市の表示
def draw_point():
    for x, y in point_table:
        c0.create_oval(x - 2, y - 2, x + 2, y + 2, fill = "green")

max_x = max(map(lambda x: x[0], point_table)) + 20
max_y = max(map(lambda x: x[1], point_table)) + 20

root = Tk()
c0 = Canvas(root, width = max_x, height = max_y, bg = "white")
c0.pack()

draw_edge(es)
draw_point()

root.mainloop()
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
# coding: utf-8
#
# pqueuedk.py : 優先度つき待ち行列 (decrease_key をサポート)
#
#               Copyright (C) 2012 Makoto Hiroi
#

# 葉の方向へ
def _downheap(buff, n, idx):
    size = len(buff)
    while True:
        c = 2 * n + 1
        if c &gt;= size: break
        if c + 1 &lt; size:
            if not buff[c] &lt;= buff[c + 1]: c += 1
        if buff[n] &lt;= buff[c]: break
        temp = buff[n]
        buff[n] = buff[c]
        buff[c] = temp
        idx[buff[c]] = c
        idx[buff[n]] = n
        n = c

# 根の方向へ
def _upheap(buff, n, idx):
    while True:
        p = (n - 1) / 2
        if p &lt; 0 or buff[p] &lt;= buff[n]: break
        temp = buff[n]
        buff[n] = buff[p]
        buff[p] = temp
        idx[buff[n]] = n
        idx[buff[p]] = p
        n = p

class PQueue:
    def __init__(self, buff = []):
        self.buff = buff[:]   # コピー
        self.idx = {}
        for x in xrange(len(buff)):
            self.idx[buff[x]] = x
        for n in xrange(len(self.buff) / 2 - 1, -1, -1):
            _downheap(self.buff, n, self.idx)

    # 最小値を取り出す
    def pop(self):
        if len(self.buff) == 0: raise IndexError
        value = self.buff[0]
        del self.idx[value]
        last = self.buff.pop()
        if len(self.buff) &gt; 0:
            # ヒープの再構築
            self.buff[0] = last
            self.idx[last] = 0
            _downheap(self.buff, 0, self.idx)
        return value

    # データの挿入
    def push(self, data):
        self.buff.append(data)
        self.idx[data] = len(self.buff) - 1
        _upheap(self.buff, len(self.buff) - 1, self.idx)

    # 最小値を求める
    def peek(self): return self.buff[0]

    # 空か
    def isEmpty(self): return len(self.buff) == 0

    # 格納されているデータを返す
    def content(self): return self.buff

    # キー値の減算
    def decrease_key(self, x, d):
        x.decrease_key(d)
        if d &gt; 0:
            _upheap(self.buff, self.idx[x], self.idx)
        else:
            _downheap(self.buff, self.idx[x], self.idx)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2012 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="pyalgo65.html">PrevPage</a> | <a href="index.html#python_algo">Python</a> | <a href="pyalgo67.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>