<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門 : 番外編</title>
  <meta name="description" content="Common Lisp, Common Lisp 入門, 番外編">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881768</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>Common Lisp 入門：番外編</h2>
<div class="small">
[ <a href="clispb14.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb16.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Common Lisp で作る micro Scheme (4)</h3>
<p> 今回は micro Scheme に「末尾再帰最適化」を実装しましょう。Scheme は言語仕様に末尾再帰最適化を行うことが明記されています。ところが Common Lisp の場合、末尾再帰最適化は仕様に含まれてないので、最適化の実装は処理系に依存します。
</p>

<p> SBCL は末尾再帰最適化が行われるので、micro Scheme を SBCL で動作させれば、プログラムを修正しなくても末尾再帰は最適化されます。ところが、CLISP で micro Scheme を動作させると、末尾再帰は最適化されません。SBCL の末尾再帰最適化は CLISP よりも優れているようです。
</p>
<p> なお、今回のプログラムで継続の実装は行いません。継続と末尾再帰の実装については今後の研究課題にしたいと思います。
</p>
<h4>●末尾呼び出しの最適化</h4>
<p> CLISP で micro Scheme の末尾呼び出しを最適化する場合、末尾呼び出しは m-eval を呼び出して評価するのではなく、そのときの m-eval の環境を使って評価するようにします。具体的には、m-eval の引数 expr と env を末尾呼び出しのものに書き換えて、それを評価すればいいわけです。末尾呼び出しを評価するとき、残りの処理を実行するための情報を保存する必要がないので、引数 expr と env を書き換えても正常に動作します。
</p>

<p> micro Scheme で末尾呼び出しが行われるのは、if を評価する関数 m-if とラムダ式の本体を評価する eval-body の 2 つです。これらの関数を m-eval に埋め込んで処理することもできますが、プログラムが複雑になってしまいます。そこで、m-if と eval-body は末尾の S 式を評価せずに、次のリストに格納して返すことにします。
</p>

<pre class="item">
(tail-call expr env)
</pre>

<p> expr は評価する S 式で、env はその時点での環境です。m-eval では S 式の評価結果をチェックし、それが (tail-call ...) であれば m-eval の引数 expr と env を書き換えて、それを再度評価することにします。今回は継続のことは考えずに、伝統的なマクロを実装した micro Scheme で末尾再帰最適化をプログラムします。
</p>
<h4>●m-if と eval-body の修正</h4>
<p> 関数 m-if と eval-body の修正は次のようになります。
</p>
<pre class="list">
リスト : if の処理

(defun m-if (expr env)
  (if (true-p (m-eval (cadr expr) env))
      (list 'tail-call (caddr expr) env)
    (if (null (cdddr expr))
        '*undef*
      (list 'tail-call (cadddr expr) env))))
</pre>

<pre class="list">
リスト : body の評価

(defun eval-body (body env)
  (cond ((null (cdr body))
         (list 'tail-call (car body) env))
        (t
         (m-eval (car body) env)
         (eval-body (cdr body) env))))
</pre>

<p> m-if の場合、then 節でも else 節でも末尾呼び出しになるので、評価する S 式と環境をリストに格納して返します。eval-body は最後尾の S 式以外は m-eval で評価します。最後尾の S 式と環境はリストに格納して返します。
</p>

<h4>●m-eval の修正</h4>
<p> m-eval の修正は次のようになります。
</p>

<pre class="list">
リスト : S 式の評価

(defun m-eval (expr env)
  (loop
    (cond ((self-evaluationp expr) (return expr))
          ((symbolp expr)
           (let ((cell (lookup expr env)))
             (if cell
                 (return (cdr cell))
               (error "unbound variable: ~S" expr))))
          ((consp expr)
           (let* ((procedure (m-eval (car expr) env))
                  (value
                   (case (car procedure)
                     ((syntax) (funcall (cadr procedure) expr env))
                     ((macro)
                      (m-eval (macro-expand (cdr procedure) (cdr expr)) env))
                     (t
                      (m-apply procedure
                               (mapcar #'(lambda (x) (m-eval x env))
                                       (cdr expr)))))))
             (if (and (consp value)
                      (eq (car value) 'tail-call))
                 (setq expr (second value)
                       env  (third value))
               (return value))))
          (t
           (error "unknown expression type -- m-eval: ~S" expr)))))
</pre>
<p> m-eval の処理を loop で囲みます。値を返すときは return を使います。expr がリストの場合、それを評価した結果を変数 value にセットします。そして、value がリストで、その先頭要素が tail-call の場合、m-eval の引数 expr と env を value の第 2 要素と第 3 要素に書き換えます。そして、loop で処理の先頭に戻って expr を評価します。tail-call でない場合、return で value を返します。
</p>

<h4>●マクロ展開の修正</h4>
<p> 今まではマクロ展開を行うのに m-apply を呼び出していましたが、tail-call の処理が複雑になるので、マクロ展開を行う専用の関数 macro-expand を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : マクロ展開

(defun macro-expand (procedure actuals)
  (labels ((eval-body (body env)
             (cond ((null (cdr body))
                    (m-eval (car body) env))
                   (t
                    (m-eval (car body) env)
                    (eval-body (cdr body) env)))))
    (let ((expr (cadr procedure)))
      (eval-body (cddr expr)
                 (add-binding (cadr expr) actuals (caddr procedure))))))
</pre>
<p> labels で局所関数 eval-body を定義します。これは今までの eval-body と同じです。したがって、マクロ展開で末尾再帰の最適化は行われません。あとは、add-binding で変数束縛を行ってラムダ式の本体を評価するだけです。
</p>

<h4>●簡単な実行例</h4>
<p> それでは簡単な実行例を示します。なお、簡単にテストできるように、primitive に算術演算子 (+, -, *, /) と比較演算子 (=, &lt;, &gt;, &lt;=, &gt;=) を追加しました。簡単な例として 1 から x までの合計値を求めるプログラムを作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 1 から x までの合計値を求める

(define sum
  (lambda (x)
    (if (= x 0)
        0
      (+ x (sum (- x 1))))))

(define sum1
  (lambda (x a)
    (if (= x 0)
        a
      (sum1 (- x 1) (+ a x)))))
</pre>

<p> 関数 sum は末尾再帰になっていないので、大きな値を計算することはできません。関数 sum1 は末尾再帰になっているので、micro Scheme が末尾再帰を最適化すれば、大きな値でも計算することができます。実行結果は次のようになりました。
</p>

<pre>
&gt;&gt;&gt; (sum1 100000 0)
5000050000
&gt;&gt;&gt; (sum 100000)

*** - Lisp stack overflow. RESET
</pre>
<p> このように、末尾再帰していない sum ではスタックオーバーフローが発生します。なお、末尾再帰最適化が行われないと、次に示すように sum1 でもスタックオーバーフローが発生します。
</p>
<pre>
&gt;&gt;&gt; (sum1 100000 0)

*** - Lisp stack overflow. RESET
</pre>
<p> <a href="clispb13.html">Common Lisp で作る micro Scheme (2)</a> で作成したプログラムに算術演算子と比較演算子を追加して実行すると、このようにスタックオーバーフローとなります。
</p>

<p> もう一つ簡単な例を示しましょう。数列を生成する関数 iota  は n 個の数列を生成する関数です。
</p>
<pre class="item">
iota n [start step]
</pre>
<p> start から始まり step ずつ増加する数列を生成します。start と step が省略された場合は 0 から始まり 1 ずつ増加する数列になります。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 数列の生成

(define iota
  (lambda (n . args)
    (let ((start (if (pair? args) (car args) 0))
          (step  (if (and (pair? args) (pair? (cdr args))) (cadr args) 1)))
      (let loop ((m n) (last (+ start (* step (- n 1)))) (a '()))
        (if (= m 0)
            a
          (loop (- m 1) (- last step) (cons last a)))))))
</pre>
<p> 最初に引数 args から start と step の値を取得します。次に、最後尾の値 last を求めます。そして、named let で n 個の要素を生成してリスト a に格納します。このとき、後ろの要素から順番に生成していくことに注意してください。
</p>
<p> iota は末尾再帰になっています。micro Scheme が末尾再帰を最適化すれば、引数 n に大きな値を与えてもリストを生成することができます。ところが、<a href="clispb13.html">Common Lisp で作る micro Scheme (2)</a> で作成した micro Scheme は CLISP で実行すると末尾再帰最適化が行われないので、次のようにスタックオーバーフローが発生します。
</p>
<pre>
&gt;&gt;&gt; (iota 10000)

*** - Lisp stack overflow. RESET
</pre>
<p> 今回修正した micro Scheme は CLISP でも正常に動作します。もちろん、次の関数を実行すると CLISP でも無限ループになります。
</p>

<pre>
&gt;&gt;&gt; (define foo (lambda () (foo)))
foo

&gt;&gt;&gt; (foo)
=&gt; 無限ループになる
</pre>
<h4>●たらいまわし関数</h4>
<p> 次は「たらいまわし関数」で実行速度を計測してみましょう。Common Lisp にはマクロ time が用意されていて、関数を評価したときのさまざまな情報を表示することができます。このマクロを使うため、次の関数を micro Scheme に追加します。
</p>

<pre class="list">
リスト : 実行時間の計測

(defun m-time (expr env)
  (time (m-eval (cadr expr) env)))
</pre>
<p> あとは *global-environment* に (list 'time 'syntax #'m-time) を追加するだけです。これで関数の実行時間を計測することができます。
</p>

<p> それでは、実際に試してみましょう。プログラムリストと実行結果を示します。
</p>
<pre class="list">
リスト : たらいまわし関数

(define tarai
  (lambda (x y z)
    (if (&lt;= x y)
        y
      (tarai (tarai (- x 1) y z) (tarai (- y 1) z x) (tarai (- z 1) x y)))))

(define tak
  (lambda (x y z)
    (if (&gt;= x y)
        z
      (tak (tak (- x 1) y z) (tak (- y 1) z x) (tak (- z 1) x y)))))
</pre>
<pre>
  表 : たらいまわし関数の実行結果

      最適化     :  無  :  有
  ---------------+------+------
  (tarai 10 5 0) : 6.38 : 7.33
  (tak   14 7 0) : 7.33 : 8.50

  単位 : 秒

  CLISP ver 2.44, Windows XP, celeron 1.40 GHz


      最適化     :  無  :  有
  ---------------+------+------
  (tarai 10 5 0) : 1.36 : 1.47
  (tak   14 7 0) : 1.54 : 1.65

  単位 : 秒

  SBCL ver 1.0.29, Windows XP, celeron 1.40 GHz
</pre>
<p> 実行速度は末尾再帰を最適化した今回のプログラムの方が遅くなりました。CLISP と SBCL ともに、今回のプログラムではコンスセルの消費量が多くなりました。その分だけ実行速度も遅くなるようです。今回のような単純な方法では、実行速度まで改善するのは難しいようです。
</p>

<h4>●遅延評価</h4>
<p> 関数 tarai は「遅延評価 (delayed evaluation または lazy evaluation) 」を行う処理系、たとえば関数型言語の Haskell では高速に実行することができます。また、Scheme でも delay と force を使って遅延評価を行うことができます。
</p>

<p> tarai のプログラムを見てください。x &lt;= y のときに y を返しますが、このとき引数 z の値は必要ありませんね。引数 z の値は x &gt; y のときに計算するようにすれば、無駄な計算を省略することができます。なお、関数 tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意ください。
</p>

<p> Scheme の delay と force は、micro Scheme でもマクロを使って簡単に実装することができます。次のリストを見てください。
</p>

<pre class="list">
リスト : delay と force

(define-macro delay 
  (lambda (expr)
    `(make-promise (lambda () ,expr))))

(define make-promise
  (lambda (f)
    (let ((flag false) (result false))
      (lambda ()
        (if (not flag)
            (let ((x (f)))
              (if (not flag)
                  (begin (set! flag true)
                         (set! result x)))))
        result))))

(define force 
  (lambda (promise) (promise)))
</pre>

<p> リストの delay と force は <a href="clispb15.html#cite">参考文献 [3]</a> に掲載されているプログラムを micro Scheme で書き直したものです。delay の引数 expr をクロージャに格納して関数 make-promis に渡します。make-promise はクロージャを生成して返します。このデータを Scheme では「プロミス」といいます。force は簡単で、引数 promise を評価するだけです。
</p>
<p> make-promise はクロージャを生成し、その中にクロージャ f の評価結果を格納します。flag が false の場合は f を評価していないので、f を評価して返り値を result にセットし、flag の値を true に書き換えます。flag が true ならば f は評価済みなので result を返します。
</p>

<p> 簡単な使用例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; (define a (delay (+ 10 20)))
A
&gt;&gt;&gt; (force a)
30
</pre>
<p> (delay (+ 10 20)) の返り値を変数 a にセットします。このとき、S 式 (+ 10 20) は評価されていません。遅延オブジェクトの値を実際に求める関数が force です。(force a) を評価すると、S 式 (+ 10 20) を評価して値 30 を返します。
</p>
<p> また、遅延オブジェクトは式の評価結果をキャッシュします。したがって、(force a) を再度実行すると、同じ式を再評価することなく値を求めることができます。次の例を見てください。
</p>
<pre>
&gt;&gt;&gt; (define b (delay (begin (display "oops! ") (+ 10 20))))
B
&gt;&gt;&gt; (force b)
oops! 30
&gt;&gt;&gt; (force b)
30
</pre>
<p> 最初に (force b) を実行すると、S 式 (begin (display "oops! ") (+ 10 20)) が評価されるので、画面に oops! が表示されます。次に、(force b) を実行すると、式を評価せずにキャッシュした値を返すので oops! は表示されません。
</p>

<p> delay と force を使うと、tarai は次のようになります。
</p>

<pre class="list">
リスト : delay と force による遅延評価

(define tarai
  (lambda (x y z)
    (if (&lt;= x y)
        y
      (let ((zz (force z)))
        (tarai (tarai (- x 1) y (delay zz))
               (tarai (- y 1) zz (delay x))
               (delay (tarai (- zz 1) x (delay y))))))))
</pre>

<p> 関数 tarai の引数 z にデータを渡すとき、delay で遅延オブジェクトを生成します。そして、その値を取り出すときは (force z) とします。これで遅延評価を行うことができます。
</p>

<p> それでは、実際に実行してみましょう。
</p>
<pre class="item">
(tarai 80 40 (delay 0))
CLISP : 2.52 [s]
SBCL  : 0.77 [s]
</pre>
<p> tarai に大きな値を与えても、高速に実行することができます。遅延評価の効果は十分に出ていると思います。
</p>

<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li>黒川利明, 『LISP 入門』, 培風館, 1982
  <li>Patrick Henry Winston, Berthold Klaus Paul Horn, 『LISP 原書第 3 版 (1)』, 培風館, 1992
  <li>R. Kent Dybvig (著), 村上雅章 (訳), 『プログラミング言語 SCHEME』, 株式会社ピアソン・エデュケーション, 2000
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995
  <li>Harold Abelson, Gerald Jay Sussman, Julie Sussman, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs"</a>, <br><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1">4.1  The Metacircular Evaluator</a>
  <li><a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/index-j.html">稲葉雅幸</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/index-j.html">ソフトウェア特論</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/soft4-scheme-interp/index.html">Scheme インタプリタ</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
;
; micro.l : micro Scheme with Common Lisp
;
;           (1) 基本機能の実装
;           (2) 伝統的なマクロの追加
;           (3) CLISP でも末尾再帰最適化が行われるように修正
;
;           Copyright (C) 2009 Makoto Hiroi
;

; 大域変数
(defvar *global-environment*)

; 変数束縛
(defun add-binding (vars vals env)
  (cond ((null vars) env)
        ((symbolp vars)
         (cons (cons vars vals) env))
        (t
         (cons (cons (car vars) (car vals))
               (add-binding (cdr vars) (cdr vals) env)))))

; 変数の値を取得
(defun lookup (var env)
  (let ((value (assoc var env)))
    (if value
        value
      (assoc var *global-environment*))))

;;; syntax

; (quote x)
(defun m-quote (expr env)
  (declare (ignore env))
  (cadr expr))

(defun true-p (x) (not (eq x 'false)))

; (if test then eles)
(defun m-if (expr env)
  (if (true-p (m-eval (cadr expr) env))
      (list 'tail-call (caddr expr) env)
    (if (null (cdddr expr))
        '*undef*
      (list 'tail-call (cadddr expr) env))))

; (lambda (args ...) body ...)
(defun m-lambda (expr env)
  (list 'closure expr env))

; (define name s-expr)
(defun m-define (expr env)
  (setf *global-environment*
        (cons (cons (cadr expr)
                    (m-eval (caddr expr) env))
              *global-environment*))
  (cadr expr))

; (set! name value)
(defun m-set! (expr env)
  (let ((cell (lookup (cadr expr) env)))
    (setf (cdr cell) (m-eval (caddr expr) env))
    (cdr cell)))

; (time expr)
(defun m-time (expr env)
  (time (m-eval (cadr expr) env)))


;;; マクロ

; (define-macro name s-expr)
(defun m-define-macro (exp env)
  ; とりあえず大域変数のみ
  (setq *global-environment*
        (cons (cons (cadr exp)
                    (cons 'macro (m-eval (caddr exp) env)))
              *global-environment*))
  ; symbol を返す
  (cadr exp))

; backquote
(defun m-backquote (expr env)
  (labels ((transfer (ls)
    (cond ((consp ls)
           (cond ((consp (car ls))
                  (cond ((eq (caar ls) 'unquote)
                         (cons (m-eval (cadar ls) env)
                               (transfer (cdr ls))))
                        ((eq (caar ls) 'splice)
                         (append (m-eval (cadar ls) env)
                                 (transfer (cdr ls))))
                        (t (cons (transfer (car ls))
                                 (transfer (cdr ls))))))
                 (t (cons (car ls) (transfer (cdr ls))))))
          (t ls))))
    (transfer (cadr expr))))

;;; 関数適用

; 関数値 : (tag ...)
; tag
; syntax    : シンタックス形式 (syntax m-xxx)
; primitive : プリミティブ     (primitive #&lt;subr ...&gt;)
; closure   : クロージャ       (closure (lambda (args ...) body ...) env)

; apply
(defun m-apply (procedure actuals)
  (case (car procedure)
    ((primitive)
     (apply (cadr procedure) actuals))
    ((closure)
     (let ((expr (cadr procedure)))
       (eval-body (cddr expr)
                  (add-binding (cadr expr) actuals (caddr procedure)))))
    (t
     (error "unknown procedure type -- m-apply: ~S" procedure))))

; マクロ展開
(defun macro-expand (procedure actuals)
  (labels ((eval-body (body env)
             (cond ((null (cdr body))
                    (m-eval (car body) env))
                   (t
                    (m-eval (car body) env)
                    (eval-body (cdr body) env)))))
    (let ((expr (cadr procedure)))
      (eval-body (cddr expr)
                 (add-binding (cadr expr) actuals (caddr procedure))))))

;;; S 式の評価

; body の評価
(defun eval-body (body env)
  (cond ((null (cdr body))
         (list 'tail-call (car body) env))
        (t
         (m-eval (car body) env)
         (eval-body (cdr body) env))))

; 自己評価フォームか
(defun self-evaluationp (expr)
  (and (not (consp expr)) (not (symbolp expr))))

; eval
(defun m-eval (expr env)
  (loop
    (cond ((self-evaluationp expr) (return expr))
          ((symbolp expr)
           (let ((cell (lookup expr env)))
             (if cell
                 (return (cdr cell))
               (error "unbound variable: ~S" expr))))
          ((consp expr)
           (let* ((procedure (m-eval (car expr) env))
                  (value
                   (case (car procedure)
                     ((syntax) (funcall (cadr procedure) expr env))
                     ((macro)
                      (m-eval (macro-expand (cdr procedure) (cdr expr)) env))
                     (t
                      (m-apply procedure
                               (mapcar #'(lambda (x) (m-eval x env))
                                       (cdr expr)))))))
             (if (and (consp value)
                      (eq (car value) 'tail-call))
                 (setq expr (second value)
                       env  (third value))
               (return value))))
          (t
           (error "unknown expression type -- m-eval: ~S" expr)))))

; 初期化
(setf *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'eqv?  'primitive #'(lambda (x y) (if (eql x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'display 'primitive (lambda (x) (princ x) '*undef*))
       (list 'newline 'primitive (lambda () (terpri) '*undef*))
       (list '+     'primitive #'+)
       (list '-     'primitive #'-)
       (list '*     'primitive #'*)
       (list '/     'primitive #'/)
       (list '=     'primitive #'(lambda (&amp;rest x) (if (apply #'= x) 'true 'false)))
       (list '&lt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&lt; x) 'true 'false)))
       (list '&gt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&gt; x) 'true 'false)))
       (list '&lt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&lt;= x) 'true 'false)))
       (list '&gt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&gt;= x) 'true 'false)))
       (list 'if     'syntax #'m-if)
       (list 'quote  'syntax #'m-quote)
       (list 'lambda 'syntax #'m-lambda)
       (list 'define 'syntax #'m-define)
       (list 'set!   'syntax #'m-set!)
       (list 'time   'syntax #'m-time)
       (list 'define-macro 'syntax #'m-define-macro)
       (list 'backquote   'syntax #'m-backquote)
       ))

;;; read-eval-print-loop

(defun change-readtable ()
  (set-macro-character
   #\`
   #'(lambda (stream char)
       (declare (ignore char))
       (list 'backquote (read stream t nil t))))
  (set-macro-character
   #\,
   #'(lambda (stream char)
       (declare (ignore char))
       (cond ((char= (peek-char nil stream) #\@)
              (read-char stream)
              (list 'splice (read stream t nil t)))
             (t (list 'unquote (read stream t nil t)))))))

(defun repl (&amp;rest file-list)
  (unwind-protect
      (progn
        (change-readtable)
        (dolist (file file-list)
          (with-open-file (in file :direction :input)
            (do ((output t))
                ((eq output nil) (terpri))
              (setf output (m-eval (read in nil) '()))
              (print output))))
        (do ((output nil))
            ((eq output 'quit))
          (princ "&gt;&gt;&gt; ")
          (force-output)
          (setf output (m-eval (read) '()))
          (princ output)
          (terpri)))
    (setq *readtable* (copy-readtable nil))))
</pre>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="clispb14.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb16.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>