<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門 : 番外編</title>
  <meta name="description" content="Common Lisp, Common Lisp 入門, 番外編">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881768</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>Common Lisp 入門：番外編</h2>
<div class="small">
[ <a href="clispb11a.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb13.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Common Lisp で作る micro Scheme</h3>
<p> 今回は Common Lisp で小さな Scheme インタプリタ "micro Scheme" を作ってみましょう。なお、このドキュメントは拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> <a href="../func/abcscm30.html">Scheme で作る micro Scheme</a> のプログラムを Common Lisp で書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>

<h4>●Scheme の特徴</h4>
<p> 最初に Scheme について簡単に説明します。Scheme は 1975 年に Gerald J.Sussman と Guy L. Steele Jr. によって作成された Lisp の方言です。伝統的な Lisp はダイナミックスコープですが、Scheme はレキシカルスコープを採用しています。その後、Common Lisp でもレキシカルスコープが採用されました。Scheme は Common Lisp に比べ、言語仕様がコンパクトにまとまっています。
</p>
<p> 関数型言語の場合、関数は他のデータと同等に扱うことができます。つまり、関数を変数に代入したり、関数を引数として渡すことができます。また、関数を値として返すこともできます。ところが、Common Lisp の関数はちょっと変わっています。次の例を見てください。
</p>
<pre>
&gt; (setq func #'(lambda (x y) (+ x y)))
#&lt;FUNCTION :LAMBDA (X Y) (+ X Y)&gt;
&gt; (funcall func 1 2)
3
</pre>
<p> 上の例は CLISP で実行した場合です。ラムダ式は無名の関数を返します。それを変数 func に格納して呼び出すことができます。Common Lisp の場合、変数に格納された関数は (func 1 2) のように呼び出すことはできません。funcall や apply を使って呼び出します。これに対し、Scheme は (func 1 2) と呼び出すことができます。次の例を見てください。
</p>
<pre>
&gt; (define func (lambda (x y) (+ x y)))
func
&gt; (func 1 2)
3
</pre>
<p> このように、Common Lisp よりも簡単に関数を取り扱うことができます。また、「継続 (continuation) 」を取り扱うことができるのも Scheme の特徴です。継続はプログラムの実行状態を保存しておいて、あとから実行を再開することができます。これは Common Lisp にはない強力な機能です。
</p>
<p> Scheme に興味のある方は、拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> を読んでみてください。
</p>
<h4>●最小の Lisp 処理系</h4>
<p> Lisp で小さな Lisp 処理系を作ることは簡単です。では、Lisp に必要な最低限の機能には何があるでしょうか。<a href="clispb12.html#cite">参考文献 [1]</a> によると、次に示す機能だけを含む Lisp を「純 LISP (pure LISP) 」と呼ぶそうです。196 頁より引用します。
</p>
<blockquote>
<p> 純 LISP の機能としては, 次のようなものだけが含まれます。
</p>
<ol>
  <li>CAR, CDR, CONS という基本的リスト処理機能。
  <li>ATOM, NULL, EQUAL という基本的述語。
  <li>プログラムの実行は, 再帰呼び出しを含めた関数呼び出しだけで, PROG などの順次処理を含まない。
  <li>変数値はラムダ式による束縛によってのみ与えられる。SETQ は存在しない。<BR>
このほかに, さらに次のような制限を設ける人もいます。
  <li>数値を含まない。自然数は (A A ... A) というように n 個の要素を持つリストで表す。
  <li>関数定義関数の存在を許さない。関数に相当するものはラムダ式で与える。
</ol>
</blockquote>
<p> このほかにも、<a href="http://ja.wikipedia.org/wiki/%E7%B4%94LISP">純LISP - Wikipedia</a> には <cite>『純LISPには二種のデータ(リスト、アトム)、及びそれらを操作する五つの基本関数だけが存在する』</cite> と書かれています。基本関数は car, cdr, cons, eq, atom の 5 つです。
</p>
<p> 5 つの基本関数とラムダ式だけでプログラムを作るのは大変です。そこで、条件分岐 cond と関数定義 defun を追加することにします。<a href="http://ja.wikipedia.org/wiki/LISP">LISP - Wikipedia</a> によると、これを<cite>『最小の Lisp』</cite> というそうです。
</p>
<p> 今回は最小の Lisp にならって、次に示す関数を持つ小さな Scheme 処理系を作ることにします。
</p>
<ul>
  <li>car
  <li>cdr
  <li>cons
  <li>quote
  <li>eq?
  <li>pair?
  <li>if
  <li>define
</ul>

<p> Scheme の関数 car, cdr, cons, quote, if は Common Lisp とほぼ同じです。Scheme の場合、car と cdr で空リストを評価するとエラーになります。eq? は eq のことで、pair? は consp と同じす。define は変数束縛を行う特殊形式 (シンタックス形式) です。Scheme のラムダ式は「レキシカルクロージャ」になります。Common Lisp のように #' (function 特殊形式) を付ける必要はありません。define で変数にラムダ式をセットすれば、それで関数を定義することができます。
</p>

<p> データは Common Lisp のデータをそのまま使います。このようにすると、プログラムの読み込みは関数 read で、データの出力も print や princ で行うことができます。Scheme には真偽値 (boolean) を表すデータ型 #t と #f がありますが、今回の micro Scheme ではシンボル true と false で真偽値を表すことにします。具体的には、偽を false で表して、それ以外のデータを真と判断します。Common Lisp のように、nil で真偽を判断することはできません。ご注意くださいませ。
</p>

<p> あとは読み込んだ S 式を評価する処理を作ればいいわけです。ただし、末尾再帰最適化など実装が難しい機能は省略します。また、エラーチェックも可能な限り省くことにします。厳密な意味で Scheme とはいえませんが、その分だけ簡単にプログラムを作ることができます。
</p>

<h4>●S 式の評価</h4>
<p> micro Scheme インタプリタの主役は関数 m-eval と m-apply です。この 2 つの関数は Lisp / Scheme の関数 eval と apply に相当します。m- は micro- を省略したものです。m-eval は評価する S 式と環境 (environment) を受け取り、渡された環境の下で S 式を評価します。環境はアクセス可能な局所変数の集合のことで、今回は連想リストで表すことにします。
</p>
<p> m-eval の仕事は簡単です。S 式が自己評価フォームであれば、それをそのまま返します。シンボル (変数) であれば環境からその値を求めて返します。リストの場合はちょっと複雑です。先頭の要素を評価して、それが関数値であればそれを呼び出します。今回は関数値をリストで表すことにします。関数値の種類を下記に示します。
</p>
<pre class="item">
関数値 : (tag ... )
tag の種類
syntax    : シンタックス形式 (if, quote, define, lambda)
primitive : Scheme の関数を呼び出す (car, cdr, cons, eq?, pair?) 
closure   : クロージャ (ラムダ式)
macro     : マクロ (予約)
</pre>
<p> syntax はシンタックス形式を表します。tag の後ろにその処理を担当する関数を格納しておきます。m-eval は引数を評価しないで、処理を担当する関数にそのまま渡します。このとき、環境も必要になるのでいっしょに渡します。
</p>
<p> primitive は Scheme の関数を呼び出します。tag の後ろに呼び出す関数値をセットします。closure はクロージャを表します。tag の後ろにはラムダ式とクロージャを生成したときの環境をセットします。primitive と clousre の評価は m-apply で行います。m-eval は引数を評価して m-apply に渡します。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : S 式の評価

; 自己評価フォームか
(defun self-evaluationp (expr)
  (and (not (consp expr)) (not (symbolp expr))))

; eval
(defun m-eval (expr env)
  (cond ((self-evaluationp expr) expr)
        ((symbolp expr)
         (let ((cell (lookup expr env)))
           (if cell
               (cdr cell)
             (error "unbound variable: ~S" expr))))
        ((consp expr)
         (let ((procedure (m-eval (car expr) env)))
           (case (car procedure)
             ((syntax) (funcall (cadr procedure) expr env))
             (t
              (m-apply procedure
                       (mapcar #'(lambda (x) (m-eval x env)) (cdr expr)))))))
        (t
         (error "unknown expression type -- m-eval: ~S" expr))))
</pre>
<p> m-eval の引数 expr が評価する S 式、env が環境です。self-evaluationp は自己評価フォームかチェックします。今回はリストとシンボル以外は自己評価フォームとしましたが、micro Scheme が扱うデータ型だけを自己評価フォームとしてもかまいません。
</p>
<p> expr がシンボルの場合は環境 env から変数を探します。この処理を関数 lookup で行います。変数が見つからない場合は大域変数から探します。大域変数は *global-environment* に格納します。大域変数も連想リストで管理します。lookup はコンスセル (変数 . 値) を返すので、cdr で値を取り出して返します。見つからない場合はエラー unbound variable を送出します。
</p>
<p> expr がリストの場合は、その先頭要素を m-eval で評価して procedure にセットします。procedure がリストでその先頭要素が syntax の場合は、procedure の第 2 要素を呼び出します。このとき、引数として expr と env をそのまま渡します。そうでなければ、procedure を m-apply に渡して評価します。このとき、procedure に渡す引数 (cdr expr) を m-eval で評価し、その結果をリストに格納して渡します。この処理は mapcar を使うと簡単です。
</p>

<h4>●関数適用</h4>
<p> 次は m-apply を作りましょう。
</p>

<pre class="list">
リスト : 関数適用

(defun m-apply (procedure actuals)
  (case (car procedure)
    ((primitive)
     (apply (cadr procedure) actuals))
    ((closure)
     (let ((expr (cadr procedure)))
       (eval-body (cddr expr)
                  (add-binding (cadr expr) actuals (caddr procedure)))))
    (t
     (error "unknown procedure type -- m-apply: ~S" procedure))))

; body の評価
(defun eval-body (body env)
  (cond ((null (cdr body))
         (m-eval (car body) env))
        (t
         (m-eval (car body) env)
         (eval-body (cdr body) env))))
</pre>
<p> m-apply の引数 procedure は micro Scheme の関数値、actuals は引数を格納したリストです。引数は評価済みであることに注意してください。procedure が primitive の場合、2 番目の要素に関数が格納されています。apply でその関数を呼び出します。
</p>
<p> procedure が closure の場合、2 番目の要素にラムダ式、3 番目の要素に環境が格納されています。まず最初にラムダ式を取り出して、変数 expr にセットします。expr の 2 番目の要素が仮引数です。関数 add-binding は変数束縛を行います。そして、それを環境に追加して返します。このとき、ラムダ式を生成したときの環境が使われることに注意してください。
</p>
<p> Scheme のラムダ式はクロージャになるので、ラムダ式を定義したときの環境が必ず保存されています。ラムダ式の本体はこの新しい環境で評価されます。この処理を関数 eval-body で行います。引数 body は S 式を格納したリスト、env が環境です。eva-body は複数の S 式を順番に m-eval で評価して、最後に評価した S 式の結果を返します。
</p>

<h4>●変数束縛と値の取得</h4>
<p> 次は変数束縛を行う関数 add-binding を作ります。
</p>

<pre class="list">
リスト : 変数束縛

(defun add-binding (vars vals env)
  (cond ((null vars) env)
        ((symbolp vars)
         (cons (cons vars vals) env))
        (t
         (cons (cons (car vars) (car vals))
               (add-binding (cdr vars) (cdr vals) env)))))
</pre>

<p> add-binding は仮引数のシンボルと実引数の値を組にして環境 env に追加します。仮引数のリスト vars が空リストの場合は env を返します。vars がシンボルの場合は可変個引数なので、vars と vals を組にして env に追加します。それ以外の場合は vars の先頭要素と vals の先頭要素を組にします。なお、引数の個数についてエラーチェックは行っていません。興味のある方はプログラムを改造してみてください。
</p>

<p> 変数値の取得は関数 lookup で行います。次のリストを見てください。
</p>
<pre class="list">
リスト : 変数値の取得

; 大域変数
(defvar *global-environment*)

; 変数の値を取得
(defun lookup (var env)
  (let ((value (assoc var env)))
    (if value
        value
      (assoc var *global-environment*))))
</pre>
<p> 環境 env は連想リストなので、assoc で env から var を探索するだけです。見つからない場合は大域変数 *gloal-environment* から探します。
</p>

<h4>●シンタックス形式の処理</h4>
<p> 次はシンタックス形式を処理する関数を作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : シンタックス形式の処理

; (quote x)
(defun m-quote (expr env)
  (declare (ignore env))
  (cadr expr))

(defun true-p (x) (not (eq x 'false)))

; (if test then eles)
(defun m-if (expr env)
  (if (true-p (m-eval (cadr expr) env))
      (m-eval (caddr expr) env)
    (if (null (cdddr expr))
        '*undef*
      (m-eval (cadddr expr) env))))

; (lambda (args ...) body ...)
(defun m-lambda (expr env)
  (list 'closure expr env))

; (define name s-expr)
(defun m-define (expr env)
  (setf *global-environment*
        (cons (cons (cadr expr)
                    (m-eval (caddr expr) env))
              *global-environment*))
  (cadr expr))
</pre>
<p> quote の処理は m-quote で行います。引数 expr には (quote x) が渡されるので、expr の第 2 要素を返します。if の処理は m-if で行います。expr の第 2 要素を m-eval で評価し、それが false でなければ expr の第 3 要素を m-eval で評価して、その結果を返します。偽の場合は expr に第 4 要素があるかチェックし、あればそれを m-eval で評価します。そうでなければシンボル *undef* を返します。*undef* は未定義を表すシンボルとして使います。
</p>
<p> lambda の処理は m-lambda で行います。これはクロージャを生成する処理です。m-lambda はシンタックス形式なので引数 env に環境が渡されます。これとラムダ式 expr をリストに格納し、それにタグ closure を付けて返します。define の処理は m-define で行います。define は変数と値を組にして大域変数 *global-environment* に追加します。このとき、値 (caddr expr) を m-eval で評価します。これでラムダ式を使って関数を定義することができます。
</p>

<h4>●read-eval-print-loop</h4>
<p> 最後に read - eval - print - loop (REPL) を作ります。
</p>

<pre class="list">
リスト : read - eval - print - loop

; 初期化
(setf *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'if     'syntax #'m-if)
       (list 'quote  'syntax #'m-quote)
       (list 'lambda 'syntax #'m-lambda)
       (list 'define 'syntax #'m-define)
       ))

;;; read-eval-print-loop
(defun repl (&amp;rest file-list)
  (dolist (file file-list)
    (with-open-file (in file :direction :input)
      (do ((output t))
          ((eq output nil) (terpri))
        (setf output (m-eval (read in nil) '()))
        (print output))))
  ;
  (do ((output nil))
      ((eq output 'quit))
    (princ "&gt;&gt;&gt; ")
    (force-output)
    (setf output (m-eval (read) '()))
    (princ output)
    (terpri)))
</pre>
<p> 最初に大域変数 *global-environment* を初期化します。true, false, nil, quit は自分自身に初期化します。car と cdr は引数 x が空リストかチェックしています。また、eq? と pair? は eq と consp を呼び出すだけではなく、true と false を返すようにします。
</p>
<p> REPL を実行する前に、プログラムをロードできると便利です。関数 repl の引数 file-list でファイル名を指定して、そのファイルを読み込みます。read で S 式を読み込み、それを m-eval で評価します。このとき、環境は空リストを渡します。それから、REPL を実行します。quit が入力されたら REPL を終了します。
</p>

<h4>●簡単な実行例</h4>
<p> それでは実行してみましょう。
</p>
<pre>
&gt;&gt;&gt; (quote a)
A
&gt;&gt;&gt; 'a
A
&gt;&gt;&gt; (if true 'a 'b)
A
&gt;&gt;&gt; (if false 'a 'b)
B
&gt;&gt;&gt; (car '(a b c))
A
&gt;&gt;&gt; (cdr '(a b c))
(B C)
&gt;&gt;&gt; (cons 'a 'b)
(A . B)
&gt;&gt;&gt; (eq? 'a 'a)
TRUE
&gt;&gt;&gt; (eq? 'a 'b)
FALSE
&gt;&gt;&gt; (pair? '(a b c))
TRUE
&gt;&gt;&gt; (pair? 'a)
FALSE
</pre>
<p> quote, if, car, cdr, cons, eq?, pair? は正常に動作していますね。次は lambda と define を試してみます。
</p>

<pre>
&gt;&gt;&gt; (define a 'b)
A
&gt;&gt;&gt; a
B
&gt;&gt;&gt; (lambda (x) x)
(CLOSURE (LAMBDA (X) X) NIL)
&gt;&gt;&gt; ((lambda (x) x) 'a)
A
&gt;&gt;&gt; (define list (lambda x x))
LIST
&gt;&gt;&gt; (list 'a 'b 'c 'd 'e)
(A B C D E)
</pre>
<p> define で変数 a を定義して、その値を求めることができます。lambda はクロージャを生成し、ラムダ式で関数呼び出しも可能です。そして、define と lambda を使って関数を定義することができます。
</p>
<h4>●レキシカルスコープとクロージャの動作</h4>
<p> 次は、レキシカルスコープとクロージャが正常に動作するか試してみましょう。
</p>
<pre>
&gt;&gt;&gt; (define x 'a)
X
&gt;&gt;&gt; x
A
&gt;&gt;&gt; (define foo (lambda () x))
FOO
&gt;&gt;&gt; (foo)
A
&gt;&gt;&gt; (define bar (lambda (x) (foo)))
BAR
&gt;&gt;&gt; (bar 'b)
A
</pre>
<p> まず最初に大域変数 x を a に初期化します。次に、関数 foo を定義します。foo の引数はないので、x は大域変数を参照します。したがって、foo を評価すると返り値は a になります。次に、関数 bar から foo を呼び出します。bar は引数 x を受け取ります。(bar 'b) を評価すると a が返ってきます。確かにレキシカルスコープになっています。
</p>
<p> foo と bar の値を表示すると次のようになります。
</p>
<pre>
&gt;&gt;&gt; foo
(CLOSURE (LAMBDA NIL X) NIL)
&gt;&gt;&gt; bar
(CLOSURE (LAMBDA (X) (FOO)) NIL)
</pre>
<p> どちらの関数も環境が空リストになっています。(bar 'b) を評価するとき、この環境に (x . b) が追加されます。そして、(foo) を呼び出しますが、foo に引数はないので、環境は空リストのままです。したがって、(foo) の返り値は大域変数の値 a になるのです。
</p>
<p> 今度はクロージャの動作を確かめます。
</p>
<pre>
&gt;&gt;&gt; (define baz (lambda (x) (lambda (y) (cons x y))))
BAZ
&gt;&gt;&gt; (define baz-a (baz 'a))
BAZ-A
&gt;&gt;&gt; (baz-a 'b)
(A . B)
&gt;&gt;&gt; (baz-a 'c)
(A . C)
</pre>
<p> 関数 baz はクロージャを生成して返します。このとき、baz の引数 x の値が保存されます。(baz 'a) の返り値を baz-a にセットすると、baz-a は a と baz-a の引数を組にしたものを返す関数となります。したがって、(baz-a 'b) は (a . b) を、(baz-a 'c) は (a . c) を返します。クロージャも正常に動作していますね。
</p>
<p> baz と baz-a の値を表示すると、次のようになります。
</p>
<pre>
&gt;&gt;&gt; baz
(CLOSURE (LAMBDA (X) (LAMBDA (Y) (CONS X Y))) NIL)
&gt;&gt;&gt; baz-a
(CLOSURE (LAMBDA (Y) (CONS X Y)) ((X . A)))
</pre>
<p> baz の環境は空リストですが、baz-a の環境は ((x . a)) となります。(baz-a 'b) を評価するとき、クロージャの環境に (y . b) が追加され、その下で (cons x y) が評価されます。したがって、x の値は a で y の値が b になるのです。
</p>

<h4>●再帰定義とリスト操作</h4>
<p> define で定義する関数は再帰呼び出しが可能です。簡単なリスト操作関数を再帰定義で作ってみました。プログラムリストと実行結果を示します。
</p>

<pre class="list">
リスト : append と reverse

; 空リストか
(define null? (lambda (x) (eq? x '())))

; 否定
(define not (lambda (x) (if (eq? x false) true false)))

; リストの結合
(define append
  (lambda (xs ys)
    (if (null? xs)
        ys
      (cons (car xs) (append (cdr xs) ys)))))

; リストの反転
(define reverse
  (lambda (ls)
    (if (null? ls)
        '()
      (append (reverse (cdr ls)) (list (car ls))))))
</pre>
<pre>
&gt;&gt;&gt; (append '(a b c) '(d e f))
(A B C D E F)
&gt;&gt;&gt; (append '((a b) (c d)) '(e f g))
((A B) (C D) E F G)
&gt;&gt;&gt; (reverse '(a b c d e))
(E D C B A)
&gt;&gt;&gt; (reverse '((a b) c (d e)))
((D E) C (A B))
</pre>
<pre class="list">
リスト : 探索

; リストの探索
(define memq
  (lambda (x ls)
    (if (null? ls)
        #f
        (if (eq? x (car ls))
            ls
          (memq x (cdr ls))))))

; 連想リストの探索
(define assq
  (lambda (x ls)
    (if (null? ls)
        #f
      (if (eq? x (car (car ls)))
          (car ls)
        (assq x (cdr ls))))))
</pre>
<pre>
&gt;&gt;&gt; (memq 'a '(a b c d e))
(A B C D E)
&gt;&gt;&gt; (memq 'c '(a b c d e))
(C D E)
&gt;&gt;&gt; (memq 'f '(a b c d e))
FALSE
&gt;&gt;&gt; (assq 'a '((a 1) (b 2) (c 3) (d 4) (e 5)))
(A 1)
&gt;&gt;&gt; (assq 'e '((a 1) (b 2) (c 3) (d 4) (e 5)))
(E 5)
&gt;&gt;&gt; (assq 'f '((a 1) (b 2) (c 3) (d 4) (e 5)))
FALSE
</pre>
<pre class="list">
リスト : 高階関数

; マッピング
(define map
  (lambda (fn ls)
    (if (null? ls)
        '()
      (cons (fn (car ls)) (map fn (cdr ls))))))

; フィルター
(define filter
  (lambda (fn ls)
    (if (null? ls)
        '()
      (if (fn (car ls))
          (cons (car ls) (filter fn (cdr ls)))
        (filter fn (cdr ls))))))

; 畳み込み
(define fold-right
  (lambda (fn a ls)
    (if (null? ls)
        a
      (fn (car ls) (fold-right fn a (cdr ls))))))

(define fold-left
  (lambda (fn a ls)
    (if (null? ls)
        a
      (fold-left fn (fn a (car ls)) (cdr ls)))))
</pre>
<pre>
&gt;&gt;&gt; (map car '((a 1) (b 2) (c 3) (d 4) (e 5)))
(A B C D E)
&gt;&gt;&gt; (map cdr '((a 1) (b 2) (c 3) (d 4) (e 5)))
((1) (2) (3) (4) (5))
&gt;&gt;&gt; (map (lambda (x) (cons x x)) '(a b c d e))
((A . A) (B . B) (C . C) (D . D) (E . E))
&gt;&gt;&gt; (filter (lambda (x) (not (eq? x 'a))) '(a b c a b c a b c))
(B C B C B C)
&gt;&gt;&gt; (fold-left cons '() '(a b c d e))
(((((NIL . A) . B) . C) . D) . E)
&gt;&gt;&gt; (fold-right cons '() '(a b c d e))
(A B C D E)
</pre>
<h4>●ダイナミックスコープと funarg 問題</h4>
<p> ところで、スコープを「ダイナミックスコープ」に変更することも簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : apply (ダイナミックスコープ版)

(defun m-apply (procedure actuals)
  (case (car procedure)
    ((primitive)
     (apply (cadr procedure) actuals))
    ((closure)
     (let ((expr (cadr procedure)))
       (eval-body (cddr expr)
                  (add-binding (cadr expr)
                               actuals
                               env)))) ; (1)
                               ; (2) (append (caddr procedure) env)))))
    (t
     (error "unknown procedure type -- m-apply: ~S" procedure))))
</pre>
<p> m-apply を呼び出すとき環境 env を渡します。そして、add-binding で変数束縛するとき、(1) のように env を渡します。これで昔の Lisp と同じダイナミックスコープになります。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; (define x 0)
X
&gt;&gt;&gt; (define foo (lambda () x))
FOO
&gt;&gt;&gt; (foo)
0
&gt;&gt;&gt; (define bar (lambda (x) (foo)))
BAR
&gt;&gt;&gt; (bar 10)
10
</pre>
<p> このように、関数 foo から関数 bar の局所変数にアクセスすることができます。ただし、このままではクロージャが機能しません。また、ラムダ式を定義するときの環境とラムダ式を実行するときの環境が異なることで問題が発生する場合があります。このような問題を "funarg 問題" といいます。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : funarg 問題

; フィルター
(define filter
  (lambda (x y)
    (if (null? y)
        '()
      (if (x (car y))
          (cons (car y) (filter x (cdr y)))
        (filter x (cdr y))))))

; 削除
(define remove
  (lambda (y z)
    (filter (lambda (x) (not (eq? x y))) z)))
</pre>
<p> filter と remove を定義します。ここで変数 y に注目してください。remove で filter に渡すラムダ式で変数 y を参照しています。この y は remove の引数 y を参照するべきです。ダイナミックスコープでは、クロージャがなくても引数 y にアクセスすることは可能です。
</p>
<p> ところが、filter でも変数 y を使っていますね。この変数 y の値は remove の引数 z になり、引数 x の値が (lambda (x) (not (eq? x y))) になります。そして、x を評価するとき y の値を参照しますが、ダイナミックスコープでは filter の引数 y の値になります。つまり、remove の引数 y は隠蔽されてアクセスできなくなるのです。
</p>
<p> 実際に試してみると、remove は正常に動作しません。
</p>
<pre>
&gt;&gt;&gt; (remove 'a '(a b c a b c))
(A B C A B C)
&gt;&gt;&gt; (remove 'b '(a b c a b c))
(A B C A B C)
</pre>
<p> この問題はラムダ式を生成するとき、その時点での環境を保存することで解決することができます。つまり、クロージャがあればよいのです。実際、apply のリストで (1) から (2) のようにクロージャに保存しておいた環境を加えると、ダイナミックスコープでも remove は正常に動作します。
</p>
<p> Common Lisp 以前の Lisp では funarg 問題を解決するため、クロージャを生成するときはラムダ式の前に #' 付けることにしました。これが function 特殊形式です。そして、生成されたクロージャのことを「レキシカルクロージャ」といいます。この結果、ラムダ式は単なるリストで表されたものとレキシカルクロージャを生成するものとが混在するようになりました。
</p>
<p> これを統一したのが Scheme です。Scheme は関数 (ラムダ式) をクロージャとして扱い、レキシカルスコープを採用した最初の Lisp 処理系です。この後、レキシカルスコープは Common Lisp にも採用されました。Common Lisp は変数を defvar で宣言するとダイナミックスコープになりますが、レキシカルクロージャを使うかぎり funarg 問題は発生しません。当然ですが、Scheme に funarg 問題はありません。
</p>

<p> 今回はここまでです。次回は micro Scheme に伝統的なマクロを追加してみましょう。
</p>
<h4><a name="cite">●参考文献, URL</a></h4>
<ol>
  <li>黒川利明, 『LISP 入門』, 培風館, 1982
  <li>Patrick Henry Winston, Berthold Klaus Paul Horn, 『LISP 原書第 3 版 (1)』, 培風館, 1992<br>
18. Lisp で書く Lisp
  <li>R. Kent Dybvig (著), 村上雅章 (訳), 『プログラミング言語 SCHEME』, 株式会社ピアソン・エデュケーション, 2000<BR>
9.2 Scheme のメタ循環インタプリタ
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995<BR>
第 11 章 定義インタプリタ
  <li>小西弘一, 清水剛, 『ＣプログラムブックⅢ』, アスキー, 1986
  <li>Harold Abelson, Gerald Jay Sussman, Julie Sussman, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs"</a>, <BR><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1">4.1  The Metacircular Evaluator</a>
  <li><a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/index-j.html">稲葉雅幸</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/index-j.html">ソフトウェア特論</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/soft4-scheme-interp/index.html">Scheme インタプリタ</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; micro.l : micro Scheme with Common Lisp
;
;           (1) 基本機能の実装
;
;           Copyright (C) 2009 Makoto Hiroi
;

; 大域変数
(defvar *global-environment*)

; 変数束縛
(defun add-binding (vars vals env)
  (cond ((null vars) env)
        ((symbolp vars)
         (cons (cons vars vals) env))
        (t
         (cons (cons (car vars) (car vals))
               (add-binding (cdr vars) (cdr vals) env)))))

; 変数の値を取得
(defun lookup (var env)
  (let ((value (assoc var env)))
    (if value
        value
      (assoc var *global-environment*))))

;;; syntax

; (quote x)
(defun m-quote (expr env)
  (declare (ignore env))
  (cadr expr))

(defun true-p (x) (not (eq x 'false)))

; (if test then eles)
(defun m-if (expr env)
  (if (true-p (m-eval (cadr expr) env))
      (m-eval (caddr expr) env)
    (if (null (cdddr expr))
        '*undef*
      (m-eval (cadddr expr) env))))

; (lambda (args ...) body ...)
(defun m-lambda (expr env)
  (list 'closure expr env))

; (define name s-expr)
(defun m-define (expr env)
  (setf *global-environment*
        (cons (cons (cadr expr)
                    (m-eval (caddr expr) env))
              *global-environment*))
  (cadr expr))

;;; 関数適用

; 関数値 : (tag ...)
; tag
; syntax    : シンタックス形式 (syntax m-xxx)
; primitive : プリミティブ     (primitive #&lt;subr ...&gt;)
; closure   : クロージャ       (closure (lambda (args ...) body ...) env)

; apply
(defun m-apply (procedure actuals)
  (case (car procedure)
    ((primitive)
     (apply (cadr procedure) actuals))
    ((closure)
     (let ((expr (cadr procedure)))
       (eval-body (cddr expr)
                  (add-binding (cadr expr) actuals (caddr procedure)))))
    (t
     (error "unknown procedure type -- m-apply: ~S" procedure))))

;;; S 式の評価

; body の評価
(defun eval-body (body env)
  (cond ((null (cdr body))
         (m-eval (car body) env))
        (t
         (m-eval (car body) env)
         (eval-body (cdr body) env))))

; 自己評価フォームか
(defun self-evaluationp (expr)
  (and (not (consp expr)) (not (symbolp expr))))

; eval
(defun m-eval (expr env)
  (cond ((self-evaluationp expr) expr)
        ((symbolp expr)
         (let ((cell (lookup expr env)))
           (if cell
               (cdr cell)
             (error "unbound variable: ~S" expr))))
        ((consp expr)
         (let ((procedure (m-eval (car expr) env)))
           (case (car procedure)
             ((syntax) (funcall (cadr procedure) expr env))
             (t
              (m-apply procedure
                       (mapcar #'(lambda (x) (m-eval x env)) (cdr expr)))))))
        (t
         (error "unknown expression type -- m-eval: ~S" expr))))

; 初期化
(setf *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'if     'syntax #'m-if)
       (list 'quote  'syntax #'m-quote)
       (list 'lambda 'syntax #'m-lambda)
       (list 'define 'syntax #'m-define)
       ))

;;; read-eval-print-loop
(defun repl (&amp;rest file-list)
  (dolist (file file-list)
    (with-open-file (in file :direction :input)
      (do ((output t))
          ((eq output nil) (terpri))
        (setf output (m-eval (read in nil) '()))
        (print output))))
  ;
  (do ((output nil))
      ((eq output 'quit))
    (princ "&gt;&gt;&gt; ")
    (force-output)
    (setf output (m-eval (read) '()))
    (princ output)
    (terpri)))
</pre>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="clispb11a.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb13.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>