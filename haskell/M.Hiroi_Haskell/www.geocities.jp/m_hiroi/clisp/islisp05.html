<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 ISLisp プログラミング超入門</title>
  <meta name="description" content="Lisp,ISLisp,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881772</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>お気楽 ISLisp プログラミング超入門</h2>
</div>
<div class="small">
[ <A href="../index.html">Home</a> | <a href="index.html">Common Lisp</a> | <a href="islisp.html">ISLisp</a> ]
<hr>
</div>
<section class="contents">
<h3>ISLisp ドリル</h3>
<p> ISLisp 用の簡単な練習問題です。拙作のページ <a href="islisp01.html#chap00">簡単なプログラム</a> と重複する問題もありますが、あしからずご了承くださいませ。
</p>
<h4 id="chap01">●問題１</h4>
<p> 次に示す関数を定義してください。
</p>
<ol>
  <li>引数に 1 を加える 1+</li>
  <li>引数から 1 を引く 1-</li>
  <li>引数を二乗する square</li>
  <li>引数を三乗する cubic</li>
  <li>引数を 1/2 にする half</li>
  <li>二つの引数の平均値をとる medium</li>
  <li>二つの引数の二乗の平均値をとる square-medium</li>
</ol>
<p> 割り算は quotient を使います。結果は浮動小数点数になります。
</p>
<p><a href="islisp05.html#ans01">解答１</a>
</p>
<h4>●問題２</h4>
<p> 次に示す関数を定義してください。
</p>
<ol>
  <li>引数が 0 か判定する述語 zerop</li>
  <li>引数が正か判定する述語 plusp</li>
  <li>引数が負か判定する述語 minusp</li>
  <li>引数の符号 (-1, 0, 1) を返す sign</li>
  <li>引数が偶数か判定する述語 evenp</li>
  <li>引数が奇数か判定する述語 oddp</li>
  <li>引数 n が引数 low, high の範囲内にあるか判定する述語 between</li>
</ol>
<p> ISLisp の比較演算子は Common Lisp とは違って引数は 2 個だけです。
</p>
<p><a href="islisp05.html#ans02">解答２</a>
</p>
<h4>●問題３</h4>
<p> 階乗を計算する関数を再帰呼び出しを使って定義してください。
</p>
<pre class="fig">
0! = 1
n! = n * (n - 1)!

図 : 階乗の定義
</pre>
<p><a href="islisp05.html#ans03">解答３</a>
</p>
<h4>●問題４</h4>
<p> フィボナッチ数を計算する関数を再帰呼び出しを使って定義してください。
</p>
<pre class="fig">
          ┌ 1;                     n = 0
fibo(n) = ┤ 1;                     n = 1
          └ fibo(n-1) + fibo(n-2); n &gt; 1

0, 1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

        図 : フィボナッチ数の定義
</pre>
<p><a href="islisp05.html#ans04">解答４</a>
</p>
<h4>●問題５</h4>
<p> 累乗 x<sup>n</sup> を計算する関数を再帰呼び出しを使って定義してください。プログラムを簡単にするため、n は正の整数とします。
</p>
<p><a href="islisp05.html#ans05">解答５</a>
</p>
<h4>●問題６</h4>
<p> リストから要素を取り出す関数を定義してください。
</p>
<ol>
  <li>first (先頭要素)</li>
  <li>second (2 番目の要素)</li>
  <li>third (3 番目の要素)</li>
  <li>fourth (4 番目の要素)</li>
  <li>fifth (5 番目の要素)</li>
</ol>
<p><a href="islisp05.html#ans06">解答６</a>
</p>
<h4>●問題７</h4>
<p> リスト xs に cdr を n 回適用する関数 nthcdr n xs を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans07">解答７</a>
</p>
<h4>●問題８</h4>
<p> リストの n 番目の要素を取り出す関数 nth x xs を定義してください。
</p>
<p><a href="islisp05.html#ans08">解答８</a>
</p>
<h4>●問題９</h4>
<p> リストの長さを求める関数 my-length xs を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans09">解答９</a>
</p>
<h4>●問題10</h4>
<p> リスト xs, ys を連結する関数 my-append xs ys を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans10">解答10</a>
</p>
<hr>
<h4 id="ans01">●解答１</h4>
<pre class="list">
リスト : 問題１の解答例

(defun 1+ (n) (+ n 1))

(defun 1- (n) (- n 1))

(defun square (n) (* n n))

(defun cubic (n) (* n n n))

(defun half (n) (quotient n 2))

(defun medium (n m) (half (+ n m)))

(defun square-medium (n m)
  (medium (square n) (square m)))
</pre>
<pre>
&gt; (1+ 1)
2
&gt; (1+ 0.5)
1.5
&gt; (1- 1)
0
&gt; (1- 0.5)
-0.5
&gt; (square 2)
4
&gt; (square 1.111111)
1.234567654321
&gt; (cubic 2)
8
&gt; (cubic 1.1111111)
1.37174207133059
&gt; (half 2)
1
&gt; (half 1.5)
0.75
&gt; (medium 2 4)
3
&gt; (medium 2 3)
2.5
&gt; (square-medium 2 3)
6.5
&gt; (square-medium 1.5 2.5)
4.25
</pre>
<h4 id="ans02">●解答２</h4>
<pre class="list">
リスト : 問題２の解答例

(defun zerop (n) (= n 0))

(defun plusp (n) (&lt; 0 n))

(defun minusp (n) (&lt; n 0))

(defun sign (n)
  (if (zerop n)  ; cond を使ってもよい
      0
    (if (plusp n) 1 -1)))

(defun evenp (n) (zerop (mod n 2)))

(defun oddp (n) (not (evenp n)))

(defun between (n low high)
  (and (&lt;= low n) (&lt;= n high)))
</pre>
<pre>
&gt; (zerop 0)
T
&gt; (zerop 0.0)
T
&gt; (zerop 1)
NIL
&gt; (plusp 10)
T
&gt; (plusp 0)
NIL
&gt; (plusp -1)
NIL
&gt; (minusp -1)
T
&gt; (minusp 0)
NIL
&gt; (minusp 1)
NIL
&gt; (sign 100)
1
&gt; (sign 0)
0
&gt; (sign -100)
-1
&gt; (evenp 100)
T
&gt; (evenp 99)
NIL
&gt; (oddp 99)
T
&gt; (oddp 100)
NIL
&gt; (between 5 1 10)
T
&gt; (between 0 1 10)
NIL
&gt; (between 100 1 10)
NIL
</pre>
<h4 id="ans03">●解答３</h4>
<pre class="list">
リスト : 階乗

(defun fact (n)
  (if (zerop n)
      1
    (* n (fact (1- n)))))

;; 末尾再帰
(defun fact-tail (n acc)
  (if (zerop n)
      acc
    (fact-tail (1- n) (* acc n))))
</pre>
<pre>
&gt; (fact 10)
3628800
&gt; (fact 20)
2432902008176640000
&gt; (fact-tail 10 1)
3628800
&gt; (fact-tail 20 1)
2432902008176640000
</pre>
<p> fact-tail は局所関数を定義する labels を使って書き直すことができます。興味のある方は挑戦してみてください。
</p>
<h4 id="ans04">●解答４</h4>
<pre class="list">
リスト : フィボナッチ数

(defun fibo (n)
  (if (&lt; n 2)
      n
    (+ (fibo (1- n)) (fibo (- n 2)))))

;; 末尾再帰
(defun fibo-tail (n a b)
  (if (zerop n)
      a
    (fibo-tail (1- n) b (+ a b))))
</pre>
<pre>
&gt; (fibo 10)
55
&gt; (fibo 20)
6765
&gt; (fibo-tail 10 0 1)
55
&gt; (fibo-tail 20 0 1)
6765
&gt; (fibo-tail 40 0 1)
102334155
</pre>
<p> fibo-tail は局所関数を定義する labels を使って書き直すことができます。興味のある方は挑戦してみてください。
</p>
<h4 id="ans05">●解答５</h4>
<pre class="list">
リスト : 累乗

(defun power (x n)
  (if (zerop n)
      1
    (* x (power x (1- n)))))

;; 末尾再帰
(defun power-tail (x n acc)
  (if (zerop n)
      acc
    (power-tail x (1- n) (* acc x))))

;; 高速版
(defun power-fast (x n)
  (cond ((zerop n) 1)
        ((= n 1) x)
        (t (let ((z (power-fast x (div n 2))))
             (if (oddp n)
                 (* x z z)
               (* z z))))))
</pre>
<pre>
&gt; (power 2 32)
4294967296
&gt; (power-tail 2 32 1)
4294967296
&gt; (power-fast 2 32)
4294967296
&gt; (power-fast 2 64)
18446744073709551616
</pre>
<p> 高速版の説明は拙作のページ <a href="../func/scheme.html">Scheme Programming</a> <a href="../func/abcscm04.html">Scheme の基礎知識 (その４)</a> をお読みくださいませ。
</p>
<h4 id="ans06">●解答６</h4>
<pre class="list">
リスト : リストの要素を取り出す

(defun first  (xs) (car xs))
(defun second (xs) (car (cdr xs)))
(defun third  (xs) (car (cdr (cdr xs))))
(defun fourth (xs) (car (cdr (cdr (cdr xs)))))
(defun fifth  (xs) (car (cdr (cdr (cdr (cdr xs))))))
</pre>
<pre>
&gt; (first '(a b c d e))
A
&gt; (second '(a b c d e))
B
&gt; (third '(a b c d e))
C
&gt; (fourth '(a b c d e))
D
&gt; (fifth '(a b c d e))
E
</pre>
<p> ISLisp には cXXr, cXXXr, cXXXXr などの関数は用意されていません。
</p>

<h4 id="ans07">●解答７</h4>
<pre class="list">
リスト : リストに cdr を n 回適用する

(defun nthcdr (n xs)
  (if (zerop n)
      xs
    (nthcdr (1- n) (cdr xs))))
</pre>
<pre>
&gt; (nthcdr 0 '(a b c d e))
(A B C D E)
&gt; (nthcdr 3 '(a b c d e))
(D E)
&gt; (nthcdr 5 '(a b c d e))
NIL
</pre>
<p> nthcdr を使うと third, fourth, fifth などは簡単に定義することができます。
</p>
<h4 id="ans08">●解答８</h4>
<pre class="list">
リスト : リスト xs の n 番目の要素を取り出す

(defun nth (n xs) (car (nthcdr n xs)))
</pre>
<pre>
&gt; (nth 0 '(a b c d e))
A
&gt; (nth 3 '(a b c d e))
D
&gt; (nth 4 '(a b c d e))
E
</pre>
<p> nth も nthcdr を使うと簡単に定義することができます。
</p>
<h4 id="ans09">●解答９</h4>
<pre class="list">
リスト : リストの長さを求める

(defun my-length (xs)
  (if (null xs)
      0
    (1+ (my-length (cdr xs)))))

;; 末尾再帰
(defun my-length-tail (xs n)
  (if (null xs)
      n
    (my-length-tail (cdr xs) (1+ n))))
</pre>
<pre>
&gt; (my-length nil)
0
&gt; (my-length '(a b c d e))
5
&gt; (my-length-tail nil 0)
0
&gt; (my-length-tail '(a b c d e) 0)
5
</pre>
<p> my-length-tail は局所関数を定義する labels を使って書き直すことができます。興味のある方は挑戦してみてください。
</p>
<h4 id="ans10">●解答10</h4>
<pre class="list">
リスト : リストの連結

(defun my-append (xs ys)
  (if (null xs)
      ys
    (cons (car xs) (my-append (cdr xs) ys))))
</pre>
<pre>
&gt; (my-append nil '(a b c))
(A B C)
&gt; (my-append '(a b c) nil)
(A B C)
&gt; (my-append '(a b c) '(d e f g))
(A B C D E F G)
</pre>
<hr>
<h4 id="chap02">●問題11</h4>
<p> リスト xs を反転する関数 my-reverse xs を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans11">解答11</a>
</p>
<h4>●問題12</h4>
<p> リスト xs の末尾から n 個の要素を取り除く関数 butlast を定義してください。
</p>
<p><a href="islisp05.html#ans12">解答12</a>
</p>
<h4>●問題13</h4>
<p> リスト xs から x と等しい要素を探索する関数 my-member を定義してください。等値の判定には述語 eql を使ってください。返り値は関数 member と同じです。
</p>
<p><a href="islisp05.html#ans13">解答13</a>
</p>
<h4>●問題14</h4>
<p> リスト xs の n 番目に x を挿入する関数 insert-at n x xs を定義してください。なお、n がリストの長さ以上の場合は末尾に追加するものとします。
</p>
<p><a href="islisp05.html#ans14">解答14</a>
</p>
<h4>●問題15</h4>
<p> リスト xs の n 番目の要素を削除する関数 remove-at n xs を定義してください。
</p>
<p><a href="islisp05.html#ans15">解答15</a>
</p>
<h4>●問題16</h4>
<p> n 個の要素 x を格納したリストを生成する関数 make-list n x と、リスト xs をコピーする関数 copy-list を定義してください。
</p>
<p><a href="islisp05.html#ans16">解答16</a>
</p>
<h4>●問題17</h4>
<p> リスト xs の要素の総和を求める関数 sum xs と、すべての要素を乗算する関数 product xs を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans17">解答17</a>
</p>
<h4>●問題18</h4>
<p> リスト xs から最大値を求める maximum xs と最小値を求める minimum xs を再帰呼び出しを使って定義してください。
</p>
<p><a href="islisp05.html#ans18">解答18</a>
</p>
<h4>●問題19</h4>
<p> 次に示す連想リスト (alist) を操作する関数を定義してください。
</p>
<ol>
  <li>acons x y alist<br>
連想リスト alist の先頭にドット対 (x . y) を追加する</li>
  <li>pairlis keys data alist<br>
リスト keys, data の要素をドット対に格納し、それを連想リスト alist に追加する</li>
  <li>my-assoc key alist<br>
連想リスト alist から key を探索する (等値の判定には述語 eql を使う)</li>
</ol>
<p><a href="islisp05.html#ans19">解答19</a>
</p>
<h4>●問題20</h4>
<p> リスト xs を挿入ソートする関数 insert-sort xs を定義してください。
</p>
<p><a href="islisp05.html#ans20">解答20</a>
</p>
<hr>
<h4 id="ans11">●解答11</h4>
<pre class="list">
リスト : リストの反転

(defun my-reverse (xs)
  (if (null xs)
      nil
    (append (my-reverse (cdr xs)) (list (car xs)))))  ; append を使っているので効率が悪い

;; 末尾再帰
(defun my-reverse-tail (xs ys)
  (if (null xs)
      ys
    (my-reverse-tail (cdr xs) (cons (car xs) ys))))
</pre>
<pre>
&gt; (my-reverse nil)
NIL
&gt; (my-reverse '(a))
(A)
&gt; (my-reverse '(a b c d e))
(E D C B A)
&gt; (my-reverse-tail nil nil)
NIL
&gt; (my-reverse-tail '(a) nil)
(A)
&gt; (my-reverse-tail '(a b c d e) nil)
(E D C B A)
</pre>
<p> my-reverse-tail は局所関数を定義する labels を使って書き直すことができます。興味のある方は挑戦してみてください。
</p>
<h4 id="ans12">●解答12</h4>
<pre class="list">
リスト : リストから末尾 n 個の要素を取り除く

(defun butlast (xs n)
  (nreverse (nthcdr n (reverse xs))))
</pre>
<pre>
&gt; (butlast '(a b c d e) 1)
(A B C D)
&gt; (butlast '(a b c d e) 3)
(A B)
&gt; (butlast '(a b c d e) 5)
NIL
</pre>
<p> butlast は reverse を使うと簡単です。リストを反転して先頭から n 個の要素を取り除き、それを nreverse で反転します。nreverse はリストを破壊的に反転するので、新しいコンスセルを使うことはありません。
</p>
<h4 id="ans13">●解答13</h4>
<pre class="list">
リスト : リストに x が含まれているか

(defun my-member (x xs)
  (if (or (null xs) (eql x (car xs)))
      xs
    (my-member x (cdr xs))))
</pre>
<pre>
&gt; (my-member 'a '(a b c d e))
(A B C D E)
&gt; (my-member 'e '(a b c d e))
(E)
&gt; (my-member 'f '(a b c d e))
NIL
</pre>
<h4 id="ans14">●解答14</h4>
<pre class="list">
リスト : リストの n 番目に x を挿入する

(defun insert-at (n x xs)
  (if (or (null xs) (= n 0))
      (cons x xs)
    (cons (car xs) (insert-at (- n 1) x (cdr xs)))))
</pre>
<pre>
&gt; (insert-at 0 'x '(a b c d e))
(X A B C D E)
&gt; (insert-at 3 'x '(a b c d e))
(A B C X D E)
&gt; (insert-at 5 'x '(a b c d e))
(A B C D E X)
</pre>
<h4 id="ans15">●解答15</h4>
<pre class="list">
リスト : リストの n 番目の要素を削除する

(defun remove-at (n xs)
  (cond ((null xs) nil)
        ((= n 0) (cdr xs))
        (t (cons (car xs) (remove-at (- n 1) (cdr xs))))))
</pre>
<pre>
&gt; (remove-at 0 '(a b c d e))
(B C D E)
&gt; (remove-at 3 '(a b c d e))
(A B C E)
&gt; (remove-at 4 '(a b c d e))
(A B C D)
&gt; (remove-at 5 '(a b c d e))
(A B C D E)
</pre>
<h4 id="ans16">●解答16</h4>
<pre class="list">
リスト : make-list と copy-list

(defun make-list (n x)
  (if (zerop n)
      nil
    (cons x (make-list (1- n) x))))

;; 末尾再帰
(defun make-list-tail (n x ys)
  (if (zerop n)
      ys
    (make-list-tail (1- n) x (cons x ys))))

(defun copy-list (xs)
  (if (null xs)
      nil
    (cons (car xs) (copy-list (cdr xs)))))

;; 末尾再帰
(defun copy-list-tail (xs ys)
  (if (null xs)
      (nreverse ys)
    (copy-list-tail (cdr xs) (cons (car xs) ys))))
</pre>
<pre>
&gt; (make-list 10 'a)
(A A A A A A A A A A)
&gt; (make-list-tail 10 'b nil)
(B B B B B B B B B B)
&gt; (copy-list '(a b c d e))
(A B C D E)
&gt; (copy-list-tail '(a b c d e) nil)
(A B C D E)
</pre>
<p> copy-list-tail は累積変数 ys に要素を追加していき、最後に nreverse で反転することでリストをコピーしています。nreverse をしないと、逆順のリストを生成することに注意してください。
</p>
<h4 id="ans17">●解答17</h4>
<pre class="list">
リスト : sum と product

(defun sum (xs)
  (if (null xs)
      0
    (+ (car xs) (sum (cdr xs)))))

;; 末尾再帰
(defun sum-tail (xs acc)
  (if (null xs)
      acc
    (sum-tail (cdr xs) (+ (car xs) acc))))

(defun product (xs)
  (if (null xs)
      1
    (* (car xs) (product (cdr xs)))))

;; 末尾再帰
(defun product-tail (xs acc)
  (if (null xs)
      acc
    (product-tail (cdr xs) (* (car xs) acc))))
</pre>
<pre>
&gt; (sum '(1 2 3 4 5 6 7 8 9 10))
55
&gt; (sum-tail '(1 2 3 4 5 6 7 8 9 10) 0)
55
&gt; (product '(1 2 3 4 5 6 7 8 9 10))
3628800
&gt; (product-tail '(1 2 3 4 5 6 7 8 9 10) 1)
3628800
&gt; (apply #'+ '(1 2 3 4 5 6 7 8 9 10))
55
&gt; (apply #'* '(1 2 3 4 5 6 7 8 9 10))
3628800
</pre>
<p> 実をいうと、sum と product は apply を使うと簡単に定義することができます。
</p>
<h4 id="ans18">●解答18</h4>
<pre class="list">
リスト : 最大値と最小値

(defun maximum-tail (xs m)
  (if (null xs)
      m
    (maximum-tail (cdr xs) (max (car xs) m))))

(defun maximum (xs)
  (if (null (cdr xs))
      (car xs)
    (maximum-tail (cdr xs) (car xs))))

(defun minimum-tail (xs m)
  (if (null xs)
      m
    (minimum-tail (cdr xs) (min (car xs) m))))

(defun minimum (xs)
  (if (null (cdr xs))
      (car xs)
    (minimum-tail (cdr xs) (car xs))))
</pre>
<pre>
&gt; (maximum '(1))
1
&gt; (maximum '(5 4 6 3 7 2 8 1 9 0))
9
&gt; (minimum '(1))
1
&gt; (minimum '(5 6 4 7 3 8 2 9 1 0))
0
&gt; (apply #'max '(5 4 6 7 3 2 1 8 9 0))
9
&gt; (apply #'min '(5 6 4 7 3 8 2 9 1 0))
0
</pre>
<p> 実をいうと、maximum, minimum は apply と max, min を使うと、もっと簡単に定義することができます。
</p>
<h4 id="ans19">●解答19</h4>
<pre class="list">
リスト : 連想リストの操作

(defun acons (x y alist)
  (cons (cons x y) alist))

(defun pairlis (keys data alist)
  (if (or (null keys) (null data))
      alist
    (acons (car keys) (car data) (pairlis (cdr xs) (cdr ys) alist))))

(defun my-assoc (key alist)
  (cond ((null alist) nil)
        ((eql (car (car alist)) key) (car alist))
        (t (my-assoc key (cdr alist)))))
</pre>
<pre>
&gt; (acons 'a 1 nil)
((A . 1))
&gt; (pairlis '(a b c d e) '(1 2 3 4 5) nil)
((A . 1) (B . 2) (C . 3) (D . 4) (E . 5))
&gt; (my-assoc 'c '((a . 1) (b . 2) (c . 3)))
(C . 3)
&gt; (my-assoc 'd '((a . 1) (b . 2) (c . 3)))
NIL
</pre>

<h4 id="ans20">●解答20</h4>
<pre class="list">
リスト : 挿入ソート

(defun insert-element (x xs)
  (if (or (null xs) (&lt;= x (car xs)))
      (cons x xs)
    (cons (car xs)
          (insert-element x (cdr xs)))))

(defun insert-sort (xs)
  (if (null xs)
      nil
    (insert-element (car xs) (insert-sort (cdr xs)))))
</pre>
<pre>
&gt; (insert-sort '(5 6 4 7 3 8 2 9 1 0))
(0 1 2 3 4 5 6 7 8 9)
&gt; (insert-sort '(9 8 7 6 5 4 3 2 1 0))
(0 1 2 3 4 5 6 7 8 9)
&gt; (insert-sort '(0 1 2 3 4 5 6 7 8 9))
(0 1 2 3 4 5 6 7 8 9)
</pre>
<p> 挿入ソートのアルゴリズムは拙作のページ <a href="../xyzzy_lisp.html">Common Lisp 入門</a> <a href="../xyzzy_lisp/abclisp05.html#yori03">ソート (その１)</a> で簡単に説明しています。興味のある方はお読みくださいませ。
</p>
<hr>
<h4 id="chap03">●問題21</h4>
<p> リスト xs を木とみなし、葉 (要素) の個数を数える関数 count-leaf xs を定義してください。
</p>
<p><a href="islisp05.html#ans21">解答21</a>
</p>
<h4>●問題22</h4>
<p> リスト xs を木とみなし、x と等しい要素を探索する関数 member-tree x xs を定義してください。等しい要素を見つけた場合は t を、見つからない場合は nil を返します。なお、等値の判定には述語 eql を使うことにします。
</p>
<p><a href="islisp05.html#ans22">解答22</a>
</p>
<h4>●問題23</h4>
<p> リスト xs の要素で、引数 old と等しいものを new に置き換える関数 substitute old new xs を定義してください。等値の判定には述語 eql を使うことにします。
</p>
<p><a href="islisp05.html#ans23">解答23</a>
</p>
<h4>●問題24</h4>
<p> リスト xs を木とみなし、引数 old と等しい要素を new に置き換える関数 subst old new xs を定義してください。等値の判定には述語 eql を使うことにします。
</p>
<p><a href="islisp05.html#ans24">解答24</a>
</p>
<h4>●問題25</h4>
<p> リスト xs を平坦化する関数 flatten xs を定義してください。
</p>
<p><a href="islisp05.html#ans25">解答25</a>
</p>
<h4>●問題26</h4>
<p> 次に示す高階関数を定義してください。
</p>
<ol>
  <li>リスト xs の要素に関数 func を適用し、その結果をリストに格納して返す関数 map func xs (マッピング)</li>
  <li>map func xs の結果を一段階平坦化する関数 flat-map func xs</li>
  <li>リスト xs の要素に述語 pred を適用し、真を返す要素をリストに格納して返す関数 filter pred xs (フィルター)</li>
  <li>リスト xs を先頭から畳み込む関数 fold-left func a xs と、末尾から畳み込む fold-right func a xs</li>
  <li>リスト xs の要素に関数 func を適用する関数 for-each func xs</li>
</ol>
<p><a href="islisp05.html#ans26">解答26</a>
</p>
<h4>●問題27</h4>
<p> リスト xs を線形探索する高階関数を定義してください。
</p>
<ol>
  <li>述語 pred が真を返す要素を探索する関数 find-if pred xs</li>
  <li>述語 pred が真を返す要素の位置を求める関数 postion-if pred xs</li>
  <li>述語 pred が真を返す要素の個数を求める関数 count-if pred xs</li>
</ol>
<p><a href="islisp05.html#ans27">解答27</a>
</p>
<h4>●問題28</h4>
<p> リスト xs の先頭から述語 pred を満たす要素を取り出す関数 take-while と、pred を満たす要素を取り除く関数 drop-while を定義してください。
</p>
<p><a href="islisp05.html#ans28">解答28</a>
</p>
<h4>●問題29</h4>
<p> リストの中で連続した等しい記号を部分リストにまとめる関数 pack xs を定義してください。
</p>
<p><a href="islisp05.html#ans29">解答29</a>
</p>
<h4>●問題30</h4>
<p> リスト xs において、連続している同じ記号を (code . num) に変換する関数 rle xs を定義してください。code は記号、num は個数を表します。このような変換を「ランレングス符号化」といいます。そして、rle の逆変換を行う関数 rld を定義してください。
</p>
<p><a href="islisp05.html#ans30">解答30</a>
</p>
<hr>
<h4 id="ans21">●解答21</h4>
<pre class="list">
リスト : 葉の個数をカウントする

(defun count-leaf (xs)
  (cond ((null xs) 0)
        ((consp xs)
         (+ (count-leaf (car xs))
            (count-leaf (cdr xs))))
        (t 1)))
</pre>
<pre>
&gt; (count-leaf '(a b c d e))
5
&gt; (count-leaf '((a b) (c d) (e f)))
6
&gt; (count-leaf '(a (b (c (d) e) f) g))
7
</pre>
<h4 id="ans22">●解答22</h4>
<pre class="list">
リスト : 木の探索

(defun member-tree (x xs)
  (cond ((eql x xs) t)
        ((consp xs)
         (or (member-tree x (car xs))
             (member-tree x (cdr xs))))
        (t nil)))
</pre>
<pre>
&gt; (member-tree 'd '(a b c d e))
T
&gt; (member-tree 'd '(a (b (c (d) e) f) g))
T
&gt; (member-tree 'h '(a (b (c (d) e) f) g))
NIL
</pre>
<h4 id="ans23">●解答23</h4>
<pre class="list">
リスト : リストの置換

(defun substitute (old new xs)
  (cond ((null xs) nil)
        ((eql (car xs) old)
         (cons new (substitute old new (cdr xs))))
        (t (cons (car xs) (substitute old new (cdr xs))))))
</pre>
<pre>
&gt; (substitute 'a 'x '(a b c a b c a b c))
(X B C X B C X B C)
&gt; (substitute 'd 'x '(a b c a b c a b c))
(A B C A B C A B C)
&gt; (substitute 'a 'x '((a b) (a c) (a d)))
((A B) (A C) (A D))
</pre>
<h4 id="ans24">●解答24</h4>
<pre class="list">
リスト : 木の置換

(defun subst (old new xs)
  (cond ((eql old xs) new)
        ((consp xs)
         (cons (subst old new (car xs))
              (subst old new (cdr xs))))
        (t xs)))
</pre>
<pre>
&gt; (subst 'a 'x '(a b c a b c a b c))
(X B C X B C X B C)
&gt; (subst 'a 'x '((a b) (a c) (a d)))
((X B) (X C) (X D))
&gt; (subst 'd 'x '(a (b (c) b) a))
(A (B (C) B) A)
</pre>
<h4 id="ans25">●解答25</h4>
<pre class="list">
リスト : リストの平坦化

(defun flatten (xs)
  (cond ((null xs) nil)
        ((consp xs)
         (append (flatten (car xs))    ; append を使っているので効率が悪い
                 (flatten (cdr xs))))
        (t (list xs))))
</pre>
<pre>
&gt; (flatten '(a b c d e))
(A B C D E)
&gt; (flatten '((a b) (c d) (e f)))
(A B C D E F)
&gt; (flatten '(a (b (c (d) e) f) g))
(A B C D E F G)
</pre>
<h4 id="ans26">●解答26</h4>
<pre class="list">
リスト : 基本的な高階関数

;; マッピング
(defun map (func xs)
  (if (null xs)
      nil
    (cons (funcall func (car xs)) (map func (cdr xs)))))

(defun flat-map (func xs)
  (apply #'append (map func xs)))

;; フィルター
(defun filter (pred xs)
  (cond ((null xs) nil)
        ((funcall pred (car xs))
         (cons (car xs) (filter pred (cdr xs))))
        (t (filter pred (cdr xs)))))

;; 畳み込み
(defun fold-left (func a xs)
  (if (null xs)
      a
    (fold-left func (funcall func a (car xs)) (cdr xs))))

(defun fold-right (func a xs)
  (if (null xs)
      a
    (funcall func (car xs) (fold-right func a (cdr xs)))))

;; 巡回
(defun for-each (func xs)
  (cond ((not (null xs))
         (funcall func (car xs))
         (for-each func (cdr xs)))))
</pre>
<pre>
&gt; (map #'square '(1 2 3 4 5 6 7 8))
(1 4 9 16 25 36 49 64)
&gt; (map (lambda (x) (make-list x x)) '(1 2 3 4 5))
((1) (2 2) (3 3 3) (4 4 4 4) (5 5 5 5 5))
&gt; (flat-map (lambda (x) (make-list x x)) '(1 2 3 4 5))
(1 2 2 3 3 3 4 4 4 4 5 5 5 5 5)
&gt; (filter #'evenp '(1 2 3 4 5 6 7 8))
(2 4 6 8)
&gt; (fold-left #'+ 0 '(1 2 3 4 5 6 7 8 9 10))
55
&gt; (fold-left (lambda (a x) (cons x a)) nil '(1 2 3 4 5 6 7 8))
(8 7 6 5 4 3 2 1)
&gt; (fold-right #'* 1 '(1 2 3 4 5 6 7 8 9 10))
3628800
&gt; (fold-right #'cons nil '(1 2 3 4 5 6 7 8))
(1 2 3 4 5 6 7 8)
&gt; (for-each (lambda (x) (format (standard-output) "~D " x)) '(1 2 3 4 5))
1 2 3 4 5 NIL
</pre>
<h4 id="ans27">●解答27</h4>
<pre class="list">
リスト : リストの線形探索

(defun find-if (pred xs)
  (cond ((null xs) nil)
        ((funcall pred (car xs)) (car xs))
        (t (find-if pred (cdr xs)))))

(defun position-if (pred xs)
  (block exit
    (for ((i 0 (1+ i))
          (ys xs (cdr ys)))
         ((null ys) -1)
      (if (funcall pred (car ys))
           (return-from exit i)))))

(defun count-if (pred xs)
  (fold-left (lambda (a x) (if (pred x) (1+ a) a)) 0 xs))
</pre>
<pre>
&gt; (find-if #'evenp '(1 3 5 7 8 9))
8
&gt; (find-if #'evenp '(1 3 5 7 9 11))
NIL
&gt; (position-if #'evenp '(1 3 5 7 8 9))
4
&gt; (position-if #'evenp '(1 3 5 7 9 11))
-1
&gt; (count-if #'evenp '(1 2 3 4 5 6 7))
3
&gt; (count-if #'oddp '(1 2 3 4 5 6 7))
4
&gt; (count-if #'minusp '(1 2 3 4 5 6 7))
0
</pre>
<h4 id="ans28">●解答28</h4>
<pre class="list">
リスト : take-while と drop-while

(defun take-while (pred xs)
  (if (or (null xs) (not (funcall pred (car xs))))
      nil
    (cons (car xs) (take-while pred (cdr xs)))))

(defun drop-while (pred xs)
  (if (or (null xs) (not (funcall pred (car xs))))
      xs
    (drop-while pred (cdr xs))))
</pre>
<pre>
&gt; (take-while #'plusp '(1 2 3 4 5 -1 2 3 4 5))
(1 2 3 4 5)
&gt; (take-while #'plusp '(-1 2 3 4 5 6 7 8))
NIL
&gt; (drop-while #'plusp '(1 2 3 4 5 -1 2 3 4 5))
(-1 2 3 4 5)
&gt; (drop-while #'plusp '(-1 2 3 4 5 6 7 8))
(-1 2 3 4 5 6 7 8)
</pre>
<h4 id="ans29">●解答29</h4>
<pre class="list">
リスト : パッキング

(defun pack (xs)
  (if (null xs)
      nil
    (cons (take-while (lambda (x) (eql (car xs) x)) xs)
          (pack (drop-while (lambda (x) (eql (car xs) x)) xs)))))
</pre>
<pre>
&gt; (pack '(a a a b c c d d d d d))
((A A A) (B) (C C) (D D D D D))
&gt; (pack '(a b c d e f g))
((A) (B) (C) (D) (E) (F) (G))
</pre>
<h4 id="ans30">●解答30</h4>
<pre class="list">
リスト : ランレングス符号

(defun rle (xs)
  (map (lambda (ys) (cons (car ys) (length ys))) (pack xs)))

(defun rld (xs)
  (flat-map (lambda (code) (make-list (cdr code) (car code))) xs))
</pre>
<pre>
&gt; (rle '(a a b b b c c c c d d d d d))
((A . 2) (B . 3) (C . 4) (D . 5))
&gt; (rld '((a . 1) (b . 3) (c . 5)))
(A B B B C C C C C)
&gt; (rld (rle '(a b b c c c d d d d e e e e e a)))
(A B B C C C D D D D E E E E E A)
</pre>
<hr>
<h4 id="chap04">●問題31</h4>
<p> リスト xs の末尾のセル (要素ではない) を求める関数 last xs を定義してください。
</p>
 <p><a href="islisp05.html#ans31">解答31</a>
</p>

<h4>●問題32</h4>
<p> リスト xs と ys を破壊的に連結する関数 my-nconc xs ys を定義してください。
</p>
<p><a href="islisp05.html#ans32">解答32</a>
</p>

<h4>●問題33</h4>
<p> リスト xs の n 番目の要素を x に破壊的に書き換える関数 set-nth n x xs を定義してください。
</p>
<p><a href="islisp05.html#ans33">解答33</a>
</p>

<h4>●問題34</h4>
<p> リストを破壊的に反転する関数 my-nreverse を定義してください。
</p>
<p><a href="islisp05.html#ans34">解答34</a>
</p>

<h4>●問題35</h4>
<p> リスト xs と ys を受け取り、xs を反転して ys と連結する関数 revappend xs ys と、xs を破壊的に反転して ys と連結する関数 nrevappend を定義してください。
</p>
<p><a href="islisp05.html#ans35">解答35</a>
</p>

<h4>●問題36</h4>
<p> リスト xs から n 個の要素を反転して取り出す関数 revtake n xs と、n 個の要素を取り出して返す関数 my-take n xs を定義してください。
</p>
<p><a href="islisp05.html#ans36">解答36</a>
</p>

<h4>●問題37</h4>
<p> my-append, insert-at, remove-at は繰り返し (末尾再帰) ではないので、長いリストを処理しようとするとスタックオーバーフロー (またはコアダンプ) します。長いリストでも処理できるように、これらの関数を改良してください。
</p>
<p><a href="islisp05.html#ans37">解答37</a>
</p>

<h4>●問題38</h4>
<p> map, filter, fold-left, take-while は繰り返し (末尾再帰) ではないので、長いリストを処理しようとするとスタックオーバーフロー (またはコアダンプ) します。長いリストでも処理できるように、これらの関数を改良してください。
</p>
<p><a href="islisp05.html#ans38">解答38</a>
</p>

<h4>●問題39</h4>
<p> 引数を要素とする循環リストを生成する関数 circular-list と、循環リストを表示する関数 print-circular-list を定義してください。
</p>
<p><a href="islisp05.html#ans39">解答39</a>
</p>

<h4>●問題40</h4>
<p> リスト xs が循環リストか判定する述語 circular-listp xs を定義してください。
</p>
<p><a href="islisp05.html#ans40">解答40</a>
</p>
<hr>
<h4 id="ans31">●解答31</h4>
<pre class="list">
リスト : 末尾のセルを求める

(defun last (xs)
  (if (or (null xs) (null (cdr xs)))
      xs
    (last (cdr xs))))
</pre>
<pre>
&gt; (last nil)
NIL
&gt; (last '(a))
(A)
&gt; (last '(a b c d e))
(E)
</pre>
<h4 id="ans32">●解答32</h4>
<p> ISLisp の場合、コンスセル xs の CAR 部を obj に書き換えるには (set-car obj xs) または (setf (car xs) obj) を使います。CDR 部を書き換えるには (set-cdr obj xs) または (setf (cdr xs) obj) を使います。Common Lisp では rplaca, rplacd, setf を、Scheme では set-car!, set-cdr! を使います。
</p>
<p> my-nconc は last で xs の末尾セルを求め、set-cdr で CDR 部を ys に書き換えるだけです。これで xs を破壊的に修正して、ys を連結することができます。
</p>
<pre class="list">
リスト : リストの破壊的連結

(defun my-nconc (xs ys)
  (set-cdr ys (last xs))
  xs)
</pre>
<pre>
&gt; (defglobal xs '(a b c d))
XS
&gt; (my-nconc xs '(e f g h))
(A B C D E F G H)
&gt; xs
(A B C D E F G H)
</pre>

<h4 id="ans33">●解答33</h4>
<p> set-nth は nthcdr と set-car を使えば簡単に定義することができます。
</p>
<pre class="list">
リスト : リストの n 番目の要素を破壊的に書き換える

(defun set-nth (n x xs)
  (set-car x (nthcdr n xs))
  xs)
</pre>
<pre>
&gt; xs
(A B C D E F G H)
&gt; (set-nth 4 'z xs)
(A B C D Z F G H)
&gt; xs
(A B C D Z F G H)
&gt; (set-nth 7 'z xs)
(A B C D Z F G Z)
&gt; (set-nth 0 'z xs)
(Z B C D Z F G Z)
</pre>
<h4 id="ans34">●解答34</h4>
<p> my-nreverse のアルゴリズムは拙作のページ <a href="../func/scheme.html">Scheme Programming</a> <a href="../func/abcscm14.html">Scheme プログラミング中級編 (その４)</a> で詳しく説明しています。よろしければ、そちらをお読みくださいませ。
</p>
<pre class="list">
リスト : リストの破壊的反転

(defun my-nreverse (xs)
  (for ((ys xs) (rs nil))
       ((null ys) rs)
       (let ((zs (cdr ys)))
         (set-cdr rs ys)
         (setq rs ys)
         (setq ys zs))))
</pre>
<pre>
&gt; (defglobal xs '(a b c d e))
XS
&gt; (my-nreverse xs)
(E D C B A)
&gt; xs
(A)
&gt; (my-nreverse nil)
NIL
&gt; (my-nreverse '(1))
(1)
</pre>

<h4 id="ans35">●解答35</h4>
<p> revappend は末尾再帰で簡単に定義することができます。nrevappend は my-nreverse とほとんど同じです。
</p>
<pre class="list">
リスト : リストを反転して連結する

(defun revappend (xs ys)
  (if (null xs)
      ys
    (revappend (cdr xs) (cons (car xs) ys))))

(defun nrevappend (xs ys)
  (for ((ys1 xs) (rs ys))
       ((null ys1) rs)
       (let ((zs (cdr ys1)))
         (set-cdr rs ys1)
         (setq rs ys1)
         (setq ys1 zs))))
</pre>
<pre>
&gt; (revappend '(a b c d) '(e f g h))
(D C B A E F G H)
&gt; (nrevappend (list 1 2 3 4) '(5 6 7 8))
(4 3 2 1 5 6 7 8)
</pre>
<h4 id="ans36">●解答36</h4>
<pre class="list">
リスト : revtake と my-take

(defun revtake (n xs)
  (for ((m n (1- m))
        (rs nil (cons (car ys) rs))
        (ys xs (cdr ys)))
       ((or (zerop m) (null ys)) rs)))

(defun my-take (n xs)
  (nreverse (revtake n xs)))
</pre>
<p> revtake は繰り返し (for) を使いましたが、末尾再帰でも簡単にプログラムすることができます。my-take は revtake と nreverse を使うと簡単です。再帰呼び出しでも簡単にプログラムできますが、繰り返し (末尾再帰) になっていないと、長いリストを処理することができません。この方法だと、長いリストにも対応することができます。
</p>
<pre>
&gt; (revtake 3 '(a b c d e))
(C B A)
&gt; (revtake 0 '(a b c d e))
NIL
&gt; (revtake 1 '(a b c d e))
(A)
&gt; (my-take 3 '(a b c d e))
(A B C)
&gt; (my-take 0 '(a b c d e))
NIL
&gt; (my-take 1 '(a b c d e))
(A)
</pre>
<h4 id="ans37">●解答37</h4>
<pre class="list">
リスト : my-append, insert-at, remove-at の改良

(defun append-ok (xs ys)
  (nrevappend (reverse xs) ys))

(defun insert-at-ok (n x xs)
  (nrevappend (revtake n xs) (cons x (nthcdr n xs))))

(defun remove-at-ok (n xs)
  (nrevappend (revtake n xs) (nthcdr (1+ n) xs)))
</pre>
<p> どの関数も reverse, revtake で反転したリストを生成し、それを nrevappend で破壊的に反転して連結します。
</p>
<pre>
&gt; (append-ok '(a b c d) '(e f g h))
(A B C D E F G H)
&gt; (append-ok nil '(e f g h))
(E F G H)
&gt; (append-ok '(a b c d) nil)
(A B C D)
&gt; (insert-at-ok 4 'x '(a b c d e f g h))
(A B C D X E F G H)
&gt; (insert-at-ok 8 'x '(a b c d e f g h))
(A B C D E F G H X)
&gt; (remove-at 4 '(a b c d e f g h))
(A B C D F G H)
&gt; (remove-at 7 '(a b c d e f g h))
(A B C D E F G)
</pre>

<h4 id="ans38">●解答38</h4>
<pre class="list">
リスト : map, filter, fold-right, take-while の改良

(defun map-ok (func xs)
  (for ((ys xs (cdr ys))
        (rs nil (cons (funcall func (car ys)) rs)))
       ((null ys) (nreverse rs))))

(defun filter-ok (pred xs)
  (for ((ys xs (cdr ys))
        (rs nil))
       ((null ys) (nreverse rs))
       (if (funcall pred (car ys))
           (setq rs (cons (car ys) rs)))))

(defun fold-right-ok (func a xs)
  (for ((ys (reverse xs) (cdr ys))
        (acc a (funcall func (car ys) acc)))
       ((null ys) acc)))

(defun take-while-ok (pred xs)
  (for ((ys xs (cdr ys))
        (rs nil (cons (car ys) rs)))
       ((or (null ys) (not (funcall pred (car ys))))
        (nreverse rs))))
</pre>
<p> どの関数も for を使ってプログラムしています。map-ok, fiter-ok, take-while-ok は最後に nreverse でリストを破壊的に反転することに注意してください。fold-right-ok は最初に reverse でリストを反転することで繰り返しに対応しています。
</p>
<pre>
&gt; (map-ok #'square '(1 2 3 4 5 6 7 8))
(1 4 9 16 25 36 49 64)
&gt; (filter-ok #'evenp '(1 2 3 4 5 6 7 8))
(2 4 6 8)
&gt; (fold-right-ok #'cons nil '(a b c d e f g))
(A B C D E F G)
&gt; (fold-right-ok #'+ 0 '(1 2 3 4 5 6 7 8))
36
&gt; (take-while-ok #'plusp '(1 2 3 4 0 5 6 7 8))
(1 2 3 4)
&gt; (take-while-ok #'plusp '(0 1 2 3 4 5 6 7 8))
NIL
&gt; (take-while-ok #'plusp '(1 2 3 4 5 6 7 8))
(1 2 3 4 5 6 7 8)
</pre>

<h4 id="ans39">●解答39</h4>
<pre class="list">
リスト : 循環リスト

(defun circular-list (:rest args)
  (set-cdr args (last args))
  args)

(defun print-circular-list (xs)
  (block exit
    (let ((ys xs))
      (while t
        (format (standard-output) "~S " (car ys))
        (setq ys (cdr ys))
        (cond ((eq ys xs)
               (format (standard-output) "~%")
               (return-from exit nil)))))))
</pre>
<p> circular-list はリスト args の末尾セルを last で求め、その CDR 部を先頭セル args に書き換えるだけです。表示は先頭セル xs から順番にセルをたどり、先頭に戻ったら処理を終了します。
</p>
<pre>
&gt; (print-circular-list (circular-list 1 2 3 4 5))
1 2 3 4 5
NIL
&gt; (print-circular-list (circular-list 1))
1
NIL
</pre>
<h4 id="ans40">●解答40</h4>
<p> 循環リストのチェックは「うさぎとかめ」のアルゴリズムを使うと簡単です。「うさぎ」と「かめ」はリストをたどる変数として定義します。うさぎは cdr を 2 回適用して進みますが、かめは cdr を 1 回適用して進みます。うさぎがリストの終端に到達すれば、リストは循環していないことがわかります。うさぎがかめに追いつけば、リストは循環していると判断できます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 循環リストの判定 (修正 2018/03/21)

(defun circular-listp (xs)
  (if (or (null xs) (null (cdr xs)))
      nil
    (block exit
      (for ((fast (cdr (cdr xs)) (cdr (cdr fast)))
            (slow (cdr xs) (cdr slow)))
           ((or (null fast) (null (cdr fast))) nil)
           (if (eq fast slow) (return-from exit t))))))
</pre>
<pre>
&gt; (circular-listp '())
NIL
&gt; (circular-listp '(1))
NIL
&gt; (circular-listp '(1 2))
NIL
&gt; (circular-listp '(1 2 3))
NIL
&gt; (circular-listp '(1 2 3 4))
NIL
&gt; (circular-listp (circular-list 1 2 3 4))
T
&gt; (circular-listp (circular-list 1 2 3))
T
&gt; (circular-listp (circular-list 1 2))
T
&gt; (circular-listp (circular-list 1))
T
</pre>
<h4>●修正 (2018/03/21)</h4>
<p> 今までのプログラム (下記リスト) は、引数に空リストまたは要素が 3 つ以上の奇数個のリストを与えるとエラーになります。ISLisp は空リストに cdr を適用するとエラーになることをうっかりしていました。ご指摘いただいた笹川さんに感謝いたします。
</p>
<pre class="list">
リスト : 循環リストの判定 (バグあり)

(defun circular-listp (xs)
  (if (null (cdr xs))
      nil
    (block exit
      (for ((fast (cdr (cdr xs)) (cdr (cdr fast)))
            (slow (cdr xs) (cdr slow)))
           ((null fast) nil)
           (if (eq fast slow) (return-from exit t))))))
</pre>
<hr>
<h4 id="chap05">●問題41</h4>
<p> 0 から n - 1 までの整数を関数 func に適用し、その結果をリストに格納して返す関数 tabulate n func と、初項を a として関数 func に前項を適用して n 個の要素を生成する iterate n a func を定義してください。
</p>
<p><a href="islisp05.html#ans41">解答41</a>
</p>

<h4>●問題42</h4>
<p> 次に示す数列を生成する関数を定義してください
</p>
<ol>
  <li>s 以上 s + n 未満の数列を生成する iota n s</li>
  <li>0 から n - 1 までの階乗を格納した数列を生成する facts n</li>
  <li>n 個のフィボナッチ数列を生成する fibos n</li>
</ol>
<p><a href="islisp05.html#ans42">解答42</a>
</p>

<h4>●問題43</h4>
<p> リスト xs から要素を一つ選んで、選んだ要素と残りの要素を返す関数 select xs を定義してください。結果はリストに格納して返すものとします。以下に簡単な動作例を示します。
</p>
<pre>
(select '(1 2 3)) =&gt; ((1 (2 3)) (2 (1 3)) (3 (1 2)))
</pre>
<p><a href="islisp05.html#ans43">解答43</a>
</p>

<h4>●問題44</h4>
<p> リスト xs に x を挿入するパターンをすべて求めてリストに格納して返す関数 interleave x xs を定義してください。以下に簡単な動作例を示します。
</p>
<pre>
(interleave 0 '(1 2)) =&gt; ((0 1 2) (1 0 2) (1 2 0))
</pre>
<p><a href="islisp05.html#ans44">解答44</a>
</p>

<h4>●問題45</h4>
<p> リスト xs の順列を求める関数 permutations xs を定義してください。なお、生成した順列はリストに格納して返すものとします。
</p>
<p><a href="islisp05.html#ans45">解答45</a>
</p>

<h4>●問題46</h4>
<p> リスト xs から n 個の要素を選ぶ組み合わせを求める関数 combinations n xs を定義してください。なお、生成した組み合わせはリストに格納して返すものとします。
</p>
<p><a href="islisp05.html#ans46">解答46</a>
</p>

<h4>●問題47</h4>
<p> 2 つのソート済みのリスト xs, ys をひとつのソート済みのリストにまとめる関数 merge-list xs ys を定義してください。
</p>
<p><a href="islisp05.html#ans47">解答47</a>
</p>
<h4>●問題48</h4>
<p> 関数 merge-list を使ってリスト xs をソートする merge-sort xs を定義してください。
</p>

<p><a href="islisp05.html#ans48">解答48</a>
</p>
<h4>●問題49</h4>
<p> リスト xs を木とみなして、以下に示す高階関数を定義してください。
</p>
<ol>
  <li>マッピングを行う map-tree func xs</li>
  <li>畳み込みを行う fold-tree func a xs (a は初期値)</li>
  <li>木 xs を巡回する for-each-tree func xs</li>
</ol>
<p><a href="islisp05.html#ans49">解答49</a>
</p>

<h4>●問題50</h4>
<p> 高階関数 map, fold-left, fold-right はリストの要素に関数が適用されますが、部分リストを関数に渡す方法も考えられます。部分リストを渡してマッピングを行う関数 my-maplist func xs と、リストの先頭から畳み込みを行う関数 pair-fold-left func a xs と、末尾から畳み込みを行う関数 pair-fold-right func a xs を定義してください。
</p>
<p><a href="islisp05.html#ans50">解答50</a>
</p>
<hr>
<h4 id="ans41">●解答41</h4>
<pre class="list">
リスト : tabulate と iterate

(defun tabulate (n func)
  (for ((m (1- n) (1- m))
        (xs nil (cons (funcall func m) xs)))
       ((minusp m) xs)))

(defun iterate (n a func)
  (for ((a0 a (funcall func a0))
        (m n (1- m))
        (xs nil (cons a0 xs)))
       ((zerop m) (nreverse xs))))
</pre>

<pre>
&gt; (tabulate 10 #'square)
(0 1 4 9 16 25 36 49 64 81)
&gt; (tabulate 10 #'cubic)
(0 1 8 27 64 125 216 343 512 729)
&gt; (iterate 10 1 (lambda (x) (+ x 2)))
(1 3 5 7 9 11 13 15 17 19)
&gt; (iterate 10 1 (lambda (x) (* x 2)))
(1 2 4 8 16 32 64 128 256 512)
</pre>
<h4 id="ans42">●解答42</h4>
<pre class="list">
リスト : 数列の生成

(defun iota (n s) (iterate n s #'1+))

(defun facts (n) (tabulate n #'fact))

(defun fibos (n)
  (mapcar #'car
          (iterate n
                   '(0 1)
                   (lambda (xs)
                   (list (second xs) (+ (first xs) (second xs)))))))
</pre>
<pre>
&gt; (iota 10 1)
(1 2 3 4 5 6 7 8 9 10)
&gt; (iota 10 100)
(100 101 102 103 104 105 106 107 108 109)
&gt; (facts 10)
(1 1 2 6 24 120 720 5040 40320 362880)
&gt; (facts 15)
(1 1 2 6 24 120 720 5040 40320 362880 3628800 39916800 479001600 6227020800 7178291200)
&gt; (fibos 20)
(0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181)
> (nthcdr 20 (fibos 40))
(6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309
3524578 5702887 9227465 14930352 24157817 39088169 63245986)
</pre>
<h4 id="ans43">●解答43</h4>
<pre class="list">
リスト : 要素の選択

(defun select (xs)
(if (null (cdr xs))
    (list (list (car xs) nil))
  (cons (list (car xs) (cdr xs))
        (mapcar (lambda (ys) (list (first ys) (cons (car xs) (second ys))))
                (select (cdr xs))))))
</pre>
<pre>
&gt; (select '(1))
((1 NIL))
&gt; (select '(1 2))
((1 (2)) (2 (1)))
&gt; (select '(1 2 3))
((1 (2 3)) (2 (1 3)) (3 (1 2)))
&gt; (select '(1 2 3 4))
((1 (2 3 4)) (2 (1 3 4)) (3 (1 2 4)) (4 (1 2 3)))
</pre>
<h4 id="ans44">●解答44</h4>
<pre class="list">
リスト : interleave

(defun interleave (x xs)
  (if (null xs)
      (list (list x))
    (append (list (cons x xs))
            (mapcar (lambda (ys) (cons (car xs) ys))
                    (interleave x (cdr xs))))))
</pre>
<pre>
> (interleave 0 '(1 2))
((0 1 2) (1 0 2) (1 2 0))
> (interleave 0 '(1 2 3 4 5))
((0 1 2 3 4 5) (1 0 2 3 4 5) (1 2 0 3 4 5) (1 2 3 0 4 5) (1 2 3 4 0 5) (1 2 3 4 5 0))
</pre>

<h4 id="ans45">●解答45</h4>
<pre class="list">
リスト : 順列の生成

(defun permutations (xs)
  (if (null xs)
      (list nil)
    (flat-map (lambda (ys) (interleave (car xs) ys))
              (permutations (cdr xs)))))
</pre>
<p> permutations は interleave を使うと簡単です。permutations を再帰呼び出しして (cdr xs) の順列を求め、順列を表す要素 ys に interleave で (car xs) を挿入すればいいわけです。リストを平坦化するため flat-map を使っていることに注意してください。
</p>
<pre>
&gt; (permutations '(a b c))
((A B C) (B A C) (B C A) (A C B) (C A B) (C B A))
&gt; (permutations '(a b c d))
((A B C D) (B A C D) (B C A D) (B C D A) (A C B D) (C A B D) (C B A D) (C B D A) (A C D B)
 (C A D B) (C D A B) (C D B A) (A B D C) (B A D C) (B D A C) (B D C A) (A D B C) (D A B C)
 (D B A C) (D B C A) (A D C B) (D A C B) (D C A B) (D C B A))
</pre>
<h4 id="ans46">●解答46</h4>
<pre class="list">
リスト : 組み合わせの生成

(defun combinations (n xs)
  (cond ((zerop n) (list nil))
        ((null xs) nil)
        (t (append (mapcar (lambda (ys) (cons (car xs) ys))
                           (combinations (1- n) (cdr xs)))
                   (combinations n (cdr xs))))))
</pre>
<pre>
&gt; (combinations 3 '(a b c d e))
((A B C) (A B D) (A B E) (A C D) (A C E) (A D E) (B C D) (B C E) (B D E) (C D E))
&gt; (combinations 4 '(a b c d e))
((A B C D) (A B C E) (A B D E) (A C D E) (B C D E))
</pre>
<h4 id="ans47">●解答47</h4>
<pre class="list">
リスト : リストのマージ

(defun merge-list (xs ys)
  (let ((zs nil))
    (while (and xs ys)
      (cond ((&lt;= (car xs) (car ys))
             (setq zs (cons (car xs) zs))
             (setq xs (cdr xs)))
            (t
             (setq zs (cons (car ys) zs))
             (setq ys (cdr ys)))))
    (nrevappend zs (if (null xs) ys xs))))
</pre>
<pre>
&gt; (merge-list '(1 3 5 7) '(2 4 6 8 10))
(1 2 3 4 5 6 7 8 10)
&gt; (merge-list '(5 6 7 8) '(1 2 3 4))
(1 2 3 4 5 6 7 8)
&gt; (merge-list '(1 2 7 8) '(3 4 5 6))
(1 2 3 4 5 6 7 8)
</pre>
<h4 id="ans48">●解答48</h4>
<pre class="list">
リスト : マージソート

(defun merge-sort (xs n)
  (if (= n 1)
      (list (car xs))
    (let ((m (div n 2)))
      (merge-list (merge-sort xs m)
      (merge-sort (nthcdr m xs) (- n m))))))
</pre>
<pre>
&gt; (merge-sort '(5 6 4 7 3 8 2 9 1 0) 10)
(0 1 2 3 4 5 6 7 8 9)
&gt; (merge-sort '(0 1 2 3 4 5 6 7 8 9) 10)
(0 1 2 3 4 5 6 7 8 9)
&gt; (merge-sort '(9 8 7 6 5 4 3 2 1 0) 10)
(0 1 2 3 4 5 6 7 8 9)
</pre>
<h4 id="ans49">●解答49</h4>
<pre class="list">
リスト : 木の高階関数

;; マッピング
(defun map-tree (func xs)
  (cond ((null xs) nil)
        ((consp xs)
         (cons (map-tree func (car xs))
               (map-tree func (cdr xs))))
        (t (funcall func xs))))

;; 畳み込み
(defun fold-tree (func a xs)
  (cond ((null xs) a)
        ((consp xs)
         (fold-tree func (fold-tree func a (cdr xs)) (car xs)))
        (t (funcall func xs a))))

;; 巡回
(defun for-each-tree (func xs)
  (cond ((null xs) nil)
        ((consp xs)
         (for-each-tree func (car xs))
         (for-each-tree func (cdr xs)))
        (t (funcall func xs))))
</pre>
<pre>
&gt; (map-tree #'1+ '(1 2 3 4 5))
(2 3 4 5 6)
&gt; (map-tree #'1+ '(1 (2 (3 (4) 5) 6) 7))
(2 (3 (4 (5) 6) 7) 8)
&gt; (fold-tree #'+ 0 '(1 2 3 4 5))
15
&gt; (fold-tree #'+ 0 '(1 (2 (3 (4) 5) 6) 7))
28
&gt; (fold-tree #'cons nil '(1 2 3 4 5))
(1 2 3 4 5)
&gt; (fold-tree #'cons nil '(1 (2 (3 (4) 5) 6) 7))
(1 2 3 4 5 6 7)
&gt; (for-each-tree (lambda (x) (format (standard-output) "~S " x)) '(1 (2 (3) 4) 5))
1 2 3 4 5 NIL
</pre>
<h4 id="ans50">●解答50</h4>
<pre class="list">
リスト : 部分リストを関数に渡す高階関数

(defun my-maplist (func xs)
  (if (null xs)
      nil
    (cons (funcall func xs) (my-maplist func (cdr xs)))))

(defun pair-fold-left (func a xs)
  (if (null xs)
      a
    (pair-fold-left func (funcall func a xs) (cdr xs))))

(defun pair-fold-right (func a xs)
  (if (null xs)
      a
    (funcall func xs (pair-fold-right func a (cdr xs)))))
</pre>
<pre>
&gt; (my-maplist (lambda (x) x) '(a b c d e))
((a b c d e) (b c d e) (c d e) (d e) (e))
&gt; (my-maplist (lambda (x) (fold + 0 x)) '(1 2 3 4 5))
(15 14 12 9 5)
&gt; (pair-fold-left (lambda (a x) (cons x a)) nil '(1 2 3 4 5))
((5) (4 5) (3 4 5) (2 3 4 5) (1 2 3 4 5))
&gt; (pair-fold-left (lambda (a x) (cons (apply #'+ x) a)) nil '(1 2 3 4 5))
(5 9 12 14 15)
&gt; (pair-fold-right (lambda (x a) (cons x a)) nil '(1 2 3 4 5))
((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5))
&gt; (pair-fold-right (lambda (x a) (cons (apply #'+ x) a)) nil '(1 2 3 4 5))
(15 14 12 9 5)
</pre>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;;
;; drill.lsp : ISLisp ドリル
;;
;;             Copyright (C) 2017 Makoto Hiroi
;;

;; Q01
(defun 1+ (n) (+ n 1))
(defun 1- (n) (- n 1))
(defun square (n) (* n n))
(defun cubic (n) (* n n n))
(defun half (n) (quotient n 2))
(defun medium (n m) (half (+ n m)))
(defun square-medium (n m)
  (medium (square n) (square m)))

;; Q02
(defun zerop (n) (= n 0))
(defun minusp (n) (&lt; n 0))
(defun plusp (n) (&lt; 0 n))
(defun sign (n)
  (if (zerop n)
      0
    (if (plusp n) 1 -1)))
(defun evenp (n) (zerop (mod n 2)))
(defun oddp (n) (not (evenp n)))
(defun between (n low high)
  (and (&lt;= low n) (&lt;= n high)))

;; Q03
(defun fact (n)
  (if (zerop n)
      1
    (* n (fact (1- n)))))

(defun fact-tail (n acc)
  (if (zerop n)
      acc
    (fact-tail (1- n) (* acc n))))

;; Q04
(defun fibo (n)
  (if (&lt; n 2)
      n
    (+ (fibo (1- n)) (fibo (- n 2)))))

(defun fibo-tail (n a b)
  (if (zerop n)
      a
    (fibo-tail (1- n) b (+ a b))))

;; Q05
(defun power (x n)
  (if (zerop n)
      1
    (* x (power x (1- n)))))

(defun power-tail (x n acc)
  (if (zerop n)
      acc
    (power-tail x (1- n) (* acc x))))

(defun power-fast (x n)
  (cond ((zerop n) 1)
        ((= n 1) x)
        (t (let ((z (power-fast x (div n 2))))
             (if (oddp n)
                 (* x z z)
               (* z z))))))

;; Q06
(defun first  (xs) (car xs))
(defun second (xs) (car (cdr xs)))
(defun third  (xs) (car (cdr (cdr xs))))
(defun fourth (xs) (car (cdr (cdr (cdr xs)))))
(defun fifth  (xs) (car (cdr (cdr (cdr (cdr xs))))))

;; Q07
(defun nthcdr (n xs)
  (if (zerop n)
      xs
    (nthcdr (1- n) (cdr xs))))

;; Q08
(defun nth (n xs) (car (nthcdr n xs)))

;; Q09
(defun my-length (xs)
  (if (null xs)
      0
    (1+ (my-length (cdr xs)))))

(defun my-length-tail (xs n)
  (if (null xs)
      n
    (my-length-tail (cdr xs) (1+ n))))

;; Q10
(defun my-append (xs ys)
  (if (null xs)
      ys
    (cons (car xs) (my-append (cdr xs) ys))))

;; Q11
(defun my-reverse (xs)
  (if (null xs)
      nil
    (append (my-reverse (cdr xs)) (list (car xs)))))

(defun my-reverse-tail (xs ys)
  (if (null xs)
      ys
    (my-reverse-tail (cdr xs) (cons (car xs) ys))))


;; Q12
(defun butlast (xs n)
  (nreverse (nthcdr n (reverse xs))))


;; Q13
(defun my-member (x xs)
  (if (or (null xs) (eql x (car xs)))
      xs
    (my-member x (cdr xs))))

;; Q14
(defun insert-at (n x xs)
  (if (or (null xs) (= n 0))
      (cons x xs)
    (cons (car xs) (insert-at (- n 1) x (cdr xs)))))

;; Q15
(defun remove-at (n xs)
  (cond ((null xs) nil)
        ((= n 0) (cdr xs))
        (t (cons (car xs) (remove-at (- n 1) (cdr xs))))))

;; Q16
(defun make-list (n x)
  (if (zerop n)
      nil
    (cons x (make-list (1- n) x))))

(defun make-list-tail (n x ys)
  (if (zerop n)
      ys
    (make-list-tail (1- n) x (cons x ys))))

(defun copy-list (xs)
  (if (null xs)
      nil
    (cons (car xs) (copy-list (cdr xs)))))

(defun copy-list-tail (xs ys)
  (if (null xs)
      (nreverse ys)
    (copy-list-tail (cdr xs) (cons (car xs) ys))))

;; Q17
(defun sum (xs)
  (if (null xs)
      0
    (+ (car xs) (sum (cdr xs)))))

(defun sum-tail (xs acc)
  (if (null xs)
      acc
    (sum-tail (cdr xs) (+ (car xs) acc))))

(defun product (xs)
  (if (null xs)
      1
    (* (car xs) (product (cdr xs)))))

(defun product-tail (xs acc)
  (if (null xs)
      acc
    (product-tail (cdr xs) (* (car xs) acc))))

;; Q18
(defun maximum-tail (xs m)
  (if (null xs)
      m
    (maximum-tail (cdr xs) (if (&lt; m (car xs)) (car xs) m))))

(defun maximum (xs)
  (if (null (cdr xs))
      (car xs)
    (maximum-tail (cdr xs) (car xs))))

(defun minimum-tail (xs m)
  (if (null xs)
      m
    (minimum-tail (cdr xs) (if (&lt; (car xs) m) (car xs) m))))

(defun minimum (xs)
  (if (null (cdr xs))
      (car xs)
    (minimum-tail (cdr xs) (car xs))))

;; Q19
(defun acons (x y alist)
  (cons (cons x y) alist))

(defun pairlis (keys data alist)
  (if (or (null keys) (null data))
      alist
    (acons (car keys) (car data) (pairlis (cdr keys) (cdr data) alist))))

(defun my-assoc (key alist)
  (cond ((null alist) nil)
        ((eql (car (car alist)) key) (car alist))
        (t (my-assoc key (cdr alist)))))

;; Q20
(defun insert-element (x xs)
  (if (or (null xs) (&lt;= x (car xs)))
      (cons x xs)
    (cons (car xs)
          (insert-element x (cdr xs)))))

(defun insert-sort (xs)
  (if (null xs)
      nil
    (insert-element (car xs) (insert-sort (cdr xs)))))

;; Q21
(defun count-leaf (xs)
  (cond ((null xs) 0)
        ((consp xs)
         (+ (count-leaf (car xs))
            (count-leaf (cdr xs))))
        (t 1)))

;; Q22
(defun member-tree (x xs)
  (cond ((eql x xs) t)
        ((consp xs)
         (or (member-tree x (car xs))
             (member-tree x (cdr xs))))
        (t nil)))

;; Q23
(defun substitute (old new xs)
  (cond ((null xs) nil)
        ((eql (car xs) old)
         (cons new (substitute old new (cdr xs))))
        (t (cons (car xs) (substitute old new (cdr xs))))))

;; Q24
(defun subst (old new xs)
  (cond ((eql old xs) new)
        ((consp xs)
         (cons (subst old new (car xs))
               (subst old new (cdr xs))))
        (t xs)))

;; Q25
(defun flatten (xs)
  (cond ((null xs) nil)
        ((consp xs)
         (append (flatten (car xs))
                 (flatten (cdr xs))))
        (t (list xs))))

;; Q26
(defun map (func xs)
  (if (null xs)
      nil
    (cons (funcall func (car xs)) (map func (cdr xs)))))

(defun flat-map (func xs)
  (apply #'append (map func xs)))

(defun filter (pred xs)
  (cond ((null xs) nil)
        ((funcall pred (car xs))
         (cons (car xs) (filter pred (cdr xs))))
        (t (filter pred (cdr xs)))))

(defun fold-left (func a xs)
  (if (null xs)
      a
    (fold-left func (funcall func a (car xs)) (cdr xs))))

(defun fold-right (func a xs)
  (if (null xs)
      a
    (funcall func (car xs) (fold-right func a (cdr xs)))))

(defun for-each (func xs)
  (cond ((not (null xs))
         (funcall func (car xs))
         (for-each func (cdr xs)))))

;; Q27 (線形探索)
(defun find-if (pred xs)
  (cond ((null xs) nil)
        ((funcall pred (car xs)) (car xs))
        (t (find-if pred (cdr xs)))))

(defun position-if (pred xs)
  (block exit
    (for ((i 0 (1+ i))
          (ys xs (cdr ys)))
         ((null ys) -1)
         (if (funcall pred (car xs))
             (return-from exit i)))))

(defun count-if (pred xs)
  (fold-left (lambda (a x) (if (pred x) (1+ a) a)) 0 xs))

;; Q28
(defun take-while (pred xs)
  (if (or (null xs) (not (funcall pred (car xs))))
      nil
    (cons (car xs) (take-while pred (cdr xs)))))

(defun drop-while (pred xs)
  (if (or (null xs) (not (funcall pred (car xs))))
      xs
    (drop-while pred (cdr xs))))

;; Q29
(defun pack (xs)
  (if (null xs)
      nil
    (cons (take-while (lambda (x) (eql (car xs) x)) xs)
          (pack (drop-while (lambda (x) (eql (car xs) x)) xs)))))

;; Q30
(defun rle (xs)
  (map (lambda (ys) (cons (car ys) (length ys))) (pack xs)))

(defun rld (xs)
  (flat-map (lambda (code) (make-list (cdr code) (car code))) xs))

;; Q31
(defun last (xs)
  (if (or (null xs) (null (cdr xs)))
      xs
    (last (cdr xs))))

;; Q32
(defun my-nconc (xs ys)
  (set-cdr ys (last xs))
  xs)

;; Q33
(defun set-nth (n x xs)
  (set-car x (nthcdr n xs))
  xs)

;; Q34
(defun my-nreverse (xs)
  (for ((ys xs) (rs nil))
       ((null ys) rs)
       (let ((zs (cdr ys)))
         (set-cdr rs ys)
         (setq rs ys)
         (setq ys zs))))

;; Q35
(defun revappend (xs ys)
  (if (null xs)
      ys
    (revappend (cdr xs) (cons (car xs) ys))))

(defun nrevappend (xs ys)
  (for ((ys1 xs) (rs ys))
       ((null ys1) rs)
       (let ((zs (cdr ys1)))
         (set-cdr rs ys1)
         (setq rs ys1)
         (setq ys1 zs))))

;; Q36
(defun revtake (n xs)
  (for ((m n (1- m))
        (rs nil (cons (car ys) rs))
        (ys xs (cdr ys)))
       ((or (zerop m) (null ys)) rs)))

(defun my-take (n xs)
  (nreverse (revtake n xs)))

;; Q37
(defun append-ok (xs ys)
  (nrevappend (reverse xs) ys))

(defun insert-at-ok (n x xs)
  (nrevappend (revtake n xs) (cons x (nthcdr n xs))))

(defun remove-at-ok (n xs)
  (nrevappend (revtake n xs) (nthcdr (1+ n) xs)))

;; Q38
(defun map-ok (func xs)
  (for ((ys xs (cdr ys))
        (rs nil (cons (funcall func (car ys)) rs)))
       ((null ys) (nreverse rs))))

(defun filter-ok (pred xs)
  (for ((ys xs (cdr ys))
        (rs nil))
       ((null ys) (nreverse rs))
       (if (funcall pred (car ys))
           (setq rs (cons (car ys) rs)))))

(defun fold-right-ok (func a xs)
  (for ((ys (reverse xs) (cdr ys))
        (acc a (funcall func (car ys) acc)))
       ((null ys) acc)))

(defun take-while-ok (pred xs)
  (for ((ys xs (cdr ys))
        (rs nil (cons (car ys) rs)))
       ((or (null ys) (not (funcall pred (car ys))))
        (nreverse rs))))

;; Q39
(defun circular-list (:rest args)
  (set-cdr args (last args))
  args)

(defun print-circular-list (xs)
  (block exit
    (let ((ys xs))
      (while t
        (format (standard-output) "~S " (car ys))
        (setq ys (cdr ys))
        (cond ((eq ys xs)
               (format (standard-output) "~%")
               (return-from exit nil)))))))


;; Q40 (修正 2018/03/21)
(defun circular-listp (xs)
  (if (or (null xs) (null (cdr xs)))
      nil
    (block exit
      (for ((fast (cdr (cdr xs)) (cdr (cdr fast)))
            (slow (cdr xs) (cdr slow)))
           ((or (null fast) (null (cdr fast))) nil)
           (if (eq fast slow) (return-from exit t))))))

;; Q41
(defun tabulate (n func)
  (for ((m (1- n) (1- m))
        (xs nil (cons (funcall func m) xs)))
       ((minusp m) xs)))

(defun iterate (n a func)
  (for ((a0 a (funcall func a0))
        (m n (1- m))
        (xs nil (cons a0 xs)))
       ((zerop m) (nreverse xs))))

;; Q42
(defun iota (n s) (iterate n s #'1+))

(defun facts (n) (tabulate n #'fact))

(defun fibos (n)
  (mapcar #'car
          (iterate n
                   '(0 1)
                   (lambda (xs)
                     (list (second xs) (+ (first xs) (second xs)))))))

;; Q43
(defun select (xs)
  (if (null (cdr xs))
      (list (list (car xs) nil))
    (cons (list (car xs) (cdr xs))
          (mapcar (lambda (ys) (list (first ys) (cons (car xs) (second ys))))
                  (select (cdr xs))))))

;; Q44
(defun interleave (x xs)
  (if (null xs)
      (list (list x))
    (append (list (cons x xs))
            (mapcar (lambda (ys) (cons (car xs) ys))
                    (interleave x (cdr xs))))))

;; Q45
(defun permutations (xs)
  (if (null xs)
      (list nil)
    (flat-map (lambda (ys) (interleave (car xs) ys))
             (permutations (cdr xs)))))

;; Q46
(defun combinations (n xs)
  (cond ((zerop n) (list nil))
        ((null xs) nil)
        (t (append (mapcar (lambda (ys) (cons (car xs) ys))
                           (combinations (1- n) (cdr xs)))
                   (combinations n (cdr xs))))))

;; Q47
(defun merge-list (xs ys)
  (let ((zs nil))
    (while (and xs ys)
      (cond ((&lt;= (car xs) (car ys))
             (setq zs (cons (car xs) zs))
             (setq xs (cdr xs)))
            (t
             (setq zs (cons (car ys) zs))
             (setq ys (cdr ys)))))
    (nrevappend zs (if (null xs) ys xs))))

;; Q48
(defun merge-sort (xs n)
  (if (= n 1)
      (list (car xs))
    (let ((m (div n 2)))
      (merge-list (merge-sort xs m)
                  (merge-sort (nthcdr m xs) (- n m))))))

;; Q49
(defun map-tree (func xs)
  (cond ((null xs) nil)
        ((consp xs)
         (cons (map-tree func (car xs))
               (map-tree func (cdr xs))))
        (t (funcall func xs))))

(defun fold-tree (func a xs)
  (cond ((null xs) a)
        ((consp xs)
         (fold-tree func (fold-tree func a (cdr xs)) (car xs)))
        (t (funcall func xs a))))

(defun for-each-tree (func xs)
  (cond ((null xs) nil)
        ((consp xs)
         (for-each-tree func (car xs))
         (for-each-tree func (cdr xs)))
        (t (funcall func xs))))

;; Q50
(defun my-maplist (func xs)
  (if (null xs)
      nil
    (cons (funcall func xs) (my-maplist func (cdr xs)))))

(defun pair-fold-left (func a xs)
  (if (null xs)
      a
    (pair-fold-left func (funcall func a xs) (cdr xs))))

(defun pair-fold-right (func a xs)
  (if (null xs)
      a
    (funcall func xs (pair-fold-right func a (cdr xs)))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017-2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<hr>
<div class="small">
[ <A href="../index.html">Home</a> | <a href="index.html">Common Lisp</a> | <a href="islisp.html">ISLisp</a> ]
</div>
</body>
</html><!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>