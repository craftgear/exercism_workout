<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門 : 番外編</title>
  <meta name="description" content="Common Lisp, Common Lisp 入門, 番外編">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881768</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>Common Lisp 入門：番外編</h2>
<div class="small">
[ <a href="clispb18.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb31.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Common Lisp で作る micro Scheme コンパイラ (4)</h3>
<p> 今回は micro Scheme コンパイラに「末尾再帰最適化」を実装しましょう。ここでいう末尾再帰最適化は処理速度のことではなく、次に示すような関数呼び出しにおいて、メモリを消費せずに実行できることです。
</p>
<pre>
&gt;&gt;&gt; (define foo (lambda () (foo)))
FOO

&gt;&gt;&gt; (foo)
=&gt; 無限ループになる
</pre>
<p> 末尾再帰最適化が行われる場合、foo を評価すると無限ループになります。
</p>
<p> なお、このプログラムは拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> <a href="../func/abcscm36.html">micro Scheme コンパイラの作成 (4)</a> のプログラムを Common Lisp で書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>

<h4>●末尾呼び出しの最適化</h4>
<p> 末尾再帰の末尾とは最後に行われる処理のことで、一般に末尾で関数を呼び出すことを「末尾呼び出し」といいます。関数を呼び出す場合、そのあとに行う処理のために、必要な情報を保存しておかなければいけません。ところが、末尾呼び出しはそのあと実行する処理がないので、情報を保存しておく必要がありません。このため、末尾再帰は繰り返しに変換することができるのです。
</p>

<p> 簡単な例として、Common Lisp で階乗を計算する関数 fact を作りましょう。
</p>

<pre class="list">
リスト : 末尾再帰を繰り返しに変換する

(defun fact (x a)
  (if (= x 0)
      a
    (fact (- x 1) (* a x))))

(defun facti (x a)
  (tagbody
    loop
    (if (= x 0)
        (return-from facti a))
    (setf a (* a x)
          x (- x 1))
    (go loop)))
</pre>

<p> fact は末尾再帰になっています。これを繰り返しに変換すると facti のようになります。引数 x と a の値を保存する必要が無いので、値を書き換えてから先頭の処理へジャンプします。tagbody はジャンプ命令 go を使うための特殊形式 (シンタックス形式) です。Scheme に tagbody と go はありませんが、末尾再帰は最適化が行われるため効率的に処理することができます。
</p>

<p> micro Scheme の場合、仮想マシン vm は繰り返し loop でプログラムしているので、vm の実行でメモリを消費することはありません。問題は命令 sel と app を実行するときです。たとえば、fact を micro Scheme でコンパイルすると次のようになります。
</p>

<pre class="list">
リスト : 階乗 (末尾再帰)

(define fact
  (lambda (n a)
    (if (= n 0)
        a
      (fact (- n 1) (* a n)))))
</pre>
<pre class="fig">
(CLOSURE
  (
    LD (0 . 0)
    LDC 0
    ARGS 2
    LDG =
    APP
    SEL
      (
        LD (0 . 1)
        JOIN
      )
      (
        LD (0 . 0)
        LDC 1
        ARGS 2
        LDG - 
        APP
        LD (0 . 1)
        LD (0 . 0)
        ARGS 2
        LDG *
        APP
        ARGS 2
        LDG FACT
        APP
        JOIN
      )
    RTN
  )
())
</pre>
<p> SECD 仮想マシンは sel 命令を実行するとき、コードレジスタ C をダンプに保存します。ここでメモリが消費されます。fact の場合、if は末尾呼び出しであり、その後の命令は rtn しかありません。この場合、join を rtn に変更すると、コードレジスタ C をダンプに保存する必要がなりなります。
</p>
<p> そこで、仮想マシンに新しい命令 selr を追加します。selr の状態遷移を図に示します。
</p>
<pre class="item">
(v . s) e (selr ct cf . c) d = v (真) =&gt; s e ct d
                             = v (偽) =&gt; s e cf d
</pre>
<p> sel はコード c をダンプ d に保存します。selr 命令の場合、ct と cf が末尾呼び出しになるので、コード c をダンプに保存する必要はありません。また、ct と cf は join 命令ではなく rtn 命令で終了します。
</p>

<p> selr 命令を使うと、fact は次のようにコンパイルされます。
</p>
<pre class="fig">
(CLOSURE
  (
    LD (0 . 0)
    LDC 0
    ARGS 2
    LDG =
    APP
    SELR
      (
        LD (0 . 1)
        RTN
      )
      (
        LD (0 . 0)
        LDC 1
        ARGS 2
        LDG - 
        APP
        LD (0 . 1)
        LD (0 . 0)
        ARGS 2
        LDG *
        APP
        ARGS 2
        LDG FACT
        APP
        RTN
      )
  )
())
</pre>
<p> ここで fact を呼び出す app 命令に注目してください。fact は末尾呼び出しで、その後に実行する命令は rtn しかありません。この場合、レジスタ S, E, C をダンプレジスタに保存する必要はありません。そこで、新しい命令 tapp を追加します。tapp の状態遷移を示します。
</p>

<pre class="item">
((closure code env) vs . s) e (tapp . c) d =&gt; s (vs . env) code d
</pre>

<p> app は s, e, c をダンプ d に保存します。tapp 命令の場合、実行する関数は末尾呼び出しになるので、s, e, c をダンプに保存する必要はありません。コード code を環境 (v . env) の元で評価するだけです。
</p>

<p> このように、selr と tapp 命令を追加することで、micro Scheme でも末尾呼び出しの最適化を実現することができます。
</p>

<h4>●コンパイラの修正</h4>
<p> それではプログラムを修正しましょう。S 式をコンパイルする関数 comp は次のようになります。
</p>

<pre class="list">
リスト : コンパイルの修正

(defun comp (expr env code tail)
  (cond ((self-evaluation-p expr)
         (list* 'ldc expr code))
        ((symbolp expr)
         (let ((pos (location expr env)))
           (if pos
               ; 局所変数
               (list* 'ld pos code)
             ; 大域変数
             (list* 'ldg expr code))))
        ((eq (car expr) 'quote)
         (list* 'ldc (cadr expr) code))
        ((eq (car expr) 'if)
         (if tail
             ; 末尾呼び出し
             (let ((t-clause (comp (caddr expr) env '(rtn) t))
                   (f-clause
                    (if (null (cdddr expr))
                        (list 'ldc '*undef* 'join)
                      (comp (cadddr expr) env '(rtn) t))))
               (comp (cadr expr) env (list* 'selr t-clause f-clause (cdr code)) nil))
           (let ((t-clause (comp (caddr expr) env '(join) nil))
                 (f-clause
                  (if (null (cdddr expr))
                      (list 'ldc '*undef* 'join)
                    (comp (cadddr expr) env '(join) nil))))
             (comp (cadr expr) env (list* 'sel t-clause f-clause code) nil))))
        ((eq (car expr) 'lambda)
         (let ((body (comp-body (cddr expr) (cons (cadr expr) env) '(rtn))))
           (list* 'ldf body code)))
        ((eq (car expr) 'define)
         (comp (caddr expr) env (list* 'def (cadr expr) code) nil))
        ((eq (car expr) 'define-macro)
         (comp (caddr expr) env (list* 'defm (cadr expr) code) nil))
        ((eq (car expr) 'set!)
         (let ((pos (location (cadr expr) env)))
           (if pos
               ; 局所変数
               (comp (caddr expr) env (list* 'lset pos code) nil)
             ; 大域変数
             (comp (caddr expr) env (list* 'gset (cadr expr) code) nil))))
        ((eq (car expr) 'call/cc)
         (list* 'ldct code 'args 1 (comp (cadr expr) env (cons 'app code) nil)))
        ((eq (car expr) 'apply)
         (complis (cddr expr)
                  env
                  (list* 'args-ap
                         (length (cddr expr))
                         (comp (cadr expr) env (cons 'app code) nil))))
        ((macro-p (car expr))
         ; マクロ展開してからコンパイルする
         (let ((new-expr (vm '()
                             (list (cdr expr))
                             (get-macro-code (car expr))
                             (list (list '() '() '(stop))))))
           (comp new-expr env code nil)))
        (t  ; 関数呼び出し
         (complis (cdr expr)
                  env
                  (list* 'args
                         (length (cdr expr))
                         (comp (car expr) env (cons (if tail 'tapp 'app) code) nil))))))
</pre>
<p> comp の引数に末尾呼び出しを示すフラグ tail を追加します。tail が真の場合、引数 expr は末尾呼び出しです。tail が真になるときは、ラムダ式本体の最後尾の S 式をコンパイルするときと、tail が真のときに if の then 節と else 節をコンパイルするときです。あとはすべて nil になります。
</p>

<p> if をコンパイルするとき、tail が偽の場合は今までと同じです。tail が真の場合、then 節と else 節をコンパイルするとき、tail に t を指定して、最後の命令を rtn にします。生成するコードは (list* 'selr t-clause f-clause (cdr code)) となります。このとき、code の先頭は rtn 命令になります。rtn が重複するので cdr で取り除きます。
</p>

<p> 関数呼び出しの場合、tail が真であれば命令を tapp に、そうでなければ app にします。tail が真の場合、code の先頭は rtn 命令になります。評価する関数がクロージャの場合、この rtn を削除することができますが、primitive の場合は rtn が必要になります。コンパイルの段階では区別がつかないので、rtn は削除しないでそのままにしておきます。
</p>

<p> ラムダ式本体をコンパイルする関数 comp-body は簡単です。
</p>
<pre class="list">
リスト : ラムダ式本体のコンパイル

(defun comp-body (body env code)
  (if (null (cdr body))
      (comp (car body) env code t)
    (comp (car body)
          env
          (list* 'pop
                 (comp-body (cdr body) env code))
          nil)))
</pre>
<p> 本体末尾の S 式をコンパイルするとき、comp の引数 tail を t にセットします。それ以外の場合は nil にセットします。
</p>

<h4>●仮想マシンの修正</h4>
<p> 次は仮想マシン vm を修正します。
</p>
<pre class="list">
リスト : 仮想マシン vm の修正

(defun vm (s e c d)
  (loop
    (case (pop c)
      ...
      ((tapp)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (setq e (cons lvar (cadr clo))
                  c (car clo))))))
      ...
      ((selr)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ...
  )))
</pre>
<p> tapp の場合、primitive と continuation の処理は app と同じです。それ以外の場合はコード (car clo) を環境 (cons lvar (cadr clo)) の元で評価します。s, e, c をダンプ d に保存する必要はありません。selr も簡単です。then 節 (t-clause) と else 節 (e-clause) どちらを評価するにしても、ダンプ d にコード c を保存する必要はありません。
</p>
<h4>●簡単な実行例</h4>
<p> それでは簡単な実行例を示しましょう。なお、簡単にテストできるように、primitive に算術演算子 (+, -, *, /) と比較演算子 (=, &lt;, &gt;, &lt;=, &gt;=) を追加しました。簡単な例として 1 から x までの合計値を求めるプログラムを作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 1 から x までの合計値を求める

(define sum
  (lambda (x)
    (if (= x 0)
        0
      (+ x (sum (- x 1))))))

(define sum1
  (lambda (x a)
    (if (= x 0)
        a
      (sum1 (- x 1) (+ a x)))))
</pre>

<p> 関数 sum は末尾再帰になっていないので、大きな値を計算するとメモリを大量に消費します。関数 sum1 は末尾再帰になっているので、大きな値でもメモリを消費せずに計算することができます。実行結果は次のようになりました。
</p>

<pre>
>>> (sum 1000000)
500000500000

>>> (sum1 1000000 0)
500000500000
</pre>
<p> CLISP ver 2.44, Windows XP で実行した場合、どちらの関数でも値を求めることができますが、sum は sum1 よりも約 65 MB ほどメモリの消費量が多くなります。
</p>

<p> また、次の関数を実行するとメモリを消費せずに無限ループとなります。
</p>
<pre>
&gt;&gt;&gt; (define foo (lambda () (foo)))
FOO

&gt;&gt;&gt; (foo)
=&gt; 無限ループになる
</pre>
<h4>●たらいまわし関数</h4>
<p> 次は「たらいまわし関数」でインタプリタとコンパイラの実行速度を計測してみましょう。プログラムリストと実行結果を示します。
</p>
<pre class="list">
リスト : たらいまわし関数

(define tarai
  (lambda (x y z)
    (if (&lt;= x y)
        y
      (tarai (tarai (- x 1) y z) (tarai (- y 1) z x) (tarai (- z 1) x y)))))

(define tak
  (lambda (x y z)
    (if (&lt;= x y)
        z
      (tak (tak (- x 1) y z) (tak (- y 1) z x) (tak (- z 1) x y)))))
</pre>
<pre>
  表 : たらいまわし関数の実行結果

                 :  A   :  B
  ---------------+------+------
  (tarai 10 5 0) : 7.33 : 6.32
  (tak   14 7 0) : 8.50 : 7.22

  A : インタプリタ (micro.l)
  B : コンパイラ   (secd.l)

  単位 : 秒

  CLISP ver 2.44, Windows XP, celeron 1.40 GHz


                 :  A   :  B
  ---------------+------+------
  (tarai 10 5 0) : 1.47 : 0.98
  (tak   14 7 0) : 1.65 : 1.11

  A : インタプリタ (micro.l)
  B : コンパイラ   (secd.l)

  単位 : 秒

  SBCL ver 1.0.29, Windows XP, celeron 1.40 GHz
</pre>

<p> CLISP は約 1.2 倍、SBCL は約 1.5 倍、インタプリタ (micro.l) よりもコンパイラ (secd.l) の方が速くなりました。予想していたよりもインタプリタの実行速度が速かったのには驚きました。CLISP と SBCL はとても優秀ですね。インタプリタとコンパイラで実行速度にあまり差がつきませんでしたが、マクロを多用したプログラムでは、もっと差がつくでしょう。
</p>
<p> コンパイラの性能ですが、末尾呼び出し以外の最適化はほとんど行っていないので、改良する余地はまだまだあると思います。興味のある方はいろいろ試してみてください。
</p>

<h4>●遅延評価</h4>
<p> 関数 tarai は「遅延評価 (delayed evaluation または lazy evaluation) 」を行う処理系、たとえば関数型言語の Haskell では高速に実行することができます。また、Scheme でも delay と force を使って遅延評価を行うことができます。
</p>

<p> tarai のプログラムを見てください。x &lt;= y のときに y を返しますが、このとき引数 z の値は必要ありませんね。引数 z の値は x &gt; y のときに計算するようにすれば、無駄な計算を省略することができます。なお、関数 tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意ください。
</p>

<p> Scheme の delay と force は、micro Scheme でもマクロを使って簡単に実装することができます。次のリストを見てください。
</p>

<pre class="list">
リスト : delay と force

(define-macro delay 
  (lambda (expr)
    `(make-promise (lambda () ,expr))))

(define make-promise
  (lambda (f)
    (let ((flag false) (result false))
      (lambda ()
        (if (not flag)
            (let ((x (f)))
              (if (not flag)
                  (begin (set! flag true)
                         (set! result x)))))
        result))))

(define force 
  (lambda (promise) (promise)))
</pre>

<p> リストの delay と force は <a href="clispb19.html#cite">参考文献 [1]</a> に掲載されているプログラムを micro Scheme で書き直したものです。delay の引数 expr をクロージャに格納して関数 make-promis に渡します。make-promise はクロージャを生成して返します。このデータを Scheme では「プロミス」といいます。force は簡単で、引数 promise を評価するだけです。
</p>
<p> make-promise はクロージャを生成し、その中にクロージャ f の評価結果を格納します。flag が false の場合は f を評価していないので、f を評価して返り値を result にセットし、flag の値を true に書き換えます。flag が true ならば f は評価済みなので result を返します。
</p>

<p> 簡単な使用例を示しましょう。
</p>
<pre>
&gt;&gt;&gt; (define a (delay (+ 10 20)))
A

&gt;&gt;&gt; (force a)
30
</pre>
<p> (delay (+ 10 20)) の返り値を変数 a にセットします。このとき、S 式 (+ 10 20) は評価されていません。プロミスの値を実際に求める関数が force です。(force a) を評価すると、S 式 (+ 10 20) を評価して値 30 を返します。
</p>
<p> また、プロミスは式の評価結果をキャッシュします。したがって、(force a) を再度実行すると、同じ式を再評価することなく値を求めることができます。次の例を見てください。
</p>
<pre>
&gt;&gt;&gt; (define b (delay (begin (display "oops! ") (+ 10 20))))
B

&gt;&gt;&gt; (force b)
oops! 30

&gt;&gt;&gt; (force b)
30
</pre>
<p> 最初に (force b) を実行すると、S 式 (begin (display "oops! ") (+ 10 20)) が評価されるので、画面に oops! が表示されます。次に、(force b) を実行すると、式を評価せずにキャッシュした値を返すので oops! は表示されません。
</p>

<p> delay と force を使うと、tarai は次のようになります。
</p>

<pre class="list">
リスト : delay と force による遅延評価

(define tarai
  (lambda (x y z)
    (if (&lt;= x y)
        y
      (let ((zz (force z)))
        (tarai (tarai (- x 1) y (delay zz))
               (tarai (- y 1) zz (delay x))
               (delay (tarai (- zz 1) x (delay y))))))))
</pre>

<p> 関数 tarai の引数 z にデータを渡すとき、delay で遅延オブジェクトを生成します。そして、その値を取り出すときは (force z) とします。これで遅延評価を行うことができます。
</p>

<p> それでは、実際に実行してみましょう。
</p>
<pre>
  表 : たらいまわし関数の実行結果

  (tarai 80 40 (delay 0))

        |  A   |   B
  ------+------+-------
  CLISP : 2.52 | 0.313
  SBCL  : 0.77 | 0.078

  A : インタプリタ (micro.l)
  B : コンパイラ   (secd.l)

  単位 : 秒

  CLISP ver 2.44
  SBCL ver 1.0.29
  Windows XP, celeron 1.40 GHz
</pre>
<p> tarai に大きな値を与えても、高速に実行することができます。遅延評価の効果は十分に出ていると思います。また、インタプリタよりもコンパイラのほうが約 8 倍から 10 倍高速になりました。マクロを使ったプログラムは、コンパイラのほうが高速に実行できることがわかります。
</p>

<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li>R. Kent Dybvig (著), 村上雅章 (訳), 『プログラミング言語 SCHEME』, 株式会社ピアソン・エデュケーション, 2000
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; secd.l : SECD 仮想マシンによる Scheme コンパイラ
;
;          (1) 基本機能の実装
;          (2) 伝統的なマクロの実装
;          (3) 継続の実装
;          (4) 末尾再帰最適化
;
;          Copyright (C) 2009 Makoto Hiroi
;

; 大域変数
(defvar *global-environment* nil)

; 変数の位置を求める
(defun position-var (sym ls)
  (labels ((iter (i ls)
             (cond ((null ls) nil)
                   ((symbolp ls)
                    (if (eq sym ls) (- (1+ i)) nil))
                   ((eq sym (car ls)) i)
                   (t (iter (1+ i) (cdr ls))))))
    (iter 0 ls)))

; フレームと変数の位置を求める
(defun location (sym ls)
  (labels ((iter (i ls)
             (if (null ls)
                 nil
               (let ((j (position-var sym (car ls))))
                 (if j
                     (cons i j)
                   (iter (1+ i) (cdr ls)))))))
    (iter 0 ls)))

; 自己評価フォームか
(defun self-evaluation-p (expr)
  (and (atom expr) (not (symbolp expr))))

; マクロか
(defun macro-p (expr)
  (let ((val (assoc expr *global-environment*)))
    (and val (consp (cdr val)) (eq 'macro (cadr val)))))

; マクロのコードを取り出す
(defun get-macro-code (expr)
  (caddr (get-gvar expr)))

; S 式をコンパイルする
(defun compile-expr (expr)
  (comp expr '() '(stop) nil))

; コンパイル本体
(defun comp (expr env code tail)
  (cond ((self-evaluation-p expr)
         (list* 'ldc expr code))
        ((symbolp expr)
         (let ((pos (location expr env)))
           (if pos
               ; 局所変数
               (list* 'ld pos code)
             ; 大域変数
             (list* 'ldg expr code))))
        ((eq (car expr) 'quote)
         (list* 'ldc (cadr expr) code))
        ((eq (car expr) 'if)
         (if tail
             ; 末尾呼び出し
             (let ((t-clause (comp (caddr expr) env '(rtn) t))
                   (f-clause
                    (if (null (cdddr expr))
                        (list 'ldc '*undef* 'join)
                      (comp (cadddr expr) env '(rtn) t))))
               (comp (cadr expr) env (list* 'selr t-clause f-clause (cdr code)) nil))
           (let ((t-clause (comp (caddr expr) env '(join) nil))
                 (f-clause
                  (if (null (cdddr expr))
                      (list 'ldc '*undef* 'join)
                    (comp (cadddr expr) env '(join) nil))))
             (comp (cadr expr) env (list* 'sel t-clause f-clause code) nil))))
        ((eq (car expr) 'lambda)
         (let ((body (comp-body (cddr expr) (cons (cadr expr) env) '(rtn))))
           (list* 'ldf body code)))
        ((eq (car expr) 'define)
         (comp (caddr expr) env (list* 'def (cadr expr) code) nil))
        ((eq (car expr) 'define-macro)
         (comp (caddr expr) env (list* 'defm (cadr expr) code) nil))
        ((eq (car expr) 'set!)
         (let ((pos (location (cadr expr) env)))
           (if pos
               ; 局所変数
               (comp (caddr expr) env (list* 'lset pos code) nil)
             ; 大域変数
             (comp (caddr expr) env (list* 'gset (cadr expr) code) nil))))
        ((eq (car expr) 'call/cc)
         (list* 'ldct code 'args 1 (comp (cadr expr) env (cons 'app code) nil)))
        ((eq (car expr) 'apply)
         (complis (cddr expr)
                  env
                  (list* 'args-ap
                         (length (cddr expr))
                         (comp (cadr expr) env (cons 'app code) nil))))
        ((macro-p (car expr))
         ; マクロ展開してからコンパイルする
         (let ((new-expr (vm '()
                             (list (cdr expr))
                             (get-macro-code (car expr))
                             (list (list '() '() '(stop))))))
           (comp new-expr env code nil)))
        (t  ; 関数呼び出し
         (complis (cdr expr)
                  env
                  (list* 'args
                         (length (cdr expr))
                         (comp (car expr) env (cons (if tail 'tapp 'app) code) nil))))))

; body のコンパイル
(defun comp-body (body env code)
  (if (null (cdr body))
      (comp (car body) env code t)
    (comp (car body)
          env
          (list* 'pop
                 (comp-body (cdr body) env code))
          nil)))

; 引数を評価するコードを生成する
(defun complis (expr env code)
  (if (null expr)
      code
    (comp (car expr) env (complis (cdr expr) env code) nil)))

;;; 仮想マシン

; 局所変数の値を求める
(defun get-lvar (e i j)
  (if (&lt;= 0 j)
      (nth j (nth i e))
    (nthcdr (- (1+ j)) (nth i e))))

; 局所変数の値を更新する
(defun set-lvar (e i j val)
  (if (&lt;= 0 j)
      (setf (nth j (nth i e)) val)
    (if (= j -1)
        (rplaca (nthcdr i e) val)
      (rplacd (nthcdr (- (+ j 2)) (nth i e)) val))))

; 大域変数の値を求める
(defun get-gvar (sym)
  (let ((val (assoc sym *global-environment*)))
    (if val
        (cdr val)
      (error "unbound variable: ~S" sym))))

; 大域変数の値を書き換える
(defun set-gvar (sym val)
  (let ((cell (assoc sym *global-environment*)))
    (if cell
        (rplacd cell val)
      (error "unbound variable: " sym))))

; 仮想マシンでコードを実行する
(defun vm (s e c d)
  (loop
    (case (pop c)
      ((ld)
       (let ((pos (pop c)))
         (push (get-lvar e (car pos) (cdr pos)) s)))
      ((ldc)
       (push (pop c) s))
      ((ldg)
       (push (get-gvar (pop c)) s))
      ((ldf)
       (push (list 'closure (pop c) e) s))
      ((ldct)
       (push (list 'continuation s e (pop c) d) s))
      ((lset)
       (let ((pos (pop c)))
         (set-lvar e (car pos) (cdr pos) (car s))))
      ((gset)
       (set-gvar (pop c) (car s)))
      ((app)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (push (list s e c) d)
            (setq s nil
                  e (cons lvar (cadr clo))
                  c (car clo))))))
      ((tapp)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (setq e (cons lvar (cadr clo))
                  c (car clo))))))
      ((rtn)
       (let ((save (pop d)))
         (setq s (cons (car s) (car save))
               e (cadr save)
               c (caddr save))))
      ((sel)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (push c d)
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ((selr)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ((join)
       (setq c (pop d)))
      ((pop) (pop s))
      ((args)
       (let ((a nil))
         (dotimes (n (pop c) (push a s))
           (push (pop s) a))))
      ((args-ap)
       (let ((a (copy-list (pop s))))
         (dotimes (n (1- (pop c)) (push a s))
           (push (pop s) a))))
      ((def)
       (let ((sym (pop c)))
         (push (cons sym (pop s)) *global-environment*)
         (push sym s)))
      ((defm)
       (let ((sym (pop c)))
         (push (cons sym (cons 'macro (pop s))) *global-environment*)
         (push sym s)))
      ((stop) (return (car s)))
      (t (error "unknown opcode")))))

; 大域変数
(setq *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'eqv?  'primitive #'(lambda (x y) (if (eql x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'display 'primitive #'(lambda (x) (princ x) '*undef*))
       (list 'newline 'primitive #'(lambda () (terpri) '*undef*))
       (list '+     'primitive #'+)
       (list '-     'primitive #'-)
       (list '*     'primitive #'*)
       (list '/     'primitive #'/)
       (list '=     'primitive #'(lambda (&amp;rest x) (if (apply #'= x) 'true 'false)))
       (list '&lt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&lt; x) 'true 'false)))
       (list '&gt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&gt; x) 'true 'false)))
       (list '&lt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&lt;= x) 'true 'false)))
       (list '&gt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&gt;= x) 'true 'false)))
       ))

;;; read-eval-print-loop

(defun change-readtable ()
  (set-macro-character
   #\`
   #'(lambda (stream char)
       (declare (ignore char))
       (list 'backquote (read stream t nil t))))
  (set-macro-character
   #\,
   #'(lambda (stream char)
       (declare (ignore char))
       (cond ((char= (peek-char nil stream) #\@)
              (read-char stream)
              (list 'splice (read stream t nil t)))
             (t (list 'unquote (read stream t nil t)))))))

(defun repl (&amp;rest file-list)
  (unwind-protect
      (progn
        (change-readtable)
        (dolist (file file-list)
          (with-open-file (in file :direction :input)
            (do ((output t))
                ((eq output nil) (terpri))
              (setf output (vm '() '() (compile-expr (read in nil)) '()))
              (print output))))
        (do ((output nil))
            ((eq output 'quit))
          (princ "&gt;&gt;&gt; ")
          (force-output)
          (let ((expr (compile-expr (read))))
            (setf output (vm '() '() expr '()))
            (princ output)
            (terpri))))
    (setq *readtable* (copy-readtable nil))))
</pre>
</section>
<hr>
<section class="contents">
<h4 id="appendix">●Appendix: ldg, gset 命令の改良 (2012/03/04)</h4>
<p> sasagawa さんの <a href="http://practical-scheme.net/wiliki/wiliki.cgi?sasagawa%3aPoly">SECDマシン　Schemeコンパイラ　Simpleの開発記録</a> に触発されて、M.Hiroi も micro Scheme コンパイラの改良に挑戦してみました。プログラムと開発記録を公開されている sasagawa さんに感謝いたします。
</p>

<p> なお、このプログラムは拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> <a href="../func/abcscm36.html#appendix">micro Scheme コンパイラの作成 (4) : Appendix</a> のプログラムを Common Lisp で書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>

<p> 今まで作成した micro Scheme コンパイラは、命令 ldg, gset で大域変数にアクセスするとき、大域変数の環境 *global-environment* を関数 assoc で線形探索していました。sasagawa さんがご指摘されているように、プログラムの実行時に探索を行うと、実行時間はどうしても遅くなります。コンパイル時に大域変数の配置を決めておくと、実行時間はもう少し速くなると思われます。
</p>

<p> micro Scheme コンパイラで一番簡単な修正方法は、コンパイル時に変数 sym を環境 *global-environment* から探索し、見つけた場合は sym ではなくセル (sym . value) を ldg, gset 命令に渡すようにコンパイルすることです。そうすると、ldg はセルの CDR 部の値 value をスタックに積むだけ、gset はセルの CDR 部をスタックトップの値に書き換えるだけで実現できます。
</p>

<p> 変数 sym が見つからない場合、セル (sym . *undef*) を生成して環境に追加することにします。*undef* は未束縛の変数であることを表すシンボルとして使います。これで define, define-macro を処理する命令 def, defm に対応することができます。*undef* のチェックは ldg, gset 命令で行えばいいでしょう。もちろん、コンパイル時にエラーチェックしてもかまいませんが、今回は簡単な方法を選びました。
</p>

<h4>●コンパイラの修正</h4>
<p> それではプログラムを修正しましょう。最初に、環境から大域変数を格納したセルを求める関数 location-gvar を作ります。
</p>

<pre class="list">
リスト :  大域変数の配置を求める

; 大域変数の配置を求める
(defun location-gvar (expr)
  (let ((cell (assoc expr *global-environment*)))
    (unless cell
      (setq cell (cons expr '*undef*))
      (push cell *global-environment*))
    cell))

; 大域変数の値を求める
(defun get-gvar (expr)
  (cdr (location-gvar expr)))
</pre>
<p> location-gvar は環境 *global-environment* から引数 expr を assoc で探索します。見つからない場合、(cons expr '*undef*) で expr 用のセルを生成し、それを環境に追加します。最後にそのセル cell を返します。関数 get-gvar は大域変数 expr の値を返します。location-gvar でセルを求め、その CDR 部の値を返します。
</p>

<p> 次はコンパイル処理を修正します。次のリストを見てください。
</p>
<pre class="list">
リスト : コンパイラの修正

  ・・・・・

        ((symbolp expr)
         (let ((pos (location expr env)))
           (if pos
               ; 局所変数
               (list* 'ld pos code)
             ; 大域変数
	     (list* 'ldg (location-gvar expr) code))))

  ・・・・・

        ((eq (car expr) 'define)
	 (comp (caddr expr) env (list* 'def (location-gvar (cadr expr)) code) nil))
        ((eq (car expr) 'define-macro)
	 (comp (caddr expr) env (list* 'defm (location-gvar (cadr expr)) code) nil))
        ((eq (car expr) 'set!)
         (let ((pos (location (cadr expr) env)))
           (if pos
               ; 局所変数
               (comp (caddr expr) env (list* 'lset pos code) nil)
             ; 大域変数
	     (comp (caddr expr) env (list* 'gset (location-gvar (cadr expr)) code) nil))))

  ・・・・・

</pre>
<p> 変数のアクセスで、大域変数の場合は location-gvar で大域変数のセルを求めて ldg のあとにセットします。set! も同様にコンパイルします。define, define-macro も修正が必要で、def, defm 命令のあとに location-gvar の返り値をセットします。
</p>
<h4>●仮想マシンの修正</h4>
<p> 次は仮想マシン vm を修正します。次のリストを見てください。
</p>
<pre class="list">
リスト : 仮想マシンの修正

  ・・・・・

      ((ldg)
       (let ((cell (pop c)))
	 (if (eq (cdr cell) '*undef*)
	     (error "unbound variable: ~S~%" (car cell))
	   (push (cdr cell) s))))

  ・・・・・

      ((gset)
       (let ((cell (pop c)))
	 (if (eq (cdr cell) '*undef*)
	     (error "unbound variable: ~S~%" (car cell))
	   (setf (cdr cell) (car s)))))

  ・・・・・

      ((def)
       (let ((cell (pop c)))
	 (setf (cdr cell) (pop s))
	 (push (car cell) s)))
      ((defm)
       (let ((cell (pop c)))
	 (setf (cdr cell) (cons 'macro (pop s)))
	 (push (car cell) s)))

  ・・・・・

</pre>
<p> ldg の場合、c の先頭から大域変数のセルを取り出して変数 cell にセットします。(cdr cell) で変数の値を求め、それが *undef* ならばエラーを送出します。そうでなければ (cdr cell) をスタックに積むだけです。gset の場合も大域変数のセルを変数 cell にセットし、その CDR 部を setf でスタックトップの値 (car s) に書き換えるだけです。def と defm は gset と同様に大域変数のセル (cell) の CDR 部を setf で書き換えて、変数名 (car cell) をスタックに積むだけです。
</p>
<p> 修正はこれだけです。プログラムの詳細は <a href="clispb19.html#list2">プログラムリスト２</a> をお読みください。
</p>
<h4>●実行結果</h4>
<p> それでは SBCL (ver 1.0.37) で実行してみましょう。1 から n までの和を求める関数 sum1 (末尾再帰版) とたらいまわし関数で試してみました。
</p>
<pre>
            表 : 実行結果

                    |   A   |   B
  ------------------+-------+--------
  (sum1  500000 0)  |  1.84 |  1.00
  (sum1  1000000 0) |  3.67 |  1.99
  (tarai 10 5 0)    |  0.99 |  0.64 
  (tarai 12 6 0)    | 36.27 | 22.50
  (tak   14 7 0)    |  1.11 |  0.72
  (tak   16 8 0)    |  7.11 |  4.39 

  A : 改良前
  B : 改良後

  単位 : 秒

実行環境 : Windows XP, celeron 1.40 GHz, SBCL 1.0.37
</pre>
<p> 大域変数のアクセス方法を改良することで、実行時間は sum1 で約 46 %, たらいまわし関数で約 35 - 38 % ほど速くなりました。簡単な方法ですが、関数を呼び出すときに ldg 命令を使っているので、SBCL の場合その効果はとても大きいようです。
</p>
<p> なお、今回の修正方法がベストというわけではありません。たとえば、他の言語で実装する場合、シンボルを表すデータ構造を作り、その中に大域変数の値を格納する領域を用意します。そうすると、ldg, gset, def, defm 命令にはシンボルを渡すだけで、大域変数の値にアクセスすることができます。いろいろな方法を考えて試してみるのも面白いと思います。
</p>

<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
;
; secd.l : SECD 仮想マシンによる Scheme コンパイラ
;
;          (1) 基本機能の実装
;          (2) 伝統的なマクロの実装
;          (3) 継続の実装
;          (4) 末尾再帰最適化
;          (5) ldg, gset 命令の改良
;
;          Copyright (C) 2009-2012 Makoto Hiroi
;

; 大域変数
(defvar *global-environment* nil)

; 変数の位置を求める
(defun position-var (sym ls)
  (labels ((iter (i ls)
             (cond ((null ls) nil)
                   ((symbolp ls)
                    (if (eq sym ls) (- (1+ i)) nil))
                   ((eq sym (car ls)) i)
                   (t (iter (1+ i) (cdr ls))))))
    (iter 0 ls)))

; フレームと変数の位置を求める
(defun location (sym ls)
  (labels ((iter (i ls)
             (if (null ls)
                 nil
               (let ((j (position-var sym (car ls))))
                 (if j
                     (cons i j)
                   (iter (1+ i) (cdr ls)))))))
    (iter 0 ls)))

; 大域変数の配置を求める
(defun location-gvar (expr)
  (let ((cell (assoc expr *global-environment*)))
    (unless cell
      (setq cell (cons expr '*undef*))
      (push cell *global-environment*))
    cell))

; 大域変数の値を求める
(defun get-gvar (expr)
  (cdr (location-gvar expr)))

; 自己評価フォームか
(defun self-evaluation-p (expr)
  (and (atom expr) (not (symbolp expr))))

; マクロか
(defun macro-p (expr)
  (let ((val (assoc expr *global-environment*)))
    (and val (consp (cdr val)) (eq 'macro (cadr val)))))

; マクロのコードを取り出す
(defun get-macro-code (expr)
  (caddr (get-gvar expr)))

; S 式をコンパイルする
(defun compile-expr (expr)
  (comp expr '() '(stop) nil))

; コンパイル本体
(defun comp (expr env code tail)
  (cond ((self-evaluation-p expr)
         (list* 'ldc expr code))
        ((symbolp expr)
         (let ((pos (location expr env)))
           (if pos
               ; 局所変数
               (list* 'ld pos code)
             ; 大域変数
	     (list* 'ldg (location-gvar expr) code))))
        ((eq (car expr) 'quote)
         (list* 'ldc (cadr expr) code))
        ((eq (car expr) 'if)
         (if tail
             ; 末尾呼び出し
             (let ((t-clause (comp (caddr expr) env '(rtn) t))
                   (f-clause
                    (if (null (cdddr expr))
                        (list 'ldc '*undef* 'join)
                      (comp (cadddr expr) env '(rtn) t))))
               (comp (cadr expr) env (list* 'selr t-clause f-clause (cdr code)) nil))
           (let ((t-clause (comp (caddr expr) env '(join) nil))
                 (f-clause
                  (if (null (cdddr expr))
                      (list 'ldc '*undef* 'join)
                    (comp (cadddr expr) env '(join) nil))))
             (comp (cadr expr) env (list* 'sel t-clause f-clause code) nil))))
        ((eq (car expr) 'lambda)
         (let ((body (comp-body (cddr expr) (cons (cadr expr) env) '(rtn))))
           (list* 'ldf body code)))
        ((eq (car expr) 'define)
	 (comp (caddr expr) env (list* 'def (location-gvar (cadr expr)) code) nil))
        ((eq (car expr) 'define-macro)
	 (comp (caddr expr) env (list* 'defm (location-gvar (cadr expr)) code) nil))
        ((eq (car expr) 'set!)
         (let ((pos (location (cadr expr) env)))
           (if pos
               ; 局所変数
               (comp (caddr expr) env (list* 'lset pos code) nil)
             ; 大域変数
	     (comp (caddr expr) env (list* 'gset (location-gvar (cadr expr)) code) nil))))
        ((eq (car expr) 'call/cc)
         (list* 'ldct code 'args 1 (comp (cadr expr) env (cons 'app code) nil)))
        ((eq (car expr) 'apply)
         (complis (cddr expr)
                  env
                  (list* 'args-ap
                         (length (cddr expr))
                         (comp (cadr expr) env (cons 'app code) nil))))
        ((macro-p (car expr))
         ; マクロ展開してからコンパイルする
         (let ((new-expr (vm '()
                             (list (cdr expr))
                             (get-macro-code (car expr))
                             (list (list '() '() '(stop))))))
           (comp new-expr env code nil)))
        (t  ; 関数呼び出し
         (complis (cdr expr)
                  env
                  (list* 'args
                         (length (cdr expr))
                         (comp (car expr) env (cons (if tail 'tapp 'app) code) nil))))))

; body のコンパイル
(defun comp-body (body env code)
  (if (null (cdr body))
      (comp (car body) env code t)
    (comp (car body)
          env
          (list* 'pop
                 (comp-body (cdr body) env code))
          nil)))

; 引数を評価するコードを生成する
(defun complis (expr env code)
  (if (null expr)
      code
    (comp (car expr) env (complis (cdr expr) env code) nil)))

;;; 仮想マシン

; 局所変数の値を求める
(defun get-lvar (e i j)
  (if (&lt;= 0 j)
      (nth j (nth i e))
    (nthcdr (- (1+ j)) (nth i e))))

; 局所変数の値を更新する
(defun set-lvar (e i j val)
  (if (&lt;= 0 j)
      (setf (nth j (nth i e)) val)
    (if (= j -1)
        (rplaca (nthcdr i e) val)
      (rplacd (nthcdr (- (+ j 2)) (nth i e)) val))))

; 仮想マシンでコードを実行する
(defun vm (s e c d)
  (loop
    (case (pop c)
      ((ld)
       (let ((pos (pop c)))
         (push (get-lvar e (car pos) (cdr pos)) s)))
      ((ldc)
       (push (pop c) s))
      ((ldg)
       (let ((cell (pop c)))
	 (if (eq (cdr cell) '*undef*)
	     (error "unbound variable: ~S~%" (car cell))
	   (push (cdr cell) s))))
      ((ldf)
       (push (list 'closure (pop c) e) s))
      ((ldct)
       (push (list 'continuation s e (pop c) d) s))
      ((lset)
       (let ((pos (pop c)))
         (set-lvar e (car pos) (cdr pos) (car s))))
      ((gset)
       (let ((cell (pop c)))
	 (if (eq (cdr cell) '*undef*)
	     (error "unbound variable: ~S~%" (car cell))
	   (setf (cdr cell) (car s)))))
      ((app)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (push (list s e c) d)
            (setq s nil
                  e (cons lvar (cadr clo))
                  c (car clo))))))
      ((tapp)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (setq e (cons lvar (cadr clo))
                  c (car clo))))))
      ((rtn)
       (let ((save (pop d)))
         (setq s (cons (car s) (car save))
               e (cadr save)
               c (caddr save))))
      ((sel)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (push c d)
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ((selr)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ((join)
       (setq c (pop d)))
      ((pop) (pop s))
      ((args)
       (let ((a nil))
         (dotimes (n (pop c) (push a s))
           (push (pop s) a))))
      ((args-ap)
       (let ((a (copy-list (pop s))))
         (dotimes (n (1- (pop c)) (push a s))
           (push (pop s) a))))
      ((def)
       (let ((cell (pop c)))
	 (setf (cdr cell) (pop s))
	 (push (car cell) s)))
      ((defm)
       (let ((cell (pop c)))
	 (setf (cdr cell) (cons 'macro (pop s)))
	 (push (car cell) s)))
      ((stop) (return (car s)))
      (t (error "unknown opcode")))))

; 大域変数
(setq *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'eqv?  'primitive #'(lambda (x y) (if (eql x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'display 'primitive #'(lambda (x) (princ x) '*undef*))
       (list 'newline 'primitive #'(lambda () (terpri) '*undef*))
       (list '+     'primitive #'+)
       (list '-     'primitive #'-)
       (list '*     'primitive #'*)
       (list '/     'primitive #'/)
       (list '=     'primitive #'(lambda (&amp;rest x) (if (apply #'= x) 'true 'false)))
       (list '&lt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&lt; x) 'true 'false)))
       (list '&gt;     'primitive #'(lambda (&amp;rest x) (if (apply #'&gt; x) 'true 'false)))
       (list '&lt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&lt;= x) 'true 'false)))
       (list '&gt;=    'primitive #'(lambda (&amp;rest x) (if (apply #'&gt;= x) 'true 'false)))
       ))

;;; read-eval-print-loop

(defun change-readtable ()
  (set-macro-character
   #\`
   #'(lambda (stream char)
       (declare (ignore char))
       (list 'backquote (read stream t nil t))))
  (set-macro-character
   #\,
   #'(lambda (stream char)
       (declare (ignore char))
       (cond ((char= (peek-char nil stream) #\@)
              (read-char stream)
              (list 'splice (read stream t nil t)))
             (t (list 'unquote (read stream t nil t)))))))

(defun repl (&amp;rest file-list)
  (unwind-protect
      (progn
        (change-readtable)
        (dolist (file file-list)
          (with-open-file (in file :direction :input)
            (do ((output t))
                ((eq output nil) (terpri))
              (setf output (vm '() '() (compile-expr (read in nil)) '()))
              (print output))))
        (do ((output nil))
            ((eq output 'quit))
          (princ "&gt;&gt;&gt; ")
          (force-output)
	  (handler-case
	      (let ((expr (compile-expr (read))))
		(setf output (vm '() '() expr '()))
		(princ output)
		(terpri))
	    (error (c) (princ c)))))
    (setq *readtable* (copy-readtable nil))))
</pre>
</section>
<hr>
<section class="contents">
<h4 id="appendix1">●Appendix: バッククォートの修正 (2013/08/24)</h4>
<p> 拙作のページ <a href="clispb13.html">Common Lisp で作る micro Scheme (2)</a> や <a href="clispb17.html">Common Lisp で作る micro Scheme コンパイラ (2)</a> で作成したバッククォートの処理は簡略版で、 Scheme の仕様書 (R5RS など) に準拠しておりません。具体的には、バッククォートは入れ子にすることができるのですが、拙作の簡略版では対応していません。今回はちょっと複雑になりますが、バッククォートの入れ子にも対応するようにプログラムを修正しましょう。
</p>

<p> バッククォートの入れ子は、レベルを考えると理解しやすいと思います。一番外側にある `expr0 をレベルを 0 とします。expr0 の中で `expr1 を見つけたら、レベルを +1 します。このとき、` はそのまま出力して、expr1 の処理を行います。その中で ,expr2 や ,@expr2 を見つけた場合、レベルが 0 ならば expr2 を評価するようにマクロ展開し、そうでなければレベルを -1 します。このとき、, や ,@ はそのまま出力して、expr2 の処理を行います。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; `(a `(b ,(c ,(+ 1 2 3))) ,(car '(d e f)))
(a `(b ,(c 6)) d)
</pre>
<p> リスト A = (a ...) のレベルは 0 です。次の要素が backquote なので、リスト B = (b ...) のレベルは 1 になります。リスト B の 2 番目の要素は unquote ですが、レベルが 1 なので、unquote をそのまま出力して、リスト C = (c ,(+ 1 2 3)) を処理します。このとき、レベルは -1 されて 0 になります。リスト C の中の unquote はレベルが 0 なので、(+ 1 2 3) を評価して 6 になります。リスト A の最後の要素はレベル 0 の unquote なので (car '(d e f)) を評価して d になります。
</p>

<p> バッククォートはリストだけではなくアトムにも適用することができます。拙作の簡略版はこの処理にも対応していません。次の例を見てください。
</p>
<pre>
gosh&gt; (define a '(1 2 3))
a
gosh&gt; `,a
(1 2 3)
gosh&gt; `,@a
=> エラー
gosh&gt; ``,,@a
`(unquote 1 2 3)
gosh&gt; ``,@,@a
`(unquote-splicing 1 2 3)
</pre>
<p> `,a は (1 2 3) に展開されますが、`,@a はリストを外せないのでエラーになります。ただし、splice の前に unquote や splice (Scheme では unquote-splicing) がそのまま展開される場合は、リストを外すことができるのでエラーにはなりません。
</p>

<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。
</p>

<pre class="list">
リスト : バッククオートの処理

(define unquote
  (lambda (x) (error "unquote appeared outside backquote")))

(define splice
  (lambda (x) (error "splice appeared outside backquote")))

(define translator
  (lambda (ls n)
    (if (pair? ls)
        (if (pair? (car ls))
	    (translator-list ls n)
	  (translator-atom ls n))
      (list 'quote ls))))

(define-macro backquote (lambda (x) (translator x 0)))
</pre>
<p> 関数 unquote と splice はエラーを返します。これは `,,a のように、対応する backquote がない場合に呼び出されます。micro Scheme コンパイラ (secd.l) に primitive の関数 error を追加してください。
</p>

<pre class="list">
リスト : secd.scm の修正

; 大域変数
(setq *global-environment*
      (list

       ・・・ 省略 ・・・

       (list 'error 'primitive #'error)    ; 追加
       ))
</pre>

<p> backquote の実際の処理は関数 translator で行います。引数が ls がリストでその先頭要素がリストの場合は tranlator-list を呼び出します。これはリストの中にある unquote や splice を展開します。先頭要素がアトムの場合は tranlator-atom を呼び出します。これは backquote の直後にある unquote や splice を展開します。それ以外の場合は (quote ls) を生成するコード (list 'quote ls) を出力します。
</p>

<p> 次は translator-list を作ります。
</p>
<pre class="list">
リスト : バッククオートの処理 (2)

(define translator-list
  (lambda (ls n)
    (if (eq? (caar ls) 'unquote)
	(translator-unquote ls n)
      (if (eq? (caar ls) 'splice)
	  (translator-splice ls n)
	(if (eq? (caar ls) 'backquote)
	    (translator-backquote ls n)
	  (list 'cons
		(translator (car ls) n)
		(translator (cdr ls) n)))))))
</pre>
<p> translator-list は (caar ls) の種類によって処理を振り分けるだけです。unquote であれば translator-unquote を、splice であれば translator-splice を、backquote であれば translator-backquote を呼び出します。それ以外の場合は (car ls) と (cdr ls) に対して translator を適用し、その結果を cons で連結するコードを生成します。
</p>

<p> 次は unquote を展開する translator-unquote を作ります。
</p>
<pre class="list">
リスト : バッククオートの処理 (3)

(define translator-sub
  (lambda (sym ls n succ)
    (list 'list
	  (list 'quote sym)
	  (translator ls (+ n succ)))))

(define translator-unquote
  (lambda (ls n)
    (list 'cons
	  (if (zero? n)
	      (cadar ls)
	    (translator-sub 'unquote (cadar ls) n -1))
	  (translator (cdr ls) n))))
</pre>
<p> レベル n が 0 の場合、unquote の次の要素 (cadar ls) を評価するコードを生成します。これは (cadar ls) をそのまま出力するだけです。そうでなければ、unquote をそのまま出力して、(cadar ls) の中を調べます。この処理を関数 translator-sub で行います。このときレベルを -1 します。あとは、(cdr ls) に traslator を適用して、2 つの引数を cons で連結するコードを生成します。
</p>

<p> 次は splice を展開する関数 translator-splice を作ります。
</p>
<pre class="list">
リスト : バッククオートの処理 (4)

(define translator-splice
  (lambda (ls n)
    (if (zero? n)
	(list 'append (cadar ls) (translator (cdr ls) n))
      (list 'cons
	    (translator-sub 'splice (cadar ls) n -1)
	    (translator (cdr ls) n)))))
</pre>
<p> レベル n が 0 の場合は、(cadar ls) を評価した結果と (cdr ls) に translator を適用した結果を append するコードを生成します。これで (cadar ls) の評価結果のリストを外すことができます。そうでなければ、translator-sub で splice をそのまま出力するコードを生成し、(cdr ls) に translator を適用した結果と cons するコードを生成します。translator-sub を呼び出すときはレベルを -1 することをお忘れなく。
</p>

<p> 次は backquote をそのまま出力する関数 translator-backquote を作ります。
</p>
<pre class="list">
リスト : バッククオートの処理 (5)

(define translator-backquote
  (lambda (ls n)
    (list 'cons
	  (translator-sub 'backquote (cadar ls) n 1)
	  (translator (cdr ls) n))))
</pre>
<p> translator-backquote は簡単です。translator-sub で backquote をそのまま出力するコードを生成し、(cdr ls) に translator を適用した結果と cons するコードを生成します。translator-sub を呼び出すときはレベルを +1 することに注意してください。
</p>

<p> 最後に translator-atom を作ります。
</p>
<pre class="list">
リスト : バッククオートの処理 (6)

(define translator-atom
  (lambda (ls n)
    (if (eq? (car ls) 'unquote)
	(if (zero? n)
	    (cadr ls)
	  (if (= n 1)
	      (if (eq? (car (cadr ls)) 'splice)
		  (list 'cons (list 'quote 'unquote) (cadr (cadr ls)))
		(translator-sub 'unquote (cadr ls) n -1))
	    (translator-sub 'unquote (cadr ls) n -1)))
      (if (eq? (car ls) 'splice)
	  (if (zero? n)
	      (error "invalid splice form")
	    (if (= n 1)
		(if (eq? (car (cadr ls)) 'splice)
		    (list 'cons (list 'quote 'splice) (cadr (cadr ls)))
		  (translator-sub 'splice (cadr ls) n -1))
	      (translator-sub 'splice (cadr ls) n -1)))
	(if (eq? (car ls) 'backquote)
	    (translator-sub 'backquote (cadr ls) n 1)
	  (list 'cons 
		(list 'quote (car ls))
		(translator (cdr ls) n)))))))
</pre>
<p> (car ls) が unquote でレベル n が 0 の場合、(cadr ls) をそのまま出力します。これでマクロ展開されたあと (cadr ls) が評価されます。レベル n が 1 で、(cadr ls) の先頭要素が splice の場合、次の要素 (cadr (cadr ls)) を評価して、そのリストの先頭に unquote を cons で追加するコードを生成します。それ以外の場合は、translator-sub で unquote をそのまま出力するコードを生成します。
</p>
<p> (car ls) が splice でレベル n が 0 の場合、リストを外せないのでエラーを返します。レベル n が 1 で、(cadr ls) の先頭要素が splice の場合、次の要素 (cadr (cadr ls)) を評価して、そのリストの先頭に splice を cons で追加するコードを生成します。それ以外の場合は、translator-sub で splice をそのまま出力するコードを生成します。
</p>
<p> (car ls) を backquote の場合は translator-sub で backquote をそのまま出力するコードを生成します。それ以外の場合は (car ls) をそのまま出力するコードを生成し、(cdr ls) に translator-sub を適用したコードと cons するコードを生成します。
</p>
<h4>●実行例</h4>
<p> それでは実際に試してみましょう。必要なプログラムはファイル <a href="clispb19.html#list3">lib.scm</a> に格納されているものとします。
</p>

<pre>
&gt;&gt;&gt; (define a 1)
A
&gt;&gt;&gt; (define b '(a b c))
B
&gt;&gt;&gt; `(a b)
(A B)
&gt;&gt;&gt; `(,a ,b)
(1 (A B C))
&gt;&gt;&gt; `(,a ,@b)
(1 A B C)
&gt;&gt;&gt; `(a `(b ,(c ,(+ 1 2 3))) ,(car '(d e f)))
(A (BACKQUOTE (B (UNQUOTE (C 6)))) D)
&gt;&gt;&gt; `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
(A (BACKQUOTE (B (UNQUOTE (+ 1 2)) (UNQUOTE (FOO 4 D)) E)) F)
&gt;&gt;&gt; (let ((name1 'x) (name2 'y)) `(a `(b ,,name1 ,',name2 d) e))
(A (BACKQUOTE (B (UNQUOTE X) (UNQUOTE 'Y) D)) E)
&gt;&gt;&gt; `,a
1
&gt;&gt;&gt; `,b
(A B C)
&gt;&gt;&gt; ``,,a
(BACKQUOTE (UNQUOTE 1))
&gt;&gt;&gt; ``,,b
(BACKQUOTE (UNQUOTE (A B C)))
&gt;&gt;&gt; ``,,@b
(BACKQUOTE (UNQUOTE A B C))
&gt;&gt;&gt; ``,@,@b
(BACKQUOTE (SPLICE A B C))

&gt;&gt;&gt; ,a
unquote appeared outside backquote
&gt;&gt;&gt; ,@b
splice appeared outside backquote
&gt;&gt;&gt; `,@b
invalid splice form
&gt;&gt;&gt; `,,@b
splice appeared outside backquote
&gt;&gt;&gt; `,,a
unquote appeared outside backquote
</pre>
<p> どうやら正常に動作しているようですが、まだバグが残っているかもしれません。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
;
; lib.scm : micro Scheme 用簡易ライブラリ
;
;           Copyright (C) 2013 Makoto Hiroi
;

; 述語
(define not (lambda (x) (if x false true)))
(define null? (lambda (x) (eq? x ())))

; 数
(define zero? (lambda (x) (= x 0)))
(define positive? (lambda (x) (&lt; 0 x)))
(define negative? (lambda (x) (&gt; 0 x)))
(define even? (lambda (x) (zero? (mod x 2))))
(define odd? (lambda (x) (not (even? x))))
(define abs (lambda (x) (if (negative? x) (- x) x)))
(define max
  (lambda (x . xs)
    (fold-left (lambda (a b) (if (&lt; a b) b a)) x xs)))
(define min
  (lambda (x . xs)
    (fold-left (lambda (a b) (if (&gt; a b) b a)) x xs)))

(define gcdi
  (lambda (a b)
    (if (zero? b)
	a
      (gcdi b (mod a b)))))
(define gcd
  (lambda xs
    (if (null? xs)
	0
      (fold-left (lambda (a b) (gcdi a b)) (car xs) (cdr xs)))))

(define lcmi (lambda (a b) (/ (* a b) (gcdi a b))))
(define lcm
  (lambda xs
    (if (null? xs)
	1
      (fold-left (lambda (a b) (lcmi a b)) (car xs) (cdr xs)))))

; cxxr
(define caar (lambda (xs) (car (car xs))))
(define cadr (lambda (xs) (car (cdr xs))))
(define cdar (lambda (xs) (cdr (car xs))))
(define cddr (lambda (xs) (cdr (cdr xs))))

; cxxxr
(define caaar (lambda (xs) (car (caar xs))))
(define caadr (lambda (xs) (car (cadr xs))))
(define cadar (lambda (xs) (car (cdar xs))))
(define caddr (lambda (xs) (car (cddr xs))))
(define cdaar (lambda (xs) (cdr (caar xs))))
(define cdadr (lambda (xs) (cdr (cadr xs))))
(define cddar (lambda (xs) (cdr (cdar xs))))
(define cdddr (lambda (xs) (cdr (cddr xs))))


; リスト操作

(define list (lambda x x))

(define append-1
  (lambda (xs ys)
    (if (null? xs)
	ys
      (cons (car xs) (append-1 (cdr xs) ys)))))

(define append
  (lambda xs
    (if (null? xs)
	'()
      (if (null? (cdr xs))
	  (car xs)
	(append-1 (car xs) (apply append (cdr xs)))))))

(define length
  (lambda (xs)
    (fold-left (lambda (a x) (+ a 1)) 0 xs)))

(define reverse
  (lambda (xs)
    (fold-left (lambda (a x) (cons x a)) () xs)))

(define list-tail
  (lambda (xs k)
    (if (zero? k)
	xs
      (list-tail (cdr xs) (- k 1)))))

(define list-ref 
  (lambda (xs k)
    (if (zero? k)
	(car xs)
      (list-ref (cdr xs) (- k 1)))))

; リストの探索
(define memq
  (lambda (x ls)
    (if (null? ls)
        false
        (if (eq? x (car ls))
            ls
          (memq x (cdr ls))))))

(define memv
  (lambda (x ls)
    (if (null? ls)
        false
        (if (eqv? x (car ls))
            ls
          (memv x (cdr ls))))))

(define member
  (lambda (x ls)
    (if (null? ls)
        false
        (if (equal? x (car ls))
            ls
          (member x (cdr ls))))))

; 高階関数
(define map-1
  (lambda (f xs)
    (if (null? xs)
	()
      (cons (f (car xs)) (map f (cdr xs))))))

(define map
  (lambda (f . args)
    (if (memq '() args)
	'()
      (cons (apply f (map-1 car args))
	    (apply map f (map-1 cdr args))))))

(define filter
  (lambda (p xs)
    (if (null? xs)
	()
      (if (p (car xs))
	  (cons (car xs) (filter p (cdr xs)))
	(filter p (cdr xs))))))

(define fold-left
  (lambda (f a xs)
    (if (null? xs)
	a
      (fold-left f (f a (car xs)) (cdr xs)))))

(define fold-right
  (lambda (f a xs)
    (if (null? xs)
	a
      (f (car xs) (fold-right f a (cdr xs))))))


;;
;; マクロ
;;
(define unquote
  (lambda (x) (error "unquote appeared outside backquote")))

(define splice
  (lambda (x) (error "splice appeared outside backquote")))

(define translator-sub
  (lambda (sym ls n succ)
    (list 'list
	  (list 'quote sym)
	  (translator ls (+ n succ)))))

(define translator-unquote
  (lambda (ls n)
    (list 'cons
	  (if (zero? n)
	      (cadar ls)
	    (translator-sub 'unquote (cadar ls) n -1))
	  (translator (cdr ls) n))))

(define translator-splice
  (lambda (ls n)
    (if (zero? n)
	(list 'append (cadar ls) (translator (cdr ls) n))
      (list 'cons
	    (translator-sub 'splice (cadar ls) n -1)
	    (translator (cdr ls) n)))))

(define translator-backquote
  (lambda (ls n)
    (list 'cons
	  (translator-sub 'backquote (cadar ls) n 1)
	  (translator (cdr ls) n))))

(define translator-list
  (lambda (ls n)
    (if (eq? (caar ls) 'unquote)
	(translator-unquote ls n)
      (if (eq? (caar ls) 'splice)
	  (translator-splice ls n)
	(if (eq? (caar ls) 'backquote)
	    (translator-backquote ls n)
	  (list 'cons
		(translator (car ls) n)
		(translator (cdr ls) n)))))))

(define translator-atom
  (lambda (ls n)
    (if (eq? (car ls) 'unquote)
	(if (zero? n)
	    (cadr ls)
	  (if (= n 1)
	      (if (eq? (car (cadr ls)) 'splice)
		  (list 'cons (list 'quote 'unquote) (cadr (cadr ls)))
		(translator-sub 'unquote (cadr ls) n -1))
	    (translator-sub 'unquote (cadr ls) n -1)))
      (if (eq? (car ls) 'splice)
	  (if (zero? n)
	      (error "invalid splice form")
	    (if (= n 1)
		(if (eq? (car (cadr ls)) 'splice)
		    (list 'cons (list 'quote 'splice) (cadr (cadr ls)))
		  (translator-sub 'splice (cadr ls) n -1))
	      (translator-sub 'splice (cadr ls) n -1)))
	(if (eq? (car ls) 'backquote)
	    (translator-sub 'backquote (cadr ls) n 1)
	  (list 'cons 
		(list 'quote (car ls))
		(translator (cdr ls) n)))))))

(define translator
  (lambda (ls n)
    (if (pair? ls)
        (if (pair? (car ls))
	    (translator-list ls n)
	  (translator-atom ls n))
      (list 'quote ls))))

(define-macro backquote (lambda (x) (translator x 0)))

; let (named-let)
(define-macro let
  (lambda (args . body)
    (if (pair? args)
        `((lambda ,(map car args) ,@body) ,@(map cadr args))
      ; named-let
      `(letrec ((,args (lambda ,(map car (car body)) ,@(cdr body))))
        (,args ,@(map cadr (car body)))))))

; and
(define-macro and
  (lambda args
    (if (null? args)
        true
      (if (null? (cdr args))
          (car args)
        `(if ,(car args) (and ,@(cdr args)) false)))))

; or
(define-macro or
  (lambda args
    (if (null? args)
        false
      (if (null? (cdr args))
          (car args)
        `(let ((+value+ ,(car args)))
          (if +value+ +value+ (or ,@(cdr args))))))))

; let*
(define-macro let*
  (lambda (args . body) 
    (if (null? (cdr args))
        `(let (,(car args)) ,@body)
      `(let (,(car args)) (let* ,(cdr args) ,@body)))))

; letrec
(define-macro letrec
  (lambda (args . body)
    (let ((vars (map car args))
          (vals (map cadr args)))
      `(let ,(map (lambda (x) `(,x '*undef*)) vars)
            ,@(map (lambda (x y) `(set! ,x ,y)) vars vals)
            ,@body))))

; begin
(define-macro begin
  (lambda args
    (if (null? args)
        `((lambda () '*undef*))
      `((lambda () ,@args)))))

; cond
(define-macro cond
  (lambda args
    (if (null? args)
        '*undef*
      (if (eq? (caar args) 'else)
          `(begin ,@(cdar args))
        (if (null? (cdar args))
            (caar args)
          `(if ,(caar args)
               (begin ,@(cdar args))
            (cond ,@(cdr args))))))))

; case
(define-macro case
  (lambda (key . args)
    (if (null? args)
        '*undef*
      (if (eq? (caar args) 'else)
          `(begin ,@(cdar args))
        `(if (memv ,key ',(caar args))
             (begin ,@(cdar args))
           (case ,key ,@(cdr args)))))))

; do
(define-macro do
  (lambda (var-form test-form . args)
    (let ((vars (map car var-form))
          (vals (map cadr var-form))
          (step (map cddr var-form)))
      `(letrec ((loop (lambda ,vars
                        (if ,(car test-form)
                            (begin ,@(cdr test-form))
                          (begin
                            ,@args
                            (loop ,@(map (lambda (x y)
					   (if (null? x) y (car x)))
                                           step
                                           vars)))))))
        (loop ,@vals)))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009-2013 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="clispb18.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb31.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>