<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 CLOS プログラミング入門</title>
  <meta name="description" content="Common Lisp,Common Lisp Object System,CLOS,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881771</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>お気楽 CLOS プログラミング入門</h2>
<div class="small">
[ PrevPage | <a href="index.html#clos">CLOS</a> | <a href="clisp02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>●オブジェクト指向の基礎知識</h3>
<p> プログラミングに興味のある方ならば、「オブジェクト指向」という言葉は聞いたことがあると思います。よく使われているオブジェクト指向言語に C++ や Java があります。また、Lightweight Language と呼ばれているプログラミング言語、たとえば Perl, Python, Ruby, JavaScript などはオブジェクト指向をサポートしています。 
</p>
<p> 多くの言語でサポートされている「オブジェクト指向」ですが、関数型言語では Common Lisp の CLOS (Common Lisp Object System) が有名でしょう。CLOS は Smalltalk, C++, Java などのポピュラーなオブジェクト指向とはちょっと違っていて、興味深い機能がたくさんあります。クラス、インスタンス、メソッド、継承などの一般的なオブジェクト指向機能のほかに、総称関数 (generic function) やメソッド結合 (method combination) などのユニークな機能があります。 
</p>
<p> CLOS は巨大なオブジェクト指向システムなので、仕様書である CLtL2 (<a href="index.html#cite">参考文献 [2]</a>) を読むだけでも一苦労しますが、CLOS は自然な形で Common Lisp を拡張しているので、基本的な機能はとても簡単に使うことができると思います。やさしいところから少しずつ勉強していきましょう。
</p>
<p> それでは、最初にオブジェクト指向について簡単に説明します。なお、この説明は拙作のページ <a href="../light/index.html">Lightweight Language</a> <a href="../light/python05.html">お気楽 Python プログラミング入門第 5 回</a> と同じです。既に読んだことがある方や、一般的なオブジェクト指向について理解されている方は、読み飛ばしてもらってもかまいません。
</p>
<p><a href="clisp01.html#next1">次へ</a>
</p>
<h4>●オブジェクトとは？</h4>
<p> プログラムを作る場合、全体を小さな処理に分割して、ひとつひとつの処理を作成し、それらを組み合わせて全体のプログラムを完成させます。このとき、基本的な部品となるのが関数です。つまり、処理を関数単位で分割して、それらを組み合わせてプログラムを作るわけです。もともと関数の役割は、入力されたデータを処理してその結果を返すことです。つまり、関数は機能を表しているのです。このため、全体を小さな処理に分割するにしても、機能単位で行われることが普通です。
</p>

<p> オブジェクト指向プログラミングでは、関数ではなく「オブジェクト (object) 」を部品として扱います。たとえば、えんぴつを考えてみましょう。えんぴつには、色、長さ、固さ、などいろいろな性質があります。そして、えんぴつを使って文字を書いたり、絵を描いたりすることができます。プログラムでは、このような性質をデータで表し、機能を関数で表すことになります。そしてオブジェクトとは、このデータと関数を結び付けたものなのです。
</p>

<p> いままでのプログラミング言語では、データと関数を別々に定義するため、それをひとつのオブジェクトとして表すことができません。えんぴつで文字を書くにも、えんぴつの種類をチェックして文字を書くようにプログラムしなければいけません。ところが、オブジェクトはデータと関数を結び付けたものなので、自分がなにをしたらよいかわかっています。えんぴつオブジェクトに文字を書けと命じれば、それが赤えんぴつのオブジェクトであれば文字は赤に、黒えんぴつのオブジェクトであれば黒い文字になるのです。
</p>

<p> このように、オブジェクトはデータと関数をひとつにまとめたものです。従来のプログラミングが全体を機能単位で分割するのに対し、オブジェクト指向プログラミングでは全体をオブジェクト単位に分割して、それを組み合わせることでプログラムを作成します。
</p>

<p> ところで、データと関数を結び付けることは、従来のプログラミング言語でも可能です。オブジェクト指向はプログラミングの考え方のひとつであり、C++ のようなオブジェクト指向言語を使わなくても、たとえばＣ言語でもその考え方にしたがってプログラムを作れば、オブジェクト指向プログラミングになります。
</p>

<p> 実際、オブジェクト指向には様々な考え方があり、いろいろなオブジェクト指向言語が存在します。ですが、データと関数をひとつにまとめたものをオブジェクトとして扱うという基本的な考え方は、オブジェクト指向言語の元祖と言われる Smalltalk でも、C++, Java, CLOS でも同じです。
</p>

<h4>●クラスとインスタンス</h4>
<p> 次は、一般的なオブジェクト指向機能について簡単に説明します。
</p>

<p> 「クラス (class) 」はオブジェクトの振る舞いを定義したものです。ここでデータを格納するための変数や、それを操作する関数が定義されます。この変数をメンバ変数とかインスタンス変数といい、関数を「メソッド (method) 」といいます。メソッドはあとで説明します。
</p>

<p> クラスはオブジェクトの設計図にあたるもので、オブジェクトの「雛形」と呼ぶこともあります。クラスはオブジェクトの振る舞いを定義するだけで、アクセスできる実体はなにも生み出していない、ということに注意してください。
</p>

<p> このクラスから実体として作り出されるのが「インスタンス (instance) 」です。このインスタンスを「オブジェクト」と考えてください。インスタンスを生成する方法は、当然ですがプログラミング言語によって違います。たとえば C++ や Java は new を使います。図 1 を見てください。
</p>
<pre class="fig">
┌─ class Foo  ─┐                        ┌─ instance ─┐
│                │                        │              │
│     設計図     │─ インスタンスの生成 →│   実体       │
│                │                        │              │
└────────┘                        └───────┘
          │
          │
          │                                ┌─ instance ─┐
          │                                │              │
          └───── インスタンスの生成 →│   実体       │
                                            │              │
                                            └───────┘

             図 1 : クラスとインスタンスの関係
</pre>
<p> クラスはオブジェクトの定義を表すものですから、Foo というクラスはひとつしかありません。これに対し、インスタンスはクラスから生み出されるオブジェクトです。たとえば、クラス Foo に new を適用することで、いくつでもインスタンスを生み出すことができるのです。クラスは設計図であり、それに従って作られるオブジェクトがインスタンスと考えるとわかりやすいでしょう。
</p>

<h4>●メソッド</h4>
<p> メソッドはオブジェクトと結びついた関数です。オブジェクト指向プログラミングでは、ほかの関数から直接オブジェクトを操作することはせず、メソッドを呼び出すことで行います。メソッドは、クラスが異なっていれば同じ名前のメソッドを定義することができます。たとえば、クラス Foo1 にメソッド bar() が定義されていても、クラス Foo2 に同名のメソッド bar() を定義することができます。
</p>

<p> そして、ここからが重要なのですが、あるオブジェクトに対してメソッド bar() を呼び出した場合、それが Foo1 から作られたオブジェクトであれば、Foo1 で定義された bar() が実行され、Foo2 から作られたオブジェクトであれば、Foo2 で定義された bar() が実行されるのです。
</p>

<p> このように、オブジェクトが属するクラスによって、実行されるメソッドが異なるのです。この機能を「ポリモーフィズム(polymorphism) 」と呼びます。これにより、オブジェクトは自分が行うべき適切な処理を実行できるわけです。
</p>

<p> クラス、インスタンス、メソッドの関係は図 2 のようになります。
</p>
<pre class="fig">
┌─ class Foo1 ─┐                    ┌─ instance ─┐
│                │                    │              │
│    設計図      │─── 生成 ───→│   実体       │
│                │                    │              │
│                │                    └───────┘
│┌─ method ─┐│                          ↑
││            ││                          │
││   bar()←─┼┼─── アクセス ─────┘
││            ││
│└──────┘│
└────────┘

       図 2 : クラス、インスタンス、メソッドの関係
</pre>
<p> クラスという設計図が中心にあり、そこからインスタンスが生み出され、メソッドを使ってインスタンスを操作する、という関係になります。
</p>

<h4><a name="next1">●クラスの定義</a></h4>
<p> さて、一般的な話はここまでにして、CLOS のオブジェクト指向機能を説明していきましょう。CLOS の場合、クラスはマクロ defclass を使って定義します。defclass は構造体 defstruct とよく似ています。構造体の説明は拙作のページ <a href="../xyzzy_lisp.html">xyzzy Lisp Programming</a> の Common Lisp 入門 <a href="../xyzzy_lisp/abclisp09.html">構造体</a> をお読みください。defclass の構文を次に示します。
</p>
<pre class="item">
(defclass クラス名 (スーパークラス ...)
  ((スロット名 :accessor アクセスメソッド名 
               :initform 初期値フォーム
               :initarg  引数マークシンボル)
    ・・・・
   (スロット名 :accessor アクセスメソッド名 
               :initform 初期値フォーム
               :initarg  引数マークシンボル)))
</pre>
<p> defclass の次にクラス名をシンボルで指定し、その次にスーパークラスをリストで指定します。CLOS は「多重継承」をサポートしているので、リスト内に複数のスーパークラスを指定することができます。継承はあとで詳しく説明します。
</p>
<p> スロット (slot) とは、クラスで定義した変数のことです。スロット名の指定にはシンボルを使います。スロットは変数と同様に S 式であれば何でも格納することができます。これは構造体と同じですね。スロットのあとにスロットオプションを指定することができます。defclass でよく使われるスロットオプションには :accessor, :initform, :initarg などがあります。
</p>
<ul>
  <li><b>:accessor</b><br>
スロットにアクセスするためのメソッド名を指定します。ここで指定された名前のメソッドが自動的に生成され、このメソッドを使ってスロットの値を参照したり、setf と組み合わせてスロットに値を書き込むことができます。
  <li><b>:initform</b><br>
スロットの初期値を指定します。:initform の引数はインスタンスを生成するときに評価され、その結果が初期値となります。
  <li><b>:initarg</b><br>
インスタンスを生成する関数 make-instance で、スロットの初期値を指定するときに使う引数マークシンボルを指定します。初期値が指定されていない場合、スロットは未束縛 (unbound) の状態になります。
</ul>

<p> 定義されたクラス名は、あとで説明するインスタンス、メソッド、継承機能の中で、データ型を表す識別子として重要な役割を果たします。つまり、構造体と同様にクラスは Lisp システムの中で新しい「データ型」として機能するのです。したがって、データ型を検査する関数 typep やデータ型を求める関数 type-of でクラス名を利用することができます。
</p>
<p> ここで、注意してもらいたいことがあります。クラスはデータ型を定義するだけで、アクセスできる実体は何も生み出していないのです。クラスというデータ型をアクセスできる実体として作り出したのが「インスタンス (instance) 」です。CLOS の場合、このインスタンスを「オブジェクト」と考えてください。
</p>

<h4>●インスタンスの生成</h4>
<p> インスタンスは関数 make-instance を使って生成します。
</p>
<pre class="item">
make-instance クラス名 [引数マークシンボル Ｓ式 ...]
</pre>

<p> スロットは make-instance でインスタンスを生成するときに初期化されます。初期値は引数マークシンボルの後ろの S 式になります。make-instance は関数なので、S 式は評価されることに注意してください。この初期値は引数マークシンボルに対応するスロットにセットされます。make-instance でスロットの初期値が省略された場合は、defclass の :initform で設定した初期値フォームを評価して、その結果をスロットに格納します。
</p>
<p> 簡単な使用例を示しましょう。
</p>

<pre>
&gt; (defclass foo () ((a :accessor foo-a :initform 1 :initarg :a)))
#&lt;STANDARD-CLASS FOO&gt;
&gt; (setq x (make-instance 'foo))
#&lt;FOO #x1A706B1D&gt;
&gt; (foo-a x)
1
&gt; (setf (foo-a x) 2)
2
&gt; (foo-a x)
2
&gt; (typep x 'foo)
T
&gt; (type-of x)
FOO

&gt; (setq y (make-instance 'foo :a 10))
#&lt;FOO #x1A70BE75&gt;
&gt; (foo-a y)
10
</pre>
<p> defclass でクラス foo を定義します。foo にはスロット a が定義されています。そして、:accessor に foo-a を指定しているので、スロット a にアクセスするメソッド foo-a が生成されます。それから、:initform に初期値 1 を、:initarg にキーワード :a を指定します。引数マークシンボルは通常のシンボルでもかまいませんが、キーワードを使った方がわかりやすいでしょう。
</p>
<p> 次に、make-instance でクラス foo のインスタンスを生成し、変数 x にセットします。スロット a は :accessor で指定したメソッド foo-a でアクセスすることができます。実際に (foo-a x) を評価すると値は 1 になります。スロット a は :initform の値 1 で初期化されていることがわかります。また、(setf (foo-a x) 2) とすれば、スロット a の値を 2 に書き換えることができます。
</p>
<p> それから、クラス名 foo はデータ型名として機能するので、クラス foo のインスタンスのデータ型は foo になります。したがって、(typep x 'foo) は真 (T) になります。また、関数 type-of で変数 x のデータ型を求めると FOO になります。一般に、Common Lisp はシンボル名の英大小文字を区別しないので、foo と FOO は同じシンボルになります。xyzzy Lisp ではシンボル名の英大小文字を区別するので、xyzzy Lisp ユーザはご注意くださいませ。
</p>
<p> make-instance でスロットの初期値を指定するには、:initarg で指定した引数マークシンボル :a を使います。この場合 :initform で指定された初期値フォームは無効になります。実際に :a に 10 を指定してインスタンスを生成すると、スロット a は 10 に初期化されます。
</p>
<p> くどいようですが、クラスはデータ型を定義するだけで、実際にアクセスするオブジェクトがインスタンスである、ということに注意してください。次の図を見てください。
</p>
<pre class="fig">
                                        変数 x
┌─ class foo  ─┐                     ┌─ instance ─┐  
│   [データ型]   │                     │[オブジェクト]│
│ slot a :       │─ make-instance ─→│ slot a : 1   │
└────────┘                     └───────┘
          │
          │                            変数 y
          │                             ┌─ instance ─┐
          │                             │[オブジェクト]│
          └───── make-instance ─→│ slot a : 10  │
                                         └───────┘

        図 3 : クラスとインスタンスの関係
</pre>
<p> クラスはデータ型を表すので、foo というクラスは Lisp システムの中にはひとつしかありません。これに対し、インスタンスは make-instance によりクラスから生み出されるオブジェクトです。クラス foo に make-instance を適用すれば、いくつでもインスタンスを生み出すことができるのです。クラスは設計図であり、それに従って作られるオブジェクトがインスタンス、それを作り出す工場が make-instance と考えるとわかりやすいでしょう。
</p>

<h4>●メソッドの定義</h4>
<p> メソッドは特定のクラス（データ型）と結びついた関数です。メソッドの特徴は、同じ名前のメソッドをいくつも定義することができ、引数のデータ型によって、その中から実際に呼び出すメソッドを自動的に選択することです。該当するメソッドが見つからない場合はエラーとなります。CLOS では同一名のメソッドの集まりを「総称関数 (generic function) 」と呼びます。この総称関数がＣ++や Java などのオブジェクト指向とはちょっと違う CLOS の特徴です。
</p>
<p> メソッドの定義にはマクロ defmethod を使います。
</p>
<pre class="item">
defmethod メソッド名 ((仮引数名 データ型) or 引数 ... ) Ｓ式 ...
</pre>
<p> defmethod は defun と構造がよく似ていまが、仮引数リストが異なっています。仮引数名を表すシンボルとデータ型をリストに格納して表します。データ型 <sup><a href="clisp01.html#note1">[*1]</a></sup> はクラス名か型指定子でなければいけません。データ型を省略した場合は、すべてのデータ型とマッチングすることになります。
</p>
<div class="note">
<a name="note1">-- note --------</a><br>
[*1] これを「引数特定子 (parameter specializer) 」と呼びます。
</div>
<p> CLOS の場合、クラス、インスタンス、メソッドの関係は次のようになります。
</p>
<pre class="fig">
┌─class foo ──┐                     ┌─ instance ─┐
│     slot a     │── make-instnace →│ slot a : 100 │
└────────┘                     └───────┘
         │                                       ↑
         │define-method                          │
         ↓                                       │Write
┌── 総称関数 bar ─┐                          │
│┌─ bar: foo ──┐│  Read                    │
││              ←┼┼─────────────┘
│└────────┘│
└──────────┘

        図 4 : クラス、インスタンス、メソッドの関係
</pre>
<p> CLOS のメソッドは、クラスの中に定義されているのではありません。個々のメソッドは総称関数に登録され、呼び出されるときに引数のデータ型によって適切なメソッドが選択されるのです。クラスとメソッドの結び付きはＣ++や Java よりも弱いですが、そのかわり柔軟なプログラミングが可能になります。
</p>
<h4>●メソッドの選択</h4>
<p> それでは簡単な使用例を示します。
</p>
<pre>
&gt; (defclass foo1 () ())
#&lt;STANDARD-CLASS FOO1&gt;
&gt; (defclass foo2 () ())
#&lt;STANDARD-CLASS FOO2&gt;
&gt; (defmethod bar ((x foo1)) (print "foo1 bar"))
#&lt;STANDARD-METHOD (#&lt;STANDARD-CLASS FOO1&gt;)&gt;
&gt; (defmethod bar ((x foo2)) (print "foo2 bar"))
#&lt;STANDARD-METHOD (#&lt;STANDARD-CLASS FOO2&gt;)&gt;
&gt; (setq a (make-instance 'foo1))
#&lt;FOO1 #x1A717699&gt;
&gt; (setq b (make-instance 'foo2))
#&lt;FOO2 #x1A71A21D&gt;
&gt; (bar a)

"foo1 bar"
"foo1 bar"
&gt; (bar b)

"foo2 bar"
"foo2 bar"
</pre>
<p> メソッド bar が 2 つ定義されています。どちらのメソッドも総称関数 bar に登録されます。そして、総称関数 bar を呼び出すとき、引数 x がクラス foo1 のインスタンスであれば、最初に定義したメソッドが選択され "foo1 bar" が表示されます。引数 x がクラス foo2 のインスタンスであれば、次に定義したメソッドが選択されるので "foo2 bar" が表示されます。このように、CLOS は総称関数 bar を呼び出すとき、引数のデータ型によってその中から適切なメソッドを選択して実行するのです。
</p>
<p> また、複数の引数にデータ型を指定して、適切なメソッドを呼び出すこともできます。次の例を見てください。
</p>
<pre>
&gt; (defmethod baz ((x integer) (y integer))
       (format t "integer ~D, float ~E~%" x y))
#&lt;STANDARD-METHOD (#&lt;BUILT-IN-CLASS INTEGER&gt; #&lt;BUILT-IN-CLASS INTEGER&gt;)&gt;
&gt; (defmethod baz ((x integer) (y float))
       (format t "integer ~D, float ~E~%" x y))
#&lt;STANDARD-METHOD (#&lt;BUILT-IN-CLASS INTEGER&gt; #&lt;BUILT-IN-CLASS FLOAT&gt;)&gt;
&gt; (defmethod baz ((x float) (y float))
       (fomat t "float ~E, float ~E~%" x y))
#&lt;STANDARD-METHOD (#&lt;BUILT-IN-CLASS FLOAT&gt; #&lt;BUILT-IN-CLASS FLOAT&gt;)&gt;

&gt; (baz 1 2)
integer 1, integer 2
NIL
&gt; (baz 1 2.0)
integer 1, float 2.0E+0
NIL
&gt; (baz 1.0 2.0)
float 1.0E+0, float 2.0E+0
NIL
</pre>
<p> CLOS のメソッドは、クラスだけではなく通常のデータ型でも定義することができます。また、メソッドを定義する場合、引数の個数は同じでなければいけません。たとえば、最初に引数 2 個のメソッド baz を定義したら、引数 1 個の baz は定義できないのです。ご注意ください。
</p>
<p> ここではメソッド baz を 3 つ定義していますが、引数 x と y のデータ型により適切なメソッドが選択されます。もしも、引数 y はどんなデータ型でもよければ、次のようにデータ型の指定を省略することで実現できます。
</p>
<pre>
&gt; (defmethod baz ((x integer) y)
       (format t "integer ~D, other ~S~%" x y))
#&lt;STANDARD-METHOD (#&lt;BUILT-IN-CLASS INTEGER&gt; #&lt;BUILT-IN-CLASS T&gt;)&gt;
&gt; (baz 1 "test")
integer 1, other "test"
NIL
</pre>
<p> 引数 y にはデータ型の指定がないことに注意してください。例のように引数 x が整数値で引数 y が文字列の場合は、ここで定義したメソッドが選択されます。ただし、引数 y が float の場合は、前に定義したメソッドが選択されます。
</p>
<p> ここで defmethod の返り値に注目してください。引数のデータ型が表示されていますね。引数 y はデータ型を指定していないはずですが、y のデータ型は BUILT-IN-CLASS T になっています。実をいうと、メソッドの選択は「継承」と密接に関連しています。これは次回以降に詳しく説明しましょう。
</p>

<h4>●スロットのアクセス</h4>
<p> ここで、スロットのアクセスで役に立つ関数を紹介しましょう。今までは defclass の :accessor で指定したメソッドを使ってスロットにアクセスしました。このほかに、スロットは関数 slot-value でアクセスすることができます。
</p>
<pre class="item">
slot-value instance slot-name
</pre>
<p> slot-value はインスタンスのスロットに格納されている値を返します。また、setf と slot-value を使ってスロットの値を更新することができます。簡単な使用例を示しましょう。
</p>
<pre>
&gt; (defclass foo () ((a :initform 10 :initarg :a) (b :initform 20 :initarg :b)))
#&lt;STANDARD-CLASS FOO&gt;
&gt; (setq x (make-instance 'foo))
#&lt;FOO #x1028BC41&gt;
&gt; (slot-value x 'a)
10
&gt; (slot-value x 'b)
20
&gt; (slot-value x 'c)

*** - SLOT-VALUE: The class #&lt;STANDARD-CLASS FOO&gt; has no slot named C

&gt; (setf (slot-value x 'a) 100)
100
&gt; (slot-value x 'a)
100
</pre>

<p> スロット a, b を持つクラス foo を定義します。defclass の :assessor にはメソッドの指定がないことに注意してください。次に、make-instance でクラス foo のインスタンスを生成して変数 x にセットします。
</p>

<p> slot-value は :accessor にメソッドの指定がなくても、スロットにアクセスすることができます。slot-value でスロット a, b の値を求めると 10 と 20 になります。slot-value は関数なので引数は評価されます。スロット名はクオートすることをお忘れなく。また、(slot-value x 'c) はクラス foo にスロット c が存在しないのでエラーになります。
</p>
<p> 次に、(setf (slot-value x 'a) 100) でスロット a に 100 をセットします。そのあと slot-value でスロット a の値を求めると 100 に書き換えられていることがわかります。
</p>

<h4>●point クラス</h4>
<p> 最後に簡単な例として、点を表すクラスを作ってみましょう。名前は point にしました。x 座標をスロット x に、y 座標をスロット y に格納します。リスト 1 を見てください。
</p>
<pre class="list">
リスト 1 : point クラス

(defclass point ()
  ((x :accessor get-x :initform 0 :initarg :x)
   (y :accessor get-y :initform 0 :initarg :y)))

; 2 点間の距離を求める
(defmethod distance ((p1 point) (p2 point))
  (let ((dx (- (get-x p1) (get-x p2)))
        (dy (- (get-y p1) (get-y p2))))
    (sqrt (+ (* dx dx) (* dy dy)))))
</pre>
<p> define-class の :accessor でスロット x, y のアクセス関数 get-x, get-y を定義します。メソッド distance は point クラスのインスタンスを 2 つ受け取り、その距離を計算します。その中でアクセスメソッド get-x, get-y を呼び出して、スロット x, y の値を取得します。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
&gt; (setq p1 (make-instance 'point))
#&lt;POINT #x10255C39&gt;
&gt; (setq p2 (make-instance 'point :x 10 :y 10))
#&lt;POINT #x1025865D&gt;
&gt; (distance p1 p2)
14.142136
</pre>

<p> 次は、3 次元の座標を表す point3d クラスを作ります。リスト 2 を見てください。
</p>
<pre class="list">
リスト 2 : point3d クラス

(defclass point3d ()
  ((x :accessor get-x :initform 0 :initarg :x)
   (y :accessor get-y :initform 0 :initarg :y)
   (z :accessor get-z :initform 0 :initarg :z)))

(defmethod distance ((p1 point3d) (p2 point3d))
  (let ((dx (- (get-x p1) (get-x p2)))
        (dy (- (get-y p1) (get-y p2)))
        (dz (- (get-z p1) (get-z p2))))
    (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))
</pre>
<p> クラス point3d は point を 3 次元に拡張しただけです。このように、point でも point3d でも距離を計算するメソッド distance を定義することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; (setq p3 (make-instance 'point3d))
#&lt;POINT3D #x10280FAD&gt;
&gt; (setq p4 (make-instance 'point3d :x 10 :y 10 :z 10))
#&lt;POINT3D #x10281DE5&gt;
&gt; (distance p3 p4)
17.320509
</pre>

<p> このように、引数のクラスによって適切なメソッドが呼び出され、ポリモーフィズムが働いていることがわかります。もしも、ポリモーフィズムを利用せずにプログラムすると、distance の中でインスタンスのクラスをチェックしなければいけません。述語 typep を使って distance を書き換えると、リスト 3 のようになります。
</p>
<pre class="list">
リスト 3 : ポリモーフィズムを使わない distance

(defun distance (p1 p2)
  (cond ((and (typep p1 'point) (typep p2 'point))
         (let ((dx (- (get-x p1) (get-x p2)))
               (dy (- (get-y p1) (get-y p2))))
           (sqrt (+ (* dx dx) (* dy dy)))))
        ((and (typep p1 'point3d) (typep p2 'point3d))
         (let ((dx (- (get-x p1) (get-x p2)))
               (dy (- (get-y p1) (get-y p2)))
               (dz (- (get-z p1) (get-z p2))))
           (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))
        (t (error "distance -- oops!"))))
</pre>
<pre>
&gt; (distance p1 p2)
14.142136
&gt; (distance p3 p4)
17.320509
&gt; (distance p1 p4)

*** - distance -- oops!
</pre>

<p> distance は 2 つのデータを扱うだけなので、プログラムはそれほど複雑にはなりません。しかし、たくさんのデータを扱うようになると、それだけプログラムは複雑になります。とくに新しいデータを追加する場合、プログラムの内部でデータの種別をチェックしている箇所をすべて調べて、そこに新しい処理を追加しなければいけません。プログラムの規模が大きくなると、修正箇所を調べるだけでも大変です。
</p>

<p> ところが、ポリモーフィズムを使ってプログラムを作ると、新しいデータを追加するにしても、そのデータを表すクラスとメソッドを定義するだけでいいのです。あとは CLOS がインスタンスに合わせて適切なメソッドを呼び出してくれます。オブジェクト指向では、オブジェクトをひとつの部品として扱います。新しい部品を追加するにしても、今までの部品を修正せずにそのまま使えた方が便利です。ポリモーフィズムはオブジェクト指向に必須の機能なのです。 
</p>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2003-2010 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ PrevPage | <a href="index.html#clos">CLOS</a> | <a href="clisp02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>