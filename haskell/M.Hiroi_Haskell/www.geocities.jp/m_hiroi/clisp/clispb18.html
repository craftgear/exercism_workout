<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門 : 番外編</title>
  <meta name="description" content="Common Lisp, Common Lisp 入門, 番外編">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881768</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>Common Lisp 入門：番外編</h2>
<div class="small">
[ <a href="clispb17.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb19.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap16">Common Lisp で作る micro Scheme コンパイラ (3)</h3>
<p> 今回は micro Scheme に「継続 (continuation) 」を導入します。拙作のページ <a href="clispb14.html">Common Lisp で作る micro Scheme (3)</a> では、インタプリタを「継続渡しスタイル」で書き直すことで「継続」を実装しました。SECD 仮想マシンの場合、継続を導入するのはとても簡単です。継続の取得はレジスタ S, E, C, D を保存するだけでよいのです。継続を再開するのも保存しておいた各レジスタを元に戻すだけですみます。
</p>

<p> なお、このプログラムは拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> <a href="../func/abcscm35.html">micro Scheme コンパイラの作成 (3)</a> のプログラムを Common Lisp で書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>
<h4>●call/cc のコンパイル</h4>
<p> それではプログラムを作りましょう。仮想マシンに継続を取得する命令 ldct を追加します。ldct の状態遷移を示します。
</p>
<pre class="item">
s e (ldct code . c) d =&gt; ((continuation s e code d) . s) e c d
</pre>
<p> 継続はリストで表します。先頭にシンボル continuation を付けて、その後ろに s, e, code, d を格納します。code は call/cc のあとに実行するコードで、call/cc をコンパイルするときにセットされます。コード c には call/cc の引数を評価して、それを呼び出す命令がセットされます。このとき、生成した継続が引数として渡されます。
</p>

<p> call/cc のコンパイルは次のようになります。
</p>
<pre class="list">
リスト : call/cc のコンパイル

(defun comp (expr env code)
  ...
        ((eq (car expr) 'call/cc)
         (list* 'ldct code 'args 1 (comp (cadr expr) env (cons 'app code))))
  ...
)
</pre>
<p> call/cc の後に実行する命令は comp の引数 code に格納されています。命令 ldct のあとに code を格納します。call/cc の引数に渡される値は関数で、その関数に生成した継続を渡します。args でスタックに積まれた継続を取り出してリストに格納します。そして、call/cc の引数 (cadr expr) を comp でコンパイルします。値は関数になるはずなので、それを命令 app で呼び出します。
</p>

<h4>●ldct の追加と app の修正</h4>
<p> 次は仮想マシン vm を修正します。命令 ldct を追加して、継続を実行できるように命令 app を修正します。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 仮想マシンに継続の処理を追加

(defun vm (s e c d)
  (loop
    (case (pop c)
      ...
      ((ldct)
       (push (list 'continuation s e (pop c) d) s))
      ...
      ((app)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (push (list s e c) d)
            (setq s nil
                  e (cons lvar (cadr clo))
                  c (car clo))))))
      ...
  )))
</pre>
<p> ldct は状態遷移をそのままプログラムしただけです。継続を実行する場合、継続に渡した引数 (1 個) が call/cc の返り値となります。SECD 仮想マシンの場合、返り値はスタックに積まれます。保存しておいた S, E, C, D レジスタの値を元に戻して、スタックに引数の値 (car lvar) を追加します。これでプログラムの実行を再開することができます。
</p>

<h4>●apply の実装</h4>
<p> 最後に高階関数 apply を追加します。apply は継続のテストで使用します。apply は引数に特別な処理が必要になるので、仮想マシンに新しい命令 args-ap を追加します。コンパイルは次のようになります。
</p>
<pre class="list">
リスト : apply のコンパイル

(defun comp (expr env code)
  ...
        ((eq (car expr) 'apply)
         (complis (cddr expr)
                  env
                  (list* 'args-ap
                         (length (cddr expr))
                         (comp (cadr expr) env (cons 'app code)))))
  ...
)
</pre>
<p> 関数呼び出しの処理と同様に、complis で引数を評価するコードを生成します。このとき、引数は (cddr expr) になることに注意してください。そして、命令 args-ap のあとに、2 番目の引数 (cadr expr) を comp でコンパイルし、それを命令 app で呼び出します。
</p>

<p> 次は仮想マシン vm に命令 args-ap を追加します。
</p>

<pre class="list">
リスト : 命令 args-ap の追加

(defun vm (s e c d)
  (loop
    (case (pop c)
      ...
      ((args-ap)
       (let ((a (copy-list (pop s))))
         (dotimes (n (1- (pop c)) (push a s))
           (push (pop s) a))))
      ...
  )))
</pre>
<p> apply に与えられる最後の引数はリストです。args-ap は最後の引数の先頭に、今までの引数を追加して返します。このとき、最後の引数 (リスト) を copy-list でコピーしないと、可変個引数の関数を呼び出して引数の値を書き換えるときに不具合が発生します。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
&gt;&gt;&gt; (apply cons '(1 2))
(1 . 2)

&gt;&gt;&gt; (apply cons 1 '(2))
(1 . 2)

&gt;&gt;&gt; (define a '(1 2 3 4 5))
A

&gt;&gt;&gt; (define foo (lambda (a b . c) (set! a 10) (set! b 20) (set! c 30)))
FOO

&gt;&gt;&gt; (apply foo a)
30

&gt;&gt;&gt; a
(1 2 3 4 5)
</pre>
<p> apply で関数 foo を呼び出すとき、最後の引数 (リスト) をコピーしないと、変数 a の値が (10 20 . 30) に書き換えられてしまいます。
</p>
<p> 最後に、継続のテストで使うため *global-environment* に関数 display と newline を追加します。これでプログラムの修正は完了です。
</p>
<h4>●簡単な実行例</h4>
<p> それでは実際に継続を使ってみましょう。なお、継続の実行例は拙作のページ <a href="clispb14.html">Common Lisp で作る micro Scheme (3)</a> で作成したプログラムとまったく同じです。インタプリタでもコンパイラでも継続の動作は同じになります。
</p>
<pre>
&gt;&gt;&gt; (define a false)
A
&gt;&gt;&gt; (define list (lambda x x))
LIST
&gt;&gt;&gt; (list 'a 'b (call/cc (lambda (k) (set! a k) 'c)) 'd)
(A B C D)
&gt;&gt;&gt; (a 'e)
(A B E D)
&gt;&gt;&gt; (a 'f)
(A B F D)
</pre>
<p> 変数 a に取り出した継続をセットします。この場合、継続は (list a b [ ] 'd) になります。list の処理だけではなく、'd を評価する処理も残っています。継続 a に引数を渡して評価すると、[ ] の部分に継続の引数がセットされ、'd を評価して list に渡されます。したがって、(a 'e) を評価すると (a b e d) になり、(a 'f) を評価すると (a b f d) になります。
</p>
<h4>●大域脱出</h4>
<p> 次は大域脱出を試してみましょう。
</p>
<pre class="list">
リスト : 大域脱出

(define bar1 (lambda (cont) (display "call bar1") (newline)))
(define bar2 (lambda (cont) (display "call bar2") (newline) (cont false)))
(define bar3 (lambda (cont) (display "call bar3") (newline)))
(define test (lambda (cont) (bar1 cont) (bar2 cont) (bar3 cont)))
</pre>
<pre>
&gt;&gt;&gt; (call/cc (lambda (cont) (test cont)))
call bar1
call bar2
FALSE
</pre>
<p> bar2 からトップレベルへ脱出するので、bar3 は呼び出されていません。
</p>
<h4>●繰り返しからの脱出</h4>
<p> 当然ですが、繰り返しから脱出することもできます。次の例を見てください。
</p>
<pre class="list">
リスト : do から脱出する場合

(define find-do
  (lambda (fn ls)
    (call/cc
      (lambda (k)
        (do ((xs ls (cdr xs)))
            ((null? xs) false)
          (if (fn (car xs)) (k (car xs))))))))
</pre>
<p> リスト ls から関数 fn が真を返す要素を探します。継続のテストということで、あえて do を使って実装しています。fn が真を返す場合、継続 k でその要素を返します。それでは実行してみましょう。
</p>
<pre>
&gt;&gt;&gt; (find-do (lambda (x) (eq? 'c x)) '(a b c d e))
C
&gt;&gt;&gt; (find-do (lambda (x) (eq? 'c x)) '(a b d e f))
FALSE
</pre>
<p> もちろん高階関数からも脱出することができます。
</p>
<pre class="list">
リスト : map から脱出する場合

(define map-check (lambda (fn chk ls)
  (call/cc
    (lambda (k)
      (map (lambda (x) (if (chk x) (k '()) (fn x))) ls)))))
</pre>
<pre>
&gt;&gt;&gt; (map-check (lambda (x) (cons x x)) (lambda (x) (eq? x 'e)) '(a b c d e f))
NIL
&gt;&gt;&gt; (map-check (lambda (x) (cons x x)) (lambda (x) (eq? x 'e)) '(a b c d f))
((A . A) (B . B) (C . C) (D . D) (F . F))
</pre>
<p> 関数 chk が真となる要素がある場合、処理を中断して空リストを返します。これも正常に動いていますね。
</p>
<h4>●再帰呼び出しからの脱出</h4>
<p> 再帰呼び出しから脱出することも簡単です。
</p>
<pre class="list">
リスト : flatten の再帰呼び出しから脱出する場合

(define flatten (lambda (ls)
  (call/cc
    (lambda (cont)
      (letrec ((flatten-sub
                (lambda (ls)
                  (cond ((null? ls) '())
                        ((not (pair? ls)) (list ls))
                        ((null? (car ls)) (cont '()))
                        (else (append (flatten-sub (car ls))
                                      (flatten-sub (cdr ls))))))))
        (flatten-sub ls))))))
</pre>
<p> 関数 flatten はリストを平坦化します。ただし、要素に空リストが含まれている場合は空リストを返します。flatten は継続 cont を取り出して局所関数 flatten-sub に渡します。flatten-sub は空リストを見つけたら継続 cont を評価します。そうすると、再帰呼び出しの処理は破棄されて flatten の処理に戻り、cont に渡した空リストが返り値となります。
</p>
<pre>
&gt;&gt;&gt; (flatten '(a (b (c (d . e) f) g) h))
(A B C D E F G H)
&gt;&gt;&gt; (flatten '(a (b (c (d () . e) f) g) h))
NIL
</pre>
<h4>●イテレータの生成</h4>
<p> 最後に、イテレータを生成する関数 make-iter を試してみます。
</p>
<pre class="list">
リスト : イテレータを生成する関数

(define (make-iter proc . args)
  (letrec ((iter
            (lambda (return)
              (apply 
                proc
                (lambda (x)             ; 高階関数に渡す関数の本体
                  (set! return          ; 脱出先継続の書き換え
                   (call/cc
                    (lambda (cont)
                      (set! iter cont)  ; 継続の書き換え
                      (return x)))))
                args)
                ; 終了後は継続 return で脱出
                (return false))))
    (lambda ()
      (call/cc
        (lambda (cont) (iter cont))))))
</pre>
<pre class="list">
リスト : 木の高階関数

(define (for-each-tree fn ls)
  (let loop ((ls ls))
    (cond ((null? ls) '())
          ((pair? ls)
           (loop (car ls))
           (loop (cdr ls)))
          (else (fn ls)))))
</pre>
<p> 拙作のページ <a href="../func/scheme.html">お気楽 Scheme プログラミング入門</a> <a href="../func/abcscm20.html">継続と継続渡しスタイル</a> で作成したプログラムと同じです。それでは実行してみましょう。
</p>
<pre>
&gt;&gt;&gt; (define a (make-iter for-each-tree '(a (b (c (d . e) f) g) h)))
A
&gt;&gt;&gt; (a)
A
&gt;&gt;&gt; (a)
B
&gt;&gt;&gt; (a)
C
&gt;&gt;&gt; (a)
D
&gt;&gt;&gt; (a)
E
&gt;&gt;&gt; (a)
F
&gt;&gt;&gt; (a)
G
&gt;&gt;&gt; (a)
H
&gt;&gt;&gt; (a)
FALSE
</pre>
<p> 正常に動作していますね。
</p>
<p> 今回はここまでです。次回は「末尾再帰最適化」の実装に挑戦してみましょう。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
;
; secd.l : SECD 仮想マシンによる Scheme コンパイラ
;
;          (1) 基本機能の実装
;          (2) 伝統的なマクロの実装
;          (3) 継続の実装
;
;          Copyright (C) 2009 Makoto Hiroi
;

; 大域変数
(defvar *global-environment* nil)

; 変数の位置を求める
(defun position-var (sym ls)
  (labels ((iter (i ls)
             (cond ((null ls) nil)
                   ((symbolp ls)
                    (if (eq sym ls) (- (1+ i)) nil))
                   ((eq sym (car ls)) i)
                   (t (iter (1+ i) (cdr ls))))))
    (iter 0 ls)))

; フレームと変数の位置を求める
(defun location (sym ls)
  (labels ((iter (i ls)
             (if (null ls)
                 nil
               (let ((j (position-var sym (car ls))))
                 (if j
                     (cons i j)
                   (iter (1+ i) (cdr ls)))))))
    (iter 0 ls)))

; 自己評価フォームか
(defun self-evaluation-p (expr)
  (and (atom expr) (not (symbolp expr))))

; マクロか
(defun macro-p (expr)
  (let ((val (assoc expr *global-environment*)))
    (and val (consp (cdr val)) (eq 'macro (cadr val)))))

; マクロのコードを取り出す
(defun get-macro-code (expr)
  (caddr (get-gvar expr)))

; S 式をコンパイルする
(defun compile-expr (expr)
  (comp expr '() '(stop)))

; コンパイル本体
(defun comp (expr env code)
  (cond ((self-evaluation-p expr)
         (list* 'ldc expr code))
        ((symbolp expr)
         (let ((pos (location expr env)))
           (if pos
               ; 局所変数
               (list* 'ld pos code)
             ; 大域変数
             (list* 'ldg expr code))))
        ((eq (car expr) 'quote)
         (list* 'ldc (cadr expr) code))
        ((eq (car expr) 'if)
         (let ((t-clause (comp (caddr expr) env '(join)))
               (f-clause
                (if (null (cdddr expr))
                    (list 'ldc '*undef* 'join)
                  (comp (cadddr expr) env '(join)))))
           (comp (cadr expr) env (list* 'sel t-clause f-clause code))))
        ((eq (car expr) 'lambda)
         (let ((body (comp-body (cddr expr) (cons (cadr expr) env) '(rtn))))
           (list* 'ldf body code)))
        ((eq (car expr) 'define)
         (comp (caddr expr) env (list* 'def (cadr expr) code)))
        ((eq (car expr) 'define-macro)
         (comp (caddr expr) env (list* 'defm (cadr expr) code)))
        ((eq (car expr) 'set!)
         (let ((pos (location (cadr expr) env)))
           (if pos
               ; 局所変数
               (comp (caddr expr) env (list* 'lset pos code))
             ; 大域変数
             (comp (caddr expr) env (list* 'gset (cadr expr) code)))))
        ((eq (car expr) 'call/cc)
         (list* 'ldct code 'args 1 (comp (cadr expr) env (cons 'app code))))
        ((eq (car expr) 'apply)
         (complis (cddr expr)
                  env
                  (list* 'args-ap
                         (length (cddr expr))
                         (comp (cadr expr) env (cons 'app code)))))
        ((macro-p (car expr))
         ; マクロ展開してからコンパイルする
         (let ((new-expr (vm '()
                             (list (cdr expr))
                             (get-macro-code (car expr))
                             (list (list '() '() '(stop))))))
           (comp new-expr env code)))
        (t  ; 関数呼び出し
         (complis (cdr expr)
                  env
                  (list* 'args
                         (length (cdr expr))
                         (comp (car expr) env (cons 'app code)))))))

; body のコンパイル
(defun comp-body (body env code)
  (if (null (cdr body))
      (comp (car body) env code)
    (comp (car body)
          env
          (list* 'pop
                 (comp-body (cdr body) env code)))))

; 引数を評価するコードを生成する
(defun complis (expr env code)
  (if (null expr)
      code
    (comp (car expr) env (complis (cdr expr) env code))))

;;; 仮想マシン

; 局所変数の値を求める
(defun get-lvar (e i j)
  (if (&lt;= 0 j)
      (nth j (nth i e))
    (nthcdr (- (1+ j)) (nth i e))))

; 局所変数の値を更新する
(defun set-lvar (e i j val)
  (if (&lt;= 0 j)
      (setf (nth j (nth i e)) val)
    (if (= j -1)
        (rplaca (nthcdr i e) val)
      (rplacd (nthcdr (- (+ j 2)) (nth i e)) val))))

; 大域変数の値を求める
(defun get-gvar (sym)
  (let ((val (assoc sym *global-environment*)))
    (if val
        (cdr val)
      (error "unbound variable: ~S" sym))))

; 大域変数の値を書き換える
(defun set-gvar (sym val)
  (let ((cell (assoc sym *global-environment*)))
    (if cell
        (rplacd cell val)
      (error "unbound variable: " sym))))

; 仮想マシンでコードを実行する
(defun vm (s e c d)
  (loop
    (case (pop c)
      ((ld)
       (let ((pos (pop c)))
         (push (get-lvar e (car pos) (cdr pos)) s)))
      ((ldc)
       (push (pop c) s))
      ((ldg)
       (push (get-gvar (pop c)) s))
      ((ldf)
       (push (list 'closure (pop c) e) s))
      ((ldct)
       (push (list 'continuation s e (pop c) d) s))
      ((lset)
       (let ((pos (pop c)))
         (set-lvar e (car pos) (cdr pos) (car s))))
      ((gset)
       (set-gvar (pop c) (car s)))
      ((app)
       (let ((clo (pop s)) (lvar (pop s)))
         (case (pop clo)
           ((primitive)
            (push (apply (car clo) lvar) s))
           ((continuation)
            (setq s (cons (car lvar) (car clo))
                  e (cadr clo)
                  c (caddr clo)
                  d (cadddr clo)))
           (t
            (push (list s e c) d)
            (setq s nil
                  e (cons lvar (cadr clo))
                  c (car clo))))))
      ((rtn)
       (let ((save (pop d)))
         (setq s (cons (car s) (car save))
               e (cadr save)
               c (caddr save))))
      ((sel)
       (let ((t-clause (pop c))
             (e-clause (pop c)))
         (push c d)
         (setq c (if (eq (pop s) 'false) e-clause t-clause))))
      ((join)
       (setq c (pop d)))
      ((pop) (pop s))
      ((args)
       (let ((a nil))
         (dotimes (n (pop c) (push a s))
           (push (pop s) a))))
      ((args-ap)
       (let ((a (copy-list (pop s))))
         (dotimes (n (1- (pop c)) (push a s))
           (push (pop s) a))))
      ((def)
       (let ((sym (pop c)))
         (push (cons sym (pop s)) *global-environment*)
         (push sym s)))
      ((defm)
       (let ((sym (pop c)))
         (push (cons sym (cons 'macro (pop s))) *global-environment*)
         (push sym s)))
      ((stop) (return (car s)))
      (t (error "unknown opcode")))))

; 大域変数
(setq *global-environment*
      (list
       (cons 'true  'true)
       (cons 'false 'false)
       (cons 'nil   'nil)
       (cons 'quit  'quit)
       (list 'car   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- car: NIL")
                                     (car x))))
       (list 'cdr   'primitive #'(lambda (x)
                                   (if (null x)
                                       (error "type error -- cdr: NIL")
                                     (cdr x))))
       (list 'cons  'primitive #'cons)
       (list 'eq?   'primitive #'(lambda (x y) (if (eq x y) 'true 'false)))
       (list 'eqv?  'primitive #'(lambda (x y) (if (eql x y) 'true 'false)))
       (list 'pair? 'primitive #'(lambda (x) (if (consp x) 'true 'false)))
       (list 'display 'primitive (lambda (x) (princ x) '*undef*))
       (list 'newline 'primitive (lambda () (terpri) '*undef*))
       ))

;;; read-eval-print-loop

(defun change-readtable ()
  (set-macro-character
   #\`
   #'(lambda (stream char)
       (declare (ignore char))
       (list 'backquote (read stream t nil t))))
  (set-macro-character
   #\,
   #'(lambda (stream char)
       (declare (ignore char))
       (cond ((char= (peek-char nil stream) #\@)
              (read-char stream)
              (list 'splice (read stream t nil t)))
             (t (list 'unquote (read stream t nil t)))))))

(defun repl (&amp;rest file-list)
  (unwind-protect
      (progn
        (change-readtable)
        (dolist (file file-list)
          (with-open-file (in file :direction :input)
            (do ((output t))
                ((eq output nil) (terpri))
              (setf output (vm '() '() (compile-expr (read in nil)) '()))
              (print output))))
        (do ((output nil))
            ((eq output 'quit))
          (princ "&gt;&gt;&gt; ")
          (force-output)
          (let ((expr (compile-expr (read))))
            (setf output (vm '() '() expr '()))
            (princ output)
            (terpri))))
    (setq *readtable* (copy-readtable nil))))
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
;
; mlib.scm : micro Scheme 用ライブラリ
;
;            Copyright (C) 2009 Makoto Hiroi
;

;;; 述語

(define null? (lambda (x) (eq? x '())))
(define not (lambda (x) (if (eq? x false) true false)))

;;; リスト操作関数

(define cadr (lambda (x) (car (cdr x))))
(define cdar (lambda (x) (cdr (car x))))
(define caar (lambda (x) (car (car x))))
(define cddr (lambda (x) (cdr (cdr x))))
(define cadar (lambda (x) (car (cdr (car x)))))

;
(define list (lambda args args))

; リストの結合
(define append
  (lambda (xs ys)
    (if (null? xs)
        ys
      (cons (car xs) (append (cdr xs) ys)))))

; リストの探索
(define memq
  (lambda (x ls)
    (if (null? ls)
        false
        (if (eq? x (car ls))
            ls
          (memq x (cdr ls))))))

;
(define memv
  (lambda (x ls)
    (if (null? ls)
        false
        (if (eqv? x (car ls))
            ls
          (memv x (cdr ls))))))

; 連想リストの探索
(define assq
  (lambda (x ls)
    (if (null? ls)
        false
      (if (eq? x (car (car ls)))
          (car ls)
        (assq x (cdr ls))))))

;
(define assv
  (lambda (x ls)
    (if (null? ls)
        false
      (if (eqv? x (car (car ls)))
          (car ls)
        (assv x (cdr ls))))))

;;; 高階関数

; マップ
(define map
  (lambda (fn ls)
    (if (null? ls)
        '()
      (cons (fn (car ls)) (map fn (cdr ls))))))

;
(define map-2
  (lambda (fn xs ys)
    (if (null? xs)
        '()
      (cons (fn (car xs) (car ys)) (map-2 fn (cdr xs) (cdr ys))))))

; フィルター
(define filter
  (lambda (fn ls)
    (if (null? ls)
        '()
      (if (fn (car ls))
          (cons (car ls) (filter fn (cdr ls)))
        (filter fn (cdr ls))))))

; 畳み込み
(define fold-right
  (lambda (fn a ls)
    (if (null? ls)
        a
      (fn (car ls) (fold-right fn a (cdr ls))))))

;
(define fold-left
  (lambda (fn a ls)
    (if (null? ls)
        a
      (fold-left fn (fn a (car ls)) (cdr ls)))))

;;; マクロ

; quasiquote
(define transfer
  (lambda (ls)
    (if (pair? ls)
        (if (pair? (car ls))
            (if (eq? (caar ls) 'unquote)
                (list 'cons (cadar ls) (transfer (cdr ls)))
              (if (eq? (caar ls) 'splice)
                  (list 'append (cadar ls) (transfer (cdr ls)))
                (list 'cons (transfer (car ls)) (transfer (cdr ls)))))
          (list 'cons (list 'quote (car ls)) (transfer (cdr ls))))
      (list 'quote ls))))

(define-macro backquote (lambda (x) (transfer x)))

; let
(define-macro let
  (lambda (args . body)
    (if (pair? args)
        `((lambda ,(map car args) ,@body) ,@(map cadr args))
      ; named-let
      `(letrec ((,args (lambda ,(map car (car body)) ,@(cdr body))))
        (,args ,@(map cadr (car body)))))))

; and
(define-macro and
  (lambda args
    (if (null? args)
        true
      (if (null? (cdr args))
          (car args)
        `(if ,(car args) (and ,@(cdr args)) false)))))

; or
(define-macro or
  (lambda args
    (if (null? args)
        false
      (if (null? (cdr args))
          (car args)
        `(let ((+value+ ,(car args)))
          (if +value+ +value+ (or ,@(cdr args))))))))

; let*
(define-macro let*
  (lambda (args . body) 
    (if (null? (cdr args))
        `(let (,(car args)) ,@body)
      `(let (,(car args)) (let* ,(cdr args) ,@body)))))

; letrec
(define-macro letrec
  (lambda (args . body)
    (let ((vars (map car args))
          (vals (map cadr args)))
      `(let ,(map (lambda (x) `(,x '*undef*)) vars)
            ,@(map-2 (lambda (x y) `(set! ,x ,y)) vars vals)
            ,@body))))

; begin
(define-macro begin
  (lambda args
    (if (null? args)
        `((lambda () '*undef*))
      `((lambda () ,@args)))))


; cond
(define-macro cond
  (lambda args
    (if (null? args)
        '*undef*
      (if (eq? (caar args) 'else)
          `(begin ,@(cdar args))
        (if (null? (cdar args))
            `(let ((+value+ ,(caar args)))
              (if +value+ +value+ (cond ,@(cdr args))))
          `(if ,(caar args)
               (begin ,@(cdar args))
            (cond ,@(cdr args))))))))

; case
(define-macro case
  (lambda (key . args)
    (if (null? args)
        '*undef*
      (if (eq? (caar args) 'else)
          `(begin ,@(cdar args))
        `(if (memv ,key ',(caar args))
             (begin ,@(cdar args))
           (case ,key ,@(cdr args)))))))

; do
(define-macro do
  (lambda (var-form test-form . args)
    (let ((vars (map car var-form))
          (vals (map cadr var-form))
          (step (map cddr var-form)))
      `(letrec ((loop (lambda ,vars
                              (if ,(car test-form)
                                  (begin ,@(cdr test-form))
                                (begin
                                  ,@args
                                  (loop ,@(map-2 (lambda (x y)
                                                   (if (null? x) y (car x)))
                                                 step
                                                 vars)))))))
        (loop ,@vals)))))

; do のテスト
(define reverse-do
  (lambda (xs)
    (do ((ls xs (cdr ls)) (result '()))
        ((null? ls) result)
      (set! result (cons (car ls) result)))))

; cond のテスト
(define cond-test
  (lambda (x)
    (cond ((eq? x 'a) 1)
          ((eq? x 'b) 2)
          ((eq? x 'c) 3)
          (else 0))))

; case のテスト
(define case-test
  (lambda (x)
    (case x
      ((a b c) 1)
      ((d e f) 2)
      ((g h i) 3)
      (else    0))))

;;; マクロを使った関数の定義

;
(define reverse
  (lambda (ls)
    (letrec ((iter (lambda (ls a)
                     (if (null? ls)
                         a
                       (iter (cdr ls) (cons (car ls) a))))))
      (iter ls '()))))

;
(define reversei
  (lambda (ls)
    (let loop ((ls ls) (a '()))
      (if (null? ls)
          a
          (loop (cdr ls) (cons (car ls) a))))))

;;; 継続のテスト

; 大域脱出
(define bar1 (lambda (cont) (display "call bar1") (newline)))
(define bar2 (lambda (cont) (display "call bar2") (newline) (cont false)))
(define bar3 (lambda (cont) (display "call bar3") (newline)))
(define test (lambda (cont) (bar1 cont) (bar2 cont) (bar3 cont)))

; 繰り返しからの脱出
(define find-do
  (lambda (fn ls)
    (call/cc
      (lambda (k)
        (do ((xs ls (cdr xs)))
            ((null? xs) false)
          (if (fn (car xs)) (k (car xs))))))))

; 高階関数からの脱出
(define map-check (lambda (fn chk ls)
  (call/cc
    (lambda (k)
      (map (lambda (x) (if (chk x) (k '()) (fn x))) ls)))))

; 再帰呼び出しからの脱出
(define flatten (lambda (ls)
  (call/cc
    (lambda (cont)
      (letrec ((flatten-sub
                (lambda (ls)
                  (cond ((null? ls) '())
                        ((not (pair? ls)) (list ls))
                        ((null? (car ls)) (cont '()))
                        (else (append (flatten-sub (car ls))
                                      (flatten-sub (cdr ls))))))))
        (flatten-sub ls))))))

; イテレータを生成する関数
(define make-iter
 (lambda (proc . args)
  (letrec ((iter
            (lambda (return)
              (apply 
                proc
                (lambda (x)             ; 高階関数に渡す関数の本体
                  (set! return          ; 脱出先継続の書き換え
                   (call/cc
                    (lambda (cont)
                      (set! iter cont)  ; 継続の書き換え
                      (return x)))))
                args)
                ; 終了後は継続 return で脱出
                (return false))))
    (lambda ()
      (call/cc
        (lambda (cont) (iter cont)))))))

; 木の高階関数
(define for-each-tree
 (lambda (fn ls)
  (let loop ((ls ls))
    (cond ((null? ls) '())
          ((pair? ls)
           (loop (car ls))
           (loop (cdr ls)))
          (else (fn ls))))))
</pre>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="clispb17.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb19.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>