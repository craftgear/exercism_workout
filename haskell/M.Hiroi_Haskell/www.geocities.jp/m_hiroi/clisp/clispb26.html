<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門 : 番外編</title>
  <meta name="description" content="Common Lisp, Common Lisp 入門, 番外編">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881770</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Common Lisp Programming</h1>
<h2>Common Lisp 入門：番外編</h2>
<div class="small">
[ <a href="clispb25.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb27.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>●適応型レンジコーダ</h3>
<p> <a href="../xyzzy_lisp.html#abclisp">Common Lisp 入門</a> の番外編です。今回は適応型レンジコーダを説明して、実際にファイルを圧縮してみましょう。なお、このドキュメントは拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo37.html">レンジコーダ [2]</a> <a href="../light/pyalgo38.html">[3]</a> のプログラムを Common Lisp で書き直したものです。内容は重複しますが、あしからずご了承ください。
</p>

<h4>●静的符号化と動的符号化</h4>
<p> 今まで説明したハフマン符号やレンジコーダは「静的符号化 (static coding) 」といい、あらかじめ記号の出現確率を調べておいて、それに基づいて入力記号列を符号化していく方法です。この方法では、ハフマン符号がもっとも有名でしょう。
</p>

<p> これに対し「動的符号化 (dynamic coding) 」は、入力記号列の符号化を行いながら記号の出現確率を変化させる方法で、「適応型符号化 (adaptive coding) 」とも呼ばれています。最初は、どの記号も同じ確率で出現すると仮定して、記号列を読み込みながら記号の出現確率を修正し、その時点での出現確率に基づいて記号の符号化を行います。なお、辞書法の LZ 符号も動的符号化の一つです。
</p>

<p> 動的符号化の特徴は入力記号列の性質（出現確率）の変化に適応できることですが、このほかにも長所があります。静的符号化の場合、復号するときに符号化で用いた記号の出現確率が必要になります。このため、レンジコーダのプログラムでは、記号の出現頻度表を出力ファイルの先頭に付加しています。ところが、動的符号化では復号しながら記号の出現確率を求めることができるので、出現頻度表をファイルに付加する必要はありません。
</p>

<p> また、静的符号化でファイルを圧縮する場合、記号の出現頻度を求めるときにファイルからデータを読み込み、符号化を行うときに再度ファイルからデータを読み込む必要があります。このようにデータの入力が 2 回必要な圧縮アルゴリズムを「2 パスの圧縮アルゴリズム」といいます。動的符号化は 1 パスで済むので、オンラインでのデータ圧縮にも対応することができます。
</p>

<p> このように、動的符号化には有利な点があるため、ハフマン符号を動的符号化に対応させた「適応型ハフマン符号」が考案されています。しかしながら、適応型ハフマン符号は実装方法が難しく、処理速度も遅いという欠点があります。これに対し、「適応型算術符号（レンジコーダ）」は簡単な方法で実装することができ、適応型レンジコーダは処理速度もそれほど遅くありません。とても優れた実装方法なのです。
</p>

<p> ただし、適応型レンジコーダにもひとつだけ問題点があります。単純な方法では累積度数の取得や更新に時間がかかるのです。たとえば、記号の出現頻度表をベクタで表す場合、出現頻度の更新は簡単できますが、記号 c の累積度数を求めるとき、その都度 0 から c - 1 までの頻度を加算するようでは、実行時間が遅くなってしまいます。そこで、今回は Binary Indexed Tree というデータ構造を使うことにします。
</p>

<h4>●Binary Indexed Tree</h4>
<p> <a href="http://homepage3.nifty.com/wpage/">Yuta Mori さん</a> によると、<cite>『累積度数の取得・更新なら、P. Fenwick氏のBinary Indexed Tree (BIT)という方法が比較的高速』</cite> とのことです。Yuta Mori さんのプログラムは <a href="http://wpage.cocolog-nifty.com/wp/2009/07/binary-indexed-.html">Binary Indexed Treeの二分探索処理</a> で公開されています。今回は Yuta Mori さんのプログラムを参考に BIT を Common Lisp でプログラムしてみましょう。
</p>

<p> BIT は二分木をベースにした方法です。簡単な例として、記号の種類が 16 (0 - 15) の場合を考えてみましょう。BIT は下図のように二分木を構成します。
</p>

<pre class="fig">
                          ○８
                        ／  ＼
                      ／      ＼
                    ／          ＼
                  ／              ＼
                ／                  ＼
              ○４                    ○12
            ／  ＼                  ／  ＼
          ／      ＼              ／      ＼
        ○２        ○６        ○10        ○14
      ／  ＼      ／  ＼      ／  ＼      ／  ＼
○  ○      ○  ○      ○  ○      ○  ○      ○    
０  １      ３  ５      ７  ９      11  13      15


            図 : Binary Indexed Tree
</pre>

<p> BIT の場合、二分木の節に記号を対応させます。ただし、記号 0 は二分木の中に入れません。そして、節には記号の出現頻度を格納するのではなく、左部分木にある記号の出現頻度とその節の記号の出現頻度の合計値を格納します。たとえば、記号の出現頻度を 0 から順番に {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16} とすると、BIT の各節の値は次のようになります。
</p>
<pre class="fig">
                           ８(44)
                         ／  ＼
                       ／      ＼
                     ／          ＼
                   ／              ＼
                 ／                  ＼
               ４(14)                  12(46)
             ／  ＼                  ／  ＼
           ／      ＼              ／      ＼
         ２(5)       ６(13)      10(21)      14(29)
       ／  ＼      ／  ＼      ／  ＼      ／  ＼
 ０  １      ３  ５      ７  ９      11  13      15   
(１)(２)    (４)(６)    (８)(10)    (12)(14)    (16)


            図 : Binary Indexed Tree の構成
</pre>
<p> 記号 0 と「葉」にあたる節はその記号の出現頻度を表します。BIT の場合、奇数の記号は葉になります。葉以外の節は、左部分木にある記号の出現頻度の合計値にその節の記号の出現頻度を足した値を保持します。たとえば、節 10 の値は記号 9 と記号 10 の出現頻度を足した 21 になります。節 12 の値は、記号 9, 10, 11 と記号 12 の出現頻度を足した 46 になります。節 8 は記号 1 から 8 の出現頻度の合計 44 になります。このように二分木を構成すると、記号の出現頻度と累積度数を簡単に求めることができます。
</p>

<h4>●構造体の定義</h4>
<p> それではプログラムを作りましょう。最初に BIT を表す構造体を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : 構造体の定義

; 中央値 (ルート) を求める
(defun get-mid (size)
  (do ((mid 1 (ash mid 1))
       (limit (ash size -1)))
      ((&lt;= limit mid) mid)))

; bitree の定義
(defstruct (bitree
            (:constructor make-bitree
             (size
              &amp;aux
              (table (make-array size :initial-element 0))
              (mid (get-mid size))
              (sum 0))))
  size table mid sum)
</pre>
<p> 構造体の名前は bitree としました。スロット size は記号の種類、table はベクタ、mid はルートを表す中央値、sum は出現頻度の合計値です。:constructor で独自のコンストラクタ make-bitree を定義します。その中でベクタを生成して table にセットし、中央値を計算して mid にセットします。:constructor の使い方は拙作のページ Common Lisp 入門 <a href="../xyzzy_lisp/abclisp09.html#append">構造体：位置によるコンストラクタ</a> をお読みください。
</p>
<p> size が 2 の累乗の場合、mid は size / 2 で求めることができますが、そうでない場合は size / 2 &lt;= 2<sup>n</sup> を満たす最も小さな整数値 n を求めます。このときの 2<sup>n</sup> が中央値になります。それを関数 get-mid で求めています。
</p>
<h4>●累積度数の求め方</h4>
<p> 次は記号の累積度数を求めてみましょう。記号 12 の累積度数は記号 0 から 11 までの出現頻度の合計値になります。BIT の場合、記号 1 から 11 までの出現頻度の合計値は、節 11 からルート方向に木をたどり、記号 11 以下の節の値を足し算すると求めることができます。
</p>
<p> この場合、経路は 11 - 10 - 12 - 8 で、足し算する節は 11, 10, 8 になります。節 11 は記号 11 の出現頻度、節 10 は記号 9, 10 の出現頻度の合計値、節 8 は記号 1 - 8 の出現頻度の合計値なので、これで記号 1 - 11 の出現頻度の合計値を求めることができます。あとは、記号 0 の出現頻度を足し算すれば、累積度数を求めることができます。
</p>

<p> BIT の場合、次の式を使って値を足し算する節を求めることができます。
</p>
<pre class="list">
(logand c (1- c))
</pre>
<p> 実際に計算してみると次のようになります。
</p>
<pre>
 1 : 1
 2 : 2
 3 : 3 2
 4 : 4
 5 : 5 4
 6 : 6 4
 7 : 7 6 4
 8 : 8
 9 : 9 8
10 : 10 8
11 : 11 10 8
12 : 12 8
13 : 13 12 8
14 : 14 12 8
15 : 15 14 12 8
</pre>
<p> 上図の二分木をたどってみてください。同じ結果になります。このように、簡単な式で節をたどることができるとはちょっと驚きました。式についての説明は割愛いたしますので、興味のある方は <a href="http://www.cs.auckland.ac.nz/~peter-f/">P. Fenwick 氏</a> の論文 <CITE>"A New Data Structure for Cumulative Probability Tables"</CITE> をお読みください。
</p>

<p> 累積度数を求めるプログラムは次のようになります。
</p>

<pre class="list">
リスト : 累積度数を求める

(defun bitree-cumul (bt c)
  (if (zerop c)
      0
    (let ((n (aref (bitree-table bt) 0)))
      ; c - 1 までの頻度を加算する
      (do ((x (1- c) (logand x (1- x))))
          ((zerop x) n)
        (incf n (aref (bitree-table bt) x))))))
</pre>
<p> 引数 bt が BIT を表す構造体のオブジェクト、c が記号です。c が 0 の場合は 0 を返します。そうでなければ、変数 n に記号 0 の出現頻度をセットします。そのあと、変数 x を c - 1 に初期化し、(logand x (1- x)) で節をたどりながら、n に節の値を加算していきます。これで記号 c の累積度数を求めることができます。
</p>

<h4>●出現頻度の求め方</h4>
<p> 記号の出現頻度も簡単に求めることができます。記号 0 と記号が奇数の場合は、節の値をそのまま返せばいいですね。その他の場合、記号 c の累積度数から記号 c - 1 の累積度数を引き算すれば、記号 c の出現頻度を求めることができます。たとえば、記号 12 の出現頻度を求めてみましょう。次の式を見てください。
</p>
<pre class="fig">
  12の累積度数 - 11の累積度数
= ([12] + [8] + [0]) - ([11] + [10] + [8] + [0])
= [12] - [11] - [10]
= 46 - 12 - 21
= 13
</pre>
<p> このように、節 12 の次の節 8 以下の節は共通になるので計算する必要はありません。したがって、節 12 の値から節 11 と 10 の値を引き算すればいいわけです。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 記号の出現頻度を求める

(defun bitree-frequency (bt c)
  (let ((n (aref (bitree-table bt) c)))
    (if (or (zerop c) (oddp c))
        n
      (do ((p (logand c (1- c)))
           (x (1- c) (logand x (1- x))))
          ((= x p) n)
        (decf n (aref (bitree-table bt) x))))))
</pre>

<p> 節の値を変数 n にセットします。記号 0 と奇数の記号は n をそのまま返します。それ以外の場合、記号 c の次の節を変数 p に c - 1 の値を x にセットし、x の節の値を n から引き算します。あとは、(logand x (1- x)) で節をたどりながら、節の値を n から引き算すればいいわけです。x が p と等しくなったら do ループを終了して n を返します。
</p>

<h4>●出現頻度の更新</h4>
<p> 更新処理も簡単です。たとえば、記号 11 の出現頻度を +1 する場合、節 11 からルート方向に木をたどり、記号 11 以上の節の値を +1 します。この場合、経路は 11 - 10 - 12 - 8 で、+1 する節は 11, 12 になります。節 11 は記号 11 の出現頻度、節 12 は記号 9 から 12 の出現頻度の合計値で、他の節には記号 11 の値は含まれていません。節 11 と 12 の値を + 1 すればいいわけです。
</p>
<p> BIT の場合、次の式を使って更新する節を求めることができます。
</p>
<pre class="list">
(+ c (logand c (- c)))
</pre>
<p> 実際に計算してみると次のようになります。
</p>
<pre>
 1 : 1 2 4 8
 2 : 2 4 8
 3 : 3 4 8
 4 : 4 8
 5 : 5 6 8
 6 : 6 8
 7 : 7 8
 8 : 8
 9 : 9 10 12
10 : 10 12
11 : 11 12
12 : 12
13 : 13 14
14 : 14
15 : 15
</pre>
<p> 上図の二分木をたどってみてください。同じ結果になることがわかります。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 出現頻度の更新

(defun bitree-update (bt c inc)
  (if (zerop c)
      (incf (aref (bitree-table bt) c) inc)
    (do ()
        ((&lt;= (bitree-size bt) c))
      (incf (aref (bitree-table bt) c) inc)
      (incf c (logand c (- c)))))
  (incf (bitree-sum bt) inc))
</pre>

<p> (incf c (logand c (- c))) で節をたどりながら、節の値に inc を加算していきます。c が size 以上になったら終了です。最後に、記号の総数を表す sum に inc を加算します。
</p>

<h4>●記号の探索</h4>
<p> 最後に累積度数表 cumul から cumul[c] &lt;= val &lt; cumul[c + 1] を満たす記号 c を求める関数 bitree-find を作ります。
</p>
<pre class="list">
リスト : 記号の探索

(defun bitree-find (bt val)
  (let ((n (aref (bitree-table bt) 0)))
    (if (&lt; val n)
        (values 0 0)
      (do ((h (bitree-mid bt) (ash h -1))
           (c 0))
          ((zerop h) (values (1+ c) n))
        (when (and (&lt; (+ c h) (bitree-size bt))
                   (&lt;= (+ n (aref (bitree-table bt) (+ c h))) val))
          (incf n (aref (bitree-table bt) (+ c h)))
          (incf c h))))))
</pre>

<p> bitree-find は変数 n に累積度数を求めながら、復号する記号を二分探索します。記号 c を 0 に、変数 h を mid に初期化し、do ループで (c + h) の位置から二分探索を行い、value &lt;= 累積度数 を満たす一番大きな記号 c を探します。したがって、求める記号は c + 1 になります。探索の範囲は下限値が c で上限値が (c + h) になります。繰り返すたびに h を半分にすることで二分探索を実現しています。最後に c + 1 と n を返します。
</p>

<h4>●簡単な実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
* (defvar *bt* (make-bitree 16))

*BT*
* *bt*

#S(BITREE::BITREE
   :SIZE 16
   :TABLE #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
   :MID 8
   :SUM 0)
* (dotimes (x 16) (bitree-update *bt* x 2))

NIL
* *bt*

#S(BITREE::BITREE
   :SIZE 16
   :TABLE #(2 2 4 2 8 2 4 2 16 2 4 2 8 2 4 2)
   :MID 8
   :SUM 32)

* (dotimes (x 16) (format t "~D: ~D~%" x (bitree-frequency *bt* x)))
0: 2
1: 2
2: 2
3: 2
4: 2
5: 2
6: 2
7: 2
8: 2
9: 2
10: 2
11: 2
12: 2
13: 2
14: 2
15: 2
NIL

* (dotimes (x 16) (format t "~D: ~D~%" x (bitree-cumul *bt* x)))
0: 0
1: 2
2: 4
3: 6
4: 8
5: 10
6: 12
7: 14
8: 16
9: 18
10: 20
11: 22
12: 24
13: 26
14: 28
15: 30
NIL
* (dotimes (x 32) (format t "~D: ~D~%" x (bitree-find *bt* x)))
0: 0
1: 0
2: 1
3: 1
4: 2
5: 2
6: 3
7: 3
8: 4
9: 4
10: 5
11: 5
12: 6
13: 6
14: 7
15: 7
16: 8
17: 8
18: 9
19: 9
20: 10
21: 10
22: 11
23: 11
24: 12
25: 12
26: 13
27: 13
28: 14
29: 14
30: 15
31: 15
NIL
</pre>
<p> 正常に動作していますね。
</p>
<h4>●出現頻度表の初期化と更新</h4>
<p> 適応型レンジコーダの場合、出現頻度表をファイルに付加する必要がないため、記号の出現頻度を 2 バイトに丸める必要はありません。これは大きな利点です。あとは、出現頻度の合計値が幅 range の最小値 min-range より大きくならないように、出現頻度表を調整するだけです。この処理は、合計値 sum が min-range に達したときに、各記号の出現頻度を半分にすることで実現できます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 出現頻度表の初期化と更新

; 初期化
(defun initialize-bitree ()
  (let ((bt (make-bitree code-size)))
    (dotimes (x code-size bt)
      (bitree-update bt x 1))))

; 更新
(defun update (bt c inc)
  (bitree-update bt c inc)
  (when (&lt;= rangecoder::min-range (bitree-sum bt))
    (dotimes (x code-size)
      (let ((n (ash (bitree-frequency bt x) -1)))
        (when (plusp n)
          (bitree-update bt x (- n)))))))
</pre>
<p> 出現頻度表を初期化する関数 initialize-bitee は簡単です。make-bitree で BIT を生成し、各記号の出現頻度を 1 に設定するだけです。
</p>
<p> 出現頻度表を更新する関数 update も簡単です。bitree-update で記号 c の出現頻度を +inc します。そして、合計値 sum が min-range 以上になったならば、各記号の出現頻度を半分にします。変数 n に 出現頻度 / 2 をセットします。もし n が 0 ならば出現頻度は 1 なので、値を半分にする必要はありません。そうでなければ、bitree-update で出現頻度から n を減算します。これで各記号の値を半分にすることができます。
</p>

<h4>●適応型レンジコーダの符号化</h4>
<p> 次は符号化を行うメソッド encode を作ります。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 記号の符号化

(defun encode (rc bt c)
  (let ((temp (floor (range-coder-range rc)
                     (bitree-sum bt))))
    (incf (range-coder-low rc)
          (* (bitree-cumul bt c) temp))
    (setf (range-coder-range rc)
          (* (bitree-frequency bt c) temp))
    (encode-normalize rc)
    (update bt c 1)))
</pre>
<p> 記号 c の累積度数は bitree-cumul で、出現頻度は bitree-frequency で求めます。あとの処理は前回のプログラムとほぼ同じです。最後にメソッド update を呼び出して出現頻度表を更新します。
</p>

<p> 適応型レンジコーダでファイルを符号化する関数 encode-file は次のようになります。
</p>
<pre class="list">
リスト : 適応型レンジコーダによる符号化

(defun encode-file (in-file out-file)
  (call-with-byte-output-file
   out-file
   #'(lambda (out)
       (call-with-byte-input-file
        in-file
        #'(lambda (in)
            (let ((size (file-length in))
                  (bt (initialize-bitree)))
              (write-file-size out size)
              (when (plusp size)
                (call-with-range-encoder
                 out
                 #'(lambda (rc)
                     (dotimes (x size)
                       (encode rc bt (read-byte in))))))))))))
</pre>
<p> 関数 file-length でファイルサイズを求め、initialize-bitree で出現頻度表を生成します。あとは前回のプログラムとほとんど同じです。
</p>
<h4>●適応型レンジコーダの復号</h4>
<p> 次は復号を行うメソッド decode を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 記号の復号

(defun decode (rc bt)
  (let ((temp (floor (range-coder-range rc)
                     (bitree-sum bt))))
    (multiple-value-bind
        (c cumul)
        (bitree-find bt (floor (range-coder-low rc) temp))
      (decf (range-coder-low rc)
            (* cumul temp))
      (setf (range-coder-range rc)
            (* (bitree-frequency bt c) temp))
      (decode-normalize rc)
      (update bt c 1)
      c)))
</pre>

<p> bitree-find で記号 c と累積度数を求めます。記号 c の出現頻度は bitree-frequency で求めます。あとの処理は前回のプログラムとほぼ同じです。最後に update を呼び出して出現頻度表を更新します。
</p>

<p> 最後に、適応型レンジコーダでファイルを復号する関数 decode-file を作ります。
</p>
<pre class="list">
リスト : 適応型レンジコーダによる復号

(defun decode-file (in-file out-file)
  (call-with-byte-input-file
   in-file
   #'(lambda (in)
       (let ((size (read-file-size in))
             (bt (initialize-bitree)))
         (call-with-byte-output-file
          out-file
          #'(lambda (out)
              (when (plusp size)
                (call-with-range-decoder
                 in
                 #'(lambda (rc)
                     (dotimes (x size)
                       (write-byte (decode rc bt) out)))))))))))
</pre>

<p> read-file-size でファイルサイズを取り出し、initialize-bitree で出現頻度表を生成します。あとは前回のプログラムとほとんど同じです。
</p>

<p> なお、今回は記号の種類を 256 (0 - 255) としましたが、終端記号 (256 : END) を含めて 257 種類とする方法もあります。この場合は、元のファイルサイズをファイルに付加する必要はありません。符号化のときは最後に END を符号化し、復号のときは END を復号した時点で処理を終了するようにします。興味のある方は試してみてください。
</p>
<UL>
  <LI><a href="clispb26.html#list3">プログラムリスト３</a>
</UL>
<h4>●実行結果</h4>
<p> それでは、実際に <a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> を圧縮してみましょう。結果は次にようになりました。
</p>
<pre>
      表 : 適応型レンジコーダの結果

  ファイル名      サイズ      ARC      下限値
  ---------------------------------------------
  alice29.txt    152,089     87,147     86,837
  asyoulik.txt   125,179     75,533     75,235
  cp.html         24,603     16,299     16,082
  fields.c        11,150      7,164      6,980
  grammar.lsp      3,721      2,305      2,155
  kennedy.xls  1,029,744    460,734    459,971
  lcet10.txt     426,754    249,491    249,071
  plrabn12.txt   481,861    273,392    272,936
  ptt5           513,216     78,090     77,636
  sum             38,240     25,638     25,473
  xargs.1          4,227      2,743      2,589
  ---------------------------------------------
  合計         2,810,784  1,278,536  1,274,965
</pre>
<p> 適応型レンジコーダの圧縮率は、静的なレンジコーダと同様に圧縮の限界に近い値になりました。出現頻度表を付加しない分だけ、多くのファイルで静的なレンジコーダよりも高い圧縮率になりましたが、小さなファイルは逆に圧縮率が悪くなるようです。
</p>

<p> 適応型符号化の場合、出現しない記号が多数あると、圧縮率が少し悪くなるという欠点があります。たとえば、記号が 0 と 1 しかないデータを符号化してみましょう。適応型レンジコーダでは記号 0 - 255 の出現頻度を 1 に初期化しています。このため、記号数が少ないうちは記号 2 - 255 の出現頻度の影響が大きくなり、圧縮率はどうしても悪くなってしまいます。
</p>

<p> ようするに、記号をたくさん読み込まないと、その出現頻度表の確率はあてにならないというわけです。したがって、小さなファイルの圧縮率は静的なレンジコーダよりも悪くなる場合が多いようです。逆に、大きなファイルであれば、静的なレンジコーダと同様に高い圧縮率を達成することができます。
</p>

<p> 次は静的なレンジコーダと適応型レンジコーダの実行時間を比較して見ましょう。The Canterbury Corpus の 11 ファイルすべてを処理する時間を計測しました。
</p>
<pre>
 表 : 符号化と復号の処理時間 (単位：秒)

                     | 符号化 | 復号 
  -------------------+--------+------
  静的レンジコーダ   :  2.80  | 1.96
  適応型レンジコーダ :  3.94  | 2.56

実行環境 : Windows XP, celeron 1.40 GHz, SBCL ver 1.0.29
</pre>
<p> 符号化と復号ともに適応型レンジコーダのほうが遅くなりましたが、どちらの処理も静的レンジコーダの 1.5 倍程度しかかかっていません。Binary Indexed Tree の効果は十分に出ていると思います。
</p>
<p> なお、実行時間の結果は M.Hiroi のコーディング、実行したマシン、プログラミング言語などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間はかなり左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
;
; bitree.l : binary indexed tree
;
;            Copyright (C) 2010 Makoto Hiroi
;
(provide "BITREE")
(defpackage "BITREE"
  (:use "COMMON-LISP")
  (:export "MAKE-BITREE"
           "BITREE-FREQUENCY" "BITREE-CUMUL" "BITREE-SUM"
           "BITREE-UPDATE" "BITREE-FIND"
   ))

(in-package "BITREE")

; 中央値 (ルート) を求める
(defun get-mid (size)
  (do ((mid 1 (ash mid 1))
       (limit (ash size -1)))
      ((&lt;= limit mid) mid)))

; 構造体の定義
(defstruct (bitree
            (:constructor make-bitree
             (size
              &amp;aux
              (table (make-array size :initial-element 0))
              (mid (get-mid size))
              (sum 0))))
  size table mid sum)

; 出現頻度を求める
(defun bitree-frequency (bt c)
  (let ((n (aref (bitree-table bt) c)))
    (if (or (zerop c) (oddp c))
        n
      (do ((p (logand c (1- c)))
           (x (1- c) (logand x (1- x))))
          ((= x p) n)
        (decf n (aref (bitree-table bt) x))))))

; 累積度数を求める
(defun bitree-cumul (bt c)
  (if (zerop c)
      0
    (let ((n (aref (bitree-table bt) 0)))
      ; c - 1 までの頻度を加算する
      (do ((x (1- c) (logand x (1- x))))
          ((zerop x) n)
        (incf n (aref (bitree-table bt) x))))))

; 出現頻度の更新
(defun bitree-update (bt c inc)
  (if (zerop c)
      (incf (aref (bitree-table bt) c) inc)
    (do ()
        ((&lt;= (bitree-size bt) c))
      (incf (aref (bitree-table bt) c) inc)
      (incf c (logand c (- c)))))
  (incf (bitree-sum bt) inc))

; 探索 (cumul[c] &lt;= val &lt; cumul[c + 1])
(defun bitree-find (bt val)
  (let ((n (aref (bitree-table bt) 0)))
    (if (&lt; val n)
        (values 0 0)
      (do ((h (bitree-mid bt) (ash h -1))
           (c 0))
          ((zerop h) (values (1+ c) n))
        (when (and (&lt; (+ c h) (bitree-size bt))
                   (&lt;= (+ n (aref (bitree-table bt) (+ c h))) val))
          (incf n (aref (bitree-table bt) (+ c h)))
          (incf c h))))))
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
;
; rangecoder.l : レンジコーダー
;
;                Copyright (C) 2010 Makoto Hiroi
;
(provide "RANGECODER")
(defpackage "RANGECODER"
  (:use "COMMON-LISP")
  (:export "CALL-WITH-BYTE-INPUT-FILE"
           "CALL-WITH-BYTE-OUTPUT-FILE"
           "CALL-WITH-RANGE-ENCODER"
           "CALL-WITH-RANGE-DECODER"
           "ENCODE-NORMALIZE" "DECODE-NORMALIZE"
           "RANGE-CODER-RANGE" "RANGE-CODER-LOW"
           "CODE-SIZE"
   ))

(in-package "RANGECODER")

; バイト入力用ファイルオープン
(defun call-with-byte-input-file (filename proc)
  (with-open-file (in filename
                      :direction :input
                      :element-type 'unsigned-byte)
    (funcall proc in)))

; バイト出力用ファイルオープン
(defun call-with-byte-output-file (filename proc)
  (with-open-file (out filename
                       :direction :output
                       :if-exists :rename-and-delete
                       :element-type 'unsigned-byte)
    (funcall proc out)))

; 定数
(defconstant max-range #x100000000)
(defconstant min-range #x1000000)
(defconstant mask      #xffffffff)
(defconstant ff-check  #xff000000)
(defconstant code-size 256)

; 構造体の定義
(defstruct range-coder
  direction file range low buff cnt)

; buff と記号 c を n 個書き出す
(defun flush-buff (rc c n)
  (write-byte (range-coder-buff rc) (range-coder-file rc))
  (dotimes (x n)
    (write-byte c (range-coder-file rc))))

; 終了処理
(defun finish (rc out)
  (if (&lt; (range-coder-low rc) max-range)
      (flush-buff rc #xff (range-coder-cnt rc))
    ; 桁上がり
    (progn
      (incf (range-coder-buff rc))
      (flush-buff rc 0 (range-coder-cnt rc))))
  ;
  (write-byte (logand (ash (range-coder-low rc) -24) #xff) out)
  (write-byte (logand (ash (range-coder-low rc) -16) #xff) out)
  (write-byte (logand (ash (range-coder-low rc) -8) #xff) out)
  (write-byte (logand (range-coder-low rc) #xff) out))

; 符号化用レンジコーダ
(defun call-with-range-encoder (out proc)
  (let ((rc (make-range-coder :direction :encode
                              :file out
                              :range max-range
                              :low 0
                              :buff 0
                              :cnt 0)))
    (funcall proc rc)
    ; 終了処理
    (finish rc out)))

; 復号用レンジコーダ
(defun call-with-range-decoder (in proc)
  (let ((rc (make-range-coder :direction :decode
                              :file in
                              :range max-range
                              :buff 0
                              :cnt 0)))
    ; buff の初期値 (0) を読み捨てる
    (read-byte in)
    ; 4 byte read
    (setf (range-coder-low rc)
          (+ (ash (read-byte in) 24)
             (ash (read-byte in) 16)
             (ash (read-byte in) 8)
             (read-byte in)))
    ;
    (funcall proc rc)))

; 符号化の正規化
(defun encode-normalize (rc)
  (when (&gt;= (range-coder-low rc) max-range)
    ; 桁上がり
    (incf (range-coder-buff rc))
    (setf (range-coder-low rc)
          (logand (range-coder-low rc) mask))
    (when (plusp (range-coder-cnt rc))
      (flush-buff rc 0 (1- (range-coder-cnt rc)))
      (setf (range-coder-buff rc) 0
            (range-coder-cnt rc) 0)))
  (do ()
      ((&gt;= (range-coder-range rc) min-range))
    (cond ((&lt; (range-coder-low rc) ff-check)
           (flush-buff rc #xff (range-coder-cnt rc))
           (setf (range-coder-buff rc)
                 (logand (ash (range-coder-low rc) -24) #xff)
                 (range-coder-cnt rc)
                 0))
          (t (incf (range-coder-cnt rc))))
    (setf (range-coder-low rc)
          (logand (ash (range-coder-low rc) 8) mask)
          (range-coder-range rc)
          (ash (range-coder-range rc) 8))))

; 復号の正規化
(defun decode-normalize (rc)
  (do ()
      ((&gt;= (range-coder-range rc) min-range))
    (setf (range-coder-range rc)
          (ash (range-coder-range rc) 8)
          (range-coder-low rc)
          (logand (+ (ash (range-coder-low rc) 8)
                     (read-byte (range-coder-file rc)))
                  mask))))
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
;
; rca.l : 適応型レンジコーダ
;
;         Copyright (C) 2010 Makoto Hiroi
;

(require :rangecoder "rangecoder")
(use-package :rangecoder)
(require :bitree "bitree")
(use-package :bitree)


; ファイルサイズの書き込み
(defun write-file-size (out size)
  (write-byte (logand (ash size -24) #xff) out)
  (write-byte (logand (ash size -16) #xff) out)
  (write-byte (logand (ash size -8) #xff) out)
  (write-byte (logand size #xff) out))

; ファイルサイズの読み込み
(defun read-file-size (in)
  (+ (ash (read-byte in) 24)
     (ash (read-byte in) 16)
     (ash (read-byte in) 8)
     (read-byte in)))

; 更新
(defun update (bt c inc)
  (bitree-update bt c inc)
  (when (&lt;= rangecoder::min-range (bitree-sum bt))
    (dotimes (x code-size)
      (let ((n (ash (bitree-frequency bt x) -1)))
        (when (plusp n)
          (bitree-update bt x (- n)))))))

; 初期化
(defun initialize-bitree ()
  (let ((bt (make-bitree code-size)))
    (dotimes (x code-size bt)
      (bitree-update bt x 1))))

;;;;

; 符号化
(defun encode (rc bt c)
  (let ((temp (floor (range-coder-range rc)
                     (bitree-sum bt))))
    (incf (range-coder-low rc)
          (* (bitree-cumul bt c) temp))
    (setf (range-coder-range rc)
          (* (bitree-frequency bt c) temp))
    (encode-normalize rc)
    (update bt c 1)))

; 復号
(defun decode (rc bt)
  (let ((temp (floor (range-coder-range rc)
                     (bitree-sum bt))))
    (multiple-value-bind
        (c cumul)
        (bitree-find bt (floor (range-coder-low rc) temp))
      (decf (range-coder-low rc)
            (* cumul temp))
      (setf (range-coder-range rc)
            (* (bitree-frequency bt c) temp))
      (decode-normalize rc)
      (update bt c 1)
      c)))

; ファイルの符号化
(defun encode-file (in-file out-file)
  (call-with-byte-output-file
   out-file
   #'(lambda (out)
       (call-with-byte-input-file
        in-file
        #'(lambda (in)
            (let ((size (file-length in))
                  (bt (initialize-bitree)))
              (write-file-size out size)
              (when (plusp size)
                (call-with-range-encoder
                 out
                 #'(lambda (rc)
                     (dotimes (x size)
                       (encode rc bt (read-byte in))))))))))))

; ファイルの復号
(defun decode-file (in-file out-file)
  (call-with-byte-input-file
   in-file
   #'(lambda (in)
       (let ((size (read-file-size in))
             (bt (initialize-bitree)))
         (call-with-byte-output-file
          out-file
          #'(lambda (out)
              (when (plusp size)
                (call-with-range-decoder
                 in
                 #'(lambda (rc)
                     (dotimes (x size)
                       (write-byte (decode rc bt) out)))))))))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="ce">
<div class="small">
<hr>
[ <a href="clispb25.html">PrevPage</a> | <a href="index.html">Common Lisp</a> | <a href="clispb27.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>