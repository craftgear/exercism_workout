<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ＃プログラミング超入門</title>
  <meta name="description" content="C#,C#入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881817</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>C# Programming</h1>
<h2>お気楽Ｃ＃プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
<hr>
</div>
<section class="contents">
<h3>簡単なプログラム</h3>
<h4 id="chap15">●連結リスト</h4>
<p> 片方向の連結リスト (singly-linked list) です。詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo02.html">連結リスト</a> をお読みください。なお、今回は C# のお勉強ということでインデクサーを実装しましたが、要素数を N とすると、要素のアクセスは O(N) に比例する時間がかかります。配列のようにランダムアクセスする用途には向きません。ご注意くださいませ。
</p>
<pre class="list">
//
// linklist.cs : 連結リスト (非ジェネリック版)
//
//               Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections;

class LinkList : IEnumerable {
  class Cell {
    public object Car { get; set; }
    public Cell Cdr { get; set; }
    public Cell(object item, Cell next) {
      Car = item;
      Cdr = next;
    }
  }

  // ヘッダーセル
  Cell header;

  // 空リストの生成
  public LinkList() {
    header = new Cell(null, null);
  }

  // n 番目のセルを求める
  private Cell NthCell(int n) {
    Cell cp = header;
    for (int i = -1; i &lt; n; i++) {
      if (cp == null) throw new IndexOutOfRangeException();
      cp = cp.Cdr;
    }
    return cp;
  }

  // インデクサー
  public object this[int n] {
    get { return NthCell(n).Car; }
    set { NthCell(n).Car = value; }
  }

  // 挿入
  public void Insert(object item, int n) {
    Cell cp = NthCell(n - 1);
    cp.Cdr = new Cell(item, cp.Cdr);
  }

  // 削除
  public void Delete(int n) {
    Cell cp = NthCell(n - 1);
    if (cp.Cdr == null) throw new IndexOutOfRangeException();
    cp.Cdr = cp.Cdr.Cdr;
  }

  // イテレータ
  public IEnumerator GetEnumerator() {
    var cp = header.Cdr;
    while (cp != null) {
      yield return cp.Car;
      cp = cp.Cdr;
    }
  }
}

class Test {
  static void PrintList(LinkList a) {
    foreach(object x in a)
      Console.Write("{0} ", x);
    Console.WriteLine("");
  }

  static void Main() {
    var a = new LinkList();
    for (int i = 0; i &lt; 10; i++) {
      a.Insert(i, i);
    }
    PrintList(a);
    for (int i = 0; i &lt; 10; i++) {
      a[i] = (int)a[i] * 10;
      Console.Write("{0} ", a[i]);
    }
    Console.WriteLine("");
    a.Delete(0);
    PrintList(a);
    a.Delete(8);
    PrintList(a);
    a.Delete(4);
    PrintList(a);
  }
}
</pre>
<ul>
  <li>Cell の Car は object 型なので、値型のデータを格納するときは「ボクシング (boxing)」が行われる
  <li>ボクシングは値型を参照型に型変換すること
  <li>具体的には参照型データを作成して、そこに値型のデータをコピーする
  <li>ボクシングされたデータから実際の値を取り出すことを「アンボクシング (unboxing)」という
  <li>C# の場合、アンボクシングするときは「キャスト (cast)」が必要になる
</ul>
<pre>
C&gt;linklist
0 1 2 3 4 5 6 7 8 9
0 10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80
10 20 30 40 60 70 80
</pre>
<hr>
<h4 id="chap16">●連結リスト (ジェネリック版)</h4>
<pre class="list">
//
// linklist1.cs : 連結リスト (ジェネリック版)
//
//                Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections;
using System.Collections.Generic;

class LinkList&lt;T&gt; : IEnumerable&lt;T&gt; where T : IComparable&lt;T&gt; {
  class Cell {
    public T Car { get; set; }
    public Cell Cdr { get; set; }

    public Cell(T item, Cell next) {
      Car = item;
      Cdr = next;
    }
  }

  // ヘッダーセル
  Cell header;

  // 空リストの生成
  public LinkList() {
    header = new Cell(default(T), null);
  }

  // n 番目のセルを求める
  private Cell NthCell(int n) {
    Cell xs = header;
    for (int i = -1; i &lt; n; i++) {
      if (xs == null) throw new IndexOutOfRangeException();
      xs = xs.Cdr;
    }
    return xs;
  }

  // インデクサー
  public T this[int n] {
    get { return NthCell(n).Car; }
    set { NthCell(n).Car = value; }
  }

  // 挿入
  public void Insert(T item, int n) {
    Cell xs = NthCell(n - 1);
    xs.Cdr = new Cell(item, xs.Cdr);
  }

  // 削除
  public void Delete(int n) {
    Cell xs = NthCell(n - 1);
    if (xs.Cdr == null) throw new IndexOutOfRangeException();
    xs.Cdr = xs.Cdr.Cdr;
  }

  // イテレータ
  public IEnumerator&lt;T&gt; GetEnumerator() {
    var xs = header.Cdr;
    while (xs != null) {
      yield return xs.Car;
      xs = xs.Cdr;
    }
  }
  IEnumerator IEnumerable.GetEnumerator() {
    return this.GetEnumerator();
  }

  // 探索
  public bool Contains(T item) {
    foreach(T x in this) {
      if (item.CompareTo(x) == 0) return true;
    }
    return false;
  }

  public int IndexOf(T item) {
    int i = 0;
    var xs = header.Cdr;
    while (xs != null) {
      if (item.CompareTo(xs.Car) == 0) return i;
      xs = xs.Cdr;
      i++;
    }
    return -1;
  }

  public int FindIndex(Func&lt;T, bool&gt; pred) {
    int i = 0;
    var xs = header.Cdr;
    while (xs != null) {
      if (pred(xs.Car)) return i;
      xs = xs.Cdr;
      i++;
    }
    return -1;
  }
}

class Test {
  static void PrintList&lt;T&gt;(LinkList&lt;T&gt; a) where T : IComparable&lt;T&gt; {
    foreach(T x in a)
      Console.Write("{0} ", x);
    Console.WriteLine("");
  }
  
  static void Main() {
    var a = new LinkList&lt;int&gt;();
    for (int i = 0; i &lt; 10; i++) {
      a.Insert(i, i);
    }
    PrintList(a);
    for (int i = -1; i &lt; 11; i++) {
      Console.WriteLine("{0}, {1}", i, a.Contains(i));
      Console.WriteLine("{0}, {1}", i, a.IndexOf(i));
      Console.WriteLine("{0}, {1}", i, a.FindIndex(x =&gt; x == i));
    }

    for (int i = 0; i &lt; 10; i++) {
      a[i] *= 10;
      Console.Write("{0} ", a[i]);
    }
    Console.WriteLine("");
    a.Delete(0);
    PrintList(a);
    a.Delete(8);
    PrintList(a);
    a.Delete(4);
    PrintList(a);
  }
}
</pre>
<pre>
C&gt;linklist1
0 1 2 3 4 5 6 7 8 9
-1, False
-1, -1
-1, -1
0, True
0, 0
0, 0
1, True
1, 1
1, 1
2, True
2, 2
2, 2
3, True
3, 3
3, 3
4, True
4, 4
4, 4
5, True
5, 5
5, 5
6, True
6, 6
6, 6
7, True
7, 7
7, 7
8, True
8, 8
8, 8
9, True
9, 9
9, 9
10, False
10, -1
10, -1
0 10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80 90
10 20 30 40 50 60 70 80
10 20 30 40 60 70 80
</pre>
<hr>
<h4 id="chap17">●immutable な連結リスト</h4>
<pre class="list">
//
// linklist2.cs : immutable な連結リスト (ジェネリック版)
//
//                Copyright (C) 2016 Makoto Hiroi
//

using System;
using System.Collections;
using System.Collections.Generic;

// immutable な連結リスト
public class Cell&lt;T&gt; : IEnumerable&lt;T&gt; where T : IComparable {
  public T Car { get; }
  public Cell&lt;T&gt; Cdr { get; }
  public Cell(T item, Cell&lt;T&gt; next) {
    Car = item;
    Cdr = next;
  }

  // 終端
  public static readonly Cell&lt;T&gt; nil = new Cell&lt;T&gt;(default(T), null);
  public bool Null() { return this == nil; }

  // イテレータ
  public IEnumerator&lt;T&gt; GetEnumerator() {
    var xs = this;
    while (!xs.Null()) {
      yield return xs.Car;
      xs = xs.Cdr;
    }
  }
  IEnumerator IEnumerable.GetEnumerator() {
    return this.GetEnumerator();
  }

  // リストの生成
  public static Cell&lt;T&gt; List(params T[] xs) {
    var ys = nil;
    for (int i = xs.Length - 1; i &gt;= 0; i--) {
      ys = new Cell&lt;T&gt;(xs[i], ys);
    }
    return ys;
  }

  // リストの連結
  public Cell&lt;T&gt; Append(Cell&lt;T&gt; xs) {
    if (this.Null())
      return xs;
    else
      return new Cell&lt;T&gt;(Car, Cdr.Append(xs));
  }

  // リストの反転
  public Cell&lt;T&gt; Reverse() {
    var ys = nil;
    foreach(T x in this) {
      ys = new Cell&lt;T&gt;(x, ys);
    }
    return ys;
  }

  // リストの長さ
  public int Length() {
    int c = 0;
    foreach(T x in this) {
      c++;
    }
    return c;
  }

  // 参照
  public T Nth(int n) {
    foreach(T x in this) {
      if (n-- == 0) return x;
    }
    throw new IndexOutOfRangeException();
  }

  // 探索
  public Cell&lt;T&gt; Member(T item) {
    var xs = this;
    while (!xs.Null()) {
      if (item.CompareTo(xs.Car) == 0) break;
      xs = xs.Cdr;
    }
    return xs;
  }

  public bool Contains(T item) {
    foreach(T x in this) {
      if (item.CompareTo(x) == 0) return true;
    }
    return false;
  }

  public int IndexOf(T item) {
    int i = 0;
    foreach(T x in this) {
      if (item.CompareTo(x) == 0) return i;
      i++;
    }
    return -1;
  }

  public int FindIndex(Func&lt;T, bool&gt; pred) {
    int i = 0;
    foreach(T x in this) {
      if (pred(x)) return i;
      i++;
    }
    return -1;
  }
  
  // マッピング
  public Cell&lt;U&gt; Map&lt;U&gt;(Func&lt;T, U&gt; func) where U : IComparable {
    if (this.Null())
      return Cell&lt;U&gt;.nil;
    else
      return new Cell&lt;U&gt;(func(Car), Cdr.Map(func));
  }

  // フィルター
  public Cell&lt;T&gt; Filter(Func&lt;T, bool&gt; pred) {
    if (this.Null())
      return nil;
    else if (pred(Car))
      return new Cell&lt;T&gt;(Car, Cdr.Filter(pred));
    else
      return Cdr.Filter(pred);
  }

  // 畳み込み
  public U FoldLeft&lt;U&gt;(Func&lt;U, T, U&gt; func, U a) {
    foreach(T x in this) {
      a = func(a, x);
    }
    return a;
  }

  public U FoldRight&lt;U&gt;(Func&lt;T, U, U&gt; func, U a) {
    if (this.Null())
      return a;
    else
      return func(Car, Cdr.FoldRight(func, a));
  }

  // 巡回
  public void Each(Action&lt;T&gt; func) {
    foreach(T x in this) {
      func(x);
    }
  }

  // 表示
  public void Print() {
    var xs = this;
    Console.Write("(");
    while (!xs.Null()) {
      Console.Write("{0}", xs.Car);
      xs = xs.Cdr;
      if (!xs.Null()) Console.Write(" ");
    }
    Console.WriteLine(")");
  }
}

class Test {
  static void Main() {
    var a = Cell&lt;int&gt;.List(1, 2, 3, 4, 5);
    a.Print();
    Console.WriteLine("{0}", a.Length());
    a.Reverse().Print();
    var b = Cell&lt;int&gt;.List(6, 7, 8, 9, 10);
    var c = a.Append(b);
    c.Print();
    for (int i = 0; i &lt; c.Length(); i++)
      Console.Write("{0} ", c.Nth(i));
    Console.WriteLine("");
    for (int i = 0; i &lt;= 11; i++) {
      c.Member(i).Print();
      Console.WriteLine("{0}", c.Contains(i));
      Console.WriteLine("{0}", c.IndexOf(i));
      Console.WriteLine("{0}", c.FindIndex(n =&gt; n == i));
    }
    c.Map(n =&gt; n * 10).Print();
    c.Filter(n =&gt; n % 2 == 0).Print();
    Console.WriteLine("{0}", c.FoldLeft((sum, n) =&gt; sum + n, 0));
    Console.WriteLine("{0}", c.FoldRight((n, sum) =&gt; sum + n, 0));
    c.Each(n =&gt; Console.Write("{0} ", n));
    Console.WriteLine("");
    foreach(int n in c) {
      Console.Write("{0} ", n);
    }
    Console.WriteLine("");
  }
}
</pre>
<pre>
C&gt;linklist2
(1 2 3 4 5)
5
(5 4 3 2 1)
(1 2 3 4 5 6 7 8 9 10)
1 2 3 4 5 6 7 8 9 10
()
False
-1
-1
(1 2 3 4 5 6 7 8 9 10)
True
0
0
(2 3 4 5 6 7 8 9 10)
True
1
1
(3 4 5 6 7 8 9 10)
True
2
2
(4 5 6 7 8 9 10)
True
3
3
(5 6 7 8 9 10)
True
4
4
(6 7 8 9 10)
True
5
5
(7 8 9 10)
True
6
6
(8 9 10)
True
7
7
(9 10)
True
8
8
(10)
True
9
9
()
False
-1
-1
(10 20 30 40 50 60 70 80 90 100)
(2 4 6 8 10)
55
55
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
</pre>
<hr>
<h4 id="chap18">●Lisp ライクな連結リスト</h4>
<pre class="list">
//
// linklist3.cs : Lisp ライクな連結リスト (immutable)
//
//                Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections;
using static Cell;

class Cell : IEnumerable {
  public object Car { get; }
  public Cell Cdr   { get; }  // ドットリストはサポートしない
  public Cell(object item, Cell next) {
    Car = item;
    Cdr = next;
  }

  // 終端
  public static readonly Cell nil = new Cell(null, null);

  // 述語
  public static bool Null(object xs)  { return xs == nil; }
  public static bool Consp(object xs) { return xs is Cell; }
  public static bool Listp(object xs) { return Null(xs) || Consp(xs); }
  public static bool Eql(object x, object y) {
    return ((IComparable)x).CompareTo((IComparable)y) == 0;
  }

  // イテレータ
  public IEnumerator GetEnumerator() {
    var xs = this;
    while (!Null(xs)) {
      yield return xs.Car;
      xs = xs.Cdr;
    }
  }

  // リストの生成
  public static Cell List(params object[] xs) {
    var ys = nil;
    for (int i = xs.Length - 1; i &gt;= 0; i--) {
      ys = new Cell(xs[i], ys);
    }
    return ys;
  }

  // リストの連結
  public Cell Append(Cell ys) {
    if (Null(this))
      return ys;
    else
      return new Cell(Car, Cdr.Append(ys));
  }

  // リストの反転
  public Cell Reverse() {
    var ys = nil;
    foreach(object x in this) {
      ys = new Cell(x, ys);
    }
    return ys;
  }

  // リストの長さ
  public int Length() {
    int c = 0;
    foreach(object x in this) {
      c++;
    }
    return c;
  }
  
  // 参照
  public object Nth(int n) {
    var xs = this;
    while (!Null(xs)) {
      if (n-- == 0) return xs.Car;
      xs = xs.Cdr;
    }
    throw new IndexOutOfRangeException();
  }

  // 探索
  public Cell Member(object x) {
    var xs = this;
    while (!Null(xs)) {
      if (Eql(xs.Car, x)) return xs;
      xs = xs.Cdr;
    }
    return xs;
  }

  public int IndexOf(object x) {
    int i = 0;
    foreach(object y in this) {
      if (Eql(x, y)) return i;
      i++;
    }
    return -1;
  }

  public int FindIndex(Func&lt;object, bool&gt; pred) {
    int i = 0;
    foreach(object x in this) {
      if (pred(x)) return i;
      i++;
    }
    return -1;
  }
  
  // マッピング
  public Cell Map(Func&lt;object, object&gt; func) {
    if (Null(this))
      return nil;
    else
      return new Cell(func(Car), Cdr.Map(func));
  }

  // フィルター
  public Cell Filter(Func&lt;object, bool&gt; pred) {
    if (Null(this))
      return nil;
    else if (pred(Car))
      return new Cell(Car, Cdr.Filter(pred));
    else
      return Cdr.Filter(pred);
  }

  // 畳み込み
  public object FoldLeft(Func&lt;object, object, object&gt; func, object a) {
    foreach(object x in this) {
      a = func(a, x);
    }
    return a;
  }

  public object FoldRight(Func&lt;object, object, object&gt; func, object a) {
    if (Null(this))
      return a;
    else
      return func(Car, Cdr.FoldRight(func, a));
  }

  // 巡回
  public void Each(Action&lt;object&gt; func) {
    foreach(object x in this) {
      func(x);
    }
  }

  // 連想リスト
  public Cell Zip(Cell xs) {
    if (Null(this) || Null(xs))
      return nil;
    else
      return new Cell(List(Car, xs.Car), Cdr.Zip(xs.Cdr));
  }
  
  public Cell Assoc(object item) {
    foreach(object xs in this) {
      Cell ys = (Cell)xs;
      if (Eql(item, ys.Car)) return ys;
    }
    return nil;
  }
  
  // 表示
  public void Print() {
    var xs = this;
    Console.Write("(");
    while (!Null(xs)) {
      if (Consp(xs.Car)) {
        Cell cp = (Cell)xs.Car;
        cp.Print();
      } else {
        Console.Write("{0}", xs.Car);
      }
      xs = xs.Cdr;
      if (!Null(xs)) Console.Write(" ");
    }
    Console.Write(")");
  }

  public void PrintLine() {
    this.Print();
    Console.WriteLine("");
  }
}

class Test {
  static void Main() {
    var a = List(1, 2);
    var b = List(3, 4, 5);
    var c = List(6, 7, 8, 9);
    var d = List(a, b, c);
    a.PrintLine();
    b.PrintLine();
    c.PrintLine();
    d.PrintLine();
    var e = a.Append(b).Append(c);
    e.PrintLine();
    e.Reverse().PrintLine();
    Console.WriteLine("{0}", e.Length());
    foreach(object x in e) {
      Console.Write("{0} ", x);
    }
    Console.WriteLine("");
    for (int i = 0; i &lt; e.Length(); i++) {
      Console.Write("{0} ", e.Nth(i));
    }
    Console.WriteLine("");
    d.Map(xs =&gt; ((Cell)xs).Length()).PrintLine();
    e.Map(n =&gt; (int)n * 10).PrintLine();
    d.Map(xs =&gt; ((Cell)xs).Reverse()).PrintLine();
    e.Filter(n =&gt; (int)n % 2 == 0).PrintLine();
    Console.WriteLine("{0}", e.FoldLeft((sum, n) =&gt; (int)sum + (int)n, 0));
    Console.WriteLine("{0}", e.FoldRight((n, sum) =&gt; (int)sum + (int)n, 0));
    e.Each(n =&gt; Console.Write("{0} ", n));
    Console.WriteLine("");
    for (int i = 0; i &lt;= 10; i++) {
      e.Member(i).PrintLine();
      Console.WriteLine("{0}", e.IndexOf(i));
      Console.WriteLine("{0}", e.FindIndex(n =&gt; (int)n == i));
    }
    var alist = List("foo", "bar", "baz").Zip(List(1, 2, 3));
    alist.PrintLine();
    alist.Assoc("foo").PrintLine();
    alist.Assoc("bar").PrintLine();
    alist.Assoc("baz").PrintLine();
    alist.Assoc("oops").PrintLine();
  }
}
</pre>
<pre>
C&gt;linklist3
(1 2)
(3 4 5)
(6 7 8 9)
((1 2) (3 4 5) (6 7 8 9))
(1 2 3 4 5 6 7 8 9)
(9 8 7 6 5 4 3 2 1)
9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
(2 3 4)
(10 20 30 40 50 60 70 80 90)
((2 1) (5 4 3) (9 8 7 6))
(2 4 6 8)
45
45
1 2 3 4 5 6 7 8 9
()
-1
-1
(1 2 3 4 5 6 7 8 9)
0
0
(2 3 4 5 6 7 8 9)
1
1
(3 4 5 6 7 8 9)
2
2
(4 5 6 7 8 9)
3
3
(5 6 7 8 9)
4
4
(6 7 8 9)
5
5
(7 8 9)
6
6
(8 9)
7
7
(9)
8
8
()
-1
-1
((foo 1) (bar 2) (baz 3))
(foo 1)
(bar 2)
(baz 3)
()
</pre>
<hr>
<h4 id="chap19">●二分木 (mutable)</h4>
<pre class="list">
//
// tree.cs : 二分木 (ジェネリック版)
//
//           Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections;
using System.Collections.Generic;

class Tree&lt;T&gt; : IEnumerable&lt;T&gt; where T : IComparable&lt;T&gt; {
  // 節
  class Node {
    public T Item  { set; get; }
    public Node Left  { set; get; }
    public Node Right { set; get; }
    public Node(T item) {
      Item  = item;
      Left  = null;
      Right = null;
    }
  }

  // ルート
  Node root;

  // コンストラクタ
  public Tree() { root = null; }

  // 操作関数

  // 挿入
  static Node InsertNode(T x, Node node) {
    if (node == null)
      return new Node(x);
    else {
      int r = x.CompareTo(node.Item);
      if (r &lt; 0)
        node.Left = InsertNode(x, node.Left);
      else if (r &gt; 0)
        node.Right = InsertNode(x, node.Right);
      return node;
    }
  }

  // 探索
  static bool SearchNode(T x, Node node) {
    while (node != null) {
      int r = x.CompareTo(node.Item);
      if (r == 0) return true;
      else if (r &lt; 0)
        node = node.Left;
      else
        node = node.Right;
    }
    return false;
  }

  // 最小値の探索
  static T SearchMin(Node node) {
    while (node.Left != null) node = node.Left;
    return node.Item;
  }

  // 最小値のノードを削除
  static Node DeleteMin(Node node) {
    if (node.Left == null) return node.Right;
    node.Left = DeleteMin(node.Left);
    return node;
  }

  // 削除
  static Node DeleteNode(T x, Node node) {
    if (node != null) {
      int r = x.CompareTo(node.Item);
      if (r == 0) {
        if (node.Left == null) return node.Right;
        if (node.Right == null) return node.Left;
        node.Item = SearchMin(node.Right);
        node.Right = DeleteMin(node.Right);
      } else if (r &lt; 0) {
        node.Left = DeleteNode(x, node.Left);
      } else if (r &gt; 0) {
        node.Right = DeleteNode(x, node.Right);
      }
    }
    return node;
  }

  // 巡回
  static void EachNode(Action&lt;T&gt; func, Node node) {
    if (node != null) {
      EachNode(func, node.Left);
      func(node.Item);
      EachNode(func, node.Right);
    }
  }

  // メソッド

  // 挿入
  public void Insert(T x) {
    root = InsertNode(x, root);
  }

  // 探索
  public bool Search(T x) {
    return SearchNode(x, root);
  }

  // 削除
  public void Delete(T x) {
    root = DeleteNode(x, root);
  }

  // 巡回
  public void Each(Action&lt;T&gt; func) {
    EachNode(func, root);
  }

  // 空の木か
  public bool IsEmpty() {
    return root == null;
  }

  // 空にする
  public void Clear() {
    root = null;
  }

  // イテレータ
  static void NextNode(List&lt;Node&gt; path, Node node) {
    while (node != null) {
      path.Add(node);
      node = node.Left;
    }
  }
  
  public IEnumerator&lt;T&gt; GetEnumerator() {
    var path = new List&lt;Node&gt;();
    NextNode(path, root);
    while (path.Count &gt; 0) {
      var node = path[path.Count - 1];
      path.RemoveAt(path.Count - 1);
      yield return node.Item;
      NextNode(path, node.Right);
    }
  }

  IEnumerator IEnumerable.GetEnumerator() {
    return this.GetEnumerator();
  }
}

class Test {
  static void Main() {
    int[] a = new int[] {5,6,4,3,7,8,1,2,9,0};
    var tree = new Tree&lt;int&gt;();
    foreach(int x in a) {
      tree.Insert(x);
    }
    for (int i = -1; i &lt; 11; i++) {
      Console.WriteLine("{0} {1}", i, tree.Search(i));
    }
    tree.Each(x =&gt; Console.WriteLine("{0}", x));
    foreach (int x in tree) {
      Console.Write("{0} ", x);
    }
    Console.WriteLine("");
    for (int i = 0; i &lt; 10; i++) {
      tree.Delete(i);
      Console.WriteLine("{0} {1}", i, tree.Search(i));
      tree.Each(x =&gt; Console.Write("{0} ", x));
      Console.WriteLine("");
    }
  }
}
</pre>
<pre>
C&gt;tree
-1 False
0 True
1 True
2 True
3 True
4 True
5 True
6 True
7 True
8 True
9 True
10 False
0
1
2
3
4
5
6
7
8
9
0 1 2 3 4 5 6 7 8 9
0 False
1 2 3 4 5 6 7 8 9
1 False
2 3 4 5 6 7 8 9
2 False
3 4 5 6 7 8 9
3 False
4 5 6 7 8 9
4 False
5 6 7 8 9
5 False
6 7 8 9
6 False
7 8 9
7 False
8 9
8 False
9
9 False

</pre>
<hr>
<h4 id="chap20">●二分木 (immutable)</h4>
<pre class="list">
//
// tree1.cs : 二分木 (immutable)
//
//            Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections;
using System.Collections.Generic;

class Tree&lt;T&gt; : IEnumerable&lt;T&gt; where T : IComparable&lt;T&gt; {
  public T Item  { get; }
  public Tree&lt;T&gt; Left  { get; }
  public Tree&lt;T&gt; Right { get; }
  public Tree(T item, Tree&lt;T&gt; left, Tree&lt;T&gt; right) {
    Item  = item;
    Left  = left;
    Right = right;
  }

  // 空の木
  public static readonly Tree&lt;T&gt; nil = new Tree&lt;T&gt;(default(T), null, null);
  public bool IsEmpty() { return this == nil; }
  public static Tree&lt;T&gt; MakeTree() { return nil; }

  // 挿入
  public Tree&lt;T&gt; Insert(T x) {
    if (this == nil)
      return new Tree&lt;T&gt;(x, nil, nil);
    else {
      int r = x.CompareTo(Item);
      if (r &lt; 0)
        return new Tree&lt;T&gt;(Item, Left.Insert(x), Right);
      else if (r &gt; 0)
        return new Tree&lt;T&gt;(Item, Left, Right.Insert(x));
      else
        return this;
    }
  }

  // 探索
  public bool Search(T x) {
    Tree&lt;T&gt; node = this;
    while (node != nil) {
      int r = x.CompareTo(node.Item);
      if (r == 0) return true;
      else if (r &lt; 0)
        node = node.Left;
      else
        node = node.Right;
    }
    return false;
  }

  // 最小値の探索
  public T SearchMin() {
    Tree&lt;T&gt; node = this;
    while (node != nil) node = node.Left;
    return node.Item;
  }

  // 最小値のノードを削除
  public Tree&lt;T&gt; DeleteMin() {
    if (Left == nil) return Right;
    return new Tree&lt;T&gt;(Item, Left.DeleteMin(), Right);
  }

  // 削除
  public Tree&lt;T&gt; Delete(T x) {
    if (this == nil) {
      return nil;
    } else {
      int r = x.CompareTo(Item);
      if (r == 0) {
        if (Left == nil) return Right;
        if (Right == nil) return Left;
        return new Tree&lt;T&gt;(Right.SearchMin(), Left, Right.DeleteMin());
      } else if (r &lt; 0) {
        return new Tree&lt;T&gt;(Item, Left.Delete(x), Right);
      } else {
        return new Tree&lt;T&gt;(Item, Left, Right.Delete(x));
      }
    }
  }

  // 巡回
  public void Each(Action&lt;T&gt; func) {
    if (this != nil) {
      Left.Each(func);
      func(Item);
      Right.Each(func);
    }
  }

  // イテレータ
  static void NextNode(List&lt;Tree&lt;T&gt;&gt; path, Tree&lt;T&gt; node) {
    while (node != nil) {
      path.Add(node);
      node = node.Left;
    }
  }
  
  public IEnumerator&lt;T&gt; GetEnumerator() {
    var path = new List&lt;Tree&lt;T&gt;&gt;();
    NextNode(path, this);
    while (path.Count &gt; 0) {
      var node = path[path.Count - 1];
      path.RemoveAt(path.Count - 1);
      yield return node.Item;
      NextNode(path, node.Right);
    }
  }

  IEnumerator IEnumerable.GetEnumerator() {
    return this.GetEnumerator();
  }
}

class Test {
  static void Main() {
    int[] a = new int[] {5,6,4,3,7,8,1,2,9,0};
    var tree = Tree&lt;int&gt;.MakeTree();
    foreach(int x in a) {
      tree = tree.Insert(x);
    }
    for (int i = -1; i &lt; 11; i++) {
      Console.WriteLine("{0} {1}", i, tree.Search(i));
    }
    tree.Each(x =&gt; Console.WriteLine("{0}", x));
    foreach(int x in tree) {
      Console.Write("{0} ", x);
    }
    Console.WriteLine("");
    for (int i = 0; i &lt; 10; i++) {
      tree = tree.Delete(i);
      Console.WriteLine("{0} {1}", i, tree.Search(i));
      tree.Each(x =&gt; Console.Write("{0} ", x));
      Console.WriteLine("");
    }
  }
}
</pre>
<pre>
C&gt;tree1
-1 False
0 True
1 True
2 True
3 True
4 True
5 True
6 True
7 True
8 True
9 True
10 False
0
1
2
3
4
5
6
7
8
9
0 1 2 3 4 5 6 7 8 9
0 False
1 2 3 4 5 6 7 8 9
1 False
2 3 4 5 6 7 8 9
2 False
3 4 5 6 7 8 9
3 False
4 5 6 7 8 9
4 False
5 6 7 8 9
5 False
6 7 8 9
6 False
7 8 9
7 False
8 9
8 False
9
9 False

</pre>
<hr>
<h4 id="chap21">●８パズル (幅優先探索)</h4>
<p> 皆さんお馴染みの「８パズル」を幅優先探索で解くプログラムです。詳しい説明は拙作のページ <a href="../linux/clang22.html">Ｃ言語超入門: スライドパズル</a> をお読みください。
</p>
<pre class="list">
//
// eight.cs : 8 パズル (幅優先探索)
//
//            Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections.Generic;

class State {
  public int space;
  public int[] board;
  public State prev;

  public State(int s, int[] b, State st) {
    space = s;
    board = b;
    prev = st;
  }
}

class Puzzle {
  // 隣接リスト
  // 0 1 2
  // 3 4 5
  // 6 7 8
  const int Size = 9;
  static int[][] adjacent = new int[Size][] {
    new int[] {1, 3},
    new int[] {0, 2, 4},
    new int[] {1, 5},
    new int[] {0, 4, 6},
    new int[] {1, 3, 5, 7},
    new int[] {2, 4, 8},
    new int[] {3, 7},
    new int[] {4, 6, 8},
    new int[] {5, 7},
  };
  
  // キュー
  const  int MaxSize = 181440;
  static State[] que = new State[MaxSize];
  static int rear;
  static int front;
  static void enq(State st) { que[rear++] = st; }
  static State deq() { return que[front++]; }
  static bool IsEmpty() { return rear == front; }
  
  static bool EqualBoard(int[] xs, int[] ys) {
    for (int i = 0; i &lt; Size; i++)
      if (xs[i] != ys[i]) return false;
    return true;
  }

  static int[] CopyBoard(int[] xs) {
    int[] ys = new int[Size];
    for (int i = 0; i &lt; Size; i++)
      ys[i] = xs[i];
    return ys;
  }
  
  static int BoardToInt(int[] xs) {
    int a = 0;
    foreach(int x in xs) {
      a = a * 10 + x;
    }
    return a;
  }

  static void PrintAnswer(State st) {
    if (st.prev != null) PrintAnswer(st.prev);
    foreach(int x in st.board) {
      Console.Write("{0} ", x);
    }
    Console.WriteLine("");
  }
  
  static void bfs(int[] start, int[] goal) {
    var ht = new Dictionary&lt;int, bool&gt;();
    enq(new State(Array.IndexOf(start, 0), start, null));
    ht[BoardToInt(start)] = true;
    while (!IsEmpty()) {
      State st = deq();
      int s = st.space;
      int[] b = st.board;
      if (EqualBoard(b, goal)) {
        PrintAnswer(st);
        return;
      } else {
        foreach(int x in adjacent[s]) {
          int[] newBoard = CopyBoard(b);
          newBoard[s] = newBoard[x];
          newBoard[x] = 0;
          int key = BoardToInt(newBoard);
          if (!ht.ContainsKey(key)) {
            ht[key] = true;
            enq(new State(x, newBoard, st));
          }
        }
      }
    }
  }

  static void Main() {
    bfs(new int[] {8,6,7,2,5,4,3,0,1},
        new int[] {1,2,3,4,5,6,7,8,0});
  }
}
</pre>
<pre>
C&gt;eight
8 6 7 2 5 4 3 0 1
8 6 7 2 0 4 3 5 1
8 0 7 2 6 4 3 5 1
0 8 7 2 6 4 3 5 1
2 8 7 0 6 4 3 5 1
2 8 7 3 6 4 0 5 1
2 8 7 3 6 4 5 0 1
2 8 7 3 6 4 5 1 0
2 8 7 3 6 0 5 1 4
2 8 0 3 6 7 5 1 4
2 0 8 3 6 7 5 1 4
2 6 8 3 0 7 5 1 4
2 6 8 0 3 7 5 1 4
2 6 8 5 3 7 0 1 4
2 6 8 5 3 7 1 0 4
2 6 8 5 3 7 1 4 0
2 6 8 5 3 0 1 4 7
2 6 0 5 3 8 1 4 7
2 0 6 5 3 8 1 4 7
2 3 6 5 0 8 1 4 7
2 3 6 0 5 8 1 4 7
2 3 6 1 5 8 0 4 7
2 3 6 1 5 8 4 0 7
2 3 6 1 5 8 4 7 0
2 3 6 1 5 0 4 7 8
2 3 0 1 5 6 4 7 8
2 0 3 1 5 6 4 7 8
0 2 3 1 5 6 4 7 8
1 2 3 0 5 6 4 7 8
1 2 3 4 5 6 0 7 8
1 2 3 4 5 6 7 0 8
1 2 3 4 5 6 7 8 0
</pre>
<hr>
<h4 id="chap22">●８パズル (反復深化)</h4>
<p> 皆さんお馴染みの「８パズル」を反復深化と下限値枝刈り法で解くプログラムです。詳しい説明は拙作のページ <a href="../linux/clang23.html">Ｃ言語超入門: スライドパズル (2)</a> をお読みください。
</p>
<pre class="list">
//
// eight1.cs : 8 パズル (反復深化＋下限値枝刈り法)
//
//             Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Collections.Generic;

class Puzzle {
  // 隣接リスト
  // 0 1 2
  // 3 4 5
  // 6 7 8
  const int Size = 9;
  static int[][] adjacent = new int[Size][] {
    new int[] {1, 3},
    new int[] {0, 2, 4},
    new int[] {1, 5},
    new int[] {0, 4, 6},
    new int[] {1, 3, 5, 7},
    new int[] {2, 4, 8},
    new int[] {3, 7},
    new int[] {4, 6, 8},
    new int[] {5, 7},
  };

  // 移動距離
  static int[,] distance = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0},  // dummy
    {0, 1, 2, 1, 2, 3, 2, 3, 4},
    {1, 0, 1, 2, 1, 2, 3, 2, 3},
    {2, 1, 0, 3, 2, 1, 4, 3, 2},
    {1, 2, 3, 0, 1, 2, 1, 2, 3},
    {2, 1, 2, 1, 0, 1, 2, 1, 2},
    {3, 2, 1, 2, 1, 0, 3, 2, 1},
    {2, 3, 4, 1, 2, 3, 0, 1, 2},
    {3, 2, 3, 2, 1, 2, 1, 0, 1},
  };
  
  // 解の総数
  static int count;

  // 移動距離の計算
  static int CalcDistance(int[] board) {
    int d = 0;
    for (int i = 0; i &lt; Size; i++) {
      int p = board[i];
      d += distance[p, i];
    }
    return d;
  }
  
  static bool EqualBoard(int[] xs, int[] ys) {
    for (int i = 0; i &lt; Size; i++)
      if (xs[i] != ys[i]) return false;
    return true;
  }

  static void dfs(int[] board, int s, int[] goal, int limit, int low, List&lt;int&gt; move) {
    if (move.Count - 1 == limit) {
      if (EqualBoard(board, goal)) {
        count++;
        foreach(int x in move) {
          Console.Write("{0} ", x);
        }
        Console.WriteLine("");
      }
    } else {
      foreach(int x in adjacent[s]) {
        int p = board[x];
        if (p == move[move.Count - 1]) continue;
        int newLow = low - distance[p, x] + distance[p, s];
        if (newLow + move.Count - 1 &lt;= limit) {
          board[s] = p;
          board[x] = 0;
          move.Add(p);
          dfs(board, x, goal, limit, newLow, move);
          move.RemoveAt(move.Count - 1);
          board[x] = p;
          board[s] = 0;
        }
      }
    }
  }

  static void Main() {
    var start = new int[] {8,6,7,2,5,4,3,0,1};
    var goal  = new int[] {1,2,3,4,5,6,7,8,0};
    var move = new List&lt;int&gt;();
    move.Add(0);   // dummy
    int low = CalcDistance(start);
    for(int limit = low; limit &lt; 32; limit++) {
      Console.WriteLine("----- {0} -----", limit);
      dfs(start, 7, goal, limit, low, move);
      if (count &gt; 0) break;
    }
    Console.WriteLine("count = {0}", count);
  }
}
</pre>
<pre>
C&gt;eight1
----- 21 -----
----- 22 -----
----- 23 -----
----- 24 -----
----- 25 -----
----- 26 -----
----- 27 -----
----- 28 -----
----- 29 -----
----- 30 -----
----- 31 -----
0 5 6 8 2 3 5 1 4 7 8 6 3 5 1 4 7 8 6 3 5 1 4 7 8 6 3 2 1 4 7 8
0 5 6 7 4 6 2 3 5 1 6 2 3 8 7 4 2 3 1 5 8 7 4 1 5 8 7 4 1 2 3 6
0 5 2 3 5 1 4 7 6 8 3 2 8 3 2 5 1 4 7 8 5 1 4 7 8 6 3 2 1 4 7 8

        ・・・ 省略 ・・・

0 1 4 5 2 3 1 4 5 7 6 8 3 2 8 3 2 1 4 5 7 8 5 7 8 6 3 2 1 4 7 8
0 1 4 5 2 3 1 4 5 7 6 2 3 8 2 3 8 1 4 8 7 5 8 7 5 6 3 2 1 4 7 8
0 1 4 5 2 3 1 4 5 7 6 2 3 8 2 3 8 1 4 5 7 8 5 7 8 6 3 2 1 4 7 8
count = 40
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>