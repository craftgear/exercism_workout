<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ＃プログラミング超入門</title>
  <meta name="description" content="C#,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881817</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>C# Programming</h1>
<h2>お気楽Ｃ＃プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
<hr>
</div>
<section class="contents">
<h3>C# の基礎知識</h3>
<h4 id="abc01">●基本的なデータ型</h4>
<ul>
  <li>C# のデータ型は「値型」と「参照型」の二種類がある
  <li>値型はデータを直接変数 (メモリ) に保持する (数, 文字, 真偽値, 構造体など)
  <li>参照型はデータへの参照情報 (アドレス) を変数に保持する (文字列, 配列, オブジェクトなど)
  <li>数
    <ul>
      <li>sbyte, short, int, long (8, 16, 32, 64 bit 符号付き整数)
      <li>byte, ushort, uint, ulong (8, 16, 32, 64 bit 無符号整数)
      <li>float (32 bit 浮動小数点数)
      <li>double (64 bit 浮動小数点数)
      <li>decimal (10 進小数)
    </ul>
  <li>文字 char, ' で囲む ('a', 'A' など)
  <li>真偽値 bool (true, false)
  <li>文字列 string, " で囲む (演算子 + で文字列の連結ができる)
  <li>配列
    <ul>
      <li>配列の定義
        <ul>
          <li>データ型[] 変数名 = new データ型 [大きさ];
          <li>データ型[] 変数名 = new データ型 [] {値1, ..., 値N};
          <li>データ型[] 変数名 = {値1, ..., 値N};
        </ul>
      <li>要素のアクセスは角カッコ [ ] を使う
      <li>添字は 0 から始まる
      <li>配列の大きさは 変数名.Length で求めることができる
      <li>二次元配列の定義
        <ul>
          <li>データ型[,] 変数名 = new データ型 [大きさ1, 大きさ2];
          <li>データ型[,] 変数名 = new データ型 [,] {{値1, ..}, {値2, ...}};
          <li>データ型[,] 変数名 = {{値1, ...}, {値2, ...}};
        </ul>
      <li>要素のアクセスは角カッコの中をカンマ ( , ) で区切る
      <li>多次元配列は角カッコの中を次元数の数だけカンマで区切る
      <li>多次元配列の場合、Length は配列全体の大きさになる
      <li>各次元の大きさはメソッド GetLenght() で求めることができる
      <li>配列の配列 (ジャグ配列) も定義できる
        <ul>
          <li>データ型 [][] 変数名 = new データ型[大きさ][]
        </ul>
    </ul>
</ul>
<pre>
csharp&gt; int[] a = new int[10]; 
csharp&gt; a[0];
0
csharp&gt; a[9] = 1;
csharp&gt; a[9];
1
csharp&gt; int[,] b = {{1,2,3},{4,5,6},{7,8,9}};
csharp&gt; b[0,0];
1
csharp&gt; b[2,2]; 
9
csharp&gt; b[2,2] = 10;
csharp&gt; b[2,2];      
10
csharp&gt; var c = new int[3, 4];
csharp&gt; c.Length;
12
csharp&gt; c.GetLength(0);
3
csharp&gt; c.GetLength(1);
4
</pre>
<h4 id="abc02">●基本的な演算子</h4>
<ul>
  <li>算術演算子 (+, -, *, /, %)
  <li>比較演算子 (==, !=, &lt;, &gt;, &lt;=, &gt;=)
  <li>論理演算子 (!, &&, ||)
  <li>ビット演算子 (~, &, |, ^, &lt;&lt;, &gt;&gt;)
  <li>代入演算子 (=, +=, -=, *=, /=, %=, &=, |=, ^=, &lt;&lt;=, &gt;&gt;=)
  <li>インクリメント (++)
  <li>デクリメント (--)
  <li>三項演算子 (test ? true節 : else節)
</ul>
<h4 id="abc03">●基本的な制御構造</h4>
<ul>
  <li>if (test1) { then節; ... } else if (test2) { then節2; ... } else { else節; ... }
  <li>switch(変数) { case 値1: 処理1; ...; break; ... default: 処理; ... }
  <li>C# の switch はフォールスルーを禁止している
  <li>ただし、case 1: case 2: のように連続して書くことはできる
  <li>while (test) { 処理; ... }
  <li>do { 処理; ... } while (test);
  <li>for (初期化式; 条件式; 更新式) { 処理; ... }
  <li>foreach(データ型 変数 in collection) { 処理; ... }
  <li>繰り返しの制御に break と continue が使える
</ul>
<h4 id="abc04">●関数</h4>
<ul>
  <li>C# の場合、関数はメソッド (method) のことで、クラス (class) の中で定義する
  <li>関数のように使いたい場合は static を付ける (静的メソッド)
    <ul>
      <li>static 返り値のデータ型 関数名(データ型 仮引数名, ...) { 処理; ...; return 返り値; }
    </ul>
  <li>返り値が無い場合はデータ型を void にする
  <li>関数呼び出しは 関数名(実引数, ...)
  <li>他のクラスから呼び出す場合は public も付ける
  <li>この場合、関数呼び出しは クラス名.関数名(実引数, ...) になる
  <li>関数名は Pascal 形式 (各単語の頭文字を大文字にしてつなげる) で記述する
  <li>C# の関数 (メソッド) は多重定義 (オーバーロード) が可能
  <li>引数名 (変数名) は Camel 形式 (先頭文字を小文字、つなげる単語の頭文字を大文字) で記述する
  <li>可変長引数の定義は データ型 関数名(..., params 配列型 仮引数名) { ... }
  <li>可変長引数に配列を渡すと、その配列を展開して関数に渡す
  <li>オプション引数の定義は データ型 関数名(..., データ型 仮引数名 = 値) { ... }
  <li>関数を呼び出すとき、名前付き引数 (仮引数名: 値, ...) を使用できる
  <li>末尾再帰最適化はサポートされていないようだ
</ul>
<pre class="list">
リスト : 階乗とフィボナッチ関数

using System;

class Test {
  // 再帰
  static long Fact(long n) {
    return n == 0 ? 1 : n * Fact(n - 1);
  }

  // 繰り返し
  static long Facti(long n) {
    long a = 1;
    for (long i = 2; i &lt;= n; i++) a *= i;
    return a;
  }

  // 再帰
  static int Fibo(int n) {
    if (n &lt; 2) return n;
    return Fibo(n - 2) + Fibo(n - 1);
  }

  // 繰り返し
  static int Fiboi(int n) {
    int a = 0, b = 1;
    while (n-- &gt; 0) {
      int c = a + b;
      a = b;
      b = c;
    }
    return a;
  }

  static void Main() {
    Console.WriteLine("{0}! = {1}", 10, Fact(10));
    Console.WriteLine("{0}! = {1}", 15, Fact(15));
    Console.WriteLine("{0}! = {1}", 20, Fact(20));
    Console.WriteLine("{0}! = {1}", 10, Facti(10));
    Console.WriteLine("{0}! = {1}", 15, Facti(15));
    Console.WriteLine("{0}! = {1}", 20, Facti(20));
    Console.WriteLine("Fibo({0}) = {1}", 10, Fibo(10));
    Console.WriteLine("Fibo({0}) = {1}", 15, Fibo(15));
    Console.WriteLine("Fibo({0}) = {1}", 20, Fibo(20));
    Console.WriteLine("Fiboi({0}) = {1}", 10, Fiboi(10));
    Console.WriteLine("Fiboi({0}) = {1}", 15, Fiboi(15));
    Console.WriteLine("Fiboi({0}) = {1}", 20, Fiboi(20));
  }
}
</pre>
<pre>
C&gt;factfibo
10! = 3628800
15! = 1307674368000
20! = 2432902008176640000
10! = 3628800
15! = 1307674368000
20! = 2432902008176640000
Fibo(10) = 55
Fibo(15) = 610
Fibo(20) = 6765
Fiboi(10) = 55
Fiboi(15) = 610
Fiboi(20) = 6765
</pre>
<h4 id="abc05">●変数</h4>
<ul>
  <li>変数宣言は データ型 変数名; または データ型 変数名 = 初期値; 
  <li>変数名は Camel 形式 (先頭文字を小文字、つなげる単語の頭文字を大文字) で記述する
  <li>データ型に var を指定するとコンパイラがデータ型を決定する (型推論)
  <li>変数の有効範囲は宣言されているブロック { ... } の中
  <li>ブロックが入れ子の場合、内側のブロックで外側のブロックと同名の変数を宣言することはできない
  <li>C# の場合、グローバル変数は基本的に定義できない (代替の方法はある)
</ul>
<h4 id="abc06">●クラス</h4>
<ul>
  <li>クラス定義は class クラス名 { ... }
  <li>クラス内で宣言された変数を「フィールド (field)」とか「メンバ変数」という
  <li>クラス内で定義された関数を「メソッド (method)」という
  <li>メソッドに static を付けると「静的メソッド」になる
    <ul>
      <li>他のプログラミング言語では「クラスメソッド」と呼ばれることもある
      <li>静的メソッドは クラス名.メソッド名(...) で呼び出す
    </ul>
  <li>フィールドに static を付けると「静的フィールド」になる
    <ul>
      <li>他のプログラミング言語では「クラス変数」と呼ばれることもある
      <li>静的フィールドは クラス名.フィールド名 でアクセスする
    </ul>
  <li>フィールドやメソッドにはアクセス修飾子をつけることができる
    <ul>
      <li>public, protected, internal, private
      <li>省略した場合は private
    </ul>
  <li>インスタンスの生成は new クラス名() で行う
  <li>このときクラスと同名のメソッド (コンストラクタ) が呼び出される
    <ul>
      <li>アクセス修飾子 クラス名(データ型 仮引数, ...) { ... }
      <li>コンストラクタは値を返さない (void はつけない)
      <li>コンストラクタも多重定義できる
      <li>static を付けると「静的コンストラクタ」になる
      <li>静的コンストラクタはクラスを初めて使うときに一度だけ呼び出される
    </ul>
  <li>インスタンスを obj とすると、フィールドのアクセスは obj.field名, メソッドの呼び出しは obj.メソッド名(実引数, ...) 
  <li>メソッドの中で変数 this は自分自身 (インスタンス) を表す
  <li>不要になったインスタンスは GC (ガベージコレクション) により回収される
  <li>このとき、デストラクタが呼び出される
    <ul>
      <li>~クラス名() { ... }
      <li>引数と返り値はない
    </ul>
  <li>class の前に static を付けると「静的クラス」になる
    <ul>
      <li>静的クラスで定義できるのは静的なフィールドやメソッドだけ
      <li>静的クラスはインスタンスを生成できない
    </ul>
  <li>using static クラス名; とすると、静的フィールドや静的メソッドの指定でクラス名を省略できる
</ul>
<pre class="list">
リスト : 簡単な例題 (Point, Point3D クラス)

using System;

class Point {
  double x = 0.0, y = 0.0;

  // コンストラクタ
  public Point() { }
  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  // メソッド
  public double Distance(Point p) {
    double dx = x - p.x;
    double dy = y - p.y;
    return Math.Sqrt(dx * dx + dy * dy);
  }
}

class Point3D {
  double x = 0.0, y = 0.0, z = 0.0;

  // コンストラクタ
  public Point3D() { }
  public Point3D(double x, double y, double z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  // メソッド
  public double Distance(Point3D p) {
    double dx = x - p.x;
    double dy = y - p.y;
    double dz = z - p.z;
    return Math.Sqrt(dx * dx + dy * dy + dz * dz);
  }
}

class Test {
  static void Main() {
    var p1 = new Point();
    var p2 = new Point(1.0, 1.0);
    Console.WriteLine("{0}", p1.Distance(p2));
    var p3 = new Point3D();
    var p4 = new Point3D(1.0, 1.0, 1.0);
    Console.WriteLine("{0}", p3.Distance(p4));
  }
}
</pre>
<pre>
C&gt;point
1.4142135623731
1.73205080756888
</pre>
<h4 id="abc07">●継承</h4>
<ul>
  <li>C# のクラスは他のクラスのフィールドやメソッドを「継承」することができる
  <li>元になるクラスを「スーパークラス」、継承したクラスを「サブクラス」とか「派生クラス」という
  <li>C# は単一継承なのでスーパークラスは一つだけ指定できる
    <ul>
      <li>class クラス名 : スーパークラス { ... }
      <li>スーパークラスの指定を省略すると暗黙のうちにクラス object を継承する
    </ul>
  <li>「インターフェース (interface)」はいくつでも継承できる
  <li>コンストラクタは最上位のスーパークラスから順番に呼び出される
  <li>このとき呼び出されるのは引数なしのコンストラクタ
  <li>スーパークラスのコンストラクタは base を使って明示的に呼び出すこともできる
    <ul>
      <li>public クラス名(引数, ...) : base(引数, ...) { ... }
    </ul>
  <li>サブクラスでスーパークラスのメソッドと同名のメソッドを定義することができる
  <li>これを「オーバーライド (over ride)」という
  <li>C# の場合、オーバーライドする時は修飾子 new を付ける
    <ul>
      <li>public new type MethodName(...) { ... }
      <li>new をつけないとコンパイラが警告をだす
    </ul>
  <li>オーバーライドしたメソッドからスーパークラスのメソッドを呼び出すときは base を使う
    <ul>
      <li>base.MethodName(...); // スーパークラスの MethodName を呼び出す
    </ul>
  <li>継承を禁止する場合は class の前に修飾子 sealed を付ける
</ul>
<pre class="list">
リスト : 継承の簡単なサンプル

using System;

class Foo {
  int x = 0, y = 0;

  public Foo() {}
  public Foo(int a, int b) {
    x = a;
    y = b;
  }

  // アクセスメソッド
  public int GetX() { return x; }
  public int GetY() { return y; }
  public void SetX(int a) { x = a; }
  public void SetY(int b) { y = b; }

  // 合計値を求める
  public int Sum() {
    return x + y;
  }
}

class Bar : Foo {
  int z = 0;

  public Bar() { }
  public Bar(int a, int b, int c) : base(a, b) {
    z = c;
  }

  // アクセスメソッド
  public int GetZ() { return z; }
  public void SetZ(int c) { z = c; }

  // 合計値を求める
  public new int Sum() {
    return z + base.Sum();
  }
}

class Test {
  static void Main() {
    var a = new Foo(1, 2);
    var b = new Bar(10, 20, 30);
    Console.WriteLine("{0}", a.Sum());  // 3 と表示
    Console.WriteLine("{0}", b.Sum());  // 60 と表示
  }
}
</pre>
<pre>
C&gt;test
3
60
</pre>
<h4 id="abc08">●仮想関数とポリモーフィズム</h4>
<ul>
  <li>サブクラスのインスタンスはスーパークラスの変数に代入することができる
  <li>これを「アップキャスト」という
  <li>アップキャストした場合、スーパークラスと同じデータ型として扱われるため、「ポリモーフィズム」が機能しない
  <li>ポリモーフィズムを機能させるには「仮想関数」を使う
    <ul>
      <li>public virtual データ型 メソッド名(...) { ... }
    </ul>
  <li>virtual を付けると仮想関数になる
  <li>サブクラスでオーバーライドするメソッドは override を付ける
    <ul>
      <li>public override データ型 メソッド名(...) { ... }
    </ul>
</ul>
<pre class="list">
リスト : 仮想関数の簡単な例題

using System;

class Foo {
  int x = 0, y = 0;

  public Foo() {}
  public Foo(int a, int b) {
    x = a;
    y = b;
  }

  // アクセスメソッド
  public int GetX() { return x; }
  public int GetY() { return y; }
  public void SetX(int a) { x = a; }
  public void SetY(int b) { y = b; }

  // 合計値を求める
  public virtual int Sum() {
    return x + y;
  }
}

class Bar : Foo {
  int z = 0;

  public Bar() { }
  public Bar(int a, int b, int c) : base(a, b) {
    z = c;
  }

  // アクセスメソッド
  public int GetZ() { return z; }
  public void SetZ(int c) { z = c; }

  // 合計値を求める
  public override int Sum() {
    return z + base.Sum();
  }
}

class Test {
  static void Main() {
    Foo a = new Foo(1, 2);
    Foo b = new Bar(10, 20, 30);        // アップキャスト
    Console.WriteLine("{0}", a.Sum());  // 3 と表示
    Console.WriteLine("{0}", b.Sum());  // 60 と表示
  }
}
</pre>
<h4 id="abc09">●抽象クラスと抽象メソッド</h4>
<ul>
  <li>メソッドを定義するとき、メソッドの型だけを宣言することができる
  <li>これを「抽象メソッド (abstract method)」という
  <li>抽象メソッドを持つクラスを「抽象クラス (abstract class)」という
  <li>抽象クラスはインスタンスを生成することができない
  <li>抽象クラスと抽象メソッドは修飾子 abstract を付ける
<pre class="list">
abstract class クラス名 {
  ...
  abstract データ型 メソッド名(データ型 引数, ...);
  ...
}
</pre>
  <li>抽象クラスは継承されることを前提としたクラス
  <li>抽象メソッドはサブクラスにおいて具体的に定義される (override を付ける)
</ul>
<pre class="list">
リスト : 抽象クラスと抽象メソッドの簡単な例題

using System;

abstract class Figure {
  public abstract string KindOf();
  public abstract double Area();
  public void Print(){
    Console.WriteLine("{0}: area = {1}", KindOf(), Area());
  }
}

// 三角形
class Triangle : Figure {
  double altitude, base_line;
  public Triangle(double a, double b){
    altitude = a;
    base_line = b;
  }
  public override string KindOf(){
    return "Triangle";
  }
  public override double Area(){
    return altitude * base_line / 2.0;
  }
}

// 四角形
class Rectangle : Figure {
  double width, height;
  public Rectangle(double w, double h){
    width = w;
    height = h;
  }
  public override string KindOf(){
    return "Rectangle";
  }
  public override double Area(){
    return width * height;
  }
}

// 円
class Circle : Figure {
  double radius;
  public Circle(double r){
    radius = r;
  }
  public override string KindOf(){
    return "Circle";
  }
  public override double Area(){
    return radius * radius * Math.PI;
  }
}

class Test {
  static void Main() {
    Triangle a = new Triangle(2.0, 2.0);
    Rectangle b = new Rectangle(2.0, 2.0);
    Circle c = new Circle(2.0);
    a.Print();
    b.Print();
    c.Print();
    Figure[] figTable = {
      new Triangle(3.0, 3.0),
      new Rectangle(3.0, 3.0),
      new Circle(3.0),
    };
    foreach(Figure f in figTable) {
      f.Print();
    }
  }
}
</pre>
<pre>
C&gt;figure
Triangle: area = 2
Rectangle: area = 4
Circle: area = 12.5663706143592
Triangle: area = 4.5
Rectangle: area = 9
Circle: area = 28.2743338823081
</pre>
<h4 id="abc10">●インターフェース</h4>
<ul>
  <li>インターフェース (interface) はメソッドの仕様 (宣言) だけを記述した抽象クラス
    <ul>
      <li>interface インターフェース名 { メソッドの宣言; ... }
      <li>宣言されたメソッドは public abstract になる
    </ul>
  <li>メソッドはインターフェースを継承したサブクラスで実装する
    <ul>
      <li>class クラス名 : スーパークラス, インターフェース1, ... { メソッドの実装; ... }
      <li>インターフェースはいくつでも継承することができる
    </ul>
  <li>インターフェースもデータ型として使用できる (アップキャスト可能)
</ul>
<pre class="list">
リスト : インターフェースの簡単な使用例

using System;

// インターフェースの定義
interface Figure {
  string KindOf();
  double Area();
  void Print();
}

// 三角形
class Triangle : Figure {
  double altitude, base_line;
  public Triangle(double a, double b){
    altitude = a;
    base_line = b;
  }
  public string KindOf(){
    return "Triangle";
  }
  public double Area(){
    return altitude * base_line / 2.0;
  }
  public void Print(){
    Console.WriteLine("{0}: area = {1}", KindOf(), Area());
  }
}

// 四角形
class Rectangle : Figure {
  double width, height;
  public Rectangle(double w, double h){
    width = w;
    height = h;
  }
  public string KindOf(){
    return "Rectangle";
  }
  public double Area(){
    return width * height;
  }
  public void Print(){
    Console.WriteLine("{0}: area = {1}", KindOf(), Area());
  }
}

// 円
class Circle : Figure {
  double radius;
  public Circle(double r){
    radius = r;
  }
  public string KindOf(){
    return "Circle";
  }
  public double Area(){
    return radius * radius * Math.PI;
  }
  public void Print(){
    Console.WriteLine("{0}: area = {1}", KindOf(), Area());
  }
}

class Test {
  static void Main() {
    Triangle a = new Triangle(2.0, 2.0);
    Rectangle b = new Rectangle(2.0, 2.0);
    Circle c = new Circle(2.0);
    a.Print();
    b.Print();
    c.Print();
    Figure[] figTable = {
      new Triangle(3.0, 3.0),
      new Rectangle(3.0, 3.0),
      new Circle(3.0),
    };
    foreach(Figure f in figTable) {
      f.Print();
    }
  }
}
</pre>
<h4 id="abc11">●プロパティ</h4>
<ul>
  <li>「プロパティ (property)」はクラス外部から見るとフィールドと同じように振る舞うメソッドのこと
<pre class="list">
class クラス名 {

  アクセス修飾子 データ型 プロパティ名 {
    get { ... }  // getter
    set { ... }  // setter
  }

}
</pre>
  <li>インスタンス.プロパティ名 で値を取得する
  <li>インスタンス.プロパティ名 = 値 で値を更新する
  <li>getter の場合、this.フィールド名 で値の取得して return で返す
  <li>setter の場合、キーワード value で右辺式の値を取得できる
  <li>getter と setter は自動生成することができる
<pre class="list">
class Foo {
  public int Bar { get; set; }
}
</pre>
  <li>このとき値を格納するフィールドも自動生成される
  <li>getter だけを自動生成することもできる
  <li>この場合、値の代入ができるのはコンストラクタの中だけ
</ul>
<pre class="list">
リスト : プロパティの簡単な例題

using System;

class Foo {
  public int X { set; get; }
  public int Y { set; get; }

  // 合計値を求める
  public int Sum {
    get { return X + Y; }
  }
}

class Test {
  static void Main() {
    var a = new Foo();
    a.X = 10;
    a.Y = 20;
    Console.WriteLine("{0}", a.Sum);  // 30
  }
}
</pre>
<pre class="list">
リスト : getter だけ自動生成する

using System;

class Foo {
  public Foo(int a, int b) {
    X = a;
    Y = b;
  }

  public int X { get; }
  public int Y { get; }

  // 合計値を求める
  public int Sum {
    get { return X + Y; }
  }
}

class Test {
  static void Main() {
    var a = new Foo(10, 20);
    Console.WriteLine("{0}", a.Sum);  // 30
  }
}
</pre>

</ul>
<h4 id="abc12">●ジェネリック </h4>
<ul>
  <li>ジェネリック (generics) はデータ型をパラメータ化する機能のこと
  <li>型パラメータ (型引数) は &lt;T, U, V, ...&gt; のように &lt; &gt; の中で指定する
  <li>ジェネリックを使ってメソッドとクラスを定義できる
    <ul>
      <li>データ型 メソッド名&lt;T, ...&gt;(仮引数, ...) where 制約条件 { ... }
      <li>class クラス名&lt;T, ...&gt; where 制約条件 { ... }
      <li>制約条件の指定方法
        <ul>
          <li>where T : struct (型 T は値型)
          <li>where T : class (型 T は値型)
          <li>where T : new() (型 T は引数なしのコンストラクタを持つ)
          <li>where T : class_name (型 T はクラス class_name を継承する)
          <li>where T : interface_name (型 T はインターフェース interface_name を実装している)
        </ul>
    </ul>
  <li>データ型は クラス名&lt;データ型, ...&gt; になる
  <li>インスタンスの生成は new クラス名&lt;データ型, ...&gt;(実引数, ...)
  <li>メソッドの呼び出しは メソッド名&lt;データ型, ...&gt;(実引数, ...)
    <ul>
      <li>実引数から型変数のデータ型が特定できる場合、型変数の指定は省略できる
    </ul>
</ul>
<pre class="list">
リスト : ジェネリッククラスの簡単な使用例

using System;

class Foo&lt;T&gt; {
  T x;
  public Foo() { x = default(T); }
  public Foo(T n) { x = n; }
  public T Get() { return x; }
};

class Bar&lt;T&gt; where T : new() {
  T y;
  public Bar() { y = new T(); }
  public Bar(T n) { y = n; }
  public T Get() { return y; }
};

class Baz {
  int z;
  public Baz() { z = 123; }
  public Baz(int n) { z = n; }
  public int Get() { return z; }
};

class Test {
  static void Main() {
    var a = new Foo&lt;int&gt;();
    var b = new Foo&lt;double&gt;(1.2345);
    var c = new Bar&lt;Baz&gt;();
    Console.WriteLine("{0}", a.Get());         // 0
    Console.WriteLine("{0}", b.Get());         // 1.2345
    Console.WriteLine("{0}", c.Get().Get());   // 123
  }
}
</pre>
<pre class="list">
リスト : ジェネリックメソッドの簡単な使用例

using System;

class Test {
  // 型変数の場合、比較演算子は使えないので、
  // インターフェース IComparable を使う
  static int IndexOf&lt;T&gt;(T[] buff, T x) where T : IComparable {
    for (int i = 0; i &lt; buff.Length; i++) {
      if (x.CompareTo(buff[i]) == 0) return i;
    }
    return -1;
  }

  static void Main() {
    int[] a = {1,2,3,4,5,6,7,8};
    double[] b = {1.1, 2.2, 3.3, 4.4, 5.5};
    Console.WriteLine("{0}", IndexOf(a, 5));   // 4
    Console.WriteLine("{0}", IndexOf(a, 9));   // -1
    Console.WriteLine("{0}", IndexOf(b, 4.4)); // 3
    Console.WriteLine("{0}", IndexOf(b, 5.0)); // -1
  }
}
</pre>
<h4 id="abc13">●構造体</h4>
<ul>
  <li>構造体はクラスのようにユーザーが定義するデータ型
    <ul>
      <li>struct 構造体名 : インターフェース, ... { ... }
    </ul>
  <li>クラスは参照型になるが構造体は値型になる
  <li>変数に代入する (または引数に渡す) ときは値がコピーされる
  <li>構造体は引数なしのコンストラクタやデストラクタを定義することができない
  <li>引数があるコンストラクタやメソッドは定義できる
  <li>構造体はクラスや他の構造体を継承することはできない
  <li>構造体を継承してサブクラスを定義することもできない
  <li>インターフェースは継承することができる
  <li>データの生成は new 構造体名() で行う
  <li>引数なしで構造体を生成した場合、値型のフィールドは 0 に、参照型のフィールドは null に初期化される
  <li>ジェネリックも使用できる
</ul>
<pre class="list">
リスト : 構造体の簡単な使用例

using System;

struct Point {
  double x, y;
  public Point(double a, double b) {
    x = a;
    y = b;
  }
  public double Distance(Point p) {
    double dx = x - p.x;
    double dy = y - p.y;
    return Math.Sqrt(dx * dx + dy * dy);
  }
}

class Test {
  static void Main() {
    Point p1 = new Point();
    Point p2 = new Point(1.0, 1.0);
    Console.WriteLine("{0}", p1.Distance(p2));  // 1.4142135623731
  }
}
</pre>
<pre class="list">
リスト : 構造体とジェネリックの簡単な使用例

using System;

struct Pair&lt;T, U&gt; {
  T p;
  U q;
  public Pair(T a, U b) {
    p = a;
    q = b;
  }
  public T Fst() { return p; }
  public U Snd() { return q; }
};

class Test {
  static void Main() {
    var a = new Pair&lt;string, int&gt;("foo", 10);
    var b = new Pair&lt;string, double&gt;("bar", 1.2345);
    Console.WriteLine("{0}, {1}", a.Fst(), a.Snd());    // foo, 10
    Console.WriteLine("{0}, {1}", b.Fst(), b.Snd());    // bar, 1.2345
  }
}
</pre>
<h4 id="abc14">●デリゲートとラムダ式</h4>
<ul>
  <li>C# のデリゲート (delegate) はメソッドへの参照を表すデータ型を定義する
    <ul>
      <li>delegate 返り値のデータ型 型名(データ型 仮引数, ...);
    </ul>
  <li>Ｃ/Ｃ++の「関数へのポインタ」と似ている
  <li>デリゲートを使ってメソッドを変数に代入したり関数の引数に渡すことができる
</ul>
<pre class="list">
リスト : デリゲートの簡単な使用例

using System;

class Test {
  // int を受け取って int を返すメソッドの型 IntFunc を定義
  delegate int IntFunc(int x);

  // マッピング (intFunc 型のメソッドを受け取る高階関数)
  static int[] Map(IntFunc func, int[] xs) {
    int[] ys = new int[xs.Length];
    for (int i = 0; i &lt; xs.Length; i++)
      ys[i] = func(xs[i]);
    return ys;
  }

  // 引数を二乗するメソッド
  static int Square(int x) { return x * x; }
  
  static void Main() {
    int[] a = {1, 2, 3, 4, 5};
    foreach(int x in Map(Square, a))
      Console.Write("{0} ", x);        // 1 4 9 16 25 
    Console.WriteLine("");
  }
}
</pre>
<ul>
  <li>デリゲートはジェネリックを使って定義することができる
    <ul>
      <li>delegate T FuncOne&lt;T&gt;(T x);
      <li>static int[] Map(FuncOne&lt;int&gt; func, int[] xs) { ... }
    </ul>
  <li>C# には汎用のデリゲート Func&lt;T, U, ..., Result&gt; と Action&lt;T, U, ...&gt; が用意されている
  <li>Func は T, U, ... が仮引数の型、Result が返り値の型を表す
    <ul>
      <li>static int[] Map(Func&lt;int,int&gt; func, int[] xs) { ... }
    </ul>
  <li>返り値が無い場合は Action を使う
  <li>C# はデリゲートを使って匿名関数を定義できるが、今は「ラムダ式」を使ったほうが簡単
  <li>ラムダ式の定義は (データ型 仮引数, ...) =&gt; { 処理; ...; return 値; }
  <li>(仮引数, ...) =&gt; 式, 仮引数 =&gt; 式 とすることもできる (型推論が行われる)
</ul>
<pre class="list">
リスト : ラムダ式の簡単な使用例

using System;

class Test {
  // 配列のマッピング
  static T[] Map&lt;T&gt;(Func&lt;T, T&gt; func, T[] xs) {
    T[] ys = new T[xs.Length];
    for (int i = 0; i &lt; xs.Length; i++)
      ys[i] = func(xs[i]);
    return ys;
  }

  static void Main() {
    int[] a = {1, 2, 3, 4, 5};
    double[] b = {1.1, 2.2, 3.3, 4.4, 5.5};
    foreach(int x in Map(n =&gt; n * n, a))
      Console.Write("{0} ", x);              // 1 4 9 16 25
    Console.WriteLine("");
    foreach(double x in Map(n =&gt; n * n, b))
      Console.Write("{0} ", x);              // 1.21 4.84 10.89 19.36 30.25
    Console.WriteLine("");
  }
}
</pre>
<ul>
  <li>「クロージャ (closure)」もサポートされている
</ul>
<pre>
csharp&gt; Func&lt;int, Func&lt;int, int&gt;&gt; make_adder = n =&gt; x =&gt; n + x;
csharp&gt; Func&lt;int, int&gt; add10 = make_adder(10);
csharp&gt; add10(1);
11
csharp&gt; add10(20);
30
</pre>
<ul>
  <li>デリゲートには演算子 += を使って複数のメソッドを代入することができる 
  <li>これを「マルチキャストデリゲート」という
  <li>メソッドは代入した順番に実行される
</ul>
<pre>
csharp&gt; Action&lt;string&gt; greeting = mes =&gt; Console.WriteLine("hello, {0}", mes);
csharp&gt; greeting("M.Hiroi");
hello, M.Hiroi
csharp&gt; greeting += mes =&gt; Console.WriteLine("good by, {0}", mes);
csharp&gt; greeting("M.Hiroi");
hello, M.Hiroi
good by, M.Hiroi
</pre>
<h4 id="abc15">●例外処理</h4>
<ul>
  <li>例外 (Exception) は throw 文で送出する
    <ul>
      <li>throw new 例外クラス();
    </ul>
  <li>throw 文で送出できるデータ型は System.Exception (例外クラス) を継承したクラス
  <li>例外の捕捉は try - chach - finally 文を使う
</ul>
<pre class="list">
try {

  ...

} catch(例外クラス [引数]) {

  ...

} finally {

  ...

}
</pre>
<ul>
  <li>catch 節には捕捉する例外クラスを指定する
  <li>その引数には例外クラスのインスタンスがセットされる (引数は省略可)
  <li>catch 節はいくつでも指定することができる
  <li>finally 節は try 文の処理で例外が発生したかどうかにかかわらず、try 文の処理が終了するときに必ず実行される
</ul>
<pre>
csharp&gt; class Foo : Exception {};
csharp&gt; try { throw new Foo(); } catch(Foo) { Console.WriteLine("catch Foo"); };
catch Foo
csharp&gt; try { Console.WriteLine("foo"); } finally { Console.WriteLine("oops!");
foo
oops!
csharp&gt; try { throw new Foo(); } catch(Foo) { Console.WriteLine("catch Foo"); } finally { Console.WriteLine("oops!"); };
catch Foo
oops!
</pre>
</ul>
<h4 id="abc16">●可変長配列</h4>
<ul>
  <li>C# のライブラリには ArrayList と List&lt;T&gt; という可変長配列が用意されている
  <li>ここではジェネリックの List&lt;T&gt; の基本的な操作を簡単に説明する
  <li>List&lt;T&gt; は連結リストではない (LinkedList&lt;T&gt; が双方向リスト)
  <li>ジェネリックコレクションを使うときは using System.Collections.Generic; 
  <li>コンストラクタ
    <ul>
      <li>List&lt;T&gt;(); 空の配列を生成
      <li>List&lt;T&gt;(collection); collection の要素を格納した配列を生成
      <li>List&lt;T&gt;(size); 容量が size の配列を生成 (要素数は 0)
    </ul>
  <li>プロパティ
    <ul>
      <li>Capacity : 容量の取得と設定
      <li>Count : 要素数の取得
      <li>list[n] : n 番目の要素にアクセスする
    </ul>
  <li>基本的なメソッド
    <ul>
      <li>Add(item) 配列の末尾に item を追加
      <li>Clear() 配列を空にする
      <li>Contains(item) 配列の中に item があれば true を返す
      <li>Insert(n, item) 配列の n 番目に item を挿入
      <li>RemoveAt(n) 配列の n 番目の要素を削除
      <li>この他にも探索やソートなど便利なメソッドが多数用意されている
    </ul>
</ul>
<pre>
csharp&gt; var a = new List&lt;int&gt;();
csharp&gt; for (int i = 0; i &lt; 10; i++) a.Add(i);
csharp&gt; a
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp&gt; a.Insert(0, -1);
csharp&gt; a
{ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp&gt; a.RemoveAt(0);
csharp&gt; a
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp&gt; a.Count;
10
csharp&gt; a.Capacity;
16
csharp&gt; a.RemoveAt(a.Count - 1);
csharp&gt; a
{ 0, 1, 2, 3, 4, 5, 6, 7, 8 }
</pre>
<h4 id="abc17">●連想配列 (ハッシュ)</h4>
<ul>
  <li>C# のライブラリには HashTable と Dictionary&lt;K, V&gt; という連想配列 (ハッシュ) が用意されている
  <li>ここではジェネリックの Dictionary&lt;K, V&gt; の基本的な操作を簡単に説明する
  <li>ジェネリックコレクション を使うときは using System.Collections.Generic; 
  <li>コンストラクタ
    <ul>
      <li>Dictionary&lt;K, V&gt;(); 空のハッシュを生成
    </ul>
  <li>プロパティ
    <ul>
      <li>Count : 要素数を取得する
      <li>hash[key] : キー key の値を取得する (キーが見つからない場合はエラー)
      <li>hash[key] = val; : キー key の値を val に更新する
      <li>Keys : キーのコレクションを取得する
      <li>Values : 値のコレクションを取得する
    </ul>
  <li>基本的なメソッド
    <ul>
      <li>Add(key, val) key と val をハッシュに追加 (hash[key] = val でも OK)
      <li>Clear() ハッシュを空にする
      <li>ContainsKey(key) ハッシュの中にキー key があれば true を返す
      <li>ContainsValue(val) ハッシュの中に値 val があれば true を返す
      <li>Remove(key) ハッシュのキー key とその値を削除
      <li>削除できた場合は true, キーが見つからない場合は false を返す
    </ul>
</ul>
<pre>
csharp&gt; var a = new Dictionary<string, int>();
csharp&gt; a["foo"] = 10;
csharp&gt; a["baz"] = 20;
csharp&gt; a["bar"] = 30;
csharp&gt; a["oops"] = 40;
csharp&gt; a;
{{ "foo", 10 }, { "baz", 20 }, { "bar", 30 }, { "oops", 40 }}
csharp&gt; a.ContainsKey("foo");
true
csharp&gt; a.ContainsKey("Foo");
false
csharp&gt; a.Keys;
{ "foo", "baz", "bar", "oops" }
csharp&gt; a.Remove("foo");
true
csharp&gt; a;
{{ "baz", 20 }, { "bar", 30 }, { "oops", 40 }}
csharp&gt; a.Remove("foo");
false
csharp&gt; a.Remove("Foo");
false
</pre>
<h4 id="abc18">●イテレータ</h4>
<ul>
  <li>インターフェース IEnumerable のメソッド GetEnumerator() を実装すると foreach を使用することができる
  <li>GetEnumerator() はインターフェース IEnumerator を継承したクラスのインスタンスを返す
  <li>これがいわゆる「イテレータ (iterator)」として動作する
  <li>IEnumerator を継承する場合、次に示すプロパティとメソッドを実装する
    <ol>
      <li>Current イテレータが示す要素を取得する
      <li>bool MoveNext() イテレータを次の要素へ進める
      <li>void Reset() イテレータを初期値に戻す
    </ol>
  <li>C# は ver 2.0 以降になると、yield return を使ってイテレータを簡単に作ることができる
  <li>なお、C# では yield return による機能を「イテレータ」と呼んでいる
  <li>GetEnumerator() の中で yiled return 要素; を実行するだけ
  <li>イテレータを途中で中断するときは yield break を使う
</ul>
<pre class="list">
リスト : イテレータの簡単な例題

using System;
using System.Collections;

class Foo : IEnumerable {
  int a, b, c;
  public Foo(int x, int y, int z) {
    a = x;
    b = y;
    c = z;
  }

  public IEnumerator GetEnumerator() {
    yield return a;
    yield return b;
    yield return c;
  }
}

class Test {
  static void Main() {
    var a = new Foo(1, 2, 3);
    foreach(int n in a) {
      Console.WriteLine("{0}", n);
    }
  }
}
</pre>
<pre>
C&gt;test
1
2
3
</pre>
<ul>
  <li>ジェネリックの場合は IEnumerable&lt;T&gt; を継承する
  <li>実装するメソッドは IEnumerator&lt;T&gt; GetEnumerator()
  <li>もうひとつ IEnumerator IEnumerable.GetEnumerator() も実装すること
  <li>これを実装すると後述する LINQ のメソッドや高階関数を利用できるようになる
</ul>
<pre class="list">
リスト : ジェネリック版

using System;
using System.Collections;
using System.Collections.Generic;

class Foo&lt;T&gt; : IEnumerable&lt;T&gt; {
  T a, b, c;
  public Foo(T x, T y, T z) {
    a = x;
    b = y;
    c = z;
  }

  public IEnumerator&lt;T&gt; GetEnumerator() {
    yield return a;
    yield return b;
    yield return c;
  }

  // public は付けない
  IEnumerator IEnumerable.GetEnumerator() {
    return this.GetEnumerator();
  }
}

class Test {
  static void Main() {
    var a = new Foo&lt;int&gt;(1, 2, 3);
    foreach(int n in a) {
      Console.WriteLine("{0}", n);
    }
  }
}
</pre>
<pre>
C&gt;test
1
2
3
</pre>
<h4 id="abc19">●インデクサー</h4>
<ul>
  <li>インデクサーを使うと角カッコ [ ] で要素にアクセスすることができる
  <li>インデクサーの定義はプロパティと似ている
<pre class="list">
class クラス名 {

  アクセス修飾子 データ型 this[データ型 添字] {
    get { ... }  // getter
    set { ... }  // setter
  }

}
</pre>
  <li>プロパティの名前が this[データ型 添字] になるだけ
  <li>getter, setter は添字が使える以外プロパティと同じ
  <li>角カッコの中は配列と同じくカンマで区切って複数の添字を指定することができる
</ul>
<pre class="list">
リスト : インデクサーの簡単な例題

using System;

class Foo {
  int a, b, c;
  public Foo(int x, int y, int z) {
    a = x;
    b = y;
    c = z;
  }

  public int this[int n] {
    set {
      switch(n) {
      case 0: a = value; break;
      case 1: b = value; break;
      default: c = value; break;
      }
    }
    get {
      switch(n) {
      case 0: return a;
      case 1: return b;
      default: return c;
      }
    }
  }
}

class Test {
  static void Main() {
    var a = new Foo(1, 2, 3);
    for (int i = 0; i &lt; 3; i++) {
      a[i] *= 10;
      Console.WriteLine("{0}", a[i]);
    }
  }
}
</pre>
<pre>
C&gt;test
10
20
30
</pre>
<h4 id="abc20">●LINQ</h4>
<ul>
  <li>LINQ (Language Integrated Query) は、C# のデータだけではなく、データベースの問い合わせや XML の操作などを統一して行うための仕組み
  <li>LINQ には SQL 同様のクエリ式を使う方法と、標準的なメソッドや演算子を使う方法がある
  <li>前者の構文は後者のメソッドや演算子にコンパイルされる
  <li>LINQ には便利なメソッドや高階関数が多数用意されている
  <li>LINQ を使うときは using System.Linq;
  <li>マッピングは Select()
  <li>フィルターは Where()
  <li>畳み込みは Aggregate()
    <ul>
      <li>第 1 引数に初期値を指定することもできる
    </ul>
  <li>OrderBy() は昇順に、OrderByDescending() は逆順にソートする
    <ul>
      <li>引数はソート対象の要素を指定する関数
    </ul>
  <li>先頭からの探索が First(), 末尾からの探索が Last()
  <li>ElementAt() は n 番目の要素を返す
  <li>Cotains() は要素が含まれていれば真を返す
  <li>All() は引数の関数 (述語) を要素に適用し、すべて真ならば真を返す
  <li>Any() は引数の関数 (述語) を要素に適用し、ひとつでも真ならば真を返す
  <li>GroupBy() はキーを指定して、キーの値が等しいもの集める (グループ化)
  <li>その他の主なメソッド
    <ul>
      <li>Take, Skip, TakeWhilte, SkipWhile
      <li>Concat, Reverse
      <li>Distinct, Union, Intersect, Except
      <li>AsEnumerable, ToArray, ToList, ToDictionary
      <li>SequenceEqual
      <li>Range, Repeat, Empty
      <li>Count, Sum, Min, Max, Average
    </ul>
</ul>
<pre>
csharp&gt; var a = new int[8] {1,2,3,4,5,6,7,8};

csharp&gt; a.Select(n =&gt; n * n);
{ 1, 4, 9, 16, 25, 36, 49, 64 }
csharp&gt; a.Select(n =&gt; n * 1.5);
{ 1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12 }

csharp&gt; a.Where(n =&gt; n % 2 == 0);
{ 2, 4, 6, 8 }
csharp&gt; a.Where(n =&gt; n % 2 != 0);
{ 1, 3, 5, 7 }

csharp&gt; a.Aggregate((sum, n) =&gt; sum + n);
36
csharp&gt; a.Aggregate(100, (sum, n) =&gt; sum + n);
136

csharp&gt; var b = new int[] {5,6,4,7,3,8,2,9,1,0};
csharp&gt; b.OrderBy(n =&gt; n);
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
csharp&gt; b.OrderByDescending(n =&gt; n);
{ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }

csharp&gt; b.First(n =&gt; n % 2 == 0);
6
csharp&gt; b.Last(n =&gt; n % 2 != 0);
1

csharp&gt; var c = new int[] {2,4,6,8,10};
csharp&gt; c.All(n =&gt; n % 2 == 0);
true
csharp&gt; c.Any(n =&gt; n % 2 != 0);
false

csharp&gt; var d = new [] { new {name="foo", gr=1}, new {name="bar", gr=2},
      > new {name="baz", gr=1}, new {name="oops", gr=2}};
csharp&gt; d
{ { name = foo, gr = 1 }, { name = bar, gr = 2 }, { name = baz, gr = 1 }, { name = oops, gr = 2 } }
csharp&gt; d.GroupBy(n =&gt; n.gr)s), 0 warnings
{ { { name = foo, gr = 1 }, { name = baz, gr = 1 } }, { { name = bar, gr = 2 }, { name = oops, gr = 2 } } }
</pre>
<ul>
  <li>{ ... } は匿名型で、コンパイラが型名を決める
  <li>new [] { new { ... }, ... } で匿名型の配列を生成することができる
</ul>
<h4 id="abc21">●LINQ (クエリ式)</h4>
<ul>
  <li>SQL の場合、データの抽出は select 文を使う
    <ul>
      <li>select カラム名 form テーブル名 where 条件式;
    </ul>
  <li>C# の場合、クエリ式を使うと次のようになる
    <ul>
      <li>from 変数名 in コレクション where 条件式 select 要素;
    </ul>
  <li>昇順にソートする場合は select の前に orderby 要素 を指定する
  <li>逆順にソートする場合は orderby 要素 descending とする
  <li>group 要素 by キー は指定したキーでグループ化する
  <li>select と group の後ろにクエリ式を書くことはできない
  <li>into でクエリ式を連結することができる
    <ul>
      <li>... into 変数 ...
      <li>前のクエリ式の結果が into で指定した変数に格納される
    </ul>
</ul>
<pre>
csharp&gt; var b = new int[] {5,6,4,7,3,8,2,9,1,0};
csharp&gt; from x in b where x % 2 == 0 select x;
{ 6, 4, 8, 2, 0 }
csharp&gt; from x in b where x % 2 == 0 orderby x select x;
{ 0, 2, 4, 6, 8 }
csharp&gt; var xs = new[] { new {name="foo", score=10}, new {name="bar", score=20}, new {name="baz", score=40}, new {name="oops", score=30}};
csharp&gt; from x in xs where x.score > 20 select x.name;
{ "baz", "oops" }
csharp&gt; from x in xs where x.score > 20 select x;
{ { name = baz, score = 40 }, { name = oops, score = 30 } }
</pre>
<ul>
  <li>select で複数のフィールドを指定するときは匿名型で指定する
  <li>この場合、クエリ式で抽出された複数の値は匿名型に格納されて返される
</ul>
<pre class="list">
リスト : クエリ式の簡単な使用例

using System;
using System.Linq;

class Test {
  static void Main() {
    var heightTable = new [] {
      new {id=1,  name="Ada",    height=148.7, rank=1},
      new {id=2,  name="Alice",  height=149.5, rank=2},
      new {id=3,  name="Carey",  height=133.7, rank=3},
      new {id=4,  name="Ellen",  height=157.9, rank=4},
      new {id=5,  name="Hanna",  height=154.2, rank=1},
      new {id=6,  name="Janet",  height=147.8, rank=2},
      new {id=7,  name="Linda",  height=154.6, rank=3},
      new {id=8,  name="Maria",  height=159.1, rank=4},
      new {id=9,  name="Miranda",height=148.2, rank=1},
      new {id=10, name="Sara",   height=153.1, rank=2},
      new {id=11, name="Tracy",  height=138.2, rank=3},
      new {id=12, name="Violet", height=138.7, rank=4},
    };
    var xs = from x in heightTable where x.height &lt; 140
             orderby x.height select new {x.name, x.height};
    foreach(var x in xs) {
      Console.WriteLine("{0}, {1}", x.name, x.height);
    }
    var ys = from x in heightTable where x.height &gt; 150
             orderby x.height descending select new {x.name, x.height};
    foreach(var y in ys) {
      Console.WriteLine("{0}, {1}", y.name, y.height);
    }
    var gs = from x in heightTable
      group new { x.name, x.height } by x.rank;
    foreach(var g in gs) {
      Console.Write("{0}: ", g.Key);  // プロパティ Key でキーの値を取得できる
      foreach(var p in g) {
        Console.Write("({0}, {1}) ", p.name, p.height);
      }
      Console.WriteLine("");
    }
  }
}
</pre>
<pre>
C&gt;test
Carey, 133.7
Tracy, 138.2
Violet, 138.7
Maria, 159.1
Ellen, 157.9
Linda, 154.6
Hanna, 154.2
Sara, 153.1
1: (Ada, 148.7) (Hanna, 154.2) (Miranda, 148.2)
2: (Alice, 149.5) (Janet, 147.8) (Sara, 153.1)
3: (Carey, 133.7) (Linda, 154.6) (Tracy, 138.2)
4: (Ellen, 157.9) (Maria, 159.1) (Violet, 138.7)
</pre>
<h4 id="abc22">●ファイル入出力</h4>
<ul>
  <li>テキストファイルの入出力は System.IO に定義されているクラス StreamReader, StreamWriter を使う
    <ul>
      <li>StreamReader 変数名 = new StreamReader("ファイル名");
      <li>StreamWriter 変数名 = new StreamWriter("ファイル名");
      <li>Windows でパス区切り記号に \ を使う場合、@quoted string を使うと便利
        <ul>
          <li>"C:\\Foo\\Bar\\Baz\\oops.txt" =&gt; @"C:\Foo\Bar\Baz\oops.txt"
          <li>@" ... " の中はエスケープシーケンスの処理が無効になる
        </ul>
      <li>ストリームを生成するときは using を使うと便利
<pre class="list">
using( インスタンスの生成 ) {

  ...

}
</pre>
      <li>using で生成されたインスタンスは自動的に廃棄される
      <li>このとき、オープンされたファイルも自動的にクローズされる
    </ul>
  <li>テキストの読み込み
    <ul>
      <li>int Read(); 1 文字 (char) 読み込み
      <li>int Read(char[] buff, int index, int size); 配列 buff の index 番目以降に size 個の文字を読み込む
      <li>string ReadLine(); 1 行読み込み
      <li>string ReadToEnd(); 最後まで読み込む
    </ul>
  <li>テキストの書き込み
    <ul>
      <li>Write(), WriteLine() は Cosole.Write(), Console.WriteLine() と同じ
      <li>Flush(); バッファに残っているデータを出力する
    </ul>
</ul>
<pre class="list">
リスト : テキストファイルの連結 (cat.cs)

using System;
using System.IO;

class Test {
  static void Main(string[] args) {
    foreach(string name in args) {
      using (var s = new StreamReader(name)) {
        string buff;
        while ((buff = s.ReadLine()) != null) {
          Console.WriteLine(buff);
        }
      }
    }
  }
}
</pre>
<pre class="list">
リスト : テキストファイルのコピー (cp.cs)

using System;
using System.IO;

class Test {
  static void Main(string[] args) {
    if (args.Length &lt; 2) {
      Console.WriteLine("arguments error");
    } else {
      using (var sIn = new StreamReader(args[0])) {
        using (var sOut = new StreamWriter(args[1])) {
          string buff;
          while ((buff = sIn.ReadLine()) != null) {
            sOut.WriteLine(buff);
          }
        }
      }
    }
  }
}
</pre>
<ul>
  <li>コマンドライン引数は Main() の引数 string[] args に格納される
  <li>ReadLine() はファイルの終了を検出すると null を返す
</ul>
<h4 id="abc23">●名前空間</h4>
<ul>
  <li>名前空間は namespace 名前 { ... } で定義する
  <li>名前空間の中では複数のクラスを定義できる
  <li>名前空間は入れ子にすることもできる
  <li>Name1 の中に Name2 を定義する場合、namespace Name1.Name2 { ... } と書くこともできる
</ul>
<pre>
csharp&gt; namespace Foo {
      &gt; namespace Bar {
      &gt; class Baz {}
      &gt; }
      &gt; class Oops {}
      &gt; }
csharp&gt; new Foo.Bar.Baz();
Foo.Bar.Baz
csharp&gt; new Foo.Oops()
Foo.Oops
csharp&gt; using Foo;
csharp&gt; using Foo.Bar;
csharp&gt; new Baz();
Foo.Bar.Baz
csharp&gt; new Oops();
Foo.Oops
</pre>
<ul>
  <li>名前空間の中で定義したクラスは Name.ClassName でアクセスできる
  <li>using Name; や using Name1.Name2; とすることで Name や Name1.Name2 を省略できる
  <li>using で別名を付けることができる
    <ul>
      <li>using 別名 = Name1.Name2.ClassName;  // クラス名の別名
      <li>using 別名 = Name1.Name2.Name3;      // 名前空間の別名
    </ul>
  <li>別名を使う場合、ドット ( . ) だけではなく :: 演算子 (エイリアス修飾子) を使うことができる
    <ul>
      <li>using System = Sys;  Sys::Console.WriteLine("") のように使う
    </ul>
  <li>名前空間 global はルートを表す (System は global::System のこと)
</ul>
<h4 id="abc24">●ライブラリの作成</h4>
<ul>
  <li>Windows の場合、C# のライブラリは DLL になる
  <li>mcs のオプション -target: (または -t:) に library, -out: に DLL ファイル名を指定する
  <li>あとはソースファイルを指定する (複数指定してもよい)
</ul>
<pre class="list">
リスト : hello.cs

using System;

namespace HelloWorld {
  public class Hello {
    public static void Greeting() {
      Console.WriteLine("Hello World");
    }
  }
}
</pre>
<pre>
C&gt;mcs -t:library -out:hello.dll hello.cs
</pre>
<ul>
  <li>DLL をリンクするときは -reference: (または -r:) で DLL ファイルを指定する
</ul>
<pre class="list">
リスト : hellotest.cs

using HelloWorld;

class Test {
  static void Main() {
    Hello.Greeting();
  }
}
</pre>
<pre>
C&gt;mcs -r:hello.dll hellotest.cs

C&gt;hellotest
Hello World
</pre>
<h4 id="abc25">●値呼びと参照呼び</h4>
<ul>
  <li>一般に、関数呼び出しには「値呼び (call by value)」と「参照呼び (call by reference)」がある
  <li>近代的なプログラミング言語では「値呼び」が主流で、C# も値呼びである
    <ol>
      <li>受け取るデータを格納する変数 (仮引数) を用意する
      <li>データを引数に代入する (データのコピーが行われる)
      <li>関数の実行終了後、引数を廃棄する
    </ol>
  <li>仮引数に対する更新が直ちに実引数にも及ぶような呼び出し方が「参照呼び」
  <li>参照呼びは、呼び出し先 (caller) から呼び出し元 (callee) の局所変数にアクセスできる
  <li>C# の場合、仮引数と実引数にキーワード ref を付けると参照呼びと同様の動作になる
</ul>
<pre class="list">
リスト : 値の交換

using System;

class Test {
  static void Swap(ref int a, ref int b) {
    int c = a;
    a = b;
    b = c;
  }

  static void Main() {
    int a = 1, b = 2;
    Console.WriteLine("a = {0}, b = {1}", a, b);
    Swap(ref a, ref b);
    Console.WriteLine("a = {0}, b = {1}", a, b);
  }
}
</pre>
<pre>
C&gt;test
a = 1, b = 2
a = 2, b = 1
</pre>
<ul>
  <li>ref を使う場合、変数は初期化しておく必要がある
  <li>基本的に C# の関数は一つの値しか返せない
  <li>複数の値 (多値) を返したい場合は参照呼びを使う
  <li>このとき ref ではなくキーワード out を使うと変数の初期化が不要になる
</ul>
<pre class="list">
リスト : out の使い方

using System;

class Test {
  // 商と剰余を返す (Math.DivRem() と同じ)
  static int DivRem(int x, int y, out int z) {
    z = x % y;
    return x / y;
  }

  static void Main() {
    int r;  // 初期化しなくてもよい
    int q = DivRem(11, 4, out r);
    Console.WriteLine("{0}, {1}", q, r);
  }
}
</pre>
<pre>
C&gt;test
2, 3
</pre>
<ul>
  <li>なお、C# 7 になると「タプル (tuple)」が導入されるので、多値を返す場合はタプルを使ったほうが簡単
</ul>
<h4 id="abc26">●データ型の判定</h4>
<ul>
  <li>データ型は演算子 is で判定できる
<pre class="item">
オブジェクト is データ型 =&gt; bool
</pre>
  <li>演算子 as は指定したデータ型にキャストするが、できない場合は null を返す
<pre class="item">
オブジェクト as データ型 =&gt; オブジェクト or null
</pre>
</ul>
<pre>
csharp&gt; class Foo {};
csharp&gt; class Bar : Foo {};
csharp&gt; class Baz : Bar {};
csharp&gt; Foo a = new Foo();
csharp&gt; Foo b = new Bar();
csharp&gt; Foo c = new Baz();
csharp&gt; a is Foo;
true
csharp&gt; a is Bar;
false
csharp&gt; b is Foo;
true
csharp&gt; b is Bar;
true
csharp&gt; b is Baz;
false
csharp&gt; c is Foo;
true
csharp&gt; c is Bar;
true
csharp&gt; c is Baz;
true
csharp&gt; a as Foo;
Foo
csharp&gt; a as Bar;
null
csharp&gt; b as Bar;
Bar
csharp&gt; b as Baz;
null
csharp&gt; c as Baz;
Baz
</pre>
<ul>
  <li>演算子 typeof(データ型) は System.Type のインスタンスを返す
  <li>メソッド GetType() でも System.Type のインスタンスを取得できる
  <li>プロパティ Name でデータ型の名前 (文字列) を取得できる
</ul>
<pre>
csharp&gt; typeof(Foo).Name;
"Foo"
csharp&gt; b.GetType();
Bar
csharp&gt; b.GetType().Name;
"Bar"
csharp&gt; c.GetType().Name;
"Baz"
</pre>
<h4 id="abc27">●演算子の多重定義</h4>
<ul>
  <li>C# はメソッドだけではなく「演算子」も多重定義 (オーバーロード) することができる
  <li>演算子の多重定義にはキーワード operator を使い、クラスのスタティックメソッドとして意義する
<pre class="list">
リスト : 二項演算子の多重定義

public static 返り値の型 operator 演算子(左辺式の型 仮引数, 右辺式の型 仮引数) { ... }
</pre>
  <li>仮引数のうち、少なくとも 1 つは定義するクラス自身でなければならない
  <li>なお、多重定義できない演算子も存在する
</ul>
<pre class="list">
//
// ratio.cs : 有理数
//
//            Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Numerics;

struct Ratio : IComparable {
  public BigInteger Numer { get; }  // 分子
  public BigInteger Denom { get; }  // 分母

  public Ratio(BigInteger p, BigInteger q) {
    BigInteger a = BigInteger.GreatestCommonDivisor(p, q);
    Numer = p / a;
    Denom = q / a;
    if (Denom &lt; 0) {
      Numer = - Numer;
      Denom = - Denom;
    }
  }

  public static Ratio operator +(Ratio a, Ratio b) {
    return new Ratio(a.Numer * b.Denom + b.Numer * a.Denom, a.Denom * b.Denom);
  }

  public static Ratio operator -(Ratio a, Ratio b) {
    return new Ratio(a.Numer * b.Denom - b.Numer * a.Denom, a.Denom * b.Denom);
  }

  public static Ratio operator *(Ratio a, Ratio b) {
    return new Ratio(a.Numer * b.Numer, a.Denom * b.Denom);
  }

  public static Ratio operator /(Ratio a, Ratio b) {
    return new Ratio(a.Numer * b.Denom, a.Denom * b.Numer);
  }
  
  // IComparable 用のメソッド
  public int CompareTo(Object obj) {
    if (!(obj is Ratio)) return 1;
    Ratio r = (Ratio)obj;
    BigInteger a = Numer * r.Denom;
    BigInteger b = r.Numer * Denom;
    if (a == b) return 0;
    else if (a &lt; b) return -1;
    else return 1;
  }

  public override bool Equals(object obj) {
    if (!(obj is Ratio)) return false;
    Ratio r = (Ratio)obj;
    return Numer == r.Numer &amp;&amp; Denom == r.Denom;
  }

  // とても適当なので実際に使ってはいけない
  public override int GetHashCode() {
    return ((Numer &lt;&lt; 7) ^ Denom).GetHashCode();
  }

  public static bool operator ==(Ratio a, Ratio b) {
    return a.Equals(b);
  }
  public static bool operator !=(Ratio a, Ratio b) {
    return !a.Equals(b);
  }
  public static bool operator &lt;(Ratio a, Ratio b) {
    return a.CompareTo(b) &lt; 0;
  }
  public static bool operator &lt;=(Ratio a, Ratio b) {
    return a.CompareTo(b) &lt;= 0;
  }
  public static bool operator &gt;(Ratio a, Ratio b) {
    return a.CompareTo(b) &gt; 0;
  }
  public static bool operator &gt;=(Ratio a, Ratio b) {
    return a.CompareTo(b) &gt;= 0;
  }

  // 表示
  public override string ToString() {
    return Numer.ToString() + "/" + Denom.ToString();
  }
}

class Test {
  static void Main() {
    Ratio a = new Ratio(1, 2);
    Ratio b = new Ratio(1, 3);
    Ratio c = new Ratio(1, 4);

    Console.WriteLine(a);
    Console.WriteLine(b);
    Console.WriteLine(c);
    Console.WriteLine(a + b);
    Console.WriteLine(a - b);
    Console.WriteLine(a * b);
    Console.WriteLine(a / b);
    Console.WriteLine(c + b);
    Console.WriteLine(c - b);
    Console.WriteLine(c * b);
    Console.WriteLine(c / b);
    Console.WriteLine(a == c + c);
    Console.WriteLine(a != c + c);
    Console.WriteLine(a &lt; b);
    Console.WriteLine(a &gt; b);
    Console.WriteLine(a &lt;= b);
    Console.WriteLine(a &gt;= b);
    Console.WriteLine(b &lt; c);
    Console.WriteLine(b &gt; c);
    Console.WriteLine(b &lt;= c);
    Console.WriteLine(b &gt;= c);

    var buff = new Ratio[] {b, a, c};
    Array.Sort(buff);
    foreach(Ratio x in buff) {
      Console.Write("{0} ", x);
    }
    Console.WriteLine("");
  }
}
</pre>
<ul>
  <li>配列のメソッド Sort() や BinarySearch() などを使用するときは IComparable を継承する
  <li>実装するメソッドは x.CompareTo(y) だけ
    <ul>
      <li>x &lt; y, 負の整数 (int) を返す
      <li>x == y, 0 を返す
      <li>x &gt; y, 正の整数を返す
    </ul>
  <li>IComparable を継承しても比較演算子は自動的に定義されないので、自分で演算子を多重定義する必要がある
  <li>演算子 ==, != を多重定義するとき、メソッド Equals() をオーバーライドしないとワーニングがでる
  <li>メソッド Equals() をオーバーライドするとき、メソッド GetHashCode() をオーバーライドしないとワーニングがでる
</ul>
<pre>
C&gt;ratio
1/2
1/3
1/4
5/6
1/6
1/6
3/2
7/12
-1/12
1/12
3/4
True
False
False
True
False
True
False
True
False
True
1/4 1/3 1/2
</pre>
<h4 id="abc28">●null 許容型</h4>
<ul>
  <li>通常、null は値型の変数に代入することはできないが、null も代入できる値型を「null 許容型」という
  <li>値型を T とすると、null 許容型は T? と記述する
    <ul>
      <li>T? は System.Nullable&lt;T&gt; の省略形 
    </ul>
  <li>null 許容型は通常の値型と同様の計算を行うことができる
    <ul>
      <li>計算する値に null が含まれていると結果は null になる
    </ul>
  <li>null の判定は演算子 ==, != のほかにプロパティ HasValue もある
  <li>プロパティ Value は値を返すが、null であれば例外を送出する
  <li>null 許容型の値を値型の変数に代入するときは演算子 ?? を使うと便利
    <ul>
      <li>x が null 許容型の場合、int y = x ?? -1; は x に値があればその値を、null であれば -1 を y に代入する
    </ul>
</ul>
<pre>
csharp&gt; int? a = 10;
csharp&gt; int? b = null;
csharp&gt; a
10
csharp&gt; b
null
csharp&gt; int c = a ?? -1;
csharp&gt; c
10
csharp&gt; int d = b ?? -1;
csharp&gt; d
-1
csharp&gt; a + a;
20
csharp&gt; a + b;
null
</pre>
<h4 id="abc29">●日付と時刻</h4>
<ul>
  <li>C# の場合、日付と時刻の操作は主に構造体 DateTime を使う
  <li>現在の日付と時刻は静的なプロパティ Now で取得できる
  <li>現在の日付だけでよければ静的なプロパティ Today を使う
  <li>主なプロパティ
    <ul>
      <li>Year, Month, Day, Hour, Minute, Second, Millsecond
      <li>Date : 日付だけを取得
      <li>TimeOfDay : 時刻だけを取得
      <li>DayOfWeek : 曜日を取得
      <li>Ticks : タイマー刻み数を取得
    </ul>
  <li>new DateTime() で新しいインスタンスを生成できる
    <ul>
      <li>引数には日付や時刻を指定する
    </ul>
  <li>構造体 TimeSpan は時間間隔を表す
  <li>DateTime と DateTime の引き算は TimeSpan を返す
  <li>主なプロパティ
    <ul>
      <li>Years, Months, Days, Hours, Minutes, Seconds, Millseconds, Ticks
      <li>これらのプロパティは TimeSpane の該当する要素の値を返すだけ
      <li>トータルでの値は次のプロパティを使う
      <li>TotalDays, TotalHours, TotalMinutes, TotalSeconds, TotalMillseconds
    </ul>
</ul>
<pre>
csharp&gt; var a = new DateTime(2016, 1, 1);
csharp&gt; var b = new DateTime(2016, 11, 6);
csharp&gt; a
01/01/2016 00:00:00
csharp&gt; b
11/06/2016 00:00:00
csharp&gt; var c = b - a;
csharp&gt; c;
310.00:00:00
csharp&gt; c.TotalDays;
310
csharp&gt; c.TotalHours;
7440
csharp&gt; c.TotalSeconds;
26784000
</pre>
<pre class="list">
リスト : 簡単な実行時間の計測

using System;

class Test {
  // 二重再帰
  static long Fibo(long n) {
    if (n &lt; 2) return n;
    return Fibo(n - 2) + Fibo(n - 1);
  }

  static void Main() {
    var s = DateTime.Now;
    Console.WriteLine(Fibo(42));
    Console.WriteLine((DateTime.Now - s).TotalSeconds);
  }
}
</pre>
<pre>
C&gt;test
267914296
3.7542147
</pre>
<h4 id="abc30">●書式指定文字列</h4>
<ul>
  <li>メソッド ToString() はオブジェクトを文字列に変換する
  <li>自作のクラスで ToString() をオーバーライドすると、Console.Write() などの出力関数でオブジェクトを表示できる
    <ul>
      <li>public overirde string ToString() { ... }
    </ul>
  <li>データ型によっては ToSting() の引数に書式指定文字列を指定することができる
  <li>数値の主な書式指定子
    <ul>
      <li>c. C : 通貨単位を表示
      <li>d, D : 10 進数 (整数専用)
      <li>x, X : 16 進数 (整数専用, x は a - f, X は A - F で表示)
      <li>f, F : 固定小数点
      <li>e, E : 指数
      <li>g, G : 数値 (F, E のどちらか簡潔な方で表示)
      <li>n, N : 桁区切り記号付き
      <li>p, P : % 記号付き
      <li>詳細は <a href="https://msdn.microsoft.com/ja-jp/library/dwhawy9k.aspx">MSDN : 標準の数値書式指定文字列</a> を参照
    </ul>
</ul>
<pre>
csharp&gt; 255.ToString("d");
"255"
csharp&gt; 255.ToString("x");
"ff"
csharp&gt; 255.ToString("X");
"FF"
csharp&gt; x.ToString("f");
"1.23"
csharp&gt; double x = 1.23456789;
csharp&gt; x.ToString("e");
"1.234568e+000"
csharp&gt; x.ToString("g");
"1.23456789"
csharp&gt; 123456789.ToString("n");
"123,456,789.00"
</pre>
<ul>
  <li>日付の主な書式指定子
    <ul>
      <li>小文字は短い形式、大文字は長い形式
      <li>d, D : 日付
      <li>t, T : 時刻
      <li>f, F : 完全な日付と時刻
      <li>g, G : 一般的な日付と時刻
      <li>y, Y : 年月
      <li>m, M : 月日
      <li>詳細は <a href="https://msdn.microsoft.com/ja-jp/library/az4se3k1(v=vs.110).aspx">MSDN : 標準の日時書式指定文字列</a> を参照
    </ul>
</ul>
<pre>
csharp&gt; a
11/06/2016 12:34:56
csharp&gt; a.ToString("d");
"11/06/2016"
csharp&gt; a.ToString("D");
"Sunday, 06 November 2016"
csharp&gt; a.ToString("t");
"12:34"
csharp&gt; a.ToString("T");
"12:34:56"
csharp&gt; a.ToString("f");
"Sunday, 06 November 2016 12:34"
csharp&gt; a.ToString("F");
"Sunday, 06 November 2016 12:34:56"
csharp&gt; a.ToString("g");
"11/06/2016 12:34"
csharp&gt; a.ToString("G");
"11/06/2016 12:34:56"
</pre>
<ul>
  <li>String.Format() や Console.Write() などでは複数のデータの書式を指定することができる
  <li>これを「復号書式指定」という
  <li>復号書式指定の構文
<pre class="item">
{ index[,w][:指定子] }
</pre>
    <ul>
      <li>index は書式文字列のあとの引数の位置
      <li>w はフィールド幅で、負数を指定すると右詰めされる
      <li>指定子のあとの数字を指定することもできる
        <ul>
          <li>整数の場合はフィールド幅 (右詰めで空欄には 0 が充填)
          <li>浮動小数点数の場合は精度 (小数点以降の桁数)
        </ul>
    </ul>
</ul>
<pre>
csharp&gt; Console.WriteLine("[{0,8}]", "hello");
[   hello]
csharp&gt; Console.WriteLine("[{0,-8}]", "hello");
[hello   ]
csharp&gt; Console.WriteLine("[{0,-8:d}]", 123);
[123     ]
csharp&gt; Console.WriteLine("[{0,8:d}]", 1234);
[    1234]
csharp&gt; Console.WriteLine("[{0,-8:d}]", 1234);
[1234    ]
csharp&gt; Console.WriteLine("[{0:d8}]", 1234);
[00001234]
csharp&gt; Console.WriteLine("{0:f}", 1.2345678);
1.23
csharp&gt; Console.WriteLine("{0:f7}", 1.2345678);
1.2345678
</pre>
<ul>
  <li>数値は 0 や # などを使って書式を作ることができる
  <li>これを「カスタム数値書式指定文字列」という
  <li>詳細は <a href="https://msdn.microsoft.com/ja-jp/library/0c899ak8.aspx">MSDN : カスタム数値書式指定文字列</a> を参照
  <li><a href="https://msdn.microsoft.com/ja-jp/library/8kb3ddd4.aspx">MSDN : カスタム日時書式指定文字列</a> も用意されている
</ul>
<pre>
csharp&gt; Console.WriteLine("{0:###.###}", 123.45);
123.45
csharp&gt; Console.WriteLine("{0:###.000}", 123.45);
123.450
csharp&gt; Console.WriteLine("{0:0000.000}", 123.45);
0123.450
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>