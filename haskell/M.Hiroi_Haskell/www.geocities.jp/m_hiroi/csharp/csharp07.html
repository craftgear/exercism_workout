<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ＃プログラミング超入門</title>
  <meta name="description" content="C#,C#入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881817</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>C# Programming</h1>
<h2>お気楽Ｃ＃プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
<hr>
</div>
<section class="contents">
<h3>簡単なプログラム</h3>
<h4 id="chap23">●三目並べ</h4>
<p> 三目並べは、皆さんお馴染みの二人で対戦するゲームです。ひとりが○側でもうひとりが×側を受け持ち、3 行 3 列のマス目に○×を書いて、3 つ並べた方が勝ちというゲームです。下図は○側が先手で引き分けになった例です。
</p>
<pre class="fig">
┌─┬─┬─┐ 
│×│○│○│ 
├─┼─┼─┤ 
│○│○│×│ 
├─┼─┼─┤ 
│×│×│○│ 
└─┴─┴─┘ 

 図：三目並べ
</pre>
<p> 三目並べは、両者が最善を尽くすと引き分けになることが知られています。実際、ミニマックス法を使って確かめてみると、初手がどこでも結果は引き分けになります。興味のある方は拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/tictactoe.html">三目並べ</a> をお読みくださいませ。
</p>
<p> ところで、<a href="csharp07.html#cite">参考文献 [1]</a> によると、三目並べで両者が次の戦略を用いると、ゲームは常に引き分けになります。
</p>
<ol>
  <li>3 つ並べることができるならばそうする
  <li>相手が 3 つ並べるのを妨げる
  <li>可能ならば中央へ着手する
  <li>可能ならば隅へ着手する
</ol>
<p> 本当に引き分けになるのか、プログラムを作って確かめてみましょう。
</p>
<h4>●プログラムの作成</h4>
<p> 最初に、ゲームに必要なデータ構造を定義します。
</p>
<pre class="fig">
┌─┬─┬─┐ 
│０│１│２│ 
├─┼─┼─┤ 
│３│４│５│ 
├─┼─┼─┤ 
│６│７│８│ 
└─┴─┴─┘ 

 図：盤面の番号
</pre>
<pre class="list">
リスト：データ構造の定義

  // 駒の種類
  enum Piece {Space, Maru, Batu};
  
  // 盤面
  static Piece[] board = new Piece[9];

  // 直線
  static int[,] lineTable = new int[8, 3] {
    {0, 1, 2},
    {3, 4, 5},
    {6, 7, 8},
    {0, 3, 6},
    {1, 4, 7},
    {2, 5, 8},
    {0, 4, 8},
    {2, 4, 6},
  };
</pre>
<p> 駒の種類を enum で定義します。先手が Maru、後手が Batu、空き場所が Space です。盤面は配列 board で表します。盤面と配列の添字の対応は上図のように定義します。すると、駒が 3 つ並ぶ直線は二次元配列 lineTable で表すことができます。
</p>

<p> 勝敗の判定は関数 CheckWin() で行います。次のリストを見てください。
</p>
<pre class="list">
リスト：勝敗の判定

  static Piece CheckWin() {
    for (int i = 0; i &lt; 8; i++) {
      int x = lineTable[i, 0];
      int y = lineTable[i, 1];
      int z = lineTable[i, 2];
      Piece p = board[x];
      if (p != Piece.Space &amp;&amp; board[y] == p &amp;&amp; board[z] == p) return p;
    }
    return Piece.Space;
  }
</pre>

<p> 関数 CheckWin() は 8 本の直線を調べ、同じ駒が 3 つ並んでいるか調べます。直線の先頭に Maru か Batu があり、残り 2 つの場所に同じ駒があれば 3 つ並んでいることがわかります。Maru が 3 つ並んでいれば Maru を、Batu が 3 つ並んでいれば Batu を返します。どちらも 3 つ並んでいなければ Space を返します。
</p>

<p> 次は同じ駒を 3 つ並べることができる場所を探す関数 GetWinPosition() を作ります。
</p>
<pre class="list">
リスト：駒を 3 つ並べられるか

  static int GetWinPosition(Piece p) {
    for (int i = 0; i &lt; 8; i++) {
      int x = lineTable[i, 0];
      int y = lineTable[i, 1];
      int z = lineTable[i, 2];
      if (board[x] == Piece.Space &amp;&amp; board[y] == p &amp;&amp; board[z] == p)
        return x;
      else if (board[y] == Piece.Space &amp;&amp; board[x] == p &amp;&amp; board[z] == p)
        return y;
      else if (board[z] == Piece.Space &amp;&amp; board[x] == p &amp;&amp; board[y] == p)
        return z;
    }
    return -1;
  }
</pre>
<p> 引数 p は駒の種類を表します。空き場所が 1 つあり、残りの 2 か所が p と等しい直線を探します。見つけた場合は空き場所の位置を、見つからない場合は -1 を返します。
</p>

<p> 次はコンピュータの指し手を決める関数 MoveCom() を作ります。
</p>
<pre class="list">
リスト：コンピュータの指し手を決定する

  static int MoveCom(Piece turn) {
    // 勝てる場所を探す
    int p = GetWinPosition(turn);
    if (p &lt; 0) {
      // 相手の手番で勝ちがあるか
      p = GetWinPosition(turn == Piece.Maru ? Piece.Batu : Piece.Maru);
      if (p &lt; 0) {
        // 中央が空いているか
        if (board[4] == Piece.Space) {
          p = 4;
        } else {
          // 隅が取れるか
          p = GetCornerPosition();
          if (p &lt; 0) {
            // 空き場所に駒を置く
            p = GetSpacePosition();
          }
        }
      }
    }
    return p;
  }
</pre>
<p> 関数 MoveCom() は戦略に従ってコンピュータの指し手を決定します。引数 turn は自分の駒の種類を表します。最初に GetWinPosition() を呼び出して、駒を 3 つ並べることができるか調べます。自分が勝てるのであれば、その場所 p に駒を置きます。そうでなければ、相手が駒を 3 つ並べることができるか調べます。これは GetWinPosition() で相手の駒の種類を渡せば調べることができます。そうであれば、その場所 p に自分の駒をおきます。
</p>
<p> それ以外の場合は、優先順位（中央 -&gt; 隅 -&gt; 空き場所) に従って駒を置きます。空いている隅は関数 GetCornerPosition() で求めます。空き場所は関数 GetSpacePosition() で求めます。最後に指し手 p を返します。これで戦略に従ってコンピュータの指し手を決定することができます。
</p>
<p> あとはとくに難しいところはないでしょう。詳細は <a href="csharp07.html#list">プログラムリスト</a> をお読みくださいませ。
</p>

<h4>●実行結果</h4>
<p> それでは実行結果を示します。
</p>
<pre class="fig">
C&gt;tictactoe
0 1 2
3 4 5
6 7 8

Input&gt; 4
Maru: 4
0 1 2
3 O 5
6 7 8

Batu: 0
X 1 2
3 O 5
6 7 8

Input&gt; 2
Maru: 2
X 1 O
3 O 5
6 7 8

Batu: 6
X 1 O
3 O 5
X 7 8

Input&gt; 3
Maru: 3
X 1 O
O O 5
X 7 8

Batu: 5
X 1 O
O O X
X 7 8

Input&gt; 7
Maru: 7
X 1 O
O O X
X O 8

Batu: 1
X X O
O O X
X O 8

Input&gt; 8
Maru: 8
X X O
O O X
X O O

draw game

C&gt;tictactoe
0 1 2
3 4 5
6 7 8

Input&gt; 4
Maru: 4
0 1 2
3 O 5
6 7 8

Batu: 0
X 1 2
3 O 5
6 7 8

Input&gt; 8
Maru: 8
X 1 2
3 O 5
6 7 O

Batu: 2
X 1 X
3 O 5
6 7 O

Input&gt; 1
Maru: 1
X O X
3 O 5
6 7 O

Batu: 7
X O X
3 O 5
6 X O

Input&gt; 5
Maru: 5
X O X
3 O O
6 X O

Batu: 3
X O X
X O O
6 X O

Input&gt; 6
Maru: 6
X O X
X O O
O X O

draw game
</pre>
<p> 確かに引き分けになりますね。興味のある方はいろいろ試してみてください。
</p>
<h4 id="cite">●参考文献</h4>
<ol>
  <li>松原仁・竹内郁雄 編著,『bit別冊 ゲームプログラミング』, 共立出版, 1997
</ol>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
//
// tictactoe.cs : 三目並べ
//
//                Copyright (C) 2016 Makoto Hiroi
//
using System;

class Game {
  enum Piece {Space, Maru, Batu};
  
  // 盤面
  // 0 1 2
  // 3 4 5
  // 6 7 8
  static Piece[] board = new Piece[9];

  // 直線
  static int[,] lineTable = new int[8, 3] {
    {0, 1, 2},
    {3, 4, 5},
    {6, 7, 8},
    {0, 3, 6},
    {1, 4, 7},
    {2, 5, 8},
    {0, 4, 8},
    {2, 4, 6},
  };

  // コーナーの位置
  static int[] corner = new int[4] {0, 2, 6, 8};

  // 3 個並ぶ場所を返す
  static int GetWinPosition(Piece p) {
    for (int i = 0; i &lt; 8; i++) {
      int x = lineTable[i, 0];
      int y = lineTable[i, 1];
      int z = lineTable[i, 2];
      if (board[x] == Piece.Space &amp;&amp; board[y] == p &amp;&amp; board[z] == p)
        return x;
      else if (board[y] == Piece.Space &amp;&amp; board[x] == p &amp;&amp; board[z] == p)
        return y;
      else if (board[z] == Piece.Space &amp;&amp; board[x] == p &amp;&amp; board[y] == p)
        return z;
    }
    return -1;
  }

  // 空いている隅を返す
  static int GetCornerPosition() {
    foreach(int x in corner) {
      if (board[x] == Piece.Space) return x;
    }
    return -1;
  }

  // 空いている場所を返す
  static int GetSpacePosition() {
    for (int i = 0; i &lt; 9; i++) {
      if (board[i] == Piece.Space) return i;
    }
    return -1;
  }

  // 勝利判定
  static Piece CheckWin() {
    for (int i = 0; i &lt; 8; i++) {
      int x = lineTable[i, 0];
      int y = lineTable[i, 1];
      int z = lineTable[i, 2];
      Piece p = board[x];
      if (p != Piece.Space &amp;&amp; board[y] == p &amp;&amp; board[z] == p) return p;
    }
    return Piece.Space;
  }

  // 終了判定
  static bool GameOver() {
    Piece p = CheckWin();
    if (p == Piece.Space) {
      return false;
    } else if (p == Piece.Maru) {
      Console.WriteLine("Maru Win!!");
    } else {
      Console.WriteLine("Batu Win!!");
    }
    return true;
  }

  // コンピュータの差し手を決める
  static int MoveCom(Piece turn) {
    // 勝てる場所を探す
    int p = GetWinPosition(turn);
    if (p &lt; 0) {
      // 相手の手番で勝ちがあるか
      p = GetWinPosition(turn == Piece.Maru ? Piece.Batu : Piece.Maru);
      if (p &lt; 0) {
        // 中央が空いているか
        if (board[4] == Piece.Space) {
          p = 4;
        } else {
          // 隅が取れるか
          p = GetCornerPosition();
          if (p &lt; 0) {
            // 空き場所に駒を置く
            p = GetSpacePosition();
          }
        }
      }
    }
    return p;
  }

  // 人間の差し手を決める
  static int MoveHuman(Piece turn) {
    while (true) {
      Console.Write("Input&gt; ");
      string buff = Console.ReadLine();
      int n;
      if (int.TryParse(buff, out n)) {
        if (0 &lt;= n &amp;&amp; n &lt; 9 &amp;&amp; board[n] == Piece.Space) return n;
      }
      Console.WriteLine("Please Input Number: 0 - 8");
    }
  }
  
  // 盤面の表示
  static void PrintBoard() {
    for (int i = 0; i &lt; 9; i++) {
      if (board[i] == Piece.Space) 
        Console.Write("{0} ", i);
      else if (board[i] == Piece.Maru)
        Console.Write("O ");
      else
        Console.Write("X ");
      if (i % 3 == 2) Console.WriteLine("");
    }
    Console.WriteLine("");
  }

  static void Main() {
    Piece turn = Piece.Maru;
    PrintBoard();
    while (!GameOver()) {
      int n = turn == Piece.Maru ? MoveHuman(turn) : MoveCom(turn);
      Console.WriteLine("{0}: {1}", turn, n);
      board[n] = turn;
      turn = turn == Piece.Maru ? Piece.Batu : Piece.Maru;
      PrintBoard();
      if (GetSpacePosition() == -1) {
        Console.WriteLine("draw game");
        break;
      }
    }
  }
}
</pre>
<hr>
<h4 id="chap24">●式の計算 (再帰降下法)</h4>
<p> 再帰降下法で式 (四則演算とカッコ) を計算するプログラムです。アルゴリズムの詳細は拙作のページ <a href="../func/scheme.html">Scheme Programming</a> <a href="../func/abcscm50.html">電卓プログラムの作成</a> をお読みください。
</p>
<pre class="list">
//
// calc0.cs : 式の計算 (単純な再帰降下法)
//
//            Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Text;

class Calc {
  // Calc 用例外クラス
  class CalcError : Exception {
    public CalcError(string msg) : base(msg) { }
  }

  // トークン種別
  enum Token {Number, Add, Sub, Mul, Div, Lpar, Rpar, Semic, Others };
  
  static char ch;         // 先読みバッファ
  static Token token;     // トークン
  static double numValue; // 数値

  // 記号の先読み
  static void NextChar() {
    ch = (char)Console.Read();
  }

  // 記号の読み込み
  static char GetChar() {
    return ch;
  }

  // 整数値の読み込み
  static void GetFixNumber(StringBuilder sb) {
    while (char.IsDigit(GetChar())) {
      sb.Append(GetChar());
      NextChar();
    }
  }

  // 数値の読み込み
  static double GetNumber() {
    double val;
    var sb = new StringBuilder();
    GetFixNumber(sb);
    if (GetChar() == '.') {
      sb.Append(GetChar());
      NextChar();
      GetFixNumber(sb);
    }
    if (GetChar() == 'e' || GetChar() == 'E') {
      sb.Append(GetChar());
      NextChar();
      if (GetChar() == '+' || GetChar() == '-') {
        sb.Append(GetChar());
        NextChar();
      }
      GetFixNumber(sb);
    }
    if (!double.TryParse(sb.ToString(), out val)) {
      throw new CalcError("Not Number");
    }
    return val;
  }
      
  // トークンの切り分け
  static void GetToken() {
    while (char.IsWhiteSpace(GetChar())) {
      NextChar();
    }
    if (char.IsDigit(GetChar())) {
      token = Token.Number;
      numValue = GetNumber();
    } else if (GetChar() == '+') {
      token = Token.Add;
      NextChar();
    } else if (GetChar() == '-') {
      token = Token.Sub;
      NextChar();
    } else if (GetChar() == '*') {
      token = Token.Mul;
      NextChar();
    } else if (GetChar() == '/') {
      token = Token.Div;
      NextChar();
    } else if (GetChar() == '(') {
      token = Token.Lpar;
      NextChar();
    } else if (GetChar() == ')') {
      token = Token.Rpar;
      NextChar();
    } else if (GetChar() == ';') {
      token = Token.Semic;
      NextChar();
    } else {
      token = Token.Others;
    }
  }
  
  // 構文解析
  static double Expr() {
    double val = Term();
    while (true) {
      if (token == Token.Add) {
        GetToken();
        val += Term();
      } else if (token == Token.Sub) {
        GetToken();
        val -= Term();
      } else {
        break;
      }
    }
    return val;
  }

  // 項
  static double Term() {
    double val = Factor();
    while (true) {
      if (token == Token.Mul) {
        GetToken();
        val *= Factor();
      } else if (token == Token.Div) {
        GetToken();
        val /= Factor();
      } else {
        break;
      }
    }
    return val;
  }

  // 因子
  static double Factor() {
    if (token == Token.Lpar) {
      GetToken();
      double val = Expr();
      if (token != Token.Rpar) {
        throw new CalcError("')' expected");
      }
      GetToken();
      return val;
    } else if (token == Token.Number) {
      GetToken();
      return numValue;
    } else if (token == Token.Add) {
      GetToken();
      return Factor();
    } else if (token == Token.Sub) {
      GetToken();
      return -Factor();
    } else {
      throw new CalcError("unexpected token");
    }
  }

  // トップレベル
  static void TopLevel() {
    double val = Expr();
    if (token == Token.Semic) {
      Console.WriteLine(val);
      Console.Write("Calc&gt; ");
    } else {
      throw new CalcError("invalid token");
    }
  }

  static void CalcExec() {
    Console.Write("Calc&gt; ");
    NextChar();
    while (true) {
      try {
        GetToken();
        TopLevel();
      } catch(CalcError e) {
        Console.WriteLine(e.Message);
        // 入力のクリア
        while (GetChar() != '\n') {
          NextChar();
        }
        Console.Write("Calc&gt; ");
      }
    }
  }

  static void Main() {
    CalcExec();
  }
}
</pre>
<pre>
C&gt;calc0
Calc&gt; 1 + 2 + 3 + 4 + 5;
15
Calc&gt; (1 + 2) * (3 - 4);
-3
Calc&gt; 1.11111111 * 1.11111111;
1.23456789876543
Calc&gt; 1 / 7;
0.142857142857143
Calc&gt; -10 * -10;
100
Calc&gt; (1 + 2;
')' expected
Calc&gt; 1 + * 2;
unexpected token
Calc&gt; (終了は CTRL-C を入力してください)
</pre>
<hr>
<h4 id="chap25">●式の計算 (構文木の構築)</h4>
<p> 再帰降下法で構文木を構築して式 (四則演算とカッコ) を計算するプログラムです。アルゴリズムの詳細は拙作のページ <a href="../func/index.html#sml">お気楽 SML/NJ プログラミング入門</a> <a href="../func/smlnj23.html">電卓プログラムの作成</a> をお読みください。
</p>
<pre class="list">
//
// calc1.cs : 式の計算 (構文木の構築)
//
//            Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Text;

class Calc {
  // Calc 用例外クラス
  class CalcError : Exception {
    public CalcError(string msg) : base(msg) { }
  }

  // 演算子
  enum Op {Add, Sub, Mul, Div};

  // 構文木
  abstract class ExprTree { }

  // 単項演算子
  class Node1 : ExprTree {
    public Op Operation { get; set; }
    public ExprTree Right { get; set; }

    public Node1(Op op, ExprTree expr) {
      Operation = op;
      Right = expr;
    }
  }

  // 二項演算子
  class Node2 : ExprTree {
    public Op Operation { get; set; }
    public ExprTree Left { get; set; }
    public ExprTree Right { get; set; }

    public Node2(Op op, ExprTree eLeft, ExprTree eRight) {
      Operation = op;
      Left = eLeft;
      Right = eRight;
    }
  }

  // 数値 (木構造の葉に相当)
  class Leaf : ExprTree {
    public double Value { get; set; }
    public Leaf(double val) { Value = val; }
  }
  
  // トークン種別
  enum Token {Number, Add, Sub, Mul, Div, Lpar, Rpar, Semic, Others };
  
  static char ch;         // 先読みバッファ
  static Token token;     // トークン
  static double numValue; // 数値

  // 記号の先読み
  static void NextChar() {
    ch = (char)Console.Read();
  }

  // 記号の読み込み
  static char GetChar() {
    return ch;
  }

  // 整数値の読み込み
  static void GetFixNumber(StringBuilder sb) {
    while (char.IsDigit(GetChar())) {
      sb.Append(GetChar());
      NextChar();
    }
  }

  // 数値の読み込み
  static double GetNumber() {
    double val;
    var sb = new StringBuilder();
    GetFixNumber(sb);
    if (GetChar() == '.') {
      sb.Append(GetChar());
      NextChar();
      GetFixNumber(sb);
    }
    if (GetChar() == 'e' || GetChar() == 'E') {
      sb.Append(GetChar());
      NextChar();
      if (GetChar() == '+' || GetChar() == '-') {
        sb.Append(GetChar());
        NextChar();
      }
      GetFixNumber(sb);
    }
    if (!double.TryParse(sb.ToString(), out val)) {
      throw new CalcError("Not Number");
    }
    return val;
  }
      
  // トークンの切り分け
  static void GetToken() {
    while (char.IsWhiteSpace(GetChar())) {
      NextChar();
    }
    if (char.IsDigit(GetChar())) {
      token = Token.Number;
      numValue = GetNumber();
    } else if (GetChar() == '+') {
      token = Token.Add;
      NextChar();
    } else if (GetChar() == '-') {
      token = Token.Sub;
      NextChar();
    } else if (GetChar() == '*') {
      token = Token.Mul;
      NextChar();
    } else if (GetChar() == '/') {
      token = Token.Div;
      NextChar();
    } else if (GetChar() == '(') {
      token = Token.Lpar;
      NextChar();
    } else if (GetChar() == ')') {
      token = Token.Rpar;
      NextChar();
    } else if (GetChar() == ';') {
      token = Token.Semic;
      NextChar();
    } else {
      token = Token.Others;
    }
  }
  
  // 構文解析
  static ExprTree Expr() {
    ExprTree e = Term();
    while (true) {
      if (token == Token.Add) {
        GetToken();
        e = new Node2(Op.Add, e, Term());
      } else if (token == Token.Sub) {
        GetToken();
        e = new Node2(Op.Sub, e, Term());
      } else {
        break;
      }
    }
    return e;
  }

  // 項
  static ExprTree Term() {
    ExprTree e = Factor();
    while (true) {
      if (token == Token.Mul) {
        GetToken();
        e = new Node2(Op.Mul, e, Factor());
      } else if (token == Token.Div) {
        GetToken();
        e = new Node2(Op.Div, e, Factor());
      } else {
        break;
      }
    }
    return e;
  }

  // 因子
  static ExprTree Factor() {
    if (token == Token.Lpar) {
      GetToken();
      ExprTree e = Expr();
      if (token != Token.Rpar) {
        throw new CalcError("')' expected");
      }
      GetToken();
      return e;
    } else if (token == Token.Number) {
      GetToken();
      return new Leaf(numValue);
    } else if (token == Token.Add) {
      GetToken();
      return new Node1(Op.Add, Factor());
    } else if (token == Token.Sub) {
      GetToken();
      return new Node1(Op.Sub, Factor());
    } else {
      throw new CalcError("unexpected token");
    }
  }

  // 式の評価
  static double Eval(ExprTree e) {
    Leaf a = e as Leaf;
    if (a != null) return a.Value;
    Node1 b = e as Node1;
    if (b != null) {
      if (b.Operation == Op.Add)
        return Eval(b.Right);
      else
        return -Eval(b.Right);
    }
    Node2 c = (Node2)e;
    double x = Eval(c.Left);
    double y = Eval(c.Right);
    if (c.Operation == Op.Add)
      return x + y;
    else if (c.Operation == Op.Sub)
      return x - y;
    else if (c.Operation == Op.Mul)
      return x * y;
    else
      return x / y;
  }
  
  // トップレベル
  static void TopLevel() {
    ExprTree e = Expr();
    if (token == Token.Semic) {
      Console.WriteLine(Eval(e));
      Console.Write("Calc&gt; ");
    } else {
      throw new CalcError("invalid token");
    }
  }

  static void CalcExec() {
    Console.Write("Calc&gt; ");
    NextChar();
    while (true) {
      try {
        GetToken();
        TopLevel();
      } catch(CalcError e) {
        Console.WriteLine(e.Message);
        // 入力のクリア
        while (GetChar() != '\n') {
          NextChar();
        }
        Console.Write("Calc&gt; ");
      }
    }
  }

  static void Main() {
    CalcExec();
  }
}
</pre>
<ul>
  <li>実行例は再帰降下法と同じです。
</ul>
<hr>
<h4 id="chap26">●最小の Lisp</h4>
<p> 小さな小さな Scheme ライクの Lisp インタプリタです。最小の Lisp については、拙作のページ <a href="../func/scheme.html">Scheme Programming</a> <a href="../func/abcscm30.html">Scheme で作る micro Scheme</a> をお読みください。
</p>
<ul>
  <li>真偽値は #t, #f ではなく t, nil (Common Lisp と同じ)
  <li>空リストも nil
  <li>car, cdr, cons, eq?, pair?, quote, if, lambda, define
  <li>データ型はシンボル、整数 (BigInteger)、リスト、関数
  <li>+, -, *, /, =, &lt;. &lt;=, &gt;, &gt;=
  <li>関数定義は (define 名前 (lambda (...) ...))
  <li>再帰定義もできる
  <li>マクロ、継続、末尾再帰最適化といった Scheme らしい機能はない
</ul>
<pre class="list">
//
// mscm.cs : micro Scheme インタプリタ
//
//           Copyright (C) 2016 Makoto Hiroi
//
using System;
using System.Text;
using System.Numerics;
using System.Collections.Generic;

class Scheme {
  // Scheme 用例外クラス
  class SchemeError : Exception {
    public SchemeError(string msg) : base(msg) { }
  }

  // コンスセル
  class Cons {
    public object car;
    public object cdr;

    public Cons(object x, object y) {
      car = x;
      cdr = y;
    }
  }

  // シンボル
  class Symbol {
    public string Name { set; get; }
    public object Value { set; get; }

    public Symbol(string s, object val = null) {
      Name = s;
      Value = val;
    }
    
    public override string ToString() {
      return Name;
    }
  }

  // シンボル表
  static Dictionary&lt;string, Symbol&gt; symTable = new Dictionary&lt;string, Symbol&gt;();

  // シンボルの生成
  static Symbol MakeSymbol(string name, object val = null) {
    if (!symTable.ContainsKey(name)) {
      symTable[name] = new Symbol(name, val);
    }
    return symTable[name];
  }

  // システムシンボル
  static Symbol sT = MakeSymbol("t");
  static Symbol sNil = MakeSymbol("nil");
  static Symbol sQuote = MakeSymbol("quote");
  static Symbol sDefine = MakeSymbol("define");
  static Symbol sLambda = MakeSymbol("lambda");
  static Symbol sIf = MakeSymbol("if");

  // 述語
  static bool Consp(object xs) { return xs is Cons; }
  static bool Null(object xs) { return xs == sNil; }
  static bool Symbolp(object xs) { return xs is Symbol; }
  static bool Numberp(object xs) { return xs is BigInteger; }

  // アクセス関数
  static object Car(object xs) {
    if (!Consp(xs)) {
      throw new SchemeError("Car: pair required");
    }
    return ((Cons)xs).car;
  }

  static object Cdr(object xs) {
    if (!Consp(xs)) {
      throw new SchemeError("Cdr: pair required");
    }
    return ((Cons)xs).cdr;
  }

  // 数値のチェック
  static void CheckNumber(object xs) {
    if (!Numberp(Car(xs)) || !Numberp(Car(Cdr(xs))))
      throw new SchemeError("Number required");
  }
  
  // 組み込み関数
  static void MakePrimitive() {
    sT.Value = sT;
    sNil.Value = sNil;
    Func&lt;object, object&gt; car = xs =&gt; Car(Car(xs));
    MakeSymbol("car", car);
    Func&lt;object, object&gt; cdr = xs =&gt; Cdr(Car(xs));
    MakeSymbol("cdr", cdr);
    Func&lt;object, object&gt; cons = xs =&gt; new Cons(Car(xs), Car(Cdr(xs)));
    MakeSymbol("cons", cons);
    Func&lt;object, object&gt; eq = xs =&gt; Car(xs) == Car(Cdr(xs)) ? sT : sNil;
    MakeSymbol("eq?", eq);
    Func&lt;object, object&gt; pair = xs =&gt; Consp(Car(xs)) ? sT : sNil;
    MakeSymbol("pair?", pair);
    Func&lt;object, object&gt; plus = xs =&gt; {
      return (BigInteger)Car(xs) + (BigInteger)Car(Cdr(xs));
    };
    MakeSymbol("+", plus);
    Func&lt;object, object&gt; mult = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) * (BigInteger)Car(Cdr(xs));
    };
    MakeSymbol("*", mult);
    Func&lt;object, object&gt; minus = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) - (BigInteger)Car(Cdr(xs));
    };
    MakeSymbol("-", minus);
    Func&lt;object, object&gt; div = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) / (BigInteger)Car(Cdr(xs));
    };
    MakeSymbol("/", div);
    Func&lt;object, object&gt; equal = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) == (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("=", equal);
    Func&lt;object, object&gt; notEqual = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) != (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("/=", notEqual);
    Func&lt;object, object&gt; lt = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) &lt; (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("&lt;", lt);
    Func&lt;object, object&gt; le = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) &lt;= (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("&lt;=", le);
    Func&lt;object, object&gt; gt = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) &gt; (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("&gt;", gt);
    Func&lt;object, object&gt; ge = xs =&gt; {
      CheckNumber(xs);
      return (BigInteger)Car(xs) &gt;= (BigInteger)Car(Cdr(xs)) ? sT : sNil;
    };
    MakeSymbol("&gt;=", ge);
  }
  
  // 先読みバッファ
  static char ch;

  // 記号の先読み
  static void NextChar() {
    ch = (char)Console.Read();
  }

  // 記号の読み込み
  static char GetChar() {
    return ch;
  }

  // 数値の読み込み
  static BigInteger GetNumber() {
    var sb = new StringBuilder();
    BigInteger val;
    do {
      sb.Append(GetChar());
      NextChar();
    } while (char.IsDigit(GetChar()));
    if (!BigInteger.TryParse(sb.ToString(), out val)) {
      throw new SchemeError("Number required");
    }
    return val;
  }
  
  // Symbol に含めてよい記号
  static bool IsSymbol(char c) {
    string symCode = "!&amp;*+-/:&lt;=&gt;?@^_~";
    return char.IsLetter(GetChar()) || symCode.IndexOf(GetChar()) &gt; 0;
  }
  
  // Symbol の読み込み
  static Symbol GetSymbol() {
    var sb = new StringBuilder();
    do {
      sb.Append(GetChar());
      NextChar();
    } while (IsSymbol(GetChar()) || char.IsDigit(GetChar()));
    return MakeSymbol(sb.ToString());
  }

  // 空白文字をスキップ
  static void SkipSpace() {
    while (char.IsWhiteSpace(GetChar())) {
      NextChar();
    }
  }

  // リストの読み込み
  static object ReadList() {
    SkipSpace();
    if (GetChar() == ')') {
      NextChar();
      return sNil;
    } else if (GetChar() == '.') {
      NextChar();
      object x = ReadS();
      SkipSpace();
      if (GetChar() != ')') {
        throw new SchemeError("invalid dot list");
      }
      NextChar();
      return x;
    } else {
      return new Cons(ReadS(), ReadList());
    }
  }
  
  // S 式の読み込み
  static object ReadS() {
    SkipSpace();
    char c = GetChar();
    if (char.IsDigit(c)) { // || c == '+' || c == '-') {
      return GetNumber();
    } else if (IsSymbol(GetChar()) ){
      return GetSymbol();
    } else if (GetChar() == '\'') {
      NextChar();
      return new Cons(sQuote, new Cons(ReadS(), sNil));
    } else if (GetChar() == '(') {
      NextChar();
      return ReadList();
    } else {
      throw new SchemeError("invalid token");
    }
  }

  // S 式の出力
  static void PrintS(object xs) {
    if (Consp(xs)) {
      Console.Write("(");
      while (Consp(xs)) {
        if (Consp(Car(xs))) {
          PrintS(Car(xs));
        } else {
          Console.Write("{0}", Car(xs));
        }
        if (!Null(Cdr(xs))) Console.Write(" ");
        xs = Cdr(xs);
      }
      if (!Null(xs)) Console.Write(". {0}", xs);
      Console.Write(")");
    } else {
      Console.Write("{0}", xs);
    }
  }

  // 環境
  class Env {
    public Symbol Key { get; set; }
    public object Value { get; set; }
    public Env Next { get; set; }

    public Env(Symbol k, object v, Env n) {
      Key = k;
      Value = v;
      Next = n;
    }

    public object Assoc(Symbol key) {
      Env xs = this;
      while (xs != null) {
        if (xs.Key == key) return xs.Value;
        xs = xs.Next;
      }
      return null;
    }
  }

  // 変数の値を求める
  static object Lookup(Symbol key, Env env) {
    object val = env != null ? env.Assoc(key) : null;
    if (val == null) {
      if (key.Value == null)
        throw new SchemeError("unbound variable");
      else
        return key.Value;
    }
    return val;
  }

  // クロージャ
  class Closure {
    public object Args { set; get; }
    public object Body { set; get; }
    public Env    Cenv { set; get; }
    public Closure(object a, object b, Env e) {
      Args = a;
      Body = b;
      Cenv = e;
    }
  }
  
  // 引数の評価
  static object EvalArguments(object xs, Env env) {
    if (Null(xs)) {
      return sNil;
    } else {
      return new Cons(EvalS(Car(xs), env), EvalArguments(Cdr(xs), env));
    }
  }

  // 変数束縛
  static Env AddBinding(object xs, object args, Env env) {
    while (Consp(xs) &amp;&amp; Consp(args)) {
      env = new Env((Symbol)Car(xs), Car(args), env);
      xs = Cdr(xs);
      args = Cdr(args);
    }
    if (!Null(xs) || !Null(args)) {
      throw new SchemeError("wrong number of arguments");
    }
    return env;
  }

  // 本体の評価
  static object EvalBody(object xs, Env env) {
    object result = sNil;
    while (Consp(xs)) {
      result = EvalS(Car(xs), env);
      xs = Cdr(xs);
    }
    return result;
  }

  static object ApplyS(object fn, object args) {
    if (fn is Delegate) {
      // 組み込み関数
      return ((Func&lt;object, object&gt;)fn)(args);
    } else if (fn is Closure) {
      // クロージャ
      Closure c = (Closure)fn;
      return EvalBody(c.Body, AddBinding(c.Args, args, c.Cenv));
    } else {
      throw new SchemeError("Function required");
    }
  }

  // 特殊形式
  static object DefineS(object xs, Env env) {
    if (!Symbolp(Car(xs)) || Null(Cdr(xs)))
      throw new SchemeError("invalid define form");
    ((Symbol)Car(xs)).Value = EvalS(Car(Cdr(xs)), env);
    return Car(xs);
  }

  static object IfS(object xs, Env env) {
    if (Consp(xs) &amp;&amp; Consp(Cdr(xs))) {
      object result = EvalS(Car(xs), env);
      if (result != sNil) {
        return EvalS(Car(Cdr(xs)), env);
      } else if (Consp(Cdr(Cdr(xs)))) {
        return EvalS(Car(Cdr(Cdr(xs))), env);
      } else {
        return sNil;
      }
    } else {
      throw new SchemeError("invalid if form");
    }
  }

  // S 式の評価
  static object EvalS(object xs, Env env) {
    if (Numberp(xs)) {
      return xs;
    } else if (Symbolp(xs)) {
      return Lookup((Symbol)xs, env);
    } else if (Consp(xs)) {
      // 特殊形式のチェック
      if (Car(xs) == sQuote) {
        return Car(Cdr(xs));
      } else if (Car(xs) == sDefine) {
        return DefineS(Cdr(xs), env);
      } else if (Car(xs) == sIf) {
        return IfS(Cdr(xs), env);
      } else if (Car(xs) == sLambda) {
        return new Closure(Car(Cdr(xs)), Cdr(Cdr(xs)), env);
      } else {
        // 関数呼び出し
        object fn = EvalS(Car(xs), env);
        return ApplyS(fn, EvalArguments(Cdr(xs), env));
      }
    } else {
      throw new SchemeError("EvalS: invalid object");
    }
  }

  // トップレベル
  static void TopLevel() {
    Console.Write("mscm&gt; ");
    NextChar();
    while (true) {
      try {
        PrintS(EvalS(ReadS(), null));
        Console.WriteLine("");
      } catch(SchemeError e) {
        Console.WriteLine(e.Message);
        // 入力のクリア
        while (GetChar() != '\n') {
          NextChar();
        }
      }
      Console.Write("mscm&gt; ");
    }
  }

  static void Main() {
    MakePrimitive();
    TopLevel();
  }
}
</pre>
<pre>
C&gt;mscm
mscm&gt; 'a
a
mscm&gt; 12345
12345
mscm&gt; '(1 2 3 4 5)
(1 2 3 4 5)
mscm&gt; (car '(a b c))
a
mscm&gt; (cdr '(a b c))
(b c)
mscm&gt; (cons 'a 'b)
(a . b)
mscm&gt; (pair? '(a b c))
t
mscm&gt; (pair? 'a)
nil
mscm&gt; (eq? 'a 'a)
t
mscm&gt; (eq? 'a 'b)
nil
mscm&gt; (define a 10)
a
mscm&gt; a
10
mscm&gt; (define square (lambda (x) (* x x)))
square
mscm&gt; (square 123)
15129
mscm&gt; ((lambda (x) (* x x)) 10)
100
mscm&gt; (define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
fact
mscm&gt; (fact 10)
3628800
mscm&gt; (fact 20)
2432902008176640000
mscm&gt; (fact 50)
30414093201713378043612608166064768844377641568960512000000000000
mscm&gt; (define iota (lambda (n m) (if (> n m) nil (cons n (iota (+ n 1) m)))))
iota
mscm&gt; (iota 1 10)
(1 2 3 4 5 6 7 8 9 10)
mscm&gt; (define map (lambda (f xs) (if (pair? xs)
(cons (f (car xs)) (map f (cdr xs))))))
map
mscm&gt; (map (lambda (x) (* x x)) (iota 1 20))
(1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400)
mscm&gt; (define foo (lambda (x) (lambda (y) (+ x y))))
foo
mscm&gt; (define foo100 (foo 100))
foo100
mscm&gt; (foo100 100)
200
mscm&gt; (foo100 1000)
1100
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Ｃ＃</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>