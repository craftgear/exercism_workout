<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj06.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj08.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap0701">モジュール</h3>
<p> 前回は双方向リストクラス &lt;dlist&gt; に &lt;sequence&gt; を Mix-in しました。プログラム (dlist.scm) の中には、内部でしか使わない作業用の関数など、外部から呼び出されると困る関数やメソッドなどがあります。また、Gauche や CLOS の場合、スロットやメソッドのアクセス権を設定する機能はありません。必要な関数 (メソッド) や変数 (シンボル) だけを外部に公開し、内部で使用するものを隠蔽する機能があると便利です。
</p>

<p> このような場合、Gauche では「モジュール (module) 」を利用することができます。モジュールを簡単に説明すると、ある機能を実現するためのプログラムの集まりや構造のことです。たとえば双方向リストの場合、クラス (データ構造) の定義と基本的な関数 (メソッド) が複数ありますが、それらをひとつにまとめてモジュールとして考えることができます。今回はモジュールの基本的な使い方について簡単に説明します。
</p>

<h4>●モジュールとは？</h4>
<p> プログラムを作っていると、ほかのプログラムで作った関数が利用できるのではないか、といった場面に出会うことがあります。このような場合、自分で作成した関数をライブラリとしてまとめておくと、簡単に再利用することができて便利です。もともと、このような場合に使われる機能がモジュールです。Gauche のライブラリはモジュールを使って整理されています。
</p>

<p> ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、ライブラリ内部で使用する関数や変数に同じ名前のものが存在すると、そのライブラリは正常に動作しないでしょう。この名前の衝突を避けるためにモジュールを使います。次の例を見てください。
</p>

<pre>
gosh&gt; (current-module)
#&lt;module user&gt;
gosh&gt; (define a 10)
a
gosh&gt; a
10
gosh&gt; (define-module foo)
#&lt;undef&gt;
gosh&gt; (select-module foo)
#&lt;undef&gt;
gosh&gt; a
*** ERROR: unbound variable: a

gosh&gt; (define a 20)
a
gosh&gt; a
20
gosh&gt; (select-module user)
#&lt;undef&gt;
gosh&gt; a
10
</pre>
<p> 特殊形式 current-module は現時点で使用しているモジュール (カレントモジュール) を返します。Gauche を起動すると、カレントモジュールは user というあらかじめ用意されているモジュールになります。REPL で定義する変数や関数は user に登録されます。したがって、最初 a に 10 を代入しましたが、この変数はモジュール user 内に定義されます。
</p>

<p> define-module はモジュールを定義する特殊形式です。あとで詳しく説明しますが、ここでは foo という名前のモジュールを定義しています。select-module はカレントモジュールを切り替える特殊形式です。Gauche はカレントモジュールの中からグローバル変数の値を探します。これ以降、REPL で定義されるグローバル変数はモジュール foo での値になります。
</p>

<p> カレントモジュールを fooに切り替えた場合、グローバル変数 a はまだ定義されていないので値は未束縛です。次に、変数 a の値を 20 にセットします。この値はモジュール foo でのみ有効で、カレントモジュールを user に切り替えると、グローバル変数 a の値は 10 になります。このように、モジュールによってグローバル変数 a の値は区別されるのです。
</p>

<h4>●モジュールの定義と評価</h4>
<p> define-module はモジュールを定義するだけではなく、その中で S 式を評価することもできます。
</p>
<pre class="item">
define-module module-name body ...
</pre>
<p> body はそのモジュールの中で評価されるので、その結果がグローバル変数を定義するものであれば、その値はそのモジュールに属することになります。モジュールで定義されているグローバル変数の値は、select-module でモジュールを切り替えなくても特殊形式 with-module を使って求めることができます。
</p>
<pre class="item">
with-module module-name body ...
</pre>
<p> with-module はカレントモジュールを module-name に切り替えて body を順番に評価します。そして、最後に評価した S 式の結果を返します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define-module foo (define a 10))
a
gosh&gt; a
*** ERROR: unbound variable: a

gosh&gt; (with-module foo a)
10
gosh&gt; (with-module foo (+ 10 a))
20
</pre>
<p> モジュール foo でグローバル変数 a を定義しました。モジュール user では定義されていません。with-module でモジュール foo を指定して S 式を評価すると、そこで定義されている変数 a の値にアクセスすることができます。
</p>
<p> もちろん、モジュールで関数を定義して呼び出すこともできます。
</p>
<pre>
gosh&gt; (define-module bar (define (baz) (print "bar baz!")))
baz
gosh&gt; (with-module bar (baz))
bar baz!
#&lt;undef&gt;
</pre>
<p> このように、with-module を使うと他のモジュールで定義された変数や関数にアクセスすることができますが、公開したくない関数や変数までアクセスが可能になってしまいます。通常は、次に説明する import と export を使います。
</p>

<h4>●import と export</h4>
<p> Gauche には、ほかのモジュールで定義された関数や変数を取り込む機能「インポート (import) 」が用意されています。ただし、このためにはモジュール側でも関数や変数を公開するための準備が必要です。これを「エキスポート (export) 」といいます。
</p>
<p> ここで、Gauche の中では同じ名前のシンボルは一つしかないことに注意してください。たとえば、モジュール user のシンボル a とモジュール foo のシンボル a は同一のものなので、eq? で比較すると #t になります。
</p>
<pre>
gosh&gt; (define a 10)
a
gosh> a
10
gosh&gt; (define-module foo (define a 20))
a
gosh&gt; (with-module foo a)
20
gosh&gt; (eq? 'a (with-module foo 'a))
#t
</pre>
<p> Gauche のモジュールは、そこに属する新しいシンボルを作成するのではありません。モジュールはシンボルに束縛されたグローバルな値を保持する環境、と考えるとわかりやすいと思います。モジュールを切り替えると環境も切り替わるので、同じシンボルであってもモジュールによってグローバル変数の値が異なるわけです。
</p>

<p> Gauche の場合、exprot と import は特殊形式として定義されています。
</p>
<pre class="item">
export symbol ...
import module-name ...
</pre>
<p> export はモジュール内の symbol を公開します。import はモジュール module-name の export で公開された symbol をカレントモジュールに受け入れます。つまり、module-name の中で定義された symbol の束縛 (グローバル変数の値) が見えるようになります。なお、import の引数は複数のモジュールを指定することができます。これで、export されたグローバル変数の値にアクセスすることができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define-module foo (export a) (define a 10))
a
gosh&gt; (define-module bar (export b) (define b 20))
b
gosh&gt; a
*** ERROR: unbound variable: a

gosh&gt; (import foo)
#&lt;undef&gt;
gosh&gt; a
10
gosh&gt; b
*** ERROR: unbound variable: b

gosh&gt; (import bar)
#&lt;undef&gt;
gosh&gt; b
20
</pre>
<p> モジュール foo はグローバル変数 a を export とし、bar はグローバル変数 b を export としています。カレントモジュール user で、グローバル変数 a は未束縛ですが、foo を import とすると foo での束縛が見えるようになるので、a の値は 10 になります。同様に、bar を import するとグローバル変数 b の値は 20 になります。
</p>

<h4>●モジュールの作り方</h4>
<p> Gauche の場合、通常はひとつのファイルでひとつのモジュールを定義します。ひとつのモジュールを複数のファイルに分割することもできますが、よほど大きなプログラムでなければ、複数のファイルに分割する必要はないと思います。Gauche の場合、モジュール名とファイル名は同じにしておきます。たとえば、モジュール名が foo であればファイル名は foo.scm となります。
</p>
<p> モジュールの骨格をリスト 1 に示します。
</p>
<pre class="list">
リスト 1 : モジュールの骨格

(define-module module-name
  (use ...)
  (export ...))

(select-module module-name)

・・・モジュール本体・・・

(provide "module-name")
</pre>
<p> 最初に define-module でモジュールを定義します。ここで、使用するモジュールを use などでロードし、公開する変数や関数 (メソッド) を export で指定します。define-module の中でモジュール本体を記述することもできますが、Gauche のユーザリファレンスでは非推薦となっています。
</p>
<p> 次に、select-module でカレントモジュールを module-name に切り替えて、モジュール本体を記述します。そして、最後に provide で module-name を文字列で指定します。
</p>
<pre class="item">
provide module-name
</pre>
<p> provide は use でモジュールをロードするために必要となります。provide で指定されたモジュールは一度ロードされると、それ以降 use や require などで再ロードされることはありません。
</p>

<h4>●モジュールのロード</h4>
<p> モジュールのロードは、プログラムファイルのロードと同じです。Gauche の場合、load や require でプログラムをロードすることができますが、import の処理は行われません。マクロ use を使うと、自動的に import の処理も行ってくれるので便利です。use はグローバル変数 *load-path* に格納されているディレクトリからモジュールを探すので、作成したモジュールはそこに置いておくか、*load-path* にモジュールがあるディレクトリのパスを追加してください。
</p>

<p> なお、モジュールをロードするとき、モジュール内でカレントモジュールを切り替えますが、ロードしたあとカレントモジュールは元の状態に戻ります。モジュール内でカレントモジュールを元に戻す操作は必要ありません。
</p>

<p> 簡単な例題として、前回作成した双方向リスト dlist.scm をモジュールにしたものを <a href="abcobj07.html#list1">プログラムリスト</a> に示します。プログラムの修正は簡単なので説明は割愛いたします。興味のある方は実際にいろいろ試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; dlist.scm : 双方向リスト (モジュール版)
;
;             Copyright (C) 2010 Makoto Hiroi
;

(define-module dlist
  (use gauche.sequence)
  (export &lt;dlist&gt;
          make-dlist dlist?
          dlist-ref dlist-set!
	  dlist-insert! dlist-delete!
	  dlist-fold dlist-for-each
	  dlist-length dlist-clear
	  dlist-empty? list-&gt;dlist dlist-&gt;list
          call-with-iterator call-with-builder
	  referencer modifier
	))

(select-module dlist)

; コレクション用メタクラス
(define-class &lt;dlist-meta&gt; (&lt;class&gt;) ())

; セルの定義
(define-class &lt;cell&gt; ()
  ((item :accessor cell-item :init-value #f :init-keyword :item)
   (prev :accessor cell-prev :init-value #f :init-keyword :prev)
   (next :accessor cell-next :init-value #f :init-keyword :next)))

; 空リストを作る
(define (make-empty)
  (let ((cp (make &lt;cell&gt;)))
    (set! (cell-prev cp) cp)
    (set! (cell-next cp) cp)
    cp))

; 双方向リストの定義
(define-class &lt;dlist&gt; (&lt;sequence&gt;)
  ((top :accessor dlist-top :init-form (make-empty)))
  :metaclass &lt;dlist-meta&gt;)

; 双方リストの生成
(define (make-dlist) (make &lt;dlist&gt;))

; 双方向リスト?
(define (dlist? x) (eq? (class-of x) &lt;dlist&gt;))

; n 番目のセルを返す (作業用関数)
(define (cell-nth d n next)
  (let loop ((i -1) (cp (dlist-top d)))
    (cond ((and (&lt;= 0 i) (eq? (dlist-top d) cp))
           (error "cell-nth --- oops!"))
	  ((= n i) cp)
	  (else
	   (loop (+ i 1) (next cp))))))

; 参照
(define-method dlist-ref ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (cell-item
    (if (negative? n)
        (cell-nth d (abs (+ n 1)) cell-prev)       
      (cell-nth d n cell-next))))

; 書き換え
(define-method dlist-set! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (set! (cell-item (if (negative? n)
                       (cell-nth d (abs (+ n 1)) cell-prev)
		     (cell-nth d n cell-next)))
        value))

; 挿入
(define-method dlist-insert! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (define (cell-insert! n next prev)
    (let* ((p (cell-nth d (- n 1) next))
           (q (next p))
           (cp (make &lt;cell&gt; :item value)))
    (set! (next cp) q)
    (set! (prev cp) p)
    (set! (prev q) cp)
    (set! (next p) cp)))
  ;
  (if (negative? n)
      (cell-insert! (abs (+ n 1)) cell-prev cell-next)
    (cell-insert! n cell-next cell-prev)))

; 削除
(define-method dlist-delete! ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (define (cell-delete! n next prev)
    (let* ((cp (cell-nth d n next))
           (p (prev cp))
	   (q (next cp)))
      (set! (next p) q)
      (set! (prev q) p)
      (cell-item cp)))
  ;
  (if (negative? n)
      (cell-delete! (abs (+ n 1)) cell-prev cell-next)
    (cell-delete! n cell-next cell-prev)))

; 畳み込み
(define-method dlist-fold ((d &lt;dlist&gt;) func init . args)
  (let ((next (if (get-keyword :from-end args #f) cell-prev cell-next)))
    (let loop ((cp (next (dlist-top d))) (a init))
      (if (eq? cp (dlist-top d))
          a
        (loop (next cp)
	      (if (eq? next cell-prev)
	          (func (cell-item cp) a)
		(func a (cell-item cp))))))))

; サイズ
(define-method dlist-length ((d &lt;dlist&gt;))
  (dlist-fold d (lambda (x y) (+ x 1)) 0))

; クリア
(define-method dlist-clear ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (set! (cell-next cp) cp)
    (set! (cell-prev cp) cp)))

; 空リストか？
(define-method dlist-empty? ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (eq? cp (cell-next cp))))

; 変換
(define-method list-&gt;dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;dlist&gt;)))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))

;
(define-method dlist-&gt;list ((d &lt;dlist&gt;))
  (dlist-fold d
              (lambda (x y) (cons x y))
	      '()
	      :from-end #t))

; 巡回
(define-method dlist-for-each ((d &lt;dlist&gt;) func . opts)
  (if (get-keyword :from-end opts #f)
      (dlist-fold d (lambda (x y) (func x)) #f :from-end #t)
    (dlist-fold d (lambda (x y) (func y)) #f)))

; &lt;collection&gt; 用
: イテレータ
(define-method call-with-iterator ((coll &lt;dlist&gt;) proc . opts)
  (let ((cp (cell-nth coll (get-keyword :start opts 0) cell-next)))
    (proc
      (lambda () (eq? cp (dlist-top coll)))
      (lambda ()
        (if (eq? cp (dlist-top coll))
            #f
	  (begin0 (cell-item cp)
	          (set! cp (cell-next cp))))))))

; ビルダー
(define-method call-with-builder ((class &lt;dlist-meta&gt;) proc . opts)
  (let ((dlist (make &lt;dlist&gt;)))
    (proc (lambda (val) (dlist-insert! dlist -1 val))
          (lambda () dlist))))

;;; &lt;sequence&gt; 用
(define-method referencer ((dlist &lt;dlist&gt;)) dlist-ref)
(define-method modifier ((dlist &lt;dlist&gt;)) dlist-set!)

(provide "dlist")
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap0702">共有スロット</h3>
<p> Gauche の場合、インスタンス中のスロットは同じクラスのインスタンスでも別々のメモリ領域に割り当てられます。たとえば、クラス &lt;foo&gt; にスロット a, b がある場合、make でインスタンス x1, x2 を生成すると、x1 と x2 のスロット a, b は異なるメモリ領域に割り当てられます。Gauche や CLOS では、これを「局所スロット」といいます。オブジェクト指向プログラミングの場合、インスタンスは個々のオブジェクトを表しているので、スロットがインスタンスごとに別々のメモリ領域に割り当てられるのは当然といえるでしょう。
</p>
<p> ところが、プログラムによっては、同じクラスのインスタンスで共通の変数や定数を使いたい場合があります。つまり、インスタンスごとにスロットを用意するのではなく、クラス単位でスロットを用意するのです。Gauche や CLOS では、これを「共有スロット」といいます。他のオブジェクト指向言語では「クラス変数」に相当する機能です。今回は共有スロットについて説明します。
</p>

<h4>●共有スロットの設定</h4>
<p> 共有スロットの設定は、スロットオプション :allocation にキーワード :class を指定します。:allocation の指定がない場合、もしくはキーワード :instance を指定すると、スロットは共有されず「局所スロット」になります。
</p>

<p> 簡単な例を示しましょう。次のリストを見てください。
</p>

<pre class="list">
リスト 1 : 共有スロットの定義

(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-keyword :a :allocation :class)
   (b :accessor foo-b :init-value 1 :init-keyword :b)))
</pre>

<p> クラス &lt;foo&gt; にはスロット a, b がありますが、スロット a が共有スロットで、スロット b が局所スロットになります。局所スロット b はインスタンスごとにメモリ領域が割り当てられますが、共有スロット a のメモリ領域はクラスでひとつしかありません。次の例を見てください。
</p>

<pre>
gosh&gt; (define x1 (make &lt;foo&gt; :a 0 :b 10))
x1
gosh&gt; (define x2 (make &lt;foo&gt; :b 20))
x2
gosh&gt; (foo-a x1)
0
gosh&gt; (foo-b x1)
10
gosh&gt; (foo-a x2)
0
gosh&gt; (foo-b x2)
20
gosh&gt; (set! (foo-a x1) 100)
100
gosh&gt; (foo-a x1)
100
gosh&gt; (foo-a x2)
100
</pre>

<p> 最初に、インスタンス x1 を生成します。ここでスロット a を 0 に、b を 10 に初期化します。次にインスタンス x2 を生成し、スロット b を 20 に初期化します。スロット a は共有スロットなので、a の値は x1 を生成したときの値 0 になります。当然ですが、(foo-a x1) と (foo-a x2) は同じ値になり、(foo-b x1) と (foo-b x2) は異なる値になります。また、(setf (foo-a x1) 100) のように共有スロットの値を書き換えると、(foo-a x2) の値は書き換えた値 100 になります。このように、スロットが共有されていることがわかります。
</p>

<p> また Guache の場合、共有スロットは次の関数を使うとインスタンスではなくクラスオブジェクトからでもアクセスすることができます。
</p>
<pre class="item">
class-slot-ref class slot-name
class-slot-set! class slot-name obj
class-slot-bound? class slot-name obj
</pre>
<p> 簡単な使用例を示します。
</p>
<pre>
gosh&gt; (define-class &lt;foo&gt; () ((a :init-value 1 :allocation :class)))
&lt;foo&gt;
gosh&gt; (class-slot-bound? &lt;foo&gt; 'a)
#t
gosh&gt; (class-slot-ref &lt;foo&gt; 'a)
1
gosh&gt; (class-slot-set! &lt;foo&gt; 'a 10)
10
gosh&gt; (class-slot-ref &lt;foo&gt; 'a)
10
</pre>
<h4>●共有スロットの継承</h4>
<p> ところで、Gauche や CLOS の継承はスロットやメソッドだけではなく :allocation オプションも継承されることに注意してください。次のリストを見てください。
</p>

<pre class="list">
リスト 2 : 共有スロットの継承

(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-keyword :a :allocation :class)
   (b :accessor foo-b :init-value 1 :init-keyword :b)))

(define-class &lt;foo1&gt; (&lt;foo&gt;)
  ((c :accessor foo-c :init-value 2 :init-keyword :c)))
</pre>
<p> クラス &lt;foo&gt; を継承してクラス &lt;foo1&gt; を定義します。&lt;foo1&gt; のスロットは a, b, c の 3 つになりますが、スロット a は共有スロットになります。このとき、スロット a は &lt;foo1&gt; だけはなく、&lt;foo&gt; と &lt;foo1&gt; の共有スロットになります。簡単な例を示しましょう。
</p>

<pre>
gosh&gt; (define x3 (make &lt;foo1&gt;))
x3
gosh&gt; (foo-a x3)
100
gosh&gt; (foo-b x3)
1
gosh&gt; (foo-c x3)
2
gosh&gt; (set! (foo-a x3) 200)
200
gosh&gt; (foo-a x1)
200
gosh&gt; (foo-a x2)
200
gosh&gt; (foo-a x3)
200
</pre>
<p> クラス &lt;foo&gt; のインスタンスが変数 x1, x2 にセットされている状態で、クラス &lt;foo1&gt; のインスタンスを生成して変数 x3 にセットします。x3 のスロット a は共有スロットなので、x1, x2 と同じ値になります。スロット b, c は局所スロットなので、:init-value の値で初期化されます。ここで、(set! (foo-a x3) 200) とスロット a の値を 200 に書き換えると、(foo-a x1) と (foo-a x2) の値は 200 になります。スロット a はクラス &lt;foo&gt; と &lt;foo1&gt; で共有されていることがわかります。
</p>

<h4>●共有スロットの衝突</h4>
<p> それでは、サブクラスにスーパークラスと同じ名前の共有スロットを定義したらどうなるのでしょうか。次のリストを見てください。
</p>

<pre class="list">
リスト 3 : 同名の共有スロットがある場合

(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-keyword :a :allocation :class)
   (b :accessor foo-b :init-value 1 :init-keyword :b)))

(define-class &lt;foo2&gt; (&lt;foo&gt;)
  ((a :accessor foo2-a :init-keyword :a :allocation :class)
   (c :accessor foo2-c :init-value 3 :init-keyword :c)))
</pre>

<p> クラス &lt;foo&gt; を継承してクラス &lt;foo2&gt; を定義します。&lt;foo2&gt; でも共有スロット a を定義していることに注意してください。この場合、&lt;foo&gt; のスロット a と &lt;foo2&gt; のスロット a は共有されません。つまり、&lt;foo&gt; のスロット a は &lt;foo&gt; の共有スロットであり、&lt;foo2&gt; のスロット a は &lt;foo2&gt; の共有スロットになるのです。次の例を見てください。
</p>

<pre>
gosh&gt; (define x1 (make &lt;foo&gt; :a 100))
x1
gosh&gt; (define x2 (make &lt;foo2&gt; :a 200))
x2
gosh&gt; (foo-a x1)
100
gosh&gt; (foo2-a x2)
200
gosh&gt; (foo-a x2)
200
</pre>
<p> &lt;foo&gt; のインスタンスを生成して変数 x1 にセットします。このとき、共有スロット a を 100 に初期化しています。次に &lt;foo2&gt; のインスタンスを生成して変数 x2 にセットします。共有スロット a は 200 に初期化されていることに注意してください。そして、インスタンス x1 と x2 のスロット a の値を求めるてみると 100 と 200 になります。
</p>
<p> このように、&lt;foo&gt; と &lt;foo2&gt; のスロット a は共有されません。&lt;foo2&gt; のインスタンス中のスロット a は &lt;foo2&gt; の共有スロットであり、(foo-a x2) としても &lt;foo&gt; の共有スロット a にアクセスすることはできません。つまり、&lt;foo&gt; の共有スロット a はサブクラス &lt;foo2&gt; の共有スロット a に「隠蔽（シャドウ）」されるわけです。
</p>

<h4>●局所スロットと共有スロットの衝突</h4>
<p> 今度は、スーパークラスの共有スロットと同じ名前の局所スロットがある場合を考えてみます。この場合、:allocation オプションはサブクラスの指定が優先されます。次のリストを見てください。
</p>

<pre class="list">
リスト 4 : 局所スロットと共有スロットの衝突 (1)

(define-class &lt;foo1&gt; (&lt;foo&gt;)
  ((c :accessor foo-c :init-value 2 :init-keyword :c)))

(define-class &lt;foo3&gt; (&lt;foo&gt;)
  ((a :accessor foo3-a :init-keyword :a :allocation :instance)
   (c :accessor foo3-c :init-value 3 :init-keyword :c)))
</pre>
<p> クラス &lt;foo&gt; を継承してクラス &lt;foo3&gt; を定義します。&lt;foo&gt; のスロット a は共有スロットですが、&lt;foo3&gt; のスロット a は局所スロットであることに注意してください。この場合、クラス &lt;foo&gt; のインスタンスのスロット a は共有スロットになりますが、クラス &lt;foo3&gt; のインスタンスのスロット a は局所スロットになります。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define x1 (make &lt;foo&gt; :a 10 :b 20))
x1
gosh&gt; (define x2 (make &lt;foo&gt; :b 30))
x2
gosh&gt; (define y1 (make &lt;foo3&gt; :a 100 :c 200))
y1
gosh&gt; (define y2 (make &lt;foo3&gt; :a 300 :c 400))
y2
gosh&gt; (foo-a x1)
10
gosh&gt; (foo-a x2)
10
gosh&gt; (foo3-a y1)
100
gosh&gt; (foo3-a y2)
300
gosh&gt; (foo-a y1)
100
gosh&gt; (foo-a y2)
300
</pre>
<p> クラス &lt;foo&gt; のインスタンスを生成して変数 x1, x2 にセットし、クラス &lt;foo3&gt; のインスタンスを生成して変数 y1, y2 にセットします。&lt;foo&gt; のスロット a は共有スロットなので、(foo-a x1) と (foo-a x2) は同じ値 (10) になります。ところが、&lt;foo3&gt; のスロット a は局所スロットになるので、make で指定した値に初期化されます。したがって、(foo-a y1) は 100 になり、(foo-a y2) は 300 になります。
</p>

<p> 逆に、スーパークラスのスロット a が局所スロットで、サブクラスのスロット a が共有スロットの場合、サブクラスのスロット a は共有スロットになります。次のリストを見てください。
</p>

<pre class="list">
リスト 5 : 局所スロットと共有スロットの衝突 (2)

(define-class &lt;bar&gt; ()
  ((a :accessor bar-a :init-value 0 :init-keyword :a)
   (b :accessor bar-b :init-value 1 :init-keyword :b)))

(define-class &lt;bar1&gt; (&lt;bar&gt;)
  ((a :accessor bar1-a :init-keyword :a :allocation :class)
   (c :accessor bar1-c :init-value 2 :init-keyword :c)))
</pre>
<p> クラス &lt;bar&gt; のスロット a, b は局所スロットです。&lt;bar&gt; を継承してクラス &lt;bar1&gt; を定義します。このとき、スロット a を共有スロットとして定義します。&lt;bar&gt; のインスタンス中のスロット a は局所スロットになりますが、&lt;bar1&gt; のスロット a は共有スロットになります。簡単な実行例を示しましょう。
</p>

<pre>
gosh&gt; (define x1 (make &lt;bar&gt; :a 10 :b 20))
x1
gosh&gt; (define x2 (make &lt;bar&gt; :a 30 :b 40))
x2
gosh&gt; (define y1 (make &lt;bar1&gt; :a 100 :b 200 :c 300))
y1
gosh&gt; (define y2 (make &lt;bar1&gt; :b 400 :c 500))
y2
gosh&gt; (bar-a x1)
10
gosh&gt; (bar-a x2)
30
gosh&gt; (bar-a y1)
100
gosh&gt; (bar-a y2)
100
gosh&gt; (bar1-a y1)
100
gosh&gt; (bar1-a y2)
100
</pre>
<p> クラス &lt;bar&gt; のインスタンス x1, x2 のスロット a は局所スロットで、&lt;bar1&gt; のインスタンス y1, y2 のスロット a は共有スロットになっていることがわかります。ようするに、スロットオプション :allocation の設定は「クラス優先順位リスト」に従って決定されるのです。これは多重継承でも同じです。次のリストを見てください。
</p>

<pre class="list">
リスト 6 : 局所スロットと共有スロットの衝突 (3)

(define-class &lt;baz1&gt; ()
  ((a :accessor baz1-a :init-keyword :a)))

(define-class &lt;baz2&gt; ()
  ((a :accessor baz2-a :init-keyword :a :allocation :class)))

(define-class &lt;baz3&gt; (&lt;baz1&gt; &lt;baz2&gt;) ())

(define-class &lt;baz4&gt; (&lt;baz2&gt; &lt;baz1&gt;) ())
</pre>

<p> クラス &lt;baz1&gt; のスロット a は局所スロットで、&lt;baz2&gt; のスロット a は共有スロットです。この 2 つのクラスを多重継承して、クラス &lt;baz3&gt; と &lt;baz4&gt; を作成します。この場合、クラス優先順位リスト（この場合は左優先則）に従って、&lt;baz3&gt; のスロット a は局所スロット、&lt;baz4&gt; のスロット a は共有スロットになります。実行例は次のようになります。
</p>

<pre>
gosh&gt; (define x1 (make &lt;baz3&gt; :a 10))
x1
gosh&gt; (define x2 (make &lt;baz3&gt; :a 20))
x2
gosh&gt; (define y1 (make &lt;baz4&gt; :a 30))
y1
gosh&gt; (define y2 (make &lt;baz4&gt;))
y2
gosh&gt; (baz1-a x1)
10
gosh&gt; (baz1-a x2)
20
gosh&gt; (baz2-a y1)
30
gosh&gt; (baz2-a y2)
30
gosh&gt; (baz1-a y2)
30
gosh&gt; (baz1-a y1)
30
</pre>
<p> &lt;baz3&gt; のインスタンス x1, x2 のスロット a の値は 10, 20 になるので、局所スロットであることがわかります。次に &lt;baz4&gt; のインスタンス y1, y2 を生成します。y1 のスロット a の値は 30 で、y2 のスロット a も 30 なので、共有スロットであることがわかります。このように、スロット名が衝突した場合、:allocation の設定は「クラス優先順位リスト」に従って決定されます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj06.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj08.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>