<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881750</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml10.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml12.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">ファンクタ</h3>
<p> 前々回はモジュールとシグネチャについて説明し、前回は簡単な例題として有理数を扱うモジュール Ratio を作成しました。OCaml のモジュール機能はこれだけではありません。もう一つ重要な機能に「ファンクタ (functor) 」があります。ファンクタは引数にモジュールを受け取り、それを使って新しいモジュールを生成する機能です。ファンクタはモジュールを生成するモジュールと考えてください。今回は「二分探索木 (binary search tree) 」を例題にファンクタを説明します。
</p>
<p> まず最初に二分探索木から説明しましょう。二分木を理解されている方は読み飛ばしてもらってかまいません。
</p>
<p> <a href="ocaml11.html#next">次へ</a>
</p>
<h4>●二分探索木</h4>
<p> あるデータの中から特定のデータを探す場合、データ数が少なければ力任せに探索してもなんとかなりますが、データ数が多くなると探索に時間がかかるようになります。このような場合、あらかじめデータを整理整頓しておくことで、特定のデータを高速に見つけることができるようになります。この代表的なアルゴリズムが「ハッシュ法」と「二分探索木」です。二分探索木はその名が示すように「木構造」の一種です。まずは木構造から説明しましょう。
</p>

<h4>●木構造</h4>
<p> 「木構造 (tree structer) 」は「木 (tree) 」とも呼ばれるデータ構造で、「節 (ノード) 」と呼ばれる要素に対して、階層的な関係を表したものです。身近な例では、ディレクトリの階層構造が木にあたります。ディレクトリに「ルートディレクトリ」があるように、木にも「根 (ルート) 」と呼ばれる節が存在します。
</p>

<pre class="fig">
          (root)
            Ａ    ────────  レベル０  
          ／｜＼                ↑
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ            木  レベル１
    ／｜＼        ｜＼          の
  ／  ｜  ＼      ｜  ＼        高
Ｅ    Ｆ    Ｇ    Ｈ    Ｉ      さ  レベル２
          ／  ＼
        ／      ＼              ↓
      Ｊ          Ｋ    ─────  レベル３

        図 1 : 一般的な木構造の一例
</pre>
<p> 木を図示する場合、階層関係がはっきりわかるように、根を上にして、同じ階層にある節を並べて書きます。根からレベル 0、レベル 1 と階層を数えていき、最下層の節までの階層数を「木の高さ」といいます。木は、ある節から下の部分を切り出したものも、木としての性質を持っています。これを「部分木」といいます。
</p>

<p> 木は、ある節からほかの節に至る「経路」を考えることができます。たとえば、A から J には、A - B - G - J という経路がありますね。これは、ディレクトリやファイルを指定するときのパスと同じです。
</p>

<p> ある節から根の方向にさかのぼるとき、途中で通っていく節を「先祖」といい、直接繋がっている節を「親」といます。これは、逆から見ると「子孫」と「子」という関係になります。子を持たない節をとくに「葉」と呼ぶことがあります。上図でいうと、G は J と K の親で、J は G の子になります。J は子を持っていないので葉となります。
</p>

<p> 子は、「左 &lt; 右」の順番で節に格納するのが一般的です。これを「順序木」といいます。また、順番がない木を「無順序木」と呼びます。節が持っている子の数を「次数」といいます。上図の場合、A は 3 つの子 B, C, D を持っているので、A の次数は 3 となります。すべての節の次数を n に揃えた順序木を「 n 分木」と呼びます。
</p>
<h4>●二分木</h4>
<p> とくに、次数が 2 の二分木は、プログラムでよく使われるデータ構造です。
</p>

<pre class="fig">
                    (root)
                      18
                    ／  ＼
                  ／      ＼
                ／          ＼
              ／              ＼
            ／                  ＼
          14                      22
        ／  ＼                  ／  ＼
      ／      ＼              ／      ＼
    12          16          20          24
  ／  ＼      ／  ＼      ／  ＼      ／  ＼
11      13  15      17  19      21  23      25

            図 2 : 二分木の一例
</pre>
<p> 上図に二分木の例を示します。二分木では、節にひとつのデータを格納します。そして、その節の左側の子には小さいデータを、右側の子には大きいデータが配置されるように木を構成します。
</p>

<p> この二分木をデータの探索に使うアルゴリズムが「二分探索木」です。二分探索木はデータの探索・挿入を高速に行うことができます。たとえば、上図の木から 19 を探してみましょう。まず root の 18 と比較します。18 &lt; 19 ですから、右側の子をたどり 22 と比較します。今度は 19 &lt; 22 なので左側の子をたどります。次は 20 と比較し 19 &lt; 20 なので左側の子をたどり、ここで 19 を見つけることができます。
</p>

<p> 二分探索木の探索は「二分探索 (binary search) 」と同じ原理です。左右どちらかの子をたどるたびに、探索するデータ数は半分になります。上図の場合でも、探索するデータ数が 15, 7, 3, 1 となり、最後に見つけることができました。
</p>

<p> データ数を N とすると、単純な線形探索では平均で N / 2 回の比較が必要になりますが、二分探索木を使うと log <SUB>2</SUB> N 程度の回数で収まります。たとえば、データが 100個ある場合、線形探索では 50 回データを比較しなければいけないのに、二分探索木では 7 回程度の比較で済むわけです。ただし、これは左右の部分木のバランスがとれている理想的な状態での話です。バランスが崩れると二分探索木の性能は劣化し、最悪の場合は線形探索と同じになってしまいます。
</p>

<p> そこで、左右のバランスを一定の範囲に収める「平衡木」が考案されています。有名なところでは AVL 木、2-3 木、B 木、B* 木などがあります。また、Ｃ++の標準ライブラリである STL (Standard Template Library) では、「2 色木（赤黒木）」というアルゴリズムが使われているそうです。今回は OCaml の勉強ということで、単純な二分探索木をプログラムすることにします。なお、本稿では二分探索木のことを単に「二分木」と書くことにします。
</p>

<h4 id="next">●二分木の実装</h4>
<p> それでは、OCaml で二分木を作ってみましょう。まずはモジュールを使わずにプログラムします。最初に type で二分木を定義します。
</p>

<pre class="list">
リスト 1 : 二分木の定義

type 'a tree = Nil | Node of 'a * 'a tree * 'a tree
</pre>
</pre>

<p> 二分木のデータ型は 'a tree とし、節は組で表します。もちろん、レコードを使ってもかまいません。Nil が空の木を表し、Node が節を表します。組の第 1 要素が二分木に格納するデータ、第 2 要素が左部分木、第 3 要素が右部分木を表します。簡単な例を示します。
</p>
<pre class="fig">
    12      
  ／  ＼    ==&gt; Node(12, Node(11, Nil, Nil), Node(13, Nil, Nil))
11      13  
</pre>
<p> これを図で表すと次のようになります。
</p>
<pre class="fig">
          ┌─┬─┬─┐
          │12│・│・│
          └─┴┼┴┼┘
                │  │
  ┌──────┘  └─┐
  ↓                    ↓
┌─┬─┬─┐        ┌─┬─┬─┐
│11│／│／│        │13│／│／│
└─┴─┴─┘        └─┴─┴─┘

     ┌─┬─┬─┐
 節：│Ｄ│Ｌ│Ｒ│
     └─┴─┴─┘
 Ｄ：data, Ｌ：left, Ｒ：right, ／：Nil

        図 3 : 二分木の構造
</pre>
<h4>●データの探索</h4>
<p> それでは、データを探索する関数から作ってみましょう。この処理はデータを比較して左右の部分木をたどっていくだけです。
</p>

<pre class="list">
リスト 2 : データの探索

let rec search x = function
  Nil -&gt; false
| Node (y, _, _) when x = y -&gt; true
| Node (y, left, _) when x &lt; y -&gt; search x left
| Node (_, _, right) -&gt; search x right
</pre>

<p> 関数 search の第 1 引数 x が探索するデータ、第 2 引数が二分木です。二分木が Nil であれば、これ以上探索することはできません。データは見つからなかったので false を返します。そうでなければ、引数 x と節のデータを比較します。節のデータはパターンマッチングで取り出すことができます。y がデータ、left が左部分木、right が右部分木です。x = y ならばデータが見つかったので true を返します。x &lt; y ならば search を再帰呼び出しして左部分木をたどります。そうでなければ x &gt; y なので右部分木をたどります。
</p>

<h4>●データの挿入</h4>
<p> 次は、データを挿入する関数を作りましょう。探索と同様に、データを比較して木をたどっていき、木がなくなった所に新しいデータを挿入します。
</p>

<pre class="list">
リスト 3 : データの挿入

let rec insert x = function
  Nil -&gt; Node (x, Nil, Nil)
| (Node (y, _, _)) as node when x = y -&gt; node
| Node (y, left, right) when x &lt; y -&gt; Node (y, (insert x left), right)
| Node (y, left, right) -&gt; Node (y, left, (insert x right))
</pre>

<p> 関数 insert の第 1 引数 x が挿入するデータ、第 2 引数が二分木です。二分木が Nil であれば、新しい節を作って返します。この返り値を節の部分木にセットします。2 番目の節で、x と y が等しい場合は二分木に同じデータがあるので節をそのまま返します。
</p>
<p> x &lt; y であれば、insert を再帰呼び出しして左部分木をたどります。そして、左部分木を insert x left の返り値に置き換えた節を作って返します。もしも、left が Nil であれば、ここに新しい節が挿入され、新しい部分木が返されます。x &gt; y であれば右部分木をたどり、データを挿入した新しい右部分木を返します。
</p>

<h4>●データの削除</h4>
<p> 次はデータを削除する処理を作りましょう。これは今までと違って少々面倒です。削除するデータが「葉」の場合は、それを削除するだけなので簡単ですが、木の途中のデータを削除する場合は、二分木の構成を崩さないように注意しないといけません。最初に、葉を削除する場合を説明します。下図を見てください。
</p>
<pre class="fig">
          14                            14
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          16
  ／  ＼      ／  ＼            ／  ＼      ／  ＼
11      13  15      17        11      13  Nil     17
                                          ↑
    15 を削除する                        削除

             図 4 : データの削除（葉の場合）
</pre>
<p> 15 を削除する場合を考えてみましょう。15 は「葉」にあたるので、それを削除するだけで大丈夫です。
</p>
<p> 次に、子が一つある場合を考えてみましょう。
</p>
<pre class="fig">
          14                            14
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          15
  ／  ＼      ／                ／  ＼
11      13  15                11      13

    16 を削除する

          図 5 : データの削除（子が一つの場合）
</pre>
<p> 16 を削除する場合、その子である 15 と置き換えれば二分木の構成は保たれます。これも簡単ですね。問題は、子が二つある節を削除する場合です。
</p>
<pre class="fig">
          14                            15  &lt;- 最小値と置き換え
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          16
  ／  ＼      ／  ＼            ／  ＼      ／  ＼
11      13  15      17        11      13  Nil     17
                                          ↑
    14 を削除する                        削除

          図 6 : データの削除（子が二つの場合）
</pre>
<p> この場合、削除するデータの右部分木の中から最小値のデータ <sup><a href="ocaml11.html#note1">[*1]</a></sup> を探し、それと削除するデータと置き換えれば「右部分木 &lt; 節 &lt; 左部分木」の構成を崩さなくてすみます。たとえば、上図で 14 を削除することを考えてみましょう。右部分木の中で 15 が最小値なので、それと 14 を置き換えます。そして、15 を格納していた節は削除します。節が最小値を格納している場合、その節の左側の子は存在しないので、その節を削除することは簡単です。
</p>

<p> まずは木の中から最小値を探す関数と、最小値の節を削除する関数を作成しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト 4 : 最小値の探索と削除

(* 最小値を求める *)
let rec search_min = function
  Nil -&gt; raise (Failure "search_min")
| Node (x, Nil, _) -&gt; x
| Node (_, left, _) -&gt; search_min left

(* 最小値を削除する *)
let rec delete_min = function
  Nil -&gt; raise (Failure "delete_min")
| Node (x, Nil, right) -&gt; right
| Node (x, left, right) -&gt; Node (x, (delete_min left), right)
</pre>
<p> 二分木の場合、最小値は簡単に求めることができます。左側の子を順番にたどっていき、左側の子がない節に行き着いたとき、その節のデータが最小値になります。関数 search_min は最小値を求めてそれを返します。
</p>
<p> 最初の節はエラーチェックです。引数が空の木であれば例外を送出します。次に、左側の子の値をチェックします。もし、Nil であれば左側の子がないので、その節のデータが最小値です。格納されているデータ x を返します。そうでなければ、search_min を再帰呼び出しして左側の子をたどります。
</p>

<p> 関数 delete_min は最小値を格納している節を削除します。左側の子が Nil の節を探すのは search_min と同じです。見つけたら、もう一つの子 right を返します。そうでなければ、delete_min を再帰呼び出しして、その左部分木の中から最小値を探し出して削除します。そして、その返り値を格納した新しい節を返します。これで、最小値を持つ節が削除されます。葉の場合であれば right は Nil なので、単純に削除されることになります。
</p>

<p> それでは、データを削除する関数 delete を作ります。まず削除するデータを探索して、見つけたら子の有無に合わせた削除処理を行います。
</p>

<pre class="list">
リスト 5 : データの削除

let rec delete x = function
  Nil -&gt; raise Not_found
| Node(y, left, right) -&gt;
    if x = y then
      if left = Nil then right
      else if right = Nil then left
      else
        let min_data = search_min right in
        Node (min_data, left, (delete_min right))
    else if x &lt; y then
      Node (y, (delete x left), right)
    else
      Node (y, left, (delete x right))
</pre>
<p> まず、節が Nil ならばデータが見つからなかったので例外 Not_found を送出します。次に、削除するデータ x と節のデータ y を比較します。等しい場合はその節を削除します。left が Nil の場合は right を返し、right が Nil の場合は left を返します。
</p>
<p> 子が 2 つある場合は、右部分木の最小値を関数 search_min で求め、その値を格納した新しい節を作ります。このとき、関数 delete_min で最小値を格納していた節を削除します。これで、削除するデータを最小値で置き換えることができます。
</p>
<p> x と節のデータ y が等しくない場合は、左右の部分木をたどって削除するデータを探索します。この処理は今までと同じで、delete の返り値を格納した新しい節を返します。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 逆に、左部分木の中から最大値を探し、それと削除するデータを置き換えてもかまいません。
</div>
<h4>●二分木の巡回</h4>
<p> 最後に、二分木の全データにアクセスする関数を作りましょう。二分木はデータの大小関係を使って構成されているので、ある順番で節をすべて出力すると、それはソートした結果と同じになります。「木」のすべての節を規則的な順序で回ることを「巡回 (traverse) 」といいいます。このなかで、次の 3 つの方法が重要です。
</p>
<ol>
  <LI><b>行きがけ順</b><br>
    まず節のデータを出力、その後左の子、右の子の順番で出力する。
  <LI><b>帰りがけ順</b><br>
    左の子、右の子と出力してから、節のデータを出力する。
  <LI><b>通りがけ順</b><br>
    左の子を出力、次に節のデータを出力、最後に右の子を出力する。
</ol>
<p> 名前の由来は、節のデータを出力するタイミングからきています。節に最初に到達したときに出力する方法が「行きがけ」、子を出力してその節に戻ってきたときに出力する方法が「帰りがけ」、子を出力する途中でその節に戻ってきたときに出力する方法が「通りがけ」です。
</p>

<p> 二分木は「左の子 &lt; 節のデータ &lt; 右の子」という関係が成り立つので、通りがけ順に出力すれば、ソートされた出力結果を得ることができます。この処理は、再帰定義を使えば簡単に実現できます。
</p>

<pre class="list">
リスト 6 : 二分木の巡回

let rec iter f = function
  Nil -&gt; ()
| Node (x, left, right) -&gt; iter f left; f x; iter f right
</pre>

<p> 関数 iter は二分木を通りがけ順に巡回し、格納されているデータに関数 f を適用します。まず、二分木が Nil ならば何もしないで unit を返します。これが再帰呼び出しの停止条件となります。あとは通りがけ順の定義そのままにプログラムをするだけです。左部分木をたどるため、left に対して iter を再帰呼び出しします。次に、節のデータ x に関数 f を適用します。最後に右部分木をたどるため、right に対して iter を再帰呼び出しします。
</p>

<h4>●実行例</h4>
<p> それでは簡単な実行例を示しましょう。
</p>
<pre>
# let a0 = insert 5 Nil;;
val a0 : int tree = Node (5, Nil, Nil)
# let a1 = insert 3 a0;;
val a1 : int tree = Node (5, Node (3, Nil, Nil), Nil)
# let a2 = insert 7 a1;;
val a2 : int tree = Node (5, Node (3, Nil, Nil), Node (7, Nil, Nil))
# search 3 a2;;
- : bool = true
# search 0 a2;;
- : bool = false
# iter (fun x -&gt; print_int x; print_string " ") a2;;
3 5 7 - : unit = ()
# let a3 = delete 5 a2;;
val a3 : int tree = Node (7, Node (3, Nil, Nil), Nil)
</pre>
<p> 正常に動作していますね。
</p>
<h4>●ファンクタの定義</h4>
<p> 二分木はデータの大小関係を比較することで動作します。格納するデータによっては、OCaml の比較演算子ではなく、ほかの方法でデータを比較した方が都合が良い場合もあります。このようなとき、モジュールにデータの型と比較関数を渡すことができると便利です。OCaml の場合、ファンクタを使うとモジュールを引数として受け取り、それを使って新しいモジュールを作成することができます。
</p>

<p> ファンクタは次のように定義します。
</p>
<pre class="item">
module 名前 (moduleA: sigA) = struct ... end
</pre>
<p> ファンクタは引数に与えられたモジュール moduleA を使って新しいモジュールを生成します。moduleA は関数定義の引数 (仮引数) と同じと考えてください。ファンクタは moduleA.func や moduleA.value のように、moduleA に定義されている関数や変数を使ってモジュールを定義します。そして、moduleA の型をシグネチャ sigA で指定します。逆にいえば、ファンクタで必要になる関数や変数の仕様を sigA に記述するのです。ファンクタに与えるモジュールは、このシグネチャの仕様を満たす必要があります。
</p>

<p> ちなみに、ファンクタの定義は次の式と同じです。
</p>
<pre class="item">
module 名前 = functor (引数: 型) -&gt; struct ... end
</pre>
<p> functor は匿名関数の fun と似ているようにみえますが大きな違いがあります。functor はモジュールを受け付けるところでないと使用できません。モジュールは一般のデータ型と同じように扱うことはできないのです。ご注意くださいませ。
</p>

<h4>●シグネチャの定義</h4>
<p> 二分木の場合、格納するデータの型と比較関数が必要になります。これをモジュールに定義してファンクタに渡すことにします。シグネチャの定義は次のようになります。
</p>

<pre class="list">
リスト 7 : シグネチャの定義

module type ItemType = sig
  type t
  val compare : t -&gt; t -&gt; int
end
</pre>

<p> シグネチャの名前は ItemType としました。データの比較関数を定義するシグネチャなので、OCaml のモジュール Map では OrderedType としています。最初に type で t というデータ型を宣言します。このデータ型を使ってシグネチャを記述します。具体的なデータ型の指定はモジュールで行います。
</p>
<p> データを比較する関数が compare です。関数型は t -&gt; t -&gt; int とします。compare x y は x &lt; y だと負の整数を返し、x = y だと 0 を返し、x &gt; y だと正の整数を返すものとします。なお、OCaml には同様の関数 compare が定義されています。
</p>
<pre>
# compare;;
val compare : 'a -&gt; 'a -&gt; int = &lt;fun&gt;
</pre>
<h4>●プログラムの作成</h4>
<p> このシグネチャを使ってファンクタを定義します。プログラムは次のようになります。
</p>

<pre class="list">
リスト 8 : ファンクタの定義

module MakeTree(Item: ItemType) = struct
  (* 節の定義 *)
  type tree = Nil | Node of Item.t * tree * tree

  (* 空の木 *)
  let create = Nil

  (* データの探索 *)
  let rec search x = function
    Nil -&gt; None
  | Node (y, _, _) when Item.compare x y = 0 -&gt; Some y
  | Node (y, left, _) when Item.compare x y &lt; 0 -&gt; search x left
  | Node (_, _, right) -&gt; search x right

  (* データの挿入 *)
  let rec insert x = function
    Nil -&gt; Node (x, Nil, Nil)
  | (Node (y, _, _)) as node when Item.compare x y = 0 -&gt; node
  | Node (y, left, right) when Item.compare x y &lt; 0 -&gt; Node (y, (insert x left), right)
  | Node (y, left, right) -&gt; Node (y, left, (insert x right))

  (* 最小値を求める *)
  let rec search_min = function
    Nil -&gt; raise (Failure "search_min")
  | Node (x, Nil, _) -&gt; x
  | Node (_, left, _) -&gt; search_min left

  (* 最小値を削除する *)
  let rec delete_min = function
    Nil -&gt; raise (Failure "delete_min")
  | Node (x, Nil, right) -&gt; right
  | Node (x, left, right) -&gt; Node (x, (delete_min left), right)

  (* 削除 *)
  let rec delete x = function
    Nil -&gt; raise Not_found
  | Node(y, left, right) -&gt;
      if Item.compare x y = 0 then
        if left = Nil then right
        else if right = Nil then left
        else
          let min_data = search_min right in
          Node (min_data, left, (delete_min right))
      else if Item.compare x y &lt; 0 then
        Node (y, (delete x left), right)
      else
        Node (y, left, (delete x right))

  (* 巡回 *)
  let rec iter f = function
    Nil -&gt; ()
  | Node (x, left, right) -&gt; iter f left; f x; iter f right
end
</pre>

<p> ファンクタの名前は MakeTree としました。引数のモジュールを Item とし、シグネチャを ItemType とします。ファンクタで指定するモジュール名は関数定義の仮引数と同じなので、あらかじめ Item というストラクチャを定義しておく必要はありません。モジュールで定義されているデータ型は Item.t で、比較関数は Item.compare で参照することができます。
</p>

<p> 二分木の型は、格納するデータ型が Item.t で渡されるので型変数を使わずに tree とします。そして、型式は Nil | Node of Item.t * tree * tree となります。これで Item.t を格納する二分木となります。それから、関数 search は見つけたデータを option 型に入れて返すことにします。あとは、データを比較する処理で、Item.compare を呼び出すように修正するだけです。
</p>
<p> ファンクタを定義すると、次に示すシグネチャが出力されます。
</p>
<pre>
module MakeTree :
  functor (Item : ItemType) -&gt;
    sig
      type tree = Nil | Node of Item.t * tree * tree
      val create : tree
      val search : Item.t -&gt; tree -&gt; Item.t option
      val insert : Item.t -&gt; tree -&gt; tree
      val search_min : tree -&gt; Item.t
      val delete_min : tree -&gt; tree
      val delete : Item.t -&gt; tree -&gt; tree
      val iter : (Item.t -&gt; 'a) -&gt; tree -&gt; unit
    end
</pre>
<p> ファンクタの型は functor (引数: 型) -&gt; sig ... end で表されます。ファンクタの引数 Item を参照して、シグネチャが定義されていることがわかります。
</p>

<h4>●実行例</h4>
<p> それでは整数を格納する二分木 IntTree をファンクタ MakeTree で生成してみましょう。
</p>
<pre>
# module IntTree = MakeTree(struct type t = int let compare x y = x - y end);;
module IntTree :
  sig
    type tree = Nil | Node of int * tree * tree
    val create : tree
    val search : int -&gt; tree -&gt; int option
    val insert : int -&gt; tree -&gt; tree
    val search_min : tree -&gt; int
    val delete_min : tree -&gt; tree
    val delete : int -&gt; tree -&gt; tree
    val iter : (int -&gt; 'a) -&gt; tree -&gt; unit
  end
</pre>
<p> ファンクタ MakeTree には名前のないモジュールを渡しています。この中で type t を int とし、比較関数 compare を定義しています。IntTree のシグネチャを見ると、格納するデータ型が int になっていることがわかります。このように、データ型と比較関数をファンクタに渡せば、そのデータ型に対応する二分木を作ることができます。
</p>

<p> それでは実際に試してみましょう。
</p>
<pre>
# open IntTree;;
# let a0 = create;;
val a0 : IntTree.tree = Nil
# let a1 = insert 5 a0;;
val a1 : IntTree.tree = Node (5, Nil, Nil)
# let a2 = insert 3 a1;;
val a2 : IntTree.tree = Node (5, Node (3. Nil, Nil), Nil)
# let a3 = insert 7 a2;;
val a3 : IntTree.tree = Node (5, Node (3. Nil, Nil), Node (7, Nil, Nil))
# search 3 a3;;
- : int option = Some 3
# search 8 a3;;
- : int option = None
# iter (fun x -&gt; print_int x; print_string " ") a3;;
3 5 7 - : unit = ()
</pre>
<p> 正常に動作していますね。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml10.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml12.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>