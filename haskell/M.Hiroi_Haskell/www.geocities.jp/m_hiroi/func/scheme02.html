<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Scheme Junk Scripts</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scheme Programming</h1>
<h2>Scheme Junk Scripts</h2>
<div class="small">
[ <a href="scheme01.html">PrevPage</a> | <a href="scheme.html#junk">Scheme</a> | <a href="scheme03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="stack_queue">スタックとキュー</h3>
<p> リストとクロージャを使ったスタック (stack) とキュー (queue) の実装です。
</p>
<p> 最初にスタックについて簡単に説明します。スタックの例として、バネ付きのトレイを取り上げます。
</p>
<pre class="fig">
    |-----|     |[ A ]|     |[ B ]|     |[ A ]|     |-----| 
    |  |  |     |-----|     |[ A ]|     |-----|     |  |  |
    |  |  |     |  |  |     |-----|     |  |  |     |  |  |
    |  |  |     |  |  |     |  |  |     |  |  |     |  |  |
    |  |  |     |  |  |     |  |  |     |  |  |     |  |  |
    +-----+     +-----+     +-----+     +-----+     +-----+  
 (1) 空の状態  (2) PUSH    (3) PUSH    (4) POP     (5) POP
                   A           B           B           A

                     図 : スタックの動作例
</pre>
<p> 初めはトレイが入っていない空の状態です。ここにトレイを上から入れると、重さによってバネを圧縮し、次のトレイを追加できるようになります。もうひとつトレイを乗せると、さらにバネを圧縮し次のトレイを追加できるようになります。バネが限界まで圧縮されると、トレイは追加できません。トレイを取り出す場合は、上にあるトレイから取り出していきます。ひとつ取り出すと、その分バネが伸びて下にあるトレイが上に出てくるので、次のトレイを取り出すことができます。
</p>
<p> このトレイをデータと考えてください。データ A をスタックに追加し(2)、次にデータ B を追加します(3)。データを取り出す場合、後から入れたデータ B が先に取り出され(4)、その次にデータ A が取り出されて、スタックが空になります(5)。このように、スタックは後から入れたデータが先に取り出されるので、<b>後入れ先出し (Last-In First-Out : LIFO)</b> と呼ばれます。スタックにデータを追加する操作を<b>プッシュ (PUSH)</b> といい、スタックからデータを取り出す操作を<b>ポップ (POP)</b> というます。スタックはリストを使うと簡単に実現することができます。
</p>
<p> 次はキューについて簡単に説明します。
</p>
<p> キューは<b>待ち行列</b>といわれるデータ構造です。たとえば、チケットを買う場合窓口に長い列ができますが、それと同じだと考えてください。チケットを買うときは、列の途中に割り込むことはできませんね。いちばん後ろに並んで順番を待たなければいけません。列の先頭まで進むと、チケットを購入することができます。
</p>
<p> このように、要素を取り出す場合は列の先頭から行い、要素を追加する場合は列の後ろに行うデータ構造がキューなのです。キューは<b>先入れ先出し (FIFO : first-in, first-out)</b> とも呼ばれます。
</p>
<pre class="fig">

  先頭                      最後尾
    ---------------------------
 &lt;=  a  b  c  d  e  .  .  .  z  &lt;= 
    ---------------------------

            先頭                        最後尾
 変数      ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 front ─→│ａ│・┼─→│ｂ│・┼─→│ｃ│／│  
           └─┴─┘    └─┴─┘    └─┴─┘
                                         ↑
 rear  ─────────────────┘

          図 : キューの構造
</pre>
<p> キューにデータを入れることを <b>enqueue</b> といい、キューからデータを取り出すことを <b>dequeue</b> といいます。リストを使ってキューを実装する場合、上図のようにキューの先頭とリストの先頭を対応させます。すると、キューからデータを取り出すには、リストの先頭からデータを取り出すだけですみます。これはとても簡単ですね。ただし、キューにデータを入れるには、リストの最後尾にデータを追加することになるため、ちょっとした工夫が必要になります。
</p>
<p> そこで、最後尾のセルを格納する変数を用意することにします。上図に示すように、リストを保持する変数 front のほかに、最後尾のセルを格納する変数 rear を用意します。プログラムでは、変数 front と rear を一つのコンスセルで表しています。
</p>

<h4>●プログラム</h4>
<pre class="list">
;
; スタック
;
(define (make-stack)
  (let ((front '()))
    (lambda (msg . args)
      (cond ((eq? msg 'push!)
             (set! front (cons (car args) front))
             (car args))
            ((eq? msg 'pop!)
             (if (null? front)
                 #f
                 (let ((data (car front)))
                   (set! front (cdr front))
                   data)))
            ((eq? msg 'empty?) (null? front))
            (else #f)))))

;
; キュー
;
(define (make-queue)
  (let ((head (cons '() '())))
    (lambda (msg . args)
      (cond ((eq? msg 'enqueue!)
             (let ((new-pair (list (car args))))
               (if (null? (car head))
                   (set-car! head new-pair)
                   (set-cdr! (cdr head) new-pair))
               (set-cdr! head new-pair))
               (car args))
            ((eq? msg 'dequeue!)
             (if (null? (car head))
                 #f
                 (let ((front (car head)))
                   (set-car! head (cdr front))
                   (car front))))
            ((eq? msg 'empty?) (null? (car head)))
            (else #f)))))


; テスト
; gauche には dotimes, dolist が用意されている
(define s (make-stack))
(dotimes (x 10)
  (format #t "~D " (s 'push! x)))
(newline)
(while (not (s 'empty?))
  (format #t "~D " (s 'pop!)))
(newline)

(define q (make-queue))
(dotimes (x 10)
  (format #t "~D " (q 'enqueue! x)))
(newline)
(while (not (q 'empty?))
  (format #t "~D " (q 'dequeue!)))
(newline)
</pre>
<h4>●実行例</h4>
<pre>
0 1 2 3 4 5 6 7 8 9 
9 8 7 6 5 4 3 2 1 0 
0 1 2 3 4 5 6 7 8 9 
0 1 2 3 4 5 6 7 8 9 
</pre>
<hr>
<h3 id="circular">循環リスト</h3>
<p> リストは要素を一列に並べたデータ構造ですが、最後尾のセルと先頭のセルを連結することで要素をリング状に並べることができます。これを<b>循環リスト (circular list)</b> といいます。次の図を見てください。
</p>
<pre class="fig">
                  CDR 部を直接 CELL A に書き換える
                                └──────┐
             CELL A                           ↓
            ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
  変数ｚ─→│・│・┼─→│・│・┼─→│・│／│  
            └┼┴─┘    └┼┴─┘    └┼┴─┘
              ↓            ↓            ↓
              ａ            ｂ            ｃ

              ┌───────────────┐
              ↓                              │
            ┌─┬─┐    ┌─┬─┐    ┌─┬┼┐
  変数ｚ─→│・│・┼─→│・│・┼─→│・│・│  
            └┼┴─┘    └┼┴─┘    └┼┴─┘
              ↓            ↓            ↓
              ａ            ｂ            ｃ

                       図 : 循環リスト
</pre>
<p> リスト (a b c) は '() で終端されています。このリストで、最後尾のセルの CDR 部を先頭のセル A に書き換えると、循環リストを作ることができます。循環リストは環状に並んだデータを表すのに便利なデータ構造です。
</p>
<h4>●プログラム</h4>
<pre class="list">
;
; 循環リストのチェック
;
(define (circular-list? ls)
  (let loop ((xs ls) (ys ls))
    (if (and (pair? xs) (pair? (cdr xs)))
        (if (eq? (cddr xs) (cdr ys))
            #t
            (loop (cddr xs) (cdr ys)))
        #f)))

;
; 循環リストによるキューの実装
;
(define (make-queue)
  (let ((rear '()))
    (lambda (msg . args)
      (cond ((eq? msg 'enqueue!)
             (cond ((null? rear)
                    (set! rear (list (car args)))
                    (set-cdr! rear rear))
                   (else
                    (let ((temp (cons (car args) (cdr rear))))
                      (set-cdr! rear temp)
                      (set! rear temp))))
             (car args))
            ((eq? msg 'dequeue!)
             (if (null? rear)
                 #f
                 (let ((front (cdr rear)))
                   (if (eq? front rear)
                       (set! rear '())
                       (set-cdr! rear (cdr front)))
                   (car front))))
            ((eq? msg 'empty?) (null? rear))
            (else #f)))))

; 循環リストのテスト
(define a '(a b c))
(set-cdr! (cddr a) a)
(let loop ((n 0) (ls a))
  (when (&lt; n 6)
    (display (car ls))
    (newline)
    (loop (+ n 1) (cdr ls))))

(display (circular-list? a))
(newline)
(display (circular-list? '(1 2 3 4 5)))
(newline)
(display (circular-list? '(1)))
(newline)
(display (circular-list? '(1 . 2)))
(newline)

(define q (make-queue))
(dotimes (x 10)
  (format #t "~D " (q 'enqueue! x)))
(newline)
(while (not (q 'empty?))
  (format #t "~D " (q 'dequeue!)))
(newline)
</pre>
<h4>●実行例</h4>
<pre>
a
b
c
a
b
c
#t
#f
#f
#f
0 1 2 3 4 5 6 7 8 9 
0 1 2 3 4 5 6 7 8 9 
</pre>
<hr>
<h3 id="binarytree">二分木</h3>
<p> 「木構造 (tree structer) 」は「木 (tree) 」とも呼ばれるデータ構造で、節 (ノード) と呼ばれる要素に対して、階層的な関係を表したものです。身近な例では、ディレクトリの階層構造が木にあたります。ディレクトリに「ルートディレクトリ」があるように、木にも「根 (ルート) 」と呼ばれる節が存在します。
</p>
<pre class="fig">
          (root)
            Ａ    ────────  レベル０
          ／｜＼                ↑
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ            木  レベル１
    ／｜＼        ｜＼          の
  ／  ｜  ＼      ｜  ＼        高
Ｅ    Ｆ    Ｇ    Ｈ    Ｉ      さ  レベル２
          ／  ＼
        ／      ＼              ↓
      Ｊ          Ｋ    ─────  レベル３


        図 : 一般的な木構造の一例
</pre>
<p> 木を図示する場合、階層関係がはっきりわかるように、根を上にして、同じ階層にある節を並べて書きます。根からレベル 0、レベル 1 と階層を数えていき、最下層の節までの階層数を「木の高さ」といいます。木は、ある節から下の部分を切り出したものも、木としての性質を持っています。これを「部分木」といいます。
</p>

<p> 木は、ある節からほかの節に至る「経路」を考えることができます。たとえば、A から J には、A - B - G - J という経路がありますね。これは、ディレクトリやファイルを指定するときのパスと同じです。
</p>

<p> ある節から根の方向にさかのぼるとき、途中で通っていく節を「先祖」といい、直接繋がっている節を「親」といます。これは、逆から見ると「子孫」と「子」という関係になります。子を持たない節をとくに「葉」と呼ぶことがあります。上図でいうと、G は J, K の親で、J は G の子になります。J は子を持っていないので葉となります。
</p>

<p> 子は、「左 &lt; 右」の順番で節に格納するのが一般的です。これを「順序木」といいます。また、順番がない木を「無順序木」と呼びます。節が持っている子の数を「次数」といいます。上図の場合、A は 3 つの子 B, C, D を持っているので、A の次数は 3 となります。すべての節の次数を n に揃えた順序木を「 n 分木」と呼びます。とくに、次数が 2 の二分木は、プログラムでよく使われるデータ構造です。
</p>
<pre class="fig">
                    (root)
                      18
                    ／  ＼
                  ／      ＼
                ／          ＼
              ／              ＼
            ／                  ＼
          14                      22
        ／  ＼                  ／  ＼
      ／      ＼              ／      ＼
    12          16          20          24
  ／  ＼      ／  ＼      ／  ＼      ／  ＼
11      13  15      17  19      21  23      25


             図 : 二分木の一例
</pre>
<p> 上図に二分木の例を示します。二分木では、節にひとつのデータを格納します。そして、その節の左側の子には小さいデータを、右側の子には大きいデータが配置されるように木を構成します。
</p>

<p> この二分木をデータの探索に使うアルゴリズムが「二分探索木」です。二分探索木はデータの探索・挿入を高速に行うことができます。たとえば、上図の木から 19 を探してみましょう。まず root の 18 と比較します。18 &lt; 19 ですから、右側の子をたどり 22 と比較します。今度は 19 &lt; 22 なので左側の子をたどります。次は 20 と比較し 19 &lt; 20 なので左側の子をたどり、ここで 19 を見つけることができます。
</p>

<p> 二分探索木の探索は二分探索と同じ原理です。左右どちらかの子をたどるたびに、探索するデータ数は半分になります。上図の場合でも、探索するデータ数が 15, 7, 3, 1 となり、最後に見つけることができました。
</p>

<p> データ数を N とすると、単純な線形探索では平均で N / 2 回の比較が必要になりますが、二分探索木を使うと log <sub>2</sub> N 程度の回数で収まります。たとえば、データが 100個ある場合、線形探索では 50 回データを比較しなければいけないのに、二分探索木では 7 回程度の比較で済むわけです。
</p>

<p> ただし、これは左右の部分木のバランスがとれている理想的な状態での話です。バランスが崩れると二分探索木の性能は劣化し、最悪の場合は線形探索と同じになってしまいます。そこで、左右のバランスを一定の範囲に収める「平衡木」が考案されています。有名なところでは AVL 木、2 色木 (赤黒木)、2-3 木、B 木、B* 木などがあります。
</p>

<h4>●参考文献</h4>
<ol>
  <li>A.V. Aho, J.E. Hopcroft, J.D. Ullman, 『データ構造とアルゴリズム』, 培風館, 1987
  <li>近藤嘉雪, 『Ｃプログラマのためのアルゴリズムとデータ構造』, ソフトバンク, 1998 
</ol>
<h4>●プログラム１</h4>
<pre class="list">
;
; bintree.scm : 二分木（その１）
;
;               Copyright (C) 2006 Makoto Hiroi
;
; 節はリスト (data left right) で表す
;
(define (make-tree obj=? obj&lt;?)
  (let ((root '()))
    ; アクセサ
    (define (data-of node) (car node))
    (define (left-of node) (cadr node))
    (define (right-of node) (caddr node))
    (define (set-data! node x) (set-car! node x))
    (define (set-left! node x) (set-car! (cdr node) x))
    (define (set-right! node x) (set-car! (cddr node) x))
    
    ; 挿入
    (define (insert! node data)
      (cond ((null? node) (list data '() '()))
            ((obj=? data (data-of node)) node)
            ((obj&lt;? data (data-of node))
             (set-left! node (insert! (left-of node) data))
             node)
            (else
             (set-right! node (insert! (right-of node) data))
             node)))
    ; 探索
    (define (search node data)
      (cond ((null? node) #f)
            ((obj=? data (data-of node)) (data-of node))
            ((obj&lt;? data (data-of node))
             (search (left-of node) data))
            (else
             (search (right-of node) data))))

    ; 最小値を求める
    (define (search-min node)
      (if (null? (left-of node))
          (data-of node)
          (search-min (left-of node))))
    ; 最小値を削除
    (define (delete-min node)
      (cond ((null? (left-of node)) (right-of node))
            (else
             (set-left! node (delete-min (left-of node)))
             node)))
    ; 削除
    (define (delete! node data)
      (if (pair? node)
        (cond ((obj=? data (data-of node))
               (cond ((null? (left-of node)) (right-of node))
                     ((null? (right-of node)) (left-of node))
                     (else
                      ; 最小値に書き換える
                      (set-data! node (search-min (right-of node)))
                      ; 最小値の節を削除
                      (set-right! node (delete-min (right-of node)))
                      node)))
              ((obj&lt;? data (data-of node))
               (set-left! node (delete! (left-of node) data))
               node)
              (else
               (set-right! node (delete! (right-of node) data))
               node))
        node))
    
    ; 巡回
    (define (traverse node func)
      (unless (null? node)
        (traverse (left-of node) func)
        (func (data-of node))
        (traverse (right-of node) func)))
    
    ; foldl
    (define (foldl func g node)
      (if (null? node)
          g
          (foldl func 
                 (func (data-of node)
                       (foldl func g (left-of node)))
                 (right-of node))))
    
    ; foldr
    (define (foldr func g node)
      (if (null? node)
          g
          (foldr func 
                 (func (data-of node)
                       (foldr func g (right-of node)))
                 (left-of node))))
    
    (lambda (msg . args)
      (cond ((eq? msg 'insert!)
             (set! root (insert! root (car args)))
             (car args))
            ((eq? msg 'search)
             (search root (car args)))
            ((eq? msg 'delete!)
             (set! root (delete! root (car args))))
            ((eq? msg 'for-each)
             (traverse root (car args)))
            ((eq? msg 'foldl)
             (foldl (car args) (cadr args) root))
            ((eq? msg 'foldr)
             (foldr (car args) (cadr args) root))
            (else #f)))))

; テスト
(define a (make-tree = &lt;))
(dolist (x '(5 6 4 7 3 8 2 9 1))
  (format #t "~A " (a 'search x))
  (a 'insert! x)
  (format #t "~A " (a 'search x)))
(newline)
(a 'for-each (lambda (x) (format #t "~D " x)))
(newline)
(display (a 'foldl + 0))
(newline)
(display (a 'foldr + 0))
(newline)
(display (a 'foldl cons '()))
(newline)
(display (a 'foldr cons '()))
(newline)
(display (a 'foldl (lambda (x y) (+ y 1)) 0))
(newline)
(display (a 'foldr (lambda (x y) (+ y 1)) 0))
(newline)
(dolist (x '(5 6 4 7 3 8 2 9 1))
  (a 'delete! x)
  (a 'for-each (lambda (x) (format #t "~D " x)))
  (newline))
</pre>
<h4>●実行例</h4>
<pre>
#f 5 #f 6 #f 4 #f 7 #f 3 #f 8 #f 2 #f 9 #f 1 
1 2 3 4 5 6 7 8 9 
45
45
(9 8 7 6 5 4 3 2 1)
(1 2 3 4 5 6 7 8 9)
9
9
1 2 3 4 6 7 8 9 
1 2 3 4 7 8 9 
1 2 3 7 8 9 
1 2 3 8 9 
1 2 8 9 
1 2 9 
1 9 
1 
</pre>
<h4>●プログラム２</h4>
<pre class="list">
;
; bintree.scm : 二分木 (その２)
;
;               Copyright (C) 2006 Makoto Hiroi
;

; 終端を表すシンボル
(define nil (gensym "nil"))

; 比較関数
(define-method obj&lt;? ((x &lt;number&gt;) (y &lt;number&gt;)) (&lt; x y))
(define-method obj=? ((x &lt;number&gt;) (y &lt;number&gt;)) (= x y))

; 節の定義
(define-class &lt;node&gt; ()
  ((data  :init-keyword :data  :accessor data-of)
   (left  :init-keyword :left  :init-value nil :accessor left-of)
   (right :init-keyword :right :init-value nil :accessor right-of)))

; データの挿入
(define (insert-node! node data)
  (cond ((eq? node nil) (make &lt;node&gt; :data data))
        ((obj=? data (data-of node)) node)
        ((obj&lt;? data (data-of node))
         (set! (left-of node) (insert-node! (left-of node) data))
         node)
        (else
         (set! (right-of node) (insert-node! (right-of node) data))
         node)))

; データの探索
(define (search-node node data)
  (cond ((eq? node nil) #f)
        ((obj=? data (data-of node)) (data-of node))
        ((obj&lt;? data (data-of node))
         (search-node (left-of node) data))
        (else
         (search-node (right-of node) data))))

; 最小値を求める
(define (search-node-min node)
  (if (eq? (left-of node) nil)
      (data-of node)
      (search-node-min (left-of node))))

; 最小値を削除
(define (delete-node-min node)
  (cond ((eq? (left-of node) nil) (right-of node))
        (else
         (set! (left-of node) (delete-node-min (left-of node)))
         node)))

; 削除
(define (delete-node! node data)
  (if (not (eq? node nil))
    (cond ((obj=? data (data-of node))
           (cond ((eq? (left-of node) nil) (right-of node))
                 ((eq? (right-of node) nil) (left-of node))
                 (else
                  (set! (data-of node) (search-node-min (right-of node)))
                  (set! (right-of node) (delete-node-min (right-of node)))
                  node)))
          ((obj&lt;? data (data-of node))
           (set! (left-of node) (delete-node! (left-of node) data))
           node)
          (else
           (set! (right-of node) (delete-node! (right-of node) data))
           node))
    node))

; 巡回
(define (traverse-node node func)
  (unless (eq? node nil)
    (traverse-node (left-of node) func)
    (func (data-of node))
    (traverse-node (right-of node) func)))

; foldl
(define (foldl-node func g node)
  (if (eq? node nil)
      g
      (foldl-node func
                  (func (data-of node)
                        (foldl-node func g (left-of node)))
                  (right-of node))))

; foldr
(define (foldr-node func g node)
  (if (eq? node nil)
      g
      (foldr-node func
                  (func (data-of node)
                        (foldr-node func g (right-of node)))
                  (left-of node))))

;
; 二分木の操作
;
(define-class &lt;tree&gt; ()
  ((root :init-keyword :root :accessor root-of :init-value nil)))

(define-method insert! ((tree &lt;tree&gt;) data)
  (set! (root-of tree) 
        (insert-node! (root-of tree) data)))

(define-method search ((tree &lt;tree&gt;) data)
  (search-node (root-of tree) data))

(define-method delete! ((tree &lt;tree&gt;) data)
  (set! (root-of tree) (delete-node! (root-of tree) data)))

(define-method each ((tree &lt;tree&gt;) func)
  (traverse-node (root-of tree) func))

(define-method foldl ((tree &lt;tree&gt;) g func)
  (foldl-node func g (root-of tree)))

(define-method foldr ((tree &lt;tree&gt;) g func)
  (foldr-node func g (root-of tree)))


; test
(define a (make &lt;tree&gt;))
(dolist (x '(5 3 8 1 2 7 9 4 6))
  (display (search a x))
  (newline)
  (insert! a x)
  (each a (lambda (x) (format #t "~D " x)))
  (newline)
  (display (search a x))
  (newline))

(display (foldl a '() cons))
(display (foldr a '() cons))
(newline)
(display (foldl a 0 +))
(newline)
(display (foldr a 0 +))
(newline)

(dolist (x '(6 4 5 3 8 1 2 7 9))
  (delete! a x)
  (each a (lambda (x) (format #t "~D " x)))
  (newline))
</pre>
<h4>●実行例</h4>
<pre>
#f
5 
5
#f
3 5 
3
#f
3 5 8 
8
#f
1 3 5 8 
1
#f
1 2 3 5 8 
2
#f
1 2 3 5 7 8 
7
#f
1 2 3 5 7 8 9 
9
#f
1 2 3 4 5 7 8 9 
4
#f
1 2 3 4 5 6 7 8 9 
6
(9 8 7 6 5 4 3 2 1)(1 2 3 4 5 6 7 8 9)
45
45
1 2 3 4 5 7 8 9 
1 2 3 5 7 8 9 
1 2 3 7 8 9 
1 2 7 8 9 
1 2 7 9 
2 7 9 
7 9 
9 
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scheme01.html">PrevPage</a> | <a href="scheme.html#junk">Scheme</a> | <a href="scheme03.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>