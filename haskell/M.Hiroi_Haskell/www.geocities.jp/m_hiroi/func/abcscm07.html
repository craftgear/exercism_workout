<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881781</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm06.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm08.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Scheme の入出力 (その１)</h3>
<p> 今回は、ファイルからデータを読み込む、またはデータをファイルに書き込むなど、Scheme でデータの入出力を行うの方法について説明します。Scheme の仕様書 R5RS には必要最低限の入出力機能だけしか定義されていないので、Gauche に用意されている便利な機能もあわせて紹介することにしましょう。最初に、最も簡単で基本的な「標準入出力」について説明します。
</p>

<h4>●標準入出力とは？</h4>
<p> 「標準入出力」は難しい話ではありません。実は、いままでに何回も使っているのです。たとえば、display を使ってデータを画面に表示しましたね。これはデータを「標準出力 (standard output) 」へ出力していたのです。また、データの入力には read や read-char を使いました。これは「標準入力 (standard input) 」からデータを受け取っているのです。一般に、標準入力にはキーボードが割り当てられていて、標準出力には画面が割り当てられています。
</p>

<p> 近代的なプログラミング言語の場合、ファイルをアクセスするためには「ストリーム (stream) 」というデータを用います。辞書を引いてみると stream は「流れ」や「小川」という意味です。プログラミング言語の場合は、ファイルとプログラムの間でやりとりされるデータの流れ、という意味で使われているようです。
</p>

<p> Scheme の場合は、「ポート (port) 」というデータ型を介してファイルにアクセスします。ストリームと同様のデータと考えてください。ポートはファイルと 1 対 1 に対応していて、ファイルからデータを入力する場合、ポートを介してデータが渡されます。逆に、ファイルへデータを出力するときも、ポートを介して行われます。
</p>

<p> Scheme 処理系を起動すると自動的に用意されるポートがあります。それが標準入出力に対応するポートです。
</p>
<pre class="fig">
┌────┐                    ┌─────┐
│        │──────────│          │
│ Scheme │→→→→→→→→→→│   画面   │【標準出力】
│        │──────────│          │
│        │                    └─────┘
│        │                    ┌─────┐
│        │──────────│          │
│        │←←←←←←←←←←│キーボード│【標準入力】
│        │──────────│          │
│        │                    └─────┘
│        │                    ┌─────┐
│        │──────────│          │
│        │→→→→→→→→→→│   画面   │【標準エラー出力】
│        │──────────│          │
└────┘      [ポート]      └─────┘

             図 : 標準入出力
</pre>
<p> 上図に示すように、ポートには出力と入力の 2 方向があります。Gauche の場合、起動した直後の標準入力、標準出力、標準エラー出力に対応するポートは次の関数で求めることができます。
</p>
<ul>
  <li>standard-input-port
  <li>standard-output-port
  <li>standard-error-port
</ul>
<p> 標準エラー出力の出力先は標準出力と同じく「画面」ですが、エラーメッセージを出力するときに使います。なぜ、標準エラー出力が必要なのでしょうか。それは、標準出力がファイルへ「リダイレクト」されている場合でも、エラーメッセージを画面へ表示するためです。ここで「リダイレクト」について簡単に説明しましょう。
</p>

<p> シェルには「リダイレクト機能」といって、標準入力や標準出力をほかのファイルへ切り替える機能を持っています。たとえば、DIR コマンドはファイルの一覧を画面へ表示しますが、次のように出力先をファイルへ切り替えることができます。
</p>
<pre>
C&gt;dir &gt; test.dat
</pre>
<p> この場合 test.dat というファイルに結果が格納されます。このときの &gt; が標準出力先を変更する命令です。シェルは標準出力を画面から &gt; の後ろに続くファイルへ切り替えます。
</p>

<p> 逆に、標準入力を切り替える命令が &lt; です。シェルは標準入力をキーボードから &lt; の後ろに続くファイルに切り替えます。キーボードからデータを受け取るように作られたプログラムであれば、リダイレクトによってファイルからの入力に切り替えることができます。
</p>

<p> もしも、標準出力がほかのファイルへリダイレクトされているならば、エラーメッセージを標準出力へ出力しても画面上には表示されないことになります。このような場合でも、標準エラー出力を使えば画面へメッセージを出力することができます。
</p>

<p> それでは、標準入出力ポートの値を見てみましょう。
</p>
<pre>
gosh&gt; (standard-input-port)
#&lt;iport (stdin) XXXXXXXX&gt;
gosh&gt; (standard-output-port)
#&lt;oport (stdout) XXXXXXXX&gt;
gosh&gt; (standard-error-port)
#&lt;oport (stderr) XXXXXXXX&gt;
</pre>

<p> Gauche の場合、入力ポートは #&lt;iport ファイル名 16進整数&gt; と表示され、出力ポートは #&lt;oport ファイル名 16進整数&gt; と表示されます。Gauche はＣ言語で作成されているので、標準入出力のファイル名はＣ言語で標準入出力を表す名前になっているようです。
</p>
<h4>●出力</h4>
<p> 次は、簡単な出力について説明します。今までデータを画面へ出力するのに display を使ってきました。display は画面だけではなく、出力先のポートを指定することができます。指定を省略した場合はデフォルト出力ポートが使用されます。Scheme を起動すると、デフォルト出力ポートには標準出力が割り当てられます。現在のデフォルト出力ポートは、次の関数で求めることができます。
</p>
<ul>
  <li>current-output-port
</ul>
<p> current-output-port は現在のデフォルト出力ポートを返します。出力関数でポートの指定を省略すると、このポートを介してデータの出力が行われます。
</p>
<p> 出力ポートの指定は次のように行います。
</p>
<pre class="fig">
display data oport

(display "Scheme\n" (standard-error-port)) =&gt; 標準エラー出力へ出力する

(display "Scheme\n" (standard-input-port)) =&gt; 入力ストリームはエラー！

                   図  : 出力ポートの指定
</pre>
<p> 出力するデータの後ろに出力ポートを指定します。入力ポートを指定するとエラーになります。データを出力する関数は display のほかに write と write-char があります。
</p>
<ul>
  <li>write obj oport
  <li>write-char char oport
</ul>
<p> display は人間にとって読みやすい形式でデータを出力しますが、write は可能な限り read で読み込める形式でデータを出力します。write-char は文字型データ char を出力します。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (display "abcd\n")
abcd
#&lt;undef&gt;
gosh&gt; (write "abcd\n")
"abcd\n"#&lt;undef&gt;
gosh&gt; (display '(a "a" #\a))
(a a a)#&lt;undef&gt;
gosh&gt; (write '(a "a" #\a))
(a "a" #\a)#&lt;undef&gt;
gosh&gt; (write-char #\a)
a#&lt;undef&gt;
</pre>
<p> display は文字列や文字を表示するときダブルクオートや #\ を表示しませんが、write は文字列を表示するときはダブルクオートで囲み、文字は #\ を付けて表示します。write-char は文字コードをそのまま出力します。
</p>

<h4>●format</h4>
<p> ここで R5RS にはありませんが、Gauche で用意されている便利な関数を紹介しましょう。format はデータを出力する関数ですが、単純に出力するのではなく、表示に関していろいろな指定を行うことができます。ですが、その分だけ使い方が少し複雑になります。もともと format は Common Lisp の関数ですが、そのサブセットとして (または独自の拡張を行って) 定義している Scheme 処理系が多いようです。
</p>
<ul>
  <li>format oport 書式文字列 Ｓ式 ...
  <li>format 書式文字列 Ｓ式 ...
</ul>
<p> format の第 1 引数は出力ポートを指定します。oport に #t が指定された場合はデフォルト出力ポートへ出力されます。#f が指定された場合は、ポートへ出力せずに変換結果を文字列にして返します。出力ポートが省略された場合は #f を指定した場合と同じ動作になります。
</p>
<p> 第 2 引数は書式文字列で、出力に関する指定を行います。これには文字列型データを使います。format は文字列をそのまま出力するのですが、文字列の途中にチルダ  ~ が表れると、その後ろの文字を変換指示子として理解し、引数のデータをその指示に従って表示します。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (format #t "~D ~B ~O ~X~%" 256 256 256 256)
256 100000000 400 100
#&lt;undef&gt;
</pre>
<p> #&lt;undef&gt; は format の返り値です。書式文字列の中には、変換指示子をいくつ書いてもかまいません。チルダの前までは、そのまま文字を表示します。チルダ ~ の次の文字 D, B, O, X が変換指示子です。これらの指示子は整数値を表示する働きをします。上の例が示すように、D は 10 進数、B は 2 進数、O は 8 進数、X は 16 進数で表示します。Gauche の場合、変換指示子は英小文字で書いてもかまいません。
</p>
<p> 変換指示子の数と引数として与えるデータの数が合わないとエラーになるので注意してください。また、~% は改行を表し、チルダを出力したい場合は ~~ と続けて書きます。
</p>
<p> それから、チルダ ~ と変換指示子の間に前置パラメータやコロン ( : ) 修飾子、アットマーク ( @ ) 修飾子を指定することができます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (format #t "[~D]~%" 10)
[10]
#&lt;undef&gt;
gosh&gt; (format #t "[~4D]~%" 10)
[  10]
#&lt;undef&gt;
gosh&gt; (format #t "[~4D]~%" 10000)
[10000]
#&lt;undef&gt;
</pre>
<p> 整数値を表示する変換指示子は、前置パラメータでデータを表示するフィールド幅を指定することができます。最初の例がフィールド幅を指定しない場合で、次の例がフィールド幅を 4 に指定した場合です。10 ではフィールド幅に満たないので、右詰めに出力されます。もしも、フィールド幅に収まらない場合は、最後の例のように指定を無視して数値を出力します。
</p>

<p> 前置パラメータを複数指定する場合はカンマ ( , ) で区切ります。前置パラメータの意味は、変換指示子によって異なるので注意してください。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (format #t "[~4,'0D]~%" 10)
[0010]
#&lt;undef&gt;
gosh&gt; (format #t "[~4,'aD]~%" 10)
[aa10]
#&lt;undef&gt;
</pre>
<p> 整数値を表示する変換指示子の場合、第 1 番目の前置パラメータでフィールド幅を指定します。第 2 番目の前置パラメータに 'a を指定すると、左側の空いたフィールドに文字 a を詰め込みます。クオート ( ' ) は前置パラメータを文字として指定するときに用いられます。最初の例では文字 0 を詰め込み、次の例では文字 a を詰め込みます。
</p>

<p> 前置パラメータに文字 V を指定すると、引数の値が前置パラメータとして用いられます。Gauche は英小文字 v で書いても受け付けます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (format #t "~V,'0D~%" 4 10)
0010
#&lt;undef&gt;
gosh&gt; (format #t "~V,'0D~%" 6 10)
000010
#&lt;undef&gt;
gosh&gt; (format #t "~V,'0D~%" 8 10)
00000010
#&lt;undef&gt;

gosh&gt; (format #t "~V,VD~%" 4 #\a 10)
aa10
#&lt;undef&gt;
gosh&gt; (format #t "~V,VD~%" 6 #\b 10)
bbbb10
#&lt;undef&gt;
gosh&gt; (format #t "~V,VD~%" 8 #\c 10)
cccccc10
#&lt;undef&gt;
</pre>
<p> 前半の例では、フィールド幅の指定に引数の値が用いられます。そして、D 変換指示子により引数 10 が表示されます。後半の例では、詰め込む文字の指定に引数の値が用いられます。この場合、クオートを指定する必要はありません。ここで 'V と指定すると、詰め込む文字が V になってしまいます。
</p>
<p> 整数値を表示する変換指示子の場合、@ 修飾子を指定すると符号 (+/-) が必ず表示されます。: 修飾子を指定すると、3 桁ごとにカンマ ( , ) が表示されます。簡単な例を示します。
</p>
<pre>
gosh&gt; (format #t "~@D~%" 10)
+10
#&lt;undef&gt;
gosh&gt; (format #t "~:D~%" 100000000)
100,000,000
#&lt;undef&gt;
gosh&gt; (format #t "~,,' :D~%" 100000000)
100 000 000
#&lt;undef&gt;
#&lt;undef&gt; (format #t "~,,,4:D" 100000000)
1,0000,0000
#&lt;undef&gt;
</pre>
<p>: 修飾子を使う場合、第 3 番目の前置パラメータで表示する区切り文字を指定することができます。また、区切る桁数は第 4 番目の前置パラメータで指定することができます。@ 修飾子と : 修飾子は、変換指示子によって意味が異なります。ご注意くださいませ。
</p>

<p> S 式を表示する場合は A (a) または S (s) 変換指示子を使います。次の例を見てください。
</p>
<pre>
gosh&gt; (format #t "~A~%" "hello, world")
hello, world
#&lt;undef&gt;
gosh&gt; (format #t "~S~%" "hello, world")
"hello, world"
#&lt;undef&gt;
</pre>

<p> A と S 変換指示子は、任意の S 式を出力できます。A は display と同じ形式で、S は write と同じ形式で出力します。A, S 変換指示子の場合でも、第 1 番目の前置パラメータでフィールド幅を指定することができます。
</p>
<pre>
gosh&gt; (format #t "[~20A]~%" "hello, world")
[hello, world        ]
#&lt;undef&gt;
gosh&gt; (format t "[~20@A]" "hello, world")
[        hello, world]
#&lt;undef&gt;
gosh&gt; (format #t "[~20,,,'*@A]" "hello, world")
[********hello, world]
#&lt;undef&gt;
</pre>
<p> A, S 変換指示子の場合、@ 修飾子を指定するとデータは右詰めに出力されます。詰め込む文字は第 4 番目の前置パラメータで指定します。
</p>
<p> このほかにも、浮動小数点数を表示する指示子など、format にはたくさんの機能があります。詳細は Gauche のマニュアルをご覧ください。
</p>

<h4>●入力</h4>
<p> 次は、簡単な入力について説明します。今まで使ってきた read や read-char は入力ポートを指定することができます。指定を省略した場合はデフォルト入力ポートが使用されます。Scheme を起動すると、デフォルト入力ポートには標準入力が割り当てられます。現在のデフォルト入力ポートは、次の関数で求めることができます。
</p>
<ul>
  <li>current-input-port
</ul>
<p> current-input-port は現在のデフォルト入力ポートを返します。入力関数でポートの指定を省略すると、このポートを介してデータの入力が行われます。
</p>
<p> 入力ポート (iport) の指定は次のように行います。
</p>
<ul>
  <li>read iport
  <li>read-char iport
</ul>
</pre>
<p> 入力ポート iport がファイルの場合、格納されているデータには限りがあるので、入力ポートからデータを取り出していくと、いつかはデータがなくなります。この状態を「ファイルの終了」とか「ファイルの終端」 (end of file : EOF) といいます。ファイルが終了したとき、read と read-car は EOF を表すデータ型 (ファイル終端オブジェクト) を返します。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (read)
^Z
#&lt;eof&gt;
</pre>
<p> Windows の場合、read で CTRL-Z を入力するとファイル終端オブジェクトが返されます。Gauche の場合、ファイル終端オブジェクトは #&lt;eof&gt; と表示されます。ファイル終端オブジェクトは、述語 eof-object? でチェックすることができます。
</p>

<p> ここで簡単な例題を見てみましょう。標準入力からデータを受け取って、それを標準出力へ出力するだけのプログラムです。標準入力をファイルにリダイレクトすれば、その内容を表示することができます。名前は type としました。
</p>

<pre class="list">
リスト : 標準入力のデータをそのまま標準出力へ出力する

;
; type.scm
;
(define (type)
    (let ((c (read-char)))
        (cond ((not (eof-object? c))
	       (display c)
	       (type)))))

(type)
</pre>

<p> 標準入力から read-char でデータを 1 文字読み込んで、その返り値を局所変数 c にセットします。次に、c がファイル終端オブジェクトか述語 eof-object? でチェックします。そうでなければ、display で文字 c を出力して type を再帰呼び出しします。このプログラムは末尾再帰で書かれています。Scheme は末尾再帰最適化が行われるので、繰り返しで書かれたプログラムと同様に動作します。
</p>

<p> 標準入力をファイルへリダイレクトすると、ファイルの内容を表示することができます。
</p>

<pre>
C&gt;gosh type.scm &lt; type.scm

・・・ type.scm の内容が表示される ・・・
</pre>

<p> 標準出力もほかのファイルへリダイレクトすれば、type.scm をコピーすることもできます。
</p>

<pre>
C&gt;gosh type.scm &lt; type.scm &gt; test.dat
</pre>

<p> ここで display の出力ポートを (standard-error-port) に変更すると、標準出力へリダイレクトされていても、画面にデータが表示されます。
</p>

<h4>●read-line</h4>
<p> R5RS にはありませんが、Gauche で用意されている便利な入力関数を紹介しましょう。関数 read-line は入力ポートからデータを読み込み、改行文字までのデータを文字列にして返します。改行文字は文字列に含まれないことに注意してください。read-line は Common Lisp にある関数です。
</p>

<p> 簡単な例を示しましょう。read-line でテキストファイルの内容を表示します。
</p>
<pre class="list">
リスト : テキストファイルの表示

; type.scm

(define (type)
    (let ((buff (read-line)))
        (cond ((not (eof-object? buff))
               (display buff)
               (newline)
               (type)))))

;
(type)
</pre>
<p> read-line はファイルの終端に達すると EOF オブジェクトを返します。ファイルを行単位で扱う場合、read-line はとても便利です。
</p>
<p> 行番号を付加することも簡単です。
</p>
<pre class="list">
リスト : テキストファイルの表示 (行番号付き)

; type.scm

(define (type n)
    (let ((buff (read-line)))
        (cond ((not (eof-object? buff))
               (format #t "~6D: ~A~%" n buff)
               (type (+ n 1))))))

; 実行
(type 1)
</pre>
<p> このように format を使えば行番号を付け加えることも簡単にできます。
</p>
<h4>●ファイル入出力</h4>
<p> 今度は、標準入出力を使わないでファイルにアクセスする方法を説明しましょう。ファイルをアクセスするためには、次の 3 つの操作が基本になります。
</p>

<ol>
  <li>アクセスするファイルをオープンする。
  <li>入出力関数を使ってファイルを読み書きする。
  <li>ファイルをクローズする。
</ol>

<p> 「ファイルをオープンする」とは、ファイルを名前 (ファイル名) で指定して、それと1 対 1 に対応するポートを作成することです。入出力関数は、そのポートを介してファイルにアクセスします。ファイルをオープンするには次の関数を使います。
</p>

<ul>
  <li>open-input-file filename
  <li>open-output-file filename
</ul>

<p> どちらの関数も引数 filename でファイル名を文字列で指定します。なお、Windows で Gauche を使う場合、パスの区切りは '\' ではなくて、次のように '/' か '\\' を使ってください。
</p>
<pre class="item">
C:\usr\work\test.dat =&gt; "C:/usr/work/test.dat" 
                     =&gt; "C:\\usr\\work\\test.dat"
</pre>
<p> ファイルからデータを読み込むときは open-inpuf-file でファイルをオープンします。open-input-file はファイルに対応する入力ポートを作成して返します。ファイルが存在しない場合、Gauche ではエラーになります。
</p>

<p> ファイルにデータを書き込むときは open-output-file でファイルをオープンします。open-output-file はファイルに対応する出力ポートを作成して返します。ファイルが存在しない場合は新しいファイルを作成します。既存のファイルがある場合は、そのファイルを 0 に切り詰めてからデータを書き込みます。
</p>

<p> これらの動作は、一般的なプログラミング言語でファイルをオープンするときの動作と同じです。Gauche の場合、これとは異なる例外的な動作を指定することもできます。詳細は Gauche のマニュアルをお読みください。
</p>

<p> 通常は返り値のポートを変数に格納しておき、それを入出力関数に渡してファイルにアクセスします。そして、最後にファイルをクローズします。これは次の関数を使います。
</p>

<ul>
  <li>close-input-file iport
  <li>close-output-file oport
</ul>
<p> close-input-file は入力ポート iport に対応するファイルをクローズします。close-output-port は出力ポート oport に対応するファイルをクローズします。オープンしたファイルは必ずクローズするようにしてください。
</p>

<p> これらの関数を使うと、ファイルのアクセスは次のようなプログラムになるでしょう。
</p>

<pre class="list">
リスト : ファイルのアクセスの例（その１）

(define (type1 filename)
    (let ((iport (open-input-file filename)))
        (let loop ((c (read-char iport)))
	    (cond ((not (eof-object? c))
	           (display c)
		   (loop (read-char iport)))))
        (close-input-port iport)))

(type1 "type.scm")
</pre>

<p> let でポートを格納する変数 iport を用意して、open-input-file でファイルをオープンします。ファイルのアクセスが終了したら、最後に close-input-port で iport に対応するファイルをクローズします。
</p>

<h4>●with-input-from-file と with-output-to-file</h4>
<p>実をいうと Scheme には、ファイルのオープンとクローズを行ってくれる便利な関数が用意されています。
</p>

<ul>
  <li>with-input-from-file filename thunk
  <li>with-output-fo-file filename thunk
</ul>

<p> with-inpur-from-file は filename で指定されたファイルをオープンし、その入力ポートをデフォルト入力ポートに設定します。それから、引数 thunk に渡された関数を評価します。thunk は引数なしで評価されるので、引数を受け取らない関数を渡すようにしてください。
</p>
<p> thunk の評価が終了すると、with-input-form-file は作成した入力ポートをクローズし、デフォルト入力ポートを元の値に戻します。with-input-from-file は thunk の返り値をそのまま返します。with-output-to-file はポートの種類が出力ポートになるだけで、あとは with-input-form-file と同じです。
</p>

<p> Scheme (Lisp) など関数型言語の場合、関数はほかのデータと同等に取り扱うことができます。つまり、関数を変数に代入したり、引数として渡すことができるのです。また、値として関数を返すこともできるので、関数を作る関数を定義することも簡単にできます。関数を引数に受け取る関数を「汎関数 (functional) 」とか「高階関数 (higher order function) 」と呼びます。高階関数については次回以降で詳しく説明します。
</p>

<p> 先ほどのプログラムを with-input-from-file で書き直すと、次のようになるでしょう。
</p>
<pre class="list">
リスト : ファイルのアクセスの例（その２）

(define (type)
    (let ((c (read-char)))
        (cond ((not (eof-object? c))
	       (display c)
	       (type)))))

(define (type2 filename)
    (with-input-from-file filename type))
</pre>

<p> 関数 type はデフォルトポート (標準入出力) で動作するプログラムですが、この関数を with-input-from-file に渡せば、filename で指定したファイルからデータを読み込むことができます。
</p>

<h4>●コマンドラインからパラメータを受け取る方法</h4>
<p> さて、ファイル操作を行うプログラムを作る場合、直接プログラムにファイル名を書き込むと、それをほかのファイルに使おうとしたときに、ファイル名を書き換えなければいけません。これは面倒なことですね。プログラムを起動するときに、コマンドラインからファイル名を指定できると便利です。
</p>

<p> Gauche の場合、起動したときのコマンドラインパラメータを大域変数 *argv* にリストとして保持しています。たとえば、次のように gosh を起動したとしましょう。write で *argv* を表示します。
</p>
<pre>
C&gt;gosh test.scm abc def ghi jkl
("abc" "def" "ghi" "jkl")
</pre>
<p> コマンドラインパラメータは文字列としてリストに格納されます。もうひとつ、Gauche には簡単な方法があります。プログラムで関数 main を定義すると、コマンドラインパラメータを格納したリストが引数に渡されます。そして、読み込んだプログラムに main が定義されていると、Gauche は最初に main を実行します。プログラムの最後で (main *argv*) と書く必要はありません。次に示すリストのように main を定義するだけです。
</p>
<pre class="list">
リスト : パラメータの取得

; test.scm

(define (main args)
    (write args))
</pre>
<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;gosh test.scm abc def ghi jkl
("test.scm" "abc" "def" "ghi" "jkl")
</pre>
<p> 引数に渡されるリストには、実行したファイル名が先頭に格納されることに注意してください。
</p>

<p> 簡単な例として、複数のファイル名を受け取るように type.scm を改造してみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : ファイルの内容を表示する

; type.scm

(define (type)
    (let ((c (read-char)))
        (cond ((not (eof-object? c))
	       (display c)
	       (type)))))

(define (main args)
    (let loop ((ls (cdr args)))
        (cond ((pair? ls)
               (with-input-from-file (car ls) type)
	       (loop (cdr ls))))))
</pre>

<p> main の引数 args でパラメータを受け取ります。先頭の要素には実行ファイル名 type.scm が格納されています。cdr でそれを取り除いて、名前付き let で繰り返しに入ります。あとはリスト ls からファイル名を順番に取り出して with-input-from-file に渡すだけです。これで複数のファイルを続けて表示することができます。
</p>

<h4>●まとめ</h4>
<p> 今回はここまでです。簡単に復習しておきましょう。
</p>
<ol>
  <li>ファイルの入出力はポートを介して行う。
  <li>入出力関数はポートの指定がない場合、デフォルトのポート (標準入出力) が使用される。
  <li>write は可能な限り read で読み込める形式でデータを出力する。
  <li>format は書式を指定してデータを出力する。
  <li>read, read-char など入力関数はファイルの終了時にファイル終端オブジェクトを返す。
  <li>read-line はファイルから 1 行読み込んで、文字列型データとして返す。
  <li>ファイルのオープンには open-input-file, open-output-file を使い、クローズには close-input-port, close-output-port を使う。
  <li>with-input-from-file と with-output-to-file は指定したファイルをオープンし、その後でファイルを自動的にクローズをする。
  <li>Gauche は関数 main の引数でコマンドラインからのパラメータを受け取ることができる。
</ol>
<p> 次回はもう少し実用的なプログラムを作ってみましょう。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm06.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm08.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>