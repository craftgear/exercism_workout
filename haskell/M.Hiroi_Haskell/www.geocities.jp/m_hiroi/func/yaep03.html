<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Erlang Problems</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881788</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Erlang Programming</h1>
<h2>Yet Another Erlang Problems</h2>
<div class="small">
[ <a href="yaep02.html">PrevPage</a> | <a href="erlang.html#yaep">Erlang</a> | <a href="yaep04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h4 id="p51">●問題51</h4>
<p> リスト Xs を木とみなして、X と等しい要素 (葉) を探す関数 member_tree(X, Xs) を定義してください。
</p>
<pre>
&gt; yaep:member_tree(d, [a, [b, [c, [d | e], f], g], h]).
true
&gt; yaep:member_tree(e, [a, [b, [c, [d | e], f], g], h]).
true
&gt; yaep:member_tree(a, [a, [b, [c, [d | e], f], g], h]).
true
&gt; yaep:member_tree(h, [a, [b, [c, [d | e], f], g], h]).
true
&gt; yaep:member_tree(x, [a, [b, [c, [d | e], f], g], h]).
false
</pre>
<p><a href="yaep03.html#ans51">解答</a>
</p>
<h4 id="p52">●問題52</h4>
<p> リスト Xs を木とみなして、要素 (葉) を数える関数 count_leaf(Xs) を定義してください。
</p>
<pre>
&gt; yaep:count_leaf([a, [b, [c, [d | e], f], g], h]).
8
&gt; yaep:count_leaf_cps([a, [b, [c, [d | e], f], g], h]).
8
</pre>
<p><a href="yaep03.html#ans52">解答</a>
</p>
<h4 id="p53">●問題53</h4>
<p> リスト Xs を木とみなして、X と等しい要素を Y に置換する関数 subst(X, Y, Xs) を定義してください。
</p>
<pre>
&gt; yaep:subst(a, x, [a, [b, [c, [d | a], f], a], h]).
[x,[b,[c,[d|x],f],x],h]
&gt; yaep:subst_cps(a, x, [a, [b, [c, [d | a], f], a], h], fun(X) -&gt; X end).
[x,[b,[c,[d|x],f],x],h]
</pre>
<p><a href="yaep03.html#ans53">解答</a>
</p>
<h4 id="p53">●問題54</h4>
<p> リスト Xs を挿入ソートする関数 insert_sort(Pred, Xs) を定義してください。
</p>
<pre>
&gt; yaep:insert_sort(fun(X, Y) -&gt; X &lt; Y end, [5, 6, 4, 7, 3, 8, 2, 9, 1, 0]).
[0,1,2,3,4,5,6,7,8,9]
&gt; yaep:insert_sort(fun(X, Y) -&gt; X &gt; Y end, [5, 6, 4, 7, 3, 8, 2, 9, 1, 0]).
[9,8,7,6,5,4,3,2,1,0]
</pre>
<p> <a href="yaep03.html#ans54">解答</a>
</p>
<h4 id="p54">●問題55</h4>
<p> リスト Xs をクイックソートする関数 quick_sort(Pred, Xs) を定義してください。
</p>
<pre>
&gt; yaep:quick_sort(fun(X, Y) -&gt; X &lt; Y end, [5, 6, 4, 7, 3, 8, 2, 9, 1, 0]).
[0,1,2,3,4,5,6,7,8,9]
&gt; yaep:quick_sort(fun(X, Y) -&gt; X &gt; Y end, [5, 6, 4, 7, 3, 8, 2, 9, 1, 0]).
[9,8,7,6,5,4,3,2,1,0]
</pre>
<p> <a href="yaep03.html#ans55">解答</a>
</p>
<h4 id="p55">●問題56</h4>
<p> リスト Xs のべき集合を求める関数 power_set(Xs) を定義してください。たとえばリスト [a, b, c] のべき集合は [ ], [a], [b], [c], [a, b], [a, c], [b, c], [a, b, c] になります。
</p>
<pre>
&gt; yaep:power_set([a, b, c]).
[[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]]
&gt; yaep:power_set1(fun io:write/1, [a, b, c]).
[a,b,c][a,b][a,c][a][b,c][b][c][]ok
</pre>
<p> <a href="yaep03.html#ans56">解答</a>
</p>

<h4 id="p57">●問題57</h4>
<p> リスト Xs がリスト Ys の部分集合か判定する述語 subset(Xs, Ys) を定義してください。なお、並び方が異なるだけのリスト、たとえば [a, b] と [b, a] は同じ集合とします。
</p>
<pre>
&gt; yaep:subset([a, b], [a, b, c]).
true
&gt; yaep:subset([b, a], [a, b, c]).
true
&gt; yaep:subset([b], [a, b, c]).
true
&gt; yaep:subset([], [a, b, c]).
true
&gt; yaep:subset([d], [a, b, c]).
false
</pre>
<p> <a href="yaep03.html#ans57">解答</a>
</p>
<h4 id="p58">●問題58</h4>
<p> 集合を表すリスト Xs, Ys の直積集合を求める述語 product(Xs, Ys) を定義してください。Xs の要素を x<sub>i</sub>, Ys 要素を y<sub>j</sub> とすると、直積集合の要素は {x<sub>i</sub>, y<sub>j</sub>} となります。たとえば、Xs = [a, b, c], Ys = [1, 2] とすると、直積集合は[{a, 1}, {a, 2}, {b, 1}, {b, 2}, {c, 1}, {c, 2}] になります。
</p>
<pre>
&gt; yaep:product([a, b, c], [1, 2]).
[{a,1},{b,1},{c,1},{a,2},{b,2},{c,2}]
</pre>
<p> <a href="yaep03.html#ans58">解答</a>
</p>
<h4 id="p59">●問題59</h4>
<p> 下記経路図において、スタート (A) からゴール (G) までの経路を求めるプログラムを「深さ優先探索」で作ってください。
</p>
<pre class="fig">
    Ｂ───Ｄ───Ｆ
  ／│      │
Ａ  │      │
  ＼│      │
    Ｃ───Ｅ───Ｇ

       図 : 経路
</pre>
<pre>
&gt; yaep:dfs(g, [a]).
[a,b,c,e,g]
[a,b,d,e,g]
[a,c,b,d,e,g]
[a,c,e,g]
ok
</pre>
<p> <a href="yaep03.html#ans59">解答</a>
</p>
<h4 id="p60">●問題60</h4>
<p> 問題 59 の経路図において、スタート (A) からゴール (G) までの経路を求めるプログラムを「幅優先探索」で作ってください。
</p>
<pre>
&gt; yaep:bfs(g, [[a]]).
[a,c,e,g]
[a,b,d,e,g]
[a,b,c,e,g]
[a,c,b,d,e,g]
ok
</pre>
<p> <a href="yaep03.html#ans60">解答</a>
</p>
<h4 id="p61">●問題61</h4>
<p> 問題 59 の経路図において、スタート (A) からゴール (G) までの経路を求めるプログラムを「反復深化」で作ってください。
</p>
<pre>
&gt; yaep:ids(a, g).
[a,c,e,g]
[a,b,c,e,g]
[a,b,d,e,g]
[a,c,b,d,e,g]
ok
</pre>
<p> <a href="yaep03.html#ans61">解答</a>
</p>
<h4 id="p62">●問題62</h4>
<div class="question">
<b>[小町算]</b>
<p>1 から 9 までの数字を順番に並べ、間に + と - を補って 100 になる式を作ってください。
</p>
<p> 例：1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
</p>
</div>
<p> パズルの世界では、1 から 9 までの数字を 1 個ずつすべて使った数字を「小町数」といいます。たとえば、123456789 とか 321654987 のような数字です。「小町算」というものもあり、たとえば 123 + 456 + 789 とか 321 * 654 + 987 のようなものです。問題は小町算の中でも特に有名なパズルです。
</p>
<p> <a href="yaep03.html#ans62">解答</a>
</p>
<h4 id="p63">●問題63</h4>
<div class="question">
<b>[油分け算]</b>
<p> 斗桶に油が 1 斗（= 10 升）あります。これを 5 升ずつ 2 つの油に分けたいのですが、手元には 7 升ますと 3 升ますが 1 つずつしかありません。この 2 つのますを使って油を二等分してください。
</p>
</div>
<p> 油分け算を「幅優先探索」で解くプログラムを作ってください。なお、油分け算は江戸時代の和算書『塵劫記（じんこうき）』にある問題です。
</p>
<p> <a href="yaep03.html#ans63">解答</a>
</p>
<h4 id="p64">●問題64</h4>
<p> 問題 63 の油分け算を「反復深化」で解くプログラムを作ってください。
</p>
<p> <a href="yaep03.html#ans64">解答</a>
</p>
<h4 id="p65">●問題65</h4>
<p> 「マスターマインド」は拙作のページ <a href="scheme.html#abcscm">お気楽 Scheme プログラミング入門</a> <a href="abcscm06.html">数当てゲーム [2]</a> で作成した、0 から 9 までの重複しない 4 つの数字からなる隠しコードを当てるゲームです。数字は合っているが位置が間違っている個数を cows で表し、数字も位置も合っている個数を bulls で表します。bulls が 4 になると正解です。
</p>
<pre class="fig">
     [6; 2; 8; 1] : 正解
-------------------------------------
1.   [0; 1; 2; 3] : cows 2 : bulls 0
2.   [1; 0; 4; 5] : cows 1 : bulls 0
3.   [2; 3; 5; 6] : cows 2 : bulls 0
4.   [3; 2; 7; 4] : cows 0 : bulls 1
5.   [3; 6; 0; 8] : cows 2 : bulls 0
6.   [6; 2; 8; 1] : cows 0 : bulls 4

  図 : マスターマインドの動作例
</pre>
<p> マスターマインドを解くプログラムを作ってください。
</p>
<p> <a href="yaep03.html#ans65">解答</a>
</p>
<hr>
<h4 id="ans51">●解答51</h4>
<pre class="list">
リスト : 木の探索

member_tree(X, X, _) -&gt; true;
member_tree(X, [Y | Ys], Cont) -&gt;
  member_tree(X,
              Y,
              fun(_) -&gt;
                member_tree(X, Ys, fun(Z) -&gt; Cont(Z) end)
              end);
member_tree(_, _, Cont) -&gt; Cont(false).
member_tree(X, Xs) -&gt; member_tree(X, Xs, fun(Y) -&gt; Y end).
</pre>
<p> 探索は member_tree/3 で行います。member_tree/3 は継続渡しスタイル (Continuation Passing Style : CPS) でプログラムしています。探索を続ける場合は、第 3 引数の継続 Cont を呼び出します。探索を打ち切る場合は Cont を呼び出さずに値をそのまま返します。
</p>

<p> リストを二分木と考えると、リストの先頭要素が左部分木、残りのリストが右部分木に相当します。左右の部分木に対して member_tree を再帰呼び出しすればいいわけです。最初の節で、X と等しい要素が見つけたならば true を返します。そうでなければ、第 2 の節で左右の部分木をたどります。最後の節は X と等しくない要素の場合です。継続 Cont に false を渡して呼び出します。
</p>

<h4 id="ans52">●解答52</h4>
<pre class="list">
リスト : 葉の個数を求める

count_leaf([]) -&gt; 0;
count_leaf([X | Xs]) -&gt; count_leaf(X) + count_leaf(Xs);
count_leaf(_) -&gt; 1.

% 別解
count_leaf_cps([], Cont) -&gt; Cont(0);
count_leaf_cps([X | Xs], Cont) -&gt;
  count_leaf_cps(X, fun(A) -&gt; count_leaf_cps(Xs, fun(B) -&gt; Cont(A + B) end) end);
count_leaf_cps(_, Cont) -&gt; Cont(1).
count_leaf_cps(Xs) -&gt; count_leaf_cps(Xs, fun(X) -&gt; X end).
</pre>
<p> count_leaf も簡単です。第 1 引数が空リストならば 0 を返します。第 1 引数がリストならば左右の部分木にたいして count_leaf を再帰呼び出しし、その結果を足し算して返します。そうでなければ、引数は葉なので 1 を返します。別解は継続渡しスタイルで書き直したものです。
</p>

<h4 id="ans53">●解答53</h4>
<pre class="list">
リスト : 木の置換

subst(X, Y, X) -&gt; Y;
subst(X, Y, [Z | Zs]) -&gt; [subst(X, Y, Z) | subst(X, Y, Zs)];
subst(_, _, Z) -&gt; Z.

% 別解
subst_cps(X, Y, X, Cont) -&gt; Cont(Y);
subst_cps(X, Y, [Z | Zs], Cont) -&gt;
  subst_cps(X, Y, Z, fun(A) -&gt; subst_cps(X, Y, Zs, fun(B) -&gt; Cont([A | B]) end) end);
subst_cps(_, _, Z, Cont) -&gt; Cont(Z).
subst_cps(X, Y, Xs) -&gt; subst_cps(X, Y, Xs, fun(Z) -&gt; Z end).
</pre>
<p> subst も簡単です。第 3 引数が X と等しい場合は Y を返します。第 3 引数がリストならば左右の部分木にたいして subst を再帰呼び出しし、その結果をリストに格納して返します。それ以外の場合は第 3 引数 Z をそのまま返します。別解は継続渡しスタイルで書き直したものです。
</p>

<h4 id="ans54">●解答54</h4>
<p> 挿入ソートの考え方はとても簡単です。ソート済みのリストに新しいデータを挿入していくことでソートを行います。たとえば、リスト [2, 4, 6] に 5 を挿入する場合、リストの要素 n と 5 を順番に比較して、5 &lt; n を満たす位置に 5 を挿入すればいいわけです。この場合は、4 と 6 の間に 5 を挿入すればいいですね。
</p>

<p> ソートするリストは、tl で分解していくと空リストになります。これをソート済みのリストと考えて、ここにデータを挿入していきます。プログラムは次のようになります。 
</p>

<pre class="list">
リスト : 挿入ソート

insert_element(_, X, []) -&gt; [X];
insert_element(Pred, X, [Y | Ys]) -&gt;
  case Pred(X, Y) of
    true -&gt; [X, Y | Ys];
    false -&gt; [Y | insert_element(Pred, X, Ys) ]
  end.
insert_sort(_, []) -&gt; [];
insert_sort(Pred, [X | Xs]) -&gt; insert_element(Pred, X, insert_sort(Pred, Xs)).
</pre>

<p> リストにデータをひとつ挿入する関数が insert_element です。再帰呼び出しでリストをたどり、データ x を挿入する位置を探します。比較関数 Pred の返り値が真であれば、その位置にデータを挿入します。insert_sort は引数のリストを再帰呼び出しで分解します。空リストになると再帰呼び出しが停止します。そして、リストの先頭要素を insert_element でソート済みのリストに挿入します。
</p>

<h4 id="ans55">●解答55</h4>
<p> クイックソートはある値を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。基準になる値のことを「枢軸 (pivot) 」といいます。枢軸は要素の中から適当な値を選んでいいのですが、リストの場合は任意の箇所を簡単に選ぶことができません。この場合、いちばん簡単に求めることができる先頭の要素を枢軸とします。
</p>
<p> リストを 2 つに分けたら、それらを同様にソートします。これは、再帰を使えば簡単に実現できます。その結果を枢軸を挟んで結合します。これを図に表すと次のようになります。
</p>
<pre class="fig">
         5 3 7 6 9 8 1 2 4

          5 を枢軸に分割

      (3 1 2 4)  5  (7 6 9 8)

   3を枢軸に分割    7を枢軸に分割

 (1 2)  3  (4) | 5 | (6)  7  (9 8) 

  ・・・分割を繰り返していく・・・ 

      図 : クイックソート
</pre>
<p> このようにリストを分割していくと、最後は空リストになります。ここが再帰の停止条件になります。あとは分割したリストを演算子 ++ で結合すればいいわけです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : リストのクイックソート

quick_sort(_, []) -&gt; [];
quick_sort(Pred, [X | Xs]) -&gt;
  {A, B} = partition(fun(Y) -&gt; Pred(Y, X) end, Xs),
  quick_sort(Pred, A) ++ [X] ++ quick_sort(Pred, B).
</pre>

<p> リストの分割は関数 partition で行います。引数 X が枢軸になります。あとは分割したリスト A, B を quick_sort でソートし、その結果を [X] を挟んで演算子 ++ で連結するだけです。
</p>
<p> クイックソートの実行時間は、データ数を N とすると平均して N * log<sub>2</sub> N に比例します。ところが、枢軸の選び方によっては、最悪で N の 2 乗に比例するまで劣化します。クイックソートはリストには不向きのアルゴリズムといえます。
</p>

<h4 id="ans56">●解答56</h4>
<pre class="list">
リスト : べき集合

power_set([]) -&gt; [[]];
power_set([X | Xs]) -&gt;
  power_set(Xs) ++ [[X | Ys] || Ys &lt;- power_set(Xs)].

% 別解 (高階関数版)
power_set1(F, [], A) -&gt; F(lists:reverse(A));
power_set1(F, [X | Xs], A) -&gt;
  power_set1(F, Xs, [X | A]), power_set1(F, Xs, A).
power_set1(F, Xs) -&gt; power_set1(F, Xs, []).
</pre>
<p> べき集合を求める関数 power_set は簡単です。引数が空リストの場合は [ ] を格納したリストを返します。そうでなければ power_set を再帰呼び出しして Xs のべき集合を求め、その集合に先頭要素 (car ls) を追加します。そして、その集合と (cdr ls) のべき集合を演算子 ++ で連結します。
</p>
<p> 別解の power_set1 は高階関数バージョンです。リストの長さを N とすると、べき集合の要素数は 2 ^ N になります。N が大きくなると、べき集合をリストに格納して返すことは困難になります。その場合は高階関数を使うとよいでしょう。
</p>

<h4 id="ans57">●解答57</h4>
<pre class="list">
リスト : 部分集合の判定

subset([], _) -&gt; true;
subset([X | Xs], Ys) -&gt;
  case lists:member(X, Ys) of
    true -&gt; subset(Xs, Ys);
    false -&gt; false
  end.
</pre>
<p> 最初の節は「空集合は集合 Ys の部分集合である」ということを表しています。これが再帰呼び出しの停止条件となります。次の規則で、リストの先頭要素 X が Ys の要素であることを lists:member で確認し、それから Xs が Ys の部分集合であることを subset で確認すればいいわけです。
</p>

<h4 id="ans58">●解答58</h4>
<pre class="list">
リスト : 直積集合

product(Xs, Ys) -&gt; [{X, Y} || Y &lt;- Ys, X &lt;- Xs].
</pre>
<p> 関数 product はリスト内包表記で Xs, Ys の要素を取り出して {X, Y} を生成するだけです。
</p>

<h4 id="ans59">●解答59</h4>
<p> 経路はリストに頂点を格納して表すことにします。次の図を見てください。
</p>

<pre class="fig">
A - B - D      ─→  [a, b, d]    ==&gt; [d, b, a]

A - B - C - E  ─→  [a, b, c, e] ==&gt; [e, c, b, a]  

                             逆順で管理する

        図  : 経路の表し方
</pre>
<p> リストの最後尾にデータを追加するのは面倒なので、経路は上図のように逆順で管理することにします。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 経路の探索 (1)

% 経路
adjacent(a) -&gt; [b, c];
adjacent(b) -&gt; [a, c, d];
adjacent(c) -&gt; [a, b, e];
adjacent(d) -&gt; [b, e, f];
adjacent(e) -&gt; [c, d, g];
adjacent(f) -&gt; [d];
adjacent(g) -&gt; [e].

% 深さ優先探索
dfs(G, [G | Path]) -&gt;
  io:write(lists:reverse([G | Path])), io:nl();
dfs(G, [X | Path]) -&gt;
  lists:foreach(
    fun (Y) -&gt;
      case lists:member(Y, Path) of
        true -&gt; false;
        false -&gt; dfs(G, [Y, X | Path])
      end
    end,
    adjacent(X)).
</pre>

<p> 関数 dfs の引数 G がゴール、第 2 引数のリストが経路を表します。最初の節で、リストの先頭要素が引数 G に等しい場合は、ゴールに到達したので経路を表示します。これが再帰呼び出しの停止条件になります。次の節で、リストの先頭から現在地点 X を取り出します。そして、関数 adjacent で X に隣接している地点を求めます。返り値はリストなので、list:foreach で要素を取り出して無名関数の引数 Y に渡します。その中で dfs を再帰呼び出しします。
</p>

<p> このとき、経路に含まれている頂点を選んではいけません。そうしないと、同じ道をぐるぐると回る巡回経路が発生し、ゴールまでたどり着くことができなくなります。このチェックを関数 lists:member で行います。経路の中に頂点 Y がないことを確認してから、経路に Y を追加して dfs を再帰呼び出しします。
</p>

<p> バックトラックによる探索は、経路を先へ先へ進めるので、「縦形探索」とか「深さ優先探索」と呼ばれています。このため、結果を見てもわかるように、最初に見つかる経路が最短経路とは限りません。最短経路を求めるのに適したアルゴリズムが「幅優先探索」です。
</p>

<h4 id="ans60">●解答60</h4>
<p> バックトラックによる探索は「深さ優先探索」や「縦形探索」とも呼ばれるように、一つの経路を先へ先へと進めていきます。このため最初に見つかる経路が最短経路であるとは限りません。幅優先探索は全ての経路について平行に探索を進めていくため、最初に見つかる経路が最短経路となります。それでは、同じ経路図を使って幅優先探索を具体的に説明しましょう。
</p>
<p> 幅優先探索の様子を下図に示します。
</p>
<pre class="fig">
    [A] ─┬─ [A,B] ─┬─ [A,B,C]  ・・・・
          │           └─ [A,B,D] ─┬─ [A,B,D,F] 行き止まり  
          │                          └─ [A,B,D,E]
          └─ [A,C] ─┬─ [A,C,B]  ・・・・
                       └─ [A,C,E] ─┬─ [A,C,E,G] GOAL
                                      └─ [A,C,E,D] 

（出発点）    （２節点）  （３節点）      （４節点）

                図 : 幅優先探索
</pre>
<p> まず、出発点 A から一つ進んだ経路 (2 節点) を全て求めます。この場合は、[A, B] と [A, C] の 2 つあり、これを全て記憶しておきます。次に、これらの経路から一つ進めた経路 (3 節点) を全て求めます。経路 [A, B] は [A, B, C] と [A, B, D] へ進めることができますね。ほかの経路 [A, C] も同様に進めて、全ての経路を記憶します。あとはこの作業をゴールに達するまで繰り返せばいいのです。
</p>

<p> 上図では、4 節点の経路 [A, C, E, G] でゴールに達していることがわかります。このように幅優先探索では、最初に見つかった経路が最短距離 (または最小手数) となるのです。この性質は、全ての経路を平行に進めていく探索順序から考えれば当然のことといえるでしょう。このことからバックトラックの縦形探索に対して、幅優先探索は「横形探索」と呼ばれます。このあとも探索を繰り返せば全ての経路を求めることができます。
</p>

<p> 完成までの最小手数を求めるパズルを解く場合、幅優先探索を使ってみるといいでしょう。ただし、探索を進めるにしたがって、記憶しておかなければならないデータの総数が爆発的に増加する、つまりメモリを大量消費することに注意してください。
</p>

<p> 上図の場合ではメモリを大量消費することはありませんが、問題によってはマシンに搭載されているメモリが不足するため、幅優先探索を実行できない場合もあるでしょう。したがって、幅優先探索を使う場合は、メモリの消費量を抑える工夫も必要になります。
</p>

<h4>●経路の管理</h4>
<p> 経路の管理はキューを使うと簡単です。幅優先探索でのキューの動作を下図に示します。
</p>
<pre class="fig">
(1)     ───── QUEUE  ──────
  ┌── [A]
  │    ───────────────
  │
  └─→ キューからデータを取り出す

(2)     ───── QUEUE  ──────
                                    ←─┐
        ───────────────  │
                                        │
        [A] の経路を進め    [A,B] ───┤
        キューに追加する    [A,C] ───┘

 (3)     ───── QUEUE  ──────
  ┌── [A,B] [A,C]                  ←─┐
  │    ───────────────    │
  │                                      │
  └─→ [A,B] の経路を進めキューに追加   │
         [A,B,C] [A,B,D]  ────────┘

(4)     ───── QUEUE  ──────
  ┌── [A,C] [A,B,C] [A,B,D]        ←─┐
  │    ───────────────    │
  │                                      │
  └─→ キューに経路がある間繰り返す ──┘  

        図 : 幅優先探索とキューの動作
</pre>
<p> 最初は、(1) のように出発点をキューにセットしておきます。次に、キューから経路を取り出し、(2) のように経路 [A] を一つ進めて、経路 [A, B] [A, C] を作り、それをキューに追加します。(3) では、経路 [A, B] を取り出して、一つ進めた経路 [A, B, C] と [A, B, D] をキューに追加します。あとはキューに経路がある間、探索処理を繰り返します。
</p>

<p> キューは先入れ先出し (FIFO) の性質を持つデータ構造です。距離の短い経路から順番に処理されるため、幅優先探索として機能するわけです。
</p>

<h4>●幅優先探索のプログラム</h4>
<p> それではプログラムを作りましょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 経路の探索 (2)

% 幅優先探索
bfs(_, []) -&gt; ok;
bfs(Goal, [[Goal | Xs] | Ys]) -&gt;
  io:write(lists:reverse([Goal | Xs])), io:nl(), bfs(Goal, Ys);
bfs(Goal, [[X | Xs] | Ys]) -&gt;
  bfs(Goal, Ys ++ lists:foldl(fun(Y, A) -&gt; 
                                case lists:member(Y, Xs) of
                                  true -&gt; A;
                                  false -&gt; [[Y, X | Xs] | A]
                                end
                              end,
                              [],
                              adjacent(X))).
</pre>

<p> 関数 bfs の引数 G がゴールを表し、第 2 引数のリストでキューを表します。最初の節で、キューが空になったら探索を終了します。これが再帰呼び出しの停止条件になります。次の節で、キューの先頭にある経路をチェックします。経路の先頭要素がゴールであれば、その経路を取り出して表示します。そのあと、bfs を再帰呼び出しすると、次の経路を求めることができます。
</p>
<p> 最後の節で、キューから先頭の経路を取り出し、foldr で新しい経路を生成し、それをキューの最後尾に連結します。無名関数の引数 Y が X に隣接する地点、A が累積変数です。lists:member で Y が経路 Xs に含まれていなければ、経路に Y を追加して、それを累積変数 A に追加します。そうでなければ A をそのまま返します。これで全ての経路を求めることができます。
</p>

<h4 id="ans61">●解答61</h4>
<p> 幅優先探索は最短手数を求めるのに適したアルゴリズムですが、生成する局面数が多くなると大量のメモリを必要とします。このため、メモリが不足するときは、幅優先探索を使うことができません。深さ優先探索の場合、メモリの消費量は少ないのですが、最初に見つかる解が最短手数とは限らないという問題点があります。
</p>

<p> それでは、大量のメモリを使わずに最短手数を求める方法はないのでしょうか。実は、とても簡単な方法があるのです。それは、深さ優先探索の「深さ」に上限値を設定し、解が見つかるまで上限値を段階的に増やしていく、という方法です。
</p>

<p> たとえば、1 手で解が見つからない場合は、2 手までを探索し、それでも見つからない場合は 3 手までを探索する、というように制限値を 1 手ずつ増やしていくわけです。このアルゴリズムを「反復深化 (iterative deeping) 」といいます。
</p>

<p> 反復深化は最短手数を求めることができるアルゴリズムですが、幅優先探索と違って局面を保存する必要が無いため、必要となるメモリは深さ優先探索と同程度で済みます。また、プログラムも深さ優先探索と同じくらい簡単に作成することができます。ただし、同じ探索を何度も繰り返すため実行時間が増大するという欠点があります。ようするに、使用するメモリは少ないが実行時間が長くなるアルゴリズムなのです。
</p>

<h4>●反復深化のプログラム</h4>
<p> 反復深化のプログラムはとても簡単です。設定した上限値まで深さ優先探索を行う関数を作り、上限値を１手ずつ増やしてその関数を呼び出せばいいのです。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 経路の探索 (3)

% 反復深化
ids(Limit, Goal, Path) when length(Path) =:= Limit -&gt;
  if
    hd(Path) =:= Goal -&gt; io:write(lists:reverse(Path)), io:nl();
    true -&gt; false
  end;
ids(Limit, Goal, Path) -&gt;
  lists:foreach(fun(N) -&gt;
                  case lists:member(N, Path) of
                    true -&gt; false;
                    false -&gt; ids(Limit, Goal, [N | Path])
                  end
                end,
                adjacent(hd(Path))).

ids(Start, Goal) -&gt;
  lists:foreach(fun(Limit) -&gt; ids(Limit, Goal, [Start]) end, iota(1, 7)).
</pre>

<p> 関数 ids/3 の引数 Limit が上限値を表します。経路の長さが上限値 Limit に達したら探索を打ち切ります。このとき、ゴールに到達したかチェックします。あとは関数 ids/2 で、Limit の値を増やしながら ids/3 を呼び出せばいいわけです。
</p>

<h4 id="ans62">●解答62</h4>
<p> それではプログラムを作りましょう。式は次のようにリストで表すことにします。
</p>
<pre class="item">
1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 =&gt; [1, +, 2, +, 3, -, 4, +, 5, +, 6, +, 78, +, 9]
</pre>
<p> Erlang の場合、+ と - をアトムとして扱うにはクオートで囲ってください。あとは、式を生成して値を計算するだけです。式を生成するとき、リストを逆順で管理すると簡単です。次の図を見てください。
</p>
<pre class="fig">
[1] =&gt; [2, +, 1] =&gt; [3, +, 2, + 1]
                 =&gt; [3, -, 2, + 1]
                 =&gt; [23, +, 1]
    =&gt; [2, -, 1] =&gt; [3, +, 2, -, 1]
                 =&gt; [3, -, 2, -, 1]
                 =&gt; [23, -, 1]
    =&gt; [12]      =&gt; [3, +, 12]
                 =&gt; [3, -, 12]
                 =&gt; [123]
</pre>
<p> 式を生成するとき、リストに数字と演算子を順番に追加していきます。数字と +, - を追加する処理は簡単です。プログラムのポイントは数字を連結する処理、たとえば 1 と 2 を連結して一つの数値 12 にする処理です。この処理はリストの先頭の数字 1 を 12 (= 1 * 10 + 2) に置き換えることで実現できます。リストが [2, +, 1] であれば、数字 2 を 23 (= 2 * 10 + 3) に置き換えます。
</p>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 小町算

% 式の計算
calc_expr([], A) -&gt; A;
calc_expr(['+', N | Expr], A) -&gt; calc_expr(Expr, A + N);
calc_expr(['-', N | Expr], A) -&gt; calc_expr(Expr, A - N).
calc_expr([X | Xs]) -&gt; calc_expr(Xs, X).

% 式の生成
make_expr(10, Expr) -&gt;
  Expr1 = lists:reverse(Expr),
  Value = calc_expr(Expr1),
  if
    Value =:= 100 -&gt; io:write(Expr1), io:nl();
    true -&gt; false
  end;
make_expr(N, [M | Expr]) -&gt;
  make_expr(N + 1, [N, '+', M | Expr]),
  make_expr(N + 1, [N, '-', M | Expr]),
  make_expr(N + 1, [M * 10 + N | Expr]).

komachi() -&gt; make_expr(2, [1]).
</pre>
<p> 関数 make_expr の引数 N が追加する数字、Expr が生成する式（リスト）です。N が 10 の場合、式がひとつ完成したので calc_expr を呼び出して式を計算します。その値が 100 であれば式を表示します。それ以外の場合は、make_expr を再帰呼び出しで式を生成します。この処理は簡単で、最初に N, '+' を追加した式を、次に N, '-' を追加した式を、最後に M を M * 10 + N に変換した式を生成します。
</p>

<p> 式の計算も簡単です。calc_expr/1 は calc_expr/2 を呼び出します。このとき、先頭の要素を累積変数にセットします。これで、リストの先頭は演算子になるので、'+', N であれば A + N を、'-', N であれば A - N を計算していくだけです。空リストになったら累積変数 A を返します。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
&gt; yaep:komachi().
[1,'+',2,'+',3,'-',4,'+',5,'+',6,'+',78,'+',9]
[1,'+',2,'+',34,'-',5,'+',67,'-',8,'+',9]
[1,'+',23,'-',4,'+',5,'+',6,'+',78,'-',9]
[1,'+',23,'-',4,'+',56,'+',7,'+',8,'+',9]
[12,'+',3,'+',4,'+',5,'-',6,'-',7,'+',89]
[12,'+',3,'-',4,'+',5,'+',67,'+',8,'+',9]
[12,'-',3,'-',4,'+',5,'-',6,'+',7,'+',89]
[123,'+',4,'-',5,'+',67,'-',89]
[123,'+',45,'-',67,'+',8,'-',9]
[123,'-',4,'-',5,'-',6,'-',7,'+',8,'-',9]
[123,'-',45,'-',67,'+',89]
false
</pre>
<p> 全部で 11 通りの解が出力されます。ところで、今回は数式を表すリストをそのまま出力していますが、これを普通の数式で表示するとわかりやすくなるでしょう。興味のある方はプログラムを改造してみてください。
</p>

<h4 id="ans63">●解答63</h4>
<p> それではプログラムを作りましょう。斗桶 (A) と 7 升ます (B) と 3 升ます (C) の状態をタプル {A, B, C} で表すことにします。油分け算の場合、次に示す 3 通りの操作があります。
</p>
<ol>
  <li>斗桶からますへ油を注ぐ。
  <li>ますの油を斗桶に戻す。
  <li>他のますに油を移す。
</ol>
<p> ますは 2 つあるので、操作は全部で 6 通りになります。この操作を関数 transfer1 - 6 で定義します。次のリストを見てください。
</p>

<pre class="list">
リスト : 油分け算 (1)

% A -&gt; B
transfer1({A, B, C}, Mb, _) when Mb - B &gt;= A -&gt; {0, A + B, C};
transfer1({A, B, C}, Mb, _) -&gt; {A - Mb + B, Mb, C}.

% A -&gt; C
transfer2({A, B, C}, _, Mc) when Mc - C &gt;= A -&gt; {0, B, A + C};
transfer2({A, B, C}, _, Mc) -&gt; {A - Mc + C, B, Mc}.

% B -&gt; A
transfer3({A, B, C}, _, _) -&gt; {A + B, 0, C}.

% C -&gt; A
transfer4({A, B, C}, _, _) -&gt; {A + C, B, 0}.

% B -&gt; C
transfer5({A, B, C}, _, Mc) when Mc - C &gt;= B -&gt; {A, 0, B + C};
transfer5({A, B, C}, _, Mc) -&gt; {A, B - Mc + C, Mc}.

% C -&gt; B
transfer6({A, B, C}, Mb, _) when Mb - B &gt;= C -&gt; {A, B + C, 0};
transfer6({A, B, C}, Mb, _) -&gt; {A, Mb, C - Mb + B}.

% 幅優先探索
abura(Goal, _, _, [[Goal | Gs] | _]) -&gt;
  io:format('~w~n', [lists:reverse([Goal | Gs])]);
abura(Goal, Mb, Mc, [[X | Xs] | Ys]) -&gt;
  abura(Goal, Mb, Mc, Ys ++ lists:foldl(
                              fun(F, A) -&gt;
                                X1 = F(X, Mb, Mc),
                                case lists:member(X1, [X |Xs]) of
                                  true -&gt; A;
                                  false -&gt; [[X1, X | Xs] | A]
                                end
                              end,
                              [],
                              [fun transfer1/3, fun transfer2/3, fun transfer3/3,
                               fun transfer4/3, fun transfer5/3, fun transfer6/3])).

solve_abura() -&gt; abura({5, 5, 0}, 7, 3, [[{10, 0, 0}]]).
</pre>

<p> 関数の引数は状態を表すタプルと B の容量と C の容量です。油を注ぐとき、移動先の空き容量をチェックして、油がそれ以下ならば全部注ぎ、そうでなければ満杯になるまで注ぎます。B, C から A へ油を注ぐ場合は、空き容量をチェックする必要はありません。あとは幅優先探索でプログラムを作るだけです。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
&gt; yaep:solve_abura().
[{10,0,0},{3,7,0},{3,4,3},{6,4,0},{6,1,3},{9,1,0},{9,0,1},{2,7,1},{2,5,3},{5,5,0}]
ok
</pre>
<p> 最短手数は 9 手になりました。
</p>

<h4 id="ans64">●解答64</h4>
<pre class="list">
リスト : 油分け算 (2)

% 反復深化
abura_id(Limit, Goal, _, _, Moves) when length(Moves) =:= Limit -&gt;
  if
    hd(Moves) =:= Goal -&gt; io:format('~w~n', [lists:reverse(Moves)]);
    true -&gt; false
  end;
abura_id(Limit, Goal, Mb, Mc, Moves) -&gt;
  lists:foreach(fun(F) -&gt;
                  X = F(hd(Moves), Mb, Mc),
                  case lists:member(X, Moves) of
                    true -&gt; false;
                    false -&gt; abura_id(Limit, Goal, Mb, Mc, [X | Moves])
                  end
                end,
                [fun transfer1/3, fun transfer2/3, fun transfer3/3,
                 fun transfer4/3, fun transfer5/3, fun transfer6/3]).

solve_abura_id() -&gt;
  lists:foreach(fun(N) -&gt; abura_id(N, {5, 5, 0}, 7, 3, [{10, 0, 0}]) end,
                iota(2, 10)).
</pre>
<p> 反復深化のプログラムも簡単ですね。実行結果を示します。
</p>
<pre>
&gt; yaep:solve_abura_id().
[{10,0,0},{3,7,0},{3,4,3},{6,4,0},{6,1,3},{9,1,0},{9,0,1},{2,7,1},{2,5,3},{5,5,0
}]
ok
</pre>
<h4 id="ans65">●解答65</h4>
<p> それではプログラムを作りましょう。正解を見つける方法ですが、質問したコードとその結果を覚えておいて、それと矛盾しないコードを作るようにします。具体的には、4 つの数字の順列を生成し、それが今まで質問したコードと矛盾しないことを確かめます。これは生成検定法と同じですね。
</p>
<p> 矛盾しているかチェックする方法も簡単で、以前に質問したコードと比較して、bulls と cows が等しいときは矛盾していません。たとえば、次の例を考えてみてください。
</p>
<pre class="fig">
[6, 2, 8, 1] が正解の場合

[0, 1, 2, 3] =&gt; bulls = 0, cows = 2

           [0, 1, 2, 3]  と比較する
     --------------------------------------------------------
           [0, X, X, X]  0 から始まるコードは bulls = 1
                         になるので矛盾する。
           ・・・・

           [1, 0, 3, 4]  cows = 3, bulls = 0 になるので矛盾する

           ・・・・

           [1, 0, 4, 5]  cows = 2, bulls = 0 で矛盾しない。
     --------------------------------------------------------

[1, 0, 4, 5] =&gt; bulls = 0, cows = 1

次は、[0, 1, 2, 3] と [1, 0, 4, 5] に矛盾しない数字を選ぶ

        図 : マスターマインドの推測アルゴリズム
</pre>
<p> [0, 1, 2, 3] で bulls が 0 ですから、その位置にその数字は当てはまりません。したがって、[0; X, X, X] というコードは [0, 1, 2, 3] と比較すると bulls が 1 となるので、矛盾していることがわかります。
</p>
<p> 次に [1, 0, 3, 4] というコードを考えてみます。[0, 1, 2, 3] の結果は cows が 2 ですから、その中で合っている数字は 2 つしかないわけです。ところが、[1, 0, 3, 4] と [0, 1, 2, 3] と比較すると cows が 3 になります。当たっている数字が 2 つしかないのに、同じ数字を 3 つ使うのでは矛盾していることになりますね。
</p>
<p> 次に [1, 0, 4, 5] というコードと比較すると、bulls が 0 で cows が 2 となります。これは矛盾していないので、このコードを質問することにします。その結果が bulls = 0, cows = 1 となり、今度は [0, 1, 2, 3] と [1, 0, 4, 5] に矛盾しないコードを選択するのです。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : マスターマインドの解法

% bulls を求める
count_bulls([], []) -&gt; 0;
count_bulls([X | Xs], [X | Ys]) -&gt; 1 + count_bulls(Xs, Ys);
count_bulls([_ | Xs], [_ | Ys]) -&gt; count_bulls(Xs, Ys).

% 同じ数字の個数を求める
count_same_number(Xs, Ys) -&gt; length(intersection(Xs, Ys)).

% 矛盾しない質問かチェックする
check_query(_, []) -&gt; true;
check_query(Code, [{Old_bulls, Old_cows, Old_code} | Qs]) -&gt;
  Bulls = count_bulls(Code, Old_code),
  Cows  = count_same_number(Code, Old_code) - Bulls,
  if
    Bulls =:= Old_bulls andalso Cows =:= Old_cows -&gt; check_query(Code, Qs);
    true -&gt; false
  end.

% マスターマインドの解法
mastermind(Code) -&gt;
  lists:foldl(
    fun(Query, Qs) -&gt;
      case check_query(Query, Qs) of
        true -&gt; Bulls = count_bulls(Query, Code),
                Cows  = count_same_number(Query, Code) - Bulls,
                io:format('~w : bulls ~w, cows ~w~n', [Query, Bulls, Cows]),
                [{Bulls, Cows, Query} | Qs];
        false -&gt; Qs
      end
    end,
    [],
    permutation(4, iota(0, 9))),
  ok.
</pre>
<p> 関数 count_bulls は bulls の個数を求めます。関数 count_same_number は同じ数字の個数を求めます。今回は length(intersection(Xs, Ys)) で求めていますが、count_bulls のように再帰定義でプログラムすることも簡単です。count_same_number で求めた値から bulls を引くと cows を求めることができます。
</p>

<p> 関数 check_query は引数 Code が今まで質問したコードと矛盾していないかチェックします。今まで質問したコードは第 2 引数のリストに格納します。タプルの最初の要素が bulls の個数、次が cows の個数、最後が質問したコードです。次に、Code と Old_code を比較して、Bulls と Cows を求めます。この値が Old_bulls と Old_cows と一致すれば、Code は今までの質問と矛盾していません。check_query を再帰呼び出しして次のデータと比較します。どちらかの値が異なっていれば矛盾しているので false を返します。
</p>

<p> 関数 mastermind の引数 Code が正解のコードです。関数 permutation はリストの中から 4 個の要素を選ぶ順列を生成し、それをリストに格納して返します。あとは lists:foldl でコードを順番に取り出して、今まで質問したコードと矛盾していないか調べます。無名関数の引数 Qs が今までに質問したコードと結果を格納したリストで、Query が質問するコードです。check_query が true を返す場合、Query は矛盾していないので、Code と Query を比較して bulls と cows を求めます。そして、その結果を表示します。
</p>
<p> あとは Qs に今回の結果を追加して返します。code が矛盾している場合は Qs をそのまま返すだけです。bulls が 4 ならば正解です。あとのコードはすべて矛盾することになるので、ここで処理を終了すべきところですが、このプログラムでは最後までチェックしています。興味のある方はプログラムを修正してください。
</p>

<h4>●何回で当たるか</h4>
<p> これでプログラムは完成です。それでは実行例を示しましょう。
</p>
<pre>
&gt; yaep:mastermind([9, 8, 7, 6]).
[0,1,2,3] : bulls 0, cows 0
[4,5,6,7] : bulls 0, cows 2
[5,4,8,9] : bulls 0, cows 2
[6,7,9,8] : bulls 0, cows 4
[8,9,7,6] : bulls 2, cows 2
[9,8,7,6] : bulls 4, cows 0
ok
&gt; yaep:mastermind([9, 4, 3, 1]).
[0,1,2,3] : bulls 0, cows 2
[1,0,4,5] : bulls 0, cows 2
[2,3,5,4] : bulls 0, cows 2
[3,4,0,6] : bulls 1, cows 1
[3,5,6,1] : bulls 1, cows 1
[6,5,0,2] : bulls 0, cows 0
[7,4,3,1] : bulls 3, cows 0
[8,4,3,1] : bulls 3, cows 0
[9,4,3,1] : bulls 4, cows 0
ok
</pre>

<p> 肝心の質問回数ですが、5, 6 回で当たる場合が多いようです。実際に、5040 個のコードをすべて試してみたところ、平均は 5.56 回になりました。これは <a href="yaep03.html#cite">参考文献 [1]</a> の結果と同じです。質問回数の最大値は 9 回で、そのときのコードは [9, 4, 3, 1], [9, 2, 4, 1], [5, 2, 9, 3], [9, 2, 0, 4], [9, 2, 1, 4] でした。
</p>
<p> なお、参考文献 [1] には平均質問回数がこれよりも少なくなる方法が紹介されています。単純な数当てゲームと思っていましたが、その奥はけっこう深いようです。興味のある方はいろいろ試してみてください。
</p>

<h4 id="cite">●参考文献</h4>
<ol>
  <li>田中哲郎, 「数当てゲーム (MOO, マスターマインド) 」, 松原仁、竹内郁雄 編 『bit 別冊 ゲームプログラミング』 pp150 - 157, 共立出版, 1997
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="yaep02.html">PrevPage</a> | <a href="erlang.html#yaep">Erlang</a> | <a href="yaep04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>