<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881749</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ PrevPage | <a href="ocaml.html">OCaml</a> | <a href="ocaml02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">はじめに</h3>
<p> OCaml は ML (Meta Language) という関数型プログラミング言語の一つです。ML は 1970 年代後半に Edinburgh 大学で定理証明を行うシステム Edinburgh LCF を記述するため、R. Minler 博士を中心に開発された言語です。その後、改良が重ねられ、いくつかの ML 処理系が作られました。その中で有名なのが <a href="index.html#sml">SML/NJ (Standard ML of New Jersey)</a> と OCaml (Objective Caml) です。Caml はフランスの INRIA 研究所で開発された ML 処理系で、そこにオブジェクト指向機能を加えたものが OCaml です。
</p>

<p> OCaml は次のサイトからダウンロードできます。Windows 用のバイナリが用意されているので、とても簡単にインストールすることができます。
</p>
<ul>
  <li><a href="http://caml.inria.fr/index.en.html">The Caml Language</a>
</ul>

<h4>●OCaml の特徴</h4>
<p> 関数型言語というと Lisp (Common Lisp, Scheme) が有名です。Lisp の場合、データに型はありますが、変数に型はありません。これに対し ML は強く型づけされた言語で、コンパイル時に静的な型チェックを行うことで、多くのエラーを検出することができます。
</p>

<p> ML で一番有名な機能は「型推論」でしょう。ML はプログラムから変数などのデータ型を見つけてくれるので、プログラマが型を宣言する必要はほとんどありません。推論できない場合にかぎり、ML は型宣言を要求します。この機能により、ML は静的な型チェックを行う「型付きの言語」でありながら、 Lisp のような柔軟なプログラミングが可能になっています。
</p>
<p> この他にも、パターンマッチング、多相型関数、モジュールなど、ML には興味深い機能がたくさんあります。なお、このような特徴は SML/NJ と OCaml で大きな違いはありませんが、文法面ではかなりの違いがあります。ご注意ください。
</p>

<h4>●プログラムの実行</h4>
<p> OCaml はプログラムをコンパイルしてから実行します。OCaml のコンパイラは対話式コンパイラとバッチコンパイラの二種類があります。たとえば、シェルで対話式コンパイラ (ocaml) を起動すると、メッセージとプロンプト # が表示されます。この状態で OCaml のプログラムを入力して簡単に実行することができます。終了する場合は #quit;; と入力してください。
</p>

<p> バッチコンパイラはプログラムをコンパイルして実行可能ファイル (executable file) を生成します。バッチコンパイラは、プログラムをバイトコードにコンパイルする ocamlc と、ネイティブコード (機械語) にコンパイルする ocamlopt の二種類があります。バイトコードにコンパイルされたファイルは、バイトコードインタプリタによって実行されますが、ネイディブコードにコンパイルされたファイルは単独で実行することができます。ただし、Windows の場合は  <a href="http://www.cygwin.com/">Cygwin</a> というパッケージをインストールしておく必要があります。
</p>

<h4>●簡単なベンチマーク</h4>
<p> OCaml はネイティブコードにコンパイルすると、当然ですがプログラムを高速に実行することができます。また、バイトコードにコンパイルする場合でも、スクリプト言語やバイトコードにコンパイルする Lisp 処理系よりも速いようです。そこで、たらいまわし関数を使って実行速度を比較してみました。
</p>
<pre class="list">
リスト : たらいまわし関数

let rec tak x y z = 
  if x &lt;= y then z
  else
    tak (tak (x - 1) y z) (tak (y - 1) z x) (tak (z - 1) x y)

(* 時間計測 *)
let () = 
  let a = Sys.time () in
    ignore (tak 18 9 0);
    print_float (Sys.time () -. a)
</pre>

<p> (* ... *) はコメントを表します。OCaml の場合、コメントは入れ子になってもかまいません。ファイル名を tak.ml とすると、コンパイルは次のように行います。
</p>
<pre>
C&gt;ocamlc -o tak.exe tak.ml

C&gt;tak
</pre>
<p> これで実行ファイル tak.exe が作成されます。あとはそのまま実行するだけです。自動的にバイトコードインタプリタが呼び出されてプログラムが実行されます。ocamlopt の場合も同様にコンパイルすることができます。
</p>
<p> それでは実行結果を示します。tak 18 9 0 を計算しました。比較のため、Python, Ruby, CLISP (Common Lisp), Gauche (Scheme), Ｃ言語 (GCC) の実行結果を示します。GCC 以外の処理系はプログラムをバイトコードにコンパイルするものです。
</p>

<table border=1>
<caption>表 : tak 18 9 0 の結果</caption>
<thead>
  <tr><th>処理系</th><th>秒</th></tr>
</thead>
<tbody>
  <tr><td>Python (ver 2.5.2)</td><td>7.88</td></tr>
  <tr><td>Ruby (ver 1.9,0)</td><td>7.42</td></tr>
  <tr><td>Gauche (ver 0.8.12)</td><td>3.16</td></tr>
  <tr><td>CLISP (ver 2.44)</td><td>2.57</td></tr>
  <tr><td>ocamlc (ver 3.10.0)</td><td>1.22</td></tr>
  <tr><td>gcc (ver 3.4.4)</td><td>0.19</td></tr>
  <tr><td>ocamlopt (ver 3.10.0)</td><td>0.13</td></tr>
</tbody>
</table>
<UL>
  <LI>実行環境 : Windows XP, celeron 1.40 GHz
</UL>
<p> ocamlopt が gcc よりも速いとは驚きました。gcc のコンパイルオプションは -O2 を指定しただけなので、他のオプションを指定するともう少し速くなるかもしれません。興味のある方は試してみてください。バイトコードにコンパイルする場合でも、OCaml は他の処理系より高速です。たらいまわし関数のように、再帰呼び出しの回数が多いテストは関数型言語に有利だったかもしれません。そうだとしても、OCaml のコンパイラは優秀だと思います。
</p>

<h4>●Enjoy Programming!!</h4>
<p> M.Hiroi は OCaml でプログラミングするのは初めてです。このページで簡単なプログラムを作りながら OCaml を勉強していきたいと思っております。たいしたことはできませんが、よろしくお付き合いくださいませ。
</p>
<hr>
<h3 id="chap02">Ocaml の基礎知識</h3>
<h4>●使ってみよう</h4>
<p> それでは、さっそく OCaml を使ってみましょう。Windows の場合、コマンドプロンプトで ocaml を実行すると、対話モード (interactive mode) で OCaml を起動することができます。
</p>
<pre>
C&gt;ocaml
        Objective Caml version 3.10.0

#
</pre>
<p> # は Ocaml のプロンプトです。終了する場合は #quit;; と入力してください。Windows の場合、Ctrl-Z (Ctrl キーを押しながら z を押す）を入力しても終了します。プロンプトのあとに式を入力すると、OCaml は式を評価して結果を返します。
</p>
<pre>
# 1 + 2 * 3;;
- : int = 7
# -3 * 4;;
- : int = -12
</pre>
<p> 対話モードで式を入力する場合、最後にセミコロンを 2 つ ( ;; ) 入力してからリターンキーを押します。;; が入力終了のしるしになります。1 + 2 * 3 の結果を見ると、値が 7 でデータの種類が int であることがわかります。データの種類や種別のことを「データ型」、またはたんに「型」といいます。
</p>
<p> 負の数を表す場合、OCaml は普通の数式と同じく - を使います。SML/NJ の場合は - ではなくチルダ ( ~ ) を使います。OCaml は -3 * 4 のようにマイナス記号を使うことができますが、SML/NJ の場合は ~3 * 4 となります。ご注意ください。
</p>
<h4>●整数と実数</h4>
<p> OCaml の場合、int は整数を表すデータ型で、float が実数を表すデータ型です。整数は 10 進数で表しますが、先頭に 0b (0B) を付けると 2 進数、0o を付けると 8 進数、0x を付けると 16 進数で表すことができます。
</p>
<p> 整数の範囲は、32 bit CPU の処理系で -1073741824 (-2<sup>30</sup>) から 1073741823 (2<sup>30</sup> - 1) になります。これらの値は min_int, max_int として定義されています。また、標準ライブラリ (モジュール) Int32 と Int64 を使うと、32 bit 整数と 64 bit 整数を扱うことができます。
</p>

<p> OCaml の実数は IEEE754 形式という倍精度浮動小数点数で表されていて、正の最大値と最小値は max_float と min_float に定義されています。それから、正の無限大を表す infinity, 負の無限大を表す neg_infinity, 実数でないことを表す nan があります。
</p>

<h4>●算術演算子</h4>
<p> ここで、よく使われる算術演算子をまとめておきましょう。
</p>
<ul>
  <li><b>+</b> 整数の加算
  <li><b>-</b> 整数の減算
  <li><b>*</b> 整数の乗算
  <li><b>/</b> 整数の除算
  <li><b>mod</b> 整数除算の剰余
</ul>
<ul>
  <li><b>+.</b> 実数の加算
  <li><b>-.</b> 実数の減算
  <li><b>*.</b> 実数の乗算
  <li><b>/.</b> 実数の除算
</ul>
<p> OCaml の場合、整数と実数 (浮動小数点数) で用いる演算子が異なります。実数の演算子は後ろにドット ( . ) を付けます。OCaml は型を厳密にチェックするプログラミング言語なので、整数と実数を混在させて計算することはできません。また、OCaml は英大文字と英小文字を区別するので、mod は小文字で入力してください。当然ですが、数式にはカッコ ( ) を使うことができます。
</p>
<pre>
# 1.0 +. 2.0;;
- : float = 3.
# -3 * (5 - 2);;
- : int = 9
</pre>
<p> 整数と実数の変換は関数 int_of_float, float_of_int を使います。
</p>
<pre>
# int_of_float 1.5;;
- : int = 1
# float_of_int 1;;
- : float = 1.
</pre>
<h4>●文字と文字列</h4>
<p> 一つの文字を表すデータ型を文字型 (char) といいます。OCaml の場合、文字は ASCII コードのみで、日本語 (漢字やカナなど) を文字として扱うことはできません。文字は 'a' のように引用符 ' で囲んで表します。' を表す場合はエスケープシーケンスを使います。
</p>
<pre>
# 'a';;
- : char = 'a'
# '\'';;
- : char = '\''
# '\\';;
- : char = '\\'
</pre>
<p> 文字と整数の変換には関数 int_of_char, char_of_int を使います。
</p>
<pre>
# int_of_char 'a';;
- : int = 97
# char_of_int 97;;
- : char = 'a'
</pre>
<p> 文字列 (string) は "foo" や "bar" のように二重引用符 ( " ) で囲みます。Ｃ言語と同様にエスケープシーケンスを使うことできます。たとえば、\n が改行で \t がタブになります。
</p>
<pre>
# "foo";;
- : string = "foo"
# "bar";;
- : string = "bar"
# "foo" ^ "bar";;
- : string = "foobar"
# "foo".[0];;
- : char = 'f'
</pre>
<p> 文字列は演算子 ^ で連結することができます。それから、文字列.[n] という形式で、文字列から n 番目の文字を取り出すことができます。
</p>

<h4>●比較演算子</h4>
<p> 比較演算子は =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;= があります。値が等しいかチェックする述語が = で、等しくないかチェックする述語が &lt;&gt; です。簡単な例を示しましょう。
</p>
<pre>
# 1 = 1;;
- : bool = true
# 1 &lt;&gt; 1;;
- : bool = false
# 1 &lt;&gt; 2;;
- : bool = ture
# 1 &lt; 2;;
- : bool = true
# 1 &gt; 2;;
- : bool = false
# "foo" = "foo";;
- : bool = true
# "foo" = "bar";;
- : bool = false
</pre>
<p> OCaml は真・偽を型 bool で表します。true が真で false が偽になります。比較演算子は整数や実数だけではなく、文字や文字列にも適用することができます。
</p>
<h4>●論理演算子</h4>
<p> OCaml には not, &amp;&amp;, || という論理演算子があります。
</p>
<ul>
  <li><b>not</b> : 否定 (NOT)
  <li><b>&amp;&amp;</b> : 論理積 (AND)
  <li><b>||</b> : 論理和 (OR)
</ul>
<p> 簡単な例を示します。
</p>
<pre>
# 1 &lt; 2 &amp;&amp; 3 &lt; 4;;
- : bool = true
# 1 &lt; 2 &amp;&amp; 3 &gt; 4;;
- : bool = false
# 1 &lt; 2 || 3 &gt; 4;;
- : bool = true
# 1 &gt; 2 || 3 &lt; 4;;
- : bool = true
# 1 &gt; 2 || 3 &gt; 4;;
- : bool = false
</pre>
<h4>●条件分岐</h4>
<p> 条件分岐は if-then-else を使います。if E then F else G は最初に E を評価して、結果が真 (true) であれば式 F を評価し、偽 (false) であれば式 G を評価します。式 F または式 G の評価結果が if の返り値になります。式 F と G の返り値はどんな型でもかまいませんが、同じ型でなければいけません。型が違うとエラーになります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
# if 1 &lt; 2 then 3 * 4 else 5 * 6;;
- : int = 12
# if 1 &gt; 2 then 3 * 4 else 5 * 6;;
- : int = 30
</pre>
<p> OCaml の場合、if-then-else の else は特別な場合を除き省略することができません。ご注意ください。
</p>
<h4>●変数</h4>
<p> 変数 (variable) は let 式で宣言します。
</p>
<pre class="item">
let 名前 = 式
</pre>
<p> Lisp などの関数型言語では、変数に値を割り当てることを「束縛 (binding) 」といいます。純粋な関数型言語の場合、束縛された変数は値を書き換えることができません。手続き型言語は代入により変数の値を書き換えることができますが、純粋な関数型言語に代入操作はありません。ちなみに、Lisp は不純な関数型言語なので、変数の値を書き換えることができます。
</p>
<p> 名前（識別子）は、先頭が英小文字またはアンダースコア ( _ ) で、そのあとに英大文字、英小文字、数字、アポストロフィ ( ' )、アンダースコアが続きます。英大文字で始まる名前は「コンストラクタ」、アポストロフィから始まる名前は「型変数」になるため、変数名や関数名として用いることはできません。ご注意ください。また、OCaml は英大文字と英小文字を区別するので、たとえば foo と fOO は異なる名前になります。コンストラクタと型変数はあとで詳しく説明します。
</p>
<p> OCaml の場合、let で宣言された変数は、値を書き換えることはできません。ただし、OCaml には「配列 (array) 」や「参照 (reference) 」といった値を書き換えることができるデータ型も用意されています。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
# let a = 10;;
val a : int = 10
# a;;
- : int = 10
# let b = 2.0;;
val b : float = 2.
# b;;
- : float = 2.
# let c = "foo";;
val c : string = "foo"
# c;;
- : string = "foo"
</pre>
<p> 対話モードの場合、変数名を入力するとその値が表示されます。なお、OCaml は同じ名前の変数を再定義することができます。
</p>
<pre>
# a;;
- : int = 10
# let a = "foo";;
- : string = "foo"
# a;;
- : string = "foo"
</pre>
<p> トップレベルで変数を再定義すると、元の変数は隠蔽されて値を参照することができなくなります。
</p>
<h4>●組</h4>
<p> OCaml は複数の型を組み合わせて新しい型を定義することができます。OCaml の場合、新しい型の定義方法はいくつかあるのですが、もっとも簡単で重要な方法が「組 (tuple) 」です。組は複数のデータや式をカンマ ( , ) で区切り、カッコ ( ) で囲んで表します。次の例を見てください。
</p>
<pre>
# let a = (1, 2);;
val a : int * int = (1, 2)
# let b = (10, 20.5);;
val b : int * float = (10, 20.5)
# let c = (1, 2.5, "foo");;
val c : int * float * string = (1, 2.5, "foo")
# let d = (1+2, 3*4);;
val d : int * int = (3, 12)
</pre>
<p> 変数 a の組 (1, 2) は整数を 2 つ持っていて、型は int * int になります。このような型を「積型」といいます。積型は複数の型をアスタリスク ( * ) でつなげて表します。変数 b の組 (10, 20.5) は整数と実数なので int * float になります。変数 c の組 (1, 2.5, "foo") は int * float * string になります。また、最後の例のようにカッコの中に式を書くと、それを評価した値が組の要素になります。
</p>
<p> 組は入れ子にしてもかまいません。次の例を見てください。
</p>
<pre>
# let a = ((1, 2), 3);;
val a : (int * int) * int = ((1, 2), 3)
# let b = (1, (2, 3));;
val b : int * (int * int) = (1, (2, 3))
</pre>
<p> 変数 a の組は、第 1 要素が int * int の組で、第 2 要素が int です。これを (int * int) * int と表します。変数 b の組は、第 1 要素が int で第 2 要素が int * int の組になります。これを int * (int * int) と表します。どちらの組も 3 つの整数が含まれていますが、型は異なることに注意してください。
</p>

<p> 組から要素を取り出すには、「パターンマッチング (pattern matching) 」という機能を使います。次の例を見てください。
</p>
<pre>
# let (a, b) = (1, 2);;
val a : int = 1
val b : int = 2
# let (a, b) = ((1, 2), 3);;
val a : int * int = (1, 2)
val b : int = 3
# let ((c, d), e) = ((1, 2), 3);;
val c : int = 1
val d : int = 2
val e : int = 3
</pre>
<p> let 式の右辺 (a, b) がパターンを表します。要素が 2 つ並んでいるので、2 要素の組を表すパターンになります。パターン (a, b) と左辺の (1, 2) を照合して、変数部分に対応する要素を取り出します。そして、変数をその値に束縛します。次の例のように、(a, b) と ((1, 2), 3) を照合すると、a は (1, 2) になり、b は 3 になります。
</p>
<p> パターンは入れ子にしてもかまいません。((c, d), e) と ((1, 2), 3) を照合すると、c = 1, d = 2, e = 3 となります。このように、パターンを使って組の要素を取り出すことができます。ただし、型が違うと照合に失敗してエラーになるので注意してください。
</p>

<h4>●関数</h4>
<p> OCaml は関数も let で定義します。
</p>
<pre class="item">
let 名前 引数 = 式
</pre>
<p> let のあとに名前と引数を書き、= のあとに引数を含む式を書きます。たとえば、引数を 2 倍する関数 times2 を定義すると次のようになります。
</p>
<pre>
# let times2 x = x * 2;;
val times2 : int -&gt; int = &lt;fun&gt;
# times2 4;;
- : int = 8
</pre>
<p> 関数型言語の場合、関数もデータ型の一つです。let で指定した名前が times2 であれば、変数 times2 の値は関数型のデータになります。&lt;fun&gt; は値が関数であることを表し、型は "引数の型 -&gt; 返り値の型" で表します。この型を見ると、関数 times2 は引数に int をひとつ取り、int を返すことがわかります。
</p>
<p> ここで、引数や返り値の型を指定しなくても、OCaml が型を決めていることに注意してください。この機能を「型推論」といいます。times2 は引数と整数 2 の乗算を行っているので、引数は int で返り値も int になるはずです。このように OCaml が型を推論してくれるので、私達が型を指定しなくてもプログラムすることができます。
</p>

<p> 複数の引数を持つ関数を定義する場合は組を使うと簡単です。次の例を見てください。
</p>
<pre>
# let f (x, y) = 2 * x + 3 * y;;
val f : int * int -&gt; int = &lt;fun&gt;
# f (1, 2);;
- : int = 8
</pre>
<p> 関数 f は 2 つの引数 x, y を受け取ります。ここで関数 f の型 int * int -&gt; int を見てください。引数の型が int * int の積型になっていますね。実をいうと、OCaml の関数は引数を一つしか受け取ることができません。複数の引数は組にして関数に渡します。つまり、関数呼び出し f (1, 2) は、組 (1, 2) に関数 f を適用するという意味なのです。
</p>

<p> 組を使えば複数の値を返す関数も簡単に作ることができます。次の例を見てください。
</p>
<pre>
# let foo (x, y) =
  if x = y then (0, 0)
  else if x &lt; y then (-1, y - x)
  else (1, x - y);;
val foo : int * int -&gt; int * int = &lt;fun&gt;
# foo (10, 20);;
- : int * int = (-1, 10)
# foo (20, 10);;
- : int * int = (1, 10)
# foo (10, 10);;
- : int * int = (0, 0)
</pre>
<p> 関数 foo は引数 x と y の差分の絶対値を計算し、符号とその値を返します。if-then-else は else if でつなぐことができます。x = y ならば (0, 0) を返します。x &lt; y ならば (-1, y - x) を返し、x &gt; y ならば (1, x - y) を返します。このように、組を使って複数の値を返すことができます。
</p>

<h4>●局所変数と大域変数</h4>
<p> 関数の引数は「局所変数 (local variable) 」として扱われます。局所変数は「有効範囲 (scope : スコープ) 」が決まっています。引数の有効範囲は、関数が定義されている式の中だけです。次の例を見てください。
</p>
<pre>
# let x = 10;;
val x : int = 10
# let y = 20;;
val y : int = 20
# let bar y = x + y;;
val bar : int -&gt; int = &lt;fun&gt;
# bar 100;;
- : int = 110
</pre>
<p> 局所変数として定義されていない変数は「大域変数 (global variable) 」になります。大域変数はどこからでも値を参照することができます。対話モードで変数を定義すると、それらの変数は大域変数になります。最初に定義した変数 x と y は大域変数です。
</p>

<p> 関数 bar は、引数が y で式は x + y です。関数を呼び出す場合、引数用に新しいメモリを割り当てて、そこに与えられた値で引数を束縛します。大域変数 y と引数 y は同じ名前ですが、異なる変数になるのです。そして、局所変数が定義されていれば、その値が参照されます。局所変数が定義されていない場合、大域変数の値が参照されます。したがって、式の中の y は引数 y を参照し、bar の引数に x がないので、式の中の x は大域変数 x を参照します。よって、bar 100 は 10 + 100 = 110 になります。これを図に示すと次のようになります。
</p>

<pre class="fig">
┌─────  OCaml system  ─────┐
│                                    │
│      大域変数  y                   │
│      大域変数  x ←──────┐  │
│                                │  │
│    ┌─ 関数 bar  引数 y ─┐  │  │
│    │                  ↑  │  │  │
│    │            ┌──┘  │  │  │
│    │        x + y         │  │  │
│    │        └──────┼─┘  │
│    └───────────┘      │
│                                    │
└──────────────────┘

        図 : 大域変数と局所変数
</pre>
<p> 関数 bar を実行するとき、関数 bar の枠が作成されると考えてください。このとき、引数用に新しいメモリが割り当てられ、新しい局所変数 y が作成されるわけです。関数の実行が終了すると枠が壊されて、作成された局所変数も廃棄されます。関数 bar の場合、引数 y が廃棄されるので、対話モードでは大域変数 y の値を参照することができます。このように、関数の引数は関数定義されている式の中だけ有効なのです。
</p>

<p> ところで、関数の中で引数以外の局所変数を定義できると便利です。OCaml の場合、let 式で局所変数を定義することができます。
</p>
<pre class="item">
let 変数 = 式1 in 式2
</pre>
<p> この let 式は、最初に 式1 を評価します。そして、変数をその結果に束縛して、式2 を評価します。その評価結果が let 式の返り値になります。なお、式1 や式2 が let 式でもかまいません。また、let 式を使って局所的な関数を定義することもできます。変数の有効範囲は let 式の中だけ、つまり式 2 の中だけになります。
</p>
<p> たとえば、2 点間の距離を求める関数 distance を作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 2 点間の距離を求める (1)

let distance ((x1, y1), (x2, y2)) =
  let dx = x1 -. x2 in
  let dy = y1 -. y2 in
  sqrt (dx *. dx +. dy *. dy)
</pre>
<p> 点の座標は組 (x, y) で表します。引数として 2 つの組 (x1, y1), (x2, y2) を受け取ります。x 座標の差分を局所変数 dx に、y 座標の差分を局所 dy に求めます。あとは、√(dx *. dx +. dy *. dy) を計算するだけです。
</p>
<p> 簡単な実行例を示しましょう。OCaml の対話モードにはディレクティブというコマンドがあり、#use "filename" でソースファイルを読み込むことができます。たとえば、ファイル名が distance.ml とすると、対話モードで次のように入力します。
</p>
<pre>
# #use "distance.ml";;
val distance (float * float) * (float * float) -&gt; float = &lt;fun&gt;
</pre>
<p> 読み込んだプログラムはコンパイルされて、関数 distance の型が表示されます。これで distance を呼び出すことができます。
</p>
<pre>
# let p1 = (0.0, 0.0);;
val p1 : float = (0., 0.)
# let p2 = (10.0, 10.0);;
val p2 : float = (10., 10.)
# distance (p1, p2);;
- : float = 14.142135623730951
</pre>
<p> 座標を表す組を変数に定義して、それを distance に渡します。すると、パターンマッチングにより、組の要素が取り出されて変数 x1, y1, x2, y2 にセットされます。
</p>
<p> また、let 式は次のように and を使って複数の変数を定義することもできます。
</p>
<pre class="list">
リスト : 2 点間の距離を求める (2)

let distance ((x1, y1), (x2, y2)) =
  let dx = x1 -. x2 and dy = y1 -. y2 in
  sqrt (dx *. dx +. dy *. dy)
</pre>
<p> OCaml の場合、and は論理演算子ではありません。ご注意くださいませ。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="ocaml.html">OCaml</a> | <a href="ocaml02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>