<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881791</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell25.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell27.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">乱数</h3>
<p> 今回は「乱数 (random numbers) 」について簡単に説明します。なお、このドキュメントは拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo18.html">乱数 [1]</a> <a href="../light/pyalgo19.html">[2]</a> と内容が一部重複しております。あしからずご了承くださいませ。
</p>

<h4>●乱数とは？</h4>
<p> 私たちが適当な数字を決める場合、サイコロを使えば 1 から 6 までの数字を簡単に決めることができます。たとえば、サイコロを振って出た目を記録したら次のようになったとしましょう。
</p>
<pre class="item">
5, 2, 1, 2, 6, 3, 4, 3, 1, 5, .....
</pre>
<p> サイコロの目はイカサマをしないかぎり、出る確率が 1 / 6 で規則性はまったくありません。したがって、数字の出る順番には規則性はなく、まったくでたらめになります。いま 2 が出たから次は 1 が出るとか、3, 4 と続いたから次は 5 が出るなどのように、前に出た数字から次に出る数字を予測することはできません。このように、でたらめに並んだ数列を「乱数列 (random sequence) 」といい、乱数列の中のひとつひとつの数字を乱数 (random numbers) といいます。
</p>

<p> コンピュータは決められた手順（プログラム）を高速に実行することは得意なのですが、まったくでたらめの数を作れといわれると、とたんに困ってしまいます。そこで、何かしらの数式をプログラムして、それを実行することで乱数を発生させます。厳密にいえば乱数ではありませんが、それを乱数としてみなして使うことにするのです。このような乱数を「疑似乱数 (pseudo-random numbers) 」といいます。
</p>

<h4>●擬似乱数の性質</h4>
<p> 乱数には重要な性質が 2 つあります。ひとつは「等確率性 (等出現性) 」です。たとえば、サイコロの目はイカサマをしないかぎり、出る確率が 1/6 になります。したがって、サイコロを振る回数 (試行回数 n) を増やしていくと、どの目も出現する回数は理論値 (n / 6) に限りなく近づいていきます。このような確率的な性質を「大数の法則」といいます。そして、ある範囲の整数値が等確率で現れる乱数を「整数の一様乱数」といいます。実数の一様乱数は、整数の一様乱数から生成することができます。
</p>

<p> もうひとつの重要な性質が「無規則性 (独立性) 」です。たとえば、サイコロには規則性がないので、目の出る順番はまったくでたらめになります。いま 2 が出たから次は 1 が出るとか、3, 4 と続いたから次は 5 が出るなどのような規則性はありません。ようするに、以前に出現した数によって次に出現する数が決まるようなことはないのです。これが無規則性で、出現した各数には相関性がないことから、無相関性とか独立性と呼ばれることもあります。
</p>

<p> ただし、コンピュータで生成する擬似乱数の場合、無規則性を完全に実現することはできない、ということに注意してください。一般的な擬似乱数のアルゴリズムは、コンピュータのメモリに現在の状態 (数値) を記憶しておきます。乱数を生成するとき、メモリの内容をある手順 (A) で書き換えて新しい状態へ移行します。そして、その状態をある手順 (B) で数値に変換し、それを乱数として出力します。これを繰り返すことで乱数列を生成しています。
</p>

<p> ここで、手順 (A) や (B) をどんなに複雑なものにしたとしても、あらかじめ「決められた手順 (アルゴリズム) 」を実行していることにかわりはありません。したがって、擬似乱数の規則性をゼロにすることは原理的に不可能というわけです。また、コンピュータにあるメモリは有限なので、擬似乱数は周期性を持つこともわかるでしょう。
</p>

<p> これに対し、何らかの物理的現象 (たとえば電子回路の熱雑音など) を利用して乱数を生成する方法があります。このような方法で生成された乱数を「物理乱数」と呼ぶ場合があります。物理乱数は規則性がまったくないので、まさに「真の乱数」といえるでしょう。そのかわり、同じ乱数列を再現するには、発生した乱数を記憶しておかない限り不可能です。つまり、物理乱数には「再現性」がまったくないのです。
</p>

<p> 擬似乱数は真の乱数ではありませんが、物理乱数にはない「再現性」があります。擬似乱数は、種 (シード) に同じ値を設定することで同じ乱数列を簡単に発生させることができます。シミュレーションやモンテカルロ法などの実験で乱数を用いる場合、この機能はとても役に立ちます。シードに別な値を設定すれば、異なる乱数列を簡単に発生させることができますし、シードに同じ値を与えれば、追試も簡単に行うことができます。
</p>

<h4>●乱数生成器</h4>
<p> Haskell の場合、モジュール System.Random をインポートすると乱数を簡単に生成することができます。乱数を表す型クラスが Random です。ghci の :info コマンドで Random を調べると次のように表示されます。
</p>
<pre>
Prelude> :m System.Random
Prelude System.Random&gt; :i Random
class Random a where
  randomR :: RandomGen g =&gt; (a, a) -&gt; g -&gt; (a, g)
  random :: RandomGen g =&gt; g -&gt; (a, g)
  randomRs :: RandomGen g =&gt; (a, a) -&gt; g -&gt; [a]
  randoms :: RandomGen g =&gt; g -&gt; [a]
  randomRIO :: (a, a) -&gt; IO a
  randomIO :: IO a
        -- Defined in `System.Random'
instance Random Integer -- Defined in `System.Random'
instance Random Int -- Defined in `System.Random'
instance Random Float -- Defined in `System.Random'
instance Random Double -- Defined in `System.Random'
instance Random Char -- Defined in `System.Random'
instance Random Bool -- Defined in `System.Random'
</pre>
<p> RandomGen は「乱数生成器」を表す型クラスです。
</p>
<pre>
Prelude System.Random&gt; :i RandomGen
class RandomGen g where
  next :: g -&gt; (Int, g)
  genRange :: g -&gt; (Int, Int)
  split :: g -&gt; (g, g)
        -- Defined in `System.Random'
instance RandomGen StdGen -- Defined in `System.Random'
</pre>
<p> RandomGen は整数の一様乱数を生成します。その範囲は genRange の返り値 (Int, Int) で表します。next は乱数を生成して新しい乱数生成器といっしょにタプルに格納して返します。split は二つの新しい乱数生成器をタプルに格納して返します。なお、実際に乱数を使用するときは next を使うのではなく、型クラス Random に定義されている関数を使います。
</p>
<p> Haskell で乱数を生成する場合、何らかの乱数生成器が必要になります。System.Random に用意されている乱数生成器が StdGen です。
</p>
<pre>
Prelude System.Random&gt; :i StdGen
data StdGen = System.Random.StdGen GHC.Int.Int32 GHC.Int.Int32
        -- Defined in `System.Random'
instance Read StdGen -- Defined in `System.Random'
instance Show StdGen -- Defined in `System.Random'
instance RandomGen StdGen -- Defined in `System.Random'
</pre>
<p> StdGen を生成する関数が mkStdGen です。
</p>
<pre class="item">
mkStdGen :: Int -&gt; StdGen
</pre>
<p> mkStdGen は整数 (Int) から StdGen を生成します。また、Haskell は起動時にシステム内の適当な値 (たとえば時刻など) を使って StdGen をひとつ生成します。この値は大域変数 getStdGen に格納されています。
</p>
<pre class="item">
getStdGen :: IO StdGen
</pre>
<p> それでは実際に試してみましょう。
</p>
<pre>
Prelude System.Random&gt; let g = mkStdGen 11
Prelude System.Random&gt; g
12 1
Prelude System.Random&gt; genRange g
(0,2147483562)
Prelude System.Random&gt; let (n1, g1) = next g
Prelude System.Random&gt; n1
439476
Prelude System.Random&gt; g1
480168 40692
Prelude System.Random&gt; next g1
(377734984,2033573848 1655838864)
Prelude System.Random&gt; mkStdGen 256
257 1
Prelude System.Random&gt; mkStdGen 123456789
123456790 1
Prelude System.Random&gt; a &lt;- getStdGen
Prelude System.Random&gt; a
620536502 1780294415
</pre>
<p> このように、StdGen は二つの整数 (Int32) で構成されています。
</p>

<h4>●乱数の取得</h4>
<p> 乱数生成器から乱数を取得する基本的な関数が randomR です。
</p>
<pre class="item">
randomR :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; (a, g)
</pre>
<p> randomR は生成する乱数の範囲と乱数生成器を受け取り、乱数と新しい乱数生成器を返します。同じ乱数生成器を渡すと同じ乱数しか生成しません。返された乱数生成器を使って新しい乱数を生成します。ご注意くださいませ。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude System.Random&gt; let (n1, g1) = randomR (1, 6) (mkStdGen 11)
Prelude System.Random&gt; n1
6
Prelude System.Random&gt; g1
480168 40692
Prelude System.Random&gt; let (n2, g2) = randomR (1, 6) g1
Prelude System.Random&gt; n2
4
Prelude System.Random&gt; g2
2033573848 1655838864
Prelude System.Random&gt; let (n3, g3) = randomR (1, 6) g2
Prelude System.Random&gt; n3
4
Prelude System.Random&gt; g3
1124268239 2103410263
</pre>
<p> 関数 randomRs は乱数をリストに格納して返します。返り値は遅延リスト (無限リスト) になることに注意してください。
</p>
<pre class="item">
randomRs :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; [a]
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude System.Random&gt; let xs = randomRs (1, 6) (mkStdGen 11)
Prelude System.Random&gt; take 16 xs
[6,4,4,6,1,2,6,5,6,5,3,2,2,2,4,4]
Prelude System.Random&gt; let ys = randomRs ('a', 'z') (mkStdGen 11)
Prelude System.Random&gt; take 26 ys
"nfphiftavkkpbxvncelmkqczaj"
</pre>

<p> 関数 random, randoms は randomR, randomRs と似ていますが、生成する乱数の範囲の指定がありません。
</p>
<pre class="item">
random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)
randoms :: (RandomGen g, Random a) =&gt; g -&gt; [a]
</pre>
<p> 乱数の範囲は指定したデータ型の (最小値, 最大値) となります。Integer の場合は Int と同じになります。実数の場合は 0 以上 1.0 未満になります。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude System.Random&gt; let (n1, g1) = random (mkStdGen 11) :: (Integer, StdGen)
Prelude System.Random&gt; n1
-1807975507
Prelude System.Random&gt; g1
2033573848 1655838864
Prelude System.Random&gt; let (n2, g2) = random g1 :: (Integer, StdGen)
Prelude System.Random&gt; n2
545074951
Prelude System.Random&gt; g2
983637622 1872071452
Prelude System.Random&gt; let (n3, g3) = random g2 :: (Integer, StdGen)
Prelude System.Random&gt; n3
-1015194702
Prelude System.Random&gt; g3
1908496843 1780294415
Prelude System.Random&gt; let xs = randoms (mkStdGen 11) :: [Integer]
Prelude System.Random&gt; take 10 xs
[-1807975507,545074951,-1015194702,-1622477312,-502893664,1176339218,-389023779,
-2131253277,1286507251,-1190640000]
Prelude System.Random&gt; let ys = randoms (mkStdGen 11) :: [Double]
Prelude System.Random&gt; take 5 ys
[0.832860419682741,0.856226244307752,5.792986567167446e-2,0.8722830042198232,
0.12274746865219488]
</pre>
<h4>●大域乱数発生器から乱数を取得する</h4>
<p> 大域変数 getStdGen から乱数を取得する場合は、関数 getStdRandom, randomIO, randomRIO を使うと簡単です。
</p>
<pre class="item">
getStdRandom :: (StdGen -&gt; (a, StdGen)) -&gt; IO a
randomIO :: Random a =&gt; IO a
randomRIO :: Random a =&gt; (a, a) -&gt; IO a
</pre>
<p> getStdRandom は引数に random や randomR を受け取って、返り値を変数に束縛します。このあと、その変数を参照するたびに乱数が生成されます。もっと簡単なのが randomIO と randomRIO です。randomIO は参照するたびに乱数が生成され、randomRIO は呼び出すたびに乱数が生成されます。当然ですが、これらの動作はすべて I/O アクションになります。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude System.Random&gt; let rand = getStdRandom random :: IO Integer
Prelude System.Random&gt; rand
-1378790601
Prelude System.Random&gt; rand
-526443969
Prelude System.Random&gt; rand
-1173262755
Prelude System.Random&gt; rand
-49930197
Prelude System.Random&gt; let dice = getStdRandom (randomR (1,6))
Prelude System.Random&gt; dice
6
Prelude System.Random&gt; dice
1
Prelude System.Random&gt; dice
1
Prelude System.Random&gt; dice
6
Prelude System.Random&gt; dice
5
Prelude System.Random&gt; dice
4
Prelude System.Random&gt; randomIO :: IO Integer
-503676392
Prelude System.Random&gt; randomIO :: IO Integer
1274879456
Prelude System.Random&gt; randomIO :: IO Double
0.42562008665406914
Prelude System.Random&gt; randomIO :: IO Double
0.7335523318618027
Prelude System.Random&gt; randomRIO (1, 6)
6
Prelude System.Random&gt; randomRIO (1, 6)
4
Prelude System.Random&gt; randomRIO (1, 6)
5
Prelude System.Random&gt; randomRIO (0.0, 1.0)
0.4155559038575266
Prelude System.Random&gt; randomRIO (0.0, 1.0)
0.301620339254129
Prelude System.Random&gt; randomRIO (0.0, 1.0)
0.3492708550303971
</pre>
<h4>●モンテカルロ法</h4>
<p> それでは、乱数を使った簡単な応用例を示しましょう。乱数を使って数学や物理などの問題を解くアルゴリズムを「モンテカルロ法 (Monte Carlo methods) 」といいます。簡単な例として、円周率πをモンテカルロ法で求めてみます。
</p>

<p> 正方形の領域 (0 &lt;= x &lt;= 1, 0 &lt;= y &lt;= 1) に乱数で点を打ちます。乱数であれば点は領域内に一様に分布するので、x2 + y2 &lt;= 1 の円内に入る確率は π/4 になります。つまり、(円内の点の個数 / 点の総数) の値は 0.7853... になるはずです。たくさん点を打つほど値は π/4 に近づくはずですが、コンピュータの乱数は疑似乱数なので規則性が生じてしまい、値の精度にはどうしても限界があります。それでも、性能の良い疑似乱数ほど π/4 に近い値になるでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : モンテカルロ法（πを求める）

import System.Random

test :: Int -&gt; IO Double
test n = iter n 0.0
  where iter 0 a = return (a * 4 / (fromIntegral n))
        iter m a = do
          x &lt;- randomRIO (0.0, 1.0) :: IO Double
          y &lt;- randomRIO (0.0, 1.0)
          if x * x + y * y &lt;= 1.0
            then iter (m - 1) (a + 1)
            else iter (m - 1) a
</pre>
<p> 簡単なプログラムなので説明は省略します。リストを読んでくださいね。それでは実行結果を示します。
</p>
<pre>
*Main&gt; test 1000000
3.14152
*Main&gt; test 1000000
3.141584
*Main&gt; test 1000000
3.143424
*Main&gt; test 1000000
3.139412
*Main&gt; test 1000000
3.143008
</pre>
<p> このように、乱数を使ってπの近似値を求めることができます。
</p>
<h4>●乱数とクイックソート</h4>
<p> 次は、乱数を使って最悪のケースを回避する方法を紹介します。拙作のページ <a href="haskell25.html">配列のソート (2)</a> で説明したクイックソートは、枢軸 (pivot) を基準にして大きなデータと小さなデータの 2 つの区間に分けてソートを行います。このとき、pivot の選び方でクイックソートの効率は大きく左右されます。最悪のケースが最小値または最大値を選ぶ場合で、クイックソートの実行時間はデータ数の 2 乗に比例する遅いソートになってしまいます。
</p>

<p> このため、ソートする区間から数個のデータを選び、その中から中央の値を枢軸に選ぶ方法があります。この方法は <a href="haskell25.html">配列のソート (2)</a> で詳しく説明しました。このほかに、もう一つ方法があります。それが乱数で枢軸を選ぶ方法です。次のリストを見てください。
</p>
<pre class="list">
リスト : クイックソート (乱択アルゴリズム)

quickSortR :: IOUArray Int Int -&gt; IO ()
quickSortR buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    selectPv low high = do
      a &lt;- randomRIO (low, high)
      x &lt;- readArray buff a
      return x
    qsort low high = do
      pv &lt;- selectPv low high
      (i, j) &lt;- partition pv low high
      when (low &lt; i - 1)  $ qsort low (i - 1)
      when (high &gt; j + 1) $ qsort (j + 1) high
</pre>
<p> 区間 low, high の中から枢軸 pivot を選ぶ関数 selectPv の中で randomRIO を使っています。区間の中央を枢軸にすると、山型データが最悪のケースになり、要素数の二乗に比例する遅いソートになってしまいます。この場合、枢軸をランダムで選ぶことにより、最悪のケースを回避することができます。もちろん、完璧に回避できるわけではありませんが、最悪のケースを何回も続けて選ぶ確率は相当に低くなると思われます。山型データでも高速にソートできるでしょう。
</p>

<p> 実行結果は次のようになりました。
</p>
<pre>
   表 : quickSortR の結果 (単位 : 秒)

   [IOUArray]
   個数    乱数   昇順   逆順   山型
  -----------------------------------
   80000 : 0.062  0.042  0.036  0.062
  160000 : 0.130  0.078  0.078  0.125
  320000 : 0.265  0.156  0.166  0.239
  640000 : 0.536  0.322  0.333  0.499

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>

<p> 乱数を生成する分だけ、実行速度はどうしても遅くなってしまいます。ですが、山型データでも高速にソートすることができました。このように、乱数を使うことにより、簡単な方法で最悪のケースを回避することができます。
</p>

<h4>●線形合同法</h4>
<p> 最後に「線形合同法」という簡単な方法を使って乱数を生成するプログラムを作ってみましょう。線形合同法は適当な初期値からスタートして、次の漸化式で乱数を生成します。
</p>
<pre class="item">
X<sub>i</sub> = (A * X<sub>i-1</sub> + C) mod M
</pre>
<p> これで 0 以上 M 未満の値を生成することができます。A, C, M の選び方は <a href="haskell26.html#cite">参考文献 1</a> より引用します。
</p>
<blockquote><cite>
<p> M が 2 の累乗なら A mod 8 を 5 または 3 とし（5 の方が安全）、定数項 C を奇数とする。このとき、周期はちょうど M となり、その 1 周期分には 0 から M - 1 までの整数が 1 個ずつ現れる。
</p>
<p> 高速にするには C = 0 とし、初期値 X<sub>0</sub> を奇数にする。ただし、周期は M / 4 になる。
</p>
</cite></blockquote>
<p> C = 0 の場合を「乗算合同法」といいます。初期値のことを「種 (seed) 」と呼ぶ場合があります。
</p>

<p> それでは実際にプログラムを作って確かめてみましょう。簡単な例として、M を 16 にして 0 - 15 の乱数を生成します。
</p>
<pre>
Prelude&gt; let rand g = (g, (13 * g + 1) `mod` 16)
Prelude&gt; let rands g = let (n, g') = rand g in n : rands g'
Prelude&gt; let xs = rands 1
Prelude&gt; take 16 xs
[1,14,7,12,13,10,3,8,9,6,15,4,5,2,11,0]
Prelude&gt; take 32 xs
[1,14,7,12,13,10,3,8,9,6,15,4,5,2,11,0,1,14,7,12,13,10,3,8,9,6,15,4,5,2,11,0]
</pre>

<p> 関数 rand は 1 周期が 16 で、0 から 15 までの値を 1 個ずつ生成していることがわかります。
</p>

<p> 実際には M の値を 2<sup>32</sup> のように大きくして周期を長くします。次のリストを見てください。
</p>

<pre class="list">
リスト : 線形合同法

module Rand where

import Data.Word

-- 乱数生成器の定義
newtype RandGen = RandGen {seed :: Word32} deriving Show

mkRandGen :: Int -&gt; RandGen
mkRandGen n = RandGen (fromIntegral n)

-- 整数の一様乱数
rand :: RandGen -&gt; (Integer, RandGen)
rand g = (fromIntegral (seed g), RandGen (69069 * seed g + 1))

rands :: RandGen -&gt; [Integer]
rands g =
  let (n, g') = rand g
  in n : rands g'

-- 実数の一様乱数
random :: RandGen -&gt; (Double, RandGen)
random g =
  let (n, g') = rand g
  in (1.0 / 4294967296.0 * (0.5 + fromIntegral n), g')

randoms :: RandGen -&gt; [Double]
randoms g =
  let (n, g') = random g
  in n : randoms g'
</pre>
<p> newtype で乱数生成器 RandGen を定義します。RandGen には無符号 32 ビット整数 Word32 を格納します。これで mod 2<sup>32</sup> の計算を省くことができます。関数 mkRandGen は整数から RandGen を作ります。fromIntegral で Int を Word32 に変換するだけです。
</p>
<p> 関数 rand は RandGen に格納されている値を乱数として返します。生成される乱数の範囲は 0 以上 2<sup>32</sup> (4294967296) 未満になります。乱数のデータ型は Integer としました。このとき、次の乱数を計算して新しい RandGen を生成し、乱数と RandGen をタプルに格納して返します。関数 rands は乱数をリストに格納して返します。遅延リスト (無限リスト) になることに注意してください。
</p>

<p> 整数の次は実数です。<a href="haskell26.html#cite">参考文献 1</a> によると、0 以上 1 未満の範囲の実数の一様乱数 U は、整数の一様乱数を生成する関数 rand を使って次式のように作ることができるそうです。
</p>
<pre class="item">
(1) U = (1.0 / (RAND_MAX + 1.0)) * (rand() + 0.5)
(2) U = (1.0 / (RAND_MAX + 1.0)) * rand()
</pre>
<p> RAND_MAX は関数 rand() が生成する乱数の最大値を表します。式 (1) は <CITE>『正確に 0 や 1 になることがないので、対数 log( U ) を求める際にも安心である。』 </CITE> とのことですが、通常は式 (2) で十分だそうです。関数 random は式 (1) で 0 以上 1 未満の実数を生成します。関数 randoms は実数の乱数をリストに格納して返します。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
*Rand&gt; let xs = rands (mkRandGen 1)
*Rand&gt; take 10 xs
[1,69070,475628535,3277404108,772999773,3877832058,3821835443,1662200408,2044158073,3788989926]
*Rand&gt; let ys = rands (mkRandGen 123456789)
*Rand&gt; take 10 ys
[123456789,1526876882,1232376875,1376507248,583047857,919067838,3774835239,2400386108,2235500557,4008647530]
*Rand&gt; let xs1 = randoms (mkRandGen 1)
*Rand&gt; take 10 xs1
[3.4924596548080444e-10,1.6081728972494602e-5,0.11074089806061238,0.7630801080958918,
0.17997803480830044,0.9028781341621652,0.8898404062492773,0.38701119099278003,
0.47594263998325914,0.8821929633850232]
*Rand&gt; let ys1 = randoms (mkRandGen 123456789)
*Rand&gt; take 10 ys1
[2.8744523762725294e-2,0.35550372733268887,0.28693510114680976,0.32049306866247207,
0.13575140794273466,0.2139871563995257,0.8788973185000941,0.5588834426598623,
0.5204930336913094,0.93333598470781]
</pre>

<h4>●線形合同法の欠点</h4>
<p> このように、線形合同法はとても簡単なアルゴリズムなのですが、使用上の注意点がいくつかあります。<a href="haskell26.html#cite">参考文献 1</a> によると、線形合同法には一般に次の欠点があるそうです。
</p>
<blockquote><cite>
<ol>
  <li>合同法乱数は、上位の桁はランダムだが、下位の桁はランダムでない
  <li>合同法乱数は、1 個ずつ使えばランダムだが、いくつか組にして使えばランダムでない
</cite></blockquote>
<p> まず、1 から説明します。線形合同法の場合、下位 k bit だけを見ると周期は高々 2 <sup>k</sup> になります。たとえば、線形合同法で生成した乱数 N から、0 以上 8 未満の乱数を作ってみましょう。この場合、N mod 8 として乱数を生成すると周期が 8 にしかなりません。下位 3 bit ではなく、上位 3 bit を使った方が良いようです。
</p>
<p> それでは、実際に確かめてみましょう。線形合同法のプログラムで、上位 3 bit と下位 3 bit の値を出力します。結果は次のようになりました。
</p>
<pre class="fig">
     rand    L   H  (L:下位 3 bit, H:上位 3 bit)
------------------
         1,  1,  0
     69070,  6,  0
 475628535,  7,  0
3277404108,  4,  6
 772999773,  5,  1
3877832058,  2,  7
3821835443,  3,  7
1662200408,  0,  3
2044158073,  1,  3
3788989926,  6,  7
 797919023,  7,  1
2743624612,  4,  5
1156259413,  5,  2
1059494674,  2,  1
 584849259,  3,  1
 786050992,  0,  1
3369345009,  1,  6
</pre>
<p> 下位 3 bit で乱数を生成すると、周期が 8 にしかならないことがわかります。また、rands の結果を見ると、偶数と奇数が交互に出現しています。これも線形合同法の特徴 (欠点) です。このように、線形合同法の下位の桁には規則性があるのです。
</p>

<p> 次は、もう一つの欠点 2 について説明します。たとえば 0 から 15 までの乱数で、(x, y) の座標を生成することを考えます。ここで周期 16 の線形合同法で乱数を生成してみましょう。すると、生成される (x, y) の座標は 16 / 2 =  8 通りにしかなりません。(x, y) の座標は 256 個もあるのに、8 個の座標しか生成できないのです。(x, y, z) の場合は 4096 個の座標があるのに、16 個の座標しか生成できません。極端な例ですが、これが線形合同法の欠点になります。
</p>

<p> 線形合同法の欠点の詳細な説明と改良方法については、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo18.html">乱数 [1]</a> をお読みください。
</p>

<h4 id="cite">●参考文献</h4>
<ol>
  <li> 奥村晴彦, 『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</ol>
</section>
<hr>
<section class="contents">
<h3 id="chap02">●選択アルゴリズム</h3>
<p> N 個のデータのうち小さい方から数えて k 番目の値を求める方法を「選択アルゴリズム (Selection Algorithm) 」と呼びます。簡単な方法はクイックソートなどでソートすることですが、データ数 N が多くなるとクイックソートでも N * log<sub>2</sub> N に比例する時間が必要になります。ところが、クイックソートを変形することで、データ数 N に比例する程度の時間で k 番目のデータを求めることができます。これを「クイックセレクト (quick select) 」と呼びます。
</p>

<h4>●クイックセレクト</h4>
<p> クイックソートはある値（枢軸）を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。2 つに分けた各々のグループを同様に分割して、さらに 2 つのグループに分けます。分割を続けていくと最後は要素がひとつになりソートが完了します。
</p>
<p> クイックセレクトも枢軸を基準に二分割していきますが、枢軸の決め方と二分割したグループの扱い方が異なるのです。
</p>
<pre class="fig">
        ３番目のデータを求める
            ↓
table[９５３７６４２８]   ３番目に格納されている７を
      ↑            ↑    枢軸にして二分割する
      Ｌ            Ｒ

table[２５３４６７９８]   Ｒ＞３なので前半部分０－４に対して
              ↑↑        同様の操作を行う
              ＲＬ

            ↓
table[２５３４６７９８]   今度は４を枢軸として二分割する
      ↑      ↑
      Ｌ      Ｒ

table[２３５４６７９８]   Ｌ＜３なので後半部分２－４に対して
        ↑↑              同様の操作を行う
        ＲＬ

            図 : クイックセレクトのアルゴリズム
</pre>
<p> 上図を見てください。配列 table の中から 3 番目のデータを求めます。この場合、枢軸は table[3] に格納されている 7 となります。この値を基準に、クイックソートと同様に配列を二分割すると、0 から R の前半部分に枢軸より小さい値が集まり、L から最後までの後半部分には枢軸より大きい値が集まります。
</p>
<p> もし、R が 3 より大きいのであれば、求めるデータは前半部分に含まれることになります。逆に L が 3 より小さいのであれば、後半部分に含まれます。上図の場合は、R は 4 なので前半部分に求めるデータがあるのです。この部分に対して、同様の処理を繰り返します。
</p>
<p> 今度も table[3] に格納されている要素を枢軸にします。この枢軸に対して配列を二分割します。この処理を繰り返していくと、最後にはグループに含まれる要素がひとつになって分割不能になります。このとき、table[3] に格納されたデータが答となるのです。
</p>

<p> このように、クイックセレクトは分割したグループの片方に対してのみ操作を行うので、クイックソートよりも高速に処理することが可能になります。
</p>

<h4>●プログラムの作成</h4>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : クイックセレクト

quickSelect :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; IO a
quickSelect buff k = do
  (start, end) &lt;- getBounds buff
  qselect start end
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qselect start end
      | start &gt;= end = readArray buff k
      | otherwise = do
          pv &lt;- readArray buff k
          (i, j) &lt;- partition pv start end
          if j &lt; k
          then qselect (j + 1) end
          else qselect start (i - 1)
</pre>
<p> 引数 k が求める順番を表し、局所関数 qselect の引数 start と end が分割する区間の両端を表します。局所関数 search1, search2, partition は <a href="haskell25.html">配列のソート (2)</a> で作成したクイックソートと同じです。
</p>

<p> 最初に、配列 table の k 番目に位置するデータを枢軸 pivot に選び、partition で区間を二分割します。分割が終わって j が k より小さい場合は後半部分を分割します。区間 (j + 1, end) に対して qselect を再帰呼び出しします。そうでなければ前半部分を分割します。区間 (start, i - 1) に対して qselect を再帰呼び出しします。start が end 以上になったならば buff の k 番目の値を返します。
</p>

<h4>●実行結果</h4>
<p> それでは、どの程度効果があるのか拙作のページ <a href="haskell25.html">配列のソート (2)</a> で作成したクイックソート quickSort と比較してみましょう。データ数を 5000, 10000, 20000, 40000 増やしていき、その中央値を求めることにします。テストプログラムは簡単なので説明は割愛します。詳細は <a href="haskell26.html#list1">プログラムリスト</a> をお読みください。
</p>
<p> インタプリタ ghci 上で実行したところ、実行結果は次のようになりました。
</p>
<pre>
*Main> test 5000
-421096
0.0624001s
-421096
0.2808005s
*Main> test 10000
12190649
0.1092001s
12190649
0.6084011s
*Main> test 20000
-683451
0.2340004s
-683451
1.2324022s
*Main> test 40000
2830430
0.4212008s
2830430
2.5740045s
</pre>
<p> select がとても速いことがわかります。ご参考までに、リストで動作するプログラムも作ってみました。この場合、枢軸はリストの先頭要素とし、分割した前半のリストの長さ a で場合分けします。a が k と等しい場合、枢軸が k 番目の要素になります。a が k よりも大きい場合、k 番目の要素は前半のリストにあります。それ以外の場合、k 番目の要素は後半のリストにあります。興味のある方は <a href="haskell26.html#list1">プログラムリスト</a> をお読みくださいませ。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
--
-- quickselect.hs : クイックセレクト
--
--                  Copyright (C) 2013 Makoto Hiroi
--

import Data.Array.IO
import Control.Monad
import Data.Time
import System.Random

-- 要素の交換
swapItem :: IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
swapItem buff i j = do
  a &lt;- readArray buff i
  b &lt;- readArray buff j
  writeArray buff i b
  writeArray buff j a

-- ソート
quickSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
quickSort buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high = do
      pv &lt;- readArray buff ((low + high) `div` 2)
      (i, j) &lt;- partition pv low high
      when (low &lt; i - 1)  $ qsort low (i - 1)
      when (high &gt; j + 1) $ qsort (j + 1) high

-- 選択
quickSelect :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; IO a
quickSelect buff k = do
  (start, end) &lt;- getBounds buff
  qselect start end
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qselect start end
      | start &gt;= end = readArray buff k
      | otherwise = do
          pv &lt;- readArray buff k
          (i, j) &lt;- partition pv start end
          if j &lt; k
          then qselect (j + 1) end
          else qselect start (i - 1)

-- リスト版
quickSort' :: Ord a =&gt; [a] -&gt; [a]
quickSort' [] = []
quickSort' (x:xs) = quickSort' [y | y &lt;- xs, y &lt; x]
                  ++ [x]
                  ++ quickSort' [y | y &lt;- xs, y &gt;= x]

quickSelect' :: Ord a =&gt; [a] -&gt; Int -&gt; a
quickSelect' xs k =
  iter xs k
  where iter [x] 0 = x
        iter (x:xs) k = if a == k then x
                        else if a &gt; k then iter ys k 
                        else iter zs (k - a - 1)
          where ys = [y | y &lt;- xs, y &lt; x]
                a  = length ys
                zs = [z | z &lt;- xs, z &gt;= x]

test :: Int -&gt; IO ()
test n = do
  a &lt;- newListArray (0, n - 1) (take n (randoms (mkStdGen 11) :: [Int])) :: IO (IOArray Int Int)
  b &lt;- newListArray (0, n - 1) (take n (randoms (mkStdGen 11) :: [Int])) :: IO (IOArray Int Int)
  x1 &lt;- getCurrentTime
  y1 &lt;- quickSelect a (n `div` 2)
  x2 &lt;- getCurrentTime
  print y1
  print (diffUTCTime x2 x1)
  x3 &lt;- getCurrentTime
  quickSort b
  y2 &lt;- readArray b (n `div` 2)
  x4 &lt;- getCurrentTime
  print y2
  print (diffUTCTime x4 x3)

test' :: Int -&gt; IO ()
test' n = do
  let a = take n (randoms (mkStdGen 11) :: [Int])
      b = take n (randoms (mkStdGen 11) :: [Int])
  x1 &lt;- getCurrentTime
  print (quickSelect' a (n `div` 2))
  x2 &lt;- getCurrentTime
  print (diffUTCTime x2 x1)
  x3 &lt;- getCurrentTime
  let c = quickSort' b
  print (c !! (n `div` 2))
  x4 &lt;- getCurrentTime
  print (diffUTCTime x4 x3)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell25.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell27.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>