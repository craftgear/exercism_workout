<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881790</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell20.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell22.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">動的計画法</h3>
<p> 今回は Haskell で「動的計画法 (dynamic programming) 」というアルゴリズムに挑戦してみましょう。難しそうな名前がついていますが、これに惑わされてはいけません。動的計画法は、大きな問題を小さな問題に分けて、それを一つ一つ解いていくことで大きな問題を解く方法です。
</p>
<p> 問題によっては、小さな問題に分割していくと同じ小問題が何回も現れる場合があります。この場合、同じ問題を何回も解くよりも、その解を表などに保存しておいて、必要なときにその表から答を求めた方が、効率良く問題を解くことができるはずです。
</p>
<p> どうせ小問題を解かなければならないのであれば、はじめから必要になりそうな小問題を解いて表を埋めておいたほうが、プログラムを作りやすい場合もあります。このように、与えられた問題を解くために小問題の表を埋めてしまう、というのが「動的計画法」の基本的な考え方です。
</p>
<p> なお、このドキュメントは拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo23.html#dp">動的計画法</a> のプログラムを Haskell で書き直したものです。内容は重複しますが、あしからずご了承ください。
</p>

<h4>●組み合わせの数</h4>
<p> 簡単な例題として、組み合わせの数を求めるプログラムを作ってみましょう。組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> を求めるには、次の公式を使えば簡単です。
</p>

<pre class="item">
(1)
<sub>n</sub>Ｃ<sub>r</sub> = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>
<pre class="item">
(2)
<sub>n</sub>Ｃ<sub>0</sub> = <sub>n</sub>Ｃ<sub>n</sub> = 1
<sub>n</sub>Ｃ<sub>r</sub> = <sub>n</sub>Ｃ<sub>r-1</sub> * (n - r + 1) / r
</pre>
<pre class="item">
(3)
<sub>n</sub>Ｃ<sub>0</sub> = <sub>n</sub>Ｃ<sub>n</sub> = 1
<sub>n</sub>Ｃ<sub>r</sub> = <sub>n-1</sub>Ｃ<sub>r-1</sub> + <sub>n-1</sub>Ｃ<sub>r</sub>
</pre>
<p> 皆さんお馴染みの公式ですね。(1) と (2) の公式を使うと簡単に (高速に) 答えを求めることができます。ただし、(3) の公式をそのままプログラムすると二重再帰になるので、大きな値を求めると時間がかかってしまいます。実際にプログラムを作って確かめてみましょう。
</p>
<pre class="list">
リスト : 組み合わせの数

comb :: Integer -&gt; Integer -&gt; Integer
comb n r 
  | n == r || r == 0 = 1
  | otherwise        = comb (n - 1) r + comb (n - 1) (r - 1)
</pre>
<pre>
*Main&gt; :set +s
*Main&gt; comb 20 10
184756
(0.53 secs, 67089856 bytes)
*Main&gt; comb 22 11
705432
(2.01 secs, 256776976 bytes)
*Main&gt; comb 24 12
2704156
(7.46 secs, 974243876 bytes)

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> このように、公式 (3) を使うと時間がかかります。公式 (1), (2) を使えば高速に答えを求めることができますが、今回は動的計画法の例題として、あえてこのプログラムの高速化に挑戦してみましょう。
</p>

<h4>●動的計画法による高速化</h4>
<p> 公式からわかるように、<sub>n</sub>Ｃ<sub>r</sub> の値は <sub>n-1</sub>Ｃ<sub>r</sub> と <sub>n-1</sub>Ｃ<sub>r-1</sub> を足したものです。n = 0 から順番に組み合わせの数を求めて表に格納しておけば、n が大きな値でも簡単に求めることができるはずです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組み合わせの数 (動的計画法[1])

combDP :: Int -&gt; Int -&gt; IO Integer
combDP n r = do
  a &lt;- newArray ((0, 0), (n, n)) 1 :: IO (IOArray (Int,Int) Integer)
  mapM_ (\x -&gt; mapM_ (\y -&gt; do b &lt;- readArray a (x - 1, y)
                               c &lt;- readArray a (x - 1, y - 1)
                               writeArray a (x, y) (b + c))
                     [1 .. x-1])
        [2 .. n]
  readArray a (n, r)
</pre>
<p> 変数 a に値を格納する二次元配列をセットします。組み合わせの数を (n, r) で表すことにすると、関数 mapM_ の中で (0, 0) から順番に、(1, 0), (1, 1), (2, 0), (2, 1), (2, 2) ... と組み合わせの数を求めて配列 a にセットします。ようするに「パスカルの三角形」を作っていくわけです。最後に配列 a から (n, r) の値を求めて返します。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; combDP 100 50
100891344545564193334812497256
(0.06 secs, 7259008 bytes)
*Main&gt; combDP 200 100
90548514656103281165404177077484163874504589675413336841320
(0.11 secs, 29563604 bytes)
</pre>
<p> 動的計画法の効果はとても高いですね。なお、表は二次元配列ではなく一次元配列で済ますこともできます。たとえば、(6, 3) を求めてみましょう。次の図を見てください。
</p>
<pre class="fig">
      0  1  2  3  4  5  6
   ------------------------- 
 0 [  1  1  1  1  1  1  1  ]

 1 [  1  1  1  1  1  1  1  ]
       ＼|
 2 [  1  2  1  1  1  1  1  ]
       ＼|＼|
 3 [  1  3  3  1  1  1  1  ]
       ＼|＼|＼|
 4 [  1  4  6  4  1  1  1  ]
       ＼|＼|＼|＼
 5 [  1  5 10 10  5  1  1  ]
       ＼|＼|＼|＼|＼|
 6 [  1  6 15 20 15  6  1  ]

    図 : パスカルの三角形
</pre>
<p> 最初にベクタの内容を 1 に初期化します。n = 0, 1 の場合はこのままで大丈夫です。あとは図のように、隣の要素を足し算するだけです。3 番目の要素の値 20 が (6, 3) の値になります。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 組み合わせの数 (動的計画法[2])

combDP' :: Int -&gt; Int -&gt; IO Integer
combDP' n r = do
  a &lt;- newArray (0, n) 1 :: IO (IOArray Int Integer)
  mapM_ (\x -&gt; mapM_ (\y -&gt; do b &lt;- readArray a y
                               c &lt;- readArray a (y - 1)
                               writeArray a y (b + c))
                     [x-1, x-2 .. 1])
        [2 .. n]
  readArray a r
</pre>
<p> 配列の値を書き換えていくので、配列の後方から計算していくことに注意してください。前方から計算すると、値がおかしくなります。
</p>

<h4>●リストを使う方法</h4>
<p> もちろん、リストを使ってプログラムすることもできます。パスカルの三角形は、両側がすべて 1 で内側の数はその左上と右上の和になっています。したがって、n 段の三角形を作る場合、一段前の値を記憶しておいて隣同士の要素を足し算すればいいわけです。一段前の値をリストに格納すると、プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組み合わせの数 (動的計画法[3])

combDP'' :: Int -&gt; Int -&gt; Integer
combDP'' n r = iter1 n [1]
  where iter1 0 xs = xs !! r
        iter1 n xs = iter1 (n - 1) (iter2 (0:xs))
        iter2 [_]      = [1]
        iter2 (x:y:zs) = (x + y) : iter2 (y:zs)
</pre>
<p> 局所関数 iter2 は、リストの隣同士の要素を足した値をリストに格納して返します。この処理は再帰呼び出しを使えば簡単です。リストの先頭要素 x と次の要素 y を足し算し、その値を再帰呼び出しの返り値に追加すればいいわけです。リストの要素がひとつになったら [1] を返します。また、iter2 を呼び出すときはリストの先頭に 0 を追加します。これで、リストの先頭と最後尾を 1 にすることができます。あとは、関数 iter1 で iter2 を n 回呼び出すだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; combDP'' 100 50
100891344545564193334812497256
(0.02 secs, 2859128 bytes)
*Main&gt; combDP'' 200 100
90548514656103281165404177077484163874504589675413336841320
(0.03 secs, 6427532 bytes)
</pre>
<h4>●整数の分割</h4>
<p> もうひとつ、数値計算の例を取り上げましょう。整数 n を 1 以上の自然数の和で表すことを考えます。これを「整数の分割」といいます。整数を分割するとき、同じ自然数を何回使ってもかまいませんが、並べる順序が違うだけのものは同じ分割とします。
</p>
<p> 簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
─┬─ 6                           : 6
  │
  ├─ 5 ─ 1                      : 5 + 1
  │
  ├─ 4 ┬ 2                      : 4 + 2
  │     │
  │     └ 1 ─ 1                 : 4 + 1 + 1
  │
  ├─ 3 ┬ 3                      : 3 + 3
  │     │
  │     ├ 2 ─ 1                 : 3 + 2 + 1
  │     │
  │     └ 1 ─ 1 ─ 1            : 3 + 1 + 1 + 1
  │
  ├─ 2 ┬ 2 ┬ 2                 : 2 + 2 + 2
  │     │   │
  │     │   └ 1 ─ 1            : 2 + 2 + 1 + 1
  │     │
  │     └ 1 ─ 1 ─ 1 ─ 1       : 2 + 1 + 1 + 1 + 1
  │
  └─ 1 ─ 1 ─ 1 ─ 1 ─ 1 ─ 1  : 1 + 1 + 1 + 1 + 1 + 1

                    図 : 整数 6 の分割
</pre>
<p> 6 の場合、分割の仕方は上図のように 11 通りあります。この数を「分割数」といいます。分割の仕方を列挙する場合、整数 n から k 以下の整数を選んでいくと考えてください。まず、6 から 6 を選びます。すると、残りは 0 になるので、これ以上整数を分割することはできません。次に、6 から 5 を選びます。残りは 1 になるので、1 を選ぶしか方法はありません。
</p>
<p> 次に、4 を選びます。残りは 2 になるので、2 から 2 以下の整数を分割する方法になります。2 から 2 を選ぶと残りは 0 になるので 2 が得られます。1 を選ぶと残りは 1 になるので、1 + 1 が得られます。したがって、4 + 2, 4 + 1 + 1 となります。同様に、6 から 3 を選ぶと、残りは 3 から 3 以下の整数を選ぶ方法になります。
</p>
<p> 6 から 2 以下の整数を選ぶ方法は、残り 4 から 2 以下の整数を選ぶ方法になり、そこで 2 を選ぶと 2 から 2 以下の整数を選ぶ方法になります。1 を選ぶと 4 から 1 以下の整数を選ぶ方法になりますが、これは 1 通りしかありません。最後に 6 から 1 を選びますが、これも 1 通りしかありません。これらをすべて足し合わせると 11 通りになります。
</p>

<p> 整数 n を k 以下の整数で分割する総数を求める関数を p(n, k) とすると、p(n, k) は次のように定義することができます。
</p>
<pre class="item">
p(n, k) = 0                          ; n &lt; 0 または k &lt; 1
p(n, k) = 1                          ; n = 0 または k = 1
p(n, k) = p(n - k, k) + p(n, k - 1)
</pre>
<p> たとえば、p(6, 6) は次のように計算することができます。
</p>
<pre class="fig">
p(6, 6) =&gt; p(0, 6) + p(6, 5)
        =&gt; 1 + p(1, 5) + p(6, 4)
        =&gt; 1 +    1    + p(2, 4) + p(6, 3)
        =&gt; 1 + 1 + 2 + 7
        =&gt; 11

p(2, 4) =&gt; p(-2, 4) + p(2, 3)
        =&gt;    0     + p(-1, 3) + p(2, 2)
        =&gt;    0     +    0     + p(0, 2) + p(2, 1)
        =&gt; 0 + 0 + 1 + 1
        =&gt; 2

p(6, 3) =&gt; p(3, 3) + p(6, 2)
        =&gt; p(0, 3) + p(3, 2) + p(4, 2) + p(6, 1)
        =&gt;    1    + p(1, 2) + p(3, 1) + p(2, 2) + p(4, 1) + 1
        =&gt;    1    +    1    +    1    + p(0, 2) + p(2, 1) + 1 + 1
        =&gt; 1 + 1 + 1 + 1 + 1 + 1 + 1
        =&gt; 7
</pre>
<p> 分割数を求める関数 partition_number は、関数 p(n, k) を使うと次のようにプログラムすることができます。
</p>
<pre class="list">
リスト : 分割数

partition_number :: Integer -&gt; Integer
partition_number n = part_num n n
  where
    part_num 0 _ = 1
    part_num 1 _ = 1
    part_num _ 1 = 1
    part_num n k
      | n &lt; 0 || k &lt; 1 = 0
      | otherwise      = part_num (n - k) k + part_num n (k - 1)
</pre>
<pre>
*Main&gt; partition_number 40
37338
(0.25 secs, 23306864 bytes)
*Main&gt; partition_number 50
204226
(1.19 secs, 121110244 bytes)
*Main&gt; partition_number 60
966467
(5.44 secs, 561464936 bytes)
</pre>
<p> 局所関数 part_num は p(n, k) の定義をそのままプログラムしただけです。ただし、このプログラムは二重再帰で何度も同じ値を求めているため実行速度はとても遅くなります。
</p>
<h4>●動的計画法による高速化</h4>
<p> 動的計画法を使うと、大きな値でも高速に計算することができます。次の図を見てください。
</p>
<pre class="fig">
k 
1 : [1,  1,  1,  1,  1,  1,  1] 

2 : [1,  1,  1+1=2, 1+1=2, 2+1=3, 2+1=3, 3+1=4]
 =&gt; [1,  1,  2,  2,  3,  3,  4]

3:  [1,  1,  2,  1+2=3, 1+3=4, 2+3=5, 3+4=7]
 =&gt; [1,  1,  2,  3,  4,  5,  7]

4:  [1,  1,  2,  3,  1+4=4, 1+5=6, 2+7=9]
 =&gt; [1,  1,  2,  3,  5,  6,  9

5:  [1,  1,  2,  3,  5,  1+6=7, 1+9=10]
 =&gt; [1,  1,  2,  3,  5,  7,  10]

6:  [1,  1,  2,  3,  5,  7,  10+1=11]
 =&gt; [1,  1,  2,  3,  5,  7,  11]
</pre>
<p> 大きさ n + 1 の配列を用意します。配列の添字が n を表していて、p(n, 1) から順番に値を求めていきます。p(n, 1) の値は 1 ですから、配列の要素は 1 に初期化します。次に、p(n, 2) の値を求めます。定義により p(n, 2) = p(n - 2, 2) + p(n, 1) なので、2 番目以降の要素に n - 2 番目の要素を加算すれば求めることができます。あとは、k の値をひとつずつ増やして同様の計算を行えば p(n, n) の値を求めることができます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 分割数 (動的計画法)

partition_number' :: Int -&gt; IO Integer
partition_number' n = do
  a &lt;- newArray (0, n) 1 :: IO (IOArray Int Integer)
  mapM_ (\k -&gt; mapM_ (\m -&gt; do b &lt;- readArray a m
                               c &lt;- readArray a (m - k)
                               writeArray a m (b + c))
                     [k .. n])
        [2 .. n]
  readArray a n
</pre>
<p> 説明をそのままプログラムしただけなので、とくに難しいところはないと思います。それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; partition_number' 40
37338
(0.02 secs, 1562132 bytes)
*Main&gt; partition_number' 50
204226
(0.02 secs, 1554160 bytes)
*Main&gt; partition_number' 60
966467
(0.02 secs, 2100680 bytes)
*Main&gt; partition_number' 100
190569292
(0.05 secs, 5713460 bytes)
*Main&gt; partition_number' 1000
24061467864032622473692149727991
(1.86 secs, 546468864 bytes)
</pre>

<h4>●リストを使う方法</h4>
<p> もちろん、リストを使ってプログラムすることもできます。
</p>

<pre class="list">
リスト : 別解 (動的計画法)

partition_number'' :: Int -&gt; Integer
partition_number'' n = iter 2 (replicate (n + 1) 1)
  where
    iter k xs
      | k &gt; n     = last xs
      | otherwise = let ys = (take k xs ++ zipWith (+) ys (drop k xs))
                    in iter (k + 1) ys
</pre>
<p> 実際の処理は局所関数 iter で行います。リストの値を更新するとき、新しいリストを ys とすると、先頭の k 個の要素は xs と同じで、それ以降の要素は xs の i 番目の要素と ys の i - k 番目の要素を加算します。この処理は、ys と (drop k xs) を zipWith で加算することと同じです。ys の先頭要素は take k xs で求められているので、zipWith で ys の要素を先頭から順番に取り出していくことができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; partition_number'' 40
37338
(0.00 secs, 691676 bytes)
*Main&gt; partition_number'' 50
204226
(0.00 secs, 0 bytes)
*Main&gt; partition_number'' 60
966467
(0.00 secs, 1264900 bytes)
*Main&gt; partition_number'' 100
190569292
(0.00 secs, 1500268 bytes)
*Main&gt; partition_number'' 1000
24061467864032622473692149727991
(0.28 secs, 103819096 bytes)
</pre>
<h4>●ナップザック問題</h4>
<p> 最後に、簡単な例題として「ナップザック問題」を取り上げます。ナップザック (knapsack) とは辞書を引いてみると、ランドセルのような背中にせおう四角形の袋や箱のことを意味します。ここでは物を入れる袋と簡単に考えてください。
</p>
<p> ここで、ナップザックの中に品物を詰め込むことを考えてみます。一つのナップザックと複数の品物が与えられたとき、袋に詰めた品物の合計金額が最大になるような選び方を求めることが「ナップザック問題」です。ここでは、同じ品物を何個も選んでもいいのですが、ナップザックの大きさをオーバーしてはいけません。
</p>
<p> 実はこの「ナップザック問題」が「NP 問題」なのです。世の中にはさまざまな問題が山積していますが、スーパーコンピュータを使っても解くのに数億年かかる、というような難問が「NP 問題」です。これは、厳密に解を求めようとすると、全ての場合について総当たりで調べるしか方法がなく、データ数が多くなると時間がかかるため、現実的な時間では解答を出すことができないというものです。品物の詰め方が難問の一つ、といわれてもピンとこないと思いますが、ナップザック問題は品物の種類が増えるにしたがって、その組み合わせ方が爆発的に増えるのです。
</p>
<p> ところが、幸いなことに「ナップザック問題」は実用的には解決済みの問題と考えられています。とくに有名なのが「動的計画法」を用いた解法です。ナップザックと品物の大きさを整数値に限定すれば、動的計画法を用いることで厳密解を求めることができるのです。
</p>

<p> それでは具体的に、ナップザック問題に動的計画法を適用してみましょう。ナップザックの大きさは 10 で、次の 3 種類の品物を詰め込むことにします。
</p>
<pre class="fig">
（Ａ）大きさ  ４  ：金額  ６
（Ｂ）大きさ  ３  ：金額  ４
（Ｃ）大きさ  １  ：金額  １
</pre>
<p> まず、大きさが 0 から 10 までのナップザックを用意します。これらのナップザックに品物を順番に詰め込んで、その合計金額を配列に格納しておきます。この配列は品物を詰め込んでいない状態 (金額は全て 0) に初期化します。
</p>
<p> 最初に品物 A を詰め込みます。このとき、小さなナップザックから順番に詰め込んでいきます。
</p>
<pre class="fig">
                  Ａを詰め込む
                      ↓
      ０  １  ２  ３  ４  ５  ６  ７  ８  ９  10
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
選択│／│／│／│／│／│／│／│／│／│／│／│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
金額│０│０│０│０│０│０│０│０│０│０│０│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
      ↓              ↓
    金額[0] + 6 = 6 &gt; 0    金額[4] に 6 をセット
</pre>
<p> 品物 A が入る大きさのナップザックから詰め込みます。品物を入れるときは、それより小さいナップザックには、その時点での最適な値が決定されていると考えます。ナップザック (4) に品物 A を詰め込む場合、A の大きさだけ空いているナップザック (0) の状態に詰め込めば、ナップザック (4) の最適な値を求めることができるはずです。このように、前に計算された値を使うところが動的計画法の特徴なのです。
</p>
<p> 具体的には、金額[0] に A の金額 6 を足した値を計算し、金額[4] より大きくなれば金額[4] をその値に更新します。もし、金額[4] より小さいのであれば金額[4] は更新しません。つまり、品物Ａはナップザック (4) には詰め込まないのです。ほかの組み合わせの方が正解だというわけです。
</p>
<p> 詰め込んだ品物を記憶しておくため、もう一つ配列を用意して、そこに追加した品物の種類を格納しておきます。ナップザックの中身全てを記憶しておく必要はありません。この配列を使って、あとからナップザックの中身を求めることができます。
</p>
<p> 次に、品物 B を詰め込んでいきます。
</p>
<pre class="fig">
                  Ｂを追加する
                      ↓
      ０  １  ２  ３  ４  ５  ６  ７  ８  ９  10
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
選択│／│／│／│Ｂ│Ａ│Ａ│Ａ│Ａ│Ａ│Ａ│Ａ│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
金額│０│０│０│４│６│６│６│６│12│12│12│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
          ↓          ↓
    金額[1] + 4 = 4 &lt; 6    金額[4] は更新しない
</pre>
<p> まず、ナップザック (3) に B が詰め込まれます。これは品物 A の場合と同じですね。次に、ナップザック (4) に B を詰めようとします。その値を計算すると 4 となり、金額[4] の値 6 より小さいので、B は詰め込みません。ナップザック (5) の場合も同様です。
</p>
<pre class="fig">
                          Ｂを追加する
                              ↓
      ０  １  ２  ３  ４  ５  ６  ７  ８  ９  10
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
選択│／│／│／│Ｂ│Ａ│Ａ│Ａ│Ａ│Ａ│Ａ│Ａ│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
金額│０│０│０│４│６│６│６│６│12│12│12│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
                  ↓          ↓
            金額[3] + 4 = 8 &lt; 6

    金額[6] を 8 に更新し、選択[6] にＢをセットする
</pre>
<p> 次はナップザック (6) に B を詰めます。値を計算すると 8 になり、今度は金額[6] の値 6 より大きくなります。つまり、A を詰め込むよりも B を詰め込む方が金額が高くなるのです。金額[6] と選択[6] の値を更新します。ナップザック (7) の場合も同様ですね。
</p>

<p> あとは、順番に同じことを繰り返して、配列の値を更新していきます。そして、品物 C を最後まで詰め込むと、次のようになります。
</p>
<pre class="fig">
      ０  １  ２  ３  ４  ５  ６  ７  ８  ９  10
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
選択│／│Ｃ│Ｃ│Ｂ│Ａ│Ｃ│Ｂ│Ｂ│Ａ│Ｃ│Ｂ│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
金額│０│１│２│４│６│７│８│10│12│13│14│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
</pre>
<p> このときの金額[10] の 14 が答となります。この状態からナップザックに詰め込まれた品物を求めます。
</p>
<pre class="fig">
      ０  １  ２  ３  ４  ５  ６  ７  ８  ９  10
    ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
選択│／│Ｃ│Ｃ│Ｂ│Ａ│Ｃ│Ｂ│Ｂ│Ａ│Ｃ│Ｂ│
    └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴┼┘
      ↑              │          │          │
      └───────┴←────┴←────┘
</pre>
<p> まず、選択[10] にセットされた品物を取り出します。この場合は B ですね。次は、10 からＢの大きさ 3 を引いた 7 のときに追加された品物を取り出します。この場合も B ですね。同様に、7 から 3 を引いた 4 のときに追加された品物を求めます。これはＡですね。4 から A の大きさを引くと 0 になるので、これ以上品物は入っていません。したがって、ナップザックの中には A が 1 個、B が 2 個入っていることがわかります。
</p>
<h4>●プログラムの作成</h4>
<p> それでは、実際にプログラミングしましょう。まず、品物を表すデータ型 Item を定義します。
</p>

<pre class="list">
リスト : 品物の定義

data Item = None | Item {name :: String, price :: Integer, size :: Integer} deriving (Eq, Show)

item_list = [Item "A" 6 4, Item "B" 4 3, Item "C" 1 1]
</pre>
<p> name が品名、price が金額で、size が大きさを表します。None は品物を選んでいないことを表すために使います。item_list は品物 (Item) を格納したリストです。
</p>

<p> 次は、ナップザック問題の解を求める関数 knapsack を作ります。
</p>

<pre class="list">
リスト : ナップザック問題の解法

knapsack :: Integer -&gt; IO ()
knapsack ksize = do
  gain &lt;- newArray (0, ksize) 0 :: IO (IOArray Integer Integer)
  choice &lt;- newArray (0, ksize) None :: IO (IOArray Integer Item)
  mapM_ (\item -&gt; mapM_ (\j -&gt; do a &lt;- readArray gain (j - size item)
                                  b &lt;- readArray gain j
                                  when (b &lt; a + price item) $ do
                                    writeArray gain j (a + price item)
                                    writeArray choice j item)
                        [size item .. ksize])
        item_list
  -- 結果の表示
  print_answer ksize choice
    where print_answer i choice = do
            item &lt;- readArray choice i
            when (item /= None) $ do
              print item
              print_answer (i - size item) choice
</pre>
<p> knapsack の引数 ksize はナップザックの大きさを表します。最初に、金額を表す配列 gain と選択した品物を格納する配列 choice を用意します。gain は 0 で、choice は None で初期化します。次の mapM_ で、品物を一つずつ item_list から取り出します。次の mapM_ で、item の size から ksize まで gain と choice を更新していきます。
</p>
<p> まず、ナップザックから item size 分だけ空けた場合の金額を a にセットします。a に item を追加した値 (a + price item) が新しい値になります。この値が現在の値 b よりも大きければ、choice と gain の値を writeArray で更新します。
</p>

<p> 最後にナップザックの中身を表示します。まず choice の i 番目に格納された品物を item にセットします。それが None でなければ、print で Item を表示し、i から size item を引いて、次に詰め込まれた品物へ移ります。
</p>
<h4>●実行結果</h4>
<p> それでは実行結果を示します。
</p>
<pre>
*Main&gt; knapsack 10
Item {name = "B", price = 4, size = 3}
Item {name = "B", price = 4, size = 3}
Item {name = "A", price = 6, size = 4}
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">部分和問題</h3>
<p> 部分和問題は、要素が数値の集合 S において、要素の総和が M となる部分集合があるか判定する問題です。たとえば、集合 {2, 3, 5, 8} の場合、総和が 10 となる部分集合は {2, 3, 5} と {2, 8} がありますが、14 となる部分集合はありません。部分集合の総数は、要素数を n とすると 2<sup>n</sup> 個になるので、n が大きくなるとナイーブな方法では時間がかかってしまいます。実際には、「分岐限定法」や「動的計画法」を使うことで、現実的な時間で部分和問題を解くことができます。
</p>
<p> なお、このドキュメントは拙作のページ <a href="../memo11.html">Memorandum 2011 年 12 月</a> で取り上げた「部分和問題」を Haskell 用に加筆・修正したものです。内容は重複しますが、あしからずご了承ください。
</p>
<h4>●ナイーブな方法</h4>
<p> 最初にナイーブな方法で部分和問題を解いてみましょう。今回は要素を正整数に限定します。部分和問題は「べき集合」を生成する関数 powerSet を作ると簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : べき集合

powerSet :: [a] -&gt; [[a]]
powerSet []     = [[]]
powerSet (x:xs) =  powerSet xs ++ [x:ys | ys <- powerSet xs]
</pre>
<p> べき集合を求める関数 powerSet は簡単です。引数が空リストの場合は [ ] を格納したリストを返します。そうでなければ、引数を x:xs で分解します。 そして、powerSet を再帰呼び出しして xs のべき集合を求め、その集合に先頭要素 x を追加します。そして、その集合と xs のべき集合を演算子 ++ で連結します。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; powerSet [2,3,5,8]
[[],[8],[5],[5,8],[3],[3,8],[3,5],[3,5,8],[2],[2,8],[2,5],[2,5,8],[2,3],[2,3,8],[2,3,5],[2,3,5,8]]
</pre>
<p> [2, 3, 5, 8] の部分集合は空集合 [ ] を含めて 16 通りあります。この powerSet を使うと部分和問題のプログラムは次のようになります。
</p>

<pre class="list">
リスト : 部分和問題

subsetSum :: Integer -&gt; [Integer] -&gt; [[Integer]]
subsetSum n xs = filter ((==n) . sum) $ powerSet xs
</pre>
<p> 部分集合の総和を sum で求め、n と等しいものを filter で取り出します。それでは実行してみましょう。
</p>
<pre>
*Main&gt; subsetSum 10 [2,3,5,8]
[[2,8],[2,3,5]]
*Main&gt; subsetSum 14 [2,3,5,8]
[]
</pre>
<p> とても簡単ですね。ただし、集合の要素数が多くなると、実行時間がかかるようになります。次のテストプログラムを見てください。
</p>
<pre class="list">
リスト : 簡単なテスト

nums :: [Integer]
nums = [  1,   2,   3,   5,   8,   13,   21,   34,   55,    89,
        144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]

test :: Int -&gt; [[Integer]]
test n = subsetSum m xs
  where xs = take n nums
        m  = sum xs - 1
</pre>
<p> 配列 nums はフィボナッチ数列になっています。要素の総和を M とすると、1 から M までの整数は、要素を組み合わせて必ず作ることができます。これはフィボナッチ数列の面白い特徴です。
</p>
<p> テストは 総和 - 1 となる組み合わせを subsetSum で求め、その実行時間を計測します。結果は次のようになりました。
</p>
<pre>
*Main&gt; :set +s
*Main&gt; test 16
[[2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597]]
(0.44 secs, 79550988 bytes)
*Main&gt; test 17
[[2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584]]
(0.90 secs, 164517272 bytes)
*Main&gt; test 18
[[2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]]
(1.84 secs, 345150612 bytes)
*Main&gt; test 19
[[2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]]
(3.78 secs, 723665764 bytes)
*Main&gt; test 20
[[2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]]
(7.75 secs, 1514117544 bytes)

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 要素がひとつ増えると実行時間は約 2 倍になっていることがわかります。要素数を n とすると、subsetSum の実行時間は 2<sup>n</sup> に比例する遅いプログラムなのです。
</p>

<h4>●分岐限定法による高速化</h4>
<p> 次は「分岐限定法」を使って部分和問題の高速化に挑戦してみましょう。分岐限定法を簡単に説明すると、深さ優先探索において不要な局面の生成を省くため枝刈りを行う方法です。思考ルーチンでよく使われる「アルファベータ法」や反復深化の高速化で用いられる「下限値枝刈り法」も分岐限定法の一種です。
</p>
<p> 今回の部分和問題は要素を正整数値に限定しているので、二種類の枝刈りを考えることができます。ひとつは部分集合の総和が求める値 N を超えた場合です。残りの要素は正整数なので、これ以上要素を追加しても解を得られないのは明白ですね。もうひとつは、部分集合の総和に残りの要素をすべて足しても N に満たない場合です。これも解を得られないのは明白です。
</p>
<p> 部分集合の総和を S, 残りの要素の総和を R, 求める値を N とすると、探索を行う条件は次の式で表すことができます。
</p>
<pre class="item">
S &lt; N &amp;&amp; S + R &gt;= N
</pre>
<p> これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 部分和問題 (分岐限定法)

subsetSum1 :: Integer -&gt; [Integer] -&gt; [[Integer]]
subsetSum1 n xs = iter [] 0 xs (sum xs) []
  where iter a m [] _ b
          | n == m    = a : b
          | otherwise = b
        iter a m (y:ys) r b
          | n == m = a : b
          | m &lt; n && m + r &gt;= n =
              iter a m ys (r - y) $ iter (y:a) (m + y) ys (r - y) b
          | otherwise = b
</pre>
<p> 実際の処理は局所関数 iter で行います。引数 m は求めている部分集合の総和、r は残りの要素の総和を表します。引数 b は結果を格納する累積変数です。m &lt; n かつ m + r &gt;= n ならば条件を満たすので、iter を再帰呼び出しして探索を続行します。とても簡単ですね。
</p>
<p> それでは試してみましょう。
</p>
<pre class="list">
リスト : テストプログラム

test1 :: Int -&gt; [[Integer]]
test1 n = subsetSum1 m xs
  where xs = take n nums
        m  = sum xs - 1
</pre>
<pre>
*Main&gt; test1 16
[[1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2]]
(0.02 secs, 522548 bytes)
*Main&gt; test1 17
[[2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2]]
(0.02 secs, 522864 bytes)
*Main&gt; test1 18
[[4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2]]
(0.00 secs, 526416 bytes)
*Main&gt; test1 19
[[6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2]]
(0.00 secs, 0 bytes)
*Main&gt; test1 20
[[10946,6765,4181,2584,1597,987,610,377,233,144,89,55,34,21,13,8,5,3,2]]
(0.03 secs, 0 bytes)
</pre>
<p> とても速くなりましたね。ただし、これは枝刈りがうまくいった場合であり、データによっては枝刈りが機能しない場合もありえます。たとえば、xs の最後尾の要素から 1 を引いた値を判定してみましょう。結果は次のようになりました。
</p>
<pre class="list">
リスト : テストプログラム

test1' :: Int -&gt; [[Integer]]
test1' n = subsetSum1 m xs
  where xs = take n nums
        m  = last xs - 1
</pre>
<pre>
*Main&gt; test1' 16
[[987,377,144,55,21,8,3,1]]
(0.23 secs, 26349100 bytes)
*Main&gt; test1' 17
[[1597,610,233,89,34,13,5,2]]
(0.39 secs, 52167776 bytes)
*Main&gt; test1' 18
[[2584,987,377,144,55,21,8,3,1]]
(0.75 secs, 103793140 bytes)
*Main&gt; test1' 19
[[4181,1597,610,233,89,34,13,5,2]]
(1.44 secs, 206529244 bytes)
*Main&gt; test1' 20
[[6765,2584,987,377,144,55,21,8,3,1]]
(2.85 secs, 412518484 bytes)
</pre>
<p> 実行時間はそれほど速くなりません。実をいうと、データの並び方によって実行時間は大きく左右されます。興味のある方はいろいろ試してみてください。
</p>

<h4>●動的計画法による高速化</h4>
<p> 今度は前回説明した「動的計画法」で部分和問題を解いてみましょう。部分和問題の場合、総和が N となる部分集合があるか判定するだけでよければ、動的計画法で解くことが可能です。
</p>
<p> 部分和問題の場合、要素をひとつずつ追加しながら、総和 N となる部分集合があるか判定します。簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
        xs = {2, 3, 5, 8}, N = 10

                ０ １ ２ ３ ４ ５ ６ ７ ８ ９ 10
-------------------------------------------------
0: {}           ○ × × × × × × × × × × 
1: {2}          ○ × ○ × × × × × × × × 
2: {2, 3}       ○ × ○ ○ × ○ × × × × × 
3: {2, 3, 5}    ○ × ○ ○ × ○ × ○ ○ × ○ 
4: {2, 3, 5, 8} ○ × ○ ○ × ○ × ○ ○ × ○ 
</pre>
<p> 上図は xs = {2, 3, 5, 8} で N = 10 の部分集合があるか判定する場合です。最初に N + 1 の配列 A<sub>i</sub> を用意します。空集合の総和は 0 なので A<sub>0</sub>[0] に○をセットします。次に、要素 2 を追加します。部分集合は { } と {2} になります。A<sub>1</sub>[0] と A<sub>1</sub>[2] に○をセットします。その次に要素 3 を追加します。追加される部分集合は {3} と {2, 3} になるので、A<sub>2</sub>[0], A<sub>2</sub>[2], A<sub>2</sub>[3] と A<sub>2</sub>[5] に○をセットします。
</p>
<p> つまり、i 番目の要素 x を追加する場合、A<sub>i-1</sub> で○が付いている位置を y とすると、A<sub>i</sub>[y] と A<sub>i</sub>[x + y] に○をセットすればいいわけです。添字 y は部分集合の総和を表しています。A<sub>i</sub>[y] に○をセットすることは、その部分集合に x を加えないことを意味し、A<sub>i</sub>[x + y] に○をセットすることは、その部分集合に x を追加することを意味するわけです。
</p>
<p> 次に 5 を追加します。A<sub>2</sub> の○の位置は 0, 2, 3, 5 なので、これに 5 を足した 5, 7, 8, 10 の位置に○をセットします。最後に 8 を追加します。A<sub>3</sub> の○の位置は 0, 2, 3, 5, 7, 8, 10 なので、これに 8 を足した 8, 10 の位置に○をセットします。A<sub>4</sub>[10] の値が○になので、部分和が 10 となる部分集合があることがわかります。
</p>
<p> もうひとつ簡単な例を示しましょう。今度は総和が 14 となる部分集合があるか判定します。
</p>
<pre class="fig">
                xs = {2,3,5,8}, N = 14

             ０ １ ２ ３ ４ ５ ６ ７ ８ ９ 10 11 12 13 14
----------------------------------------------------------
0: {}        ○ × × × × × × × × × × × × × × 
1: {2}       ○ × ○ × × × × × × × × × × × × 
2: {2,3}     ○ × ○ ○ × ○ × × × × × × × × × 
3: {2,3,5}   ○ × ○ ○ × ○ × ○ ○ × ○ × × × × 
4: {2,3,5,8} ○ × ○ ○ × ○ × ○ ○ × ○ ○ × ○ × 
</pre>
<p> 3 番目で○の位置は 0, 2, 3, 5, 7, 8, 10 です。次は 8 を追加しますが、総和 14 より大きい値は不要なので、8, 10, 11, 13 の位置に○を追加します。14 の位置は×なので、総和が 14 となる部分集合は無いことがわかります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 部分和問題 (動的計画法)

subsetSum2 :: Integer -&gt; [Integer] -&gt; IO Bool
subsetSum2 n xs = do
  a &lt;- newArray (0, n) False :: IO (IOArray Integer Bool)
  writeArray a 0 True
  mapM_ (\x -&gt; mapM_ (\y -&gt; do f &lt;- readArray a y
                               when f $ do writeArray a (x + y) True)
               [n - x, n - x - 1 .. 0])
        xs
  readArray a n
</pre>
<p> ○を True で、×を False で表します。配列をひとつで済ますため、配列の後ろから True の位置を検索していることに注意してください。また、検索の開始位置を n - x とすることで、True をセットするときの範囲チェックを省略しています。今回のプログラムでは xs の要素をすべてチェックしていますが、x + y が n と等しくなったら True を返えすようにプログラムしてもかまいません。あとは特に難しいところはないと思います。
</p>
<p> それでは実際に試してみましょう。テストプログラムを示します。
</p>
<pre class="list">
リスト : テストプログラム

test2 :: Int -&gt; IO Bool
test2 n = subsetSum2 m xs
  where xs = take n nums
        m  = sum xs - 1
</pre>
<p> 実行結果は次のようになりました。
</p>
<pre>
*Main&gt; test2 16
True
(0.20 secs, 34201996 bytes)
*Main&gt; test2 17
True
(0.28 secs, 58553636 bytes)
*Main&gt; test2 18
True
(0.42 secs, 100038048 bytes)
*Main&gt; test2 19
True
(0.72 secs, 170536616 bytes)
*Main&gt; test2 20
True
(1.17 secs, 290291452 bytes)
</pre>
<p> ナイーブな方法よりも高速になりましたが、分岐限定法にはかないませんでした。集合の要素数を M, 総和を N とすると、今回のプログラムの実行速度は N * M に比例します。たとえば、N の値を 最後尾の要素 - 1 とすると、実行結果は次のようになります。
</p>
<pre class="list">
リスト : テストプログラム

test2' :: Int -&gt; IO Bool
test2' n = subsetSum2 m xs
  where xs = take n nums
        m  = last xs - 1
</pre>
<pre>
*Main&gt; test2' 16
True
(0.06 secs, 11909840 bytes)
*Main&gt; test2' 17
True
(0.14 secs, 20719836 bytes)
*Main&gt; test2' 18
True
(0.17 secs, 35229532 bytes)
*Main&gt; test2' 19
True
(0.28 secs, 60623920 bytes)
*Main&gt; test2' 20
True
(0.47 secs, 103138556 bytes)
</pre>
<p> N が小さくなったので、実行時間も速くなりました。このように、動的計画法では N が大きくなると、どうしても時間がかかるようになります。そこで、配列を使わずにプログラムを作ってみましょう。
</p>
<h4>●Data.Set を使う方法</h4>
<p> 配列を使う場合、N が大きくなると True を検索する処理に時間がかかるようになります。そこで、配列の代わりにモジュール Data.Set を使って部分集合の総和を管理することにします。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 部分和問題

import qualified Data.Set as S

subsetSum3 :: Integer -&gt; [Integer] -&gt; Bool
subsetSum3 n xs = iter xs (S.singleton 0)
  where iter [] s = S.member n s
        iter (x:xs) s = iter xs $ foldl (\s' y -&gt; if x + y &lt;= n
                                                  then S.insert (x + y) s'
                                                  else s')
                                        s
                                        (S.elems s)
</pre>
<p> 実際の処理は局所関数 iter で行います。最初に部分集合の総和を管理するセット s を 0 に初期化します。関数 S.elems で集合の要素を求め、それを foldl に渡します。ラムダ式の中で、リストの要素 x と集合の要素 y を足し算し、それが n 以下であれば S.insert で集合に追加します。最後に、S.member で集合 s に n が含まれているかチェックします。
</p>

<p> それでは実行結果を示します。
</p>
<pre class="list">
リスト : テストプログラム

test3 :: Int -&gt; Bool
test3 n = subsetSum3 m xs
  where xs = take n nums
        m  = sum xs - 1

test3' :: Int -&gt; Bool
test3' n = subsetSum3 m xs
  where xs = take n nums
        m  = last xs - 1
</pre>
<pre>
*Main&gt; test3 16
True
(0.03 secs, 3773328 bytes)
*Main&gt; test3 17
True
(0.06 secs, 5465532 bytes)
*Main&gt; test3 18
True
(0.08 secs, 9301780 bytes)
*Main&gt; test3 19
True
(0.14 secs, 15908532 bytes)
*Main&gt; test3 20
True
(0.17 secs, 25858544 bytes)
</pre>
<pre>
*Main&gt; test3' 16
True
(0.03 secs, 2633104 bytes)
*Main&gt; test3' 17
True
(0.05 secs, 3178072 bytes)
*Main&gt; test3' 18
True
(0.05 secs, 4841424 bytes)
*Main&gt; test3' 19
True
(0.06 secs, 7611284 bytes)
*Main&gt; test3' 20
True
(0.09 secs, 13069068 bytes)
</pre>
<p> subsetSum2 よりも高速になりました。ちなみに、分岐限定法と同様の枝刈りを入れると、実行速度はもう少し速くなります。興味のある方は試してみてください。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell20.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell22.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>