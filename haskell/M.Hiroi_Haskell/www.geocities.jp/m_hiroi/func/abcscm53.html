<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881784</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm52.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm54.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>電卓プログラムの作成 (4)</h3>
<p> 今回は電卓プログラムに論理演算子、比較演算子、条件分岐の機能を追加してみましょう。
</p>

<h4>●論理演算子と比較演算子の優先順位</h4>
<p> 論理演算子と比較演算子を使う場合、真偽値を表すデータが必要になります。電卓プログラムのデータは数値しかないので、Scheme の述語 zero? を満たすデータを偽、それ以外を真と定義することにしましょう。論理演算子と比較演算子は、結果が真であれば整数値 1 を、偽であれば整数値 0 を返すことにします。
</p>
<p> 電卓プログラムで使用する論理演算子と比較演算子を表に示します。
</p>
<table border=1>
<caption>表 : 論理演算子</caption>
<thead>
  <tr><th>操作</th><th>意味</th><th>トークン</th></tr>
</thead>
<tbody>
  <tr><td>not x, ! x </td><td>x の否定（真偽の反転）</td><td>not</td></tr>
  <tr><td>x and y </td><td>x が真かつ y が真ならば真</td><td>and</td></tr>
  <tr><td>x or y  </td><td>x が真まはた y が真ならば真</td><td>or</td></tr>
</tbody>
</table>
<br>
<table border=1>
<caption>表 : 比較演算子</caption>
<thead>
  <tr><th>演算子</th><th>意味</th><th>トークン</th></tr>
</thead>
<tbody>
  <tr><td> ==   </td><td>等しい</td><td>==</td></tr>
  <tr><td> !=   </td><td>等しくない</td><td>!=</td></tr>
  <tr><td> &lt;  </td><td>より小さい</td><td>&lt;</td></tr>
  <tr><td> &gt;  </td><td>より大きい</td><td>&gt;</td></tr>
  <tr><td> &lt;= </td><td>より小さいか等しい</td><td>&lt;=</td></tr>
  <tr><td> &gt;= </td><td>より大きいか等しい</td><td>&gt;=</td></tr>
</tbody>
</table>

<p> 論理演算子は not (!), and, or で、not は単項演算子になります。比較演算子は ==, !=, &lt;, &gt;, &lt;=, &gt;= の 6 種類で、Ｃ言語の比較演算子と同じです。演算子の優先順位ですが、Ｃ言語のように細かく分けることはしないで、次のように設定することにしました。
</p>
<pre class="item">
優先順位 (高)
単項演算子 (+, -, not)
乗法演算子 (*, /)
加法演算子 (+, -)
比較演算子 (==, !=, &lt;, &gt;, &lt;=, &gt;=)
論理演算子 (and, or)
代入演算子 (=)
優先順位 (低)
</pre>

<h4>●条件分岐</h4>
<p> 条件分岐は「文」として定義することもできますが、今回は簡単な電卓プログラムなので「if 式」として組み込むことにします。if 式の構文を示します。
</p>
<pre class="item">
if 条件式 then 式a else 式b end
if 条件式 then 式a end
</pre>
<p> if は条件式が真であれば式a を実行し、その結果が if 式の値になります。条件式が偽であれば 式b を実行して、その結果が if 式の値になります。else 節が省略されていて、かつ条件式が偽の場合、if 式は 0 を返すことにしましょう。
</p>

<h4>●文法の修正</h4>
<p> 文法を EBNF で表すと次のようになります。
</p>
<pre class="item">
[EBNF]
   文    = 関数定義 | 式.
関数定義 = "def", 関数, "(", [仮引数リスト], ")", 式, "end".
   式    = 代入式 | 式１.
 代入式  = 変数, "=", 式.
  式１   = 式２, { ("and" | "or"), 式２}.
  式２   = 式３, ("==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="), 式３.
  式３   = 項, { ("+" | "-"), 項 }.
   項    = 因子, { ("*" | "/"), 因子 }.
  因子   = 数値 | ("+" | "-" | "not"), 因子 | "(", 式, ")" | 変数 | 関数, "(", [引数リスト], ")" | if式.
  if式   = "if", 式, "then", 式, ["else", 式], "end".
  変数   = 識別子
  関数   = 識別子

仮引数リスト = 変数, { ",", 変数 }.
引数リスト   = 式, { ",", 式 }.

[注意] 数値と識別子の定義は省略
</pre>
<p> 論理演算子と比較演算子の処理は、文法をそのままプログラムするだけなので簡単です。if 式は then 節または else 節をスキップする処理が必要になるので、プログラムはちょっと複雑になります。
</p>

<h4>●字句解析の修正</h4>
<p> それではプログラムを作りましょう。まず最初に、関数 get-token を修正します。
</p>
<pre class="list">
リスト : トークンの切り出し

(define (get-token)
  ; 空白文字の読み飛ばし
  (while (char-whitespace? (getch))
    (nextch))
  (cond ((char-numeric? (getch))
         (set! *token* 'number)
         (set! *value* (get-number)))
        ((char-alphabetic? (getch))
         (set! *value* (get-ident))
         (case *value*
           ((def end if then else not and or)
            (set! *token* *value*))
           (else
            (set! *token* 'ident))))
        (else
         (case (getch)
          ((#\=)
           (set! *token* '=)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '==)
             (nextch)))
          ((#\+)
           (set! *token* '+)
           (nextch))
          ((#\-)
           (set! *token* '-)
           (nextch))
          ((#\*)
           (set! *token* '*)
           (nextch))
          ((#\/)
           (set! *token* '/)
           (nextch))
          ((#\()
           (set! *token* 'lpar)
           (nextch))
          ((#\))
           (set! *token* 'rpar)
           (nextch))
          ((#\&lt;)
           (set! *token* '&lt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&lt;=)
             (nextch)))
          ((#\&gt;)
           (set! *token* '&gt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&gt;=)
             (nextch)))
          ((#\!)
           (set! *token* 'not)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '!=)
             (nextch)))
          ((#\,)
           (set! *token* 'comma)
           (nextch))
          ((#\;)
           (set! *token* 'semic)
           (nextch))
          ((#\null)
           (set! *token* 'eof))
          (else
           (set! *token* 'others))))))
</pre>
<p> 識別子の処理で、*value* の値が def, end, if, then, else, not, and, or であれば、その値を *token* にセットします。それ以外の場合は ident をセットします。記号が = で、次の記号も = の場合は *token* にシンボル == をセットします。記号が ! の場合は *token* に not をセットし、次の記号が = であれば != に書き換えます。あとは同様に、&lt;, &lt;= と &gt;, &gt;= の処理を行います。
</p>

<h4>●構文解析の修正</h4>
<p> 次は構文解析の処理を修正します。論理演算子の処理は次のようになります。
</p>
<pre class="list">
リスト : 論理演算子の処理

; 式
(define (expression)
  (let ((val (expr1)))
    (case *token*
      ((=)
       ; 代入式の処理
       (unless (symbol? val)
         (error "invalid = form"))
       (get-token)
       (let ((val1 (eval-var (expression))))
         (update-variable val val1)
         val1))
      (else val))))

; 論理演算子 (and と or の優先順位は同じとする)
(define (expr1)
  (let loop ((val1 (expr2)))
    (case *token*
      ((and)
       (get-token)
       (let ((val2 (expr2)))
         (if (zero? (logand (eval-var val1) (eval-var val2)))
             (loop 0)
           (loop 1))))
      ((or)
       (get-token)
       (let ((val2 (expr2)))
         (if (zero? (logior (eval-var val1) (eval-var val2)))
             (loop 0)
           (loop 1))))
      (else val1))))
</pre>

<p> 式を評価する expression から関数 expr1 を呼び出します。expr1 は and と or の処理を行います。最初に、関数 expr2 を評価して返り値を val1 にセットします。次に、*token* が and または or の場合は、get-token を呼び出してから expr2 を評価して、返り値を val2 にセットします。and の場合、val1 と val2 の論理積が 0 でなければ、and の結果は 1 に、論理積が 0 であれば 0 になります。or の場合は論理和が 0 でなけれれば 1 に、論理和が 0 であれば 0 になります。
</p>
<p> なお、and と or は短絡演算子といって、値が確定した時点でそれ以降の引数は評価されません。今回はプログラムを簡単にするため、すべての引数を評価しています。短絡演算子として実装する場合、値が確定した時点で残りの引数の処理をスキップする必要があります。ご注意くださいませ。
</p>

<p> 次は比較演算子の処理を作ります。
</p>
<pre class="list">
リスト : 比較演算子の処理

; 比較演算子の取得
(define (getcmp op)
  (case op
    ((==) =)
    ((!=) (lambda (x y) (not (= x y))))
    ((&lt;)  &lt;)
    ((&lt;=) &lt;=)
    ((&gt;)  &gt;)
    ((&gt;=) &gt;=)
    (else
     (error "invalid operation:" op))))

; 比較演算子 (==, !=, &lt;, &lt;=, &gt;, &gt;= の優先順位は同じ)
(define (expr2)
  (let ((val1 (expr3)))
    (case *token*
      ((== != &lt; &lt;= &gt; &gt;=)
       (let ((op *token*))
         (get-token)
         (if ((getcmp op) (eval-var val1) (eval-var (expr3)))
             1
           0)))
      (else val1))))

(define (expr3)
  (let loop ((val (term)))
    (case *token*
      ((+)
       (get-token)
       (loop (eval-op + val (term))))
      ((-)
       (get-token)
       (loop (eval-op - val (term))))
      (else val))))
</pre>

<p> 関数 expr2 は比較演算子の処理を行います。比較演算子の定義は 式, 演算子, 式. なので、繰り返しは不要になります。最初に、expr3 を呼び出して左辺の式を評価し、その結果を val1 にセットします。次に、get-token を呼び出してから右辺の式を expr3 で評価して、その値と val1 を (getcmp op) で求めた関数で比較します。結果が真であれば 1 を、偽であれば 0 を返します。関数 expr3 は + と - の処理を行います。これは今までと同じです。
</p>

<p> 次は factor に not と if の処理を追加します。
</p>
<pre class="list">
リスト : 因子の処理

(define (factor)
  (case *token*
    ((lpar)
     (get-token)
     (let ((val (expression)))
       (if (eq? *token* 'rpar)
           (get-token)
         (error "')' expected"))
       val))
    ((number)
     (begin0 *value* (get-token)))
    ((+)
     ; 単項演算子
     (get-token)
     (eval-var (factor)))
    ((-)
     ; 単項演算子
     (get-token)
     (- (eval-var (factor))))
    ((not)
     ; 単項演算子
     (get-token)
     (if (zero? (eval-var (factor)))
         1
       0))
    ((if)
     ; if
     (get-token)
     (eval-if))
    ((ident)
     (let ((func (lookup-function *value*)))
       (cond (func
              ; 関数呼び出し
              (get-token)
              (if (eq? *token* 'lpar)
                  (if (string? (cdr func))
                      (call-usrfunc (cdr func))
                    (apply (cdr func) (get-argument)))
                (error "'(' expected")))
             (else
              ; 変数
              (begin0 *value* (get-token))))))
    (else
     (error "unexpected token" *token*))))
</pre>
<p> not は 右辺を factor で評価して、その結果が 0 ならば 1 を、そうでなければ 0 を返します。if の処理は関数 eval-if で行います。
</p>

<h4>●条件分岐の処理</h4>
<p> 次は if 式を評価する関数 eval-if を作ります。
</p>
<pre class="list">
リスト : if の評価

(define (eval-if)
  ; test の評価
  (let ((result (eval-var (expression))))
    (cond ((eq? *token* 'then)
           (get-token)
           (cond ((zero? result)
                  ; 偽
                  (skip-expression '(else end))
                  (cond ((eq? *token* 'else)
                         (get-token)
                         (let ((val (eval-var (expression))))
                           (unless (eq? *token* 'end)
                             (error "end expected"))
                           (get-token)
                           val))
                        ((eq? *token* 'end)
                         ; else 節は無し
                         (get-token)
                         0)
                        (else
                         (error "end expected"))))
                (else
                 ; 真
                 (let ((val (eval-var (expression))))
                   (when (eq? *token* 'else)
                     (get-token)
                     (skip-expression '(end semic)))
                   (unless (eq? *token* 'end)
                     (error "end expected"))
                   (get-token)
                   val))))
          (else
           (error "then expected")))))
</pre>
<p> 最初に expression を呼び出して条件式を評価して返り値を変数 result にセットます。そのあと、*token* が then であることを確認します。そうでなければエラーを送出します。次に、result が 0 ならば else 節の処理を行います。関数 skip-expression で then 節の式をスキップして *token* をチェックします。
</p>
<p> *token* が else であれば else 節が存在するので、その式を expression で評価します。そのあと、*token* が end であることを確認します。そうでなければエラーを送出します。それから、評価結果 val を返します。else 節がない場合は 0 を返します。
</p>
<p> result が 0 でなければ then 節を expression で評価します。そのあと、*token* が else であれば else 節が存在するので、それを skip-expression でスキップします。次に、*token* が end であることを確認します。そうでなければエラーを送出します。最後に評価結果 val を返します。
</p>

<p> 次は式をスキップする処理を作ります。
</p>
<pre class="list">
リスト : スキップ処理

; if のスキップ
(define (skip-if)
  ; 条件式をスキップ
  (skip-expression '(then else end))
  (unless (eq? *token* 'then)
    (error "then expected"))
  ; then 節をスキップ
  (get-token)
  (skip-expression '(else end))
  (when (eq? *token* 'else)
    (get-token)
    ; else 節をスキップ
    (skip-expression '(end)))
  (unless (eq? *token* 'end)
    (error "end expected"))
  (get-token))

; 式のスキップ
(define (skip-expression ends)
  (let loop ()
    (cond ((eq? *token* 'if)
           ; if のスキップ
           (get-token)
           (skip-if)
           (loop))
          ((not (member *token* ends))
           (get-token)
           (loop)))))
</pre>
<p> 関数 skip-expression は引数 ends で指定されたトークンまでスキップします。if は式なので、入れ子にすることができます。このため、if 式をスキップする専用の関数 skip-if を用意し、*token* が if ならばその if 式まるごとスキップするようにします。
</p>
<p> skip-if は if 式を解析しながらスキップしていきます。最初に条件式を skip-expression でスキップします。この場合、終端には then, else, end, を指定します。そのあと、*token* が then でなければエラーを送出します。次に、*token* が else であれば、終端に end を指定して else 節をスキップします。最後に *token* が end であることを確認し、get-token を呼び出して次のトークンを取り出します。これで if 式をスキップすることができます。
</p>

<h4>●実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
Calc&gt; not 0;
=&gt; 1
Calc&gt; not 1;
=&gt; 0
Calc&gt; ! 0;
=&gt; 1
Calc&gt; ! 1;
=&gt; 0
Calc&gt; 0 and 1;
=&gt; 0
Calc&gt; 1 and 1;
=&gt; 1
Calc&gt; 1 and 0;
=&gt; 0
Calc&gt; 0 and 0;
=&gt; 0
Calc&gt; 0 or 0;
=&gt; 0
Calc&gt; 0 or 1;
=&gt; 1
Calc&gt; 1 or 0;
=&gt; 1
Calc&gt; 1 or 1;
=&gt; 1
Calc&gt; 2 == 2;
=&gt; 1
Calc&gt; 2 == 1;
=&gt; 0
Calc&gt; 2 != 2;
=&gt; 0
Calc&gt; 2 != 1;
=&gt; 1
Calc&gt; 1 &lt; 2;
=&gt; 1
Calc&gt; 1 &lt;= 2;
=&gt; 1
Calc&gt; 2 &lt;= 1;
=&gt; 0
Calc&gt; 2 &gt; 1;
=&gt; 1
Calc&gt; 2 &gt;= 1;
=&gt; 1
Calc&gt; 1 &gt;= 2;
=&gt; 0
</pre>
<p> 論理演算子と比較演算子は正常に動作しているようです。次は論理演算子と比較演算子を組み合わせてみましょう。
</p>
<pre>
Calc&gt; not 1 or not 0;
=&gt; 1
Calc&gt; not 1 or not 1;
=&gt; 0
Calc&gt; not 0 or not 1;
=&gt; 1
Calc&gt; not 0 and not 0;
=&gt; 1
Calc&gt; not 0 and not 1;
=&gt; 0
Calc&gt; 1 &lt; 2 and 2 &lt; 3;
=&gt; 1
Calc&gt; 1 &lt; 2 and 3 &lt; 2;
=&gt; 0
Calc&gt; 1 &lt; 2 or 3 &lt; 2;
=&gt; 1
Calc&gt; 2 &lt; 1 or 3 &lt; 2;
=&gt; 0
</pre>
<p> これも正常に動作しているようです。次は if 式を試してみましょう。
</p>
<pre>
Calc&gt; if 1 &lt; 2 then 10 else -10 end;
=&gt; 10
Calc&gt; if 3 &lt; 2 then 10 else -10 end;
=&gt; -10
Calc&gt; if 3 &lt; 2 then 10 end;
=&gt; 0
Calc&gt; def abs(x) if x &gt; 0 then x else -x end end;
=&gt; abs
Calc&gt; abs(10);
=&gt; 10
Calc&gt; abs(-10);
=&gt; 10
Calc&gt; abs(10 - 11);
=&gt; 1
Calc&gt; abs(11 - 10);
=&gt; 1
</pre>
<p> 正常に動作していますね。条件分岐があると、再帰呼び出しで繰り返しを実現することができます。階乗を求める関数 fact とフィボナッチ数列を求める関数 fibo は次のようになります。
</p>
<pre>
Calc&gt; def fact(n) if n == 0 then 1 else n * fact(n - 1) end end;
=&gt; fact
Calc&gt; fact(8);
=&gt; 40320
Calc&gt; fact(9);
=&gt; 362880
Calc&gt; fact(10);
=&gt; 3628800
Calc&gt; def fibo(n) if n == 0 or n == 1 then 1 else fibo(n - 1) + fibo(n - 2) end end;
=&gt; fibo
Calc&gt; fibo(5);
=&gt; 8
Calc&gt; fibo(6);
=&gt; 13
Calc&gt; fibo(7);
=&gt; 21
Calc&gt; fibo(8);
=&gt; 34
Calc&gt; fibo(9);
=&gt; 55
Calc&gt; fibo(10);
=&gt; 89
</pre>
<p> 関数 fibo は二重再帰ですが、累積変数を使って末尾再帰に変換することができます。
</p>
<pre>
Calc&gt; def fiboi(n, a, b) if n == 0 then a else fiboi(n - 1, a + b, a) end end;
=&gt; fiboi
Calc&gt; fiboi(5, 1, 0);
=&gt; 8
Calc&gt; fiboi(6, 1, 0);
=&gt; 13
Calc&gt; fiboi(7, 1, 0);
=&gt; 21
Calc&gt; fiboi(10, 1, 0);
=&gt; 89
</pre>
<p> 電卓プログラムは末尾再帰最適化を行わないので繰り返しに変換することはできませんが、二重再帰よりも高速にフィボナッチ数列を求めることができます。
</p>
<p> 今回はここまでです。次回は字句解析と構文解析の処理を分離して、複数の式を順番に実行する begin 式と、式を繰り返し実行する while 式を追加してみましょう。
</p>

<h4>●参考文献</h4>
<ol>
  <li>松田晋, 『実践アルゴリズム戦略 解法のテクニック 再帰降下型構文解析』, C MAGAZINE 1992 年 9 月号, ソフトバンク
  <li>水野順, 『スクリプト言語を作ろう』, C MAGAZINE 2000 年 5 月号, ソフトバンク
  <li>松浦健一郎, 『コンパイラの作成』, C MAGAZINE 2003 年 1 月号, ソフトバンク
  <li>高田昌之, 『インタプリタ進化論』, ＣＱ出版社, 1992
  <li>久野靖, 『言語プロセッサ』, 丸善株式会社, 1993
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; calc3.scm : 電卓プログラム
;
;             Copyright (C) 2011 Makoto Hiroi
;
; 論理演算子、比較演算子を追加する
; if test then expr1 else expr2 end の追加
;

;;;
;;; 大域変数
;;;
(define *ch*    #f)
(define *token* #f)
(define *value* #f)
(define *input* (standard-input-port))

;;;
;;; 関数
;;;
(define *function*
  `((exp  . ,exp)
    (log  . ,log)
    (sin  . ,sin)
    (cos  . ,cos)
    (tan  . ,tan)
    (asin . ,asin)
    (acos . ,acos)
    (atan . ,atan)
    (sqrt . ,sqrt)
    (expt . ,expt)))

; 関数を求める
(define (lookup-function name)
  (assoc name *function*))

;;;
;;; 変数
;;;
(define *variable* '())

; 変数の値を求める
(define (lookup-variable var)
  (let ((cp (assoc var *variable*)))
    (if cp
        (cdr cp)
      (error "unbound variable:" var))))

; 変数の値を更新する
(define (update-variable var val)
  (let ((cp (assoc var *variable*)))
    (if cp
        (set-cdr! cp val)
      (push! *variable* (cons var val)))))

;;;
;;; 入力処理
;;;

; 文字の読み込み
(define (nextch)
  (set! *ch* (read-char *input*))
  (when (eof-object? *ch*)
    (set! *ch* #\null)))

; 先読み文字の取得
(define (getch) *ch*)

; 数値
(define (get-number)
  (let ((buff '()))
    ; 整数を buff に格納
    (define (get-numeric)
      (while (char-numeric? (getch))
        (push! buff (getch))
        (nextch)))
    ; 整数部
    (get-numeric)
    (case (getch)
      ((#\.)
       ; 小数部
       (push! buff (getch))
       (nextch)
       (get-numeric)
       (case (getch)
         ((#\d #\D #\e #\E)
          ; 指数部
          (push! buff (getch))
          (nextch)
          (when (or (eqv? (getch) #\+)
                    (eqv? (getch) #\-))
            (push! buff (getch))
            (nextch))
          ; 指数の数字
          (get-numeric))))
      ((#\/)
       ; 分数
       (push! buff (getch))
       (nextch)
       (get-numeric)))
    (string-&gt;number (list-&gt;string (reverse buff)))))

; 識別子
(define (get-ident)
  (let loop ((a '()))
    (if (not (char-alphabetic? (getch)))
        (string-&gt;symbol (list-&gt;string (reverse a)))
      (loop (begin0 (cons (getch) a) (nextch))))))

; トークンの切り出し
(define (get-token)
  ; 空白文字の読み飛ばし
  (while (char-whitespace? (getch))
    (nextch))
  (cond ((char-numeric? (getch))
         (set! *token* 'number)
         (set! *value* (get-number)))
        ((char-alphabetic? (getch))
         (set! *value* (get-ident))
         (case *value*
           ((def end if then else not and or)
            (set! *token* *value*))
           (else
            (set! *token* 'ident))))
        (else
         (case (getch)
          ((#\=)
           (set! *token* '=)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '==)
             (nextch)))
          ((#\+)
           (set! *token* '+)
           (nextch))
          ((#\-)
           (set! *token* '-)
           (nextch))
          ((#\*)
           (set! *token* '*)
           (nextch))
          ((#\/)
           (set! *token* '/)
           (nextch))
          ((#\()
           (set! *token* 'lpar)
           (nextch))
          ((#\))
           (set! *token* 'rpar)
           (nextch))
          ((#\&lt;)
           (set! *token* '&lt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&lt;=)
             (nextch)))
          ((#\&gt;)
           (set! *token* '&gt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&gt;=)
             (nextch)))
          ((#\!)
           (set! *token* 'not)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '!=)
             (nextch)))
          ((#\,)
           (set! *token* 'comma)
           (nextch))
          ((#\;)
           (set! *token* 'semic)
           (nextch))
          ((#\null)
           (set! *token* 'eof))
          (else
           (set! *token* 'others))))))

;;;
;;; if の評価
;;;

; if のスキップ
(define (skip-if)
  ; 条件式をスキップ
  (skip-expression '(then else end))
  (unless (eq? *token* 'then)
    (error "then expected"))
  ; then 節をスキップ
  (get-token)
  (skip-expression '(else end))
  (when (eq? *token* 'else)
    (get-token)
    ; else 節をスキップ
    (skip-expression '(end)))
  (unless (eq? *token* 'end)
    (error "end expected"))
  (get-token))


; 式のスキップ
(define (skip-expression ends)
  (let loop ()
    (cond ((eq? *token* 'if)
           ; if のスキップ
           (get-token)
           (skip-if)
           (loop))
          ((not (member *token* ends))
           (get-token)
           (loop)))))

; if の評価
(define (eval-if)
  ; test の評価
  (let ((result (eval-var (expression))))
    (cond ((eq? *token* 'then)
           (get-token)
           (cond ((zero? result)
                  ; 偽
                  (skip-expression '(else end))
                  (cond ((eq? *token* 'else)
                         (get-token)
                         (let ((val (eval-var (expression))))
                           (unless (eq? *token* 'end)
                             (error "end expected"))
                           (get-token)
                           val))
                        ((eq? *token* 'end)
                         ; else 節は無し
                         (get-token)
                         0)
                        (else
                         (error "end expected"))))
                (else
                 ; 真
                 (let ((val (eval-var (expression))))
                   (when (eq? *token* 'else)
                     (get-token)
                     (skip-expression '(end semic)))
                   (unless (eq? *token* 'end)
                     (error "end expected"))
                   (get-token)
                   val))))
          (else
           (error "then expected")))))

;;;
;;; 式の評価
;;;

; 変数の評価
(define (eval-var var)
  (if (number? var)
      var
    (lookup-variable var)))

; 演算子の評価
(define (eval-op op var1 var2)
  (op (eval-var var1) (eval-var var2)))

; 式
(define (expression)
  (let ((val (expr1)))
    (case *token*
      ((=)
       ; 代入式の処理
       (unless (symbol? val)
         (error "invalid = form"))
       (get-token)
       (let ((val1 (eval-var (expression))))
         (update-variable val val1)
         val1))
      (else val))))

; 論理演算子 (and と or の優先順位は同じとする)
(define (expr1)
  (let loop ((val1 (expr2)))
    (case *token*
      ((and)
       (get-token)
       (let ((val2 (expr2)))
         (if (zero? (logand (eval-var val1) (eval-var val2)))
             (loop 0)
           (loop 1))))
      ((or)
       (get-token)
       (let ((val2 (expr2)))
         (if (zero? (logior (eval-var val1) (eval-var val2)))
             (loop 0)
           (loop 1))))
      (else val1))))

; 比較演算子の取得
(define (getcmp op)
  (case op
    ((==) =)
    ((!=) (lambda (x y) (not (= x y))))
    ((&lt;)  &lt;)
    ((&lt;=) &lt;=)
    ((&gt;)  &gt;)
    ((&gt;=) &gt;=)
    (else
     (error "invalid operation:" op))))


; 比較演算子 (==, !=, &lt;, &lt;=, &gt;, &gt;= の優先順位は同じとする)
(define (expr2)
  (let ((val1 (expr3)))
    (case *token*
      ((== != &lt; &lt;= &gt; &gt;=)
       (let ((op *token*))
         (get-token)
         (if ((getcmp op) (eval-var val1) (eval-var (expr3)))
             1
           0)))
      (else val1))))

(define (expr3)
  (let loop ((val (term)))
    (case *token*
      ((+)
       (get-token)
       (loop (eval-op + val (term))))
      ((-)
       (get-token)
       (loop (eval-op - val (term))))
      (else val))))

; 項
(define (term)
  (let loop ((val (factor)))
    (case *token*
      ((*)
       (get-token)
       (loop (eval-op * val (factor))))
      ((/)
       (get-token)
       (loop (eval-op / val (factor))))
      (else val))))

; 実引数の取得
(define (get-argument)
  (get-token)
  (if (eq? *token* 'rpar)
      ; 引数無し
      (begin (get-token) '())
    (let loop ((a '()))
      (let ((val (eval-var (expression))))
        (case *token*
          ((rpar)
           (get-token)
           (reverse (cons val a)))
          ((comma)
           (get-token)
           (loop (cons val a)))
          (else
           (error "unexpected token in argument list" *token*)))))))

; 仮引数の取得
(define (get-parameter)
  (get-token)
  (unless (eq? *token* 'lpar)
    (error "'(' expected"))
  (get-token)
  (let loop ((a '()))
    (let ((val *value*))
      (case *token*
        ((rpar)
         (get-token)
         (reverse a))
        ((ident)
         (let ((val *value*))
           (get-token)
           (loop (cons val a))))
        ((comma)
         (get-token)
         (loop a))
        (else
         (error "unexpected token in parameter list" *token*))))))

; 変数束縛
(define (add-binding pars args)
  (let loop ((pars pars) (args args))
    (cond ((and (pair? pars) (pair? args))
           (push! *variable* (cons (car pars) (car args)))
           (loop (cdr pars) (cdr args)))
          ((and (pair? pars) (null? args))
           (push! *variable* (cons (car pars) 0))
           (loop (cdr pars) args)))))

; ユーザー関数の呼び出し
(define (call-usrfunc buff)
  (let ((args (get-argument)))   ; 実引数の取得
    (call-with-input-string buff
      (lambda (in)
        (let ((save-port  *input*)
              (save-ch    *ch*)
              (save-token *token*)
              (save-value *value*)
              (save-var   *variable*))
          (set! *input* in)
          (nextch)
          (add-binding (get-parameter) args)
          (unwind-protect
            ; 本体の評価
            (begin0
              (eval-var (expression))
              (unless (eq? *token* 'end)
                (error "end expected")))
              ; (get-token))
            (begin
              ; 環境の復帰
              (set! *input* save-port)
              (set! *ch*    save-ch)
              (set! *token* save-token)
              (set! *value* save-value)
              (set! *variable* save-var))))))))

; 因子
(define (factor)
  (case *token*
    ((lpar)
     (get-token)
     (let ((val (expression)))
       (if (eq? *token* 'rpar)
           (get-token)
         (error "')' expected"))
       val))
    ((number)
     (begin0 *value* (get-token)))
    ((+)
     ; 単項演算子
     (get-token)
     (eval-var (factor)))
    ((-)
     ; 単項演算子
     (get-token)
     (- (eval-var (factor))))
    ((not)
     (get-token)
     (if (zero? (eval-var (factor)))
         1
       0))
    ((if)
     (get-token)
     (eval-if))
    ((ident)
     (let ((func (lookup-function *value*)))
       (cond (func
              ; 関数呼び出し
              (get-token)
              (if (eq? *token* 'lpar)
                  (if (string? (cdr func))
                      (call-usrfunc (cdr func))
                    (apply (cdr func) (get-argument)))
                (error "'(' expected")))
             (else
              ; 変数
              (begin0 *value* (get-token))))))
    (else
     (error "unexpected token" *token*))))

;;;
;;;
;;;

; ユーザー定義関数の本体を取得
(define (get-usrfunc)
  (let loop ((a '()))
    (if (eqv? (getch) #\;)
        (begin0 (list-&gt;string (reverse (cons (getch) a)))
                (nextch))
      (loop (begin0 (cons (getch) a)
                    (nextch))))))

; 値を表示する
(define (display-value value)
  (display "=&gt; ")
  (display value)
  (newline))

; 式の入力と評価
(define (toplevel)
  (cond ((eq? *token* 'def)
         ; 関数定義
         (get-token)
         (unless (eq? *token* 'ident)
           (error "invalid def form"))
         (let ((name *value*))
           (push! *function* (cons name (get-usrfunc)))
           (display-value name)))
        (else
         ; 式
         (let ((val (eval-var (expression))))
           (if (eq? *token* 'semic)
               (display-value val)
             (error "invalid token:" *token*)))))
  (display "Calc&gt; ")
  (flush))

; 入力をクリアする
(define (clear-input-data)
  (while (not (eqv? *ch* #\return))
    (nextch))
  (display "Calc&gt; ")
  (flush))

; 電卓プログラムの実行
(define (calc)
  (display "Calc&gt; ")
  (flush)
  (nextch)
  (call/cc
    (lambda (break)
      (let loop ()
        (guard (err
                 ((&lt;error&gt; err)
                  (format #t "ERROR: ~S~%" (condition-ref err 'message))
                  (clear-input-data)))
          (get-token)
          (when (eqv? *token* 'eof) (break #t))
          (toplevel))
        (loop)))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm52.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm54.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>