<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881788</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell04.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">遅延評価</a></h3>
<p> 今回は Haskell の特徴である「遅延評価 (delayed evaluation または lazy evaluation) 」について説明します。なお、このドキュメントは拙作のページ <a href="../memo12.html">Memorandum 2012 年 12 月</a> に書いた Haskell の話を加筆・修正したものです。内容は重複していますが、あしからずご了承くださいませ。
</p>

<h4>●Haskell の遅延評価</h4>
<p> 一般的なプログラミング言語の場合、関数を呼び出す前に引数が評価され、その結果が関数に渡されます。これを「正格 (strict) な評価」といいます。Haskell は正格評価ではありません。関数の引数は、その値が必要になるまで評価は行われません。具体的には、引数を参照するときに評価が行われます。これを「遅延評価」といいます。そして、その評価結果は保存されることに注意してください。再度引数を参照すると、保存されている値が返されます。この動作は Scheme の delay, force とほとんど同じです。
</p>

<p> 遅延評価は関数の引数を評価するときだけではなく、変数の値を評価するときにも行われます。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; :m Debug.Trace
Prelude Debug.Trace&gt; let foo = trace "oops!" (10 + 20)
Prelude Debug.Trace&gt; foo
oops!
30
Prelude Debug.Trace&gt; foo
30
</pre>
<p> Haskell のモジュール Debug.Trace にある関数 trace を使うと、遅延評価されていることがよくわかると思います。trace は第 2 引数の式を評価して返しますが、このとき第 1 引数の文字列を画面に表示します。:m はモジュールをロードする ghci のコマンドです。
</p>
<p> 10 + 20 の結果を変数 foo にセットします。このとき、式 10 + 20 は評価されていないことに注意してください。(単純な式であればコンパイルの段階で計算されます。) foo を参照すると式 10 + 20 を評価して値 30 が得られます。このとき、oops! が表示されます。foo を再度参照すると、式を評価せずに保存した値を返すので oops! は表示されません。
</p>
<p> もうひとつ簡単な例を示しましょう。
</p>
<pre>
Prelude Debug.Trace&gt; let a = trace "oops-a" 10
Prelude Debug.Trace&gt; let b = trace "oops-b" 20
Prelude Debug.Trace&gt; let c = trace "oops-c" 30
Prelude Debug.Trace&gt; let add3 x y z = x + y
Prelude Debug.Trace&gt; add3 a b c
oops-a
oops-b
30
</pre>
<p> 関数 add3 は 3 つの引数 x, y, z を受け取りますが、x と y しか参照していません。この場合、引数 z は評価されません。実際、add3 a b c を評価すると、変数 a, b は評価されて oops-a, oops-b が表示されますが oops-c は表示されないので、変数 c は評価されていないことがわかります。
</p>

<h4>●たらいまわし関数</h4>
<p> それでは、遅延評価の簡単な例題として「たらいまわし関数」を取り上げます。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数

tarai :: Int -&gt; Int -&gt; Int -&gt; Int
tarai x y z =
  if x &lt;= y then y
  else tarai (tarai (x - 1) y z) (tarai (y - 1) z x) (tarai (z - 1) x y)

tak :: Int -&gt; Int -&gt; Int -&gt; Int
tak x y z =
  if x &lt;= y then z
  else tak (tak (x - 1) y z) (tak (y - 1) z x) (tak (z - 1) x y)
</pre>

<p> 関数 tarai や tak は「たらいまわし関数」といって、再帰的に定義されています。これらの関数は、引数の与え方によっては実行に時間がかかるため、Lisp などのベンチマークに利用されることがあります。
</p>

<p> 関数 tarai は通称「竹内関数」と呼ばれていて、日本の代表的な Lisper である竹内郁雄先生によって考案されたそうです。そして、関数 tak は関数 tarai のバリエーションで、John Macarthy 先生によって作成されたそうです。たらいまわし関数が Lisp のベンチマークで使われていたことは知っていましたが、このような由緒ある関数だとは思ってもいませんでした。
</p>

<p> 関数 tarai は遅延評価を行う処理系では高速に実行できることが知られています。正格な評価を行うプログラミング言語では時間がかかっても、Haskell ではあっというまに計算することができます。
</p>

<p> tarai のプログラムを見てください。x &lt;= y のときに y を返しますが、このとき引数 z の値は必要ありませんね。Haskell は x &gt; y のときにだけ引数 z を評価するので、無駄な計算を省略することができます。なお、関数 tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意ください。
</p>

<p> 実行時間を比較するため、x &lt;= y のときにも引数 z を評価する関数 tarai' を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数 (2)

tarai' :: Int -&gt;  Int -&gt; Int -&gt; Int
tarai' x y z =
  if x &lt;= y then z `seq` y
  else tarai' (tarai' (x - 1) y z) (tarai' (y - 1) z x) (tarai' (z - 1) x y)
</pre>
<p> 関数 seq x y は x を評価してから y を評価する関数です。返り値は y の評価結果です。x `seq` y `seq` z とすると、x, y, z の順番で評価し、最後に評価した z の結果を返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude&gt; :m Debug.Trace
Prelude Debug.Trace&gt; let x = trace "oops-x" 10
Prelude Debug.Trace&gt; let y = trace "oops-y" 20
Prelude Debug.Trace&gt; let z = trace "oops-z" 30
Prelude Debug.Trace&gt; x `seq` y `seq` z
oops-x
oops-y
oops-z
30
</pre>
<p> tarai' は x &lt;= y のときに z `seq` y で引数 z を評価して無駄な計算を行っているので、実行時間はとても遅くなるはずです。それでは実行してみましょう。
</p>
<pre>
*Main&gt; :set +s
*Main&gt; tarai' 12 6 0
12
(11.53 secs, 1576415280 bytes)
*Main&gt; tarai 12 6 0
12
(0.00 secs, 552932 bytes)

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> コマンド :set で +s を指定すると、実行時間と使用したメモリを表示します。取り消す場合はコマンド :unset を使います。
</p>
<p> 結果は一目瞭然で、tarai' は約 12 秒かかりますが、tarai は瞬時に計算を終えてしまいます。なお、これはインタプリタ ghci での結果であり、コンパイルするともっと高速になるでしょう。興味のある方はいろいろ試してみてください。
</p>

<h4>●末尾再帰</h4>
<p> 再帰定義のなかで、処理の最後で再帰呼び出しを行う場合を「末尾再帰 (tail recursion) 」といいます。英語では tail recursion ですが、日本語では末尾再帰のほかに末端再帰とか終端再帰と呼ぶことがあります。末尾再帰は簡単な処理で繰り返しに変換できることが知られています。
</p>
<p> ML や Lisp などの関数型言語や論理型言語の Prolog では、プログラムをコンパイルもしくは実行するときに、末尾再帰を繰り返しに変換する処理系があります。この機能を「末尾再帰最適化」<sup><a href="haskell05.html#note1">[*1]</a></sup> といいます。なかには Scheme <sup><a href="haskell05.html#note2">[*2]</a></sup> のように、言語仕様に末尾再帰最適化を行うことを明記しているプログラミング言語もあります。
</p>

<p> たとえば、階乗を計算する関数 fact を思い出してください。
</p>
<pre class="list">
リスト : 階乗

fact :: Integer -&gt; Integer
fact 0 = 1
fact n = n * fact (n - 1)
</pre>
<p> 上記リストの fact は最後に n と fact の返り値を乗算しているので、このプログラムは末尾再帰ではありません。これを末尾再帰に変換すると次のようになります。
</p>

<pre class="list">
リスト : 階乗 (末尾再帰)

fact :: Integer -&gt; Integer
fact n = facti n 1 where
  facti 0 a = a
  facti n a = facti (n - 1) (a * n)
</pre>

<p> 局所関数 facti を見てください。最後の再帰呼び出しで、facti の返り値をそのまま返しているので、このプログラムは末尾再帰になっています。これで階乗を計算できるなんて、ちょっと不思議に思われるかもしれません。そこが再帰呼び出しの面白いところです。このプログラムでは引数 a の使い方がポイントです。
</p>

<p> たとえば facti 4 1 を実行すると、このプログラムでは 4 * 3 * 2 * 1 を計算しています。このとき、計算の途中経過を変数 a に記憶しているのです。正格評価を行う処理系で、末尾再帰最適化を適用する前の facti の呼び出しを図に示すと、次のようになります。
</p>
<pre class="fig">
facti 4 1
  facti 3 4
    facti 2 12 
      facti 1 24
        facti 0 24
        =&gt; a の値 24 を返す
      =&gt; 24
    =&gt; 24
  =&gt; 24
=&gt; 24
</pre>
<p> 変数 a には計算途中の値が格納されていることがわかります。このような変数を「累算変数」とか「累算器」といいます。純粋な関数型言語では、while や loop など繰り返しの構文が用意されていない言語があります。Haskell もそうですが、論理型言語の Prolog にも単純な繰り返しはありません。これらのプログラミング言語では、繰り返しのかわりに末尾再帰を使ってプログラミングを行い、末尾再帰最適化によりプログラムを高速に実行することができます。
</p>
<p> ただし、Haskell は遅延評価を行う処理系なので、上図のような動作をするとは限りません。これはあとで詳しく説明します。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 末尾再帰最適化は一般的な呼び方で、厳密には「末尾呼び出し最適化」とか「末尾最適化」といいます。詳しい説明は拙作のページ <a href="scheme.html">Scheme Programming</a> <a href="abcscm58.html">関数型電卓プログラム fncalc の作成 (4)</a> 末尾再帰とは？ をお読みください。<br>
<a name="note2">[*2]</a> Scheme は Lisp の方言の一つです。Scheme は Lisp の標準である Common Lisp よりもシンプルな仕様で、熱心なユーザが多いプログラミング言語です。
</div>
<h4>●フィボナッチ関数の高速化</h4>
<p> 今度は累算変数を使って、二重再帰を末尾再帰へ変換してみましょう。例題としてフィボナッチ関数を取り上げます。<a href="haskell02.html">再帰定義</a> で作成したフィボナッチ関数は二重再帰になっているので、とても時間がかかります。二重再帰を末尾再帰に変換すると、プログラムを高速に実行することができます。次のリストを見てください。
</p>

<pre class="list">
リスト : フィボナッチ関数(末尾再帰)

fibo :: Integer -&gt; Integer
fibo n = fiboi n 1 0 where
  fiboi 0 a1 _  = a1
  fiboi n a1 a2 = fibo (n - 1) (a1 + a2) a1
</pre>

<p> 局所関数 fiboi の累算変数 a1 と a2 の使い方がポイントです。現在のフィボナッチ数を変数 a1 に、ひとつ前の値を変数 a2 に格納しておきます。あとは a1 と a2 を足し算して、新しいフィボナッチ数を計算すればいいわけです。fiboi の呼び出しを図に示すと、次のようになります。
</p>
<pre class="fig">
fiboi 5 1 0
  fiboi 4 1 1
    fiboi 3 2 1
      fiboi 2 3 2
        fiboi 1 5 3
          fiboi 0 8 5
          =&gt; a1 の値 8 を返す
        =&gt; 8
      =&gt; 8
    =&gt; 8
  =&gt; 8
=&gt; 8

図 : 関数 fiboi の呼び出し
</pre>
<p> 二重再帰では、同じ値を何回も求めていたため効率がとても悪かったのですが、このプログラムでは無駄な計算を行っていないので、値を高速に求めることができます。
</p>

<h4>●末尾再帰と正格評価</h4>
<p> Haskell は遅延評価を行う処理系なので、「末尾再帰」でプログラムしたからといって、正格評価を行う処理系と同じ動作になるとは限りません。たとえば、整数 1 から n までの合計値を求める関数 sum' を作ってみましょう。
</p>
<pre class="list">
リスト : 1 から n までの合計値を求める

sum' :: Integer -&gt; Integer
sum' 0 = 0
sum' n = n + sum' (n - 1)

-- 末尾再帰
sumi :: Integer -&gt; Integer
sumi n = iter n 0
  where
    iter 0 a = a
    iter n a = iter (n - 1) (a + n)
</pre>
<p> どちらも簡単な関数ですが、n が大きな値になると関数 sum' はスタックオーバーフローします。実際、最適化オプションを指定せずに GHC でコンパイルして試してみたところ、n = 1000000 で sum' はスタックオーバーフローします。ところが、末尾再帰でプログラムした sumi もスタックオーバーフローするのです。これは Haskell の遅延評価が原因です。
</p>
<p> 累積変数 a の値は、sumi の返り値が必要となるまで評価されません。たとえば、n = 5 とすると、再帰呼び出しで (((((0 + 5) + 4) + 3) + 2) + 1) という式が組み立てられ、sumi の返り値を評価するときに、この式が計算されて合計値が求められます。次のように、trace を使うと式 (a + n) が遅延評価されていることがよくわかります。
</p>
<pre class="list">
リスト : トレース表示

import Debug.Trace

sumi :: Integer -&gt; Integer
sumi n = iter n 0
  where
    iter 0 a = trace "oops0" a
    iter n a = iter (n - 1) (trace "oops1" (a + n))
</pre>
<pre>
*Main> sumi 5
oops0
oops1
oops1
oops1
oops1
oops1
15
</pre>
<p> 最初に iter の返り値 a が評価され、そのことにより組み立てられていた式が順番に評価されていくことがわかると思います。この場合、組み立てた式を保存するメモリが必要になるため、末尾再帰でプログラムしても n が大きくなるとスタックオーバーフローしてしまいます。
</p>
<p> このような場合、正格評価を行う関数 seq を使うとうまくいきます。次のリストを見てください。
</p>
<pre class="list">
リスト : 正格評価バージョン

sumi' :: Integer -&gt; Integer
sumi' n = iter n 0
  where
    iter 0 a = a
    iter n a = a `seq` iter (n - 1) (n + a)
</pre>
<p> seq で累積変数 a を強制的に評価します。これで再帰呼び出しが行われるたびに式を計算するので、n が大きな値でもスタックオーバーフローせずに計算することができます。
</p>
<p> 実際に実行すると次のようになります。
</p>
<pre>
 表 : 実行結果 (単位 秒)

  n   | 500000 | 1000000
------+--------+----------
sum'  | 0.140  | Overflow
sumi  | 0.187  | Overflow
sumi' | 0.062  | 0.156

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> ところで、ghc に最適化オプション -O を指定すると、結果は次のようになりました。
</p>
<pre>
 表 : 実行結果 (単位 秒)

  n   | 500000 | 1000000
------+--------+----------
sum'  | 0.093  | 0.172
sumi  | 0.031  | 0.078
sumi' | 0.047  | 0.078

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> sum' も sumi もオーバーフローせずに実行することができました。GHC の最適化はとても優秀ですね。M.Hiroi は Haskell 初心者なので、GHC がどこまで最適化してくれるのかよくわかりませんが、必要であれば、最適化に頼らずに正格評価を使ったほうがよいのかもしれません。たとえば、畳み込みを行う関数 foldl には、正格評価を行う関数 foldl' がモジュール Data.List に用意されています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude> :set +s
Prelude> :m Data.List
Prelude Data.List> foldl (+) 0 [1 .. 1000000]
500000500000
(0.53 secs, 141374364 bytes)
Prelude Data.List> foldl' (+) 0 [1 .. 1000000]
500000500000
(0.17 secs, 104505380 bytes)

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> foldl よりも foldl' のほうが速いみたいですね。興味のある方はいろいろ試してみてください。
</p>

<h4>●遅延ストリーム</h4>
<p> 次は拙作のページ <a href="scheme.html">Scheme Programming</a> <a href="abcscm23.html">遅延ストリーム (1)</a>, <a href="abcscm24.html">(2)</a> で取り上げた「遅延ストリーム」を Haskell でプログラムしてみましょう。Haskell はデフォルトで「遅延評価」を行う処理系なので、「リスト」をそのまま遅延ストリームとして扱うことができます。
</p>
<h4>●整数列の生成</h4>
<p> たとえば、n から始まる整数列を生成する場合、 Haskell は [n .. ] で実現できますが、次のように定義することもできます。
</p>
<pre class="list">
リスト : 整数列の生成

intgen :: Integer -&gt; [Integer]
intgen n = n : intgen (n + 1)
</pre>
<p> 関数 intgen を再帰呼び出しして、その返り値 (リスト) に整数 n を追加します。リストを生成する簡単なプログラムですが、再帰呼び出しの停止条件がないため、正格な評価を行うプログラミング言語では動作しません。ところが、Haskell のように遅延評価を行う処理系では、必要なときがくるまで intgen の評価は遅延されます。たとえば、関数 take で要素を 10 個取り出す場合、intgen は (10 - 1) 回だけしか評価されません。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; :t take
take :: Int -&gt; [a] -&gt; [a]
*Main&gt; take 3 [1,2,3,4,5,6]
[1,2,3]
*Main&gt; take 0 [1,2,3,4,5,6]
[]
*Main&gt; take 6 [1,2,3,4,5,6]
[1,2,3,4,5,6]
</pre>
<pre>
*Main&gt; take 10 (intgen 1)
[1,2,3,4,5,6,7,8,9,10]
*Main&gt; take 10 (intgen 100)
[100,101,102,103,104,105,106,107,108,109]
*Main&gt; let nums = intgen 0
*Main&gt; nums !! 10
10
*Main&gt; nums !! 100
100
</pre>
<p> 記号 !! は左辺のリストの要素を参照する演算子です。Haskell の場合、リストは 0 から数えます。nums は 0 から始まる整数列なので、10 番目の要素は 10 で、100 番目の要素は 100 になります。
</p>
<p> trace を使うと、遅延評価されていることがよくわかります。次のプログラムを見てください。
</p>
<pre class="list">
リスト : 整数列の生成 (2)

import Debug.Trace

-- n から m までの整数列
intgen' :: Integer -&gt; Integer -&gt; [Integer]
intgen' n m
  | n &gt; m     = []
  | otherwise =  n : trace "oops!" (intgen' (n + 1) m)
</pre>
<p> intgen' n m は n 以上 m 以下の整数列を生成します。Haskell の [n .. m] と同じですが、trace を使って intgen が評価されるときに文字列 "oops!" を画面に表示しています。それでは実行してみましょう。
</p>
<pre>
*Main&gt; intgen' 1 10
[1oops!
,2oops!
,3oops!
,4oops!
,5oops!
,6oops!
,7oops!
,8oops!
,9oops!
,10oops!
]
*Main&gt; take 5 (intgen' 1 10)
[1oops!
,2oops!
,3oops!
,4oops!
,5]
</pre>
<p> intgen' 1 10 を評価すると、1 から 10 を格納したリストが生成されます。このとき、oops! が 10 回表示されていて、intgen' が 10 回評価されていることがわかります。これに対し、take 5 (intgen' 1 10) は oops! が 4 回しか評価されていません。残りの 6 回は評価されていない、つまり遅延評価されている、というわけです。
</p>

<p> ところで、intgen' は無限リストではありませんが、Haskell では遅延ストリームとして機能します。これを次のように末尾再帰でプログラムすると、遅延ストリームにはなりません。
</p>
<pre class="list">
リスト : 整数列の生成 (3)

intgen'' :: Integer -&gt; Integer -&gt; [Integer]
intgen'' n m = iter m [] where
  iter m a
     | n &gt; m     = a
     | otherwise = trace "oops!" (iter (m - 1) (m:a))
</pre>
<p> 局所関数 iter は末尾再帰になっていて、累積変数 a に m を追加してリストを生成しています。それでは実行してみましょう。
</p>
<pre>
*Main&gt; intgen'' 1 10
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
[1,2,3,4,5,6,7,8,9,10]
*Main&gt; take 5 (intgen'' 1 10)
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
oops!
[1,2,3,4,5]
</pre>
<p> intgen'' 1 10 は oops! が 10 回表示されているので、intgen'' が 10 回呼び出されていることがわかります。これに対し、take 5 (intgen'' 1 10) も oops! が 10 回表示されいて、遅延ストリームとして動作していないことがわかります。intgen'' の場合、返り値となるリストの先頭要素は、プログラムを最後まで実行しないと求めることができません。つまり、正格な評価と同じになってしまうのです。
</p>
<p> ところが、intgen は "要素 : 再帰呼び出し" の形になっているので、返り値のリストの先頭要素はすぐに求めることができますね。そして、次の要素が必要なるまで、intgen の評価を遅延することができます。このように、リストを遅延ストリームとして扱いたい場合は、末尾再帰ではなく次の形式でプログラムしてください。
</p>
<pre class="item">
関数 引数 ... = 要素 : 再帰呼び出し 引数 ...
</pre>
<p> 今まで M.Hiroi は ML や Lisp / Scheme などでプログラムするとき、効率を重視して末尾再帰でプログラムすることが多かったのですが、Haskell のような遅延評価を行う処理系では、末尾再帰にこだわる必要はないのかもしれません。
</p>

<h4>●フィボナッチ数列の生成</h4>
<p> フィボナッチ数列も簡単に作ることができます。
</p>
<pre class="list">
リスト : フィボナッチ数列の生成

fibgen :: Integer -&gt; Integer -&gt; [Integer]
fibgen a b = a : fibgen b (a + b)
</pre>
<p> 関数 fibgen の引数 a がフィボナッチ数列の最初の項で、b が次の項です。fibgen b (a + b) が評価されるたびに、フィボナッチ数列の新しい項が生成されていきます。Haskell の型 Integer は多倍長整数なので、メモリの許す限りフィボナッチ数列を生成することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; take 20 (fibgen 1 1)
[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
*Main&gt; take 40 (fibgen 1 1)
[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,
28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,
9227465,14930352,24157817,39088169,63245986,102334155]

*Main&gt; let fibs = fibgen 1 1
*Main&gt; fibs !! 0
1
*Main&gt; fibs !! 10
89
*Main&gt; fibs !! 100
573147844013817084101
</pre>

<h4>●遅延ストリームの連結</h4>
<p> 次は 2 つの遅延ストリームを結合することを考えてみましょう。Haskell の場合、リストは演算子 ++ で結合できますが、遅延ストリーム同士の結合はできません。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; let ones = 1 : ones
Prelude&gt; take 10 ones
[1,1,1,1,1,1,1,1,1,1]

Prelude&gt; let twos = 2 : twos
Prelude&gt; take 10 twos
[2,2,2,2,2,2,2,2,2,2]

Prelude&gt; take 20 (ones ++ twos)
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
</pre>
<p> 変数 ones は要素が 1 の遅延ストリーム (循環リスト)、twos は要素が 2 の遅延ストリームになります。これは関数 repeat を使っても実現できます。簡単な実行例を示しましょう。
</p>
<pre>
Prelude&gt; let ones' = repeat 1
Prelude&gt; take 10 ones'
[1,1,1,1,1,1,1,1,1,1]

Prelude&gt; let twos' = repeat 2
Prelude&gt; take 20 twos
[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]

Prelude&gt; take 20 (ones' ++ twos')
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
</pre>
<p> ones ++ twos で生成した新しい遅延ストリームは、けっきょく左辺のストリームの要素しか取り出すことができないのです。
</p>
<p> このような場合、ストリームの要素を交互に出力する関数を用意すると便利です。次のリストを見てください。
</p>
<pre class="list">
リスト : 遅延ストリームの要素を交互に出力

interleave :: [a] -&gt; [a] -&gt; [a]
interleave []     ys = ys
interleave (x:xs) ys = x : interleave ys xs
</pre>
<p> 関数 interleave は 2 つのリスト xs, ys を受け取ります。そして、xs の要素 x をリストに格納したら、次は ys の要素をリストに格納します。これは interleave を再帰呼び出しするとき、引数 xs と ys の順番を交換するだけです。これで xs と ys の要素を交互に出力することができます。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
*Main&gt; take 20 (interleave ones twos)
[1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
</pre>
<h4>●高階関数</h4>
<p> Haskell の場合、マッピングやフィルターなどの高階関数はそのまま遅延ストリームにも適用できます。ただし、畳み込み foldl と foldr を無限リストに適用するときには注意が必要です。基本的に foldl は無限リストに適用できません。foldr の場合、返り値がリストであれば無限リストにも適用することができます。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; take 20 (map (*2) [1..])
[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]

Prelude&gt; take 20 (filter even [1..])
[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]

Prelude&gt; take 20 (foldr (:) [] [1..])
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
</pre>
<p> なお、foldr は値を求める処理、たとえば foldr (+) 0 [1..] は当然ですが実行できません。
</p>
<p> 遅延ストリームを操作する場合、2 つの遅延ストリームを受け取るマップ関数 map2 があると便利です。プログラムは次のようになります。
</p>
<pre class="list">
リスト : マップ関数

map2 :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
map2 f (x:xs) (y:ys) = f x y : map2 f xs ys
map2 _ _      _      = []
</pre>
<p> リスト xs と ys からそれぞれの要素を取り出して関数 f に渡します。そして、その評価結果を map2 の返り値 (リスト) に格納します。どちらかのリストが空リストのときが再帰呼び出しの停止条件です。これで有限なリストにも無限の遅延ストリームにも対応することができます。なお、Haskell には同じ働きをする関数 zipWith が用意されています。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
*Main&gt; map2 (+) [1,2,3,4,5] [6,7,8,9,10]
[7,9,11,13,15]
*Main&gt; map2 (*) [1 ..] [6,7,8,9,10]
[6,14,24,36,50]
*Main&gt; take 20 (map2 (*) [1 ..] [10 ..])
[10,22,36,52,70,90,112,136,162,190,220,252,286,322,360,400,442,486,532,580]

*Main&gt; zipWith (+) [1,2,3,4,5] [6,7,8,9,10]
[7,9,11,13,15]
*Main&gt; zipWith (*) [1 ..] [6,7,8,9,10]
[6,14,24,36,50]
*Main&gt; take 20 (zipWith (*) [1 ..] [10 ..])
[10,22,36,52,70,90,112,136,162,190,220,252,286,322,360,400,442,486,532,580]
</pre>
<p> map2 (zipWith) を使うと、遅延ストリームに対していろいろな処理を定義することができます。次の例を見てください。
</p>
<pre>
*Main&gt; let add_stream s1 s2 = zipWith (+) s1 s2
*Main&gt; let s3 = add_stream [1 ..] [100 ..]
*Main&gt; take 20 s3
[101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,137,139]
</pre>
<p> add_stream は s1 と s2 の要素を加算した遅延ストリームを返します。この add_stream を使うと、整数を生成する遅延ストリームは次のように定義することができます。
</p>

<pre>
*Main&gt; let ints = 1 : add_stream ones ints
*Main&gt; take 20 ints
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]

*Main&gt; let fibs = 1 : 1 : add_stream (tail fibs) fibs
*Main&gt; take 20 fibs
[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
</pre>
<p> ストリーム ints は、現在の ints に 1 を足し算することで整数を生成しています。fibs は現在のフィボナッチ数列を表していて、tail fibs で次の要素を求め、それらを足し算することで、その次の要素を求めています。この場合、ストリームの初期値として 2 つの要素が必要になることに注意してください。
</p>

<h4>●組 (pair) を生成する遅延ストリーム</h4>
<p> 次は、2 つのストリームからその要素の組み合わせを生成するストリームを作りましょう。要素が n 個のストリームの場合、組み合わせは n * n 個あります。次の図を見てください。
</p>
<pre class="fig">
(a0, b0) (a0, b1) (a0, b2) ... (a0, bn)
(a1, b0) (a1, b1) (a1, b2) ... (a1, bn)
(a2, b0) (a2, b1) (a2, b2) ... (a2, bn)

                           ...

(an, b0) (an, b1) (an, b2) ... (an, bn)

        図 : n * n 個の組
</pre>
<p> これは「直積集合」を求めることと同じです。Haskell の場合、リスト内包表記を使って次のようにプログラムできます。
</p>
<pre class="list">
リスト : 組の生成 (1)

pair_stream :: [a] -&gt; [b] -&gt; [(a, b)]
pair_stream xs ys = [(x, y) | x <- xs, y <- ys]
</pre>
<p> 実行例を示します。
</p>

<pre>
*Main&gt; pair_stream [1..4] [5..8]
[(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,5),(4,6),(4,7),(4,8)]
</pre>
<p> ところが、この方法では無限リストに対応できません。実際、ys に無限リストを渡した場合、xs の最初の要素を a0 とすると (a0, ys の要素) という組しか生成されません。実際に試してみましょう。
</p>
<pre>
*Main&gt; take 10 (pair_stream [1..4] [5..])
[(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(1,14)]
</pre>

<p> そこで、下図に示すように、対角線上に組を生成していくことにします。
</p>
<pre class="fig">
   | a0  a1  a2  a3  a4  a5
---+-----------------------------
b0 | 0   1   3   6   10  15  ...
   |
b1 | 2   4   7   11  16  ...
   |
b2 | 5   8   12  17  ...
   |
b3 | 9   13  18  ...
   |
b4 | 14  19  ...
   |
b5 | 20 ...
   |
   | ...
   |

図 : 無限ストリームによる組の生成
</pre>
<p> 図を見ればおわかりのように、対角線の要素数を n とすると、組は (an-1, b0), (an-2, b1), ..., (a1, bn-2), (a0, bn-1) となっています。これは、xs から n 個の要素を取り出したリストと、ys から n 個の要素を取り出して反転したリストを zip でまとめた形になっています。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組の生成 (2)

pair_stream' :: [a] -&gt; [b] -&gt; [(a, b)]
pair_stream' xs ys = makePair 1 xs ys where
  makePair n xs ys = zip (take n xs) (reverse (take n ys)) ++ makePair (n + 1) xs ys
</pre>
<p> 実際の処理は局所関数 makePair で行っています。引数 n が対角線上の要素数を表します。take で xs と ys から要素を取り出し、ys から取り出したリストを reverse で反転してから zip でタプルに格納します。そして、再帰呼び出しした makePair の返り値にそのリストを連結します。これで無限リストに対応することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; take 50 (pair_stream' [1..] [1..])
[(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,3),
 (4,2),(5,1),(1,6),(2,5),(3,4),(4,3),(5,2),(6,1),(1,7),(2,6),(3,5),(4,4),(5,3),
 (6,2),(7,1),(1,8),(2,7),(3,6),(4,5),(5,4),(6,3),(7,2),(8,1),(1,9),(2,8),(3,7),
 (4,6),(5,5),(6,4),(7,3),(8,2),(9,1),(1,10),(2,9),(3,8),(4,7),(5,6)]

*Main&gt; let s1 = pair_stream' [1..] [1..]
*Main&gt; s1 !! 10
(1,5)
*Main&gt; s1 !! 49
(5,6)
</pre>
<p> 正常に動作していますね。
</p>
<h4>●素数列の生成</h4>
<p> 次は無限の素数列を生成するプログラムを作ってみましょう。整数 n が素数か確かめる簡単な方法は、√n 以下の素数で割り切れるか試してみることです。割り切れる素数があれば、n は素数ではありません。そうでなければ、n は素数であることがわかります。
</p>
<p> これをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 素数列の生成

checkPrime :: Integer -&gt; Bool
checkPrime n =
  all (\x -&gt; mod n x /= 0) (takeWhile (\x -&gt; x * x &lt;= n) primes)

primesFrom :: Integer -&gt; [Integer]
primesFrom n
  | checkPrime n = n : primesFrom (n + 2)
  | otherwise    = primesFrom (n + 2)

primes = 2 : 3 : 5 : primesFrom 7
</pre>
<p> 変数 primes は無限の素数列を表します。実際に素数を生成する処理は関数 primesFrom で行います。primesFrom は簡単で、関数 checkPrime を呼び出して n が素数かチェックします。そうであれば、primsFrom を再帰呼び出しして、その返り値に n を追加します。そうでなければ primesFrom を再帰呼び出しするだけです。偶数は素数ではないので、引数 n には奇数を与えていることに注意してください。
</p>
<p> checkPrime も簡単です。takeWhile で primes から √n 以下の素数列を取り出します。√n 以下の素数は生成済みなので、primes から takeWhile で取り出すことが可能です。ここでは√n のかわりに条件を x * x &lt;= n としています。あとは、関数 all を使って、取り出した素数で n が割り切れないことを確認するだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; take 25 primes
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
*Main&gt; primes !! 99
541
*Main&gt; primes !! 500
3581
</pre>
<p> 100 以下の素数は全部で 25 個あります。また、100 番目の素数は 541 になります。Haskell のリストは 0 から数えるので、primes !! 99 で 100 番目の素数になります。
</p>

<h4>●エラトステネスの篩</h4>
<p> もうひとつ素数列を生成する簡単な方法を紹介しましょう。考え方は簡単です。最初に、2 から始まる整数列を生成するストリームを用意します。2 は素数なので、素数ストリームの要素になります。次に、この整数列から 2 で割り切れる整数を取り除き除きます。これは filter を使うと簡単です。
</p>

<p> 2 で割り切れる整数が取り除かれたので、次の要素は 3 になります。今度は 3 で割り切れる整数を取り除けばいいのです。これも filter を使えば簡単です。このとき、入力用のストリームは 2 で割り切れる整数が取り除かれています。したがって、このストリームに対して 3 で割り切れる整数を取り除くように filter を設定すればいいわけです。
</p>

<p> このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩」といいます。ようするに、2 から始まる整数ストリームに対して、見つけた素数 2, 3, 5, 7, 11, ... を順番に fiter で設定して素数でない整数をふるい落としていくわけです。
</p>

プログラムは次のようになります。
<pre class="list">
リスト : 素数列の生成

primes' = 2 : sieve [3, 5 ..] where
  sieve (x:xs) = x : sieve (filter (\y -&gt; y `mod` x /= 0) xs)
</pre>
<p> primes' は素数列を表します。先頭が 2 で、その後の素数列を局所関数 sieve で生成します。sieve には 3 から始まる奇数列を渡します。2 から始まる整数列を渡すよりも、このほうが効率的です。sieve を再帰呼び出しするとき、filter でリストから先頭要素 x で割り切れる数を filter で取り除きます。最初に奇数列から 3 で割り切れる整数を取り除いたリストが返されます。次の要素 5 を取り出すとき、このリストに対して 5 で割り切れる整数を取り除くことになるので、3 と 5 で割り切れる整数が取り除かれることになります。次の要素は 7 になりますが、そのストリームからさらに 7 で割り切れる整数が filter で取り除かれることになります。
</p>

<p> このように filter を重ねて設定していくことで、素数でない整数をふるい落としていくことができるわけです。それでは実行してみましょう。
</p>
<pre>
*Main&gt; take 25 primes'
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
*Main&gt; primes' !! 99
541
</pre>
<p> 正常に動作していますね。ところで、primes' の実行速度は primes よりもかなり遅いです。primes' よりもっと速いプログラムが <a href="http://www.sampou.org/">WWW.SAMPOU.ORG</a> <a href="http://www.sampou.org/cgi-bin/haskell.cgi">Programming in Haskell</a> <a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming%3a%E7%8E%89%E6%89%8B%E7%AE%B1%3a%E6%95%B4%E6%95%B0%E8%AB%96#H-1fgmzkongd54i">Programming:玉手箱:整数論</a> にあります。興味のある方はいろいろ試してみてください。
</p>
<h4>●参考 URL</h4>
<p> Haskell の Trace については、<a href="http://www.sampou.org/">WWW.SAMPOU.ORG</a> <a href="http://www.sampou.org/cgi-bin/haskell.cgi">Programming in Haskell</a> <a href="http://www.sampou.org/cgi-bin/haskell.cgi?Trace">Trace</a> を参考にさせていただきました。素数列を生成するプログラムは <a href="http://practical-scheme.net/gauche/man/gauche-refj_57.html">Gauche ユーザリファレンス: 6.19 遅延評価</a> を参考にさせていただきました。山下伸夫さんと Shiro Kawai さんに感謝いたします。</DIV>
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell04.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>