<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Erlang Problems</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Erlang Programming</h1>
<h2>Yet Another Erlang Problems</h2>
<div class="small">
[ PrevPage | <a href="erlang.html#yaep">Erlang</a> | <a href="yaep02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">はじめに</h3>
<p> 今回はちょっと便利な関数を問題形式で紹介します。元ネタは <a href="http://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">P-99: Ninety-Nine Prolog Problems</a> です。拙作のページ <a href="../prolog/index.html">Prolog Programming</a> <a href="../prolog/yapp01.html">Yet Another Prolog Problems</a> と同じ問題ですが、あしからずご了承くださいませ。
</p>
<h4 id="p01">●問題１</h4>
<p> リストの要素がただひとつか調べる述語 single(Xs) を定義してください。
</p>
<pre>
&gt; yaep:single([a]).
true
&gt; yaep:single([a, b]).
false
&gt; yaep:single([]).
false
</pre>
<p><a href="yaep01.html#ans01">解答</a>
</p>
<h4 id="p02">●問題２</h4>
<p> リストの要素がひとつ以上あるか調べる述語 pair(Xs) を定義してください。
</p>
<pre>
&gt; yaep:pair([a, b]).
true
&gt; yaep:pair([a]).
true
&gt; yaep:pair([]).
false
</pre>
<p><a href="yaep01.html#ans02">解答</a>
</p>
<h4 id="p03">●問題３</h4>
<p> リスト Xs はリスト Ys よりも長いか調べる述語 longer(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:longer([a, b, c], [d, e]).
true
&gt; yaep:longer([a, b], [d, e]).
false
&gt; yaep:longer([a], [d, e]).
false
</pre>
<p><a href="yaep01.html#ans03">解答</a>
</p>
<h4 id="p04">●問題４</h4>
<p> リストの最後尾の要素を求める関数 last(Xs) と、最後尾の要素を取り除く関数 butlast(Xs) を定義してください。
</p>
<pre>
&gt; yaep:last([a, b, c]).
c
&gt; yaep:last([a]).
a
&gt; yaep:last([]).
** exception error: no function clause matching yaep:last([])
&gt; yaep:butlast([a, b, c]).
[a,b]
&gt; yaep:butlast([a]).
[]
&gt; yaep:butlast([]).
** exception error: no function clause matching yaep:butlast([])
</pre>
<p><a href="yaep01.html#ans04">解答</a>
</p>
<h4 id="p05">●問題５</h4>
<p> リスト Xs の先頭から N 個の要素を取り出す関数 take(N, Xs) を定義してください。
</p>
<pre>
&gt; yaep:take(3, [a, b, c, d, e]).
[a,b,c]
&gt; yaep:take(0, [a, b, c, d, e]).
[]
&gt; yaep:take(5, [a, b, c, d, e]).
[a,b,c,d,e]
&gt; yaep:take(6, [a, b, c, d, e]).
[a,b,c,d,e]
</pre>
<p><a href="yaep01.html#ans05">解答</a>
</p>
<h4 id="p06">●問題６</h4>
<p> リスト Xs の先頭から N 個の要素を取り除く関数 drop(N, Xs) を定義してください。
</p>
<pre>
&gt; yaep:drop(3, [a, b, c, d, e]).
[d,e]
&gt; yaep:drop(0, [a, b, c, d, e]).
[a,b,c,d,e]
&gt; yaep:drop(5, [a, b, c, d, e]).
[]
&gt; yaep:drop(6, [a, b, c, d, e]).
[]
</pre>
<p><a href="yaep01.html#ans06">解答</a>
</p>
<h4 id="p07">●問題７</h4>
<p> リスト Xs の N 番目から M - 1 番目の要素を部分リストとして取り出す関数 subseq(N, M, Xs) を定義してください。なお、リストの要素は 1 から数え始めるものとします。
</p>
<pre>
&gt; yaep:subseq(1, 3, [a, b, c, d, e]).
[a,b]
&gt; yaep:subseq(1, 6, [a, b, c, d, e]).
[a,b,c,d,e]
&gt; yaep:subseq(3, 6, [a, b, c, d, e]).
[c,d,e]
&gt; yaep:subseq(3, 3, [a, b, c, d, e]).
[]
</pre>
<p><a href="yaep01.html#ans07">解答</a>
</p>
<h4 id="p08">●問題８</h4>
<p> リスト Xs の末尾から N 個の要素を取り除く関数 butlastn(N, Xs) を定義してください。
</p>
<pre>
&gt; yaep:butlastn(1, [a, b, c, d, e]).
[a,b,c,d]
&gt; yaep:butlastn(2, [a, b, c, d, e]).
[a,b,c]
&gt; yaep:butlastn(5, [a, b, c, d, e]).
[]
</pre>
<p><a href="yaep01.html#ans08">解答</a>
</p>
<h4 id="p09">●問題９</h4>
<p> リスト Xs を長さ N の部分リストに分割する述語 group(N, Xs) を定義してください。
</p>
<pre>
&gt; yaep:group(3, [1, 2, 3, 4, 5, 6]).
[[1,2,3],[4,5,6]]
&gt; yaep:group(2, [1, 2, 3, 4, 5, 6]).
[[1,2],[3,4],[5,6]]
&gt; yaep:group(1, [1, 2, 3, 4, 5, 6]).
[[1],[2],[3],[4],[5],[6]]
&gt; yaep:group(4, [1, 2, 3, 4, 5, 6]).
[[1,2,3,4],[5,6]]
</pre>
<p><a href="yaep01.html#ans09">解答</a>
</p>
<h4 id="p10">●問題10</h4>
<p> リスト Xs の中から述語 Pred が真を返す最初の要素の位置を求める関数 position_if(Pred, Xs) を定義してください。なお、リストの要素は 1 から数え始めるものとします。
</p>
<pre>
&gt; yaep:position_if(fun(X) -> X =:= 2 end, [6, 5, 4, 3, 2, 1]).
5
&gt; yaep:position_if(fun(X) -> X =:= 6 end, [6, 5, 4, 3, 2, 1]).
1
&gt; yaep:position_if(fun(X) -> X =:= 1 end, [6, 5, 4, 3, 2, 1]).
6
&gt; yaep:position_if(fun(X) -> X =:= 0 end, [6, 5, 4, 3, 2, 1]).
false
</pre>
<p><a href="yaep01.html#ans10">解答</a>
</p>
<h4 id="p11">●問題11</h4>
<p> リスト Xs から述語 Pred が真を返す要素の個数を求める関数 count_if(Pred, Xs) を定義してください。
</p>
<pre>
&gt; yaep:count_if(fun(X) -> X =:= 1 end, [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]).
4
&gt; yaep:count_if(fun(X) -> X =:= 2 end, [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]).
3
&gt; yaep:count_if(fun(X) -> X =:= 3 end, [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]).
2
&gt; yaep:count_if(fun(X) -> X =:= 4 end, [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]).
1
&gt; yaep:count_if(fun(X) -> X =:= 5 end, [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]).
0
</pre>
<p><a href="yaep01.html#ans11">解答</a>
</p>
<h4 id="p12">●問題12</h4>
<p> リスト Xs の要素の合計値を求める述語 sum_list(Xs) を定義してください。
</p>
<pre>
&gt; yaep:sum_list([1, 2, 3, 4, 5, 6, 7, 8]).
36
&gt; yaep:sum_list([1, -2, 3, -4, 5, -6, 7, -8]).
-4
&gt; yaep:sum_list([]).
0
</pre>
<p><a href="yaep01.html#ans12">解答</a>
</p>
<h4 id="p13">●問題13</h4>
<p> リスト Xs の中から最大値を求める関数 max_list(Xs) と最小値を求める関数 min_list(Xs) を定義してください。
</p>
<pre>
&gt; yaep:max_list([5, 6, 4, 7, 3, 8, 2, 9, 1]).
9
&gt; yaep:min_list([5, 6, 4, 7, 3, 8, 2, 9, 1]).
1
</pre>
<p><a href="yaep01.html#ans13">解答</a>
</p>
<h4 id="p14">●問題14</h4>
<p> 要素 X の右隣に要素 Y があるかチェックする関数 adjacent(X, Y, Xs) を定義してください。
</p>
<pre>
&gt; yaep:adjacent(a, b, [a, b, c, d, e]).
true
&gt; yaep:adjacent(d, e, [a, b, c, d, e]).
true
&gt; yaep:adjacent(a, c, [a, b, c, d, e]).
false
&gt; yaep:adjacent(e, d, [a, b, c, d, e]).
false
</pre>
<p><a href="yaep01.html#ans14">解答</a>
</p>
<h4 id="p15">●問題15</h4>
<p> 要素 X が 要素 Y よりも前に出現しているか調べる関数 before(X, Y, Xs) を定義してください。
</p>
<pre>
&gt; yaep:before(a, b, [a, b, c, d, e]).
true
&gt; yaep:before(a, e, [a, b, c, d, e]).
true
&gt; yaep:before(c, b, [a, b, c, d, e]).
false
&gt; yaep:before(e, a, [a, b, c, d, e]).
false
</pre>
<p><a href="yaep01.html#ans15">解答</a>
</p>
<h4 id="p16">●問題16</h4>
<p> 整数 N から M までを格納したリストを作る関数 iota(N, M) を定義してください。
</p>
<pre>
&gt; yaep:iota(1, 8).
[1,2,3,4,5,6,7,8]
&gt; yaep:iota(1, 1).
[1]
&gt; yaep:iota(1, 0).
[]
</pre>
<p><a href="yaep01.html#ans16">解答</a>
</p>
<h4 id="p17">●問題17</h4>
<p> リスト Xs から重複要素を取り除いて集合を生成する関数 set_of_list(Xs) を定義してください。
</p>
<pre>
&gt; yaep:set_of_list([a, b, c, a, d, e, b, f, g]).
[c,a,d,e,b,f,g]
</pre>
<p><a href="yaep01.html#ans17">解答</a>
</p>
<h4 id="p18">●問題18</h4>
<p> 2 つの集合 Xs, Ys の和を求める関数 union(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:union([a, b, c, d], [c, d, e, f]).
[a,b,c,d,e,f]
&gt; yaep:union([a, b, c, d], [e, f, g, h]).
[a,b,c,d,e,f,g,h]
&gt; yaep:union([a, b, c, d], [a, b, c, d]).
[a,b,c,d]
</pre>
<p><a href="yaep01.html#ans18">解答</a>
</p>
<h4 id="p19">●問題19</h4>
<p> 2 つの集合 Xs, Ys の積を求める関数 intersection(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:intersection([a, b, c, d], [c, d, e, f]).
[c,d]
&gt; yaep:intersection([a, b, c, d], [e, f, g, h]).
[]
&gt; yaep:intersection([a, b, c, d], [a, b, c, d]).
[a,b,c,d]
</pre>
<p><a href="yaep01.html#ans19">解答</a>
</p>
<h4 id="p20">●問題20</h4>
<p> 2 つの集合 Xs, Ys の差を求める関数 difference(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:difference([a, b, c, d], [c, d, e, f]).
[a,b]
&gt; yaep:difference([a, b, c, d], [e, f, g, h]).
[a,b,c,d]
&gt; yaep:difference([a, b, c, d], [a, b, c, d]).
[]
</pre>
<p><a href="yaep01.html#ans20">解答</a>
</p>
<h4 id="p21">●問題21</h4>
<p> 2 つのソート済みのリスト Xs, Ys をひとつのソート済みのリストにまとめる関数 merge_list(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:merge_list(fun(X,Y)-> X < Y end, [1, 3, 5, 7], [2, 4, 6, 8]).
[1,2,3,4,5,6,7,8]
&gt; yaep:merge_list(fun(X,Y)-> X < Y end, [1, 3, 5, 7], [1, 3, 5, 7, 9]).
[1,1,3,3,5,5,7,7,9]
&gt; yaep:merge_list(fun(X,Y)-> X < Y end, [2, 4, 6], [2, 4, 6, 8]).
[2,2,4,4,6,6,8]
</pre>
<p><a href="yaep01.html#ans21">解答</a>
</p>
<h4 id="p22">●問題22</h4>
<p> 関数 merge_list を使ってリスト Xs をソートする merge_sort(Pred, N, Xs) を定義してください。引数 N はリストの長さです。
</p>
<pre>
&gt; yaep:merge_sort(fun(X,Y)-> X < Y end, 9, [5, 6, 4, 7, 3, 8, 2, 9, 1]).
[1,2,3,4,5,6,7,8,9]
&gt; yaep:merge_sort(fun(X,Y)-> X < Y end, 9, [9, 8, 7, 6, 5, 4, 3, 2, 1]).
[1,2,3,4,5,6,7,8,9]
&gt; yaep:merge_sort(fun(X,Y)-> X < Y end, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).
[1,2,3,4,5,6,7,8,9,10]
</pre>
<p><a href="yaep01.html#ans22">解答</a>
</p>
<h4 id="p23">●問題23</h4>
<p> リスト Ps がリスト Xs の「接頭辞 (prefix) 」か判定する述語 prefix(Xs, Ps) を定義してください。接頭辞とは、列の先頭からある位置までの部分列のことです。たとえば、リスト [a, b, c, d] の接頭辞は [ ], [a], [a, b], [a, b, c], [a, b, c, d] の 5 つになります。
</p>
<pre>
&gt; yaep:prefix([a, b, c, d, e], [a, b]).
true
&gt; yaep:prefix([a, b, c, d, e], [a, b, c]).
true
&gt; yaep:prefix([a, b, c, d, e], [b, c]).
false
&gt; yaep:prefix([a, b, c, d, e], []).
true
</pre>
<p><a href="yaep01.html#ans23">解答</a>
</p>
<h4 id="p24">●問題24</h4>
<p> リスト Ss がリスト Xs の「接尾辞 (suffix) 」か判定する述語 suffix(Xs, Ss) を定義してください。接尾辞とは、列のある位置から末尾までの部分列のことです。たとえば、リスト [a, b, c, d] の接尾辞は [a, b, c, d], [b, c, d], [c, d], [d], [ ] の 5 つになります。
</p>
<pre>
&gt; yaep:suffix([a, b, c, d, e], []).
true
&gt; yaep:suffix([a, b, c, d, e], [e]).
true
&gt; yaep:suffix([a, b, c, d, e], [d, e]).
true
&gt; yaep:suffix([a, b, c, d, e], [b, d, e]).
false
</pre>
<p><a href="yaep01.html#ans24">解答</a>
</p>
<h4 id="p25">●問題25</h4>
<p> リスト Xs がリスト Ys の部分リストか判定する述語 sublist(Xs, Ys) を定義してください。
</p>
<pre>
&gt; yaep:sublist([b, c, d], [a, b, c, d, e]).
true
&gt; yaep:sublist([c, d], [a ,b, c, d, e]).
true
&gt; yaep:sublist([c], [a, b, c, d, e]).
true
&gt; yaep:sublist([], [a, b, c, d, e]).
true
&gt; yaep:sublist([a, c], [a, b, c, d, e]).
false
</pre>
<p><a href="yaep01.html#ans25">解答</a>
</p>
<hr>
<h4 id="ans01">●解答１</h4>
<pre class="list">
リスト : 要素がただひとつか

single([_]) -&gt; true;
single(_) -&gt; false.
</pre>
<p> Erlang の場合、引数のリストとパターン [ _ ] がマッチングすれば、そのリストの要素は一つしかないことがわかります。length でリストの長さを求める必要はありません。
</p>

<h4 id="ans02">●解答２</h4>
<pre class="list">
リスト : 要素がひとつ以上あるか

pair([_ | _]) -&gt; true;
pair(_) -&gt; false.
</pre>
<p> たとえば、リスト [1] と [X | Xs] を照合すると、X = 1, Xs = [ ] になります。したがって、引数のリストと [_ | _] がマッチングすれば、そのリストの要素は一つ以上あることがわかります。length でリストの長さを求める必要はありません。
</p>
<p> なお、述語 pair の名前は Scheme の関数 pair? から拝借しました。
</p>
<h4 id="ans03">●解答３</h4>
<pre class="list">
リスト : リスト Xs は Ys よりも長いか

longer([], _) -&gt; false;
longer(_, []) -&gt; true;
longer([_ | Xs], [_ | Ys]) -&gt; longer(Xs, Ys).
</pre>
<p> リストの先頭から順番にたどり、途中で Ys が空リストになれば xs の方が長いことがわかります。length でリストの長さを求めて比較するよりも、このプログラムの方が効率的だと思います。
</p>
<h4 id="ans04">●解答４</h4>
<pre class="list">
リスト :  リストの最後尾の要素を求める

last([X]) -&gt; X;
last([_ | Xs]) -&gt; last(Xs).
</pre>
<pre class="list">
リスト : 最後尾の要素を取り除く

butlast([_]) -&gt; [];
butlast([X | Xs]) -&gt; [X | butlast(Xs)].
</pre>
<p> どちらの関数も引数が空リストの場合はエラーになります。last は単純な再帰定義でリストの最後尾を求めています。butlast の 1 番目の節は、要素がひとつしかないリストから最後尾の要素を取り除くと空リストになることを表しています。これが再帰の停止条件になります。あとは次の節で butlast を再帰呼び出しして、Xs から最後尾の要素を取り除いたリストに、引数のリストの先頭要素 X を追加していくだけです。
</p>

<h4 id="ans05">●解答５</h4>
<pre class="list">
リスト : リストの先頭から N 個の要素を取り出す

take(0, _) -&gt; [];
take(_, []) -&gt; [];
take(N, [X | Xs]) when N &gt; 0 -&gt; [X | take(N - 1, Xs)].
</pre>
<p> N が 0 の場合は空リストを返します。途中でリスト Xs が空になった場合も空リストを返します。最後の節で take を再帰呼び出しして、その先頭に要素 X を追加します。
</p>

<h4 id="ans06">●解答６</h4>
<pre class="list">
リスト : リストの先頭から N 個の要素を削除する

drop(0, Xs) -&gt; Xs;
drop(_, []) -&gt; [];
drop(N, [_ | Xs]) when N &gt; 0 -&gt; drop(N - 1, Xs).
</pre>
<p> 最初の節で、削除する要素数が 0 であればリスト Xs をそのまま返します。次の節で、Xs が空リストの場合は空リストを返します。最後の節で drop を再帰呼び出しして、Xs から N - 1 個の要素を取り除いたリストを求めます。
</p>

<h4 id="ans07">●解答７</h4>
<pre class="list">
リスト : 部分リストを取り出す

subseq(N, M, Xs) when N &gt; 0, M &gt;= N -&gt; take(M - N, drop(N - 1, Xs)).
</pre>
<p> subseq は drop と take を使うと簡単です。ガードで N と M の値をチェックします。drop で Xs から N - 1 個の要素を取り除き、そのリストから M - N 個の要素を take で取り出します。
</p>

<h4 id="ans08">●解答８</h4>
<pre class="list">
リスト : リストの末尾から N 個の要素を取り除く

butlastn(N, Xs) -&gt; take(length(Xs) - N, Xs).
</pre>
<p> リスト Xs の長さを M とすると、リストの末尾から N 個の要素を取り除くことは、リストの先頭から M - N 個の要素を取り出すことと同じになります。butlastn は取り出す要素の個数を計算して take で取り出すだけです。
</p>
<h4 id="ans09">●解答９</h4>
<pre class="list">
リスト : リストの分割

group(_, []) -&gt; [];
group(N, Xs) -&gt; [take(N, Xs) | group(N, drop(N, Xs)) ].
</pre>
<p> 関数 group は take と drop を使うと簡単に定義できます。Xs が空リストの場合は分割できないので空リストを返します。これが再帰の停止条件になります。Xs が空リストでない場合、まず take で N 個の要素を格納したリストを求めます。次に、N 個の要素を取り除いたリストを drop で求め、group を再帰呼び出ししてそのリストを分割します。あとはその返り値に take で取り出したリストを追加するだけです。
</p>

<h4 id="ans10">●解答10</h4>
<pre class="list">
リスト : 要素の位置を求める

position_if(_, _, []) -&gt; false;
position_if(P, N, [X | Xs]) -&gt;
  case P(X) of
    true -&gt; N;
    false -&gt; position_if(P, N + 1, Xs)
  end.
position_if(P, Xs) -&gt; position_if(P, 1, Xs).
</pre>
<p> positon_if/3 で要素の位置 N を求めます。リストの先頭から順番に調べていき、Pred の返り値が真であれば N を返します。Pred が真となる要素が見つからない場合は false を返します。
</p>

<h4 id="ans11">●解答11</h4>
<pre class="list">
リスト : 要素の個数を求める

count_if(_, C, []) -&gt; C;
count_if(P, C, [X | Xs]) -&gt;
  case P(X) of
    true -&gt; count_if(P, C + 1, Xs);
    false -&gt; count_if(P, C, Xs)
  end.
count_if(P, Xs) -&gt; count_if(P, 0, Xs).
</pre>
<p> count_if/3 で要素の個数をカウントします。引数 C を累積変数として使います。Pred(X) が真の場合、C を +1 して count_if/3 を再帰呼び出しします。そうでなければ C の値をそのままにして count_if/3 を再帰呼び出しします。リストが空リストの場合は C を返します。
</p>

<h4 id="ans12">●解答12</h4>
<pre class="list">
リスト : 要素の合計値を求める

sum_list([], A) -&gt; A;
sum_list([X | Xs], A) -&gt; sum_list(Xs, A + X).
sum_list(Xs) -&gt; sum_list(Xs, 0).
</pre>
<p> sum_list/2 で要素の合計値を求めます。引数 A を累積変数として使っていて、sum_list/2 を再帰呼び出しするとき、A に X を加算します。リストが空リストの場合は A を返します。
</p>

<h4 id="ans13">●解答13</h4>
<pre class="list">
リスト : リストから最大値と最小値を求める

max_list([], Max) -&gt; Max;
max_list([X | Xs], Max) when X &gt; Max -&gt; max_list(Xs, X);
max_list([_ | Xs], Max) -&gt; max_list(Xs, Max).
max_list([X | Xs]) -&gt; max_list(Xs, X).

min_list([], Min) -&gt; Min;
min_list([X | Xs], Min) when X &lt; Min -&gt; min_list(Xs, X);
min_list([_ | Xs], Min) -&gt; min_list(Xs, Min).
min_list([X | Xs]) -&gt; min_list(Xs, X).
</pre>
<p> max_list/2 (min_list/2) で最大値 (最小値) を求めます。引数 Max (Min) を累積変数として使っていて、そこに最大値 (または最小値) を保持します。最初に呼び出すとき、リストの先頭要素をセットします。あとは残りの要素を順番に調べていき、リストの先頭要素 X が Max (Min) よりも大きい (または小さい) 場合は、それを Max (Min) に置き換えるだけです。
</p>

<h4 id="ans14">●解答14</h4>
<pre class="list">
リスト : X と Y は隣り合っているか

adjacent(_, _, [_]) -&gt; false;
adjacent(X, Y, [X, Y | _]) -&gt; true;
adjacent(X, Y, [_ | Xs]) -&gt; adjacent(X, Y, Xs).
</pre>
<p> 関数 adjacent の定義は簡単です。リスト Xs が [X, Y | _] とマッチングすれば、X と Y は隣り合っていることがわかります。そうでなければ、adjacent を再帰呼び出しして先頭要素を取り除いたリストから探します。
</p>

<h4 id="ans15">●解答15</h4>
<pre class="list">
リスト : X は Y よりも前に出現しているか

before(_, _, []) -&gt; false;
before(X, Y, [X | Xs]) -&gt; lists:member(Y, Xs);
before(X, Y, [_ | Xs]) -&gt; before(X, Y, Xs).
</pre>
<p> 関数 before は関数 lists:member を使うと簡単にプログラムすることができます。最初の節と最後の節で、Xs の中から X を探しています。見つからない場合は、最初の節で false を返します。2 番目の節で X を見つけたら、残りのリスト Xs の中から Y を lists:member で探します。
</p>

<h4 id="ans16">●解答16</h4>
<pre class="list">
リスト : 数列の生成

iota(N, M) when N &gt; M -&gt; [];
iota(N, M) -&gt; [N | iota(N + 1, M)].

% 別解
iota(N, N, A) -&gt; [N | A];
iota(N, M, A) -&gt; iota(N, M - 1, [M | A]).
iota(N, M) -&gt; iota(N, M, []).
</pre>
<p> 最初の節で N > M になったら空リストを返します。次の節で、iota(N + 1, M) を再帰呼び出しして N + 1 から M までのリストを生成し、その先頭に N を追加します。別解は末尾再帰でプログラムしたものです。M を -1 していくところに注意してください。
</p>

<h4 id="ans17">●解答17</h4>
<pre class="list">
リスト : 集合の生成

set_of_list([]) -&gt; [];
set_of_list([X | Xs]) -&gt;
  case lists:member(X, Xs) of
    true -&gt; set_of_list(Xs);
    false -&gt; [X | set_of_list(Xs)]
  end.
</pre>
<p> 関数 set_of_list はリストから重複要素を取り除きます。先頭要素 X が残りのリスト Xs に含まれているか lists:member でチェックします。そうであれば、set_of_list を再帰呼び出しするだけです。含まれていなければ、set_of_list を再帰呼び出しして、その返り値の先頭に X を追加します。
</p>

<h4 id="ans18">●解答18</h4>
<pre class="list">
リスト : 集合の和

union([], Ys) -&gt; Ys;
union([X | Xs], Ys) -&gt;
  case lists:member(X, Ys) of
    true -&gt; union(Xs, Ys);
    false -&gt; [X | union(Xs, Ys)]
  end.
</pre>
<p> Xs が空リストの場合は Ys を返します。これは空集合 (空リスト) と集合 Ys の和は Ys であることを表しています。次の節でリストを [X | Xs] に分解して、X が Ys に含まれていなければ、X を集合に追加します。含まれている場合は集合に追加しません。
</p>

<h4 id="ans19">●解答19</h4>
<pre class="list">
リスト : 集合の積

intersection([], _) -&gt; [];
intersection([X | Xs], Ys) -&gt;
  case lists:member(X, Ys) of
    true -&gt; [X | intersection(Xs, Ys)];
    false -&gt; intersection(Xs, Ys)
  end.
</pre>
<p> Xs が空リストの場合は空リストを返します。これは空集合 (空リスト) と集合 Xs の積は空リストであることを表しています。次の節でリストを [X | Xs]  に分解して、X が Ys に含まれていれば X を集合に追加します。含まれていない場合は集合に追加しません。
</p>

<h4 id="ans20">●解答20</h4>
<pre class="list">
リスト : 集合の差

difference([], _) -&gt; [];
difference([X | Xs], Ys) -&gt;
  case lists:member(X, Ys) of
    true -&gt; difference(Xs, Ys);
    false -&gt; [X | difference(Xs, Ys)]
  end.
</pre>
<p> Xs が空リストの場合は空リストを返します。これは空集合 (空リスト) と集合 Ys の差は空リストであることを表しています。次の節でリストを [X | Xs] に分解して、X が Ys に含まれていなければ X を集合に追加します。含まれている場合は集合に追加しません。
</p>

<h4 id="ans21">●解答21</h4>
<pre class="list">
リスト : リストのマージ

merge_list(_, [], Ys) -&gt; Ys;
merge_list(_, Xs, []) -&gt; Xs;
merge_list(P, [X | Xs], [Y | Ys]) -&gt;
  case P(X, Y) of
    true -&gt; [X | merge_list(P, Xs, [Y | Ys])];
    false -&gt; [Y | merge_list(P, [X | Xs], Ys)]
  end.
</pre>
<p> 要素の比較は述語 Pred で行います。Xs が空リストの場合は Ys を返し、Ys が空リストの場合は Xs を返します。次に、リストの先頭要素 X と Y を Pred で比較します。Pred(X, Y) が真の場合は X をリストに追加します。そうでなければ Y をリストに追加します。
</p>

<h4 id="ans22">●解答22</h4>
<pre class="list">
リスト : マージソート

merge_sort(_, 0, _) -&gt; [];
merge_sort(_, 1, [X | _]) -&gt; [X];
merge_sort(P, 2, [X, Y | _]) -&gt;
  case P(X, Y) of
    true -&gt; [X, Y];
    false -&gt; [Y, X]
  end;
merge_sort(P, N, Xs) -&gt;
  M = N div 2,
  merge_list(P, merge_sort(P, M, Xs), merge_sort(P, N - M, drop(M, Xs))).
</pre>

<p> 要素の比較は述語 Pred で行います。引数 N はリスト Xs の長さを表します。要素が一つしかない場合は [X] を返します。2 つある場合は要素 X と Y を Pred で比較し、Pred(X, Y) が真であれば [X, Y] を、そうでなければ [Y, X] を返します。それ以外の場合は、リスト Xs を二分割して merge_sort を再帰呼び出しし、その結果を merge_list でマージします。
</p>

<h4 id="ans23">●解答23</h4>
<pre class="list">
リスト : 接頭辞の判定

prefix(_, []) -&gt; true;
prefix([], _) -&gt; false;
prefix([X | Xs], [X | Ys]) -&gt; prefix(Xs, Ys);
prefix(_, _) -&gt; false.
</pre>
<p> 接頭辞の判定は簡単です。最初の節は、空リストは接頭辞であることを表しています。次の節で Xs が空リストの場合、Ys は接頭辞ではないので false を返します。それ以外の場合は、Xs と Ys の先頭要素を比較して、等しい場合は prefix を再帰呼び出しして次の要素を比較します。等しくない場合は接頭辞ではないので false を返します。
</p>

<h4 id="ans24">●解答24</h4>
<pre class="list">
リスト : 接尾辞の判定

suffix(Xs, Ys) -&gt; drop(length(Xs) - length(Ys), Xs) =:= Ys.
</pre>
<p> 接尾辞の判定も簡単です。リスト Xs と Ys の長さ (n1, n2) を求め、Xs の先頭から (n1 - n2) 個の要素を取り除きます。これで Xs と Ys の長さが等しくなるので、あとは単純に演算子 =:= で比較するだけです。
</p>

<h4 id="ans25">●解答25</h4>
<pre class="list">
リスト : 部分リストの判定

sublist(Xs, Ys) -&gt;
  case prefix(Ys, Xs) of
    true -&gt; true;
    false -&gt; case Ys of
               [] -&gt; false;
               [_ | Ys1] -&gt; sublist(Xs, Ys1)
             end
  end.
</pre>
<p> sublist は prefix を使うと簡単です。最初の case で Xs が Ys の接頭辞であれば部分リストなので true を返します。false の場合は Ys をチェックします。Ys が空リストの場合、Xs は部分リストではないので false を返します。それ以外の場合は Ys の先頭要素を取り除いて、sublist を再帰呼び出しするだけです。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="erlang.html#yaep">Erlang</a> | <a href="yaep02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>