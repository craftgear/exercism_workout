<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881785</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm12.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm19.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>パズルの解法 [2]</h3>
<p> 前回は基本的な探索手法として、深さ優先探索、幅優先探索、反復深化を説明しました。今回は幅優先探索の例題として 15 パズルで有名なスライドパズルを解いてみましょう。なお、本稿は拙作のページ <a href="http://www.geocities.jp/m_hiroi/light/scheme.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo27.html">幅優先探索と反復深化</a> を Scheme で書き直したものです。内容は重複しますが、あしからずご了承くださいませ。
</p>

<h4>●８パズルの説明</h4>
<p> <a href="abcscm18.html#cite">参考文献 1</a> によると、15 パズルはアメリカのサム・ロイドが 1870 年代に考案したパズルで、彼はパズルの神様と呼ばれるほど有名なパズル作家だそうです。
</p>
<pre class="fig">
┌─┬─┬─┬─┐  
│１│２│３│４│
├─┼─┼─┼─┤
│５│６│７│８│
├─┼─┼─┼─┤
│９│10│11│12│
├─┼─┼─┼─┤
│13│14│15│  │
└─┴─┴─┴─┘

  図 : 15 パズル
</pre>
<p> 15 パズルは上図に示すように、1 から 15 までの駒を並べるパズルです。駒の動かし方は、1 回に 1 個の駒を空いている隣の場所に滑らせる、というものです。駒を跳び越したり持ち上げたりすることはできません。
</p>

<p> 15 パズルの場合、駒の配置は空き場所がどこでもいいことにすると、16! (約 2e13) 通りもあります。実際には、15 パズルの性質からその半分になるのですが、それでもパソコンで扱うにはあまりにも大きすぎる数です。そこで、盤面を一回り小さくした、1 から 8 までの数字を並べる「8 パズル」を考えることにします。
</p>
<pre class="fig">
  ┌─┬─┬─┐      ┌─┬─┬─┐
  │１│２│３│      │１│２│３│
  ├─┼─┼─┤      ├─┼─┼─┤
  │４│５│６│      │４│５│６│
  ├─┼─┼─┤      ├─┼─┼─┤
  │７│８│  │      │８│７│  │
  └─┴─┴─┘      └─┴─┴─┘
  （１）完成形      （２）不可能な局面  

            図 : 8 パズル
</pre>
<p> 15 パズルは 4 行 4 列の盤ですが、8 パズルは 3 行 3 列の盤になります。8 パズルの場合、駒の配置は空き場所がどこでもいいことにすると、9! =  362880 通りあります。15 パズルや 8 パズルの場合、<a href="abcscm18.html#cite">参考文献 2</a> によると <cite>『適当な 2 つの駒をつまみ上げて交換する動作を偶数回行った局面にしか移行できない』</cite> とのことです。
</p>
<p> 上図 (2) は 7 と 8 を入れ替えただけの配置です。この場合、交換の回数が奇数回のため完成形に到達することができない、つまり解くことができないのです。このような性質を「偶奇性（パリティ）」といいます。詳しい説明は拙作のページ <a href="http://www.geocities.jp/m_hiroi/puzzle/scheme.html">Puzzle DE Programming</a> <a href="../puzzle/parity.html">偶奇性（パリティ）のお話</a> をお読みください。8 パズルの場合、完成形に到達する局面の総数は 9! / 2 = 181440 個となります。
</p>

<h4>●幅優先探索による解法</h4>
<p> それでは、プログラムを作りましょう。下図に示すスタートから完成形 (ゴール) に到達するまでの最短手数を幅優先探索で求めます。
</p>
<pre class="fig">
  ┌─┬─┬─┐    ┌─┬─┬─┐
  │８│６│７│    │１│２│３│
  ├─┼─┼─┤    ├─┼─┼─┤
  │２│５│４│    │４│５│６│
  ├─┼─┼─┤    ├─┼─┼─┤
  │３│  │１│    │７│８│  │
  └─┴─┴─┘    └─┴─┴─┘
     スタート           ゴール

          図 : 8 パズル
</pre>
<p> 8 パズルの盤面はベクタを使って表します。盤面の位置とベクタの添字の対応は下図を見てください。
</p>
<pre class="fig">
  ┌─┬─┬─┐      ┌─┬─┬─┐
  │１│２│３│      │０│１│２│
  ├─┼─┼─┤      ├─┼─┼─┤
  │４│５│６│      │３│４│５│
  ├─┼─┼─┤      ├─┼─┼─┤
  │７│８│  │      │６│７│８│
  └─┴─┴─┘      └─┴─┴─┘

 盤面: #(1 2 3       盤面と配列の対応
         4 5 6
         7 8 0)

         図 : 8 パズルの盤面
</pre>

<p> 隣接リストの定義は次のようになります。
</p>

<pre class="list">
リスト : 隣接リスト

(define *adjacent*
    #((1 3)     ; 0
      (0 2 4)   ; 1
      (1 5)     ; 2
      (0 4 6)   ; 3
      (1 3 5 7) ; 4
      (2 4 8)   ; 5
      (3 7)     ; 6
      (4 6 8)   ; 7
      (5 7)))   ; 8
</pre>

<p> 次は局面を表すリストを定義します。
</p>
<pre class="list">
リスト : 局面の定義

; 局面を表すリスト
; (board  : 盤面 (ベクタ)
;  space  : 空き場所の位置
;  prev)  : 1 手前の局面

; アクセス関数
(define (get-board state) (car state))
(define (get-space state) (cadr state))
(define (get-prev state) (caddr state))
</pre>
<p> リストの第 1 要素 board は盤面を表すベクタ、第 2 要素 space は空き場所の位置、第 3 要素 prev は 1 手前の局面 (リスト) を格納します。ゴールに到達したら、prev をたどって手順を表示します。そして、各々の要素に対応するアクセス関数を用意します。
</p>

<p> それでは幅優先探索のプログラムを作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 幅優先探索

(define (solve1 start goal)
  ; 初期化
  (define q (make-queue))
  (define ht (make-hash 99991 hash-func equal?))
  (q 'enqueue! (list start (vector-position zero? start) '()))
  (ht 'insert! start #t)
  ;
  (while (not (q 'empty?))
    (let ((state (q 'dequeue!)))
      (let loop ((ls (vector-ref *adjacent* (get-space state))))
        (if (pair? ls)
          (let ((new-board (move-piece (get-board state)
                                       (get-space state)
                                       (car ls))))
            (cond ((equal? goal new-board)
                   (print-answer state)
                   (print-board goal)
                   (q 'clear!))
                  ((not (ht 'search new-board))
                   (q 'enqueue! (list new-board (car ls) state))
                   (ht 'insert! new-board #t)
                   (loop (cdr ls)))
                  (else (loop (cdr ls))))))))))
</pre>

<p> プログラムの骨格は <a href="abcscm17.html">経路の探索</a> で説明した幅優先探索と同じです。関数 solve1 の引数 start がスタートの盤面で、goal がゴールの盤面です。幅優先探索はキューを使うと簡単にプログラムできます。今回は <a href="abcscm14.html">Scheme プログラミング中級編 [4]</a> で作成したプログラムを使うことにします。
</p>
<p> 最初に、関数 make-queue でキューを生成して変数 q にセットします。それから、start の局面を list で生成してキューに登録します。関数 vector-position は拙作のページ <a href="abcscm13.html">Scheme プログラミング中級編 [3]</a> で作成したもので、ベクタから条件を満たす要素を探してその位置を返します。
</p>

<p> 変数 ht は同一局面をチェックするためのハッシュ表を格納します。ハッシュ表は <a href="abcscm16.html">ヒープとハッシュ法</a> で作成したプログラムを使います。hash-func は盤面を整数値に変換するハッシュ関数で、ハッシュ表の大きさは 99991 (素数) としました。盤面はベクタで表しているので、等値関係の述語には equal? を指定します。
</p>

<p> 幅優先探索の場合、手数 を 1 つずつ増やしながら探索を行います。このため、n 手目の移動で作られた局面が n 手以前の局面で出現している場合、n 手より短い手数で到達する移動手順が必ず存在します。最短手順を求めるのであれば、この n 手の手順を探索する必要はありません。ハッシュ表 ht をチェックして新しい局面だけキューに登録します。
</p>

<p> 次の while ループで、ゴール (goal) に到達するまで探索を繰り返します。キューが空になり while ループが終了する場合、start は goal に到達できない、つまり解くことができなかったことになります。キューから局面を取り出して変数 state にセットします。そして、駒を動かして新しい局面を生成します。
</p>
<p> 駒の移動は関数 move-piece で行います。動かせる駒の位置は空き場所の隣なので、隣接リストから求めることができます。隣接リストは変数 ls にセットします。あとは、move-piece に空き場所の位置 (get-space state) と移動する駒の位置 (car ls) を渡して、新しい盤面を作成します。
</p>

<p> 新しい盤面 new-board を作ったら、goal に到達したか述語 equal? でチェックします。goal と等しい場合は、関数 print-answer と関数 print-board で手順を表示します。そして、while ループを終了するため、clear! でキューを空にします。
</p>
<p> なお、<a href="abcscm14.html">Scheme プログラミング中級編 [4]</a> で作成したキューにはキューを空にする操作 clear! がありません。clear! の処理を追加する必要があります。これは簡単な処理なので、詳細は <a href="abcscm18.html#list2">プログラムリスト２</a> をお読みください。
</p>

<p> 同一局面がない場合は、list で新しい局面を生成してキューに追加します。このとき、空き場所の位置は (car ls) で、1 手前の局面は state になります。そして、ハッシュ表に new-board を登録します。
</p>

<p> あとのプログラムは簡単なので、説明は省略いたします。詳細は <a href="abcscm18.html#list">プログラムリスト</a> をお読みください。
</p>

<h4>●実行結果</h4>
<p> これでプログラムは完成です。それでは実行してみましょう。
</p>
<pre>
gosh&gt; (solve1 #(8 6 7 2 5 4 3 0 1) #(1 2 3 4 5 6 7 8 0))

8 6 7 
2 5 4 
3 0 1 

8 6 7 
2 0 4 
3 5 1 

-省略-

1 2 3 
4 5 6 
7 0 8 

1 2 3 
4 5 6 
7 8 0 
</pre>
<p> 31 手で解くことができました。生成した局面は全部で 181440 通りで、実行時間は 4.9 秒 (Windows XP, celeron 1.40 GHz, Gauche 0.8.12) かかりました。8 パズルの場合、最長手数は 31 手で、下図に示す 2 通りの局面があります。スタートの局面はその一つです。
</p>
<pre class="fig">
┌─┬─┬─┐    ┌─┬─┬─┐
│８│６│７│    │６│４│７│
├─┼─┼─┤    ├─┼─┼─┤
│２│５│４│    │８│５│  │
├─┼─┼─┤    ├─┼─┼─┤
│３│  │１│    │３│２│１│
└─┴─┴─┘    └─┴─┴─┘

    図 : 31 手で解ける局面
</pre>
<p> 最長手数の局面は、幅優先探索を使って求めることができます。これはあとで試してみましょう。
</p>

<h4>●双方向探索</h4>
<p> ところで、今回の 8 パズルのようにゴールの状態が明確な場合、スタートから探索するだけではなくゴールからも探索を行うことで、幅優先探索を高速化することができます。これを「双方向探索 (bi-directional search) 」といいます。
</p>
<p> その理由を説明するために、簡単なシミュレーションをしてみましょう。たとえば、1 手進むたびに 3 つの局面が生成され、5 手で解けると仮定します。すると、n 手目で生成される局面は 3 の n 乗個になるので、初期状態から単純に探索すると、生成される局面の総数は、3 + 9 + 27 + 81 + 243 = 363 個となります。
</p>
<p> これに対し、初期状態と終了状態から同時に探索を始めた場合、お互い 3 手まで探索した時点で同じ局面に到達する、つまり、解を見つけることができます。この場合、生成される局面の総数は 3 手目までの局面数を 2 倍した 78 個となります。
</p>
<p> 生成される局面数はぐっと少なくなりますね。局面数が減少すると同一局面の探索処理に有利なだけではなく、「キューからデータを取り出して新しい局面を作る」という根本的な処理のループ回数を減らすことになるので、処理速度は大幅に向上するのです。
</p>

<p> それではプログラムを作りましょう。単純に考えると、2 つの探索処理を交互に行うことになりますが、そうするとプログラムの大幅な修正が必要になります。ここは、探索方向を示すフラグを用意することで、一つのキューだけで処理することにしましょう。局面を表すリストに方向を示す要素を追加します。
</p>

<pre class="list">
リスト : 局面の定義 (双方向からの探索)

; 局面を表すリスト
; (board  : 盤面 (ベクタ)
;  space  : 空き場所の位置
;  prev   : 1 手前の局面
;  dir)   : 方向 (F or B)

; アクセス関数
(define (get-board state) (car state))
(define (get-space state) (cadr state))
(define (get-prev state) (caddr state))
(define (get-dir state) (cadddr state))
</pre>

<p> スタートからの探索をシンボル F で、ゴールからの探索をシンボル B で表ます。双方向探索のプログラムは次のようになります。
</p>

<pre class="list">
リスト : 双方向探索

; 新しい局面をキューとハッシュ表に挿入する
(define (insert-new-state q ht . state)
    (q 'enqueue! state)
    (ht 'insert! (get-board state) state))

; 幅優先探索
(define (solve2 start goal)
  ; 初期化
  (define q (make-queue))
  (define ht (make-hash 99991 hash-func equal?))
  (insert-new-state q ht start (vector-position zero? start) '() 'F)
  (insert-new-state q ht goal (vector-position zero? goal) '() 'B)
  ;
  (while (not (q 'empty?))
    (let ((state (q 'dequeue!)))
      (let loop ((ls (vector-ref *adjacent* (get-space state))))
        (if (pair? ls)
          (let* ((new-board (move-piece (get-board state)
                                        (get-space state)
                                        (car ls)))
                 (same-state (ht 'search new-board)))
            (cond (same-state
                   (cond ((not (eq? (get-dir state) (get-dir same-state)))
                          (print-answer2 state same-state)
                          (q 'clear!))
                         (else (loop (cdr ls)))))
                  (else
                   (insert-new-state q ht new-board (car ls) state (get-dir state))
                   (loop (cdr ls))))))))))
</pre>

<p> スタートとゴールの局面を生成してキューとハッシュ表に登録します。最初に、スタートの状態から 1 手目の局面が生成され、次にゴールの状態から 1 手目の局面が生成されます。あとは、交互に探索が行われます。それから、同一局面を見つけたとき、その局面の方向 dir を比較する必要があるので、ハッシュ表には局面を表すリストをセットします。
</p>
<p> 駒の移動と局面の生成処理は幅優先探索と同じです。新しい局面 new-board を生成して、同じ局面がないかハッシュ表を探索して結果を変数 same-state にセットします。同じ局面を見つけたとき、state と same-state の探索方向が異なっていれば、双方向からの探索で同一局面に到達したことがわかります。見つけた最短手順を関数 print_answer2 で出力します。同じ探索方向であれば、キューへの追加は行いません。
</p>

<p> あとのプログラムは簡単なので、説明は省略いたします。詳細は <a href="abcscm18.html#list">プログラムリスト</a> をお読みください。
</p>

<p> さっそく実行してみると、生成された局面数は 16088 個で、実行時間は 0.27 秒 (Windows XP, celeron 1.40 GHz, Gauche 0.8.12) でした。局面数は約 1 / 11 になり、実行時間も約 18 倍と高速になりました。
</p>

<h4>●最長手数の求め方</h4>
<p> 今度は最長手数の局面を求めてみましょう。最長手数の求め方ですが、181440 通りの配置の最短手数がすべてわかれば、最長の手数となる配置を求めることができます。しかし、この方法では時間がとてもかかりそうです。そこで、完成形から始めていちばん長い手数の局面を生成することにします。
</p>
<p> まず、完成形から駒を動かして 1 手で到達する局面をすべて作ります。次に、これらの局面から駒を動かして新しい局面を作れば、完成形から 2 手で到達する局面となります。このように、手数を 1 手ずつ伸ばしていき、新しい局面が生成できなくなった時点での手数が求める最長手数となります。この処理は幅優先探索を使えばぴったりです。
</p>
<p> このプログラムの目的は、いちばん長い手数となる配置を求めることなので、その手順を表示することは行いません。このため、1 手前の局面を格納する第 3 要素 prev は不要になります。そのかわり、その局面までの手数を表す move を用意します。1 手前の局面の手数を move から求め、それに 1 を足せば現在の局面の手数となります。
</p>

<h4>●プログラムの作成</h4>
<p> それではプログラムを作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 8 パズルの最長手数を求める

; アクセス関数
(define (get-move state) (caddr state))

; 最長手数の探索
(define (solve-max start)
  : 初期化
  (define ht (make-hash 99991 hash-func equal?))
  (define old-state '())
  (define new-state (list (list start (vector-position zero? start) 0)))
  (ht 'insert! start #t)
  ;
  (while (pair? new-state)
    (set! old-state new-state)
    (set! new-state '())
    (dolist (state old-state)
      (dolist (x (vector-ref *adjacent* (get-space state)))
        (let ((new-board (move-piece (get-board state)
                                     (get-space state)
                                     x)))
          (unless (ht 'search new-board)
            (set! new-state
                  (cons (list new-board x (+ (get-move state) 1)) new-state))
            (ht 'insert! new-board #t))))))
  ; 最長手数の局面を表示
  (dolist (state old-state)
      (format #t "~%~D" (get-move state))
      (print-board (get-board state))))
</pre>

<p> 関数 solve-max には goal をチェックする処理がないことに注意してください。生成できる局面がなくなるまで処理を繰り返します。このプログラムではキューを使わないで、old-state と new-state という 2 つのリストに局面を格納することにします。old-state にある局面から新しい局面を生成して、それを new-state にセットします。new-state にデータがない場合、新しい局面は生成されなかったので繰り返しを終了します。このとき、old-state に格納されている局面が最長手数となります。
</p>

<p> solve-max では dolist と unless という関数 (マクロ) を使っています。マクロは次回以降で詳しく説明する予定ですが、ここではユーザーがシンタックス形式の関数を定義するときにマクロを使うと考えてください。ここで、dolist と when, unless について簡単に説明しましょう。
</p>

<h4>●dolist</h4>
<p> dolist はもともと Common Lisp の関数 (マクロ) で、for-each と同じようにリストの要素を順番に取り出して処理を行いますが、for-each とは違って高階関数ではありません。単純な繰り返しを行うときに便利な関数で、Gauche にも用意されています。dolist の構文を示します。
</p>

<pre class="item">
(dolist (変数 初期値 結果) Ｓ式 ... )
</pre>

<p> 最初に初期値を評価します。このとき、評価結果がリストでなければいけません。リスト以外の場合はエラーになります。このリストの要素を順番に変数に代入して、S 式を評価します。リストの要素がなくなったら結果を評価して、その値が dolist の結果になります。次の例を見てください。
</p>

<pre>
gosh&gt; (dolist (x '(0 1 2 3 4)) (display x))
01234()
</pre>

<p> この処理は、局所変数 x の値を display で表示するだけですが、繰り返しのたびに、変数 x にリストの要素が順番に代入されていく様子がよくわかると思います。最後の () は dolist の返り値です。結果が省略された場合、dolist は空リストを返します。これを図に表すと、次のようになります。
</p>
<pre class="fig">
              ↓
              ├←────┐
     No ┌─────┐    │
┌───│要素がある│    │
│      └─────┘    │
│            ↓Yes       │
│    ┌───────┐  │
│    │ x ← 次の要素│  │
│    └───────┘  │
│            ↓          │
│     ┌──────┐   │
│     │(display x) │   │
│     └──────┘   │
│            └─────┘
└──────┐
              ↓

    図 : dolist の処理
</pre>
<p> dolist の簡単な例題として、リストの要素を数えるプログラムを作ってみましょう。
</p>
<pre class="list">
リスト : 要素の個数を求める

(define (my-length ls)
    (let ((count 0))
        (dolist (x ls count)
            (set! count (+ count 1)))))
</pre>
<p> 最初に count を 0 で初期化しておき、要素がある間 count に 1 を足していきます。この場合、count の値を書き換えていくことで、要素の個数をカウントするわけです。
</p>
<p> なお、Gauche には dotimes という繰り返しに便利な関数 (マクロ) も用意されています。興味のある方は Gauche のマニュアルをお読みください。また、拙作のページ <a href="../xyzzy_lisp.html#abclisp">Common Lisp 入門</a> <a href="../xyzzy_lisp/abclisp04.html">繰り返し</a> でも詳しく説明しています。
</p>
<h4>●when と unless</h4>
<p> when と unless は条件分岐を行う関数 (マクロ) です。これらの関数は R5RS に定義されていませんが、Gauche では使うことができます。when の構文を示します。
</p>
<pre class="item">
(when test Ｓ式１ Ｓ式２ Ｓ式３ ..... )
</pre>
<p> when は最初に test を評価し、その結果が #f であれば、その後ろの S 式を評価せずに #f を返します。そうでなければ、S 式を順番に評価し、最後の S 式の評価結果を返します。つまり、when は if の else 節がない場合と同様な働きをするわけです。ただし、if では then 節と else 節ともにひとつの S 式しか受け付けませんが、when は複数の S 式を引数として受け取ることができます。
</p>

<p> unless は when とは逆の働きをする関数で、述語が偽 (#f) に評価されたときに、引数の S 式を順番に評価します。unless は述語 not を使うと、次のように when を使って表すことができます。
</p>
<pre class="item">
(unless test Ｓ式１ ...) ≡ (when (not test) Ｓ式１ ...)
</pre>
<h4>●実行結果</h4>
<p>これでプログラムは完成です。さっそく実行してみましょう。
</p>
<pre>
gosh&gt; (solve-max #(1 2 3 4 5 6 7 8 0))

31
8 6 7 
2 5 4 
3 0 1 

31
6 4 7 
8 5 0 
3 2 1 
</pre>

<p> 最長手数は 31 手で、その配置は全部で 2 通りになります。実行時間は 4.7 秒 (Windows XP, celeron 1.40 GHz, Gauche 0.8.12) でした。
</p>
<h4 id="cite">●参考文献</h4>
<ol>
  <li>井上うさぎ, 『世界のパズル百科イラストパズルワンダーランド』, 東京堂出版, 1997
  <li>三木太郎, 『特集コンピュータパズルへの招待 スライディングブロック編』, C MAGAZINE 1996 年 2 月号, ソフトバンク
</ol>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
;
; eight.scm : 8 Puzzle
;
;             Copyright (C) 2008 Makoto Hiroi
;
(load "./hash.scm")
(load "./queue.scm")

; 盤面の大きさ
(define *size* 9)

; 隣接リスト
(define *adjacent*
    #((1 3)     ; 0
      (0 2 4)   ; 1
      (1 5)     ; 2
      (0 4 6)   ; 3
      (1 3 5 7) ; 4
      (2 4 8)   ; 5
      (3 7)     ; 6
      (4 6 8)   ; 7
      (5 7)))   ; 8

; 局面を表すリスト
; (board  : 盤面 (ベクタ)
;  space  : 空き場所の位置
;  prev)  : 1 手前の局面

; アクセス関数
(define (get-board state) (car state))
(define (get-space state) (cadr state))
(define (get-prev state) (caddr state))

; 盤面の表示
(define (print-board board)
    (newline)
    (let loop ((i 0))
        (cond ((&lt; i *size*)
               (format #t "~D " (vector-ref board i))
               (if (or (= i 2) (= i 5) (= i 8)) (newline))
               (loop (+ i 1))))))

; 解の表示
(define (print-answer state)
    (cond ((pair? state)
           (print-answer (get-prev state))
           (print-board (get-board state)))))

; 駒の移動
(define (move-piece board space pos)
    (let ((new-board (vector-copy board)))
        (vector-set! new-board space (vector-ref new-board pos))
        (vector-set! new-board pos 0)
        new-board))

; 見つけたデータの位置を返す
(define (vector-position p v)
    (let loop ((n 0))
        (cond ((= (vector-length v) n) #f)
              ((p (vector-ref v n)) n)
              (else
               (loop (+ n 1))))))

; ハッシュ関数
(define (hash-func board)
    (let loop ((i 0) (a 0))
        (if (&lt;= *size* i)
            a
            (loop (+ i 1) (+ (* a *size*) (vector-ref board i))))))

; 幅優先探索 (ハッシュ法)
(define (solve1 start goal)
  ; 初期化
  (define q (make-queue))
  (define ht (make-hash 99991 hash-func equal?))
  (q 'enqueue! (list start (vector-position zero? start) '()))
  (ht 'insert! start #t)
  ;
  (while (not (q 'empty?))
    (let ((state (q 'dequeue!)))
      (let loop ((ls (vector-ref *adjacent* (get-space state))))
        (if (pair? ls)
          (let ((new-board (move-piece (get-board state)
                                       (get-space state)
                                       (car ls))))
            (cond ((equal? goal new-board)
                   (print-answer state)
                   (print-board goal)
                   (q 'clear!))
                  ((not (ht 'search new-board))
                   (q 'enqueue! (list new-board (car ls) state))
                   (ht 'insert! new-board #t)
                   (loop (cdr ls)))
                  (else (loop (cdr ls))))))))))

; 解の表示 (双方向探索用)
(define (print-answer-f state)
    (cond ((pair? state)
           (print-answer-f (get-prev state))
           (print-board (get-board state)))))

;
(define (print-answer-b state)
    (cond ((pair? state)
           (print-board (get-board state))
           (print-answer-b (get-prev state)))))

;
(define (print-answer2 state1 state2)
    (cond ((eq? (get-dir state1) 'F)
           (print-answer-f state1)
           (print-answer-b state2))
          (else
           (print-answer-f state2)
           (print-answer-b state1))))

; アクセス関数
(define (get-dir state) (cadddr state))

; 新しい局面をキューとハッシュ表に挿入する
(define (insert-new-state q ht . state)
    (q 'enqueue! state)
    (ht 'insert! (get-board state) state))

; 幅優先探索
(define (solve2 start goal)
  ; 初期化
  (define q (make-queue))
  (define ht (make-hash 99991 hash-func equal?))
  (insert-new-state q ht start (vector-position zero? start) '() 'F)
  (insert-new-state q ht goal (vector-position zero? goal) '() 'B)
  ;
  (while (not (q 'empty?))
    (let ((state (q 'dequeue!)))
      (let loop ((ls (vector-ref *adjacent* (get-space state))))
        (if (pair? ls)
          (let* ((new-board (move-piece (get-board state)
                                        (get-space state)
                                        (car ls)))
                 (same-state (ht 'search new-board)))
            (cond (same-state
                   (cond ((not (eq? (get-dir state) (get-dir same-state)))
                          (print-answer2 state same-state)
                          (q 'clear!))
                         (else (loop (cdr ls)))))
                  (else
                   (insert-new-state q ht new-board (car ls) state (get-dir state))
                   (loop (cdr ls))))))))))

; アクセス関数
(define (get-move state) (caddr state))

; 最長手数の探索
(define (solve-max start)
  ; 初期化
  (define ht (make-hash 99991 hash-func equal?))
  (define old-state '())
  (define new-state (list (list start (vector-position zero? start) 0)))
  (ht 'insert! start #t)
  ;
  (while (pair? new-state)
    (set! old-state new-state)
    (set! new-state '())
    (dolist (state old-state)
      (dolist (x (vector-ref *adjacent* (get-space state)))
        (let ((new-board (move-piece (get-board state)
                                     (get-space state)
                                     x)))
          (unless (ht 'search new-board)
            (set! new-state
                  (cons (list new-board x (+ (get-move state) 1)) new-state))
            (ht 'insert! new-board #t))))))
  ; 最長手数の局面を表示
  (dolist (state old-state)
      (format #t "~%~D" (get-move state))
      (print-board (get-board state))))
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
;
; queue.scm : リストによるキューの実装
;
;             Copyright (C) 2008 Makoto Hiroi
;

(define (make-queue)
    (let ((front '()) (rear '()))
        ; キューにデータを追加する
        (define (enqueue! item)
            (let ((new-cell (list item)))
                (if (null? front)
                    ; キューは空
                    (set! front new-cell)
                    ; 最後尾のセルを書き換える
                    (set-cdr! rear new-cell))
                (set! rear new-cell)))
        ; キューからデータを取り出す
        (define (dequeue!)
            (if (null? front)
                #f
                (let ((item (car front)))
                    (set! front (cdr front))
                    (if (null? front)
                        ; キューは空になった
                        (set! rear '()))
                    item)))
        :
        (lambda (x . args)
            (cond ((eq? x 'enqueue!)
                   (enqueue! (car args)))
                  ((eq? x 'dequeue!)
                   (dequeue!))
                  ((eq? x 'empty?)
                   (null? front))
                  ((eq? x 'clear!)
                   (set! front '())
                   (set! rear '()))
                  (else #f)))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm12.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm19.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>