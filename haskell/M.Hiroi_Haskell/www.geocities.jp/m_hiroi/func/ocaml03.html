<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881749</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml02.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">高階関数</h3>
<p> Lisp や ML などの関数型言語は、関数を他のデータ型と同等に取り扱うことができます。つまり、関数を変数に代入したり、引数として渡すことができるのです。また、値として関数を返すこともできるので、関数を作る関数を定義することもできます。関数を引数にとる関数のことを「汎関数 (functional) 」とか「高階関数 (higher order function) 」と呼びます。
</p>

<p> OCaml は高階関数を簡単に定義することができます。もちろん、値として関数を返すこともできるので、関数を作る関数を定義することも簡単です。実際、関数の操作は Common Lisp よりも柔軟で簡単です。
</p>

<h4>●関数を引数にとる関数</h4>
<p> 簡単な例として、整数 n から m までの和を求める関数 sum_of_integer を作ってみましょう。末尾再帰でプログラムすると、次のようになります。
</p>
<pre class="list">
リスト 1 : 整数の和

let rec sum_of_integer (n, m, a) =
  if n &gt; m then a
  else sum_of_integer (n + 1, m, a + n)
</pre>
<p> 実行例を示します。
</p>
<pre>
# sum_of_intger (1, 10, 0);;
- : int = 55
</pre>
<p> プログラムは簡単なので説明は不要でしょう。それでは、整数の 2 乗の和と 3 乗の和を求めるプログラムはどうなるでしょうか。次のリストを見てください。
</p>
<pre class="list">
リスト 2 : 整数の 2 乗の和と 3 乗の和

(* 2 乗 *)
let square x = x * x

(* 3 乗 *)
let cube x = x * x * x

(* 2 乗の和 *)
let rec sum_of_square (n, m, a) =
  if n &gt; m then a
  else sum_of_square (n + 1, m, a + square n)

(* 3 乗の和 *)
let rec sum_of_cube (n, m, a) =
  if n &gt; m then a
  else sum_of_cube (n + 1, m, a + cube n)
</pre>

<p> 実行例を示します。
</p>
<pre>
# sum_of_square (1, 10, 0);;
- : int = 385
# sum_of_cube (1, 10, 0);;
- : int = 3025
</pre>
<p> 累積変数 a に値を加算する処理で、関数 square を呼び出すと 2 乗の和を、関数 cube を呼び出すと 3 乗の和を求めることができます。関数 sum_of_square と sum_of_cube の違いはこれだけです。ここで、square や cube を引数として渡すことができれば、sum_of_square や sum_of_cube を一つの関数で済ますことができます。次のリストを見てください。
</p>
<pre class="list">
リスト 3 : 高階関数 sum_of

let rec sum_of (f, n, m, a) =
  if n &gt; m then a
  else sum_of (f, n + 1, m, a + f n)
</pre>
<p> 関数 sum_of の第 1 引数 f に関数を渡します。渡された関数は、今までと同じ方法で呼び出すことができます。square や cube のかわりに a + f n とすることで、関数 f に整数 n を適用した結果を a に加算することができます。
</p>
<p> OCaml の場合、let で定義された関数は、関数型データとしてその名前の変数に格納されています。したがって、次に示すように関数 sum_of の第 1 引数に square や cube を指定するだけで、変数に格納されている関数を渡すことができます。
</p>
<pre>
# sum_of (square, 1, 10, 0);;
- : int = 385
# sum_of (cube, 1, 10, 0);;
- : int = 3025
</pre>

<h4>●多相性</h4>
<p> ところで、sum_of_integer も sum_of を使って実現することができます。引数 f には自分自身を返す関数を渡せばよいのです。これを「恒等関数 (identity function) 」といいます。次の例を見てください。
</p>
<pre>
# let identity x = x;;
val identity : 'a -&gt; 'a = &lt;fun&gt;
# identity 10;;
- : int = 10
# identity 1.5;;
- : flaot = 1.5
# identity "foo";;
- : string = "foo"
# identity (1, 2);;
- : int * int = (1, 2)
</pre>
<p> 関数 identity は引数をそのまま返す関数です。'a は「型変数」といって、任意のデータ型を表します。identity の型は 'a -&gt; 'a なので、任意の型のデータを受け取り、同じ型を返す関数であることがわかります。つまり、int, float, string や組といった OCaml のデータ型であれば何でも対応することができるのです。このような関数を「多相型関数 (polymorphic function) 」といいます。
</p>

<p> 多相型関数のように、いろいろな型を取ることができる性質のことを「多相性 (polymmprphism) 」といいます。多相性は ML (OCaml, SML/NJ など) の特徴のひとつです。たとえば、要素が 2 つの組から最初の要素を取り出す関数 first を作ってみましょう。
</p>
<pre>
# let first (x, y) = x;;
val first : ('a * 'b) -&gt; 'a = &lt;fun&gt;
</pre>
<p> first は組の要素が何であっても対応することができます。実行例を示しましょう。
</p>
<pre>
# first (1, 2);;
- : int = 1
# first ("foo", 10);;
- : string = "foo"
</pre>
<p> なお、OCaml には first と同じ動作を行う関数 fst が定義されています。
</p>
<p> sum_of_integer は sum_of と identity を使って次のように実現できます。
</p>
<pre>
# sum_of (identity, 1, 10, 0);;
- : int = 55
</pre>
<p> OCaml は型チェックを厳密に行うプログラミング言語ですが、型推論と多相性により柔軟なプログラミングが可能になっています。
</p>

<h4>●匿名関数とカリー化</h4>
<p> 高階関数を使うようになると、数を 2 乗する square のような小さな関数をいちいち定義するのが面倒になります。とくに、その高階関数でしか使わないのであれば、なおさらそう思うでしょう。ML には Lisp のラムダ式 (lambda) のような「匿名関数 (anonymous function) 」という名前のない関数が用意されています。
</p>
<p> OCaml の場合、匿名関数は次のように定義します。
</p>
<pre class="item">
fun 引数 -&gt; 式
</pre>
<p> let による関数定義は、匿名関数を用いて次のように表すことができます。
</p>
<pre class="item">
let func = fun 引数 -&gt; 式
</pre>
<p> 匿名関数は関数型のデータを生成して返します。そして、let は変数 func をその値に束縛するだけなのです。また、OCaml は匿名関数をそのまま実行することができますし、関数の引数に匿名関数を渡すこともできます。
</p>
<pre>
# (fun x -&gt; x * x) 5;;
- : int = 25
# (fun (x, y) -&gt; x + y) (1, 2);;
- : int = 3
# sum_of ((fun x -&gt; x * x), 1, 10, 0);;
- : int = 385
</pre>

<p> ところで、今までは組を使って複数の引数を受け取る関数を実現しましたが、ML にはもう一つ方法があります。関数型言語は関数をデータ型の一つとして扱うことができるので、関数の返り値として関数を返すことができます。この「関数を返す関数」を使うと、関数の引数が一つでも複数の引数を処理することができます。このような関数を「カリー化関数 (curried function) 」といいます。
</p>

<p> たとえば、fun (x, y) -&gt; x + y の場合、引数 x を受け取ると「引数 y を受け取って x + y を計算する関数」を返し、その関数に引数 y を渡せば x + y を計算することができます。OCaml では、次のように定義することができます。
</p>
<pre>
# fun x -&gt; fun y -&gt; x + y;;
- : int -&gt; int -&gt; int = &lt;fun&gt;
</pre>
<p> 関数の型が少し複雑になりました。-&gt; は右結合なので、int -&gt; int -&gt; int は int -&gt; (int -&gt; int) となります。これは引数 int を受け取り、int -&gt; int という型の関数を返すことを表しています。これで引数を一つだけ与えれば、関数を返すことになります。もちろん、引数を 2 つ与えれば、それらを加算した結果を返します。つまり、最初の引数を受け取って関数を生成し、その関数を 2 番目の引数に適用する、という動作になります。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
# (fun x -&gt; fun y -&gt; x + y) 1;;
- : int -&gt; int = &lt;fun&gt;
# (fun x -&gt; fun y -&gt; x + y) 1 2;;
- : int = 3
</pre>
<p> 引数を一つだけ渡すと「引数 y を受け取って x + y を計算する関数」を返します。引数を 2 つ渡すと、それを足し算した値を返します。カリー化関数の場合、引数は空白で区切ることに注意してください。
</p>
<p> fun を入れ子にするのは面倒なので、OCaml は次のようにカリー化関数を定義することができます。
</p>
<pre class="item">
fun 引数1 引数2 ... 引数n -&gt; 式
</pre>
<p> また、let 式でも同様にカリー化関数を定義することができます。
</p>
<pre class="item">
let func 引数1 引数2 ... 引数n = 式
</pre>
<p> 関数をカリー化する場合、引数をカッコで囲わず、カンマでも区切りません。たとえば、関数 sum_of をカリー化すると次のようになります。
</p>
<pre class="list">
リスト 4 : 関数 sum_of のカリー化

let rec sum_of f n m a =
  if n &gt; m then a
  else sum_of f (n + 1) m (a + f n)
</pre>
<p> そして、この sum_of を使うと、sum_of_integer, sum_of_square, sum_of_cube を簡単に定義することができます。
</p>
<pre>
# let sum_of_integer = sum_of (fun x -&gt; x);;
val sum_of_integer : int -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
# let sum_of_square = sum_of (fun x -&gt; x * x);;
val sum_of_square : int -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
# let sum_of_cube = sum_of (fun x -&gt; x * x * x);;
val sum_of_cube : int -&gt; int -&gt; int -&gt; int = &lt;fun&gt;
# sum_of_integer 1 10 0;;
- : int = 55
# sum_of_square 1 10 0;;
- : int = 385
# sum_of_cube 1 10 0;;
- : int = 3025
</pre>
<p> このように、カリー化された関数の一部の引数に値を与えて、残りの引数を受け取る関数を生成することを「部分適用 (partial application) 」といいます。カリー化関数は部分適用が簡単にできるのでとても便利です。OCaml の場合、カリー化関数はよく使われる方法です。
</p>
<hr>
<h3 id="chap02">リスト</h3>
<p> 次は「リスト (list) 」というデータ構造を説明します。OCaml のリストは「連結リスト (Linked List) 」のことです。リストを扱うプログラミング言語といえば Lisp が有名です。SML/NJ や Haskell などの関数型言語や論理型言語の Prolog も、組み込みのデータ構造として連結リストを装備しています。
</p>

<p> 連結リストは単純なデータ構造ですが、他のデータ構造を実装するときに用いられることがあります。連結リストは基本的で重要なデータ構造の一つなのです。OCaml のリストは Lisp のリストと同じで、複数のデータを格納することができます。ただし、Lisp のリストとは違って、リストの要素は同じデータ型でなければいけません。
</p>

<h4>●リストの構造</h4>

<p> リストの構造を図で表すと次のようになります。
</p>

<pre class="fig">
┌─┬─┐    ┌─┬─┐    ┌─┬─┐
│・│・┼─→│・│・┼─→│・│・┼─→ [] (空リスト)
└┼┴─┘    └┼┴─┘    └┼┴─┘
  ↓            ↓            ↓
  １            ２            ３

        図 1 : リスト内部の構造
</pre>

<p> リストは貨物列車にたとえるとわかりやすいでしょう。車両に相当するものを「コンスセル (cons cell) 」といいます。貨物列車には多数の車両が接続されて運行されるように、リストは複数のコンスセルを接続して構成されます。1 つのコンスセルには、貨物（データ）を格納する場所と、連結器に相当する場所があります。
</p>

<p> 上図では、コンスセルを箱で表しています。コンスセルの左側がデータを格納する場所で、右側が次のコンスセルと連結しています。この例では、3 つのコンスセルが接続されています。それから、最後尾のコンスセルには、リストの終わりを示す特別なデータが格納されます。OCaml の場合、要素が一つもないリスト (空リスト) を表すデータ [ ] でリストの終端を表します。
</p>

<h4>●リストの構成法</h4>
<p> OCaml のリストは、要素をセミコロン ( ; ) で区切り、角カッコ [ ] で囲んで表します。次の例を見てください。
</p>
<pre>
# let a = [1; 2; 3; 4];;
val a : int list = [1; 2; 3; 4]
# let b = ["abc"; "def"; "ghi"];;
val b : string list ["abc"; "def"; "ghi"]
# let c = [(1, 2); (3, 4); (5, 6)];;
val c : (int * int) list= [(1, 2), (3, 4), (5, 6)]
# let d = [[1]; [2; 3]; [4; 5; 6]];;
val d : int list list = [[1]; [2; 3]; [4; 5; 6]]
# let e = [1 + 2 + 3; 4 * 5 * 6];;
val e : int list = [6; 120]
</pre>
<p> 変数 a のリストは要素が int なので型は int list になります。[1] や [2; 3] も型は int list になります。リストに格納された要素の個数を「リストの長さ」といいます。リストの型はリストの長さとは関係なく、格納する要素の型によって決まります。変数 b のリストは要素が文字列なので型は string list になります。
</p>
<p> 組をリストに入れてもかまいません。変数 c は組 int * int を格納するリストなので、型は (int * int) list になります。このリストに (1, 2, 3) という組を入れることはできません。(1, 2, 3) の型は int * int * int で、int * int とは型が異なるからです。
</p>
<p> リストは入れ子にすることができます。変数 d のリストは [1], [2; 3], [4; 5; 6] という int list を格納しています。したがって、型は int list list になります。このリストに [[7]] を入れることはできません。[[7]] の型は int list list になるので、要素の型 int list とは異なるからです。また、最後の例のように角カッコの中に式を書くと、それを評価した値がリストの要素になります。
</p>

<h4>●リストの合成と分解</h4>
<p> リストは関数 hd, tl を使って分解し、演算子 :: (コンス演算子) で合成することができます。また、演算子 @ でリストを連結することができます。次の例を見てください。
</p>
<pre>
# let a = [1; 2; 3; 4];;
val a : int list = [1; 2; 3; 4]
# List.hd a;;
- : int = 1
# List.tl a;;
- : int list = [2; 3; 4]
# let b = 0 :: a;;
val b = [0; 1; 2; 3; 4]
# let c = [1; 2; 3] @ [4; 5; 6];;
val c : int list = [1; 2; 3; 4; 5; 6]
</pre>
<p> OCaml の場合、リストを操作する関数は標準ライブラリ List に定義されています。OCaml は「モジュール」という機能を使ってライブラリを構成しています。モジュール内の関数は "モジュール名 + ドット ( . ) + 関数名" という形式で呼び出します。関数 hd を呼び出すときは List.hd とし、関数 tl を呼び出すときは List.tl とします。
</p>

<p> hd a は Lisp の関数 car と同じで、リスト a の先頭要素を取り出します。リスト [1; 2; 3; 4] の先頭要素は 1 なので、hd a は 1 を返します。tl a は Lisp の関数 cdr と同じで、リスト a から先頭要素を取り除いたリストを返します。tl a は [1; 2; 3; 4] から 1 を取り除いた [2; 3; 4] を返します。演算子 :: は Lisp の関数 cons と同じで、リストの先頭にデータを付け加えます。演算子 @ は Lisp の関数 append と同じで、2 つのリストをつないだリストを返します。
</p>

<p> hd, tl, コンス演算子の関係を図に表すと次のようになります。
</p>

<pre class="fig">
                      ┌──┐
                ┌─→│ｈｄ│→ １  ────┐
                │    └──┘               ↓
                │                        ┌──┐
 [1; 2; 3; 4] ─┤                        │：：│→ [1; 2; 3; 4]  
                │                        └──┘
                │    ┌──┐               ↑
                └─→│ｔｌ│→ [2; 3; 4] ─┘
                      └──┘

                図 2 : リストの分解と合成
</pre>

<p> この関係はリストを操作する関数を作る場合の基本になります。
</p>

<p> 要素のないリストを「空リスト」といい、OCaml では [ ] で表します。次の例を見てください。
</p>
<pre>
# [];;
- : 'a list = []
# List.tl [1];;
- : int list = []
# List.tl ["abc"];;
- : string list = []
</pre>
<p> [ ] はどのようなリスト型にもあてはまります。[ ] だけを入力すると型は 'a list と表示されます。要素が一つしかないリストに tl を適用すると空リストになります。次の例は int list に tl を適用したので、[ ] を int list と表示しました。3 番目の例のように、string list の空リスト [ ] は string list と表示されます。リスト自身は多相的なデータ型で、格納する要素のデータ型によってリストのデータ型が決まることに注意してください。
</p>

<p> コンス演算子を続ける場合は結合規則に注意してください。次の例を見てください。
</p>
<pre class="item">
1::2::3::[] =&gt; (1::(2::(3::[]))) =&gt; [1; 2; 3]
</pre>
<p> このように、コンス演算子は四則演算とは違って「右結合」になります。また、コンス演算子の右辺はリストでなければいけません。1::2 はエラーになります。ご注意くださいませ。
</p>
<p> 実際のプログラムでは、hd や tl でリストを分解するよりも「パターンマッチング」を使った方が簡単です。リストのパターンマッチングはあとで詳しく説明します。
</p>

<h4>●再帰定義によるリスト操作</h4>
<p> リストを操作する関数は再帰定義を使うと簡単に作ることができます。実は、リスト操作と再帰定義はとても相性が良いのです。まずは、リストの長さを求める関数 length を作りましょう。 OCaml には List.length という同等の機能を持つ関数が用意されていますが、再帰定義を使えば簡単に作ることができます。
</p>

<p> まず、いちばん簡単な場合を考えます。引数が空リストであれば 0 を返せばいいですね。あとは、リストが空リストになるように分解していけばいいのです。つまり、リスト ls の長さを求めるには、リスト ls に tl を適用したリストの長さがわかればいい、と考えるのです。それに 1 を足せば、リストの長さを求めることができます。これをプログラムすると、次のようになります。
</p>

<pre class="list">
リスト 5 : リストの長さを求める

let rec length ls =
  if ls = [] then 0
  else 1 + length (List.tl ls)
</pre>

<p> 引数 ls が空リストであれば 0 を返します。そうでなければ、引数 ls に関数 tl を適用して length を再帰呼び出しします。リストに tl を繰り返し適用していくと最後は空リストになります。ここで再帰呼び出しが止まって 0 を返します。そうすると、1 + length によって length の返り値に 1 を足した値を返していきます。すなわち tl した回数だけ 1 が足されるわけです。
</p>

<p> 実際に length を定義すると次のように表示されます。
</p>
<pre class="item">
val length : 'a list -&gt; int = &lt;fun&gt;
</pre>
<p> length の場合、任意の型 'a を格納するリストを引数に取り、int を返すことが示されています。つまり、引数が int list でも string list でも、リストであればその長さを返すことができます。このように、length は多相型関数として定義されます。OCaml の関数 hd, tl も多相型関数です。
</p>
<pre>
# List.hd;;
- : 'a list -&gt; 'a = &lt;fun&gt;
# List.tl;;
- : 'a list -&gt; 'a list = &lt;fun&gt;
</pre>
<p> それでは実際に試してみましょう。
</p>
<pre>
# length [1; 2; 3; 4; 5; 6];;
- : int = 6
# length ["ab", "cd", "ef"];;
- : int = 3
</pre>
<p> 正常に動作していますね。なお、length を末尾再帰で直すと次のようになります。
</p>
<pre class="list">
リスト 6 : 末尾再帰版

let length ls =
  let rec iter ls a =
    if ls = [] then a
    else iter (List.tl ls) (a + 1)
  in
    iter ls 0
</pre>
<h4>●リストの連結</h4>
<p> 次はリストを連結する演算子 @ と同じ動作をする関数 append を作ってみましょう。引数としてリスト xs と ys を渡して、それを連結したリストを返します。
</p>
<p> 処理手順ですが、簡単な場合から考えていきましょう。まず、リスト xs が空リストならば、リスト ys を返すだけでいいですね。次に、リスト xs に要素が 1 つしかない場合を考えてみます。これは、リスト xs に hd を適用して要素を取り出し、それをコンス演算子でリスト ys の先頭に追加すればいいでしょう。
</p>
<p> それでは、リスト xs に要素が複数ある場合を考えてください。リスト xs を hd と tl で分解します。そして、tl xs と ys を連結したリストを求め、そのリストの先頭に hd xs  を追加すれば xs と ys を連結することができます。tl xs  と ys の連結は再帰呼び出しで実現することができます。これを図に示すと次のようになります。
</p>

<pre class="fig">
┌────────────────────────────┐ 
│append( [1; 2], [3; 4] )                                │
├────────────────────────────┤
│ [ 1,  2 ]                                              │
│  ┬  ─── tl ─┐                                    │
│  hd              ↓                                    │
│  │    ┌──────────────────────┐│
│  │    │append( [2], [3; 4] )                       ││
│  │    ├──────────────────────┤│
│  │    │ [  2     ]                                 ││
│  │    │    ┬  ─ tl  ─┐                         ││
│  │    │    hd           ↓                         ││
│  │    │    │  ┌────────────────┐││
│  │    │    │  │append( [],  [3; 4] ) =&gt; [3; 4] │││
│  │    │    │  └────────────────┘││
│  │    │    │            │                        ││
│  │    │    └→  ::  ←─┘                        ││
│  │    │       [2; 3; 4]                            ││
│  │    └─────┼────────────────┘│
│  └──→  ::  ←─┘                                  │
└──────┼─────────────────────┘
              ↓
          [1; 2; 3; 4]

                図 3 : append の動作
</pre>


<p> これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト 7 : リストの結合

let rec append xs ys =
  if xs = [] then ys
  else List.hd xs :: append (List.tl xs) ys
</pre>

<p>  引数 xs が空リストであればリスト ys をそのまま返します。これが再帰呼び出しの停止条件になります。そうでなければ、tl xs を append に渡して再帰呼び出しします。そして、その返り値と hd xs をコンス演算子で接続します。これでリストを連結することができます。
</p>
<p> 実際に append を定義すると、次のように表示されます。
</p>
<pre class="item">
val append = 'a list -&gt; 'a list -&gt; 'a list
</pre>
<p> このように、append も多相型関数になります。簡単な実行例を示します。
</p>
<pre>
# append [1; 2; 3] [4; 5; 6];;
- : int list = [1; 2; 3; 4; 5; 6]
# append ["ab"; "cd"] ["ef"; "gh"];;
- : string list = ["ab"; "cd"; "ef"; "gh"]
</pre>
<h4>●リストの反転</h4>
<p> 今度はリストの要素を反転する関数 reverse を作ってみましょう。OCaml には List.rev という同等の機能を持つ関数が用意されていますが、私達でも簡単に作ることができます。reverse は引数のリスト xs を hd と tl で分解し、tl xs を反転させてから hd xs を最後尾に追加することで実現できます。次の図を見てください。
</p>

<pre class="fig">
[1, 2, 3]                               [3, 2] @ [1] =&gt; [3, 2, 1]  
      ↓                                  ↑
   [2, 3]                  [3] @ [2] =&gt; [3, 2]
      ↓                   ↑
      [3]     [ ] @ [3] =&gt; [3]
      ↓      ↑
      [ ] ──┘

                図 4 : reverse の動作</TH></TR>
</pre>

<p> これをプログラムすると、次のようになります。
</p>

<pre class="list">
リスト 8 : リストの反転

let rec reverse xs =
  if xs = [] then []
  else reverse (List.tl xs) @ [List.hd xs]
</pre>

<p> 引数 xs が空リストの場合は [ ] を返します。そうでなければ、reverse を再帰呼び出しして tl xs を反転し、演算子 @ で反転したリストの最後尾に先頭の要素を追加します。
</p>
<p> 実際に reverse を定義すると、次のように表示されます。
</p>
<pre class="item">
val reverse : 'a list -&gt; 'a list = &lt;fun&gt;
</pre>
<p> reverse も多相型関数になります。簡単な実行例を示します。
</p>
<pre>
# reverse [1; 2; 3];;
- : int list = [3; 2; 1]
# reverse ["ab"; "cd"; "ef"];;
- : string list = ["ef";"cd";"ab"]
</pre>
<p> 正常に動作していますね。なお、このプログラムはリストを連結する @ 演算子を使っているので効率的ではありません。末尾再帰で書き直すと次のようになります。
</p>
<pre class="list">
リスト 9 : 末尾再帰版

let reverse ls =
  let rec iter ls a =
    if ls = [] then a
    else iter (List.tl ls) (List.hd ls :: a)
  in
    iter ls []
</pre>
<p> リスト ls の先頭要素を取り出し、コンス演算子で累積変数 a の先頭に追加していけば、ls の逆順のリストを得ることができます。
</p>
<h4>●リストの探索</h4>
<p> 最後に、リストからデータを探索する関数 member を作ってみましょう。OCaml にはデータを見つけたら true を返し、見つからない場合は false を返す関数 List.mem がありますが、ここでは Common Lisp の関数 member と同等の動作をする関数を作ります。
</p>
<p> member はリストの中にデータがなければ空リストを返します。データを見つけた場合は、そのリストの残りを返します。つまり、返り値のリストの先頭要素が見つけたデータになります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト 10 : リストの探索

let rec member x ys =
  if ys = [] then []
  else if x = List.hd ys then ys
  else member x (List.tl ys)
</pre>

<p> 関数 member はリスト ys の中から x と等しい要素を探します。これは member を再帰呼び出ししてリストを分解し、リストの先頭要素をチェックしていくことで実現できます。
</p>
<p> ys が空リストの場合は x を見つけることができなかったので [ ] を返します。これが再帰の停止条件になります。次に、リスト ys の先頭の要素 hd ys が x と等しいかチェックします。等しい場合は、リスト ys をそのまま返します。そうでなければ、member を再帰呼び出しして次の要素を調べます。
</p>
<p> 実際に member を定義すると、次のように表示されます。
</p>
<pre class="item">
val member : 'a -&gt; 'a list -&gt; 'a list
</pre>
<p> それでは、簡単な実行例を示します。
</p>
<pre>
# member 3 [1; 2; 3; 4; 5];;
- : int list = [3; 4; 5]
# member 5 [1; 2; 3; 4; 5];;
- : int list = [5]
# member 0 [1; 2; 3; 4; 5];;
- : int list  = []
# member "ab" ["ab"; "cd"; "ef"];;
- : string list = ["ab";"cd";"ef"]
# member "ac" ["ab"; "cd"; "ef"];;
- : string list = []
</pre>
<p> データが見つからない場合、空リストが返されますが、そのデータ型は引数のリストと同じデータ型であることに注意してください。OCaml の関数は、異なるデータ型を返すことができません。たとえば、見つけた場合はその要素を返し、見つからない場合は false を返す、ということはできないのです。要素を返したい場合は option というデータ型を使うと簡単です。これは後で詳しく説明します。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml02.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>