<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj02.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>継承</h3>
<p> 前回は Gauche のオブジェクト指向機能を使った例題として「双方向リスト」というデータ構造を作りました。今回は「継承 (inheritance : インヘリタンス) 」のお話です。まずは最初に、一般的なオブジェクト指向言語での「継承」について簡単に説明します。
</p>

<h4>●継承とは？</h4>
<p> 継承は簡単に言うとクラスに「親子関係」を持たせる機能です。子クラスは親クラスの性質を受け継ぐことができます。プログラミング言語の場合、引き継ぐ性質は定義された「スロット (インスタンス変数) 」や「メソッド」などになります。プログラムを作る場合、いままで作ったプログラムと同じような機能が必要になることがありますが、継承を使うことでその機能を受け継ぎ、新規の機能や変更される機能だけプログラムする、いわゆる「差分プログラミング」が可能になります。
</p>

<p> クラスを継承する場合、その元になるクラスを「スーパークラス」とか「ベースクラス」と呼びます。そして、継承したクラスを「サブクラス」と呼びます。この呼び方は言語によってまちまちで統一されていません。Ｃ++の場合は、元になるクラスを基本クラスといい、継承するクラスを派生クラスとか導出クラスといいます。
</p>

<p> たとえば、クラス Foo1 を継承してクラス Foo2 を定義しましょう。クラス Foo1 にはメソッド bar が定義されています。クラス Foo2 にメソッド bar は定義されていませんが、Foo2 のオブジェクトに対して bar を呼び出すと、スーパークラス Foo1 のメソッド bar が実行されるのです。
</p>

<p> メソッドの選択は次のように行われます。まず、オブジェクトが属するクラス Foo2 にメソッド bar が定義されているか調べます。ところが、Foo2 には bar が定義されていないので、スーパークラスである Foo1 に bar が定義されているか調べます。ここでメソッド bar が見つかり、それを実行するのです。このように、メソッドが見つかるまで順番にスーパークラスを調べていきますが、最上位のスーパークラスまで調べてもメソッドが見つからない場合はエラーとなります。
</p>

<p> 継承したクラスのメソッドとは違う働きをさせたい場合、同名のメソッドを定義することで、そのクラスのメソッドを設定することができます。これを「オーバーライド (over ride) 」といいます。メソッドを選択する仕組みから見た場合、オーバーライドは必然の動作です。メソッドはサブクラスからスーパークラスに向かって探索されるので、スーパークラスのメソッドよリサブクラスのメソッドが先に選択されるわけです。
</p>

<h4>●単一継承と多重継承</h4>
<p> 継承には「単一継承」と「多重継承」の 2 種類があります。単一継承は、ただひとつのクラスからしか機能を継承することができません。したがって、クラスの階層は図 1 のような木構造で表すことができます。
</p>
<pre class="fig">
            Ａ
          ／｜＼
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ
    ／  ＼
  ／      ＼
Ｅ          Ｆ

図 1 : 単一継承におけるクラスの階層
</pre>
<p> 継承は何段階に渡って行われてもかまいません。たとえばクラス E の場合、スーパークラスが B で、B のスーパークラスが A に設定されています。サブクラスは複数あってもかまいません。たとえば、A のサブクラスは B, C, D と 3 つ、B のサブクラスは E, F と 2 つあります。図 1 では、クラス A のスーパークラスはありませんが、ほかのクラスではただひとつのスーパークラスを持っています。プログラミング言語では、Smalltalk, Java, Ruby が単一継承です。
</p>

<p> これに対し多重継承は、複数のクラスを継承することができます。このため、クラスの階層は木構造ではなく、図 2 のようなグラフで表すことができます。
</p>
<pre class="fig">
              Ａ
            ／  ＼
          ／      ＼
        Ｂ          Ｃ
      ／  ＼      ／  ＼
    ／      ＼  ／      ＼
  Ｄ          Ｅ          Ｆ

図 2 : 多重継承におけるクラスの階層
</pre>
<p> クラス E に注目してください。スーパークラスには B と C の 2 つがあります。多重継承では、単一継承と同じくサブクラスを複数持つことができ、なおかつ、スーパークラスも複数持つことができるのです。Ｃ++, Perl, Python, CLOS は多重継承をサポートしています。Gauche のオブジェクト指向システムも多重継承です。
</p>

<h4>●単一継承の使い方</h4>
<p> まずは「単一継承」から説明しましょう。クラスを継承する場合、define-class でスーパークラスを指定します。簡単な使用例を示します。
</p>
<pre class="list">
リスト 1 : クラスの定義

(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-value 1 :init-keyword :a)
   (b :accessor foo-b :init-value 2 :init-keyword :b)))

(define-class &lt;bar&gt; (&lt;foo&gt;)
  ((c :accessor bar-c :init-value 10 :init-keyword :c)
   (d :accessor bar-d :init-value 20 :init-keyword :d)))
</pre>

<p> define-class でクラス名を指定し、その次のリストでスーパークラスを指定します。クラス &lt;bar&gt; はクラス &lt;foo&gt; を指定しているので、&lt;foo&gt; は &lt;bar&gt; のスーパークラスになります。この場合、スーパークラスはひとつしかないので「単一継承」になります。ここで複数のスーパークラスを指定すると「多重継承」になります。
</p>

<h4>●スロットとメソッドの継承</h4>
<p> それでは、実際にインスタンスを生成してみましょう。次の例を見てください。
</p>
<pre>
gosh&gt; (define x (make &lt;foo&gt;))
x
gosh&gt; (define y (make &lt;bar&gt;))
y
gosh&gt; (foo-a x)
1
gosh&gt; (foo-b x)
2
gosh&gt; (bar-c y)
10
gosh&gt; (bar-d y)
20
gosh&gt; (foo-a y)
1
gosh&gt; (foo-b y)
2
</pre>
<p> これを図に示すと次のようになります。
</p>
<pre class="fig">
                         変数 x
┌─ &lt;foo&gt;  ─┐          ┌─ instance ─┐  
├──────┤          ├───────┤
│slot a : 1  │────→│slot a : 1    │
├──────┤          ├───────┤
│slot b : 2  │          │slot b : 2    │
└──────┘          └───────┘
       │
       ↓                変数 y
┌─ &lt;bar&gt;  ─┐          ┌─ instance ─┐
├──────┤────→├───────┤
│slot c : 10 │          │slot a : 1    │
├──────┤          ├───────┤
│slot d : 20 │          │slot b : 2    │
└──────┘          ├───────┤
                          │slot c : 10   │
                          ├───────┤
                          │slot d : 20   │
                          └───────┘

        図 3 : インスタンスの生成
</pre>
<p> クラス &lt;foo&gt; にはスロット a, b とメソッド foo-a, foo-b が定義されています。次に、クラス &lt;bar&gt; を定義します。&lt;bar&gt; は &lt;foo&gt; を継承し、&lt;bar&gt; 固有のスロット c, d  とメソッド bar-c, bar-d  が定義されています。&lt;foo&gt; と &lt;bar&gt; のインスタンスを生成すると、上図に示したように &lt;bar&gt; のインスタンスはスロット c, d だけではなく、クラス &lt;foo&gt; で定義されたスロット a, b も含まれます。
</p>

<p> &lt;foo&gt; のインスタンスにもスロット a, b がありますが、&lt;bar&gt; のインスタンスのスロット a, b とメモリ領域を共有 <SUP><a href="abcobj03.html#note1">[*1]</a></SUP> することはありません。クラスはオブジェクトの設計図です。設計に共通な部分があったとしても、それから生み出されるインスタンスは別々の実体で、メモリ領域を共有することはないのです。 
</p>

<p> クラス &lt;bar&gt; にはメソッド bar-c, bar-d しか定義されていませんが、クラス &lt;foo&gt; を継承したことにより、メソッド foo-a と foo-b も呼び出すことができます。&lt;bar&gt; のインスタンス y に対して foo-a を呼び出すと、インスタンス y のスロット a の値を取り出すことができます。また、(set! (foo-a y) 100) とすれば、インスタンス y のスロット a の値を書き換えることができます。次の例を見てください。
</p>
<pre>
gosh&gt; (set! (foo-a y) 100)
#&lt;undef&gt;
gosh&gt; (foo-a y)
100
gosh&gt; (foo-a x)
1
</pre>

<p> set! でインスタンス y のスロット a を 100 に変更しました。当然ですが、インスタンス x のスロット a の値は 1 のままです。スロット a は共有されていないので、インスタンス y にメソッド foo-a を適用すれば、インスタンス y のスロット a にアクセスすることになります。
</p>

<DIV class="note">
<a name="note1">-- note --------</a><BR>
[*1] Gauche の場合、スロットオプション :allocation にキーワード :class を指定すると、そのスロットは共有されます。:allocation の指定がない場合、もしくはキーワード :instance を指定すると、スロットは共有されません。
</DIV>
<h4>●スーパークラスに同じスロット名がある場合</h4>
<p> Gauche の場合、define-class でスロットを定義するときに、スーパークラスと同じスロット名があってもかまいません。ただし、インスタンス内では、同じスロット名でアクセスできるスロットはひとつしか存在しません。次の例を見てください。
</p>
<pre class="list">
リスト 2 : クラスの定義

(define-class &lt;baz&gt; (&lt;foo&gt;)
  ((a :accessor baz-a :init-value 100 :init-keyword :baz-a)))
</pre>
<pre>
gosh&gt; (define z (make &lt;baz&gt;))
z
gosh&gt; (baz-a z)
100
gosh&gt; (foo-a z)
100
gosh&gt; (define z2 (make &lt;baz&gt; :baz-a 1000))
z2
gosh&gt; (baz-a z2)
1000
gosh&gt; (foo-a z2)
1000
gosh&gt; (define z3 (make &lt;baz&gt; :a 100000))
z3
gosh&gt; (baz-a z3)
100
gosh&gt; (foo-a z3)
100
</pre>
<p> クラス &lt;foo&gt; はスロット a を定義しています。クラス &lt;baz&gt; は &lt;foo&gt; を継承していますが、同じ名前のスロット a を定義しています。この場合、インスタンスを生成すると、a に対応するスロットはひとつしかありません。このとき、スロットオプションはサブクラスの指定が優先されることに注意してください。
</p>
<p> ただし、:accessor で指定されたメソッド foo-a, baz-a はどちらも利用することができます。この場合、同じスロット a をアクセスすることになります。:init-value はサブクラスの値が優先されます。したがって、(make &lt;bar&gt;) とすると、スロット a の初期値は 100 になります。実際に、メソッド foo-a, bar-a で値を求めると、100 に初期化されていることがわかります。:init-keyword はサブクラスのキーワードが優先されます。&lt;foo&gt; で指定したキーワード :a で、スロット a の初期値を与えることはできません。
</p>

<h4>●データ型の継承</h4>
<p> Gauche の場合、クラスはインスタンスのデータ型を表す識別子として使うことができます。継承はスロットやメソッドだけに作用するのではなく、データ型も継承されます。次の例を見てください。
</p>

<pre>
gosh&gt; (define-class &lt;foo&gt; () ())
&lt;foo&gt;
gosh&gt; (define-class &lt;bar&gt; (&lt;foo&gt;) ())
&lt;bar&gt;
gosh&gt; (define a (make &lt;foo&gt;))
a
gosh&gt; (define b (make &lt;bar&gt;))
b
gosh&gt; (is-a? a &lt;foo&gt;)
#t
gosh&gt; (is-a? b &lt;bar&gt;)
#t
gosh&gt; (is-a? b &lt;foo&gt;)
#t
gosh&gt; (is-a? a &lt;bar&gt;)
#f
</pre>
<pre class="item">
is-a? object class
</pre>
<p> 関数 is-a? は object が class のインスタンス、または class のサブクラスのインスタンスであれば真を返し、そうでなければ偽を返します。
</p>
<p> クラス &lt;bar&gt; はクラス &lt;foo&gt; を継承しています。&lt;foo&gt; のインスタンス a は is-a? でチェックすると、当然ですが &lt;foo&gt; では #t になり、&lt;bar&gt; では #f になります。ところが、クラス &lt;bar&gt; のインスタンス b は、&lt;bar&gt; で #t になるのは当然ですが、&lt;foo&gt; のサブクラスなのでデータ型が継承されて &lt;foo&gt; でも #t になります。
</p>

<p> ここで、&lt;bar&gt; を継承したクラス &lt;baz&gt; の作って、そのインスタンスを is-a? でチェックすると、&lt;foo&gt;, &lt;bar&gt;, &lt;baz&gt; のどれでも #t になります。
</p>

<pre>
gosh&gt; (define-class &lt;baz&gt; (&lt;bar&gt;) ())
&lt;baz&gt;
gosh&gt; (define c (make &lt;baz&gt;))
c
gosh&gt; (is-a? c &lt;baz&gt;)
#t
gosh&gt; (is-a? c &lt;bar&gt;)
#t
gosh&gt; (is-a? c &lt;foo&gt;)
#t
</pre>

<p> このように、クラスを継承してサブクラスを作ると、サブクラスはスーパークラスの部分集合として考えることができます。図 3 を見てください。
</p>
<pre class="fig">
  ┌──────────┐
  │       &lt;foo&gt;        │
  │  ┌──────┐  │
  │  │   &lt;bar&gt;    │  │
  │  │ ┌───┐ │  │
  │  │ │&lt;baz&gt; │ │  │
  │  │ │      │ │  │
  │  │ └───┘ │  │
  │  │            │  │
  │  └──────┘  │
  │                    │
  └──────────┘

図 3 : クラスとサブクラスの関係
</pre>
<p> 単一継承の場合、クラスとサブクラスは図 3 の関係になります。サブクラス &lt;baz&gt; は &lt;bar&gt; や &lt;foo&gt; に含まれているので、そのインスタンスに &lt;bar&gt; や &lt;foo&gt; のメソッドを適用することができるわけです。
</p>

<h4>●メソッドの選択</h4>
<p> もうひとつ簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define-method add ((x &lt;foo&gt;)) (+ (foo-a x) (foo-b x)))
#&lt;generic add (1)&gt;
gosh&gt; (define a1 (make &lt;foo&gt; :a 10 :b 20))
a1
gosh&gt; (define b1 (make &lt;bar&gt; :a 100 :b 200))
b1
gosh&gt; (add a1)
30
gosh&gt; (add b1)
300
</pre>
<p> いま、メソッド add を定義しました。add はスロット a と b の値を足し算します。このメソッドは引数のクラス指定（引数特定子）に &lt;foo&gt; を指定しているので、&lt;foo&gt; のインスタンスだけではなく、&lt;foo&gt; のサブクラス &lt;bar&gt; のインスタンスにも適用することができます。クラス &lt;bar&gt; のインスタンスを生成して変数 b1 にセットします。このインスタンスに add を適用すると、スロット a と b を足した値を求めることができます。
</p>

<p> それでは、メソッドの引数特定子にサブクラス &lt;bar&gt; を指定した場合はどうなるのでしょうか。実際に試してみましょう。
</p>
<pre>
gosh&gt; (define-method sub ((x &lt;bar&gt;)) (- (foo-a x) (foo-b x)))
#&lt;generic sub (1)&gt;
gosh&gt; (sub b1)
-100
gosh&gt; (sub a1)
*** ERROR: no applicable method for #&lt;generic sub (1)&gt; with arguments (#&lt;&lt;foo&gt; 0pba1da0&gt;)
</pre>

<p> スロット a, b の差分を求めるメソッド sub を定義します。sub の引数特定子は &lt;bar&gt; なので、&lt;bar&gt; のインスタンス y に sub を適用すると a と b の差分を求めることができます。ところが、スーパークラス &lt;foo&gt; のインスタンス a1 に sub を適用すると、「適用できるメソッドがない」というエラーが発生します。&lt;foo&gt; にもスロット a, b があるのですが、このメソッドを &lt;foo&gt; のインスタンスに適用することはできないのです。
</p>

<p> ここで、Gauche がどのようにメソッドを選択するか簡単に説明しましょう。まず、総称関数 add に引数特定子が &lt;bar&gt; のメソッドが定義されているか調べます。ところが、総称関数 add には引数特定子が &lt;bar&gt; のメソッドは定義されていません。この場合はスーパークラスをチェックします。&lt;bar&gt; のスーパークラスは &lt;foo&gt; なので、引数特定子が &lt;foo&gt; のメソッドが定義されているか総称関数 add を調べます。ここで該当するメソッドが見つかり、それを評価するのです。
</p>

<p> 総称関数 sub の場合、引数特定子が &lt;foo&gt; のメソッドは定義されていませんね。そこで、&lt;foo&gt; のスーパークラスを調べようとするのですが、&lt;foo&gt; のスーパークラスは定義されていません。これ以上探索するクラスがないのでエラーになるのです。このように、メソッドはサブクラスからスーパークラスの方向へ探索することを覚えておいてください。
</p>
<h4>●複数の引数がある場合</h4>
<p> では、複数の引数特定子を持つメソッドの場合はどうなるのでしょうか。次の例を見てください。
</p>
<pre>
gosh&gt; (define-class &lt;foo&gt; () ())
&lt;foo&gt;
gosh&gt; (define-class &lt;foo1&gt; (&lt;foo&gt;) ())
&lt;foo1&gt;
gosh&gt; (define-class &lt;bar&gt; () ())
&lt;bar&gt;
gosh&gt; (define-class &lt;bar1&gt; (&lt;bar&gt;) ())
&lt;bar1&gt;
gosh&gt; (define-method baz ((x &lt;foo&gt;) (y &lt;bar&gt;)) (print "foo bar!"))
#&lt;generic baz (1)&gt;
gosh&gt; (define-method baz ((x &lt;foo1&gt;) (y &lt;bar1&gt;)) (print "foo1 bar1!"))
#&lt;generic baz (2)&gt;
gosh&gt; (define x1 (make &lt;foo&gt;))
x1
gosh&gt; (define x2 (make &lt;foo1&gt;))
x2
gosh&gt; (define y1 (make &lt;bar&gt;))
y1
gosh&gt; (define y2 (make &lt;bar1&gt;))
y2
gosh&gt; (baz x1 y1)
foo bar!
#&lt;undef&gt;
gosh&gt; (baz x2 y2)
foo1 bar1!
#&lt;undef&gt;
gosh&gt; (baz x1 y2)
foo bar!
#&lt;undef&gt;
gosh&gt; (baz x2 y1)
foo bar!
#&lt;undef&gt;
</pre>
<p> 総称関数 baz に引数特定子が &lt;foo&gt; と &lt;bar&gt; のメソッド A と &lt;foo1&gt; と &lt;bar1&gt; のメソッド B を定義します。(baz x1 y1) の場合、x1 が &lt;foo&gt; のインスタンスで y1 が &lt;bar&gt; のインスタンスなのでメソッド A が呼び出されます。次は (baz x2 y2) ですが、x2 が &lt;foo1&gt; のインスタンスで y2 が &lt;bar1&gt; のインスタンスなのでメソッド B が呼び出されます。メソッドの選択は簡単なように思えますが、実際にはちょっと複雑な処理を行っています。
</p>
<p> 最初に、第 1 引数のインスタンス x2 に適用可能なメソッドを選びます。この場合、x2 のクラス &lt;foo1&gt; と引数特定子が一致するメソッド B のほかに、引数特定子が &lt;foo&gt; であるメソッド A も適用することができますね。&lt;foo1&gt; は &lt;foo&gt; のサブクラスなので、インスタンス x2 のデータ型は &lt;foo&gt; として扱うことができるからです。ただし、メソッドを選ぶ優先順位はサブクラス &lt;foo1&gt; のメソッド B の方が高くなります。メソッドはサブクラスからスーパークラスに向かって探索されるので、優先順位はサブクラスのメソッドの方が高くなるのです。
</p>
<p> 次に、第 2 引数のインスタンス y2 に適用可能なメソッドを選びます。この場合も、メソッド A と B を適用することができますが、第 1 引数と同じ理由でメソッド B の方が優先順位が高くなります。したがって、メソッド B が選択されます。このように、適用可能なメソッドが複数ある場合は、もっとも特定的なメソッド（引数特定子がサブクラスのメソッド）が選択されます。
</p>
<p> その次の (baz x1 y2) は簡単です。第 1 引数のインスタンス x1 に適用可能なメソッドは A しかありません。メソッド A は第 2 引数のインスタンス y2 にも適用できるので、メソッド A が選択されます。最後の (baz x2 y1) ですが、第 1 引数のインスタンス x2 に適用可能なメソッドは A と B の 2 つあります。次に第 2 引数のインスタンス y1 に適用可能なメソッドを選びますが、インスタンス y1 のクラスは &lt;bar&gt; なので、適用可能なメソッドは A しかありません。したがって、メソッド A が選択されます。
</p>

<p> このように、引数が複数ある場合は第 1 引数から順番に適用可能なメソッドを調べていきます。この例は単一継承なのでそれほど難しくありませんが、Gauche (CLOS) は多重継承をサポートしているので、メソッドの選択はもっと複雑になります。これは「多重継承」のところで詳しく説明しましょう。
</p>

<h4>●メソッドのオーバーライド</h4>
<p> では、継承したクラスのメソッドとは違う働きをさせたい場合はどうするのでしょうか。これはとても簡単で、同名のメソッドを定義することで、そのクラスのメソッドを設定することができます。この機能を「オーバーライド (over ride) 」といいます。
</p>
<p> メソッド仕組みから見た場合、オーバーライドは必然の動作です。選択されるメソッドはもっとも特定的なメソッド、つまり引数特定子がサブクラスのメソッドになるので、サブクラスにメソッドを定義すれば、スーパークラスのメソッドではなくサブクラスのメソッドが選択されるのです。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト 3 : メソッドのオーバーライド

(define-method add ((x &lt;bar&gt;))
  (+ (foo-a x) (foo-b x) (bar-c x) (bar-d x)))
</pre>
<pre>
gosh&gt; (define y (make &lt;bar&gt; :a 10 :b 20 :c 30 :d 40))
y
gosh&gt; (add y)
100
</pre>

<p> &lt;foo&gt; のメソッド add はスロット a, b の値を足し算しましたね。この状態で、メソッド add をクラス &lt;bar&gt; のインスタンス y に適用すると、スロット a, b を足した値を返します。ここで、&lt;bar&gt; のメソッド add を定義します。今度は、スロット a, b, c, d の値を足し算します。メソッド add をインスタンス y に適用すると、すべてのスロットの値を足した値 100 を返します。このように &lt;foo&gt; のメソッドではなく、サブクラス &lt;bar&gt; のメソッドが評価されました。
</p>

<p> ところで、スロット a, b の足し算は foo のメソッド add で定義されていました。このメソッドを呼び出すことができれば、わざわざメソッド foo-a, foo-b を呼び出す必要はありません。いいかえれば、スーパークラスのメソッドと同じプログラムを書かなくてもよいわけです。スーパークラスのメソッドを呼び出す機能は、オブジェクト指向言語では当然の機能といえるでしょう。
</p>

<p> Gauche の場合、スーパークラスのメソッドを呼び出すには next-method を使います。
</p>
<pre class="item">
next-method [引数 ...]
</pre>
<p> next-method はメソッドのように呼び出すことができます。引数が省略された場合、next-method には評価中のメソッドと同じ引数が与えられます。それでは、この関数を使ってクラス &lt;bar&gt; のメソッド add を書き直してみましょう。
</p>
<pre class="list">
リスト 4 : メソッドのオーバーライド (2)

(define-method add ((x &lt;bar&gt;))
  (+ (next-method) (bar-c x) (bar-d x)))
</pre>
<p> next-method により &lt;foo&gt; のメソッド add が呼び出されて、スロット a, b を足し算した値を返します。この例は簡単すぎるので、あまりメリットを感じないかもしれません。ところが、スーパークラスのメソッドが複雑な処理をしていて、サブクラスのメソッドでも同様の処理が必要な場合には、その力を十分に発揮してくれるでしょう。
</p>

<p> それでは、複数の引数特定子を持つメソッドの場合はどうなるのでしょうか。次の例を見てください。
</p>
<pre class="list">
リスト 5 : メソッドのオーバーライド (3)

; クラス定義
(define-class &lt;foo&gt; () ((a :accessor foo-a :init-value 1)))
(define-class &lt;bar&gt; () ((b :accessor bar-b :init-value 2)))
(define-class &lt;foo1&gt; (&lt;foo&gt;) ((c :accessor foo-c :init-value 3)))
(define-class &lt;bar1&gt; (&lt;bar&gt;) ((d :accessor bar-d :init-value 4)))

; メソッド A
(define-method baz ((x &lt;foo&gt;) y) (print "foo-other method"))

; メソッド B
(define-method baz ((x &lt;foo&gt;) (y &lt;bar&gt;))
  (next-method)
  (print "foo-bar method"))

; メソッド C
(define-method baz ((x &lt;foo1&gt;) (y &lt;bar1&gt;))
  (next-method)
  (print "foo1-bar1 method"))
</pre>
<pre>
gosh&gt; (define x1 (make &lt;foo&gt;))
x1
gosh&gt; (define x2 (make &lt;foo1&gt;))
x2
gosh&gt; (define y1 (make &lt;bar&gt;))
y1
gosh&gt; (define y2 (make &lt;bar1&gt;))
y2
gosh&gt; (baz x1 y1)
foo-other method
foo-bar method
#&lt;undef&gt;
gosh&gt; (baz x2 y2)
foo-other method
foo-bar method
foo1-bar1 method
#&lt;undef&gt;
</pre>
<p> 総称関数 baz には 3 つのメソッド A, B, C が定義されています。メソッド A の第 2 引数には引数特定子が指定されていないので、第 2 引数がどのデータでも適用することができます。最初の (baz x1 y1) の場合、適用可能なメソッドは A と B の 2 つがあります。メソッドの優先順位は引数特定子が指定されているメソッド B の方が高くなります。ここで、メソッドの優先順位をリスト (B A) と表すことにしましょう。
</p>
<p> 最初に、メソッド B が呼び出されます。次に、メソッド B は next-method を評価します。next-method は、実行しているメソッド B の次に優先順位が高いメソッドをリスト (B A) から探します。この場合、メソッド A が呼び出されます。したがって、実行結果は foo-other method と foo-bar method が表示されます。
</p>
<p> 次の (baz x2 y2) の場合、適用可能なメソッドは A, B, C の 3 つあり、優先順位は (C B A) になります。最初にメソッド C が呼び出され、next-method により次に優先順位が高いメソッド B が呼び出されます。そして、メソッド B の next-method によりメソッド A が呼び出されます。その結果、foo-other mthod, foo-bar method, foo1-bar1 method と表示されます。
</p>

<p> もしも、next-method で次に適用できるメソッドが見つからない場合はエラーになります。次の例を見てください。
</p>
<pre>
gosh&gt; (define-method baz1 ((x &lt;foo&gt;)) (next-method) (print "foo baz1"))
#&lt;generic baz1 (1)&gt;
gosh&gt; (baz1 x1)
*** ERROR: no applicable method for #&lt;generic baz1 (1)&gt; with arguments (#&lt;&lt;foo&gt; 0pba55a8&gt;)
</pre>
<p> 新しいメソッド baz1 を定義しました。次に (baz1 x1) を評価しますが、適用可能なメソッドはひとつしかありませんね。次に、そのメソッドで next-method が評価されますが、適用可能なメソッドはもうありません。したがって、next-method でエラーが発生するわけです。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj02.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>