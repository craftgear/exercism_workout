<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881789</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell07.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell09.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">モジュール</h3>
<p> プログラムを作っていると、以前作った関数と同じ処理が必要になる場合があります。いちばんてっとり早い方法はソースファイルからその関数をコピーすることですが、賢明な方法とはいえません。このような場合、自分で作成した関数をライブラリとしてまとめておくと便利です。
</p>

<p> ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、同じ名前の関数や変数が存在すると、そのライブラリは正常に動作しないでしょう。この問題は「モジュール (module) 」を使うと解決することができます。
</p>

<p> モジュールを簡単に説明すると、データ構造とそれを操作する関数を一つにまとめるための仕組みです。最近は、モジュールに相当する機能を持つプログラミング言語が多くなりました。Haskell にもモジュールがあるので、データ構造や関数をモジュールにまとめておけば、ユーザーにとって使いやすいライブラリを構築することができます。
</p>

<p> 実際、Haskell には多くのモジュールが標準で添付されています。これらのモジュールを使うことで、プログラムを効率的に開発することができます。
</p>

<h4>●モジュールの使い方</h3>
<p> Haskell の場合、モジュールは import 文を使って読み込みます。
</p>
<pre class="item">
import モジュール名
</pre>
<p> import 文で指定できるモジュールは一つだけです。複数のモジュールを読み込む場合は、モジュールの数だけ import 文を記述してください。
</p>
<p> ghci の場合、コマンド :m でモジュールを読み込むことができます。
</p>
<pre class="item">
:m + モジュール名 ...
</pre>
<p> :m コマンドは複数のモジュールを指定することができます。その場合はモジュール名を空白で区切ってください。
</p>
<p> 簡単な例を示します。
</p>
<pre>
Prelude&gt; :t union

&lt;interactive&gt;:1:1: Not in scope: `union'
Prelude&gt; :m + Data.List
Prelude Data.List> :t union
union :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]
Prelude Data.List> union [1,2,3,4] [3,4,5,6]
[1,2,3,4,5,6]
</pre>
<p> union は集合 (リスト) の和を求める関数で、モジュール Data.List に定義されています。Data.List をロードすると union を利用することができます。
</p>
<p> 必要な関数 (変数) だけインポートすることもできます。
</p>
<pre class="item">
import モジュール名 (名前, ...)
</pre>
<p> モジュール名の後ろのカッコの中にインポートする関数を指定します。逆に、インポートしたくない関数を指定することもできます。
</p>
<pre class="item">
import モジュール名 hiding (名前, ...)
</pre>
<p> hiding を付けると、指定された関数はインポートされません。それ以外の関数はすべてインポートされます。
</p>
<p> 複数のモジュールをインポートすると、名前が重複する場合があります。名前の重複を避けるため、Haskell には別名を付ける方法が用意されています。
</p>
<pre class="item">
import qualified モジュール名
</pre>
<p> qualified を指定すると、"モジュール名" + "." + "名前" でアクセスすることができます。これを「修飾付きインポート」といいます。このとき、モジュール名が長いとプログラムを書くのが面倒になるので、次のように別名を指定することができます。
</p>
<pre class="item">
import qualified モジュール名 as 別名
</pre>
<p> as の後ろに名前 (別名) を指定します。これで "別名" + "." + "名前" でアクセスすることができます。
</p>

<h4>●モジュールの作り方</h4>
<p> モジュールは module を使って定義します。
</p>
<pre class="item">
module モジュール名 (名前, ...) where
</pre>
<p> 通常はファイルの先頭に module を記述します。たとえば、モジュール名を Foo とすると、ファイル名はモジュール名と同じ名前 Foo.hs としなければなりません。モジュール名の後のカッコの中にはエクスポート (export) する名前 (関数名、変数名、型構築子、データ構築子など) を記述します。省略した場合はモジュールで定義されたすべての名前がエクスポートされます。そして、where 以降にモジュールに格納するデータ構造や関数を定義します。where はレイアウトが使えますが、モジュールの場合はインデントしないで行頭からプログラムを書くのが一般的なようです。
</p>

<p> import でインポートされる名前は、module でエクスポートされている名前だけです。エクスポートされていない名前はインポートすることができません。モジュール内だけで使用する関数は、エクスポートしなければ「非公開」となります。同様に、データ構築子をエクスポートしないと、データを生成したりパターンマッチングでデータを取り出すことができなくなります。この場合、公開されている関数だけを使ってデータ構造にアクセスすることになります。
</p>

<p> 簡単な例を示しましょう。
</p>

<pre class="list">
リスト : Fruit.hs

module Fruit (Fruit(..), getPrice) where

data Fruit = Apple | Grape | Orange deriving (Show, Eq)

priceList :: [(Fruit, Integer)]
priceList = [(Apple, 100), (Grape, 150), (Orange, 200)]

getPrice :: Fruit -&gt; Maybe Integer
getPrice x = lookup x priceList


リスト : fruit1.hs

import Fruit

sumPrice :: [Fruit] -&gt; Integer
sumPrice xs = foldl (\a x -&gt; let (Just v) = getPrice x in a + v) 0 xs
</pre>
<p> モジュール Fruit にはデータ型 Fruit の定義と果物の値段が記述されています。型構築子とデータ構築子は次のようにエクスポートします。
</p>
<pre class="item">
1. 型構築子(データ構築子, ...)
2. 型構築子(..)
</pre>
<p> 型構築子の後ろのカッコの中にデータ構築子を指定します。データ構築子が複数ある場合はカンマで区切ります。2 番目のようにカッコの中で記号 .. を指定すると、型構築子で定義されているデータ構築子がすべてエクスポートされます。priceList は果物の値段を表す連想リストです。getPrice は priceList から果物の値段を求める関数です。priceList はエクスポートされていないので、果物の値段は getPrice を使って求めることになります。
</p>
<p> fruit1.hs では、モジュール Fruit をインポートして、関数 sumPrice を定義しています。sumPrice は getPrice を使ってリストに格納された果物の合計値を求める関数です。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
Prelude&gt; :l fruit1
[1 of 2] Compiling Fruit            ( Fruit.hs, interpreted )
[2 of 2] Compiling Main             ( fruit1.hs, interpreted )
Ok, modules loaded: Fruit, Main.
*Main&gt; priceList

&lt;interactive&gt;:3:1: Not in scope: `priceList'
*Main&gt; :t Apple
Apple :: Fruit
*Main&gt; getPrices Apple
Just 100
*Main&gt; sumPrice [Apple, Grape, Grape, Orange, Orange, Orange]
1000
</pre>
<p> priceList はアクセスできませんが、getPrice で Apple の値段を求めることができます。最後に、sumPrice で合計値を求めています、
</p>

<h4>●スタックとは？</h4>
<p> 次は簡単なデータ構造の例題として「スタック (stack) 」と「キュー (queue) 」を取り上げます。最初にスタックの動作を説明します。次の図を見てください。
</p>

<pre class="fig">
    |-----|     |[ A ]|     |[ B ]|     |[ A ]|     |-----|
    |  |  |     |-----|     |[ A ]|     |-----|     |  |  |
    |  |  |     |  |  |     |-----|     |  |  |     |  |  |
    |  |  |     |  |  |     |  |  |     |  |  |     |  |  |
    |  |  |     |  |  |     |  |  |     |  |  |     |  |  |
    +-----+     +-----+     +-----+     +-----+     +-----+
 (1) 空の状態 (2) PUSH A  (3) PUSH B  (4) POP B   (5) POP A  

                    図 : スタックの動作例
</pre>

<p> 上図は、バネがついた容器を表していて、上から品物を出し入れすることができます。初めは空の状態です。ここに品物を乗せると、重さによってバネを圧縮し、品物が容器に格納されます。さらにもう一つ品物を上に乗せると、さらにバネを圧縮し、その品物も容器に格納することができます。バネが限界まで圧縮されると、もう品物は追加できなくなります。取り出す場合は、上にある品物から行います。一つ取り出すと、その分バネが伸びて下にある品物が上に押し出されます。
</p>

<p> この容器の動作が、スタックの動作なのです。スタックにデータを追加する操作をプッシュ (PUSH) といい、スタックからデータを取り出す操作をポップ (POP) といいます。品物をデータに見立てれば、データ A をスタックにプッシュし (2)、次にデータ B をプッシュします (3)。データを取り出す場合、あとから入れたデータ B が先にポップされ (4)、その次にデータ A がポップされてスタックが空になります (5)。このように、スタックはあとから入れたデータが先に取り出されるので、後入れ先出し (LIFO : Last-In, First-Out) と呼ばれます。
</p>

<h4>●スタックの実装</h4>
<p> Haskell の場合、スタックはリストを使って簡単に実現することができます。データを追加するときはリストの先頭に追加し、データを取り出すときはリストの先頭から行うように操作を限定すると、それはスタックの動作と同じになります。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : スタック

module Stack (
  Stack,
  emptyStack,
  singleton,
  push,
  pop,
  top,
  isEmptyStack
) where

-- スタックの定義
data Stack a = S [a] deriving Show

-- 空のスタック
emptyStack :: Stack a
emptyStack = S []

-- 要素が一つのスタックを作る
singleton :: a -&gt; Stack a
singleton x = S [x]

-- データの追加
push :: Stack a -&gt; a -&gt; Stack a
push (S xs) x = S (x:xs)

-- データの削除
pop :: Stack a -&gt; (a, Stack a)
pop (S []) = error "Empty Stack"
pop (S (x:xs)) = (x, S xs)

-- データの取得
top :: Stack a -&gt; a
top (S []) = error "Empty Stack"
top (S (x:_)) = x

-- スタックは空か
isEmptyStack :: Stack a -&gt; Bool
isEmptyStack (S []) = True
isEmptyStack (S _)  = False
</pre>
<p> 最初に data 宣言でスタック Stack a を定義します。スタックの本体はリストです。新しいスタックを生成するため、空のスタックを変数 emptyStack にセットします。関数 shigleton は引数 x を格納したスタックを返します。
</p>
<p> スタックの操作関数は簡単です。push はデータをリストの先頭に追加します。pop はリストの先頭要素とそれを取り除いたスタックを返します。データの取得は関数 top で行います。スタックが空の場合、pop と top を適用することができないので、error でエラーを送出します。関数 isEmptyStack はスタックが空かチェックする述語です。
</p>
<p> Haskell は純粋な関数型言語なので、スタックを破壊的に書き換えることはできません。push と pop は新しいスタックを返すことに注意してください。
</p>

<p> 簡単な使用例を示します。モジュール Stack.hs は ghci のコマンド :m でロードできなかったので、コマンド :l で Stack.hs を読み込んでいます。
</p>
<pre>
Prelude&gt; :l Stack
[1 of 1] Compiling Stack            ( Stack.hs, interpreted )
Ok, modules loaded: Stack.
*Stack&gt; let a = push emptyStack 1
*Stack&gt; :t a
a :: Stack Integer
*Stack&gt; a
S [1]
*Stack&gt; singleton 1
S [1]
*Stack&gt; let b = push a 2
*Stack&gt; b
S [2,1]
*Stack&gt; let c = push b 3
*Stack&gt; c
S [3,2,1]
*Stack&gt; top c
3
*Stack&gt; let (x, d) = pop c
*Stack&gt; x
3
*Stack&gt; d
S [2,1]
*Stack&gt; let e = foldl push emptyStack [1..10]
*Stack&gt; e
S [10,9,8,7,6,5,4,3,2,1]
*Stack&gt; isEmptyStack emptyStack
True
*Stack&gt; isEmptyStack d
False
</pre>
<p> 正常に動作していますね。純粋な関数型言語の場合、変数の値を書き換えることができないので、push や pop の返り値を別の変数に格納する必要があります。ご注意くださいませ。
</p>

<h4>●キューとは？</h4>
<p> 次はキューについて説明します。キューは「待ち行列」といわれるデータ構造です。たとえばチケットを買う場合、窓口に長い列ができますが、それと同じだと考えてください。チケットを買うときは、列の途中に割り込むことはできませんね。いちばん後ろに並んで順番を待たなければいけません。列の先頭まで進むと、チケットを購入することができます。
</p>
<p> このように、要素を取り出す場合は列の先頭から行い、要素を追加する場合は列の後ろに行うデータ構造がキューなのです。キューは「先入れ先出し (FIFO : first-in, first-out) 」とも呼ばれます。
</p>

<pre class="fig">
                  先頭                      最後尾
                    ---------------------------
                 &lt;=  1  2  3  4  5  .  .  .  n  &lt;= 
                    ---------------------------

            先頭                                          最後尾
 変数      ┌─┬─┐    ┌─┬─┐    ┌─┬─┐        ┌─┬─┐
 queue ─→│・│・┼─→│・│・┼─→│・│・┼・・・→│・│／│  
           └┼┴─┘    └┼┴─┘    └┼┴─┘        └┼┴─┘
             ↓            ↓            ↓                ↓
             １            ２            ３                ｎ

                        図 : キューの構造
</pre>

<p> キューにデータを入れることを enqueue といい、キューからデータを取り出すことを dequeue といいます。リストを使ってキューを実装する場合、上図のようにキューの先頭とリストの先頭を対応させます。すると、キューからデータを取り出すには、リストの先頭からデータを取り出すだけですみます。これはとても簡単ですね。
</p>
<p> ただし、キューにデータを入れるには、リストの最後尾にデータを追加することになるため、ちょっとした工夫が必要になります。たとえば、データの追加に演算子 ++ を使うと、データを追加するたびにリスト（キュー）がコピーされてしまいます。このため、キューに格納されているデータが多くなると時間がかかるようになります。
</p>
<p> これを回避する方法はいろいろ考えられるのですが、今回は SML/NJ や OCaml などの関数型言語で使われている方法を紹介します。次の図を見てください。
</p>

<pre class="fig">
            先頭                        
 変数      ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 front ─→│０│・┼─→│１│・┼─→│２│／│  
           └─┴─┘    └─┴─┘    └─┴─┘
           最後尾                  
           ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 rear  ─→│５│・┼─→│４│・┼─→│３│／│  
           └─┴─┘    └─┴─┘    └─┴─┘

        図 : キューの構造（改良版）
</pre>

<p> 上図は 2 つのリストでキューを表しています。データを取り出すときは front のリストを、データを追加するときは rear のリストを使います。front と rear で一つのキューを構成し、rear のリストはデータを逆順で格納することになります。ようするに、front が先頭で rear が最後尾になるわけです。上図のキューを一つのリストで表すと [0, 1, 2, 3, 4, 5] になります。
</p>
<p> したがって、front が空リストでも rear にデータがあれば、キューは空ではありません。rear のリストを逆順にして front にセットし、rear を空リストにします。これで front からデータを取り出すことができます。キューが空の状態は front と rear が両方とも空リストの場合です。
</p>

<h4>●キューの実装</h4>
<p> それではプログラムを作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : キューの実装

module Queue (
  Queue,
  emptyQueue,
  singleton,
  enqueue,
  dequeue,
  front,
  isEmptyQueue
) where

-- キューの定義
data Queue a = Q [a] [a] deriving Show

-- 空のキュー
emptyQueue :: Queue a
emptyQueue = Q [] []

-- 要素が一つのキューを返す
singleton :: a -> Queue a
singleton x = Q [x] []

-- データの追加
enqueue :: Queue a -&gt; a -&gt; Queue a
enqueue (Q front rear) x = Q front (x:rear)

-- データの取り出し
dequeue :: Queue a -&gt; (a, Queue a)
dequeue (Q [] []) = error "Empty Queue"
dequeue (Q [] rear) = dequeue (Q (reverse rear) [])
dequeue (Q (x:xs) rear) = (x, Q xs rear)

-- 先頭データの参照
front :: Queue a -&gt; a
front (Q [] []) = error "Empty Queue"
front (Q [] rear) = front (Q (reverse rear) [])
front (Q (x:_) _) = x

-- キューは空か
isEmptyQueue :: Queue a -&gt; Bool
isEmptyQueue (Q [] []) = True
isEmptyQueue (Q _  _)  = False
</pre>
<p> まず data 宣言でデータ型 Queue a を定義します。データ構築子は Q [a] [a] で、第 1 要素が front で第 2 要素が rear になります。emptyQueue は空のキュー (Q [ ] [ ]) を表す変数です。関数 singleton は引数 x を格納したキューを返します。
</p>

<p> 関数 equeue はキューにデータ x を追加します。これは x を rear の先頭に追加するだけです。関数 dequeue はキューからデータを取り除きます。キューが空の場合は error でエラーを送出します。front が空リストの場合は、新しいキュー Q (reverse rear) [ ] を作って dequeue を再帰呼び出しします。front にデータがある場合は先頭要素を取り除くだけです。関数 front はキューの先頭要素を返します。処理は dequeue とほとんど同じで、違いは front の先頭データ x を返すだけです。関数 isEmptyQueue は、キューが空であれば True を、そうでなければ False を返します。
</p>

<p> それでは簡単な実行例を示します。
</p>
<pre>
Prelude&gt; :l Queue
[1 of 1] Compiling Queue            ( Queue.hs, interpreted )
Ok, modules loaded: Queue.
*Queue&gt; let a = enqueue emptyQueue 1
*Queue&gt; a
Q [] [1]
*Queue&gt; :t a
a :: Queue Integer
*Queue&gt; singleton 1
Q [1] []
*Queue&gt; let b = enqueue a 2
*Queue&gt; b
Q [] [2,1]
*Queue&gt; let c = enqueue b 3
*Queue&gt; c
Q [] [3,2,1]
*Queue&gt; front c
1
*Queue&gt; let (x, d) = dequeue c
*Queue&gt; x
1
*Queue&gt; d
Q [2,3] []
*Queue&gt; let (y, e) = dequeue d
*Queue&gt; y
2
*Queue&gt; e
Q [3] []
*Queue&gt; let (z, f) = dequeue e
*Queue&gt; z
3
*Queue&gt; f
Q [] []
*Queue&gt; isEmptyQueue f
True
*Queue&gt; isEmptyQueue e
False
*Queue&gt; let g = foldl enqueue emptyQueue [1..10]
*Queue&gt; g
Q [] [10,9,8,7,6,5,4,3,2,1]
*Queue&gt; dequeue g
(1,Q [2,3,4,5,6,7,8,9,10] [])
</pre>
<p> 正常に動作していますね。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">パズルの解法 (2)</h3>
<h4>●小町算</h4>
<p> パズルの世界では、1 から 9 までの数字を 1 個ずつすべて使った数字を「小町数」といいます。たとえば、123456789 とか 321654987 のような数字です。「小町算」というものもあり、たとえば 123 + 456 + 789 とか 321 * 654 + 987 のようなものです。
</p>
<div class="question">
<b>[問題]</b> 小町算
<p>1 から 9 までの数字を順番に並べ、間に + と - を補って三桁の値 (100 - 999) になる式を作ることにします。なお、1 の前に - 符号は付けないものとします。100 になる式の一例を示します。
</p>
<p> 例：1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
</p>
<p> 100 になる式は全部で 11 通りあります。それでは問題です。
</p>
<ol>
  <li>式の総数が最大になる値をすべて求めてください。
  <li>解のない値で最小のものを求めてください。
  <li>解のある値で最大のものを求めてください。
</ol>
</div>
<p> Haskell で解法プログラムを作ってください。
</p>

<h4>●プログラムの作成</h4>
<p> 今回のパズルは、演算子が + と - しかないので、数字の間に演算子を挿入して式を計算する処理は簡単にプログラムできます。ちょっと面倒なのが数字を連結する処理です。そこで、数字を連結する処理、数字の間に演算子を挿入する処理、式を計算する処理に分けてプログラムを作っていくことにします。
</p>

<h4>●数字の連結</h4>
<p> 最初に数字を連結する処理を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : 数字の連結

concat_number :: [Int] -&gt; [[Int]]
concat_number [] = [[]]
concat_number [x] = [[x]]
concat_number (x:y:zs) =
  map (x:) (concat_number (y:zs)) ++ concat_number ((x * 10 + y):zs)
</pre>
<p> 関数 concat_number は数字を格納したリストを受け取り、隣り合う数字を連結してできるパターンをすべて求めてリストに格納して返します。引数が空リストの場合は [[ ]] を返します。引数が [x] の場合は [[x]] を返します。これが再帰呼び出しの停止条件になります。
</p>
<p> 要素が 2 つ以上ある場合はリストを x : y : zs に分解して、x と y を連結しないパターンと、x と y を連結するパターンに分けて処理します。x と y を連結しない場合は x をそのまま使うことになります。リスト y : zs に concat_number を適用して、数字を連結したリストを求め、その先頭に x を追加します。この処理は map を使うと簡単ですね。x と y を連結する場合は、x * 10 + y を zs の先頭に追加し、そのリストに concat_number を適用します。あとは 2 つのリストを演算子 ++ で連結するだけです。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; concat_number [1,2]
[[1,2],[12]]
*Main&gt; concat_number [1,2,3]
[[1,2,3],[1,23],[12,3],[123]]
*Main&gt; concat_number [1,2,3,4]
[[1,2,3,4],[1,2,34],[1,23,4],[1,234],[12,3,4],[12,34],[123,4],[1234]]
*Main&gt; concat_number [1,2,3,4,5]
[[1,2,3,4,5],[1,2,3,45],[1,2,34,5],[1,2,345],[1,23,4,5],[1,23,45],[1,234,5],
[1,2345],[12,3,4,5],[12,3,45],[12,34,5],[12,345],[123,4,5],[123,45],[1234,5],
[12345]]
</pre>
<h4>●演算子の挿入</h4>
<p> 次は演算子 +, - を挿入して式を生成する処理を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : 式の生成

-- 式の定義
data Expr = Val Int | Add | Sub deriving (Eq, Show)

-- 式の生成
make_expr :: [Int] -&gt; [[Expr]]
make_expr [x] = [[Val x]]
make_expr (x:xs) = map (\zs -&gt; (Val x):Add:zs) ys1 
                ++ map (\zs -&gt; (Val x):Sub:zs) ys1
  where ys1 = make_expr xs
</pre>

<p> Expr で数値と演算子を定義します。Val が数値、Add が + で Sub が - です。関数 make_expr は数字を格納したリストを受け取り、数字の間に演算子を挿入するパターンをすべて求めてリストに格納して返します。
</p>
<p> プログラムは簡単です。引数が [x] であれば、[[Val x]] を返します。そうでなければ、引数を x : xs で分解して、xs に make_expr を適用して数式を生成します。そして、その数式の先頭に map で (Val x):Add と (Val x):Sub を追加します。この処理は map を使うと簡単ですね。あとは 2 つのリストを連結するだけです。
</p>
<p> それでは簡単な実行例を示します。
</p>

<pre>
*Main&gt; concatMap make_expr $ concat_number [1,2]
[[Val 1,Add,Val 2],[Val 1,Sub,Val 2],[Val 12]]
*Main&gt; concatMap make_expr $ concat_number [1,2,3]
[[Val 1,Add,Val 2,Add,Val 3],
 [Val 1,Add,Val 2,Sub,Val 3],
 [Val 1,Sub,Val 2,Add,Val 3],
 [Val 1,Sub,Val 2,Sub,Val 3],
 [Val 1,Add,Val 23],
 [Val 1,Sub,Val 23],
 [Val 12,Add,Val 3],
 [Val 12,Sub,Val 3],
 [Val 123]]
</pre>
<h4>●式の計算</h4>
<p> 次は式を計算する処理を作ります。
</p>
<pre class="list">
リスト : 式の計算

calc_expr :: [Expr] -&gt; Int
calc_expr ((Val x):xs) = iter xs x where
  iter [] a = a
  iter (Add:(Val x):xs) a = iter xs (a + x)
  iter (Sub:(Val x):xs) a = iter xs (a - x)
</pre>
<p> 関数 calc_expr はリストの先頭 (左側) から順番に計算していくだけです。とくに難しいところはないと思います。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; map calc_expr $ concatMap make_expr $ concat_number [1,2]
[3,-1,12]
*Main&gt; map calc_expr $ concatMap make_expr $ concat_number [1,2,3]
[6,0,2,-4,24,-22,15,9,123]
*Main&gt; map calc_expr $ concatMap make_expr $ concat_number [1,2,3,4]
[10,2,4,-4,6,-2,0,-8,37,-31,33,-35,28,20,-18,-26,235,-233,19,11,13,5,46,-22,127,119,1234]
</pre>

<h4>●実行結果</h4>
<p> あとは filter で指定した値になる式を取り出すだけです。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 小町算の解法

komachi :: [Int] -&gt; Int -&gt; [[Expr]]
komachi xs n =
  filter (\expr -&gt; calc_expr expr == n) $ concatMap make_expr $ concat_number xs
</pre>
<p> 実行結果を示します。
</p>
<pre>
*Main&gt; komachi [1..9] 100
[[Val 1,Add,Val 2,Add,Val 3,Sub,Val 4,Add,Val 5,Add,Val 6,Add,Val 78,Add,Val 9],
 [Val 1,Add,Val 2,Add,Val 34,Sub,Val 5,Add,Val 67,Sub,Val 8,Add,Val 9],
 [Val 1,Add,Val 23,Sub,Val 4,Add,Val 5,Add,Val 6,Add,Val 78,Sub,Val 9],
 [Val 1,Add,Val 23,Sub,Val 4,Add,Val 56,Add,Val 7,Add,Val 8,Add,Val 9],
 [Val 12,Add,Val 3,Add,Val 4,Add,Val 5,Sub,Val 6,Sub,Val 7,Add,Val 89],
 [Val 12,Sub,Val 3,Sub,Val 4,Add,Val 5,Sub,Val 6,Add,Val 7,Add,Val 89],
 [Val 12,Add,Val 3,Sub,Val 4,Add,Val 5,Add,Val 67,Add,Val 8,Add,Val 9],
 [Val 123,Sub,Val 4,Sub,Val 5,Sub,Val 6,Sub,Val 7,Add,Val 8,Sub,Val 9],
 [Val 123,Add,Val 4,Sub,Val 5,Add,Val 67,Sub,Val 89],
 [Val 123,Add,Val 45,Sub,Val 67,Add,Val 8,Sub,Val 9],
 [Val 123,Sub,Val 45,Sub,Val 67,Add,Val 89]]
</pre>
<p> これではよくわからないので、式を文字列に変換する関数 toStr を作ります。
</p>
<pre class="list">
リスt :  式を文字列に変換

toStr :: Int -&gt; [Expr] -&gt; [Char]
toStr n []     = "=" ++ show n
toStr n (x:xs) =
  case x of
    Add   -&gt; "+"
    Sub   -&gt; "-"
    Val x -&gt; show x
  ++ toStr n xs
</pre>
<p> プログラムは簡単なので説明は割愛します。実行結果を示します。
</p>
<pre>
*Main&gt; map (toStr 100) $ komachi [1..9] 100
["1+2+3-4+5+6+78+9=100",
 "1+2+34-5+67-8+9=100",
 "1+23-4+5+6+78-9=100",
 "1+23-4+56+7+8+9=100",
 "12+3+4+5-6-7+89=100",
 "12-3-4+5-6+7+89=100",
 "12+3-4+5+67+8+9=100",
 "123-4-5-6-7+8-9=100",
 "123+4-5+67-89=100",
 "123+45-67+8-9=100",
 "123-45-67+89=100"]
</pre>
<p> ここまでプログラムを作ると、問題を解くのは簡単です。最初の問題は次のようになります。
</p>
<pre>
*Main&gt; let a = map (komachi [1..9]) [100..999]
*Main&gt; let b = map length a
*Main&gt; maximum b
15
*Main&gt; :m +Data.List
*Main Data.List&gt; map (+100) $ elemIndices 15 b
[108,117,126]
</pre>
<p> 3 桁の整数の中で、式の総数の最大値は 15 になり、その値は 108, 117, 126 の 3 通りになります。たとえば、108 になる式は次のようになります。
</p>
<pre>
*Main Data.List&gt; map (toStr 108) (a !! 8)
["1+2+3+4+5+6+78+9=108",
 "1+2-3+45-6+78-9=108",
 "1+2+34-5-6-7+89=108",
 "1+2+34+5+67+8-9=108",
 "1-2-34+56+78+9=108",
 "1+23+4+5+6+78-9=108",
 "1+23-4-5+6+78+9=108",
 "1+23+4+56+7+8+9=108",
 "12+3-4-5+6+7+89=108",
 "12-3+4+5-6+7+89=108",
 "12+3+4+5+67+8+9=108",
 "12+34+56+7+8-9=108",
 "123+4-5-6-7+8-9=108",
 "123-4+5-6+7-8-9=108",
 "123-45+6+7+8+9=108"]
</pre>
<p> 解のない最小値は次のように求めることができます。
</p>
<pre>
*Main Data.List&gt; head $ map (+100) $ findIndices (==0) b
160
*Main Data.List&gt; a !! 60
[]
</pre>
<p> 解が存在する最大値は次のようになります。
</p>
<pre>
*Main Data.List&gt; last $ map (+100) $ findIndices (&gt;0) b
972
*Main Data.List&gt; map (toStr 972) $ a !! 872
["123+4+56+789=972"]
</pre>
<p> ちなみに、数字の並びを逆順 (9,8,7,6,5,4,3,2,1) にした場合も簡単に答えを求めることができます。
</p>
<pre>
*Main Data.List&gt; let c = map (komachi [9,8..1]) [100..999]
*Main Data.List&gt; let d = map length c
*Main Data.List&gt; maximum d
19
*Main Data.List&gt; map (+100) $ elemIndices 19 d
[102]
*Main Data.List&gt; map (toStr 102) (c !! 2)
["9+8+7+6+54-3+21=102",
 "9+8-7+65-4+32-1=102",
 "9-8+7+65-4+32+1=102",
 "9+8+76+5+4+3-2-1=102",
 "9+8+76+5+4-3+2+1=102",
 "9+8+76-5-4-3+21=102",
 "9-8+76+5-4+3+21=102",
 "98+7+6-5-4+3-2-1=102",
 "98+7+6-5-4-3+2+1=102",
 "98+7-6+5+4-3-2-1=102",
 "98+7-6+5-4+3-2+1=102",
 "98+7-6-5+4+3+2-1=102",
 "98-7+6+5+4-3-2+1=102",
 "98-7+6+5-4+3+2-1=102",
 "98-7+6-5+4+3+2+1=102",
 "98+7+6+5+4+3-21=102",
 "98-7-6-5+4-3+21=102",
 "98-7-6-5+43-21=102",
 "98+76-54+3-21=102"]
*Main Data.List&gt; head $ map (+100) $ findIndices (==0) d
194
*Main Data.List&gt; (c !! 94)
[]
*Main Data.List&gt; last $ map (+100) $ findIndices (&gt;0) d
999
*Main Data.List&gt; map (toStr 999) (c !! 899)
["9+8+7+654+321=999"]
</pre>
<h4>●大町算</h4>
<p> パズルの世界では小町数に 0 を加えた数を「大町数」といいます。そして、0 から 9 までの 10 個の数字を 1 個ずつ使った計算を「大町算」といいます。ただし、0123456789 のように最上位の桁に 0 を入れることはできません。今回は大町数のパズルを生成検定法で解いてみましょう。それでは問題です。
</p>
<div class="question">
<b>[問題]</b> ３数で大町どうさま
<p>ある連続した３数 (n, n+1, n+2) を掛け合わせたら、大町数になったという。そのような３数をすべて見つけてほしい。もちろん、負の数は考えない。
</p>
<p> 出典：『Ｃマガ電脳クラブ』 Ｃマガジン 1998 年 2 月号（ソフトバンク）
</p>
</div>
<p> Ｃ言語でプログラムを作る場合、大町数は整数 (32 bit) の範囲を超えるためちょっとした工夫が必要になりますが、Haskell だと簡単にプログラムを作ることができます。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。最初に整数 n の範囲を絞り込みます。大町数の最大値は 9876543210 で最小値は 1023456789 ですから、n の値は次の範囲内になります。
</p>
<pre>
(**) :: Floating a =&gt; a -&gt; a -&gt; a

1023456789 ** (1 / 3) =&gt; 1007.758578449832
1006 * 1007 * 1008    =&gt; 1021146336 &lt; 1023456789

9876543210 ** (1 / 3) =&gt; 2145.5319657992272
2145 * 2146 * 2147    =&gt; 9883005990 &gt; 9876543210
</pre>
<p> x ** y は x の y 乗を返します。これらの計算結果から n は 1007 以上 2144 以下であることがわかります。n の範囲がぐっと狭くなりましたね。これならば、あとは単純に計算して大町数になるかチェックすればいいでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : パズル「３数で大町どうさま」の解法

import Data.List

splitDigit :: Integer -&gt; [Integer]
splitDigit 0 = []
splitDigit n = n `mod` 10 : splitDigit(n `div` 10)

check :: Integer -&gt; Bool
check n = length (nub (splitDigit (n * (n + 1) * (n + 2)))) == 10

answer :: Integer -&gt; String
answer n = show n ++ "*" ++ show n1 ++ "*" ++ show n2 ++ "=" ++ show n3
  where n1 = n + 1
        n2 = n + 2
        n3 = n * n1 * n2

oomachi_solver :: [String]
oomachi_solver = map answer $ filter check [1007 .. 2144]
</pre>
<p> 関数 splitDigit は整数を 1 桁ずつ数字に分解します。実行例を示します。
</p>
<pre>
*Main&gt; splitDigit 1234567890
[0,9,8,7,6,5,4,3,2,1]
</pre>
<p> 数字の並びは逆になりますが、これでも今回の問題を解くことができます。興味のある方は数字の並び方が逆にならないようにプログラムを修正してみてください。
</p>
<p> 関数 check は引数 n が大町数になっているかチェックします。n * (n + 1) * (n + 2) を計算して、その値を splitDigit で分割します。nub は重複要素を取り除く関数で、モジュール Data.List に定義されています。簡単な使用例を示します。
</p>
<pre>
*Main&gt; :t nub
nub :: Eq a =&gt; [a] -&gt; [a]
*Main&gt; nub [1,2,3,4,2,3,4,5,3,4,5,6]
[1,2,3,4,5,6]
</pre>
<p> 生成される値は 10 桁なので、重複要素を取り除いたリストの長さが 10 であれば、その値は「大町数」であることがわかります。あとは filter で大町数になる値だけ取り出して、関数 answer で文字列に変換します。
</p>
<h4>●実行結果</h4>
<p> これでプログラムは完成です。さっそく実行してみましょう。
</p>
<pre>
*Main&gt; oomachi_solver
["1267*1268*1269=2038719564","1332*1333*1334=2368591704"]
</pre>
<p> 2 通りの解を見つけることができました。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell07.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell09.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>