<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another SML/NJ Problems</title>
  <meta name="description" content="Standard ML of New Jersey,SML/NJ,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881760</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>Yet Another SML/NJ Problems</h2>
<div class="small">
[ <a href="yasmlp06.html">PrevPage</a> | <a href="index.html">SML/NJ</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h4>●問題111</h4>
<p> 2 つのリスト xs, ys を受け取って動作するマップ関数 map2 f xs ys と畳み込みを行う関数 foldl2 f a xs ys, foldr2 f a xs ys を定義してください。引数のリストの長さが異なる場合は、短いリストの長さに合わせてください。なお、SML/NJ のモジュール ListPair には同様の動作を行う関数 map, foldl, foldr が用意されています。
</p>
<pre class="item">
val map2 = fn : ('a * 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
val foldl2 = fn : ('a * 'b * 'c -&gt; 'c) -&gt; 'c -&gt; 'a list -&gt; 'b list -&gt; 'c
val foldr2 = fn : ('a * 'b * 'c -&gt; 'c) -&gt; 'c -&gt; 'a list -&gt; 'b list -&gt; 'c
</pre>
<pre>
- map2 (op +) [1,2,3,4] [10,100,1000,10000];
val it = [11,102,1003,10004] : int list
- map2 (op * ) [1,2,3] [10,100,1000,10000];
val it = [10,200,3000] : int list

- foldl2 (fn(x,y,a) =&gt; (x, y) :: a) [] [1,2,3,4] [10,11,12,13];
val it = [(4,13),(3,12),(2,11),(1,10)] : (int * int) list
- foldl2 (fn(x,y,a) =&gt; x * y + a) 0 [1,2,3,4] [10,11,12,13];
val it = 120 : int

- foldr2 (fn(x,y,a) =&gt; (x, y) :: a) [] [1,2,3,4] [10,11,12,13];
val it = [(1,10),(2,11),(3,12),(4,13)] : (int * int) list
- foldr2 (fn(x,y,a) =&gt; x * y + a) 0 [1,2,3,4] [10,11,12,13];
val it = 120 : int
</pre>
<p><a href="yasmlp07.html#ans111">解答</a>
</p>
<h4>●問題112</h4>
<p> <a href="yasmlp02.html#p37">関数 zip</a> でまとめたリストを元に戻す関数 unzip xs を定義してください。
</p>
<pre class="item">
val unzip = fn : ('a * 'b) list -&gt; 'a list * 'b list
</pre>
<pre>
- zip([1,2,3,4,5],[6,7,8,9,10]);
val it = [(1,6),(2,7),(3,8),(4,9),(5,10)] : (int * int) list
- unzip [(1,6),(2,7),(3,8),(4,9),(5,10)];
val it = ([1,2,3,4,5],[6,7,8,9,10]) : int list * int list
</pre>
<p><a href="yasmlp07.html#ans112">解答</a>
</p>
<h4>●問題113</h4>
<p> 3 つのリスト xs, ys, zs の要素 x, y, z を取り出し、タプル (x, y, z) にまとめてリストに格納して返す関数 zip3(xs, ys, zs) を定義してください。リストは短いほうに合わせるものとします。
</p>
<pre class="item">
val zip3 = fn : 'a list * 'b list * 'c list -&gt; ('a * 'b * 'c) list
</pre>
<pre>
- zip3([1,2,3],[4,5,6],[7,8,9]);
val it = [(1,4,7),(2,5,8),(3,6,9)] : (int * int * int) list
- zip3([1,2,3],[4,5,6],[7,8]);
val it = [(1,4,7),(2,5,8)] : (int * int * int) list
</pre>
<p><a href="yasmlp07.html#ans113">解答</a>
</p>
<h4>●問題114</h4>
<p> zip3 したリストを元に戻す関数 unzip3 xs を定義してください。
</p>
<pre class="item">
val unzip3 = fn : ('a * 'b * 'c) list -&gt; 'a list * 'b list * 'c list
</pre>
<pre>
- unzip3 [(1,2,3),(4,5,6),(7,8,9)];
val it = ([1,4,7],[2,5,8],[3,6,9]) : int list * int list * int list
</pre>
<p><a href="yasmlp07.html#ans114">解答</a>
</p>
<h4>●問題115</h4>
<p> 関数 takeWhile pred xs は述語 pred を満たす要素が続いている間、リスト xs の先頭から順番に要素を取り出します。関数 takeWhile を定義してください。
</p>
<pre class="item">
val takeWhile = fn : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
</pre>
<pre>
- fun even x = x mod 2 = 0;
val even = fn : int -&gt; bool
- fun odd x = x mod 2 = 1;
val odd = fn : int -&gt; bool
- takeWhile even [2,4,6,8,1,2,3,4,5];
val it = [2,4,6,8] : int list
- takeWhile odd [2,4,6,8,1,2,3,4,5];
val it = [] : int list
</pre>
<p><a href="yasmlp07.html#ans115">解答</a>
</p>
<h4>●問題116</h4>
<p> 関数 dropWhile pred xs は述語 pred を満たす要素が続いている間、リスト xs の先頭から順番に要素を取り除きます。関数 dropWhile を定義してください。
</p>
<pre class="item">
val dropWhile = fn : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
</pre>
<pre>
- dropWhile even [2,4,6,8,1,2,3,4,5];
val it = [1,2,3,4,5] : int list
- dropWhile odd [2,4,6,8,1,2,3,4,5];
val it = [2,4,6,8,1,2,3,4,5] : int list
</pre>
<p><a href="yasmlp07.html#ans116">解答</a>
</p>
<h4>●問題117</h4>
<p> 関数 span pred xs はタプル (takeWhile pred xs, dropWhile pred xs) を返します。takeWhile と dropWhile を使わないで関数 span を定義してください。
</p>
<pre class="item">
val span = fn : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
</pre>
<pre>
- span even [2,4,6,8,1,2,3,4,5];
val it = ([2,4,6,8],[1,2,3,4,5]) : int list * int list
- span odd [2,4,6,8,1,2,3,4,5];
val it = ([],[2,4,6,8,1,2,3,4,5]) : int list * int list
</pre>
<p><a href="yasmlp07.html#ans117">解答</a>
</p>
<h4>●問題118</h4>
<p> 関数 break pred xs は span とは逆の動作、つまり span (not o pred) xs と同じ動作をします。takeWhile, dropWhile, span を使わないで関数 break を定義してください。
</p>
<pre class="item">
val break = fn : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
</pre>
<pre>
- break even [2,4,6,8,1,2,3,4,5];
val it = ([],[2,4,6,8,1,2,3,4,5]) : int list * int list
- break odd [2,4,6,8,1,2,3,4,5];
val it = ([2,4,6,8],[1,2,3,4,5]) : int list * int list
</pre>
<p><a href="yasmlp07.html#ans118">解答</a>
</p>
<h4>●問題119</h4>
<p> 関数 scanl f a xs は畳み込みを行う関数 fold f a xs と同じ動作をしますが、計算途中の累積値をリストに格納して返すところが異なります。関数 scanl を定義してください。
</p>
<pre class="item">
val scanl = fn : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b list
</pre>
<pre>
- scanl (op +) 0 [1,2,3,4,5];
val it = [0,1,3,6,10,15] : int list
- scanl (op ::) [] [1,2,3,4,5];
val it = [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]] : int list list
</pre>
<p><a href="yasmlp07.html#ans119">解答</a>
</p>
<h4>●問題120</h4>
<p> 関数 scanr f a xs は畳み込みを行う関数 fold-right f a xs と同じ動作をしますが、計算途中の累積値をリストに格納して返すところが異なります。関数 scanr を定義してください。
</p>
<pre class="item">
val scanr = fn : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b list
</pre>
<pre>
- scanr (op +) 0 [1,2,3,4,5];
val it = [15,14,12,9,5,0] : int list
- scanr (op ::) [] [1,2,3,4,5];
val it = [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]] : int list list
</pre>
<p><a href="yasmlp07.html#ans120">解答</a>
</p>
<h4>●問題121</h4>
<p> 関数 mapAaccumL f a xs は map と foldl を合わせた関数で、畳み込みを行った結果と各要素に関数 f を適用した結果を格納したリストをタプルで返します。関数 f は累積値とリストの要素を受け取り、新しい累積値とリストに格納する値をタプルで返します。関数 mapAccumL を定義してください。
</p>
<pre class="item">
val mapAccumL = fn : ('a * 'b -&gt; 'a * 'c) -&gt; 'a -&gt; 'b list -&gt; 'a * 'c list
</pre>
<pre>
- mapAccumL (fn(a, x) =&gt; (x * 2 + a, x * 2)) 0 [1,2,3,4,5];
val it = (30,[2,4,6,8,10]) : int * int list
- mapAccumL (fn(a, x) =&gt; (x * 2 :: a, x * 2)) [] [1,2,3,4,5];
val it = ([10,8,6,4,2],[2,4,6,8,10]) : int list * int list
</pre>
<p><a href="yasmlp07.html#ans121">解答</a>
</p>
<h4>●問題122</h4>
<p> 関数 mapAccumR f a xs は map と foldr を合わせた関数で、畳み込みを行った結果と各要素に関数 f を適用した結果を格納したリストをタプルで返します。関数 f は累積値とリストの要素を受け取り、新しい累積値とリストに格納する値をタプルで返します。関数 mapAccumR を定義してください。
</p>
<pre class="item">
val mapAccumR = fn : ('a * 'b -&gt; 'a * 'c) -&gt; 'a -&gt; 'b list -&gt; 'a * 'c list
</pre>
<pre>
- mapAccumR (fn(a, x) =&gt; (x * 2 + a, x * 2)) 0 [1,2,3,4,5];
val it = (30,[2,4,6,8,10]) : int * int list
- mapAccumR (fn(a, x) =&gt; (x * 2 :: a, x * 2)) [] [1,2,3,4,5];
val it = ([2,4,6,8,10],[2,4,6,8,10]) : int list * int list
</pre>
<p><a href="yasmlp07.html#ans122">解答</a>
</p>
<h4>●問題123</h4>
<p> リスト xs の要素の間に x を挿入する関数 intersperse(x, xs) を定義してください。
</p>
<pre class="item">
val intersperse = fn : 'a * 'a list -&gt; 'a list
</pre>
<pre>
- intersperse(0, [1,2,3,4,5]);
val it = [1,0,2,0,3,0,4,0,5] : int list
- intersperse([0,0], [[1,2],[3,4],[5,6]]);
val it = [[1,2],[0,0],[3,4],[0,0],[5,6]] : int list list
</pre>
<p><a href="yasmlp07.html#ans123">解答</a>
</p>
<h4>●問題124</h4>
<p> リスト ys の要素の間にリスト xs を挿入して平坦化する関数 intercalate(xs, ys) を定義してください。この場合、ys の要素はリストでなければなりません。
</p>
<pre class="item">
val intercalate = fn : 'a list * 'a list list -&gt; 'a list
</pre>
<pre>
- intercalate([0,0], [[1,2],[3,4],[5,6]]);
val it = [1,2,0,0,3,4,0,0,5,6] : int list
- intercalate([0,0], [[1,2]]);
val it = [1,2] : int list
- intercalate([0,0], []);
val it = [] : int list
</pre>
<p><a href="yasmlp07.html#ans124">解答</a>
</p>
<h4>●問題125</h4>
<p> 畳み込みを行う関数 foldl, foldr はリストの要素に関数が適用されますが、リストそのものを関数に渡して畳み込みを行う方法も考えられます。リストの先頭から畳み込みを行う関数 pair_foldl と、末尾から畳み込みを行う関数 pair_foldr を定義してください。
</p>
<pre class="item">
val pair_foldl = fn : ('a list * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b
val pair_foldr = fn : ('a list * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b
</pre>
<pre>
- pair_foldl (fn(x, a) =&gt; x :: a) [] [1,2,3,4,5];
val it = [[5],[4,5],[3,4,5],[2,3,4,5],[1,2,3,4,5]] : int list list
- pair_foldr (fn(x, a) =&gt; x :: a) [] [1,2,3,4,5];
val it = [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]] : int list list

- fun sum xs = foldl (op +) 0 xs;
val sum = fn : int list -&gt; int
- pair_foldl (fn(x, a) =&gt; sum x :: a) [] [1,2,3,4,5];
val it = [5,9,12,14,15] : int list
- pair_foldr (fn(x, a) =&gt; sum x :: a) [] [1,2,3,4,5];
val it = [15,14,12,9,5] : int list
</pre>
<p><a href="yasmlp07.html#ans125">解答</a>
</p>
<h4>●問題126</h4>
<p> リスト xs の接頭辞をすべて求める関数 inits xs を定義してください。
</p>
<pre class="item">
val inits = fn : 'a list -&gt; 'a list list
</pre>
<pre>
- inits [1,2,3,4,5];
val it = [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]] : int list list
</pre>
<p><a href="yasmlp07.html#ans126">解答</a>
</p>
<h4>●問題127</h4>
<p> リスト xs の接尾辞をすべて求める関数 tails xs を定義してください。
</p>
<pre class="item">
val tails = fn : 'a list -&gt; 'a list list
</pre>
<pre>
- tails [1,2,3,4,5];
val it = [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]] : int list list
</pre>
<p><a href="yasmlp07.html#ans127">解答</a>
</p>
<h4>●問題128</h4>
<p> リスト xs の中で等しい要素を集めてグループに分ける関数 group_collection xs を定義してください。なお、等値関係は述語 = でチェックするものとします。
</p>
<pre class="item">
val group_collection = fn : ''a list -&gt; ''a list list
</pre>
<pre>
- group_collection [1,2,1,3,2,1,4,3,2,1,1,2,3,4,5];
val it = [[1,1,1,1,1],[2,2,2,2],[3,3,3],[4,4],[5]] : int list list
- group_collection [1,2,3,4,5];
val it = [[1],[2],[3],[4],[5]] : int list list
</pre>
<p><a href="yasmlp07.html#ans128">解答</a>
</p>
<h4>●問題129</h4>
<p> リスト xs に x を挿入するパターンをすべて求めてリストに格納して返す関数 interleave x xs を定義してください。
</p>
<pre class="item">
val interleave = fn : 'a -&gt; 'a list -&gt; 'a list list
</pre>
<pre>
- interleave 0 [1,2,3,4,5];
val it =
  [[0,1,2,3,4,5],[1,0,2,3,4,5],[1,2,0,3,4,5],[1,2,3,0,4,5],[1,2,3,4,0,5],
   [1,2,3,4,5,0]] : int list list
- interleave 0 [1];
val it = [[0,1],[1,0]] : int list list
- interleave 0 [];
val it = [[0]] : int list list
</pre>
<p><a href="yasmlp07.html#ans129">解答</a>
</p>
<h4>●問題130</h4>
<p> 関数 interleave を使ってリスト xs の順列を求める関数 permutations を定義してください。なお、順列はリストに格納して返すものとします。
</p>
<pre class="item">
val permutations = fn : 'a list -&gt; 'a list list
</pre>
<pre>
- permutations [1,2,3];
val it = [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]] : int list list
- permutations [#"a",#"b",#"c"];
val it =
  [[#"a",#"b",#"c"],[#"b",#"a",#"c"],[#"b",#"c",#"a"],[#"a",#"c",#"b"],
   [#"c",#"a",#"b"],[#"c",#"b",#"a"]] : char list list
</pre>
<p><a href="yasmlp07.html#ans130">解答</a>
</p>
<hr>
<h4 id="ans111">●解答111</h4>
<pre class="list">
リスト : マッピングと畳み込み

fun map2 _ [] _ = []
|   map2 _ _ [] = []
|   map2 f (x::xs) (y::ys) = f(x, y) :: map2 f xs ys

fun foldl2 _ a [] _ = a
|   foldl2 _ a _ [] = a
|   foldl2 f a (x::xs) (y::ys) = foldl2 f (f(x, y, a)) xs ys

fun foldr2 _ a [] _ = a
|   foldr2 _ a _ [] = a
|   foldr2 f a (x::xs) (y::ys) = f(x, y, foldr2 f a xs ys)

(* 別解 *)
fun zip([], _) = []
|   zip(_, []) = []
|   zip(x::xs, y::ys) = (x, y) :: zip(xs, ys)

fun map2a f xs ys = map f (zip(xs, ys))

fun foldl2a f a xs ys = foldl (fn((x,y),z) =&gt; f(x,y,z)) a (zip(xs, ys))

fun foldr2a f a xs ys = foldr (fn((x,y),z) =&gt; f(x,y,z)) a (zip(xs, ys))
</pre>
<p> マッピングと畳み込みは再帰呼び出しを使うと簡単です。どの関数も、xs または ys が空リストになったときが再帰の停止条件となります。別解は zip と map, foldl, foldr を組み合わせたものです。
</p>

<h4 id="ans112">●解答112</h4>
<pre class="list">
リスト : ひとつのリストを 2 つのリストに分ける

fun unzip([]) = ([], [])
|   unzip((x, y)::xs) =
    let
      val (a, b) = unzip(xs)
    in
      (x::a, y::b)
    end
</pre>
<p> unzip は再帰呼び出しでプログラムすると簡単です。引数が空リストの場合、2 つの空リストをタプルに格納して返します。そうでなければ、unzip を再帰呼び出しして、返り値 (タプル) を受け取ります。そして、受け取ったリストに要素を追加して、それをタプルに格納して返すだけです。
</p>

<h4 id="ans113">●解答113</h4>
<pre class="list">
リスト : 3 つのリストをひとつにまとめる

fun zip3([], _, _) = []
|   zip3(_, [], _) = []
|   zip3(_, _, []) = []
|   zip3(x::xs, y::ys, z::zs) = (x, y, z) :: zip3(xs, ys, zs)
</pre>

<p> zip3 も再帰呼び出しで簡単にプログラムできます。引数の中でどれかひとつが空リストであれば空リストを返します。あとは、zip3 を再帰呼び出しして、その返り値に各リストの先頭要素を格納したタプルを追加するだけです。
</p>

<h4 id="ans114">●解答114</h4>
<pre class="list">
リスト : ひとつのリストを 3 つのリストに分ける

fun unzip3([]) = ([], [], [])
|   unzip3((x,y,z)::xs) =
    let
      val (a, b, c) = unzip3(xs)
    in
      (x::a, y::b, z::c)
    end
</pre>
<p> unzip3 も簡単です。引数が空リストの場合、3 つの空リストを格納したタプルを返します。そうでなければ unzip3 を再帰呼び出しして、返り値と変数 (a, b, c) をパターンマッチします。あとは、タプルの要素 x, y, z をリスト a, b, c に追加し、それをタプルに格納して返せばいいわけです。
</p>

<h4 id="ans115">●解答115</h4>

<pre class="list">
リスト : pred が真の要素を取り出す

fun takeWhile _ [] = []
|   takeWhile p (x::xs) =
    if p x then x :: takeWhile p xs else []
</pre>
<p> takeWhile は xs が空リストまたは述語 pred が偽を返すとき空リストを返します。そうでなければ、takeWhile を再帰呼び出しして、その返り値にリストの要素を追加します。
</p>

<h4 id="ans116">●解答116</h4>

<pre class="list">
リスト : pred が真の要素を取り除く

fun dropWhile _ [] = []
|   dropWhile p (a as(x::xs)) =
    if p x then dropWhile p xs else a
</pre>
<p> dropWhile は簡単です。引数が空リストまたは述語 pred が偽を返すとき、空リストまたはリスト a を返します。そうでなければ、dropWhile を再帰呼び出しするだけです。
</p>

<h4 id="ans117">●解答117</h4>

<pre class="list">
リスト : pred が偽を返すところでリストを分ける

fun span _ [] = ([], [])
|   span p (y as (x::xs)) =
    if p x then
      let
        val (a, b) = span p xs
      in
        (x::a, b)
      end
    else ([], y)
</pre>
<p> span は再帰呼び出しでプログラムすると簡単です。引数が空リストまたは述語 pred が偽を返すときが再帰の停止条件です。そうでなければ、span を再帰呼び出しして返り値を変数 (a, b) にセットします。そして、リストの先頭要素 x を a に追加して、b といっしょにタプルに格納して返します。
</p>

<h4 id="ans118">●解答118</h4>

<pre class="list">
リスト : pred が真を返すところでリストを分ける

fun break _ [] = ([], [])
|   break p (y as (x::xs)) =
    if p x then ([], y)
    else
      let
        val (a, b) = break p xs
      in
        (x::a, b)
      end
</pre>
<p> break も再帰呼び出しでプログラムすると簡単です。引数が空リストまたは述語 pred が真を返すときが再帰の停止条件です。そうでなければ、break を再帰呼び出しして返り値を変数 (a, b) で受け取ります。そして、リストの先頭要素 x を a に追加して、b といっしょにタプルに格納して返します。
</p>

<h4 id="ans119">●解答119</h4>

<pre class="list">
リスト : 累積値リストの生成

fun scanl _ a [] = [a]
|   scanl f a (x::xs) = a :: scanl f (f(x, a)) xs

(* 別解 *)
fun scanl1 f a xs =
    rev (foldl (fn(x, a) =&gt; f(x, hd a) :: a) [a] xs)
</pre>
<p> scanl はリストの最後の要素が最終の累積値になります。引数のリストが空リストのとき、累積変数 a の値をリストに格納して返します。そうでなければ、scanl を再帰呼び出しして、その返り値に累積変数 a の値を追加して返します。scanl を再帰呼び出しするときは、関数 f を呼び出して累積変数の値を更新することに注意してください。別解は fold を使ったバージョンです。返り値のリストは逆順になるので、関数 rev で反転しています。
</p>
<h4 id="ans120">●解答120</h4>

<pre class="list">
リスト : 累積値リストの生成

fun scanr _ a [] = [a]
|   scanr f a (x::xs) =
    let
      val ys as (y::_) = scanr f a xs
    in
      f(x, y) :: ys
    end

(* 別解 *)
fun scanr1 f a xs = foldr (fn(x, a) =&gt; f(x, hd a) :: a) [a] xs
</pre>
<p> scanr はリストの先頭の要素が最終の累積値、最後の要素が初期値になります。引数のリストが空リストの場合は [a] を返します。そうでなければ、scanr を再帰呼び出しします。このとき、累積変数 a の値は更新しません。返り値のリストは変数 ys にセットします。この ys の先頭要素が一つ前の累積値になるので、この値 y とリストの先頭要素 x を関数 f に渡して評価します。あとは、f の返り値を ys の先頭に追加して返せばいいわけです。別解は foldr を使ったバージョンです。
</p>
<h4 id="ans121">●解答121</h4>

<pre class="list">
リスト : マッピングと畳み込み

fun mapAccumL _ acc [] = (acc, [])
|   mapAccumL f acc (x::xs) =
    let
      val (a, y) = f(acc, x)
      val (b, ys) = mapAccumL f a xs
    in
      (b, y::ys)
    end
</pre>
<p> mapAccumL は foldl と map を組み合わせたものです。累積値はリストの先頭から計算し、マッピングの結果は末尾から組み立てていきます。引数 acc は初期値とともに計算途中の累積値を表します。引数のリストが空リストの場合、acc と空リストをタプルで返します。そうでなければ、関数 f に累積値 acc と要素 x を渡して評価し、新しい累積値とマッピングの値を変数 a と y にセットします。
</p>
<p> それから、mapAccumL を再帰呼び出しします。このとき、累積値は a になることに注意してください。返り値は畳み込みの値 b とマッピングの結果を格納したリスト ys です。あとは、ys に y を追加して b と一緒にタプルで返すだけです。
</p>

<h4 id="ans122">●解答122</h4>

<pre class="list">
リスト : マッピングと畳み込み

fun mapAccumR _ acc [] = (acc, [])
|   mapAccumR f acc (x::xs) =
    let
      val (a, ys) = mapAccumR f acc xs
      val (b, y)  = f(a, x)
    in
      (b, y::ys)
    end
</pre>
<p> mapAccumR の場合、累積値はリストの末尾から計算し、マッピングの結果も末尾から組み立てていきます。引数のリストが空リストの場合、初期値 acc と空リストをタプルで返します。そうでなければ mapAccumR を再帰呼び出しします。初期値 acc をそのまま渡すことに注意してください。累積値が変数 a に、マッピングの値を格納したリストが変数 ys にセットされます。
</p>
<p> 次に関数 f を呼び出します。このとき、累積値 a とリストの要素 x を渡します。結果は、新しい累積値が b に、マッピングの値が y にセットされます。あとは、y を ys に追加して累積値 b と一緒にタプルで返すだけです。
</p>

<h4 id="ans123">●解答123</h4>

<pre class="list">
リスト : 要素の間にデータを挿入する

fun intersperse(_, []) = []
|   intersperse(_, [x]) = [x]
|   intersperse(x, y::ys) = y :: x :: intersperse(x, ys)

(* 別解 *)
fun intersperse1(_, []) = []
|   intersperse1(x, y::ys) =
    y :: foldr (fn(z, a) =&gt; x :: z :: a) [] ys
</pre>
<p> intersperse は再帰呼び出しで簡単にプログラムできます。引数のリストが空リストまたは要素がひとつしかない場合、データを挿入できないのでリストをそのまま返します。そうでなければ、先頭の要素と次の要素の間に x を挿入します。 y :: x :: のあとに残りのリスト ys に対して intersperse を再帰呼び出しすればいいわけです。別解は畳み込み foldr を使ったバージョンです。
</p>
<h4 id="ans124">●解答124</h4>

<pre class="list">
リスト : リストの要素の間にデータを挿入して平坦化する

(* リストの平坦化 *)
fun flatten [] = []
|   flatten (x::xs) = x @ flatten xs

fun intercalate(xs, ys) = flatten (intersperse(xs, ys))

(* 別解 *)
fun intercalate1(_, []) = []
|   intercalate1(x, y::ys) =
    y @ foldr (fn(z, a) =&gt; x @ z @ a) [] ys
</pre>
<p> intercalate は intersperse を呼び出して xs を ys の要素の間に挿入し、その結果を関数 flatten で平坦化するだけです。別解は intersperses を使わずに foldr でプログラムしたものです。intersperses と違って、演算子 @ でリストを連結していることに注意してください。これでリストを平坦化することができます。
</p>

<h4 id="ans125">●解答125</h4>

<pre class="list">
リスト : 畳み込み

fun pair_foldl _ a [] = a
|   pair_foldl f a xs = pair_foldl f (f(xs, a)) (tl xs)

fun pair_foldr _ a [] = a
|   pair_foldr f a xs = f(xs, pair_foldr f a (tl xs))
</pre>
<p> pair_foldl と pair_foldr は簡単です。関数 f を呼び出すときリストの要素の代わりにリスト xs をそのまま渡すだけです。あとは普通の畳み込み foldl, foldr と同じです。
</p>

<h4 id="ans126">●解答126</h4>

<pre class="list">
リスト : 接頭辞を求める

fun inits xs = scanl (fn(x, a) =&gt; a @ [x]) [] xs

(* 別解 *)
fun inits1 xs = foldl (fn(x, a) =&gt; ((hd a) @ [x]) :: a) [[]] xs
</pre>
<p> inits は scanl を使うと簡単です。累積値 a の末尾に x を追加していくだけです。別解は foldl を使ったバージョンです。
</p>

<h4 id="ans127">●解答127</h4>

<pre class="list">
リスト : 接尾辞を求める

fun tails xs = scanr (op ::) [] xs

(* 別解 *)
fun tails1 xs = pair_foldr (op ::) [[]] xs
</pre>
<p> inits は scanr を使うと簡単です。累積値の先頭に xs の要素を追加するだけです。別解のように pair_foldr を使っても簡単にプログラムできます。
</p>
<h4 id="ans128">●解答128</h4>

<pre class="list">
リスト : 等値 (eqv?) でグループに分ける

fun group_insert(x, []) = [[x]]
|   group_insert(x, y::ys) =
    if x = (hd y) then (x::y)::ys else y :: group_insert(x, ys)

fun group_collection xs = foldl group_insert [] xs
</pre>
<p> group_collection は x をグループに挿入する関数 group_insert(x, ys) を定義すると簡単です。group_insert の引数 ys はグループ (リスト) を格納したリストです。ys が空リストの場合、x と等しい値を持つグループはなかったので新しいグループを生成して返します。グループの先頭要素 (hd y) と x が等しい場合、そのグループに x を追加して返します。そうでなければ、group_insert を再帰呼び出しして次のグループをチェックします。
</p>
<p> group_collection は引数 xs の要素を順番に取り出し、group_insert で該当するグループに挿入していくだけです。この処理は foldl を使うと簡単にできます。
</p>

<h4 id="ans129">●解答129</h4>

<pre class="list">
リスト : データをひとつ挿入するパターンをすべて求める

fun interleave x [] = [[x]]
|   interleave x (xs as (y::ys)) =
    [x::xs] @ map (fn(zs) =&gt; y :: zs) (interleave x ys)

(* 別解 *)
fun interleave1 x xs =
    let
      fun iter([], ys, a) = revAppend(ys, [x]) :: a
      |   iter(zs as x1::xs1, ys, a) =
          iter(xs1, x1::ys, revAppend(ys, x::zs) :: a)
    in
      iter(xs, [], [])
    end
</pre>
<p> interleave はリストの先頭に x を挿入する場合と、それ以外の場合に分けて考えます。先頭に追加するのは簡単ですね。それ以外の場合は、先頭要素を取り除いたリスト ys に x を挿入すればいいので、interleave を再帰呼び出しすることで求めることができます。そして、その返り値のリストに先頭要素 y を追加すればいいわけです。
</p>
<p> プログラムは簡単です。引数のリストが空リストの場合は [[x]] を返します。そうでなければ、xs の先頭に x を追加したものと、interleave x ys の返り値に y を追加したものを演算子 @ で連結して返します。
</p>

<p> 別解はリストの先頭から順番に x の挿入位置を変えていきます。x よりも前にある要素を変数 ys に格納しておくと、x を挿入したリストは、ys @ [x] @ zs で求めることができます。interleave1 の場合、ys は逆順になるので、リストの連結処理を関数 revAppend で行っています。
</p>

<h4 id="ans130">●解答130</h4>

<pre class="list">
リスト : 順列の生成

fun flatmap _ [] = []
|   flatmap f (x::xs) = f x @ flatmap f xs

fun permutations [] = [[]]
|   permutations (x::xs) =
    flatmap (interleave x) (permutations xs)
</pre>
<p> permutations は簡単です。permutations を再帰呼び出しして xs の順列を求め、順列を表す要素に interleave で x を挿入すればいいわけです。リストを平坦化するため flatmap を使っていることに注意してください。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2012 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="yasmlp06.html">PrevPage</a> | <a href="index.html">SML/NJ</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>