<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881790</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell13.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell15.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">Applicative</h3>
<p> 今回は Functor の強化版である「Applicative (アプリカティブ) 」について説明します。
</p>

<h4>●Applicative とは？</h4>
<p> Applicative は Functor と同様に型クラスのひとつで、モジュール Control.Applicative に定義されています。Applicative の定義をコマンド :info で調べると、次のように表示されます。
</p>
<pre>
Prelude&gt; :m Control.Applicative
Prelude Control.Applicative&gt; :i Applicative
class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
  (*&gt;) :: f a -&gt; f b -&gt; f b
  (&lt;*) :: f a -&gt; f b -&gt; f a
        -- Defined in `Control.Applicative'
instance Applicative [] -- Defined in `Control.Applicative'
instance Applicative ZipList -- Defined in `Control.Applicative'
instance Monad m =&gt; Applicative (WrappedMonad m)
  -- Defined in `Control.Applicative'
instance Applicative Maybe -- Defined in `Control.Applicative'
instance Applicative IO -- Defined in `Control.Applicative'
instance Applicative (Either e) -- Defined in `Control.Applicative'
instance Applicative ((-&gt;) a) -- Defined in `Control.Applicative'
</pre>
<p> ここで、関数 pure と演算子 &lt;*&gt; に注目してください。この 2 つが Applicative の主な機能です。f は型クラス制約で Functor を指定されているので、Functor と同様に型変数をひとつ取る型構築子になります。関数 pure の型は a -&gt; f a なので、任意のデータを f の中に格納して返す働きをします。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude Control.Applicative&gt; pure 1 :: Maybe Int
Just 1
Prelude Control.Applicative&gt; pure 1 :: [Int]
[1]
Prelude Control.Applicative&gt; pure 1 :: Either a Int
Right 1
</pre>
<p> pure の働きは「引数を文脈に入れて返す」と考えることができます。このことを「値を持ち上げる」といいます。引数が 1 とすると、文脈が Maybe であれば Just 1 に、リストであれば [1] に、Either であれば Right 1 になります。
</p>
<p> &lt;*&gt; の型は fmap とよく似ていますが、最初の関数が f に格納されているところが異なります。つまり、f に格納されている関数を取り出し、それを f に格納されているデータに適用し、その結果を f に格納して返す、という働きをします。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; Just 10
Just 20
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; Nothing
Nothing
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; [1,2,3,4,5]
[2,4,6,8,10]
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; []
[]
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; Right 10
Right 20
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; Left "error"
Left "error"
Prelude Control.Applicative&gt; pure reverse &lt;*&gt; getLine
hello, world
"dlrow ,olleh"
</pre>
<p> pure で関数を持ち上げます。このとき、右辺のデータ型が Maybe であれば関数は Just に格納され、リストであれば関数はリストに、Either であれば関数は Right に格納されます。あとは、fmap と同様に文脈を保ったまま関数を値に適用します。
</p>
<p> ところで、リストには複数の関数を格納することができます。この場合、動作は次のようになります。
</p>
<pre>
Prelude Control.Applicative&gt; [(+3),(*2)] &lt;*&gt; [1,2,3,4,5]
[4,5,6,7,8,2,4,6,8,10]
</pre>
<p> (+3) を適用して得られたリストと (*2) を適用して得られたリストを連結したものになります。
</p>
<h4>●&lt;*&gt; を複数回使用する</h4>
<p> Applicative も関数の部分適用が可能です。たとえば、関数 a -&gt; b -&gt; c は a -&gt; (b -&gt; c) のことなので、これを演算子 &lt;*&gt; に適用すると型は次のようになります。
</p>
<pre class="item">
(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
pure (a -&gt; b -&gt; c) &lt;*&gt; =&gt; f (a -&gt; (b -&gt; c)) -&gt; f a -&gt; f (b -&gt; c)
</pre>
<p> ここで、返り値の型は f (b -&gt; c) になることに注目してください。これは演算子 &lt;*&gt; に適用できる型ですね。つまり、Applicative でカリー化関数を評価する場合、次のように引数を &lt;*&gt; でつなげて渡すことができます。
</p>
<pre class="item">
pure func &lt;*&gt; 引数1 &lt;*&gt; 引数2 &lt;*&gt; ... &lt;*&gt; 引数N
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude Control.Applicative&gt; pure (*) &lt;*&gt; Just 2 &lt;*&gt; Just 10
Just 20
Prelude Control.Applicative&gt; pure (+) &lt;*&gt; Right 2 &lt;*&gt; Right 10
Right 12
Prelude Control.Applicative&gt; pure (,) &lt;*&gt; [1,2,3] &lt;*&gt; [4,5,6]
[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
</pre>
<p> リストの動作はリスト内包表記で表すと [(x, y) | x &lt;- [1,2,3], y &lt;- [4,5,6]] と同じ <sup><a href="haskell14.html#note1">[*1]</a></sup> になります。ただし、Applicative ではリスト内包表記の条件節を実現することはできません。(,) はタプルのデータ構築子です。タプルは最大で 62 個の要素を格納できます。データ構築子は (,) だけではなく、(,,) や (,,,) など最大で 61 個のカンマ ( , ) を並べたデータ構築子が用意されています。
</p>
<p> 簡単な例を示します。
</p>
<pre>
Prelude Control.Applicative&gt; :t (,)
(,) :: a -&gt; b -&gt; (a, b)
Prelude Control.Applicative&gt; :t (,,)
(,,) :: a -&gt; b -&gt; c -&gt; (a, b, c)
Prelude Control.Applicative&gt; :t (,,,)
(,,,) :: a -&gt; b -&gt; c -&gt; d -&gt; (a, b, c, d)
Prelude Control.Applicative&gt; (,) 1 2
(1,2)
Prelude Control.Applicative&gt; (,,) 1 2 3
(1,2,3)
Prelude Control.Applicative&gt; (,,,) 1 2 3 4
(1,2,3,4)

Prelude Control.Applicative&gt; pure (,,) &lt;*&gt; [1,2] &lt;*&gt; [3,4] &lt;*&gt; [5,6]
[(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
Prelude Control.Applicative&gt; pure (,,,) &lt;*&gt; [1,2] &lt;*&gt; [3,4] &lt;*&gt; [5,6] &lt;*&gt; [7,8]
[(1,3,5,7),(1,3,5,8),(1,3,6,7),(1,3,6,8),(1,4,5,7),(1,4,5,8),(1,4,6,7),(1,4,6,8)
,(2,3,5,7),(2,3,5,8),(2,3,6,7),(2,3,6,8),(2,4,5,7),(2,4,5,8),(2,4,6,7),(2,4,6,8)
]
</pre>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> リスト内包表記は「リストモナド」の構文糖衣です。モナドの演算子 &gt;&gt;= を使うと次のようになります。
<pre>
Prelude&gt; [1,2,3] &gt;&gt;= \x -&gt; [4,5,6] &gt;&gt;= \y -&gt; return (x, y)
[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
</pre>
</div>
<h4>●&lt;$&gt; と &lt;*&gt; の組み合わせ</h4>
<p> pure ではなく Functor の fmap を使って関数を持ち上げることもできます。モジュール Control.Applicative には fmap の別名として &lt;$&gt; が定義されています。簡単な実行例を示します。
</p>
<pre>
Prelude Control.Applicative&gt; :t (&lt;$&gt;)
(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
Prelude Control.Applicative&gt; (*) &lt;$&gt; Just 2 &lt;*&gt; Just 10
Just 20
Prelude Control.Applicative&gt; (*) &lt;$&gt; Just 2 &lt;*&gt; Nothing
Nothing
Prelude Control.Applicative&gt; (*) &lt;$&gt; [2] &lt;*&gt; [1,2,3,4,5]
[2,4,6,8,10]
Prelude Control.Applicative&gt; (*) &lt;$&gt; Right 2 &lt;*&gt; Right 10
Right 20
Prelude Control.Applicative&gt; (*) &lt;$&gt; Right 2 &lt;*&gt; Left "error"
Left "error"
Prelude Control.Applicative&gt; (,) &lt;$&gt; [1,2,3] &lt;*&gt; ['a', 'b', 'c']
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
</pre>
<p> Functor の演算子 &lt;$&gt; により関数が持ち上げられて f (a -&gt; b) のデータ型が生成され、それが Applicative の演算子 &lt;*&gt; に渡されます。そして、その中て文脈を保ちながら関数 (a -&gt; b) が評価されます。
</p>

<h4>●ZipList</h4>
<p> ところで、Applicative におけるリストの動作はリスト内包表記と同じですが、関数 zipWith のように動作してほしい場合もあります。zipWith の動作を示します。
</p>
<pre>
Prelude&gt; :t zipWith
zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
Prelude&gt; :t zipWith3
zipWith3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]

Prelude&gt; zipWith (,) "abc" [1,2,3]
[('a',1),('b',2),('c',3)]
Prelude&gt; zipWith3 (,,) "abc" [1,2,3] "def"
[('a',1,'d'),('b',2,'e'),('c',3,'f')]
</pre>
<p> Applicative でも同様の動作を行うため、Control.Applicative には ZipList というデータ型が定義されています。コマンド :info で ZipList を調べてみましょう。
</p>
<pre>
Prelude Control.Applicative&gt; :i ZipList
newtype ZipList a = ZipList {getZipList :: [a]}
        -- Defined in `Control.Applicative'
instance Functor ZipList -- Defined in `Control.Applicative'
instance Applicative ZipList -- Defined in `Control.Applicative'
</pre>
<p> ZipList はリストを格納しているだけです。リストは Applicative のインスタンスになっています。それとは異なる動作をさせるため、ZipList という新しいデータ型を定義して Applicative のインスタンスに設定します。newtype はあとで説明します。なお、ZipList は Show のインスタンスではないので、インタプリタ ghci で表示する場合は関数 getZipList を使って ZipList からリストを取り出してください。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude Control.Applicative&gt; getZipList $ ZipList [1,2,3,4]
[1,2,3,4]
Prelude Control.Applicative&gt; getZipList $ (,) &lt;$&gt; ZipList "abc" &lt;*&gt; ZipList [1,2,3]
[('a',1),('b',2),('c',3)]
Prelude Control.Applicative&gt; getZipList $ (,,) &lt;$&gt; ZipList "abc" &lt;*&gt; ZipList [1,2,3] &lt;*&gt; ZipList "def"
[('a',1,'d'),('b',2,'e'),('c',3,'f')]
</pre>
<p> 関数を ZipList に格納して、演算子 &lt;*&gt; で評価することもできます。
</p>
<pre>
Prelude Control.Applicative&gt; getZipList $ ZipList [(*2), (+10)] &lt;*&gt; ZipList [1,2]
[2,12]
Prelude Control.Applicative&gt; getZipList $ ZipList [(*), (+)] &lt;*&gt; ZipList [1,2] &lt;*&gt; ZipList [3,4]
[3,6]
</pre>
<p> 最初の例では 1 * 2 と 2 + 10 が評価されて [2, 12] になります。次の例では 1 * 3 と 2 + 4 が評価されて [3, 6] になります。
</p>

<h4>●newtype</h4>
<p> newtype は data 宣言のように新しいデータ型を定義することができます。たとえば、ZipList を data 宣言で書き直して比較してみましょう。
</p>
<pre class="item">
newtype ZipList a = ZipList [a]
newtype ZipList a = ZipLIst {getZipList :: [a]}

data ZipList a = ZipList [a]
data ZipList a = ZipList {getZipList :: [a]}
</pre>
<p> data が newtype に変わっただけで、あとは同じですね。実際、data 宣言で ZipList を定義しても問題なく動作します。ただし、data 宣言を使って定義すると、Haskell が ZipList にリストを格納する処理や ZipList からリストを取り出す処理を行うことになります。これは当然のことですが、今回のようにリストとは異なるデータ型だけが必要な場合、Haskell が ZipList をリストと同じように操作できると効率的です。
</p>
<p> newtype はこのようなときのために用意された機能です。このため、newtype ではデータ構築子は一つだけしか定義できず、そのデータ構築子の型式も一つだけしか持つことができません。そのかわり、newtype で定義された新しいデータ型は、元のデータ型と同じように一手間かけず効率的に処理することができます。
</p>

<h4>●自分で Applicative を定義する</h4>
<p> それではここで Applicative の理解を深めるため、私たちで Applicative を定義してみましょう。型クラスの名前は Mapplicative とします。Mapplicative の定義は次のようになります。
</p>

<pre class="list">
リスト : Mapplicative の定義

class Mfunctor f =&gt; Mapplicative f where
  pure  :: a -&gt; f a
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p> Mapplicative は型クラスの名前が異なるだけで、pure と &lt;*&gt; の定義は Applicative と同じです。
</p>
<p> 次は Maybe、Either, IO, リスト を Mapplicative のインスタンスに設定します。次のリストを見てください。
</p>
<pre class="list">
リスト : インスタンスの設定

-- Maybe
instance Mapplicative Maybe where
  pure x = Just x
  Nothing &lt;*&gt; _ = Nothing
  (Just f) &lt;*&gt; x = f &lt;$&gt; x

-- Either
instance Mapplicative (Either a) where
  pure x = Right x
  (Left x) &lt;*&gt; _ = Left x
  (Right f) &lt;*&gt; x = f &lt;$&gt; x

-- IO
instance Mapplicative IO where
  pure x = return x
  action1 &lt;*&gt; action2 = do
    f &lt;- action1
    x &lt;- action2
    return (f x)

-- リスト
instance Mapplicative [] where
  pure x = [x]
  fs &lt;*&gt; xs = concatMap (&lt;$&gt; xs) fs
</pre>
<p> どのデータ型でも pure の定義は簡単ですね。Maybe であれば Just x、Either であれば Right x、IO であれば return x、リストであれば [x] を返します。&lt;*&gt; の定義も簡単です。Maybe は左辺が Nothing であれば Nothing を返します。そうでなければ、左辺 Just f から関数 f を取り出して f &lt;$&gt; x を評価します。f は Mfunctor なので、演算子 &lt;$&gt; を使用することができます。Either の場合も同じです。
</p>

<p> IO の場合は左辺の I/O アクション action1 から関数 f を取り出し、右辺の I/O アクション action2 から引数 x を取り出します。あとは return (f x) を返すだけです。リストの場合はちょっと複雑です。左辺 fs に格納されている関数を取り出して、右辺のリスト xs に適用し、その結果を連結しないといけません。この処理は関数 concatMap を使うとうまくいきます。
</p>

<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; pure (*2) &lt;*&gt; Just 10
Just 20
*Main&gt; pure (*2) &lt;*&gt; Nothing
Nothing
*Main&gt; Nothing &lt;*&gt; Just 10
Nothing
*Main&gt; pure (*2) &lt;*&gt; Right 10
Right 20
*Main&gt; pure (*2) &lt;*&gt; Left "error"
Left "error"
*Main&gt; Left "error" &lt;*&gt; Right 10
Left "error"
*Main&gt; [(+3), (*2)] &lt;*&gt; [1,2,3,4,5]
[4,5,6,7,8,2,4,6,8,10]
*Main&gt; [(+3), (*2)] &lt;*&gt; []
[]
*Main&gt; [] &lt;*&gt; [1,2,3,4,5]
[]
*Main&gt; pure reverse &lt;*&gt; getLine
hello, world
"dlrow ,olleh"
</pre>
<p> もちろん、前回作成した型クラス Mfunctor の演算子 &lt;$&gt; と組み合わせることもできます。
</p>
<pre>
*Main&gt; (*) &lt;$&gt; Just 2 &lt;*&gt; Just 10
Just 20
*Main&gt; (+) &lt;$&gt; Right 2 &lt;*&gt; Right 10
Right 12
*Main&gt; (^) &lt;$&gt; [2,3] &lt;*&gt; [1..5]
[2,4,8,16,32,3,9,27,81,243]
*Main&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine
hello,
world
"hello,world"
</pre>
<h4>●関数も Applicative になる</h4>
<p> Functor で説明したように -&gt; は中置演算子で、関数の型は (-&gt;) r a と書くこともできます。(-&gt;) r を型コンストラクタと考えると、関数の Applicative の定義を導くことができます。
</p>
<pre class="item">
&lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b
=&gt; ((-&gt;) r (a -&gt; b)) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)
=&gt; (r -&gt; a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)
</pre>
<p> f &lt;*&gt; g は関数 f :: r -&gt; a -&gt; b と g :: r -&gt; a を受け取って、関数 r -&gt; b を返します。f は r と a から b を求めます。引数 a は関数 g から求めることができるので、&lt;*&gt; が返す関数をラムダ式で書くと \r -&gt; f r (g r) と表すことができます。
</p>
<p> このあと、さらに &lt;*&gt; をつなげて関数を合成することができます。f &lt;*&gt; g で生成される関数の型は r -&gt; b なので、最初に与えた引数 r が次の関数にも伝播していくことに注意してください。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : インスタンスの設定 (2)

instance Mapplicative ((-&gt;) r) where
  pure x = \_ -&gt; x
  f &lt;*&gt; g = \x -&gt; f x (g x)
</pre>
<p> pure はラムダ式 (クロージャ) に x を格納して返します。&lt;*&gt; は定義どおりにプログラムしただけです。そうはいっても、これだけでは何ができるのかよくわかりませんね。具体的な例を示しましょう。
</p>
<pre>
*Main&gt; :t pure (+)
pure (+) :: (Num a, Mapplicative f) =&gt; f (a -&gt; a -&gt; a)
*Main&gt; :t pure (+) &lt;*&gt; (+10)
pure (+) &lt;*&gt; (+10) :: Num a =&gt; a -&gt; a -&gt; a
*Main&gt; (pure (+) &lt;*&gt; (+10)) 1 2
13
*Main&gt; (pure (+) &lt;*&gt; (*10)) 1 2
12
</pre>
<p> pure (+) &lt;*&gt; (+10) は 2 つの数値を引数に取る関数になります。その動作は 1 を (+10) に適用して、その結果と 2 を足し算する、つまり 2 + (1+10) = 13 となります。(*10) の場合は 2 + (1*10) = 12 になります。
</p>
<pre>
*Main&gt; :t pure (+) &lt;*&gt; (+10) &lt;*&gt; (*10)
pure (+) &lt;*&gt; (+10) &lt;*&gt; (*10) :: Num b =&gt; b -&gt; b
*Main&gt; :t pure (+) &lt;*&gt; (+10) &lt;*&gt; (*10) $ 10
pure (+) &lt;*&gt; (+10) &lt;*&gt; (*10) $ 10 :: Num b =&gt; b
*Main&gt; pure (+) &lt;*&gt; (+10) &lt;*&gt; (*10) $ 10
120
</pre>
<p> 次に、&lt;*&gt; (*10) を追加しましょう。すると、合成された関数は引数が 1 つの関数になります。その動作は引数 10 を (+10) と (*10) に適用して、その結果を足し算する、つまり (10 + 10) + (10 * 10) = 120 になります。
</p>
<p> pure のかわりに &lt;$&gt; を使っても同じように動作します。
</p>
<pre>
*Main&gt; (+) &lt;$&gt; (+10) &lt;*&gt; (*10) $ 10
120
</pre>
<h4>●ZipList の定義</h4>
<p> もちろん、ZipList も定義することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : ZipList の定義

newtype ZipList a = ZipList {getZipList :: [a]}

instance Mfunctor ZipList where
  f &lt;$&gt; (ZipList xs) = ZipList (map f xs)

instance Mapplicative ZipList where
  pure x = ZipList (repeat x)
  ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith id fs xs)
</pre>
<p> プログラムは Haskell のモジュール Data.Applicative とほとんど同じです。Functor の演算子 &lt;$&gt; の定義は簡単ですね。Applicative の演算子 &lt;*&gt; は zipWith を使うと簡単です。id には fs の要素 fi と xs の要素 xi が次のように渡されます。
</p>
<pre class="item">
id f x =&gt; (id fi) xi =&gt; fi xi
</pre>
<p> つまり、xs の要素 xi に fs の要素 (関数) fi を適用していくことになります。関数 pure はちょっと変わっていますね。repeat x は x の無限リストを生成する関数です。ここで、リスト [x] を返すと、各リストの先頭要素だけに x を適用することになるので、長さが 1 のリストしか生成されません。リストの各要素に関数 x を適用するため、repeat で無限リストを生成しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; getZipList $ pure (*) &lt;*&gt; ZipList [1..5] &lt;*&gt; ZipList [11..15]
[11,24,39,56,75]
*Main&gt; getZipList $ (*) &lt;$&gt; ZipList [1..5] &lt;*&gt; ZipList [11..15]
[11,24,39,56,75]
*Main&gt; getZipList $ ZipList [(+1), (+2), (+3)] &lt;*&gt; ZipList [10,11,12]
[11,13,15]
*Main&gt; getZipList $ (,,) &lt;$&gt; ZipList [1..5] &lt;*&gt; ZipList [11..15] &lt;*&gt; ZipList "abcde"
[(1,11,'a'),(2,12,'b'),(3,13,'c'),(4,14,'d'),(5,15,'e')]
</pre>
<h4>●liftA2</h4>
<p> pure や &lt;*&gt; のほかにも、モジュール Control.Applicative には便利な関数 liftA2 が用意されています。関数 liftA2 を Mapplicative で定義すると次のようになります。
</p>
<pre class="list">
リスト : liftA2

liftA2 :: Mapplicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b
</pre>
<p> プログラムは簡単ですね。実行例を示します。
</p>
<pre>
*Main&gt; liftA2 (+) (Just 1) (Just 2)
Just 3
*Main&gt; liftA2 (:) (Just 1) (Just [2])
Just [1,2]
*Main&gt; liftA2 (+) [1,2,3,4] [5,6,7,8]
[6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
</pre>

<p> また、<a href="haskell09.html">簡単な入出力</a> で説明した関数 sequence のような関数を作ることもできます。名前は <a href="haskell.html#cite">参考文献 1</a> と同じく sequenceA としました。
</p>

<pre class="list">
リスト : sequenceA

sequenceA :: Mapplicative f =&gt; [f a] -&gt; f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs

-- 別解
sequenceA :: Mapplicative f =&gt; [f a] -&gt; f [a]
sequenceA = foldr (liftA2(:)) (pure [])
</pre>
<p> sequenceA の型を見ればおわかりのように、リストに格納されている f a から a を取り出して、それをリストに格納した [a] を作り、それを f に格納して返します。プログラムは簡単にみえますが、Functor と Applicative が働いていることに注意してください。&lt;$&gt; で x からデータを取り出し、それを sequeceA の返り値のリストに追加します。また、別解のように foldr と liftA2 を組み合わせてプログラムすることもできます。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; sequenceA [Just 1, Just 2, Just 3]
Just [1,2,3]
*Main&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
Nothing
*Main&gt; sequenceA [Right 1, Right 2, Right 3]
Right [1,2,3]
*Main&gt; sequenceA [Right 1, Right 2, Left "error", Right 3]
Left "error"
*Main&gt; sequenceA (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]
</pre>
<p> I/O アクションも Mapplicative なので、sequenceA を使うとリストに格納された I/O アクションを実行することができます。
</p>
<p> リストの場合、動作がもっと複雑になります。次の例を見てください。
</p>
<pre>
*Main&gt; sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
</pre>
<p> これは次のように動作します。
</p>
<pre>
*Main&gt; (:) &lt;$&gt; [3,4] &lt;*&gt; [[]]
[[3],[4]]
*Main&gt; (:) &lt;$&gt; [1,2] &lt;*&gt; [[3],[4]]
[[1,3],[1,4],[2,3],[2,4]]
</pre>
<p> リストの場合、pure [ ] は [[ ]] のことなので、3 : [ ], 4 : [ ] が評価されて、それがリストに格納されます。次に、1 と [3], [4] が結合され、2 と [3], [4] が結合され、それらがリストに格納されるので、返り値は [[1,3],[1,4],[2,3],[2,4]] になります。
</p>

<p> sequenceA はリストに格納された関数に引数を渡して評価することもできます。
</p>
<pre>
*Main&gt; :t sequenceA [(+3), (*4), (^2)]
sequenceA [(+3), (*4), (^2)] :: Num a =&gt; a -&gt; [a]
*Main&gt; sequenceA [(+3), (*4), (^2)] $ 5
[8,20,25]
</pre>
<h4>●Applicative の規則</h4>
<p> Applicative にも満たすべき規則があります。まず大前提として、pure f &lt;*&gt; x = f &lt;$&gt; x を満たす必要があります。この規則を満たさないと Functor と Applicative を組み合わせて使うことができません。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; pure (+10) &lt;*&gt; Just 10
Just 20
*Main&gt; (+10) &lt;$&gt; Just 10
Just 20
*Main&gt; pure (+10) &lt;*&gt; Right 10
Right 20
*Main&gt; (+10) &lt;$&gt; Right 10
Right 20
*Main&gt; pure (+10) &lt;*&gt; [1,2,3,4,5]
[11,12,13,14,15]
*Main&gt; (+10) &lt;$&gt; [1,2,3,4,5]
[11,12,13,14,15]
*Main&gt; getZipList $ (+10) &lt;$&gt; ZipList [1,2,3,4,5]
[11,12,13,14,15]
*Main&gt; getZipList $ pure (+10) &lt;*&gt; ZipList [1,2,3,4,5]
[11,12,13,14,15]
</pre>
<p> 正しく動作していますね。
</p>
<p> このほかに、Haskell の Data.Applicative のマニュアルによると、次の 4 つの規則があるそうです。
</p>
<ol>
  <li>pure id &lt;*&gt; v = v
  <li>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)
  <li>puer f &lt;*&gt; pure x = pure (f x)
  <li>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u
</ol>
<p> 規則の詳しい説明は本稿の範囲を超えるので (M.Hiroi の力不足なので)、ここでは Maybe を使って、規則が成り立っていることを示すだけにとどめます。これらの規則の意味は shelarcy さんの <a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20060915/248215/?ST=ittrend">本物のプログラマは Haskell を使う</a>  <a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20120110/378061/?ST=ittrend">第51回　FunctorとMonadの間にあるApplicative</a> で詳しく説明されています。そちらをお読みくださいませ。
</p>
<pre>
Prelude Control.Applicative&gt; pure id &lt;*&gt; Just 10
Just 10
Prelude Control.Applicative&gt; pure (.) &lt;*&gt; Just (*2) &lt;*&gt; Just (+5) &lt;*&gt; Just 10
Just 30
Prelude Control.Applicative&gt; Just (*2) &lt;*&gt; (Just (+5) &lt;*&gt; Just 10)
Just 30
Prelude Control.Applicative&gt; pure (*2) &lt;*&gt; Just 10
Just 20
Prelude Control.Applicative&gt; pure ((*2) 10) :: Maybe Int
Just 20
Prelude Control.Applicative&gt; Just (*2) &lt;*&gt; pure 10
Just 20
Prelude Control.Applicative&gt; pure ($ 10) &lt;*&gt; Just (*2)
Just 20
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">経路の探索 (2)</h3>
<p> <a href="haskell09.html#chap02">経路の探索</a> の続きです。今回は「反復深化」というアルゴリズムを説明します。
</p>

<h4>●反復深化</h4>
<p> 幅優先探索は最短手数を求めるのに適したアルゴリズムですが、生成する局面数が多くなると大量のメモリを必要とします。このため、メモリが不足するときは、幅優先探索を使うことができません。深さ優先探索の場合、メモリの消費量は少ないのですが、最初に見つかる解が最短手数とは限らないという問題点があります。
</p>

<p> それでは、大量のメモリを使わずに最短手数を求める方法はないのでしょうか。実は、とても簡単な方法があるのです。それは、深さ優先探索の「深さ」に上限値を設定し、解が見つかるまで上限値を段階的に増やしていく、という方法です。
</p>

<p> たとえば、1 手で解が見つからない場合は、2 手までを探索し、それでも見つからない場合は 3 手までを探索する、というように制限値を 1 手ずつ増やしていくわけです。このアルゴリズムを「反復深化 (iterative deeping) 」といいます。
</p>

<p> 反復深化は最短手数を求めることができるアルゴリズムですが、幅優先探索と違って局面を保存する必要が無いため、必要となるメモリは深さ優先探索と同程度で済みます。また、プログラムも深さ優先探索と同じくらい簡単に作成することができます。ただし、同じ探索を何度も繰り返すため実行時間が増大するという欠点があります。ようするに、使用するメモリは少ないが実行時間が長くなるアルゴリズムなのです。
</p>

<h4>●反復深化のプログラム</h4>
<p> それでは、同じ経路図を使って反復深化を具体的に説明しましょう。
</p>
<pre class="fig">
    Ｂ------Ｄ------Ｆ
  ／│      │          
Ａ  │      │          
  ＼│      │          
    Ｃ------Ｅ------Ｇ

      図 :経路図
</pre>

<p> 反復深化のプログラムはとても簡単です。設定した上限値まで深さ優先探索を行う関数を作り、上限値を１手ずつ増やしてその関数を呼び出せばいいのです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 反復深化

-- 隣接リスト
adjacent :: [[Int]]
adjacent =
  [[1,2],
   [0,2,3],
   [0,1,4],
   [1,4,5],
   [2,3,6],
   [3],
   [4]]

-- 次の頂点へ進む
nextPath :: [Int] -&gt; [[Int]]
nextPath path@(x:xs) = [y:path | y &lt;- adjacent !! x, y `notElem` xs]

-- 反復深化
ids :: Int -&gt; Int -&gt; IO ()
ids start goal = iter 1 where
  dfs n m path@(x:xs)
    | n == m    = if x == goal then print (reverse path) else return ()
    | otherwise = mapM_ (dfs (n + 1) m) $ nextPath path
  iter 7 = return ()
  iter m = do
    dfs 0 m [start]
    iter (m + 1)

-- リストに格納する
ids' :: Int -&gt; Int -&gt; [[Int]]
ids' start goal = iter 1 where
  dfs n m ys path@(x:xs)
    | n == m    = if x == goal then reverse path : ys else ys
    | otherwise = foldl (dfs (n + 1) m) ys $ nextPath path
  iter 7 = []
  iter m = dfs 0 m [] [start] ++ iter (m + 1)
</pre>
<p> 局所関数 iter で上限値を増やしていき、局所関数 dfs で深さ優先探索を行います。引数 n が経路長、引数 m が上限値を表します。n が m に達したら探索を打ち切ります。このとき、ゴールに到達したかチェックします。あとは、m の値を増やしながら dfs を呼び出せばいいわけです。関数 ids' は見つけた解をリストに格納して返します。
</p>
<p> それでは実行結果を示しましょう。
</p>
<pre>
*Main&gt; ids 0 6
[0,2,4,6]
[0,1,2,4,6]
[0,1,3,4,6]
[0,2,1,3,4,6]
*Main&gt; ids 6 0
[6,4,2,0]
[6,4,2,1,0]
[6,4,3,1,0]
[6,4,3,1,2,0]
*Main&gt; ids' 0 6
[[0,2,4,6],[0,1,3,4,6],[0,1,2,4,6],[0,2,1,3,4,6]]
*Main&gt; ids' 6 0
[[6,4,2,0],[6,4,3,1,0],[6,4,2,1,0],[6,4,3,1,2,0]]
</pre>
<p> 結果を見ればおわかりのように、最初に見つかる解が最短手数になります。このプログラムでは全ての経路を求めましたが、最短手数を求めるだけでよい場合は、解が見つかった時点で探索を終了すればいいでしょう。
</p>

<h4>●探索の一般化</h4>
<p> ところで、深さ優先探索と幅優先探索は高階関数を使うと一般化することができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 探索の一般化

-- 解をリストに格納して返す
search :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; [a]
search _ _ _ [] = []
search isGoal nextState combine (x:xs) =
  if isGoal x then x : search isGoal nextState combine xs
  else search isGoal nextState combine (combine (nextState x) xs)

-- 解を一つだけ求める
search' :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; Maybe a
search' _ _ _ [] = Nothing
search' isGoal nextState combine (x:xs) =
  if isGoal x then Just x 
  else search' isGoal nextState combine (combine (nextState x) xs)
</pre>
<p> 関数 search はまだ調べていない局面 (state) を格納したリスト (stateList) を受け取り、その先頭から局面を取り出して新しい局面を生成することで探索を進めます。isGoal はゴールに到達したか調べる述語、nextState は現在の局面から新しい局面を生成してリストに格納して返す関数、combine は新しく生成した局面を stateList に連結する関数、最後の引数が stateList です。
</p>

<p> 最初に、stateList が空リストであれば、空リストを返して探索を終了します。次に、先頭の局面 x を取り出して、ゴールに到達しているか isGoal でチェックします。isGoal が True であれば x を search の返り値 (リスト) に追加します。そうでなければ、search を再帰呼び出しします。このとき、x に nextState を適用して新しい局面を生成し、combine で xs に追加します。チェックした局面 x は stateList から取り除くことに注意してください。
</p>

<p> 解を一つ求めるだけでよければ、関数 search' のように isGoal の返り値が True であれば Just x を返して、ここで探索を打ち切ります。解が見つからない場合は Nothing を返します。
</p>

<p> 深さ優先探索は経路を先へ先へと進めていく探索なので、stateList の先頭に新しい局面を追加することで実現できます。combine にはリストを連結する関数を渡します。演算子 ++ をカッコで囲めばカリー化関数として渡すことができます。幅優先探索はすべての経路を並行に探索していくので、stateList の末尾に新しい局面を追加することで実現できます。combine には flip (++) を渡します。ただし、演算子 ++ を使う場合、たくさんの局面が生成されると効率は悪くなります。
</p>

<p> それでは、実際に経路の探索を行ってみましょう。
</p>
<pre>
*Main&gt; map reverse $ search (\x -&gt; head x == 6) nextPath (++) [[0]]
[[0,1,2,4,6],[0,1,3,4,6],[0,2,1,3,4,6],[0,2,4,6]]
*Main&gt; map reverse $ search (\x -&gt; head x == 6) nextPath (flip (++)) [[0]]
[[0,2,4,6],[0,1,2,4,6],[0,1,3,4,6],[0,2,1,3,4,6]]
*Main&gt; fmap reverse $ search' (\x -&gt; head x == 6) nextPath (++) [[0]]
Just [0,1,2,4,6]
*Main&gt; fmap reverse $ search' (\x -&gt; head x == 6) nextPath (flip (++)) [[0]]
Just [0,2,4,6]
</pre>
<p> 経路が逆順になるので reverse で反転しています。深さ優先探索と幅優先探索どちらも正常に動作していますね。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell13.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell15.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>