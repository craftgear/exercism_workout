<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881750</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml14.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml16.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">継承</h3>
<p> 前回まででオブジェクト指向の基本であるクラス、インスタンス、メソッドについて一通り説明しました。今回はオブジェクト指向機能の目玉ともいえる「継承」について説明します。
</p>

<p> OCaml の継承は他のオブジェクト指向言語と比べると、基本的な考え方は同じですが、クラスの継承関係が必ずしも「部分型」にはならない場合があるので注意が必要です。まず最初に、一般的なオブジェクト指向言語で使われている継承について簡単に説明します。
</p>

<p> なお、このドキュメントは拙作のページ <a href="../light/index.html">Lightweight Language</a> <a href="../light/python06.html">お気楽 Python プログラミング入門第 6 回</a> と同じです。既に読んだことがある方や、継承について理解されている方は読み飛ばしてもらってもかまいません。
</p>
<p><a href="ocaml15.html#next1">次へ</a>
</p>

<h4>●継承とは？</h4>
<p> 「継承 (inheritance : インヘリタンス) 」は簡単に言うとクラスに「親子関係」を持たせる機能です。子供のクラスは親クラスの性質を受け継ぐことができます。プログラミング言語の場合、引き継ぐ性質は定義されたインスタンス変数やメソッドになります。
</p>

<p> プログラムを作る場合、いままで作ったプログラムと同じような機能が必要になることがありますが、継承を使うことでその機能を受け継ぎ、新規の機能や変更される機能だけプログラムする、いわゆる「差分プログラミング」が可能になります。
</p>

<p> クラスを継承する場合、その元になるクラスを「スーパークラス」とか「ベースクラス」と呼びます。そして、継承したクラスを「サブクラス」と呼びます。この呼び方は言語によってまちまちで統一されていません。C++ の場合は、元になるクラスを基本クラスといい、継承するクラスを派生クラスとか導出クラスといいます。
</p>

<p> たとえば、クラス Foo1 を継承してクラス Foo2 を定義しましょう。クラス Foo1 にはメソッド bar が定義されています。クラス Foo2 にメソッド bar は定義されていませんが、Foo2 のオブジェクトに対して bar を呼び出すと、スーパークラス Foo1 のメソッド bar が実行されるのです。
</p>

<p> メソッドの選択は次のように行われます。まず、オブジェクトが属するクラス Foo2 にメソッド bar が定義されているか調べます。ところが、Foo2 には bar が定義されていないので、スーパークラスである Foo1 に bar が定義されているか調べます。ここでメソッド bar が見つかり、それを実行するのです。このように、メソッドが見つかるまで順番にスーパークラスを調べていきますが、最上位のスーパークラスまで調べてもメソッドが見つからない場合はエラーとなります。
</p>

<p> 継承したクラスのメソッドとは違う働きをさせたい場合、同名のメソッドを定義することで、そのクラスのメソッドを設定することができます。これを「オーバーライド (over ride) 」といいます。メソッドを選択する仕組みから見た場合、オーバーライドは必然の動作です。メソッドはサブクラスからスーパークラスに向かって探索されるので、スーパークラスのメソッドよリサブクラスのメソッドが先に選択されるわけです。
</p>

<h4>●単一継承と多重継承</h4>

<p> 継承には「単一継承」と「多重継承」の 2 種類があります。単一継承は、ただひとつのクラスからしか機能を継承することができません。したがって、クラスの階層は図 1 のような木構造で表すことができます。
</p>
<pre class="fig">
            Ａ
          ／｜＼
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ
    ／  ＼
  ／      ＼
Ｅ          Ｆ

図 1 : 単一継承におけるクラスの階層
</pre>
<p> 継承は何段階に渡って行われてもかまいません。たとえばクラス E の場合、スーパークラスが B で、B のスーパークラスが A に設定されています。サブクラスは複数あってもかまいません。たとえば、A のサブクラスは B, C, D と 3 つ、B のサブクラスは E, F と 2 つあります。図 1 では、クラス A のスーパークラスはありませんが、ほかのクラスではただひとつのスーパークラスを持っています。プログラミング言語では、Smalltalk や Java が単一継承です。
</p>

<p> これに対し多重継承は、複数のクラスを継承することができます。このため、クラスの階層は木構造ではなく、図 2 のようなグラフ <sup><a href="ocaml15.html#note1">[*1]</a></sup> で表すことができます。
</p>
<pre class="fig">
              Ａ
            ／  ＼
          ／      ＼
        Ｂ          Ｃ
      ／  ＼      ／  ＼
    ／      ＼  ／      ＼
  Ｄ          Ｅ          Ｆ

図 2 : 多重継承におけるクラスの階層
</pre>
<p> クラス E に注目してください。スーパークラスには B と C の 2 つがあります。多重継承では、単一継承と同じくサブクラスを複数持つことができ、なおかつ、スーパークラスも複数持つことができるのです。C++ や Common Lisp Object System (CLOS) は多重継承をサポートしています。そして、OCaml も多重継承です。
</p>

<p> 実をいうと、筆者は多重継承に対してあまりいいイメージを持っていません。私見ですが、多重継承はメリットよりもプログラムを複雑にするデメリットの方が大きいのではないか、と思っています。とくに、図 2 のクラス A, B, C, E のような菱形の関係を C++ でプログラムする場合、とても複雑な問題を引き起こすことが知られています。OCaml の場合でも、多重継承で問題が発生することがあります。多重継承については次回で詳しく説明します。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> グラフは木をより一般化したデータ構造です。数学のグラフ理論では、いくつかの点とそれを結ぶ線でできた図形を「グラフ」といいます。
</div>

<h4>●継承の仕組み</h4>
<p> 一般的なオブジェクト指向言語の場合、継承によって引き継がれる性質は定義されたインスタンス変数やメソッドになります。図 3 を見てください。
</p>
<pre class="fig">
     class
 ┌─ Foo  ─┐          ┌─ instance ─┐
 ├─────┤          ├───────┤
 │  変数 a  │────→│    変数 a    │
 ├─────┤          ├───────┤
 │  変数 b  │          │    変数 b    │
 └─────┘          └───────┘
method : get_a, get_b
      │
     継承
      ↓
 ┌─ Bar  ─┐          ┌─ instance ─┐
 ├─────┤────→├───────┤
 │  変数 c  │          │    変数 a    │
 └─────┘          ├───────┤
method : get_c           │    変数 b    │
                         ├───────┤
                         │    変数 c    │
                         └───────┘

図 3 : 一般的なオブジェクト指向言語における継承
</pre>
<p> クラス Foo にはインスタンス変数 a, b とメソッド get_a, get_b が定義されています。次に、クラス Bar を定義します。Bar は Foo を継承し、Bar 固有のインスタンス変数 c とメソッド get_c を定義します。Foo と Bar のインスタンスを生成すると、図 3 に示したように、Bar のインスタンスにはクラス Foo で定義された変数 a, b も含まれます。このように、Foo のインスタンス変数が Bar に継承されます。
</p>

<p> Foo のインスタンスを生成すると、もちろん変数 a, b は含まれていますが、Bar のインスタンスとメモリを共有することはありません。クラスはオブジェクトの設計図です。設計に共通な部分があったとしても、それから生み出されるインスタンスは別々の実体で、インスタンス変数を共有することはないのです。
</p>

<p> クラス Bar にはメソッド get_c しか定義されていませんが、クラス Foo を継承することにより、メソッド get_a と get_b を利用することができます。Bar のインスタンスに対して get_a を呼び出すと、クラス Bar には get_a が定義されていないので、スーパークラス Foo を調べ、そこで定義されている get_a が呼び出されます。もちろん、取り出される値は Bar のインスタンスにある変数 a の値です。このように、Foo のメソッドが Bar に継承されます。
</p>

<h4 id="next1">●単一継承の使い方</h4>
<p> それでは、具体的に OCaml の継承を説明しましょう。スーパークラスは object ... end の中で inherit 宣言を使って指定します。また、inherit 宣言を複数並べると、多重継承を行うことができます。継承に必要な設定はこれだけです。
</p>

<p> 簡単な例として、図 3 のクラスを実際にプログラムしてみましょう。まずクラス foo を定義します (リスト 1)。
</p>
<pre class="list">
リスト 1 : クラス foo の定義

class ['a] foo x y =
  object
    val a = (x: 'a)
    val b = (y: 'a)
    method get_a = a
    method get_b = b
  end
</pre>
<p> インスタンス変数 a, b は引数 x, y で初期化します。データ型は型変数 'a で表します。メソッド get_a と get_b の定義は簡単です。与えられたインスタンスから値を取り出すだけです。次にクラス bar を定義します (リスト 2)。
</p>
<pre class="list">
リスト 2 : クラス Bar の定義

class ['a] bar x y z =
  object
    inherit ['a] foo x y
    val c = (z: 'a)
    method get_c = c
  end
</pre>
<p> inherit でスーパークラス foo を指定します。このとき、必要な型変数や引数を指定します。これで foo で定義されているインスタンス変数が初期化されます。あとは自分のクラスで使うインスタンス変数 c を初期化し、メソッド get_c を定義します。
</p>

<p> 実際にクラス foo と bar を定義すると、次のように表示されます。
</p>
<pre>
class ['a] foo :
  'a -&gt;
  'a -&gt; object val a : 'a val b : 'a method get_a : 'a method get_b : 'a end

class ['a] bar :
  'a -&gt;
  'a -&gt;
  'a -&gt;
  object
    val a : 'a
    val b : 'a
    val c : 'a
    method get_a : 'a
    method get_b : 'a
    method get_c : 'a
  end
</pre>
<p> クラス foo を継承したことにより、クラス bar には foo のインスタンス変数とメソッドが引き継がれていることが分かります。なお、クラス bar は foo にメソッド get_c を追加しているだけなので、bar は foo の部分型になります。
</p>

<p> それでは実行してみましょう。
</p>

<pre>
# let a = new foo 1 2;;
val a : int foo = &lt;obj&gt;
# let b = new bar 10 20 30;;
val b : int bar = &lt;obj&gt;
# a#get_a;;
- : int = 1
# a#get_b;;
- : int = 2
# b#get_a;;
- : int = 10
# b#get_b;;
- : int = 20
# b#get_c;;
- : int = 30
</pre>

<p> メソッド get_a は bar に定義されていませんが、スーパークラス foo のメソッド get_a が呼び出されて、インスタンス変数 a の値を求めることができます。また、bar のインスタンスに対して get_c を呼び出せば、インスタンス変数 c の値を求めることができます。
</p>

<h4>●オーバーライド</h4>
<p> 継承はクラスに新しい機能を追加するだけではなく、メソッドをオーバーライドすることで機能を変更することができます。簡単な例題として、前々回作成したスタックを継承して、格納する要素数を制限するスタック fixed_stack というクラスを作ってみましょう。リスト 3 を見てください。
</p>

<pre class="list">
リスト 3 : 制限付きスタック

exception Full

class ['a] fixed_stack (limit: int) =
  object
    inherit ['a] stack as super
    val mutable size = 0

    method push x =
      if size = limit then raise Full
      else size &lt;- size + 1; super#push x

    method pop =
      if size = 0 then raise Empty
      else size &lt;- size - 1; super#pop

    method is_full = size = limit
  end
</pre>

<p> fixed_stack は指定した上限値までしか要素を格納できません。stack で要素を追加するメソッドは push で、削除するメソッドは pop です。この 2 つのメソッドをオーバーライドすることで、fixed_stack の機能を実現することができます。スタックの上限値は引数 limit で指定し、スタックの要素数はインスタンス変数 size で管理します。
</p>

<p> fixed_stack は stack を継承するので、inherit でスーパークラスに stack を指定します。メソッドをオーバーライドするとき、スーパークラスのメソッドを呼び出すことができると便利です。これを「メソッド結合 (method combination) 」といいます。OCaml の場合、inherit でスーパークラスを指定しますが、このとき次のように名前を指定すると、その名前を使ってスーパークラスのメソッドを呼び出すことができます。
</p>
<pre class="item">
inherit スーパークラス名 as 名前
</pre>
<p> fixed_stack では、名前に super を指定しているので、super#push や super#pop でスーパークラス stack のメソッドを呼び出すことができます。
</p>

<p> メソッド push は limit と size を比較して、size が limit と等しい場合はデータを挿入できないので例外 Full を送出します。そうでない場合はスーパークラスのメソッド push を呼び出して、データを挿入して size を +1 します。
</p>
<p> メソッド pop の場合、size が 0 であればデータを削除できないので例外 Empty を送出します。size が 0 よりも大きいときにスーパークラスのメソッド pop を呼び出して、size を -1 します。これで、スタックに格納される要素数を管理することができます。
</p>

<p> 簡単な実行例を示しましょう。
</p>

<pre>
# let a = new fixed_stack 5;
val a : '_a fixed_stack = &lt;obj&gt;
# for i = 0 to 4 do a#push i done;;
- : unit = ()
# a#push 5;;
exception: Full
# a#is_full;;
- : bool = true
# while not a#is_empty do print_int a#pop; print_string " " done;;
4 3 2 1 0 - : unit = ()
</pre>

<p> このように stack を継承することで、fixed_stack を簡単にプログラムすることができます。
</p>

<h4>●集合 (2)</h4>
<p> もう一つ簡単な例題として、前回作成した集合 set を継承して、要素を昇順に並べて格納する集合 sorted_set を作ってみましょう。sorted_set はリストは要素をまとめてソートするのではなく、要素が昇順に並ぶように適切な位置にデータを挿入します。また、要素を昇順に並べておくと、最小値を簡単に求めることができます。
</p>

<p> プログラムをリスト 4 に示します。
</p>

<pre class="list">
リスト 4 : 順序付き集合

exception Empty

class ['a] sorted_set compare =
  object
    inherit ['a] set compare

    method member p =
      let rec mem_eq = function
        [] -&gt; false
      | x::xs -&gt; let r = compare p x in
          if r = 0 then true
          else if r &lt; 0 then false
          else mem_eq xs
      in
        mem_eq content

    method insert p =
      let rec ins = function
        [] -&gt; [p]
      | (x::xs) as ls -&gt; let r = compare p x in
          if r = 0 then ls
          else if r &lt; 0 then p::ls
          else x :: (ins xs)
      in
        content &lt;- ins content

    method min =
      match content with
        [] -&gt; raise Empty
      | x::_ -&gt; x

    method delete_min =
      match content with
        [] -&gt; raise Empty
      | x::xs -&gt; content &lt;- xs; x
  end
</pre>

<p> sorted_set は set を継承するので、inherit で ['a] set と指定します。このとき、要素を比較する関数 compare も忘れずに指定してください。オーバーライドするメソッドは member と insert です。データを昇順に並べると、探索処理は線形探索よりも速くなります。メソッド min は最小値のデータを返します。メソッド delete_min は集合から最小値のデータを取り除きます。
</p>

<p> member は簡単にプログラムできます。要素は昇順に並んでいるので、引数 p よりも要素 x が大きい場合、それ以降に p と等しい要素は存在しません。ここで探索を打ち切って false を返すことができます。
</p>

<p> データを挿入する insert も簡単です。これは拙作のページ <a href="ocaml04.html#chap03">ソート</a> で取り上げた「挿入ソート」と同じ考え方です。データ p と要素を比較していき、p よりも大きい要素の前に p を挿入します。リストが空リストになった場合、p が一番大きなデータなので [p] を返します。
</p>

<p> メソッド min は content の先頭の要素を返すだけです。メソッド delete_min は content の先頭の要素を取り除き、その要素を返します。どちらのメソッドも content が空リストの場合は例外 Empty を送出します。
</p>

<p> sorted_list を定義すると、次のように表示されます。
</p>

<pre>
class ['a] sorted_set :
  ('a -&gt; 'a -&gt; int) -&gt;
  object ('b)
    val mutable content : 'a list
    val mutable size : int
    method copy : 'b
    method delete : 'a -&gt; unit
    method delete_min : 'a
    method difference : 'b -&gt; 'b
    method insert : 'a -&gt; unit
    method intersection : 'b -&gt; 'b
    method is_equal : 'b -&gt; bool
    method is_subset : 'b -&gt; bool
    method iter : ('a -&gt; unit) -&gt; unit
    method length : int
    method member : 'a -&gt; bool
    method min : 'a
    method union : 'b -&gt; 'b
  end
</pre>

<p> set から継承したバイナリメソッドの型に注目してください。引数の型が自分自身 (sorted_set) と同じ 'b になっていますね。もしも、クラス set でバイナリメソッドの引数の型を 'a set とすると、sorted_set のバイナリメソッドの引数の型も 'a set になってしまうので、sorted_set の集合演算を定義することができません。
</p>

<p> また、集合演算を行うメソッドでは返り値が 'b になっています。もしも、オブジェクトをコピーしないで新しい集合を new set で生成すると、集合演算の返り値は 'a set になってしまいます。自分自身の型を指定し、オブジェクトをコピーすることで、set を継承した sorted_set を正しく定義することができます。
</p>

<p> ただし、問題点がないわけではありません。実は、sorted_set は set の部分型にはなりません。このことについては次回で詳しく説明します。
</p>

<p> それでは簡単な実行例を示しましょう。
</p>

<pre>
# let print s = s#iter (fun x -&gt; print_int x#get; print_string " ");;
val print : &lt; iter : (int -&gt; unit) -&gt; 'a; .. &gt; -&gt; 'a = &lt;fun&gt;
# let a = new sorted_set compare;;
val a : '_a sorted_set = &lt;obj&gt;
# for i = 1 to 5 do a#insert i done;;
- : unit = ()
# print a;;
1 2 3 4 5 - : unit = ()
# let b = new sorted_set compare;;
val b : '_a sorted_set = &lt;obj&gt;
# for i = 4 to 8 do b#insert i done;;
- : unit = ()
# print b;;
4 5 6 7 8 - : unit = ()
# print (a#union b);;
1 2 3 4 5 6 7 8 - : unit = ()
# print (a#intersection b);;
4 5 - : unit = ()
# print (a#difference b);;
1 2 3 - : unit = ()
</pre>
<p> 正常に動作していますね。
</p>
<h4>●initializer</h4>
<p> インスタンスを生成した後で独自の処理を行いたい場合は initializer を設定します。
</p>
<pre class="item">
initializer 式
</pre>
<p> initializer はインスタンスが生成されてから呼び出されます。このとき、インスタンス変数の値は初期化されています。式の返り値は unit でなければいけません。また、initializer の中で自分のクラスのメソッドを呼び出すこともできます。簡単な例を示しましょう。
</p>
<pre class="list">
リスト 5 : initializer

class foo (xi: int) =
  object
    val mutable x = xi
    initializer 
      print_int x; print_newline ()

    method get_x = x
    method set_x a = x &lt;- a
  end

class bar (xi: int) (yi: int) =
  object
    inherit foo xi
    val mutable y = yi
    initializer 
      print_int y; print_newline ()

    method get_y = y
    method set_y a = y &lt;- a
  end
</pre>

<p> クラス foo と bar の initializer はインスタンス変数の値を表示します。initializer はオーバーライドされることはなく、継承したクラスの initializer は設定されていれば必ず実行されます。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
# let a = new foo 10;;
10
val a : foo = &lt;obj&gt;
# let b = new bar 1 2;;
1
2
val b : bar = &lt;obj&gt;
</pre>
<p> bar のインスタンスを生成すると、foo の initializer が評価されて、その次に bar の initializer が評価されていることがわかります。
</p>
<h4>●抽象メソッドと抽象クラス</h4>
<p> クラスでメソッドを定義するとき、キーワード virtual を付けるとメソッドの型だけを宣言することができます。これを「抽象メソッド (virtual method) 」といいます。そして、抽象メソッドを持つクラスを「抽象クラス (virtual class) 」といい、new でインスタンスを生成することはできません。抽象クラスと抽象メソッドは次のように定義します。
</p>
<pre class="item">
class virtual クラス名 args ... =
  object
    method virtual メソッド名 : 型式
    ...
  end
</pre>

<p> 抽象クラスは継承されることを前提としたクラスで、抽象メソッドはサブクラスにおいて具体的に定義されます。抽象クラスでは、サブクラス共通のメソッドを定義します。このとき、抽象クラスのメソッドは抽象メソッドを使って定義することができます。サブクラスのインスタンスが生成されるとき、そのサブクラスでは抽象メソッドが具体化されているはずなので、抽象クラスのメソッドからサブクラスのメソッドが呼び出されることになります。
</p>

<p> それでは簡単な例題として、図形の面積を求めるプログラムを作ってみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト 6 : 図形のクラス

let pi = 3.14159265

(* 抽象クラス *)
class virtual figure =
  object (self)
    method virtual kind_of : string
    method virtual area : float

    method print =
      Printf.printf "%s: area = %f\n" self#kind_of self#area
  end
</pre>

<p> クラス figure は抽象クラスです。メソッド kind_of と area が抽象メソッドで、kind_of は図形の種類を文字列で返し、area は図形の面積を計算して返します。print は図形の種別と面積を表示するメソッドです。ここで、抽象メソッド kind_of と area を呼び出しています。kind_of と area はサブクラスで定義します。
</p>

<p> 実際に figure を定義すると、次のように表示されます。
</p>
<pre>
class virtual figure :
  object
    method virtual area : float
    method virtual kind_of : string
    method print : unit
  end
</pre>

<p> 次は図形を表すサブクラスを定義します。
</p>

<pre class="list">
リスト 7 : サブクラスの定義

(* 三角形 *)
class triangle altitude base =
  object
    inherit figure
    method get_altitude = altitude
    method get_base = base
    method kind_of = "Triangle"
    method area = altitude *. base /. 2.0
  end

(* 四角形 *)
class rectangle width height =
  object
    inherit figure
    method get_width = width
    method get_height = height
    method kind_of = "Rectangle"
    method area = width *. height
  end

(* 円 *)
class circle radius = 
  object
    inherit figure
    method get_radius = radius
    method kind_of = "Circle"
    method area = radius *. radius *. pi
  end
</pre>

<p> triangle, rectangle, circle は figure を継承します。サブクラス固有のメソッドも定義されていますが、どのクラスも抽象メソッド kind_of と area を具体化しています。なお、スーパークラスの抽象メソッドをすべて具体化しないと、そのサブクラスも抽象クラスになるため、インスタンスを生成することができません。ご注意ください。
</p>

<p> 実際にクラスを定義すると、次のように表示されます。
</p>
<pre>
class triangle :
  float -&gt;
  float -&gt;
  object
    method area : float
    method get_altitude : float
    method get_base : float
    method kind_of : string
    method print : unit
  end

class rectangle :
  float -&gt;
  float -&gt;
  object
    method area : float
    method get_height : float
    method get_width : float
    method kind_of : string
    method print : unit
  end

class circle :
  float -&gt;
  object
    method area : float
    method get_radius : float
    method kind_of : string
    method print : unit
  end
</pre>
<p> それでは簡単な実行例を示します。
</p>
<pre>
# let a = new triangle 2.0 2.0;;
val a : triangle = &lt;obj&gt;
# let b = new rectangle 2.0 2.0;;
val b : rectangle = &lt;obj&gt;
# let c = new circle 2.0;;
val c : circle = &lt;obj&gt;
# a#print;;
Triangle: area = 2.000000
- : unit = ()
# b#print;;
Rectangle: area = 4.000000
- : unit = ()
# c#print;;
Circle: area = 12.566371
</pre>
<p> 正常に動作していますね。
</p>
<h4>●型変換</h4>
<p> OCaml では、型 A の部分型のオブジェクトは型 A のオブジェクトに変換することができます。この機能を「型変換 (coercion) 」といいます。これは Java などのオブジェクト指向言語の「アップキャスト」に相当します。なお、OCaml のオブジェクト指向には「ダウンキャスト」に相当する機能はありません。型変換の構文を示します。
</p>
<pre class="item">
(式 : 型1 :&gt; 型2)
</pre>
<p> 式の評価値 (オブジェクト) の型 1 を型 2 に変換します。なお、たいていの場合は ": 型1" の部分を省略することができます。
</p>
<p> たとえば、図形のオブジェクトをリストにまとめて格納することを考えます。triangle, rectangle, circle は型が違うので、同じリストに格納することはできません。この場合、figure に型変換すると同じリストに格納することができます。次の例を見てください。
</p>
<pre>
# let sum_of_figure ls = List.fold_left (fun x y -&gt; x +. y#area) 0.0 ls;;
val sum_of_figure : &lt; area : float; .. &gt; list -&gt; float = &lt;fun&gt;
# sum_of_figure [(a :&gt; figure); (b :&gt; figure); (c :&gt; figure)];;
- : float = 18.5663706
</pre>
<p> 関数 sum_of_figure は図形の面積の合計値を求めます。型変換した場合、サブクラスの情報は失われるため、サブクラス独自のメソッドを呼び出すことはできません。型変換したスーパークラスのメソッドしか利用できませんが、ポリモーフィズムによりサブクラスのメソッドが呼び出されるため、図形の面積を正しく計算することができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml14.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml16.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>