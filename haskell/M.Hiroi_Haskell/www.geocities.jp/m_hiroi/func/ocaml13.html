<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881750</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml12.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml14.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">オブジェクト指向</h3>
<p> プログラミングに興味のある方ならば、「オブジェクト指向」という言葉は聞いたことがあると思います。よく使われているオブジェクト指向言語に C++ や Java があります。また、Lightweight Language と呼ばれているプログラミング言語、たとえば Perl, Python, Ruby, JavaScript などはオブジェクト指向をサポートしています。
</p>

<p> 多くの言語でサポートされている「オブジェクト指向」ですが、関数型言語では Common Lisp の CLOS (Common Lisp Object System) が有名でしょう。CLOS は Smalltalk, C++, Java などのポピュラーなオブジェクト指向とはちょっと違っていて、興味深い機能がたくさんあります。
</p>

<p> OCaml は "Objective Caml" の略なので、もちろんオブジェクト指向をサポートしています。ただし、OCaml には多相性と型推論があるため、他のオブジェクト指向言語とは異なる部分がかなりあります。とくにオブジェクトの「型」については、一般的なオブジェクト指向とは大きく異なります。
</p>

<p> OCaml 初心者である M.Hiroi が OCaml のオブジェクト指向を説明するのは無謀なことだと思いますが、簡単なところから少しずつ勉強していきましょう。まず最初に、一般的なオブジェクト指向について簡単に説明します。
</p>

<p> なお、この説明は拙作のページ <a href="../light/index.html">Lightweight Language</a> <a href="../light/python05.html">お気楽 Python プログラミング入門第 5 回</a> と同じです。既に読んだことがある方や、一般的なオブジェクト指向について理解されている方は、読み飛ばしてもらってもかまいません。
</p>
<p><a href="ocaml13.html#next1">次へ</a>
</p>
<h4>●オブジェクトとは？</h4>
<p> プログラムを作る場合、全体を小さな処理に分割して、ひとつひとつの処理を作成し、それらを組み合わせて全体のプログラムを完成させます。このとき、基本的な部品となるのが関数です。つまり、処理を関数単位で分割して、それらを組み合わせてプログラムを作るわけです。もともと関数の役割は、入力されたデータを処理してその結果を返すことです。つまり、関数は機能を表しているのです。このため、全体を小さな処理に分割するにしても、機能単位で行われることが普通です。
</p>

<p> オブジェクト指向プログラミングでは、関数ではなく「オブジェクト (object) 」を部品として扱います。たとえば、えんぴつを考えてみましょう。えんぴつには、色、長さ、固さ、などいろいろな性質があります。そして、えんぴつを使って文字を書いたり、絵を描いたりすることができます。プログラムでは、このような性質をデータで表し、機能を関数で表すことになります。そしてオブジェクトとは、このデータと関数を結び付けたものなのです。
</p>

<p> いままでのプログラミング言語では、データと関数を別々に定義するため、それをひとつのオブジェクトとして表すことができません。えんぴつで文字を書くにも、えんぴつの種類をチェックして文字を書くようにプログラムしなければいけません。ところが、オブジェクトはデータと関数を結び付けたものなので、自分がなにをしたらよいかわかっています。えんぴつオブジェクトに文字を書けと命じれば、それが赤えんぴつのオブジェクトであれば文字は赤に、黒えんぴつのオブジェクトであれば黒い文字になるのです。
</p>

<p> このように、オブジェクトはデータと関数をひとつにまとめたものです。従来のプログラミングが全体を機能単位で分割するのに対し、オブジェクト指向プログラミングでは全体をオブジェクト単位に分割して、それを組み合わせることでプログラムを作成します。
</p>

<p> ところで、データと関数を結び付けることは、従来のプログラミング言語でも可能です。オブジェクト指向はプログラミングの考え方のひとつであり、C++ のようなオブジェクト指向言語を使わなくても、たとえばＣ言語でもその考え方にしたがってプログラムを作れば、オブジェクト指向プログラミングになります。
</p>

<p> 実際、オブジェクト指向には様々な考え方があり、いろいろなオブジェクト指向言語が存在します。ですが、データと関数をひとつにまとめたものをオブジェクトとして扱うという基本的な考え方は、オブジェクト指向言語の元祖と言われる Smalltalk でも、C++, Java, OCaml でも同じです。
</p>

<h4>●クラスとインスタンス</h4>
<p> 次は、一般的なオブジェクト指向機能について簡単に説明します。
</p>

<p> 「クラス (class) 」はオブジェクトの振る舞いを定義したものです。ここでデータを格納するための変数や、それを操作する関数が定義されます。この変数をメンバ変数とかインスタンス変数といい、関数を「メソッド (method) 」といいます。メソッドはあとで説明します。
</p>

<p> クラスはオブジェクトの設計図にあたるもので、オブジェクトの「雛形」と呼ぶこともあります。クラスはオブジェクトの振る舞いを定義するだけで、アクセスできる実体はなにも生み出していない、ということに注意してください。
</p>

<p> このクラスから実体として作り出されるのが「インスタンス (instance) 」です。このインスタンスを「オブジェクト」と考えてください。インスタンスを生成する方法は、当然ですがプログラミング言語によって違います。たとえば C++ や Java は new を使います。図 1 を見てください。
</p>
<pre class="fig">
┌─ class Foo  ─┐                        ┌─ instance ─┐
│                │                        │              │
│     設計図     │─ インスタンスの生成 →│   実体       │
│                │                        │              │
└────────┘                        └───────┘
          │
          │
          │                                ┌─ instance ─┐
          │                                │              │
          └───── インスタンスの生成 →│   実体       │
                                            │              │
                                            └───────┘

             図 1 : クラスとインスタンスの関係
</pre>
<p> クラスはオブジェクトの定義を表すものですから、Foo というクラスはひとつしかありません。これに対し、インスタンスはクラスから生み出されるオブジェクトです。たとえば、クラス Foo に new を適用することで、いくつでもインスタンスを生み出すことができるのです。クラスは設計図であり、それに従って作られるオブジェクトがインスタンスと考えるとわかりやすいでしょう。
</p>

<h4>●メソッド</h4>
<p> メソッドはオブジェクトと結びついた関数です。オブジェクト指向プログラミングでは、ほかの関数から直接オブジェクトを操作することはせず、メソッドを呼び出すことで行います。メソッドは、クラスが異なっていれば同じ名前のメソッドを定義することができます。たとえば、クラス Foo1 にメソッド bar() が定義されていても、クラス Foo2 に同名のメソッド bar() を定義することができます。
</p>

<p> そして、ここからが重要なのですが、あるオブジェクトに対してメソッド bar() を呼び出した場合、それが Foo1 から作られたオブジェクトであれば、Foo1 で定義された bar() が実行され、Foo2 から作られたオブジェクトであれば、Foo2 で定義された bar() が実行されるのです。
</p>

<p> このように、オブジェクトが属するクラスによって、実行されるメソッドが異なるのです。この機能を「ポリモーフィズム(polymorphism) 」と呼びます。これにより、オブジェクトは自分が行うべき適切な処理を実行できるわけです。
</p>

<p> クラス、インスタンス、メソッドの関係は図 2 のようになります。
</p>
<pre class="fig">
┌─ class Foo1 ─┐                    ┌─ instance ─┐
│                │                    │              │
│    設計図      │─── 生成 ───→│   実体       │
│                │                    │              │
│                │                    └───────┘
│┌─ method ─┐│                          ↑
││            ││                          │
││   bar()←─┼┼─── アクセス ─────┘
││            ││
│└──────┘│
└────────┘

       図 2 : クラス、インスタンス、メソッドの関係
</pre>
<p> クラスという設計図が中心にあり、そこからインスタンスが生み出され、メソッドを使ってインスタンスを操作する、という関係になります。
</p>

<h4 id="next1">●OCaml のクラス</h4>
<p> さて、一般的な話はここまでにして、OCaml のオブジェクト指向機能に目を向けてみましょう。OCaml は class 宣言でクラスを定義します。class の構文を示します。
</p>
<pre class="item">
class class_name = object ... end
</pre>
<p> class の次にクラス名を指定し、= の右辺 object ... end でインスタンス変数やメソッドを定義します。
</p>

<p> 一番簡単なクラス定義を示しましょう。次の例を見てください。
</p>
<pre>
# class foo = object end;;
class foo : object end
</pre>
<p> 一般的なオブジェクト指向言語では、クラス名を英大文字から始めることが多いのですが、OCaml の場合、英大文字から始まる名前はコンストラクタとして認識されるので、クラス名は英小文字から始めます。foo はクラス名しかありませんが、これでも立派なクラスなのです。次の例を見てください。
</p>

<pre>
# let a = new foo;;
val a : foo = &lt;obj&gt;
</pre>

<p> OCaml は次の形式でインスタンスを生成します。
</p>
<pre class="item">
new クラス名
</pre>
<p> インスタンスを生成するとき、引数を指定することができます。これはあとで説明します。
</p>

<h4>●インスタンス変数とメソッドの定義</h4>
<p> OCaml の場合、インスタンス変数は val で、メソッドは method で定義します。
</p>
<pre class="item">
val (mutable) 変数名 = 初期値
method メソッド名 引数 ... = 式
</pre>
<p> OCaml の場合、インスタンス変数にアクセスできるのはクラス内のメソッドだけです。クラスの外からアクセスすることはできません。また、名前の前に mutable を付けると値を書き換えることができます。インスタンス変数の書き換えは次の式で行います。
</p>
<pre class="item">
インスタンス変数名 &lt;- 式
</pre>

<p> メソッドの定義は let の代わりに method を使います。引数がないメソッドを定義するとき、( ) をつける必要はありません。
</p>

<p> それでは、簡単な例を示しましょう。
</p>
<pre class="list">
リスト 1 : インスタンス変数とメソッドの定義

class foo = object
  val mutable a = 10
  method get_a = a
  method set_b x = a &lt;- x
end
</pre>

<p> 実際に foo を定義すると、次のように表示されます。
</p>
<pre>
class foo :
  object
    val mutable a : int
    method get_a : int
    method set_a : int -&gt; unit
  end
</pre>
<p> メソッドの呼び出しは次の形式で行います。
</p>
<pre class="item">
式#メソッド名
</pre>
<p> それでは実際に試してみましょう。
</p>
<pre>
# let x = new foo;;
val x : foo = &lt;obj&gt;
# x#get_a;;
- : int = 10
# x#set_a 100;;
- : unit = ()
# x#get_a;;
100
</pre>
<p> このように、メソッドを呼び出してインスタンス変数の値を取得したり、値を書き換えることができます。
</p>

<h4>●オブジェクトの初期化</h4>
<p> OCaml は new でオブジェクトを生成するとき、関数の引数のようにデータを渡すことができます。次の構文を見てください。
</p>
<pre class="item">
class クラス名 引数1 引数2 ... = object ... end
</pre>
<p> クラス名と = の間に引数を指定します。これで object ... end の中から与えられた引数を参照することができます。たとえば、クラス foo に整数値を渡す場合は次のようになります。
</p>
<pre class="list">
リスト 2 : 引数の指定方法

class foo (init: int) = object
  val mutable a = init
  method get_a = a
  method set_a x = a &lt;- x
end
</pre>
<p> 引数 init でインスタンス変数の値を初期化します。init の型は int に指定します。このプログラムでは引数のデータ型を指定しましたが、OCaml はクラスに型変数を渡すことで多相的なクラスを定義することができます。これはあとで説明します。
</p>

<p> 実際にクラス foo を定義すると次のように表示されます。
</p>
<pre>
class foo :
  int -&gt;
  object
    val mutable a : int
    method get_a : int
    method set_a : int -&gt; unit
  end
</pre>
<p> あとは new でインスタンスを生成するときに値を渡すだけです。
</p>
<pre>
# let a = new foo 100;;
val a : foo = &lt;obj&gt;
# a#get_a;;
- : int = 100
# let b = new foo;;
val b : int -&gt; foo = &lt;fun&gt;
# let c = b 1000;;
val c : foo = &lt;obj&gt;
# c#get_a;;
- : int = 1000
</pre>
<p> 最初の例のように、引数を与えるとインスタンスが生成されます。引数を与えない場合、引数を受け取ってインスタンスを返す関数が生成されます。その関数を使ってインスタンスを生成することもできます。
</p>

<h4>●多相クラス</h4>
<p> クラスはヴァリアントやレコードと同様に、型変数を使って多相的なデータ構造を定義することができます。これを「多相クラス (polymorphic class) 」といいます。型変数は次のように指定します。
</p>
<pre class="item">
class [型変数1, 型変数2, ..., 型変数n] クラス名 = object ... end
</pre>
<p> クラス名の前の角カッコ [ ] に型変数を指定します。そして、object ... end の中で型変数を参照することができます。
</p>
<p> それでは簡単な例題としてスタックを作ってみましょう。クラスでスタックを定義すると次のようになります。
</p>
<pre class="list">
リスト 3 : スタック

(* 例外 *)
exception Empty

(* クラス定義 *)
class ['a] stack = object
  (* データを格納するリスト *)
  val mutable content = ([]: 'a list)

  (* データを追加 *)
  method push x =
    content &lt;- x::content

  (* データの削除 *)
  method pop =
    match content with
      [] -&gt; raise Empty
    | x::xs -&gt; content &lt;- xs; x

  (* データの取得 *)
  method top =
    match content with
      [] -&gt; raise Empty
    | x::_ -&gt; x

  (* スタックは空か *)
  method is_empty = content = []
end
</pre>
<p> データはインスタンス変数 content のリストに格納します。ここでクラスに渡された型変数 'a を使ってデータ型を 'a list に指定します。データ型を指定しなかったり、型変数を渡さずに 'a list と指定するとコンパイルでエラーになります。
</p>
<p> メソッドの動作は拙作のページ <a href="ocaml09.html">モジュール</a> で作成した「参照型データを使ったスタックの実装」と同じです。メソッド push は content の先頭にデータ x を追加します。メソッド pop は content の先頭の要素を取り除いて、その値を返します。メソッド top は content の先頭の要素を返します。メソッド is_empty は content が空リストであれば true を返します。
</p>
<p> 実際に、クラス stack を定義すると次のように表示されます。
</p>
<pre>
class ['a] stack :
  object
    val mutable content : 'a list
    method is_empty : bool
    method pop : 'a
    method push : 'a -&gt; unit
    method top : 'a
  end
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
# let a = new stack;;
val a: '_a stack = &lt;obj&gt;
# for i = 0 to 9 do a#push i done;;
- : unit = ()
# a#is_empty;;
- : bool = false
# a#top;;
- : int = 9
# while not a#is_empty do Printf.printf "%d " a#pop done;;
9 8 7 6 5 4 3 2 1 0 - : unit = ()
</pre>
<p> このように、型変数を渡すことで多相クラスを定義することができます。
</p>

<h4>●private メソッド</h4>
<p> もう一つ簡単な例としてキューを作ってみましょう。拙作のページ <a href="ocaml09.html">モジュール</a> で作成した「キュー」をクラスを使って実装します。次のリストを見てください。
</p>
<pre class="list">
リスト 4 : キュー

exception Empty

class ['a] queue =
  object (self)
    val mutable front = ([]: 'a list)
    val mutable rear  = ([]: 'a list)

    (* データの移動 *)
    method private move =
      front &lt;- (List.rev rear); rear &lt;- []

    (* データの追加 *)
    method enqueue x = rear &lt;- x :: rear

    (* データの削除 *)
    method dequeue =
      if front = [] then self#move;
      match front with
        [] -&gt; raise Empty
      | x::xs -&gt; front &lt;- xs; x

    (* データの取得 *)
    method top = 
      if front = [] then self#move;
      match front with
        [] -&gt; raise Empty
      | x::_ -&gt; x

    (* キューは空か *)
    method is_empty = front = [] &amp;&amp; rear = []
  end
</pre>
<p> インスタンス変数 front と rear にデータを格納するリストをセットします。このプログラムは front と rear の値を書き換えることで動作します。データの追加は簡単ですね。メソッド enqueue は引数 x を rear の先頭に追加するだけです。
</p>

<p> メソッド dequeue と top は、rear のデータを front に移動するメソッド move を呼び出すと簡単に定義できます。メソッドから同じクラスのメソッドを呼び出す場合、メソッドを呼び出したインスタンスが必要になります。OCaml の場合、次の構文で呼び出し元のインスタンスに名前を付けて、それを用いてメソッドを呼び出すことができます。
</p>
<pre class="item">
object (変数名) ... end 
</pre>
<p> 今回は変数名に self を使っています。self#move とすれば、メソッド move を呼び出して、rear のデータを front に移動することができます。
</p>
<p> ここで move の前に付いているキーワード private に注目してください。move はクラス内部のメソッドから呼び出される作業用のメソッドです。もしも外部から move を呼び出すことができると、キューの状態を破壊することになるのでとても危険です。このような場合、private をつけることでメソッドを外部から隠蔽することができます。
</p>
<p> dequeue と top は front が空リストであれば move を呼び出してデータを移動します。そして、dequeue はキューから先頭の要素を取り除き、top は先頭の要素を返します。is_empty はキューが空の場合は true を返します。
</p>

<p> 実際にキューを定義すると次のように表示されます。
</p>
<pre>
class ['a] queue :
  object
    val mutable front : 'a list
    val mutable rear : 'a list
    method dequeue : 'a
    method enqueue : 'a -&gt; unit
    method is_empty : bool
    method private move : unit
    method top : 'a
  end
</pre>
<p> メソッド move のデータ型が表示されていますが、private が付いているので外部から呼び出すことはできません。
</p>
<p> それでは簡単な実行例を示します。
</p>
<pre>
# let a = new queue;
val a : '_a queue = &lt;obj&gt;
# for i = 0 to 9 do a#enqueue i done;;
- : unit = ()
# a#is_empty;;
- : bool = false
# while not a#is_empty do Printf.printf "%d " a#dequeue done;;
0 1 2 3 4 5 6 7 8 9 - : unit = ()
</pre>
<p> 正常に動作していますね。
</p>

<h4>●オブジェクトの型</h4>
<p> さて、これまでに説明した OCaml のクラス、インスタンス、メソッドの働きは、多相クラスを除くと一般的なオブジェクト指向とそれほど変わらないように思えます。class 文でクラスを定義し、new を適用してインスタンスを生成する方法は、一般的なオブジェクト指向とまったく同じです。ところが、OCaml のオブジェクト指向はクラスを定義しなくてもインスタンスを生成することができます。次の例を見てください。
</p>
<pre>
# let a = object
  val mutable a = 10
  method get_a = a
  medhod set_a x = a &lt;- x
  end
val a : &lt; get_a : int; set_a : int -&gt; unit &gt; = &lt;obj&gt;
# a#get_a;;
10
# a#set_a 100;;
- : unit = ()
# a#get_a;;
100
</pre>
<p> OCaml は object ... end でインスタンス (オブジェクト) を生成することができます。ちなみに、class 文によるクラス定義は次の式と同じ意味です。
</p>
<pre class="item">
class クラス名 = fun 引数1 引数2 ... -&gt; object ... end
</pre>

<p> ここで表示されるデータ型に注目してください。&lt; &gt; の中にメソッドのデータ型が列挙されていますね。これがオブジェクトのデータ型を表しています。OCaml の場合、オブジェクトの型は次の形式で表します。
</p>
<pre class="item">
&lt; メソッド名1: 型1; メソッド名2: 型2; ... ; メソッド名n: 型n &gt;
</pre>
<p> オブジェクトの型にインスタンス変数は関係ありません。インスタンス変数の名前が異なっていても、メソッドの名前と型が一致すれば、同じオブジェクトの型と判断されます。OCaml の場合、インスタンス変数にアクセスできるのはメソッドだけなので、メソッド名とその型を使ってオブジェクトの型を表すことができるわけです。
</p>

<p> したがって、異なるクラスから生成されたオブジェクトでも、同一のオブジェクト型と判断されることがあります。つまり、OCaml におけるクラスはデータ型そのものを表しているのではなく、オブジェクトのデータ型に「名前」を付けただけなのです。もちろん、名前をつけることには意味があり、オブジェクトの型をそのまま使うよりも、クラス名を使うことでわかりやすいプログラムを作ることができます。
</p>

<h4>●OCaml の部分型</h4>
<p> M.Hiroi は「クラス＝型」という意識を強く持っていたので、「クラス≠型」という OCaml のオブジェクト指向には本当に驚きました。これで本当にオブジェクト指向が機能するのか不思議に思っていたのですが、実際に使ってみると多相性と型推論により、とても柔軟なシステムになっているのです。たとえば、次の例を見てください。
</p>

<pre>
let foo obj = obj#get_a;;
val foo : &lt; get_a : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;
</pre>
<p> 関数 foo はオブジェクト obj を受け取り、メソッド get_a を呼び出してその値を返します。OCaml は静的な型付けを行うプログラミング言語ですが、メソッドの選択はプログラムの実行時に行う「遅延束縛 (late binding) 」を採用しているので、メソッド get_a が定義されていなくてもコンパイルすることが可能です。
</p>

<p> また、遅延束縛により OCaml はメソッドのポリモーフィズムを実現しています。ただし、メソッドの呼び出しは、その分だけ関数呼び出しよりも少し遅くなります。
</p>

<p> ここで obj の型に注目してください。引数 obj に対応するメソッド get_a を呼び出すので、当然ですが obj は型推論によりオブジェクトを表すデータ型になります。最後に現れている 2 つのピリオド ( .. ) はパターンマッチングのワイルドカードみたいなもので、ほかにメソッドがあってもよいことを表しています。次の例を見てください。
</p>
<pre class="item">
(1) &lt; get_a : 'a &gt;
(2) &lt; get_a : 'a; get_b : 'b &gt;
(3) &lt; get_a : 'a: get_b : 'b; ... ; get_n : 'n &gt;
</pre>
<p> どのオブジェクトの型もメソッド get_a があるので、関数 foo の引数として渡すことができます。OCaml の場合、(2) と (3) は (1) の「部分型 (subtypeing) 」になります。データ型を集合とみなした場合、部分型はある型の部分集合を表していると考えることができます。
</p>
<p> (1), (2), (3) はどれもメソッド get_a: 'a を持つデータ型です。これを一つの大きな集合と考えます。(2) はその中で get_b: 'b を持つデータ型の集合を表しているので、(2) は (1) の部分集合と考えることができます。どうように、(3) は (1) の部分集合で、(2) の部分集合にもなっています。
</p>

<p> OCaml の部分型の規則を次に示します。
</p>
<pre class="item">
(a) &lt; メソッド名1 : 型1; ... ; メソッド名m: 型m &gt;
(b) &lt; メソッド名1 : 型1; ... ; メソッド名m: 型m; ...; メソッド名n: 型n &gt;
型 (b) は 型 (a) の部分型である
</pre>
<p> (b) は (a) と同じ型のメソッドをすべて含んでいて、そこにいくつかのメソッドを追加したものです。OCaml の場合、これが部分型になります。
</p>
<p> 一般的なオブジェクト指向では、クラスを「継承」することによって部分型が発生します。このように、継承を宣言することで部分型を生成する方法を「名前的部分型 (nomincal subtyping) 」といいます。これに対し、OCaml の場合は継承に関係なく部分型が発生することがあります。これを「構造的部分型 (structural subtyping) 」といいます。継承についてはあとで詳しく説明します。
</p>

<p> 関数 foo の場合、引数 obj の型は (1) の任意の部分型を表していると考えることができます。したがって、次のように部分型のオブジェクトであれば、関数 foo を呼び出すことができます。
</p>
<pre>
# foo (object method get_a = 10 method get_b = 20 end);;
- : int = 10
# foo (object method get_a = 1.234 method get_b = 20 method get_c = 30 end);;
- : float = 1.234
</pre>
<p> メソッド get_a の型は型変数 'a なので、任意のデータ型に対応することができます。このように、関数 foo はオブジェクトにメソッド get_a があれば動作します。もちろん、OCaml は静的な型チェックを行うので、get_a を持たないオブジェクトを foo に渡すと、コンパイルでエラーとなります。
</p>

<h4>●ダック・タイピング</h4>
<p> Python や Ruby など動的な型付けを行うプログラミング言語では、同じインターフェースが備わっているオブジェクトは同じデータ型とみなす、という手法 (考え方) があります。これを「ダック・タイピング」といい、よく用いられる手法のようです。ご参考までに、Ruby のプログラムを示します。
</p>
<pre class="list">
リスト 5 : ダック・タイピング (Ruby)

class Foo
  def initialize
    @a = 10
  end
  def get_a
    @a
  end
  def set_a(x)
    @a = x
  end
end

class Bar
  def initialize
    @a = 20
  end
  def get_a
    @a
  end
  def set_a(x)
    @a = x
  end
end

def foo(x)
  print x.get_a
end

foo(Foo.new)   # 10 と表示する
foo(Bar.new)   # 20 と表示する
</pre>
<p> クラス Foo と Bar は異なるクラスで継承関係もありません。この場合、Ruby は異なるデータ型と判断します。しかし、どちらのクラスにもメソッド get_a が定義されているので、関数 foo にインスタンスを渡して get_a を呼び出すことができます。動的なプログラミング言語では、このような「ダック・タイピング」を簡単に行うことができます。
</p>

<p> OCaml は静的に強く型付けされる言語ですが、構造的部分型によりダック・タイピングのようなプログラミングスタイルも可能になっています。もちろん、コンパイル時に静的な型チェックが行われるので、エラーを検出することもできます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml12.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml14.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>