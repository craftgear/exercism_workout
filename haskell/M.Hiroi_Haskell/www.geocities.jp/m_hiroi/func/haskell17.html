<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881790</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell16.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell18.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">モナド (1)</h3>
<p> いよいよ今回から Haskell の最難関といわれている「モナド (Monad) 」にチャレンジします。Haskell のモナドは Applicative を強化した型クラスです。今回はモナドの基本とリストモナドについて説明します。
</p>

<h4>●モナドとは？</h4>
<p> Haskell のモナドは Applicative, Functor と同様に型クラスのひとつです。モナドの定義をコマンド :info で調べると、次のように表示されます。
</p>

<pre>
Prelude&gt; :i Monad
class Monad m where
  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
  (&gt;&gt;) :: m a -&gt; m b -&gt; m b
  return :: a -&gt; m a
  fail :: String -&gt; m a
        -- Defined in `GHC.Base'
instance Monad Maybe -- Defined in `Data.Maybe'
instance Monad [] -- Defined in `GHC.Base'
instance Monad IO -- Defined in `GHC.Base'
</pre>
<p> ここで、関数 return と演算子 &gt;&gt;= に注目してください。この 2 つがモナドの主な機能です。m は Functor と Applicative と同様に型変数をひとつ取る型構築子になります。関数 return の型は a -&gt; m a なので、任意のデータを m の中に格納して返す働きをします。Applicative の関数 pure と同じ意味ですが、モナドは Applicative を継承していないので、引数を文脈に入れて返す関数として定義されています。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; return 1 :: Maybe Int
Just 1
Prelude&gt; return 1 :: [Int]
[1]
Prelude&gt; :m + Control.Monad.Instances
Prelude Control.Monad.Instances> return 1 :: Either a Int
Right 1
</pre>
<p> 引数を 1 とすると、文脈が Maybe であれば Just 1 に、リストであれば [1] に、Either であれば Right 1 になります。Either のモナドはモジュール Control.Monad.Instances に定義されています。なお、モナドはデータ型によって、Maybe モナド、リストモナド、Either モナドというように、データ型を付けて呼ばれています。
</p>

<p> &gt;&gt;= の型はちょっと難しいですね。第 1 引数 (左辺値) は m a なので、モナドを受け取ることがわかります。第 2 引数 (右辺値) は関数ですが、計算結果をモナドに格納して返します。つまり、演算子 &gt;&gt;= は左辺値のモナドから値を取り出し、それを関数に渡して評価し、その返り値 (モナド) をそのまま返す、という働きをします。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
Prelude&gt; Just 1 &gt;&gt;= \x -&gt; return (x * 2)
Just 2
Prelude&gt; Nothing &gt;&gt;= \x -&gt; return (x * 2)
Nothing
Prelude&gt; [1,2,3,4,5] &gt;&gt;= \x -&gt; return (x * 2)
[2,4,6,8,10]
Prelude&gt; [] &gt;&gt;= \x -&gt; return (x * 2)
[]
Prelude&gt; getLine &gt;&gt;= \x -&gt; return (reverse x)
hello, world
"dlrow ,olleh"
Prelude&gt; :m + Control.Monad.Instances
Prelude Control.Monad.Instances&gt; Right 1 &gt;&gt;= \x -&gt; return (x * 2)
Right 2
Prelude Control.Monad.Instances&gt; Left "error" &gt;&gt;= \x -&gt; return (x * 2)
Left "error"
</pre>
<p> 計算結果は return を使ってモナドに格納します。このとき、左辺のデータ型が Maybe であれば値は Just に格納され、リストであれば値はリストに、I/O アクションであれば IO に、Either であれば Right に格納されます。Nothing, 空リスト [ ], Left の場合は値がないので、それをそのまま返します。Functor や Applicative と同様にモナドでも文脈は保たれていることに注意してください。
</p>

<h4>●演算子 &gt;&gt;= で関数を連結する</h4>
<p> 演算子 &gt;&gt;= の返り値の型は m b なので、&gt;&gt;= を使って関数を連結していくことができます。このとき、モナドから取り出された値は右辺の関数の引数に渡されるので、&gt;&gt;= は「バインド (bind) 演算子」とか「束縛演算子」と呼ばれています。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; Just 1 &gt;&gt;= \x -&gt; return (x*2) &gt;&gt;= \x -&gt; return (x+10)
Just 12
Prelude&gt; Nothing &gt;&gt;= \x -&gt; return (x*2) &gt;&gt;= \x -&gt; return (x+10)
Nothing
Prelude&gt; [1,2,3,4,5] &gt;&gt;= \x -&gt; return (x*2) &gt;&gt;= \x -&gt; return (x+10)
[12,14,16,18,20]
Prelude&gt; [] &gt;&gt;= \x -&gt; return (x*2) &gt;&gt;= \x -&gt; return (x+10)
[]
</pre>
<p> 最初の関数は引数 x を 2 倍し、次の関数は引数 x に 10 を加算します。2 つの関数を &gt;&gt;= でつなげると、 x * 2 + 10 を計算する処理になります。左辺の値が Nothing や空リストの場合、&gt;&gt;= はそれをそのまま返すので、返り値も Nothing や空リストになります。
</p>
<p>もう一つ簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; Just 1 &gt;&gt;= \x -&gt; Just 'a' &gt;&gt;= \y -&gt; return (x, y)
Just (1,'a')
Prelude&gt; getLine &gt;&gt;= \x -&gt; getLine &gt;&gt;= \y -&gt; return (x++y)
hello,
world
"hello, world"
</pre>
<p> 最初に例では、Just 1 の 1 がラムダ式の引数 x に渡され、次に Just 'a' の 'a' がラムダ式の引数 y に渡されます。そして、最後に return (x, y) で x と y をタプルに格納して返します。次の例では、最初の getLine で文字列を読み取り、それをラムダ式の引数 x に渡します。そして、再度 getLine で文字列を読み取ってラムダ式の引数 y に渡し、その中で文字列を連結して返します。これで入力された 2 つの文字列を連結することができます。
</p>
<p> リストモナドの場合、リスト内包表記と同じ動作になります。簡単な例を示します。
</p>
<pre>
Prelude&gt; [(x, y)| x &lt;- [1,2,3], y &lt;- "abc"]
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
Prelude&gt; [1,2,3] &gt;&gt;= \x -&gt; "abc" &gt;&gt;= \y -&gt; return (x, y)
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
</pre>
<p> リスト内包表記はリストモナドの構文糖衣と考えることができます。
</p>

<h4>●自分でモナドを定義する</h4>
<p> それではここでモナドの理解を深めるため、私たちでモナドを定義してみましょう。型クラスの名前は Mmonad とします。Mmonad の定義は次のようになります。
</p>

<pre class="list">
リスト : Mmonad の定義

class Mmonad m where
  ret  :: a -&gt; m a
  bind :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p> return と演算子 &gt;&gt;= は Haskell の Prelude で使用されているので、ここでは ret と bind という名前にしました。ret の仕様は return と、bind の仕様は演算子 &gt;&gt;= と同じです。
</p>

<p> 次は Maybe、Either, IO, リスト を Mmonad のインスタンスに設定します。次のリストを見てください。
</p>
<pre class="list">
リスト : インスタンスの設定

-- Maybe
instance Mmonad Maybe where
  ret x = Just x
  Nothing `bind` _ = Nothing
  Just x `bind` f  = f x

-- Either
instance Mmonad (Either a) where
  ret x = Right x
  Left x `bind` _ = Left x
  Right x `bind` f = f x

-- IO
instance Mmonad IO where
  ret = return
  action `bind` f = do
    x &lt;- action
    f x

-- リスト
instance Mmonad [] where
  ret x = [x]
  xs `bind` f = concatMap f xs
</pre>
<p> ret の定義は Applicative の pure と同じです。bind の定義も簡単ですね。Maybe は左辺が Nothing であれば Nothing を返します。そうでなければ、左辺 Just x から値 x を取り出して、右辺の関数 f に渡して評価します。Either, IO の場合も同じです。
</p>

<p> リストの場合はちょっと複雑です。左辺の関数 f の返り値はリストに格納されているので、xs の要素に適用した結果を連結しないといけません。この処理は関数 concatMap を使うとうまくいきます。
</p>

<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; Just 1 `bind` \x -&gt; ret (x * 2)
Just 2
*Main&gt; Nothing `bind` \x -&gt; ret (x * 2)
Nothing
*Main&gt; Right 1 `bind` \x -&gt; ret (x * 2)
Right 2
*Main&gt; Left "error" `bind` \x -&gt; ret (x * 2)
Left "error"
*Main&gt; getLine `bind` \x -&gt; ret (reverse x)
hello, world
"dlrow ,olleh"
*Main&gt; [1,2,3,4,5] `bind` \x -&gt; ret (x * 2)
[2,4,6,8,10]
*Main&gt; [1,2,3] `bind` \x -&gt; "abc" `bind` \y -&gt; ret (x,y)
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
</pre>
<h4>●モナドと do 構文</h4>
<p> モナドは演算子 &gt;&gt;= を使わずに do 構文で操作することができます。do 構文はモナドの構文糖衣と考えることができます。次の例を見てください。
</p>
<pre>
Prelude&gt; getLine &gt;&gt;= \x -&gt; getLine &gt;&gt;= \y -&gt; return (x++y)
hello,
world
"hello,world"
Prelude&gt; do {x &lt;- getLine; y &lt;- getLine; return (x++y)}
hello,
world
"hello,world"
</pre>
<p> do 構文で実行される処理は演算子 &gt;&gt;= で連結されていると考えてください。getLine &gt;&gt;= \x -&gt; ... は、do 構文の中では x &lt;- getLine; ...; となります。ここで、ラムダ式の中で getLine &gt;&gt;= \y ... と続けると、do 構文の中では x &lt;- getLine; y &lt;- getLine; ... となります。do 構文の return はモナドの return と同じです。
</p>

<p> IO モナドだけではなく、ほかのモナドでも do 構文を使うことができます。簡単な例を示します。
</p>
<pre>
Prelude&gt; do { x &lt;- Just 1; y &lt;- Just 2; return (x, y)}
Just (1,2)
Prelude&gt; do {x &lt;- [1,2,3]; y &lt;- "abc"; return (x, y)}
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
</pre>
<p> モナドの演算子 &gt;&gt; は左辺が渡す値を無視して、右辺のモナドを返します。簡単な例を示します。
</p>
<pre>
Prelude&gt; Just 1 &gt;&gt; Just 2
Just 2
Prelude&gt; Nothing &gt;&gt; Just 2
Nothing
Prelude&gt; [1,2,3] &gt;&gt; [4,5,6]
[4,5,6,4,5,6,4,5,6]
Prelude&gt; [] &gt;&gt; [4,5,6]
[]
Prelude&gt; [y | _ &lt;- [1,2,3], y &lt;- [4,5,6]]
[4,5,6,4,5,6,4,5,6]
Prelude&gt; [y | _ &lt;- [1,2,3], y &lt;- []]
[]
</pre>
<p> Just 1 &gt;&gt; Just 2 は Just 1 &gt;&gt;= \_ -&gt; Just 2 と同じ意味で、左辺から渡される値 2 を捨てるだけです。左辺値が Nothing であれば、今までと同じく Nothing を返します。リストモナドの場合、リスト内包表記で [1,2,3] の要素を捨てることと同じ動作になります。
</p>
<p> また、次のように左辺から右辺に渡す値が不要な場合、演算子 &gt;&gt; を使うことができます。
</p>
<pre>
Prelude&gt; getLine &gt;&gt;= \x -&gt; print x &gt;&gt; print (reverse x)
hello, world
"hello, world"
"dlrow ,olleh"
</pre>
<p> &gt;&gt; print (reverse x) は &gt;&gt;= \_ -&gt; print (reverse x) と同じです。もちろん、do 構文でも同じことができます。
</p>
<pre>
Prelude&gt; do { x &lt;- getLine; print x; print (reverse x)}
hello, world
"hello, world"
"dlrow ,olleh"
</pre>
<p> print x の返り値 IO () は捨てられて、print (reverse x) が実行されます。
</p>

<h4>●MonadPlus と guard</h4>
<p> 次は、リスト内包表記の条件節をモナドで実現してみましょう。次の例を見てください。
</p>
<pre>
Prelude&gt; [x | x &lt;- [1..10], even x]
[2,4,6,8,10]
Prelude&gt; [1..10] &gt;&gt;= \x -&gt; if even x then return x else []
[2,4,6,8,10]
</pre>
<p> リストモナドは concatMap でリストを連結します。このとき、空リストは無視されるので、リストに格納された値だけが連結されて返されます。
</p>

<p> 次のように、モナドの途中で if の処理を行うこともできます。
</p>
<pre>
Prelude&gt; [1..10] &gt;&gt;= \x -&gt; (if even x then [()] else []) &gt;&gt; return x
[2,4,6,8,10]
Prelude&gt; do { x &lt;- [1..10]; if even x then [()] else []; return x}
[2,4,6,8,10]
</pre>
<p> 左辺が空リストの場合、リストモナドは空リストを返すことを利用しています。したがって、モナドで連結した処理の途中で空リストが返されると、それ以降の処理は結果が空リストになるのです。空リスト以外の値、たとえば、unit 型を格納したリストを返すと、それ以降の処理が実行されて、条件を満たすデータがリストに格納されて返されます。do 構文を使った場合も同じです。
</p>

<p> この処理はモジュール Contorl.Monad に定義されている関数 guard を使うと簡単です。guard の型を :t コマンドで調べてみると、次のように表示されます。
</p>
<pre>
Prelude Control.Monad> :t guard
guard :: MonadPlus m =&gt; Bool -&gt; m ()
</pre>
<p> guard には型クラス制約 MonadPlus が付けられています。:i コマンドで MonadPlus を調べてみましょう。
</p>
<pre>
Prelude Control.Monad&gt; :i MonadPlus
class Monad m =&gt; MonadPlus m where
  mzero :: m a
  mplus :: m a -&gt; m a -&gt; m a
        -- Defined in `Control.Monad'
instance MonadPlus [] -- Defined in `Control.Monad'
instance MonadPlus Maybe -- Defined in `Control.Monad'
</pre>
<p> MonadPlus は Monad を継承していて、関数 mzero と mplus の仕様が定義されています。MonadPlus はモナドにおける単位元 mzero と二項演算子 mplus を表す型クラスです。つまり、MonadPlus はモノイドのモナドバージョンなのです。もちろん、MonadPlus は Monad を継承しているので、モノイドの規則だけではなくモナドの規則も満たす必要があります。モナドの規則は次回以降に説明します。
</p>
<p> Maybe とリストの場合、MonadPlus は次のように定義されています。
</p>
<pre class="list">
リスト : Maybe とリストの MonadPlus

instance MonadPlus Maybe where
  mzero = Nothing
  Nothing `mplus` ys  = ys
  xs      `mplus` _ys = xs

instance MonadPlus [] where
  mzero = []
  mplus = (++)
</pre>

<p> Maybe モナドの場合、Monoid のデータ型 First と同じで、mplus は論理和 (||) のように短絡演算子として機能します。リストモナドは Monoid の定義と同じです。
</p>

<p> 関数 guard は MonadPlus を使って次のように定義されています。
</p>
<pre class="list">
リスト ; 関数 guard の定義

guard :: (MonadPlus m) =&gt; Bool -&gt; m ()
guard True  = return ()
guard False = mzero
</pre>
<p> guard は引数が真ならばユニットを格納したモナドを返し、そうでなければ mzero を返します。リストモナドの場合、mzero は空リストなので、それ以降のモナドの処理は結果が空リストになり、guard はガードとして機能します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude Control.Monad&gt; [1..10] &gt;&gt;= \x -&gt; guard(even x) &gt;&gt; return x
[2,4,6,8,10]
Prelude Control.Monad&gt; do {x &lt;- [1..10]; guard(even x); return x}
[2,4,6,8,10]
</pre>

<h4>●順列の生成</h4>
<p> それでは簡単な例題として、リストモナドを使って順列を生成する関数 permutation n xs を作ってみましょう。permutation はリスト xs から n 個の要素を選択して順列を生成します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 順列の生成

permutation :: Eq a =&gt; Int -&gt; [a] -&gt; [[a]]
permutation n xs = iter 0 [] where
  iter m ys
    | m == n    = return (reverse ys)
    | otherwise = do
        x &lt;- xs
        guard(x `notElem` ys)
        iter (m + 1) (x:ys)
</pre>
<p> 実際の処理は局所関数 iter で行います。引数 m が選んだ要素の個数、ys が選んだ要素を格納するリストです。m が n と等しい場合、順列が一つ完成したので、reverse で ys を反転してから return でリストに格納します。そうでなければ、xs から要素 x を一つ選び、guard で x が ys に含まれていないことを確認して、iter を再帰呼び出しします。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; permutation 2 [1,2,3,4]
[[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]]
*Main&gt; permutation 3 [1,2,3]
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
*Main&gt; permutation 3 [1,2,3,4]
[[1,2,3],[1,2,4],[1,3,2],[1,3,4],[1,4,2],[1,4,3],[2,1,3],[2,1,4],[2,3,1],[2,3,4]
,[2,4,1],[2,4,3],[3,1,2],[3,1,4],[3,2,1],[3,2,4],[3,4,1],[3,4,2],[4,1,2],[4,1,3]
,[4,2,1],[4,2,3],[4,3,1],[4,3,2]]
</pre>

<h4>●経路の探索</h4>
<p> モナドを使うと、<a href="haskell14.html#chap02">経路の探索 (2)</a> の「探索の一般化」で作成した関数 search と search' を一つのプログラムにまとめることができます。経路図とプログラムを再掲します。
</p>
<pre class="fig">
    Ｂ------Ｄ------Ｆ
  ／│      │          
Ａ  │      │          
  ＼│      │          
    Ｃ------Ｅ------Ｇ

      図 :経路図
</pre>
<pre class="list">
リスト : 経路の探索

-- 隣接リスト
adjacent :: [[Int]]
adjacent =
  [[1,2],
   [0,2,3],
   [0,1,4],
   [1,4,5],
   [2,3,6],
   [3],
   [4]]

-- 次の頂点へ進む
nextPath :: [Int] -&gt; [[Int]]
nextPath path@(x:xs) = [y:path | y &lt;- adjacent !! x, y `notElem` xs]

-- 解をリストに格納して返す
search :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; [a]
search _ _ _ [] = []
search isGoal nextState combine (x:xs) =
  if isGoal x then x : search isGoal nextState combine xs
  else search isGoal nextState combine (combine (nextState x) xs)

-- 解を一つだけ求める
search' :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; Maybe a
search' _ _ _ [] = Nothing
search' isGoal nextState combine (x:xs) =
  if isGoal x then Just x 
  else search' isGoal nextState combine (combine (nextState x) xs)
</pre>
<p> リストと Maybe を MonadPlus として扱うと、search と search' のデータ型は次のように表すことができます。
</p>
<pre class="item">
searchM :: MonadPlus m =&gt; (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; m a
</pre>
<p> 関数名は searchM としました。searchM の返り値の型を m a とし、型クラス制約 に MonadPlus m を指定します。すると、searchM の返り値は MonadPlus のインスタンスになります。プログラムは次のようになります。
</p>
<pre class="list">
リスト : モナドで統一する

searchM :: MonadPlus m =&gt; (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (b -&gt; [a] -&gt; [a]) -&gt; [a] -&gt; m a
searchM _ _ _ [] = mzero
searchM isGoal nextState combine (x:xs) =
  if isGoal x then return x `mplus` searchM isGoal nextState combine xs
  else searchM isGoal nextState combine (combine (nextState x) xs)

-- 深さ優先探索
dfsM :: Int -&gt; Int -&gt; [[Int]]
dfsM start goal =
  searchM (\x -&gt; head x == goal) nextPath (++) [[start]]

dfsM' :: Int -&gt; Int -&gt; Maybe [Int]
dfsM' start goal =
  searchM (\x -&gt; head x == goal) nextPath (++) [[start]]

-- 幅優先探索
bfsM :: Int -&gt; Int -&gt; [[Int]]
bfsM start goal =
  searchM (\x -&gt; head x == goal) nextPath (flip (++)) [[start]]

bfsM' :: Int -&gt; Int -&gt; Maybe [Int]
bfsM' start goal =
  searchM (\x -&gt; head x == goal) nextPath (flip (++)) [[start]]
</pre>
<p> searchM で最後の引数が空リストの場合、MonadPlus の mzero を返します。リストの場合は空リストが、Maybe の場合は Nothing が返されます。x がゴールに到達した場合、return x でモナドに格納し、mplus で searchM の返り値と連結します。リストの場合、mplus は演算子 ++ なので、見つけた解をリストに格納して返す動作になります。Maybe の場合、mplus は論理和と同じ動作になるので、ここで探索が打ち切られて Just x が返されます。
</p>
<p> あとは、searchM を使って深さ優先探索を行う関数 dfsM, dfsM' と幅優先探索を行う関数 bfsM, bfsM' を定義します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; fmap reverse $ dfsM 0 6
[[0,1,2,4,6],[0,1,3,4,6],[0,2,1,3,4,6],[0,2,4,6]]
*Main&gt; dfsM' 0 6
Just [6,4,2,1,0]
*Main&gt; fmap reverse $ dfsM' 0 6
Just [0,1,2,4,6]
*Main&gt; fmap reverse $ bfsM 0 6
[[0,2,4,6],[0,1,2,4,6],[0,1,3,4,6],[0,2,1,3,4,6]]
*Main&gt; fmap reverse $ bfsM' 0 6
Just [0,2,4,6]
</pre>
<h4>●リストモナドと非決定性計算</h4>
<p> Maybe の Nothing が「失敗」を表すことができるように、リストの空リストも失敗を表すことができます。逆に、ある計算が「成功」した場合、Maybe は結果を Just で表すことができます。リストの場合、複数の要素が格納されているので、どの要素が成功するのかわかりませんが、この中に計算が成功する要素が含まれていると考えます。
</p>

<p> そこで、リストの中から要素を一つ選ぶ処理を考えます。たとえば、ls !! n はリスト ls の n 番目の要素を取り出しますが、選ぶ要素を引数 n で指定する必要があります。これに対して、特別な指定をしないで無作為に要素を選ぶことを考えます。このような選択を「非決定的選択」といいます。
</p>

<p> ここで、非決定的選択は問題を解くのに都合のいい選択が行われると仮定します。つまり、複数の選択肢の中で解に導くものがいくつか存在するならば、そのうちの一つを選択するのです。たとえば、迷路で分かれ道にきた場合、その中から出口につながる道を一つ選ぶわけです。このような非決定的選択を含む処理 (計算) を「非決定性計算」とか「非決定性」といいます。
</p>

<p> このような都合のいい処理を現在のコンピュータで実現することは不可能ですが、バックトラックを使って近似的に実現することは可能です。つまり、ある要素を選んで条件を満たさない場合は、バックトラックして異なる要素を選択すればいいわけです。Haskell の場合、リストモナドはすべての組み合わせを生成するように動作するので、その中から条件を満たす解を探せばいいわけです。
</p>

<p> このように、リストモナドは「非決定性計算」をシミュレートしていると考えることができます。また、Haskell は遅延評価により必要になったときに新しい組み合わせを生成するので、多くのメモリを消費することなく効率的に処理することができます。
</p>

<h4>●論理パズル</h4>
<p> 簡単な例題として論理パズルを解いてみましょう。
</p>
<div class="question">
<b>[問題]</b>
<p> ３人の友達が、あるプログラミング競技会で１位、２位、３位になった。この３人は、名前も、好きなスポーツも、国籍も異なる。Michael はバスケットが好きで、アメリカ人よりも上位であった。イスラエル人の Simon はテニスをする者よりも上位であった。クリケットをするものが１位であった。誰がオーストラリア人か？ Richard はどのようなスポーツをするか？
</p>
<ul>
  <li>出典：Leon Sterling, Ehud Shapiro (著), 松田利夫 (訳), 『Prolog の技芸』, 共立出版, 1988, (278頁より)
</ul>
</div>
<p> 簡単な論理パズルなので、プログラムを作る前に考えてみてください。
</p>

<h4>●データ型の定義</h4>
<p> 最初に必要となるデータ型を定義しましょう。
</p>
<pre class="list">
リスト : データ型の定義

data Nation = US | IL | AU deriving (Eq, Show)
data Sports = Basket | Cricket | Tennis deriving (Eq, Show)
data Name   = Michael | Simon | Richard deriving (Eq, Show)
data Person = Person {name :: Name, rank :: Int, nation :: Nation, sports :: Sports} deriving Show
</pre>
<p> このデータをリストモナドで作成します。次のリストを見てください。
</p>
<pre class="list">
リスト : データの生成

makePerson :: Name -&gt; [Person]
makePerson name = do
  r &lt;- [1, 2, 3]
  n &lt;- [US, IL, AU]
  s &lt;- [Basket, Cricket, Tennis]
  return (Person name r n s)
</pre>
<p> &lt;- で順位 (1, 2, 3)、国籍 (US, IL, AU)、スポーツ (Basket, Cricket, Tennis) の中から要素を一つ選びます。Haskell は遅延評価を行うので、データが必要になるときに異なる要素が選ばれて、新しいデータが生成されます。
</p>

<h4>●補助関数の作成</h4>
<p> 次は問題を解くための補助関数を作ります。
</p>
<pre class="list">
リスト : 補助関数の定義

-- 国籍を探す
findNation :: Nation -&gt; [Person] -&gt; Person
findNation _ [] = error "findNation"
findNation x (y:ys) =
  if x == nation y then y else findNation x ys

-- スポーツを探す
findSports :: Sports -&gt; [Person] -&gt; Person
findSports _ [] = error "findSports"
findSports x (y:ys) =
  if x == sports y then y else findSports x ys

-- 名前以外で重複した要素があるか
isDuplicate :: Person -&gt; Person -&gt; Bool
isDuplicate x y =
  rank x == rank y || nation x == nation y || sports x == sports y

-- 同じ要素があるか
check :: Person -&gt; Person -&gt; Person -&gt; Bool
check a b c = isDuplicate a b || isDuplicate a c || isDuplicate b c
</pre>
<p> findNation は引数のリスト中から国籍が x と等しい要素を返します。findSports は好きなスポーツが x と等しい要素を返します。isDuplicate は引数 a と b に重複した要素があれば True を返します。要素が全て異なる場合は False を返します。関数 check は isDuplicate を呼び出して、引数 a, b, c に重複した要素があれば True を返します。
</p>
<h4>●論理パズルの解法</h4>
<p> 論理パズルの解法プログラムは次のようになります。
</p>
<pre class="list">
リスト : 論理パズルの解法

solver :: [[Person]]
solver = do
  m &lt;- makePerson(Michael)
  s &lt;- makePerson(Simon)
  r &lt;- makePerson(Richard)
  guard(not(check m s r))
  guard(sports m == Basket)
  guard(nation m /= US)
  guard(nation s == IL)
  guard(rank m &lt; rank(findNation US [m,s,r]))
  guard(rank s &lt; rank(findSports Tennis [m,s,r]))
  guard(rank(findSports Cricket [m,s,r]) == 1)
  return [m,s,r]
</pre>
<p> 最初に makePerson でデータを作成し、&lt;- で要素を一つ選んで局所変数 m, s, r にセットします。そして、check で順位、国籍、スポーツで要素が重複していないかチェックします。あとは問題の条件を guard でチェックしていくだけです。
</p>
<ol>
  <li> Michael の好きなスポーツはバスケットである。
  <li> Michael の国籍はアメリカではない。
  <li> Simon の国籍はイスラエルである。
  <li> Michael は国籍がアメリカの人よりも上位である。
  <li> Simon はテニスが好きな人よりも上位である。
  <li> クリケットが好きな人が１位である。
</ol>
<p> 最後に、return で見つけた解をリストに格納します。とても簡単ですね。実行結果は次のようになります。
</p>
<pre>
*Main&gt; solver
[[Person {name = Michael, rank = 2, nation = AU, sports = Basket},
  Person {name = Simon,   rank = 1, nation = IL, sports = Cricket},
  Person {name = Richard, rank = 3, nation = US, sports = Tennis}]]
</pre>
<p> 解は 1 通りで、１位が Simon, ２位が Michael, ３位が Richard になります。ちなみに、最後の条件がない場合は 2 通りの解が出力されます。興味のある方は試してみてください。
</p>
<h4>●モナドとパターンマッチング</h4>
<p> モナドの演算子 &gt;&gt;= の右辺は通常の関数なので、引数にパターンマッチングを使うことができます。パターンマッチングに失敗した場合、演算子 &gt;&gt;= と do 構文 (リスト内包表記) では動作が異なります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; Just "abcd" &gt;&gt;= \('a':s) -&gt; return ('a', s)
Just ('a',"bcd")
Prelude&gt; Just "Abcd" &gt;&gt;= \('a':s) -&gt; return ('a', s)
*** Exception: <interactive>:3:17-43: Non-exhaustive patterns in lambda

Prelude&gt; ["abcd"] &gt;&gt;= \('a':s) -&gt; return ('a', s)
[('a',"bcd")]
Prelude&gt; ["Abcd"] &gt;&gt;= \('a':s) -&gt; return ('a', s)
*** Exception: <interactive>:5:14-40: Non-exhaustive patterns in lambda

</pre>
<p> 演算子 &gt;&gt;= の場合、パターンマッチングで失敗するとエラーが送出されます。ところが、do 構文の場合は Monad の関数 fail が呼び出されます。次の例を見てください。
</p>
<pre>
Prelude&gt; do { ('a':s) &lt;- Just "abcd"; return ('a', s) }
Just ('a',"bcd")
Prelude&gt; do { ('a':s) &lt;- Just "Abcd"; return ('a', s) }
Nothing
Prelude&gt; do { ('a':s) &lt;- ["abcd"]; return ('a', s) }
[('a',"bcd")]
Prelude&gt; do { ('a':s) &lt;- ["Abcd"]; return ('a', s) }
[]
</pre>
<p> Maybe モナドの fail は Nothing を返すので、do の返り値は Nothing となります。同様に、リストモナドの fail は空リストを返すので、do の返り値は空リストになります。Maybe モナドとリストモナドの文脈が、失敗するかもしれない計算を表していると考えると、エラーを送出するよりも Nothing や空リストを返したほうが都合が良いことがあります。
</p>

<h4>●リストモナドと reads</h4>
<p> 関数 reads とリストモナドを組み合わせると簡単な構文解析を行うことができます。reads の型をコマンド :t で調べると次のように表示されます。
</p>

<pre>
Prelude&gt; :t read
read :: Read a =&gt; String -&gt; a
Prelude&gt; :t reads
reads :: Read a =&gt; ReadS a
Prelude&gt; :i ReadS
type ReadS a = String -&gt; [(a, String)]
        -- Defined in `Text.ParserCombinators.ReadP'
</pre>

<p> 型クラス制約に Read が指定されています。型クラス Read のインスタンスは、関数 read や reads を使って文字列をそのデータ型に変換することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; read "123" :: Int
123
Prelude&gt; read "123.456" :: Double
123.456
Prelude&gt; read "'a'" :: Char
'a'
Prelude&gt; read "\"hello, world\"" :: String
"hello, world"
Prelude&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
Prelude&gt; read "123 456" :: Int
*** Exception: Prelude.read: no parse
</pre>
<p> 関数 read は構文解析に失敗するとエラーを送出しますが、そうしたくない場合は関数 reads を使います。簡単な例を示します。
</p>
<pre>
Prelude&gt; reads "123 456" :: [(Int, String)]
[(123," 456")]
Prelude&gt; reads "123456" :: [(Int, String)]
[(123456,"")]
Prelude&gt; reads "    123456" :: [(Int, String)]
[(123456,"")]
Prelude&gt; reads "123.456" :: [(Int, String)]
[]
</pre>
<p> reads は変換した値とそれ以降の文字列をタプルにセットし、それをリストに格納して返します。reads は空白文字を区切り記号として扱うので、先頭の空白文字は読み飛ばしてくれます。構文解析に失敗した場合は空リストを返します。これはリストモナドと組み合わせるときに役に立ちます。
</p>

<p> それでは簡単な例題として文字列から「二分木」を生成する関数 readsTree を作ってみましょう。二分木のデータ型を再掲します。
</p>
<pre class="list">
リスト ; 二分木のデータ型

data Tree a = Nil | Node a (Tree a) (Tree a) deriving Show
</pre>
<p> この二分木を次のような文字列で表すことにします。
</p>
<pre class="item">
Nil =&gt; #
Node 1 Nil Nil =&gt; &lt;1##&gt;
Node 2 (Node 1 Nil Nil) (Node 3 Nil Nil) =&gt; &lt;2&lt;1##&gt;&lt;3##&gt;&gt;
</pre>
<p> Nil は '#' で、Node は &lt;...&gt; で表します。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 二分木の読み込み

readsTree :: Read a =&gt; ReadS (Tree a)
readsTree "" = []
readsTree ('#':s) = return (Nil, s)
readsTree ('&lt;':s) = do
  (x, t) &lt;- reads s
  (l, u) &lt;- readsTree t
  (r, '&gt;':v) &lt;- readsTree u
  return (Node x l r, v)
readsTree (_:s) = readsTree s
</pre>

<p> readsTree の引数は文字列です。空文字列の場合は空リストを返します。先頭の文字が '#' であれば return で (Nil, s) をリストに格納します。次に、先頭の文字が '&lt;' であれば、reads で二分木の要素を読み込みます。次に、左部分木を readsTree で読み込み、最後に右部分木を readsTree で読み込み、return で (Node x l r, v) をリストに格納します。ここで、帰ってきた文字列の先頭文字が '>' であることを確認します。そうでなければマッチングに失敗して返り値は空リストになります。最後の節で、'#' と '&lt;' 以外の文字はスキップします。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; readsTree "#" ::[(Tree Int, String)]
[(Nil,"")]
*Main&gt; readsTree "&lt;2##&gt;" ::[(Tree Int, String)]
[(Node 2 Nil Nil,"")]
*Main&gt; readsTree "&lt;2&lt;1##&gt;#&gt;" ::[(Tree Int, String)]
[(Node 2 (Node 1 Nil Nil) Nil,"")]
*Main&gt; readsTree "&lt;2&lt;1##&gt;&lt;3##&gt;&gt;" ::[(Tree Int, String)]
[(Node 2 (Node 1 Nil Nil) (Node 3 Nil Nil),"")]
*Main&gt; readsTree "&lt;2&lt;1##&gt;&gt;3.1##&gt;&gt;" ::[(Tree Int, String)]
[]
*Main&gt; readsTree "&lt;2&lt;1##&gt;&lt;3##" ::[(Tree Int, String)]
[]
</pre>
<p> なお、型クラス Read は deriving することができるので、二分木に deriving で Read を指定すると、read や reads で二分木を読み込むことができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre class="list">
リスト ; 二分木のデータ型 (2)

data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Read, Show)
</pre>
<pre>
*Main&gt; read "Nil" :: Tree Int
Nil
*Main&gt; read "Node 1 Nil Nil" :: Tree Int
Node 1 Nil Nil
*Main&gt; read "Node 2 (Node 1 Nil Nil) Nil" :: Tree Int
Node 2 (Node 1 Nil Nil) Nil
*Main&gt; read "Node 2 (Node 1 Nil Nil) (Node 3 Nil Nil)" :: Tree Int
Node 2 (Node 1 Nil Nil) (Node 3 Nil Nil)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell16.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell18.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>