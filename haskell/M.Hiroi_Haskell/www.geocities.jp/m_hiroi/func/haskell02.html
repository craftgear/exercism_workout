<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881788</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell01.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">再帰定義</h3>
<p> 関数を定義するとき、その関数自身を呼び出すことを「再帰呼び出し (recursive call) 」とか「再帰定義 (recursive definition) 」といいます。関数の定義に自分自身を使うことができるなんて、何か特別な仕掛があるのではないかと思われるかもしれません。ところが、再帰定義は特別なことではありません。大昔のプログラミング言語ならばいざしらず、今では再帰呼び出しができないプログラミング言語のほうが珍しいでしょう。特に関数型言語の場合、再帰定義を積極的に活用してプログラミングを行うので、初心者の方が覚えるべき基礎テクニックのひとつにすぎません。慣れるまでちょっと苦労するかもしれませんが、ポイントさえつかめば簡単に使いこなすことができるようになります。
</p>

<h4>●再帰定義の基本</h4>
<p> まずは簡単な例を見てみましょう。階乗を計算するプログラムです。階乗の定義を図に示します。
</p>

<pre class="fig">
0! = 1
n! = n * (n - 1)!

図 : 階乗の定義
</pre>

<p> 階乗の定義からわかるように、n の階乗は n - 1 の階乗がわかれば求めることができます。実は、これをそのままプログラムすることができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 階乗

fact :: Integer -&gt; Integer
fact n = if n == 0 then 1 else n * fact (n - 1)

-- 記号 = の後ろで改行する場合
{-
fact n =
  if n == 0 then 1
  else n * fact (n - 1)
-}
</pre>

<p> 関数 fact は引数 n が 0 であれば 1 を返し、そうでなければ n * fact (n - 1) の計算結果を返します。fact の定義で fact 自身を呼び出しています。これが再帰呼び出しです。なお、記号 = の後ろで改行する場合はインデントをつけてください。Haskell では、-- から改行までがコメントになります。コメントはもう一種類あって、{- と -} で囲まれた範囲がコメントになります。
</p>

<p> それでは、本当にこれで階乗を計算できるのか、実際に試してみましょう。ファイル fact.hs にプログラムが書かれているとしましょう。対話モードで :load fact (または :l fact) と入力すると、ファイルがロードされて関数 fact を呼び出すことができるようになります。ghci を実行するときに、"C&gt; ghci fact.hs" のようにコマンドラインからファイル名を指定してもかまいません。
</p>
<pre>
Prelude> :l fact
[1 of 1] Compiling Main             ( fact.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; fact 4
24
*Main&gt; fact 10
3628800
</pre>
<p> ファイルをロードすると、プロンプトは *"ファイルに定義されているモジュール名" にかわります。モジュール名が省略されている場合は *Main になります。モジュールについては後の回で説明します。関数 fact を実行すると、確かに階乗の答えを求めることができました。
</p>

<h4>●再帰定義のポイント</h4>
<p> それでは、再帰定義のポイントを説明しましょう。次の図を見てください。
</p>

<pre class="fig">
Call:1    --&gt;  Call:2    --&gt;  Call:3    --&gt; Call:4    --&gt; Call:5
n:4            n:3            n:2           n:1           n:0
value 24  &lt;--  value : 6 &lt;--  value : 2 &lt;-- value : 1 &lt;-- value : 1 

        図 : fact の再帰呼び出し（n:引数の値, value:返り値
</pre>

<p> 上図は関数 fact 4 の呼び出しを表したものです。最初の呼び出し (Call:1) では、引数 n の値は 4 なので n の値を 1 減らして fact を再帰呼び出しします。2 回目の呼び出し (Call:2) では、引数 n は 3 に束縛されます。ここで、最初に呼び出したときと、2 回目に呼び出したときでは、引数 n の値が違うことに注意してください。
</p>

<p> 関数の引数は局所変数として扱われます。前回説明したように、局所変数には有効範囲（スコープ）があります。引数の場合、その関数が実行されている間だけ有効です。関数呼び出しが行われるたびに新しい局所変数を生成して、そこに値を束縛します。そして、関数の実行が終了すると、生成された局所変数は廃棄されます。つまり、1 回目の呼び出しと 2 回目の呼び出しでは、引数 n は名前が同じでも異なる変数になるのです。ここが再帰呼び出しを理解するポイントの一つです。
</p>

<p> プログラムを見ると変数 n は一つしかありませんが、再帰呼び出しが行われるたびに新しい変数 n が作られていくと考えてください。fact 4 を実行しているときの n は 4 であり、fact 3 を呼び出すときには、この n の値を書き換えるのではなく、新しい変数 n を用意して、そこに 3 を束縛するのです。
</p>

<p> 同様に再帰呼び出しが行われ、5 回目の呼び出し (Call:5) で引数 n が 0 になります。このとき、if の then 節が実行され 1 が返されます。ここで再帰呼び出しが止まります。これを再帰呼び出しの停止条件といいます。ここが第 2 のポイントです。
</p>

<p> 停止条件がなかったり、あってもその条件を満たさない場合、関数を際限なく呼び出すことになり、Haskell であればプログラムの実行は途中で停止します。再帰呼び出しを使う場合は、この停止条件に十分注意してください。
</p>

<p> fact 0 は 1 を返して fact 1 に戻ります。fact 1 を実行しているあいだ、引数 n の値は 1 です。したがって、fact 1 の返り値は 1 * 1 を計算して 1 となります。あとは同様に、再帰呼び出しした関数の返り値を使って値を計算し、最後に fact 4  の値 24 を求めることができます。
</p>

<h4>●フィボナッチ関数</h4>
<p> もうひとつ簡単な例を示しましょう。フィボナッチ関数も再帰的に定義される関数です。
</p>
<pre class="fig">
       ┌ 1                : n = 0
f(n) = ┤ 1                : n = 1
       └ f(n-1) + f(n-2)  : n &gt; 1

1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

        図 : フィボナッチ関数の定義
</pre>
<p> フィボナッチ関数も再帰定義を使えば簡単にプログラムできます。
</p>

<pre class="list">
リスト : フィボナッチ関数

fibo :: Integer -&gt; Integer
fibo n =
  if n == 0 || n == 1 then 1
  else fibo (n - 1) + fibo (n - 2)
</pre>
<p> 定義をそのままプログラムしただけです。それでは実行してみましょう。
</p>
<pre>
*Main&gt; fibo 0
1
*Main&gt; fibo 1
1
*Main&gt; fibo 2
2
*Main&gt; fibo 3
3
*Main&gt; fibo 4
5
*Main&gt; fibo 5
8
*Main&gt; fibo 10
89
*Main&gt; fibo 20
10946
</pre>
<p> 関数 fibo は fact とは違い、自分自身を 2 回呼び出しています。これを「二重再帰」といいます。fibo の呼び出しをトレースすると下図のようになります。
</p>

<pre class="fig">
f(5) ┬ f(4) ┬ f(3) ┬ f(2) ┬ f(1)
     │      │      │      │
     │      │      │      └ f(0)
     │      │      └ f(1)
     │      └ f(2) ┬ f(1)
     │              │
     │              └ f(0)
     │
     └ f(3) ┬ f(2) ┬ f(1)
             │      │
             │      └ f(0)
             └ f(1)

    図 : fibo のトレース
</pre>

<p> 同じ値を何回も求めているため、効率はとても悪いのです。もちろん、高速に求める方法があるので、心配しないで下さい。
</p>

<h4>●ユークリッドの互除法</h4>
<p> フィボナッチ関数は二重再帰でプログラムしたので実行速度はとても遅いのですが、再帰定義を使うと非効率的なプログラムになるというわけではありません。再帰定義でも効率的なプログラムを作ることができます。簡単な例題として、負でない整数 a と b の最大公約数を求めるプログラムを「ユークリッド (Euclid) の互除法」で作ってみましょう。まず最初に、ユークリッドの互除法を説明します。
</p>
<pre class="item">
[ユークリッドの互除法]
負でない整数 a と b (a &gt; b) で、a を b で割った余りを r とする。
このとき、a と b の最大公約数は b と r の最大公約数に等しい。
</pre>

<p> ユークリッドの互除法は簡単に証明できます。a と b の割り算を式 (1) で表します。
</p>

<pre class="item">
a = q * b + r --- (1)
</pre>

<p> ここで、a と b の最大公約数を m とすると、a = m * a', b = m * b' となります。すると、式 (1) は式 (2) で表すことができます。
</p>

<pre class="item">
m * a' = q * m * b' + r --- (2)
</pre>

<p> 左辺は m で割り切れるので、右辺も m で割り切れる必要があります。q * m * b' は m で割り切れるので、r も m で割り切れることになります。つまり、m は b と r の公約数であることがわかります。b と r の最大公約数を m' とすると、式 (3) が成り立ちます。
</p>
<pre class="item">
m &lt;= m' --- (3)
</pre>
<p> 次に、b = m' * b'', r = m' * r' として式 (1) に代入すると、式 (4) が成り立ちます。
</p>
<pre class="item">
a = q * m' * b'' + m' * r'  --- (4)
</pre>
<p> 右辺は m' で割り切れるので、a も m' で割り切れる必要があります。つまり、m' は a と b の公約数であることがわかります。したがって、式 (5) が成り立ちます。
</p>
<pre class="item">
m' &lt;= m --- (5)
</pre>
<p> 式 (3) と (5) より m = m' となり、a と b の最大公約数は b と r の最大公約数に等しいことが証明されました。
</p>

<p> あとは b を a とし、r を b にして同じ計算をすればいいわけです。この計算を繰り返し行うと、a と b はどんどん小さくなっていき、r = 0 になったときの b が最大公約数になります。
</p>

<p> プログラムは再帰定義を使って簡単に作ることができます。次のリストを見てください。関数 gcd は Haskell に定義されているので、ここでは関数名を gcd' としました。
</p>

<pre class="list">
リスト : 最大公約数

gcd' :: (Integer, Integer) -&gt; Integer
gcd' (a, b) =
  if b == 0 then a else gcd' (b, a `mod` b)
</pre>

<p> 関数 gcd' は引数 a と b の最大公約数を求めます。b が 0 の場合は a を返します。これが再帰呼び出しの停止条件になります。そうでなければ gcd' を再帰呼び出しして、b と a `mod` b の最大公約数を求めます。上のリストはユークリッドの互除法の定義をそのままプログラムしただけです。このように、再帰定義を使うと簡単にプログラムを作ることができます。
</p>
<p> それでは実行例を示しましょう。
</p>

<pre>
*Main&gt; gcd' (42, 30)
6
*Main&gt; gcd' (15, 70)
5
</pre>

<p> 最小公倍数は最大公約数を使って簡単に求めることができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 最大公倍数

lcm' :: (Integer, Integer) -&gt; Integer
lcm' (a, b) = a * b `div` gcd' (a, b)
</pre>

<p> Haskell には関数 lcm が定義されているので、ここでは関数名を lcm' としました。整数 a と b の最小公倍数は a * b / gcd' (a, b) で求めることができます。実行例を示します。
</p>

<pre>
*Main&gt; lcm' (5, 7)
35
*Main&gt; lcm' (14, 35)
70
</pre>

<h4>●組み合わせの数</h4>
<p> 次は組み合わせの数を求めるプログラムを作ってみましょう。ここでは組み合わせの数を <sub>n</sub>Ｃ<sub>r</sub> と表記します。<sub>n</sub>Ｃ<sub>r</sub> を求めるには、次の公式を使えば簡単です。
</p>
<pre class="item">
<sub>n</sub>Ｃ<sub>r</sub> = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>

<p> 皆さんお馴染みの公式ですね。ところが、整数値の範囲が限られているプログラミング言語では、この公式を使うと乗算で「桁あふれ」を起こす恐れがあります。Haskell は多倍長演算をサポートしているので、桁あふれを心配する必要はありません。
</p>

<p> この公式をそのままプログラムすることもできますが、次の式を使うともっと簡単にプログラムできます。
</p>

<pre class="item">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n</sub>C<sub>r-1</sub> * (n - r + 1) / r
</pre>
<p> この式は <sub>n</sub>Ｃ<sub>r</sub> と <sub>n</sub>Ｃ<sub>r-1</sub> の関係を表しています。あとは階乗と同じように、再帰定義を使って簡単にプログラムできます。次のリストを見てください。
</p>

<pre class="list">
リスト : 組み合わせの数を求める

comb :: (Integer,Integer) -&gt; Integer
comb (n, r) =
  if n == r || r == 0 then 1
  else comb (n, r - 1) * (n - r + 1) `div` r
</pre>
<p> 定義をそのままプログラムしただけです。それでは実行してみましょう。
</p>
<pre>
*Main&gt; comb (20, 10)
184756
*Main&gt; comb (30, 15)
155117520
*Main&gt; comb (40, 20)
137846528820
</pre>
<p> ところで、整数値の範囲が限られているプログラミング言語では、この方法でも桁あふれする場合があるので注意してください。
</p>

<h4>●累乗の計算</h4>
<p> 次は累乗を求める関数 pow を作ってみましょう。累乗は x の n 乗という x を n 回掛ける計算です。累乗は x の右上に小さく n を書くことで表されますが、ここでは x ** n と書くことにします。なお、Haskell には累乗を求める演算子 ^ が用意されています。
</p>
<pre class="fig">
pow (x, y) = x ** y

x ** 3 = x * x * x;
x ** 4 = x * x * x * x;
x ** 5 = x * x * x * x * x;

  図 : 累乗の計算
</pre>
<p> 今回のプログラムは、引数 x を Integer、y を Integer とします。そうすると、x ** y は次のように定義することができます。
</p>
<pre class="fig">
x ** 0 = 1
x ** y = x * (x ** (y - 1))

    図 : 累乗の定義
</pre>
<p> 階乗の場合と同様に、x ** y は x ** (y - 1) がわかれば求めることができます。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 累乗 (1)

pow :: (Integer, Integer) -&gt; Integer
pow (x, y) =
  if y == 0 then 1 else x * pow (x, y - 1)
</pre>
<pre>
*Main&gt; pow (2, 8)
256
*Main&gt; pow (2, 16)
65536
*Main&gt; pow (2, 32)
4294967296
</pre>
<p> 再帰定義を使って x ** y を計算しています。手続き型言語では単純な繰り返しで実現できる処理ですが、関数型言語では単純な繰り返しでも再帰定義を使って実現します。
</p>

<h4>●累乗の高速化</h4>
<p> 関数 pow は n 回の掛け算をしなくてはいけませんが、式を変形するともっと少ない回数で累乗を求めることがでます。次の式を見てください。
</p>
<pre class="fig">
x ** 4  = (x ** 2) ** 2 -&gt 2 回
x ** 8  = (x ** 4) ** 2 -&gt 3 回
x ** 16 = (x ** 8) ** 2 -&gt 4 回

一般化すると

x ** y = (x ** (y / 2)) ** 2       （n は偶数）
x ** y = ((x ** (y / 2)) ** 2) * x （n は奇数）

        図 : 累乗の高速化
</pre>
<p> 階乗の計算では n を n - 1 の計算に置き換えていきますが、累乗の場合は y を y / 2 に置き換えていくことができます。y が半分になっていくので減少の度合いが大きくなり、計算回数は少なくて済みます。これを単純にプログラムすると、次のようになります。
</p>

<pre class="list">
リスト : 累乗 (2)

pow' :: (Integer, Integer) -&gt; Integer
pow' (x, y) =
  if y == 0 then 1
  else if even y then pow' (x, y `div` 2) * pow' (x, y `div` 2)
  else x * pow' (x, y `div` 2) * pow' (x, y `div` 2)
</pre>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; pow' (2, 16)
65536
*Main&gt; pow' (2, 15)
32768
*Main&gt; pow' (2, 31)
2147483648
</pre>
<p> ところで、このプログラムは y が偶数の場合でも奇数の場合でも、pow' (x, y / 2) を 2 回呼び出していますね。このような場合、関数の中で局所変数を定義すると無駄を省くことができます。
</p>

<h4>●let 式による局所変数の定義</h4>
<p> Haskell の場合、let 式で局所変数を定義することができます。
</p>
<pre class="item">
let 変数 = 式1 in 式2
let {変数1 = 式1; 変数2 = 式2; ...} in 式n
</pre>
<p> let 式は let ... in の間にある式を評価して、その結果を変数に束縛します (正確にいうと変数の値が必要になったときに式が評価されます)。そして、in 以降の式を評価します。その評価結果が let 式の返り値になります。また、let 式を使って局所的な関数を定義することもできます。変数の有効範囲は let 式の中だけになります。
</p>
<p> 変数は複数定義することができますが、その場合は { } で囲ってセミコロン ( ; ) で区切ってください。ただし、ファイルに書き込む場合はインデントを揃えることで { } と ; を省略することができます。これはあとで説明します。
</p>

<p> 関数 pow' の場合、同じ計算を 2 回しているのは無駄なので、let を使って局所変数を定義しましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 累乗 (3)

pow'' :: (Integer, Integer) -&gt; Integer
pow'' (x, y) =
  if y == 0 then 1
  else let z1 = pow'' (x, y `div` 2)
           z2 = z1 * z1
       in if even y then z2 else x * z2
</pre>
<p> let で局所変数 z1 と z2 を定義します。let は式なので、if の then 節や else 節に入れてもかまいません。z1 の値は x ** (y/2) です。これは pow を再帰呼び出しすれば簡単に求めることができます。z2 の値は z1 * z1 になります。あとは、y が偶数であれば、z2 をそのまま返し、奇数であれば x * z2 を返します。このように、局所変数 z1 に pow (x, y `div` 2) の値を求めておくことで、累乗を効率的に計算することができます。
</p>

<h4>●レイアウト</h4>
<p> ところで、let で複数の変数を定義していますが、{ }  と ; が書かれていませんね。Haskell はインデントをそろえることで、{ } の範囲を指定することができます。このとき ; を省くことができます。この機能を「レイアウト」といいます。ルールは簡単で、let の後に出現する最初の変数名の位置にインデントを揃えます。次の例を見てください。
</p>
<pre class="list">
リスト : レイアウトの例

-- その１
let a = ...
    b = ...
    c = ...
in ...

-- その２
let
  a = ...
  b = ...
  c = ...
in ...
</pre>
<p> その１では、変数 a が 4 桁目から定義されているので、それ以降の変数定義は同じ位置 (4 桁目) から始めます。インデントが変わると、そこで { } の範囲が終了したと判断されます。また、let の後に改行を入れてもかまいません。その２では、最初に現れる変数 a が 2 桁目から定義されているので、他の変数も 2 桁目から定義します。
</p>

<h4>●where 節による局所変数の定義</h4>
<p> 局所変数は let 式だけではなく where 節を使って定義することもできます。もちろん、局所関数の定義もできます。累乗のプログラムを where 節を使って書き直すと次のようになります。
</p>

<pre class="list">
リスト : 累乗 (4)

pow''' :: (Integer, Integer) -&gt; Integer
pow''' (x, y) =
  if y == 0 then 1
  else if even y then z2
  else x * z2
  where z1 = pow''' (x, y `div` 2)
        z2 = z1 * z1
</pre>
<p> 式の後ろに where 節を定義します。where 節は式ではないので値を返すことはありません。where 節はレイアウトを使うことができます。この中で局所変数 z1 と z2 を定義します。where 節で定義された局所変数の有効範囲は、where 節の前に定義されている式になります。
</p>

<h4>●再帰定義によるリスト操作</h4>
<p> リストを操作する関数は再帰定義を使うと簡単に作ることができます。実は、リスト操作と再帰定義はとても相性が良いのです。まずは、リストの長さを求める関数 length' を作りましょう。 Hakell には length という同等の機能を持つ関数が用意されていますが、再帰定義を使えば私達でも簡単に作ることができます。
</p>

<p> まず、いちばん簡単な場合を考えます。引数が空リスト [ ] であれば 0 を返せばいいですね。あとは、リストが空リストになるように分解していけばいいのです。つまり、リスト xs の長さを求めるには、リスト xs に tail を適用したリストの長さがわかればいい、と考えるのです。それに 1 を足せば、リストの長さを求めることができます。これをプログラムすると、次のようになります。
</p>
<pre class="list">
リスト : リストの長さを求める

length' :: [a] -&gt; Int
length' xs =
  if null xs then 0
  else 1 + length (tail xs)
</pre>

<p> 関数 null xs は引数 xs が空リストであれば真 (True) を返し、そうでなければ偽 (False) を返します。引数 xs が空リストであれば 0 を返します。そうでなければ、引数 xs に関数 tail を適用して length' を再帰呼び出しします。リストに taill を繰り返し適用していくと最後は空リストになります。ここで再帰呼び出しが止まって 0 を返します。そうすると、1 + length' によって length' の返り値に 1 を足した値を返していきます。すなわち tail した回数だけ 1 が足されるわけです。
</p>

<h4>●多相型関数</h4>
<p> ところで、Haskell では格納するデータ型によってリストの型は変化します。もしも、[Integer] と [String] で異なる関数が必要だとしたら、とても面倒なことですね。ところが Haskell の場合、関数をひとつ定義するだけで、[Integer] にも [String] にも [Char] にも対応することができます。このような関数を「多相型関数 (polymorphic function) 」といいます。
</p>
<p> 多相型関数の極端な例に「恒等関数 (identity function) 」があります。次の例を見てください。
</p>
<pre>
*Main&gt; let identity x = x
*Main&gt; :t identity
identity :: t -&gt; t
*Main&gt; identity 10
10
*Main&gt; identity 1.2345
1.2345
*Main&gt; identity 'a'
'a'
*Main&gt; identity [1,2,3,4,5]
[1,2,3,4,5]
*Main&gt; identity (1, 'a')
(1,'a')
</pre>
<p> 関数 identity は引数をそのまま返す関数です。identity の型は t -&gt; t なので、任意の型のデータを受け取り、同じ型を返す関数であることがわかります。したがって、identity は Integer, Double, Char, [Integer] など、Haskell のデータ型であれば何でも対応することができます。なお、Haskell には identity と同じ働きをする関数 id が用意されています。
</p>
<p> length' の場合、任意の型 a を格納するリストを引数に取り、Int を返すことが示されています。つまり、引数が [Integer] でも [String] でも、リストであればその長さを返すことができます。このように、length' は多相型関数として定義されます。Haskell の関数 null, head, tail, fst, snd も多相型関数です。
</p>

<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; length' [1,2,3,4,5]
5
*Main&gt; length' ["foo", "bar", "baz"]
3
*Main&gt; length' []
0
</pre>
<p> 正常に動作していますね。Haskell は型チェックを厳密に行うプログラミング言語ですが、多相型関数により柔軟なプログラミングが可能になっています。
</p>

<h4>●リストの連結</h4>
<p> 次はリストを連結する演算子 ++ と同じ動作をする関数 append を作ってみましょう。引数としてリスト xs と ys を渡して、それを連結したリストを返します。
</p>
<p> 処理手順ですが、簡単な場合から考えていきましょう。まず、リスト xs が空リストならば、リスト ys を返すだけでいいですね。次に、リスト xs に要素が 1 つしかない場合を考えてみます。これは、リスト xs に head を適用して要素を取り出し、それをコンス演算子でリスト ys の先頭に追加すればいいでしょう。
</p>
<p> それでは、リスト x に要素が複数ある場合を考えてください。リスト xs を head と tail で分解します。そして、tail xs  と ys を連結したリストを求め、そのリストの先頭に head xs を追加すれば xs と ys を連結することができます。tail xs  と ys の連結は再帰呼び出しで実現することができます。これを図に示すと次のようになります。
</p>

<pre class="fig">
 ┌────────────────────────────┐ 
 │append( [1, 2], [3, 4] )                                │
 ├────────────────────────────┤
 │ [ 1,  2 ]                                              │
 │  ┬  ───tail─┐                                    │
 │ head             ↓                                    │
 │  │    ┌──────────────────────┐│
 │  │    │append( [2], [3, 4] )                       ││
 │  │    ├──────────────────────┤│
 │  │    │ [  2     ]                                 ││
 │  │    │    ┬── tail─┐                         ││
 │  │    │   head          ↓                         ││
 │  │    │    │  ┌────────────────┐││
 │  │    │    │  │append( [],  [3, 4] ) =&gt; [3, 4] │││
 │  │    │    │  └────────────────┘││
 │  │    │    │            │                        ││
 │  │    │    └─→ :  ←─┘                        ││
 │  │    │       [2, 3, 4]                            ││
 │  │    └─────┼────────────────┘│
 │  └──→  :   ←─┘                                  │
 └──────┼─────────────────────┘
               ↓
           [1, 2, 3, 4]

                    図：append の動作
</pre>

<p> これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : リストの結合

append :: ([a], [a]) -&gt; [a]
append (xs, ys) =
  if null xs then ys
  else head xs : append (tail xs, ys)
</pre>
<p>  引数 xs が空リストであればリスト ys をそのまま返します。これが再帰呼び出しの停止条件になります。そうでなければ、tail xs を append に渡して再帰呼び出しします。そして、その返り値と head xs をコンス演算子で接続します。これでリストを連結することができます。
</p>
<p> append も多相型関数になります。簡単な実行例を示します。
</p>
<pre>
*Main&gt; append ([1,2,3], [4,5,6])
[1,2,3,4,5,6]
*Main&gt; append ("foo", "bar")
"foobar"
*Main&gt; append (["foo", "bar"], ["baz", "oops"])
["foo","bar","baz","oops"]
</pre>
<h4>●リストの反転</h4>
<p> 今度はリストの要素を反転する関数 reverse' を作ってみましょう。Haskell には reverse という同等の機能を持つ関数が用意されていますが、再帰定義で簡単に作ることができます。reverse' は引数のリスト xs を head と tail で分解し、tail xs を反転させてから head xs を最後尾に追加することで実現できます。次の図を見てください。
</p>

<pre class="fig">
  [1, 2, 3]                                 [3, 2] ++ [1] =&gt; [3, 2, 1]  
        ↓                                  ↑
     [2, 3]                   [3] ++ [2] =&gt; [3, 2]
        ↓                    ↑
        [3]     nil ++ [3] =&gt; [3]
        ↓      ↑
        nil ──┘

                図：reverse' の動作
</pre>

<p> これをプログラムすると、次のようになります。
</p>
<pre class="list">
リスト：リストの反転

reverse' :: [a] -&gt; [a]
reverse' xs =
  if null xs then []
  else reverse' (tail xs) ++ [head xs]
</pre>

<p> 引数 x が空リストの場合は [ ] を返します。そうでなければ、reverse' を再帰呼び出しして tail xs を反転し、演算子 ++ で反転したリストの最後尾に先頭の要素を追加します。
</p>
<p> reverse' も多相型関数になります。簡単な実行例を示します。
</p>
<pre>
*Main&gt; reverse' [1,2,3,4,5]
[5,4,3,2,1]
*Main&gt; reverse' ["foo", "bar", "baz"]
["baz","bar","foo"]
*Main&gt; reverse' "abcdefg"
"gfedcba"
</pre>
<h4>●リストの探索</h4>
<p> 次はリストからデータを探索する関数 member を作ってみましょう。関数の名前と動作は Common Lisp から拝借しました。member はリストの中にデータがなければ空リスト [ ] を返します。データを見つけた場合は、そのリストの残りを返します。つまり、返り値のリストの先頭要素が見つけたデータになります。
</p>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト：リストの探索

member :: Eq a =&gt; (a, [a]) -&gt; [a]
member (x, xs) =
  if null xs then []
  else if x == head xs then xs
  else member (x, tail xs)
</pre>

<p> 関数 member はリスト xs の中から x を探します。これは member を再帰呼び出ししてリストを分解し、リストの先頭要素をチェックしていくことで実現できます。xs が空リストの場合は x を見つけることができなかったので [ ] を返します。これが再帰の停止条件になります。次に、リスト xs の先頭の要素 head xs が x と等しいかチェックします。そうであれば、リスト xs をそのまま返します。そうでなければ、member を再帰呼び出しして次の要素を調べます。
</p>
<p> ここで member の型に注目してください。型クラス制約 Eq a が指定されていすね。Eq は等値演算子 ==, /= が定義されている型クラスです。つまり、型 a は等値演算子 (=, /=) を適用できる型に限られるわけです。Integer, Double, Char, Bool など基本的な型は Eq <STRIKE>を継承しています。</STRIKE> のインスタンスです。また、等値演算子はタプルやリストにも適用できますが、<STRIKE>要素が Eq を継承している型</STRIKE> 要素の型が Eq のインスタンスでないとエラーになります。
</p>
<pre>
*Main&gt; (1, 2) == (1, 2)
True
*Main&gt; (1, 2) == (1, 3)
False
*Main&gt; [1,2,3,4] == [1,2,3,4]
True
*Main&gt; [1,2,3,4] == [1,2,3,5]
False
</pre>
<p> member は多相型関数ですが、データの比較で演算子 == を使っているため、要素の型が型クラス Eq で制限されているのです。それでは、簡単な実行例を示します。
</p>
<pre>
*Main&gt; member (5, [1,2,3,4,5,6,7,8])
[5,6,7,8]
*Main&gt; member (1, [1,2,3,4,5,6,7,8])
[1,2,3,4,5,6,7,8]
*Main&gt; member (8, [1,2,3,4,5,6,7,8])
[8]
*Main&gt; member (9, [1,2,3,4,5,6,7,8])
[]

*Main&gt; member ("foo", ["foo", "bar", "baz"])
["foo","bar","baz"]
*Main&gt; member ("baz", ["foo", "bar", "baz"])
["baz"]
*Main&gt; member ("a", ["foo", "bar", "baz"])
[]
</pre>
<p> member はリストを返しますが、真偽値を返すようにプログラムすることも簡単です。Haskell の関数 elem はデータを見つけたら True を、見つからなかったら False を返します。elem はカリー化関数という形式で定義されていますが、タプルを使ってプログラムすると次のようになります。
</p>
<pre class="list">
リスト：リストの探索 (2)

elem' :: Eq a =&gt; (a, [a]) -&gt; Bool
elem' (x, xs) =
  if null xs then False
  else if x == head xs then True
  else elem' (x, tail xs)
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; elem'(5, [1,2,3,4,5,6,7,8])
True
*Main&gt; elem'(1, [1,2,3,4,5,6,7,8])
True
*Main&gt; elem'(8, [1,2,3,4,5,6,7,8])
True
*Main&gt; elem'(9, [1,2,3,4,5,6,7,8])
False
</pre>
<div class="note">
-- <a name="update"><b>[修正 (2013/02/03)]</b></a> --------<br>
「継承」ではなく「インスタンス」を使うように修正しました。
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell01.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell03.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>