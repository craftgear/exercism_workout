<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Erlang プログラミング入門</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">

</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Erlang プログラミング入門</h2>
<div class="small">
[ <a href="abcerl01.html">PrevPage</a> | <a href="erlang.html">Erlang</a> | <a href="abcerl03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">再帰定義</h3>
<p> 関数を定義するとき、その関数自身を呼び出すことを「再帰呼び出し (recursive call)」とか「再帰定義 (recursive definition)」といいます。関数の定義に自分自身を使うことができるなんて、何か特別な仕掛があるのではないかと思われるかもしれません。ところが、再帰定義は特別なことではありません。大昔のプログラミング言語ならばいざしらず、今では再帰呼び出しができないプログラミング言語のほうが珍しいでしょう。
</p>

<p> ところが、Ｃ言語などの手続き型言語では、再帰定義を難しいテクニックの一つと思い込んでしまい、初心者の方は避けて通ることが多いように思います。再帰定義は、今まで説明した関数の呼び出しとまったく同じなので、難しく考える必要はありません。とくに関数型言語の場合、再帰定義を積極的に活用してプログラミングを行うので、初心者の方が覚えるべき基礎テクニックのひとつにすぎません。慣れるまでちょっと苦労するかもしれませんが、ポイントさえつかめば簡単に使いこなすことができるようになります。
</p>

<h4>●再帰定義の基本</h4>
<p> まずは簡単な例を見てみましょう。階乗を計算するプログラムです。階乗の定義を下図に示します。
</p>

<pre class="fig">
0! = 1
n! = n * (n - 1)!

図 : 階乗の定義
</pre>

<p> 階乗の定義からわかるように、n の階乗は n - 1 の階乗がわかれば求めることができます。実は、これをそのままプログラムすることができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 階乗

-module(fact).
-export([fact/1]).

fact(0) -> 1;
fact(N) -> N * fact(N - 1).
</pre>

<p> 関数 fact/1 は引数 N が 0 であれば 1 を返し、そうでなければ N * fact(N - 1) の計算結果を返します。fact の定義で fact 自身を呼び出しています。これが再帰呼び出しです。
</p>

<p> それでは、本当にこれで階乗を計算できるのか、実際に試してみましょう。
</p>
<pre>
&gt; c(fact).
{ok,fact}
&gt; fact:fact(4).
24
&gt; fact:fact(5).
120
&gt; fact:fact(6).
720
&gt; fact:fact(7).
5040
</pre>
<p> 確かに階乗の答えを求めることができました。
</p>

<h4>●再帰定義のポイント</h4>
<p> それでは、再帰定義のポイントを説明しましょう。次の図を見てください。
</p>

<pre class="fig">
Call:1    --&gt;  Call:2    --&gt;  Call:3    --&gt; Call:4    --&gt; Call:5
N:4            N:3            N:2           N:1           N:0
value 24  &lt;--  value : 6 &lt;--  value : 2 &lt;-- value : 1 &lt;-- value : 1 

        図 : fact の再帰呼び出し（n:引数の値, value:返り値)
</pre>

<p> 図は関数 fact(4) の呼び出しを表したものです。最初の呼び出し (Call:1) では、引数 N の値は 4 なので N の値を 1 減らして fact を再帰呼び出しします。2 回目の呼び出し (Call:2) では、引数 N は 3 に束縛されます。ここで、最初に呼び出したときと、2 回目に呼び出したときでは、引数 N の値が違うことに注意してください。
</p>

<p> 関数の引数は局所変数として扱われます。前回説明したように、局所変数には有効範囲（スコープ）があります。引数の場合、その関数が実行されている間だけ有効です。関数呼び出しが行われるたびに新しい局所変数を生成して、そこに値を束縛します。そして、関数の実行が終了すると、生成された局所変数は廃棄されます。つまり、1 回目の呼び出しと 2 回目の呼び出しでは、引数 N は名前が同じでも異なる変数になるのです。ここが再帰呼び出しを理解するポイントの一つです。
</p>

<p> プログラムを見ると変数 N は一つしかありませんが、再帰呼び出しが行われるたびに新しい変数 N が作られていくと考えてください。fact(4) を実行しているときの N は 4 であり、fact(3) を呼び出すときには、この N の値を書き換えるのではなく、新しい変数 N を用意して、そこに 3 を束縛するのです。
</p>

<p> 同様に再帰呼び出しが行われ、5 回目の呼び出し (Call:5) で引数 N が 0 になります。このとき、fact の最初の節が実行され 1 が返されます。ここで再帰呼び出しが止まります。これを再帰呼び出しの停止条件といいます。ここが第 2 のポイントです。停止条件がなかったり、あってもその条件を満たさない場合、関数を際限なく呼び出すことになり、プログラムは正常に終了しません。再帰呼び出しを使う場合は、この停止条件に十分注意してください。
</p>

<p> fact(0) は 1 を返して fact(1) に戻ります。fact(1) を実行している間、引数 N の値は 1 です。したがって、fact(1) の返り値は 1 * 1 を計算して 1 となります。あとは同様に、再帰呼び出しした関数の返り値を使って値を計算し、最後に fact(4)  の値 24 を求めることができます。
</p>

<h4>●ガード (Guard)</h4>
<p> ところで、関数 fact/1 に負の整数値を与えると、再帰呼び出しの停止条件が真にならないので、プログラムは正常に停止しません。Erlang のパターンマッチングにおいて、0 以上の整数値を表すパターンはありません。このような場合、when を使うと条件を指定することができます。when の構文を示します。
</p>
<pre class="item">
関数名(引数, ...) when 条件式 -&gt; 式, ..., 式;
     ・・・・・
関数名(引数, ...) when 条件式 -&gt; 式, ..., 式.

        図 : ガードの設定
</pre>
<p> パターンとの照合に成功して、かつ when の条件式が真を返す場合に限り右辺の式が評価されます。この機能を「ガード (Guard)」といいます。複数の条件式をカンマ (,) でつなげると論理積になり、セミコロン (;) でつなげると論理和になります。なお、when で指定できる条件式は if の条件式と同じで、制限があることに注意してください。詳細は Erlang のリファレンスマニュアル <a href="http://erlang.org/doc/reference_manual/expressions.html#guard-sequences">8.25  Guard Sequences</a> をお読みください。
</p>
<p> ガードを使って関数 fact/1 を書き直すと次のようになります。
</p>
<pre class="list">
リスト : 階乗 (ガード付き)

fact(0) -&gt; 1;
fact(N) when N &gt; 0 -&gt; N * fact(N - 1).
</pre>
<p> when で条件 N &gt; 0 を指定します。これで N が正のときに節が実行されます。簡単な実行例を示します。
</p>
<pre>
&gt; fact:fact(10).
3628800
&gt; fact:fact(-10).
** exception error: no function clause matching fact:fact(-10)
</pre>
<p> このように、負の値を入力するとエラーが表示されます。
</p>

<h4>●累乗の計算</h4>
<p> それでは簡単な例題として累乗を求める関数 pow/2 を作ってみましょう。累乗は x の n 乗という x を n 回掛ける計算です。累乗は x の右上に小さく n を書くことで表されますが、ここでは x ** n と書くことにします。
</p>
<pre class="fig">
pow (x, y) = x ** y

x ** 3 = x * x * x;
x ** 4 = x * x * x * x;
x ** 5 = x * x * x * x * x;

  図 : 累乗の計算
</pre>
<p> 今回のプログラムは引数 x, y を整数とします。そうすると、x ** y は次のように定義することができます。
</p>
<pre class="fig">
x ** 0 = 1
x ** y = x * (x ** (y - 1))

    図 : 累乗の定義
</pre>
<p> 階乗の場合と同様に、x ** y は x ** (y - 1) がわかれば求めることができます。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 累乗 (1)

-module(pow).
-export([pow/2]).

pow(_, 0) -&gt; 1;
pow(X, Y) when Y &gt; 0 -&gt; X * pow(X, Y - 1).
</pre>

<p> 再帰定義を使って X ** Y を計算しています。手続き型言語では単純な繰り返しで実現できる処理ですが、関数型言語では単純な繰り返しでも再帰定義を使って実現します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; pow:pow(2,8).
256
&gt; pow:pow(2,16).
65536
&gt; pow:pow(2,32).
4294967296
</pre>
<h4>●累乗の高速化</h4>
<p> 関数 pow(X, Y) は Y 回の掛け算をしなくてはいけませんが、式を変形するともっと少ない回数で累乗を求めることがでます。次の式を見てください。
</p>
<pre class="fig">
x ** 4  = (x ** 2) ** 2 -&gt; 2 回
x ** 8  = (x ** 4) ** 2 -&gt; 3 回
x ** 16 = (x ** 8) ** 2 -&gt; 4 回

一般化すると

x ** y = (x ** (y / 2)) ** 2       （y は偶数）
x ** y = ((x ** (y / 2)) ** 2) * x （y は奇数）

        図 : 累乗の高速化
</pre>
<p> 階乗の計算では N を N - 1 の計算に置き換えていきますが、累乗の場合は Y を Y / 2 に置き換えていくことができます。Y が半分になっていくので減少の度合いが大きくなり、計算回数は少なくて済みます。これを単純にプログラムすると、次のようになります。
</p>

<pre class="list">
リスト : 累乗 (2)

pow1(_, 0) -&gt; 1;
pow1(X, Y) when Y &gt; 0 -&gt;
    Z = pow1(X, Y div 2),
    ZZ = Z * Z,
    if
      Y rem 2 == 0 -&gt; ZZ;
      true -&gt; X * ZZ
    end.

% 別解
pow1(_, 0) -&gt; 1;
pow1(X, Y) when Y &gt; 0, Y rem 2 =:= 0 -&gt;
    Z = pow1(X, Y div 2),
    Z * Z;
pow1(X, Y) when Y > 0 -&gt;
    Z = pow1(X, Y div 2),
    X * Z * Z.
</pre>

<p> 変数 Z の値は X ** (Y / 2) です。これは pow1 を再帰呼び出しすれば簡単に求めることができます。ZZ の値は Z ** 2 になります。あとは、Y が偶数であれば、ZZ をそのまま返し、奇数であれば X * ZZ を返します。別解はガードで Y が偶数かチェックして、処理を 2 つの節に分けて記述しています。こちらのほうが Erlang らしいプログラムかもしれません。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; pow:pow1(2, 8).
256
&gt; pow:pow1(2, 16).
65536
&gt; pow:pow1(2, 32).
4294967296
&gt; pow:pow1(2, 64).
18446744073709551616
</pre>
<h4>●フィボナッチ関数</h4>
<p> もうひとつ簡単な数値計算の例を示しましょう。フィボナッチ関数も再帰的に定義される関数です。
</p>
<pre class="fig">
       ┌ 0                : n = 0
f(n) = ┤ 1                : n = 1
       └ f(n-1) + f(n-2)  : n &gt; 1

0, 1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

        図 : フィボナッチ関数の定義
</pre>
<p> フィボナッチ関数も再帰定義を使えば簡単にプログラムできます。
</p>

<pre class="list">
リスト : フィボナッチ関数

-module(fibo).
-export([fibo/1]).

fibo(0) -&gt; 0;
fibo(1) -&gt; 1;
fibo(N) when N &gt; 1 -&gt; fibo(N - 1) + fibo(N - 2).
</pre>

<p> 関数 fibo/1 は fact とは違い、自分自身を 2 回呼び出しています。これを「二重再帰」といいます。fibo の呼び出しをトレースすると下図のようになります。
</p>

<pre class="fig">
f(5) ┬ f(4) ┬ f(3) ┬ f(2) ┬ f(1)
     │      │      │      │
     │      │      │      └ f(0)
     │      │      └ f(1)
     │      └ f(2) ┬ f(1)
     │              │
     │              └ f(0)
     │
     └ f(3) ┬ f(2) ┬ f(1)
             │      │
             │      └ f(0)
             └ f(1)

        図 : fibo/1 のトレース
</pre>

<p> 同じ値を何回も求めているため、効率はとても悪いのです。もちろん、高速に求める方法があるので、心配しないで下さい。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; fibo:fibo(0).
0
&gt; fibo:fibo(1).
1
&gt; fibo:fibo(2).
1
&gt; fibo:fibo(3).
2
&gt; fibo:fibo(4).
3
&gt; fibo:fibo(5).
5
&gt; fibo:fibo(10).
55
&gt; fibo:fibo(20).
6765
</pre>
<h4>●ユークリッドの互除法</h4>
<p> フィボナッチ関数は二重再帰でプログラムしたので実行速度はとても遅いのですが、再帰定義を使うと非効率的なプログラムになるというわけではありません。累乗のプログラムのように、再帰定義でも効率的なプログラムを作ることができます。たとえば、負でない整数 a と b の最大公約数を求めるプログラムを「ユークリッド (Euclid) の互除法」で作ってみましょう。まず最初に、ユークリッドの互除法を説明します。
</p>
<pre class="item">
[ユークリッドの互除法]
負でない整数 a と b (a &gt; b) で、a を b で割った余りを r とする。
このとき、a と b の最大公約数は b と r の最大公約数に等しい。
</pre>

<p> ユークリッドの互除法は簡単に証明できます。a と b の割り算を式 (1) で表します。
</p>

<pre class="item">
a = q * b + r --- (1)
</pre>

<p> ここで、a と b の最大公約数を m とすると、a = m * a', b = m * b' となります。すると、式 (1) は式 (2) で表すことができます。
</p>

<pre class="item">
m * a' = q * m * b' + r --- (2)
</pre>

<p> 左辺は m で割り切れるので、右辺も m で割り切れる必要があります。q * m * b' は m で割り切れるので、r も m で割り切れることになります。つまり、m は b と r の公約数であることがわかります。b と r の最大公約数を m' とすると、式 (3) が成り立ちます。
</p>
<pre class="item">
m &lt;= m' --- (3)
</pre>
<p> 次に、b = m' * b'', r = m' * r' として式 (1) に代入すると、式 (4) が成り立ちます。
</p>
<pre class="item">
a = q * m' * b'' + m' * r'  --- (4)
</pre>
<p> 右辺は m' で割り切れるので、a も m' で割り切れる必要があります。つまり、m' は a と b の公約数であることがわかります。したがって、式 (5) が成り立ちます。
</p>
<pre class="item">
m' &lt;= m --- (5)
</pre>
<p> 式 (3) と (5) より m = m' となり、a と b の最大公約数は b と r の最大公約数に等しいことが証明されました。
</p>

<p> あとは b を a とし、r を b にして同じ計算をすればいいわけです。この計算を繰り返し行うと、a と b はどんどん小さくなっていき、r = 0 になったときの b が最大公約数になります。
</p>

<p> プログラムは再帰定義を使って簡単に作ることができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 最大公約数と最小公倍数

-module(gcd).
-export([gcd/2, lcm/2]).

# 最大公約数
gcd(A, 0) -&gt; A;
gcd(A, B) -&gt; gcd(B, A rem B).

% 最小公倍数
lcm(A, B) -&gt; A * B div gcd(A, B).
</pre>

<p> 関数 gcd/2 は引数 A と B の最大公約数を、関数 lcm/2 は最小公倍数を求めます。B が 0 の場合は A を返します。これが再帰呼び出しの停止条件になります。そうでなければ gcd を再帰呼び出しして、B と A rem B の最大公約数を求めます。上記リストはユークリッドの互除法の定義をそのままプログラムしただけです。このように、再帰定義を使うと簡単にプログラムを作ることができます。それから、整数 A と B の最小公倍数は A * B / gcd(A, B) で求めることができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; gcd:gcd(42, 36).
6
&gt; gcd:gcd(36, 42).
6
&gt; gcd:gcd(15, 70).
5
&gt; gcd:gcd(70, 15).
5
&gt; gcd:lcm(5, 7).
35
&gt; gcd:lcm(14, 35).
70
</pre>
<h4>●組み合わせの数</h4>
<p> 次は組み合わせの数を求めるプログラムを作ってみましょう。ここでは組み合わせの数を <sub>n</sub>Ｃ<sub>r</sub> と表記します。<sub>n</sub>Ｃ<sub>r</sub> を求めるには、次の公式を使えば簡単です。
</p>
<pre class="item">
<sub>n</sub>Ｃ<sub>r</sub> = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>
<p> 皆さんお馴染みの公式ですね。ところが、整数値の範囲が限られているプログラミング言語では、この公式を使うと乗算で桁あふれを起こす恐れがあります。Erlang は多倍長演算をサポートしているので、桁あふれを心配する必要はありません。
</p>
<p> この公式をそのままプログラムすることもできますが、次の式を使うともっと簡単にプログラムできます。
</p>
<pre class="item">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n</sub>C<sub>r-1</sub> * (n - r + 1) / r
</pre>
<p> この式は <sub>n</sub>Ｃ<sub>r</sub> と <sub>n</sub>Ｃ<sub>r-1</sub> の関係を表しています。あとは階乗と同じように、再帰定義を使って簡単にプログラムできます。次のリストを見てください。
</p>

<pre class="list">
リスト : 組み合わせの数を求める

-module(comb).
-export([combination_number/2]).

combination_number(N, N) -&gt; 1;
combination_number(_, 0) -&gt; 1;
combination_number(N, R) -&gt; combination_number(N, R - 1) * (N - R + 1) div R.
</pre>

<p> とても簡単ですね。ところで、整数値の範囲が限られているプログラミング言語では、この方法でも桁あふれする場合があるので注意してください。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
&gt; comb:combination_number(2, 0).
1
&gt; comb:combination_number(2, 1).
2
&gt; comb:combination_number(2, 2).
1
&gt; comb:combination_number(4, 0).
1
&gt; comb:combination_number(4, 1).
4
&gt; comb:combination_number(4, 2).
6
&gt; comb:combination_number(4, 3).
4
&gt; comb:combination_number(4, 4).
1
&gt; comb:combination_number(5, 3).
10
&gt; comb:combination_number(10, 5).
252
</pre>

<h4>●ハノイの塔</h4>
<p> 再帰といえば忘れてはいけないのが「ハノイの塔」でしょう。ハノイの塔は棒に刺さっている円盤を、次に示す規則に従ってほかの棒にすべて移動させる問題です。
</p>
<ol>
 <li>1 回に 1 枚の円盤しか動かせない。
 <li>小さな円盤の上に大きな円盤を乗せることはできない。
 <li>最初は 1 本の棒に、大きい円盤の上に小さな円盤が順番に刺さっている。
</ol>

<p> ハノイの塔は、再帰を使えば簡単に解ける問題です。たとえば、5 番目の円盤を左から中央の棒に移す場合、その上の 4 枚の円盤を右の棒に移しておけば、5 番目の円盤を動かすことができるようになります。そして、5 番目の円盤を中央に移したら、右の棒に移した 4 枚の円盤を中央の棒に移すことを考えればよいわけです。したがって、n 枚の円盤を左から中央の棒に移すプログラムは次のように表現できます。
</p>
<ol>
 <li>n - 1 枚の円盤を左から右に移す
 <li>n 枚目の円盤を左から中央へ移す
 <li>n - 1 枚の円盤を右から中央へ移す
</ol>
<p> これを素直にプログラムすると次のようになります。
</p>
<pre class="list">
リスト : ハノイの塔

-module(hanoi).
-export([hanoi/4]).

hanoi(1, From, To, _) -&gt; io:write({From, to, To});
hanoi(N, From, To, Via) -&gt;
    hanoi(N - 1, From, Via, To),
    io:write({From, to, To}),
    hanoi(N - 1, Via, To, From).
</pre>

<p> 引数 N は動かす円盤の枚数、From は移動元の棒、To は移動先の棒、Via は残りの棒を示します。円盤の枚数が 1 枚の場合は簡単です。From にある円盤を To へ移すだけです。これが再帰の停止条件になります。io:write() は標準出力にデータを出力する関数です。このプログラムでは移動手順をタプルで示しています。
</p>

<p> 2 番目の規則は、円盤が複数枚ある場合に対応します。hanoi を再帰呼び出しして、N - 1 枚の円盤を棒 Via に移動します。棒 From に残った円盤は 1 枚なので、それを棒 To に移動します。これを write で出力します。最後に、棒 Via に移した円盤を棒 To に移動します。ここでも再帰呼び出しが行われます。
</p>
<p> これで完成です。それでは実行してみましょう。
</p>

<pre>
&gt; hanoi:hanoi(3, a, b, c).
{a,to,b}{a,to,c}{b,to,c}{a,to,b}{c,to,a}{c,to,b}{a,to,b}ok
&gt; hanoi:hanoi(4, a, b, c).
{a,to,c}{a,to,b}{c,to,b}{a,to,c}{b,to,a}{b,to,c}{a,to,c}{a,to,b}{c,to,b}{c,to,a}
{b,to,a}{c,to,b}{a,to,c}{a,to,b}{c,to,b}ok
</pre>
<h4>●format</h4>
<p> きれいに印字したい場合はモジュール io に用意されている関数 format を使いましょう。この関数はＣ言語の関数 printf や Common Lisp の関数 format に相当する働きをします。format は表示に関していろいろな指定を行うことができますが、その分使い方が少しだけ複雑になります。
</p>
<pre class="item">
format('書式文字列', 引数リスト).
</pre>

<p> 第 1 引数は書式文字列で、出力に関する様々な指定を行います。これにはアトムを使います。format はアトムをそのまま出力するのですが、文字列の途中にチルダ ~ が表れると、その後ろの文字を変換指示子として理解し、引数リストのデータをその指示に従って表示します。よく使われる指示子を表に示します。
</p>
<table border=1>
<caption>表：foramt の変換指示子</caption>
<thead>
  <tr><th>指示子</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>w</td><td>項を Erlang の形式で表示する</td></tr>
  <tr><td>p</td><td>項を整形して表示する</td></tr>
  <tr><td>s</td><td>文字列を表示する</td></tr>
  <tr><td>e, f, g</td><td>浮動小数点数を表示 (Ｃ言語 printf と同じ)</td></tr>
  <tr><td>b</td><td>整数を表示 (2 - 32 までの基数を指定する)</td></tr>
  <tr><td>n</td><td>改行</td></tr>
  <tr><td>t</td><td>タブ</td></tr>
  <tr><td>~</td><td>チルダ</td></tr>
</tbody>
</table>

<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; io:format('~b ~.8b ~.16b ~n', [256, 256, 256]).
256 400 100
ok
</pre>
<p> 書式文字列の中には、複数の変換指示子を設定することができます。チルダの前までは、そのまま文字を表示します。チルダ ~ の次の文字 b, n が変換指示子です。b は整数値を表示する指示子で、n は改行を表す指示子です。b の場合、~ の後ろに "ドット + N" を指定すると、整数値を N 進数で表示することができます。与えるデータと指示子の数が合わないとエラーになります。ご注意くださいませ。
</p>
<p> アトムを表示する場合は w または p 変換指示子を使い、チルダを出力したい場合は ~~ と続けて書きます。このほかにも、浮動小数点数を表示する指示子などがあります。それらの機能は、必要になった時点で説明することにしましょう。
</p>

<p> format を使ってプログラムを書き換えると、次のようになります。
</p>

<pre class="list">
リスト：ハノイの塔

hanoi1(1, From, To, _) -&gt; io:format('~w to ~w~n', [From, To]);
hanoi1(N, From, To, Via) -&gt;
        hanoi1(N - 1, From, Via, To),
        io:format('~w to ~w~n', [From, To]),
        hanoi1(N - 1, Via, To, From).
</pre>

<p> それでは実行してみましょう。
</p>
<pre>
&gt; hanoi:hanoi1(3, a, b, c).
a to b
a to c
b to c
a to b
c to a
c to b
a to b
ok
</pre>
<h4>●パスカルの三角形</h4>
<p> もう一つ簡単な例題として、関数 combination_number/2 を使って「パスカルの三角形」を作ってみましょう。次の図を見てください。
</p>

<pre class="fig">
                １                                 0Ｃ0
              ／  ＼                              ／  ＼
            １      １                         1Ｃ0    1Ｃ1
          ／  ＼  ／  ＼                      ／  ＼  ／  ＼
        １      ２      １                 2Ｃ0    2Ｃ1    2Ｃ2
      ／  ＼  ／  ＼  ／  ＼              ／  ＼  ／  ＼  ／  ＼
    １      ３      ３      １         3Ｃ0    3Ｃ1    3Ｃ2    3Ｃ3
  ／  ＼  ／  ＼  ／  ＼  ／  ＼      ／  ＼  ／  ＼  ／  ＼  ／  ＼
１      ４      ６      ４      １ 4Ｃ0    4Ｃ1    4Ｃ2    4Ｃ3    4Ｃ4 

                       図 : パスカルの三角形
</pre>

<p> パスカルの三角形は、左側の図のように両側がすべて 1 で、内側の数はその左上と右上の和になっています。これは (a + b)<sup>n</sup> を展開したときの各項の係数を表しています。そして、その値は右側の図のように組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> に対応しています。
</p>
<p> きれいな三角形にはなりませんが、パスカルの三角形を表示するプログラムを示します。
</p>

<pre class="list">
リスト : パスカルの三角形

pascal_sub(N, 0) -&gt; io:format('~w~n', [combination_number(N, 0)]);
pascal_sub(N, R) -&gt; io:format('~w ', [combination_number(N, R)]), pascal_sub(N, R - 1).

pascal(0) -&gt; pascal_sub(0, 0);
pascal(N) -&gt; pascal(N - 1), pascal_sub(N, N).
</pre>
<p> 関数 pascal/1 は N + 1 段のパスカルの三角形を表示します。関数 pascal_sub/2 は (N, 0) から (N, N) までの combination_number/2 の値を表示します。pascal(N) は pascal(N - 1) を再帰呼び出ししてから pascal_sub(N, N) を呼び出しているところに注意してください。これにより 0 から順番に値が表示されます。pascal_sub は簡単ですね。format で combination_number(N, R) の値を表示するだけです。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
&gt; comb:pascal(10).
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
1 10 45 120 210 252 210 120 45 10 1
ok
</pre>

<h4>●相互再帰</h4>
<p> 相互再帰とは、関数 foo が関数 bar を呼び出し、bar でも foo を呼び出すというように、お互いに再帰呼び出しを行っていることをいいます。Erlang は相互再帰している関数でも簡単に定義することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 相互再帰

-module(recur).
-export([foo/1, bar/1]).

foo(0) -&gt; true;
foo(N) -&gt; bar(N - 1).
bar(0) -&gt; false;
bar(N) -&gt; foo(N - 1).
</pre>

<p> このプログラムは関数 foo/1 と bar/1 が相互再帰しています。foo と bar が何をしているのか、実際に動かしてみましょう。
</p>
<pre>
&gt; recur:foo(10).
true
&gt; recur:foo(11).
false
&gt; recur:bar(11).
true
&gt; recur:bar(12).
false
</pre>
<p> 結果を見ればおわかりのように、foo は N が偶数のときに真を返し、bar は N が奇数のときに真を返します。なお、このプログラムはあくまでも相互再帰の例題であり、実用的なプログラムではありません。
</p>

<h4>●末尾再帰</h4>
<p> 再帰定義のなかで、処理の最後で再帰呼び出しを行う場合を「末尾再帰 (tail recursion)」といいます。英語では tail recursion ですが、日本語では末尾再帰のほかに末端再帰とか終端再帰と呼ぶことがあります。末尾再帰は簡単な処理で繰り返しに変換できることが知られています。
</p>
<p> ML や Lisp などの関数型言語や論理型言語の Prolog では、プログラムをコンパイルもしくは実行するときに、末尾再帰を繰り返しに変換する処理系があります。この機能を「末尾再帰最適化」<sup><a href="abcerl02.html#note1">[*1]</a></sup> といいます。なかには Scheme のように、言語仕様に末尾再帰最適化を行うことを明記しているプログラミング言語もあります。
</p>

<p> たとえば、階乗を計算する関数 fact/1 を思い出してください。最初に定義した fact は最後に n と fact の返り値を乗算しているので、このプログラムは末尾再帰ではありません。これを末尾再帰に変換すると次のようになります。
</p>

<pre class="list">
リスト : 階乗 (末尾再帰)

facti(0, A) -&gt; A;
facti(N, A) -&gt; facti(N - 1, N * A).

facti(N) when N &gt; 0 -&gt; facti(N, 1).
</pre>
<pre>
&gt; fact:facti(9).
362880
&gt; fact:facti(10).
3628800
&gt; fact:facti(11).
39916800
</pre>
<p> 関数 facti/2 を見てください。2 番目の節で facti を再帰呼び出しして返り値をそのまま返しているので、このプログラムは末尾再帰になっています。これで階乗を計算できるなんて、ちょっと不思議に思われるかもしれません。そこが再帰呼び出しの面白いところです。このプログラムでは引数 A の使い方がポイントです。
</p>

<p> たとえば facti(4, 1) を実行すると、このプログラムでは 4 * 3 * 2 * 1 を計算します。このとき、計算の途中経過を引数 A に記憶しているのです。facti の呼び出し (末尾再帰最適化を適用する前の動作) をトレースすると次のようになります。
</p>

<pre class="fig">
facti(4, 1)
  facti(3, 4)
    facti(2, 12)
      facti(1, 24)
        facti(0, 24)
        =&gt; a の値 24 を返す
      =&gt; 24
    =&gt; 24
  =&gt; 24
=&gt; 24

  図 : facti() の動作
</pre>

<p> 引数 A には計算途中の値が格納されていることがわかります。このような変数を「累算変数」とか「累算器」といいます。
</p>

<p> 純粋な関数型言語の場合、while や for などの繰り返しがないプログラミング言語があります。Erlang や論理型言語 Prolog にも単純な繰り返しはありません。これらのプログラミング言語では、繰り返しのかわりに末尾再帰を用いてプログラミングを行い、末尾再帰最適化によりプログラムを高速に実行することができます。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 末尾再帰最適化は一般的な呼び方で、厳密には「末尾呼び出し最適化」とか「末尾最適化」といいます。詳しい説明は拙作のページ <a href="scheme.html">Scheme Programming</a> <a href="abcscm58.html">関数型電卓プログラム fncalc の作成 (4)</a> 末尾再帰とは？ をお読みください。
</div>

<h4>●フィボナッチ関数の高速化</h4>
<p> 今度は累算変数を使って、二重再帰を末尾再帰へ変換してみましょう。例題としてフィボナッチ関数を取り上げます。フィボナッチ関数の定義は二重再帰になっているので、そのままプログラムすると時間がかかります。二重再帰を末尾再帰に変換すると、プログラムを高速に実行することができます。次のリストを見てください。
</p>

<pre class="list">
リスト : フィボナッチ関数(末尾再帰)

fiboi(0, A, _) -&gt; A;
fiboi(N, A, B) -&gt; fiboi(N - 1, B, A + B).

fibo1(N) when N &gt; 0 -&gt; fiboi(N, 0, 1).
</pre>

<p> 累算変数 A と B の使い方がポイントです。現在のフィボナッチ数を変数 A に、ひとつ前の値を変数 B に格納しておきます。あとは A と B を足し算して、新しいフィボナッチ数を計算すればいいわけです。関数 fiboi/2 の呼び出しを図に示すと、次のようになります。
</p>
<pre class="fig">
fiboi(5, 0, 1)
  fiboi(4, 1, 1)
    fiboi(3, 1, 2)
      fiboi(2, 2, 3)
        fiboi(1, 3, 5)
          fiboi(0, 5, 8)
          =&gt; A の値 5 を返す
        =&gt; 5
      =&gt; 5
    =&gt; 5
  =&gt; 5
=&gt; 5

図 : 関数 fiboi/2 の呼び出し
</pre>
<p> 二重再帰では、同じ値を何回も求めていたため効率がとても悪かったのですが、このプログラムでは無駄な計算を行っていないので、値を高速に求めることができます。もちろん、末尾再帰になっているので、プログラムを高速に実行することができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
&gt; timer:tc(fibo, fibo, [38]).
{1859027,39088169}

&gt; timer:tc(fibo, fibo1, [38]).
{0,39088169}

&gt; timer:tc(fibo, fibo1, [100]).
{31000,354224848179261915075}

実行環境 : Windows 10, Intel Core i5-6200U 2.30GHz
</pre>
<p> timer:tc/3 が返す値はタプルで、最初の要素が計測した時間 (μsec) で、二番目の要素が関数の返り値です。fibo(38) を計算するのに約 2 秒ほどかかりますが、fibo1(38) ならば瞬時に終わります。fibo1(100) でも高速に計算することができます。
</p>
<p> 末尾再帰 (繰り返し) は再帰定義に比べると実行速度やメモリの消費量など効率の点で有利です。このため、何がなんでも繰り返しでプログラムしようとする方もいるでしょう。ところが、再帰定義を使うと簡単にプログラムできるのに、繰り返しではとても複雑なプログラムになってしまう場合もあります。したがって、とくに問題がなければ再帰定義を繰り返しに変換する必要はないと思います。複雑なプログラムは、しばらくたつと書いた本人でさえ理解できなくなることがよくあります。わかりやすいプログラムが一番だと思います。
</p>
<h4>●FizzBuzz 問題</h4>
<p> 最後に簡単な例題として FizzBuzz 問題を Erlang で解いてみましょう。FizzBuzz 問題は 1 から 100 までの値を表示するとき、3 の倍数のときは Fizz を、5 の倍数ときは Buzz を表示するというものです。FizzBuzz 問題の詳細については <a href="http://ja.wikipedia.org/wiki/Fizz_Buzz">Fizz Buzz - Wikipedia</a> をお読みください。
</p>
<p> 今回は fizz, buzz, fizzbuzz と小文字で表示することにします。プログラムは次のようになります。
</p>
<pre class="list">
リスト : FizzBuzz 問題 (fizzbuzz.erl)

-module(fizzbuzz).
-export([fizzbuzz/0]).

fizzbuzz(N) when N &gt; 100 -&gt; ok;
fizzbuzz(N) -&gt;
    X = if
            N rem 15 == 0 -&gt; fizzbuzz;
            N rem 3  == 0 -&gt; fizz;
            N rem 5  == 0 -&gt; buzz;
            true -&gt; N
        end,
    io:format('~p ', [X]),
    fizzbuzz(N + 1).

fizzbuzz() -&gt; fizzbuzz(1).

% 別解
check(N) when N rem 15 == 0 -&gt; io:format('fizzbuzz ');
check(N) when N rem 3 == 0 -&gt; io:format('fizz ');
check(N) when N rem 5 == 0 -&gt; io:format('buzz ');
check(N) -&gt; io:format('~p ', [N]).

fizzbuzz1(N) when N &gt; 100 -&gt; ok;
fizzbuzz1(N) -&gt; check(N), fizzbuzz1(N + 1).

fizzbuzz1() -&gt; fizzbuzz1(1).
</pre>
<p> fizzbuzz/1 も別解 fizzbuzz1/1 も難しいところはないと思います。それでは実行してみましょう。
</p>
<pre>
&gt; c(fizzbuzz).
{ok,fizzbuzz}
&gt; fizzbuzz:fizzbuzz().
1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 
fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 
fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 
fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz ok
</pre>
<p> 正常に動作していますね。
</p>
<hr>
<div align="right">
初出 2011 年 10 月 2 日<br>
改訂 2018 年 12 月 9 日
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011-2018 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcerl01.html">PrevPage</a> | <a href="erlang.html">Erlang</a> | <a href="abcerl03.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>