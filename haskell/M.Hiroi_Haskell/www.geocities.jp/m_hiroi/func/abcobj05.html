<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj04.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>多重継承</h3>
<p> 今回は「多重継承」について説明します。実をいうと、M.Hiroi は多重継承に対してあまりいいイメージを持っていません。私見ですが、多重継承はメリットよりもプログラムを複雑にするデメリットの方が大きいのではないか、と思っています。とくに、下図のクラス A, B, C, E のような菱形の関係をＣ++でプログラムする場合、とても複雑な問題を引き起こすことが知られています。
</p>
<pre class="fig">
      Ａ
    ／  ＼
  ／      ＼
Ｂ          Ｃ  
  ＼      ／
    ＼  ／
      Ｄ

図 1 : 多重継承
</pre>
<p> CLOS や Gauche の多重継承はクラスの優先順位が明確に定められているので、Ｃ++よりも扱いやすいと思います。しかしながら、CLOS や Gauche でも多重継承で問題が発生することもあります。多重継承は強力な機能ですが万能ではありません。多重継承は慎重に扱うべきだと思っています。
</p>

<h4>●多重継承の使い方</h4>
<p> 簡単な例題として、2 つのクラス &lt;foo&gt; と &lt;bar&gt; を継承するクラス &lt;baz&gt; を考えてみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト 1 : 多重継承

; &lt;foo&gt; の定義
(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-value 1 :init-keyword :a)))

; &lt;foo&gt; のメソッド
(define-method method-foo ((x &lt;foo&gt;)) (print "foo!"))
(define-method method-a ((x &lt;foo&gt;)) (print "foo method-a"))

; &lt;bar&gt; の定義
(define-class &lt;bar&gt; ()
  ((b :accessor bar-b :init-value 2 :init-keyword :b)))

; &lt;bar&gt; のメソッド
(define-method method-bar ((x &lt;bar&gt;)) (print "bar!"))
(define-method method-a ((x &lt;bar&gt;)) (print "bar method-a"))

; &lt;baz&gt; の定義
(define-class &lt;baz&gt; (&lt;foo&gt; &lt;bar&gt;) ())
</pre>

<p> クラス &lt;foo&gt; にはスロット a とメソッド foo-a, method-foo が、クラス &lt;bar&gt; にはスロット b とメソッド bar-b, method-bar が定義されています。そして、両方のクラスともメソッド method-a が定義されています。
</p>

<p> クラス &lt;baz&gt; で &lt;foo&gt; と &lt;bar&gt; を多重継承する場合、スーパークラスを指定するリストに &lt;foo&gt; と &lt;bar&gt; をセットするだけです。これで &lt;foo&gt; と &lt;bar&gt; を継承することができます。さっそく実行してみましょう。
</p>
<pre>
gosh&gt; (define a (make &lt;baz&gt;))
a
gosh&gt; a
#&lt;&lt;baz&gt; 0pb72480&gt;
gosh&gt; (foo-a a)
1
gosh&gt; (bar-b a)
2
gosh&gt; (method-foo a)
foo!
#&lt;undef&gt;
gosh&gt; (method-bar a)
bar!
#&lt;undef&gt;
gosh&gt; (is-a? a &lt;foo&gt;)
#t
gosh&gt; (is-a? a &lt;bar&gt;)
#t
gosh&gt; (is-a? a &lt;baz&gt;)
#t</pre>

<p> クラス &lt;baz&gt; にはスーパークラスから継承したスロット a と b があり、メソッドは foo-a, method-foo, bar-b, method-bar の 4 つがあります。&lt;baz&gt; のインスタンス a に foo-a を適用するとスロット a にアクセスし、bar-b を適用するとスロット b にアクセスすることができます。当然ですが、メソッド method-foo と method-bar も呼び出すことができます。
</p>
<p> それから、多重継承の場合でもデータ型は継承されます。クラス &lt;baz&gt; のインスタンス a は (is-a? a &lt;baz&gt;) を評価すると #t を返しますが、クラス &lt;foo&gt; と &lt;bar&gt; を継承しているので、is-a? は &lt;foo&gt; でも &lt;bar&gt; でも #t を返します。
</p>

<h4>●多重継承におけるメソッドの選択</h4>
<p> それでは、両方のクラスに定義されている method-a はどちらが評価されるのでしょうか。実際に実行してみましょう。
</p>
<pre>
gosh&gt; (method-a a)
foo method-a
#&lt;undef&gt;
</pre>
<p> foo method-a と表示されたので、クラス &lt;foo&gt; の method-a が評価されたことがわかります。このように、メソッドの探索はスーパークラスを格納するリストの先頭から順番 (左から右) に行われ、最初に見つかったメソッドが適用されます。これを「左優先則」といいます。したがって、スーパークラスの順番を逆にすると、次のように bar method-a と表示されます。
</p>
<pre>
gosh&gt; (define-class &lt;baz1&gt; (&lt;bar&gt; &lt;foo&gt;) ())
&lt;baz1&gt;
gosh&gt; (define b (make &lt;baz1&gt;))
b
gosh&gt; (method-a b)
bar method-a
#&lt;undef&gt;
</pre>

<p> では、&lt;foo&gt; と &lt;bar&gt; にスーパークラスが設定されている場合はどうなるのでしょうか。この場合、メソッドは「深さ優先」で探索されます。次の図を見てください。
</p>

<pre class="fig">
      Ａ    Ｂ    Ｃ  
      │    │    │
      │    │    │
      Ｄ    Ｅ    Ｆ
        ＼  │  ／
          ＼│／
            Ｇ

Ｇ→Ｄ→Ａ→Ｅ→Ｂ→Ｆ→Ｃ  

図 2 : 多重継承のメソッドの探索 (1)
</pre>

<p> クラス G は、クラス D, E, F を多重継承しています。D, E, F のスーパークラスはそれぞれ A, B, C です。クラス G でスーパークラスのリストが (D E F) であれば、最初にクラス D のメソッドを探索します。次は深さ優先で探索するので、クラス E ではなくクラス A を探索します。
</p>

<p> このように、スーパークラスを優先して探索し、それでも見つからないときはクラス E を探索します。したがって、探索順序は「G → D → A → E → B → F → C」となるのです。上図を経路と考えれば、まさに深さ優先探索そのものですね。これを「深さ優先則」といいます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
gosh&gt; (define-class &lt;foo1&gt; (&lt;foo&gt;) ())
&lt;foo1&gt;
gosh&gt; (define-class &lt;bar1&gt; (&lt;bar&gt;) ())
&lt;bar1&gt;
gosh&gt; (define-class &lt;baz2&gt; (&lt;foo1&gt; &lt;bar1&gt;) ())
&lt;baz2&gt;
gosh&gt; (define c (make &lt;baz2&gt;))
c
gosh&gt; c
#&lt;&lt;baz2&gt; 0pbbbe50&gt;
gosh&gt; (method-foo c)
foo!
#&lt;undef&gt;
gosh&gt; (method-bar c)
bar!
#&lt;undef&gt;
gosh&gt; (method-a c)
foo method-a
#&lt;undef&gt;
</pre>
<p> クラス &lt;foo1&gt; と &lt;bar1&gt; は &lt;foo&gt; と &lt;bar&gt; を単一継承し、クラス &lt;baz2&gt; は &lt;foo1&gt; と &lt;bar1&gt; を多重継承しています。次に &lt;baz2&gt; のインスタンスを生成し、変数 c にセットします。そして、(method-foo c) を呼び出すと、&lt;foo1&gt; -&gt; &lt;foo&gt; と探索して &lt;foo&gt の method-foo が見つかります。これを評価して foo! と表示されます。
</p>
<p> (method-bar c) を呼び出すと、&lt;foo1&gt; -&gt; &lt;foo&gt; -&gt; &lt;bar1&gt; -&gt; &lt;bar&gt; と探索して &lt;bar&gt; の method-bar が見つかります。これを評価して bar! と表示されます。(method-a c) を呼び出すと、&lt;foo1&gt; -&gt; &lt;foo&gt; を探索したところで method-a が見つかるので、このメソッドを評価して foo method-a と表示されます。
</p>

<p> では、次の場合はどうなるのでしょうか。
</p>
<pre class="fig">
      Ａ
    ／  ＼
  ／      ＼
Ｂ          Ｃ    Ｄ→Ｂ→Ｃ→Ａ  
  ＼      ／
    ＼  ／
      Ｄ

図 3 : 多重継承のメソッドの探索 (2)
</pre>

<p> あるクラスからスーパークラスをたどり、複数の経路で到達できるクラスを「合流点」といいます。上図の場合、クラス A は D - B - A と D - C - A という 2 つの経路があるので合流点になります。メソッドの探索で合流点にぶつかると、そこで探索を中断して次の経路を探索します。そして、最後の経路で合流点に到達したら、それ以降のスーパークラスを探索します。したがって、上図の探索順序は「D → B → C → A」となります。これを「合流則」といいます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
gosh&gt; (define-class &lt;foo-a&gt; () ())
&lt;foo-a&gt;
gosh&gt; (define-class &lt;foo-b&gt; (&lt;foo-a&gt;) ())
&lt;foo-b&gt;
gosh&gt; (define-class &lt;foo-c&gt; (&lt;foo-a&gt;) ())
&lt;foo-c&gt;
gosh&gt; (define-class &lt;foo-d&gt; (&lt;foo-b&gt; &lt;foo-c&gt;) ())
&lt;foo-d&gt;
gosh&gt; (define-method method-b ((x &lt;foo-a&gt;)) (print "foo-a method-b"))
#&lt;generic method-b (1)&gt;
gosh&gt; (define-method method-b ((x &lt;foo-c&gt;)) (print "foo-c method-b"))
#&lt;generic method-b (2)&gt;
gosh&gt; (define x (make &lt;foo-d&gt;))
x
gosh&gt; (method-b x)
foo-c method-b
#&lt;undef&gt;
</pre>
<p> 4 つのクラス &lt;foo-a&gt;, &lt;foo-b&gt;, &lt;foo-c&gt;, &lt;foo-d&gt; とメソッド method-b を定義します。method-b は &lt;foo-a&gt; と &lt;foo-c&gt; に定義します。&lt;foo-a&gt; が合流点であることに注意してください。&lt;foo-d&gt; のインスタンスを生成して method-b を呼び出すと、foo-c method-b と表示されますね。&lt;foo-a&gt; のメソッドではなく、&lt;foo-c&gt; のメソッドが適用されたことがわかります。
</p>

<p> このように Gauche は「適用可能なメソッド」を探索するのですが、実際にはもっと複雑な処理を行っています。Gauche や CLOS の場合、適用可能なメソッドとは「クラス優先順位リスト」と呼ばれるものの中で、一番最初にその引数特定子があらわれるものになります。
</p>
<p> Gauche の場合、クラスの優先順位リストは関数 class-precedence-list で求めることができます。
</p>
<pre>
gosh&gt; (class-precedence-list &lt;foo-d&gt;)
(#&lt;class &lt;foo-d&gt;&gt; #&lt;class &lt;foo-b&gt;&gt; #&lt:class &lt;foo-c&gt;&gt; #&lt;class &lt;foo-a&gt;&gt; 
#&lt;class &lt;object&gt;&gt; #&lt;class &lt;top&gt;&gt;)
</pre>
<p> クラス &lt;top&gt; は Gauche のオブジェクト指向システムの中で最上位のスーパークラスです。クラス &lt;object&gt; はユーザーが定義したクラスが暗黙のうちに継承するスーパークラスです。私たちが define-class で定義したクラスは、スーパークラスを指定しなくても &lt;object&gt; を継承しているわけです。
</p>

<p> このように、優先順位はリストの先頭の &lt;foo-d&gt; がいちばん高く、&lt;foo-a&gt; がいちばん低くなります。ここで、method-b の引数特定子は &lt;foo-c&gt; と &lt;foo-a&gt; がありますが、&lt;foo-c&gt; の優先順位が高いので &lt;foo-c&gt; のメソッドが適用されます。
</p>
<p> Gauche や CLOS の場合、このクラス優先順位を決めるアルゴリズムがとても複雑なのですが、たいていの場合は今まで説明した次の 3 つの規則を適用した結果と同じになります。
</p>
<ul>
  <li>左優先則
  <li>深さ優先則
  <li>合流則
</ul>
<p> 複雑な継承関係でなければ、これらの規則で十分理解できると思います。CLOS のクラス優先順位リストを決定するアルゴリズムは <a href="abcobj05.html#cite">参考文献 [1]</a> の付録で詳しく説明されています。興味のある方はお読みくださいませ。
</p>

<h4>●スーパークラスに同じスロット名がある場合</h4>
<p> <a href="abcobj03.html">継承</a> で説明しましたが、Gauche は define-class でスロットを定義するときに、スーパークラスと同じスロット名があってもかまいません。ただし、インスタンス内では、同じスロット名でアクセスできるスロットはひとつしか存在しません。これは多重継承でも同じです。次の例を見てください。
</p>
<pre>
gosh&gt; (define-class &lt;foo&gt; () ((a :accessor foo-a :init-value 1 :init-keyword :a)))
&lt;foo&gt;
gosh&gt; (define-class &lt;bar&gt; () ((a :accessor bar-a :init-value 2 :init-keyword :b)))
&lt;bar&gt;
gosh&gt; (define-class &lt;baz&gt; (&lt;foo&gt; &lt;bar&gt;) ())
&lt;baz&gt;
gosh&gt; (define x (make &lt;baz&gt;))
x
gosh&gt; (foo-a x)
1
gosh&gt; (bar-a x)
1
gosh&gt; (define y (make &lt;baz&gt; :a 10))
y
gosh&gt; (foo-a y)
10
gosh&gt; (bar-a y)
10
gosh&gt; (define z (make &lt;baz&gt; :b 100))
z
gosh&gt; (foo-a z)
1
</pre>
<p> クラス &lt;foo&gt; はスロット a を定義しています。クラス &lt;bar&gt; にも同じ名前のスロット a があります。そして、クラス &lt;baz&gt; は &lt;foo&gt; と &lt;bar&gt; を継承しています。この場合、&lt;baz&gt; のインスタンスを生成すると、a に対応するスロットはひとつしかありません。このとき、スロットオプションの優先順位はメソッドの選択と同じ方法で決定されます。
</p>
<p> :accessor で指定されたメソッド foo-a, bar-a はどちらも利用することができます。この場合、同じスロット a をアクセスすることになります。:init-value は「クラス優先順位リスト」と同じ規則で決定されます。この場合、左優先則でクラス &lt;foo&gt; の値が優先されます。したがって、(make &lt;baz&gt;) でインスタンスを生成すると、スロット a の初期値は 1 になります。実際に、メソッド foo-a, bar-a で値を求めると、1 に初期化されていることがわかります。:init-keyword は &lt;foo&gt; で指定した :a が優先されます。&lt;bar&gt; で指定した :b でスロット a の初期値を与えることはできません。
</p>

<h4>●多重継承の問題点</h4>
<p> ところで、多重継承を使う場合、異なる性質や機能を持つクラスを継承することがあります。たとえば、クラス &lt;foo&gt; にはメソッド method-a があり、クラス &lt;bar&gt; にはメソッド method-b があるとしましょう。この 2 つのメソッドはまったく異なる働きをします。ここで、メソッド method-a はスロット x を使っていて、method-b もスロット x を使っていると、多重継承で問題が発生します。
</p>
<p> クラス &lt;foo&gt; と &lt;bar&gt; を多重継承してクラス &lt;baz&gt; を作成した場合、クラス &lt;baz&gt; のインスタンスにはスロット x がひとつしかありません。メソッド method-a と method-b はひとつしかないスロット x を使うことになります。この場合、どちらかのメソッドは正常に動作しないでしょう。これでは多重継承する意味がありませんね。これが CLOS や Gauche における多重継承の問題点です。
</p>
<p> このように、多重継承はどんなクラスでもできるというわけではありません。同名のスロットを持つクラスは多重継承できないと考えた方がよいでしょう。それから、多重継承にはもうひとつ問題点があります。それはクラスの階層構造が複雑になることです。
</p>
<p> 単一継承の場合、クラスの階層は木構造になりますが、多重継承ではグラフになります。木構造の場合、クラスの優先順位は簡単にわかりますが、グラフになると優先順位を理解するのは難しくなります。多重継承は強力な機能ですが、使うときには十分な注意が必要なのです。
</p>

<h4>●Mix-in</h4>
<p> これらの問題を回避するため、スロット (属性) を継承するスーパークラスはひとつだけに限定して、あとのスーパークラスはメソッド (実装) だけを継承するという方法があります。この方法を Mix-in といいます。
</p>

<p> 具体的には、スロットを定義せずにメソッドだけを記述したクラスを用意します。属性の継承は単一継承になりますが、実装のみを記述したクラスはいくつ継承してかまいません。ひとつのクラスに複数の実装を混ぜることから Mix-in と呼ばれています。
</p>

<p> なお、Mix-in は特別な機能ではなく、多重継承を使いこなすための方法論にすぎません。多重継承を扱うことができるプログラミング言語であれば Mix-in を行うことが可能です。なお、もともと Mix-in は Flavors という Lisp にあるオブジェクト指向機能です。CLOS は Flavors の影響を強く受けています。この Mix-in を言語仕様に取り込んだのが Ruby です。
</p>

<p> Gauche は多重継承をサポートしているので、Mix-in を利用することができます。図 4 を見てください。
</p>

<pre class="fig">
                Ａ
              ／
            Ｂ
 Mixin A  ／  ＼    Mixin B
    ＼  ／      ＼  ／
      Ｃ          Ｄ

      図 4 : Mix-in
</pre>

<p> クラス C はクラス B を継承していて、そこにクラス Mixin A が Mix-in されています。クラス D もクラス B を継承していますが、Mix-in されているクラスは Mixin B となります。
</p>

<p> 多重継承の問題点は Mix-in ですべて解決できるわけではありませんが、クラスの階層構造がすっきりとしてわかりやすくなることは間違いありません。Mix-in は多重継承を使いこなす優れた方法だと思います。
</p>

<h4>●クラス &lt;enumerable&gt;</h4>
<p> それでは Mix-in の例題として、クラス &lt;enumerable&gt; を作ってみましょう。&lt;enumerable&gt; は &lt;dlist&gt; のような複数のデータを格納するクラス (コレクションクラス) に高階関数 (メソッド) を Mix-in します。これは Ruby のモジュール (Mix-in 用のクラス) Enumerable を参考にしました。追加するメソッドを表 1 に示します。
</p>
<table border=1>
<caption>表 1 : &lt;enumerable&gt; のメソッド</caption>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>enum-find obj func</td><td>func が真となる要素を返す</td></tr>
  <tr><td>enum-position obj func</td><td>func が真となる要素の位置を返す</td></tr>
  <tr><td>enum-count obj func</td><td>func が真となる要素の個数を返す</td></tr>
  <tr><td>enum-map obj func</td><td>要素に func を適用した結果をリストに格納して返す</td></tr>
  <tr><td>enum-filter obj func</td><td>func が真となる要素をリストに格納して返す</td></tr>
</tbody>
</table>

<p> なお、これらのメソッドは &lt;enumerable&gt; を Mix-in するクラスのメソッド enum-fold を呼び出して動作します。なお、畳み込みを使わずにイテレータを使う方法もあります。これは後で実際に試してみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト 2 : Mix-in 用のクラス &lt;enumerable&gt;

; クラス定義
(define-class &lt;enumerable&gt; () ())

; fold の定義
(define-method enum-fold ((d &lt;dlist&gt;) func init . opts)
  (apply dlist-fold d func init opts))

; func が真となる要素を返す
(define-method enum-find ((d &lt;enumerable&gt;) func)
  (call/cc
    (lambda (exit)
      (enum-fold d (lambda (a x) (if (func x) (exit x) #f)) #f))))

; func が真となる要素の位置を返す
(define-method enum-position ((d &lt;enumerable&gt;) func)
  (call/cc
   (lambda (exit)
     (enum-fold d (lambda (n x) (if (func x) (exit n) (+ n 1))) 0)
     #f)))

; func が真となる要素の個数を返す
(define-method enum-count ((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (n x) (if (func x) (+ n 1) n)) 0))

; マッピング
(define-method enum-map ((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (x a) (cons (func x) a)) '() :from-end #t))

; フィルター
(define-method enum-filter((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (x a) (if (func x) (cons x a) a)) '() :from-end #t))
</pre>

<p> クラス &lt;enumerable&gt; は Mix-in を前提としているので、スロットの定義は不要でメソッドだけを定義します。要素のアクセスは enum-fold で行います。enum-fold は Mix-in するクラスで定義されているものとします。つまり、enum-fold を定義さえすれば、どんなクラスでも &lt;enumberable&gt; を Mix-in することができるわけです。&lt;dlist&gt; の enum-fold は dlist-fold を呼び出すだけです。
</p>

<p> それでは、&lt;dlist&gt; と &lt;enumerable&gt; を継承したクラス &lt;enum-dlist&gt; を作って、実際に試してみましょう。
</p>
<pre>
gosh&gt; (define-class &lt;enum-dlist&gt; (&lt;dlist&gt; &lt;enumerable&gt;) ())
&lt;enum-dlist&gt;
gosh&gt; (define a (make &lt;enum-dlist&gt;))
a
gosh&gt; a
#<&lt;enum-dlist&gt; 0pbea6d8>
gosh&gt; (dotimes (x 5) (dlist-insert! a -1 x))
#t
gosh&gt; (dlist-&gt;list a)
(0 1 2 3 4)
gosh&gt; (enum-find a even?)
0
gosh&gt; (enum-find a odd?)
1
gosh&gt; (enum-position a (lambda (x) (&lt; 5 x)))
#f
gosh&gt; (enum-position a (lambda (x) (&lt; 2 x)))
3
gosh&gt; (enum-count a even?)
3
gosh&gt; (enum-map a (lambda (x) (* x x)))
(0 1 4 9 16)
gosh&gt; (enum-filter a even?)
(0 2 4)
</pre>
<p> 正常に動作していますね。複数のクラスで共通の操作 (メソッド) を定義したい場合、Mix-in はとても役に立ちます。
</p>
<p> ところで、&lt;dlist&gt; が &lt;enumerable&gt; を継承すれば、&lt;dlist&gt; のインスタンスに &lt;enumerable&gt; のメソッドを適用することができます。この場合、&lt;dlist&gt; を継承するクラス、たとえば &lt;fixed-dlist&gt; は &lt;enumerable&gt; を Mix-in しなくても &lt;enumerable&gt; のメソッドを利用することができます。また、&lt;dlist&gt; が &lt;enumerable&gt; を継承しない場合でも、&lt;fixed-dlist&gt; で &lt;enumerable&gt; を Mix-in すれば、&lt;fixed-dlist&gt; で &lt;enumerable&gt; のメソッドを利用することができます。
</p>
<h4>●イテレータを使う方法</h4>
<p> &lt;enumerable&gt; はメソッド enum-fold を呼び出すことで動作しますが、畳み込みのかわりにイテレータを使う方法もあります。Gauche のコレクションクラス &lt;collection&gt; を参考にプログラムを作ってみましょう。
</p>

<p> Gauche のコレクションクラスはハッシュ表 &lt;hash-table&gt;、リスト &lt;list&gt;、文字列 &lt;string&gt;、ベクタ &lt;vector&gt; などのスーパークラスで、複数のデータを格納するデータ構造 (コレクション) を表す抽象クラスです。&lt;collection&gt; を継承 (Mix-in) することで、&lt;collection&gt; のメソッドを利用できるようになります。このとき、基本となるメソッドが call-with-iterator です。
</p>
<pre class="item">
call-with-iterator collection proc [opts]
</pre>
<p> call-with-iterator は高段関数 (メソッド) で、関数 proc には 2 つの関数が渡されて呼び出されます。第 1 引数はコレクションの終了判定を行う関数、第 2 引数はコレクションの要素を順番に取り出す関数 (イテレータ) です。どちらの関数も引数はありません。proc はこれらの関数を使ってコレクションの要素を取り出して、適切な処理を行います。
</p>
<p> 双方向リスト用の call-with-iterator は次のようになります。
</p>
<pre class="list">
リスト : 双方向リスト用のイテレータ

(define-method call-with-iterator ((d &lt;dlist&gt;) proc . opts)
  (let* ((next (if (get-keyword :from-end opts #f) cell-prev cell-next))
         (cp (next (dlist-top d))))
    (proc
      (lambda () (eq? cp (dlist-top d)))
      (lambda ()
        (if (eq? cp (dlist-top d))
            #f
          (begin0 (cell-item cp)
                  (set! cp (next cp))))))))
</pre>
<p> どちらの関数もクロージャを使って実装します。第 1 引数に渡す終了判定用の関数は簡単ですね。第 2 引数に渡すイテレータは、変数 cp の要素を cell-item で取り出して、その後 cp の値を次のセルに更新します。これで、イテレータを呼び出すたびに、双方向リストの要素を順番に取り出していくことができます。
</p>
<p> call-with-iterator を使って &lt;enumerable&gt; を書き直すと、次のようになります。
</p>
<pre class="list">
リスト : Mix-in 用クラス (イテレータバージョン)

; Mix-in 用クラスの定義
(define-class &lt;enumerable1&gt; () ())

; func が真となる要素を返す
(define-method enum-find ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ()
        (if (end?)
            #f
          (let ((x (next)))
            (if (func x) x (loop))))))))

; func が真となる要素の位置を返す
(define-method enum-position ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((n 0))
        (if (end?)
            #f
          (let ((x (next)))
            (if (func x) n (loop (+ n 1)))))))))

; func が真となる要素の個数を返す
(define-method enum-count ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((c 0))
        (cond ((end?) c)
              ((func (next)) (loop (+ c 1)))
              (else (loop c)))))))

; マッピング
(define-method enum-map ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a '()))
        (if (end?)
            a
          (loop (cons (func (next)) a)))))
    :from-end #t))

; フィルター
(define-method enum-filter ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a '()))
        (if (end?)
            a
          (let ((x (next)))
            (if (func x) (loop (cons x a)) (loop a))))))
    :from-end #t))

; 畳み込み
(define-method enum-fold-left ((d &lt;enumerable1&gt;) func init)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a init))
        (if (end?)
            a
          (loop (func a (next))))))))

; 畳み込み
(define-method enum-fold-right ((d &lt;enumerable1&gt;) func init)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a init))
        (if (end?)
            a
          (loop (func (next) a)))))
    :from-end #t))
</pre>
<p> end? で &lt;enumberable1&gt; を継承したコレクションの終端をチェックし、next でその要素を取り出していくだけのなで、とくに難しいところはないと思います。簡単な実行例を示します。
</p>
<pre>
gosh&gt; (define-class &lt;enum-dlist1&gt; (&lt;dlist&gt; &lt;enumerable1&gt;) ())
&lt;enum-dlist1&gt;
gosh&gt; (define a (make &lt;enum-dlist1&gt;))
a
gosh&gt; (dotimes (x 8) (dlist-insert! a -1 (+ x 1)))
#t
gosh&gt; (dlist-&gt;list a)
(1 2 3 4 5 6 7 8)
gosh&gt; (enum-find a even?)
2
gosh&gt; (enum-position a even?)
1
gosh&gt; (enum-count a even?)
4
gosh&gt; (enum-map a (lambda (x) (* x x)))
(1 4 9 16 25 36 49 64)
gosh&gt; (enum-filter a even?)
(2 4 6 8)
gosh&gt; (enum-fold-left a (lambda (a x) (cons x a)) '())
(8 7 6 5 4 3 2 1)
gosh&gt; (enum-fold-right a (lambda (x a) (cons x a)) '())
(1 2 3 4 5 6 7 8)
</pre>
<p> 正常に動作していますね。双方向リストの場合、畳み込みとイテレータどちらの方法でも Mix-in を簡単に実現することができます。このほかにも、いくつかの方法が考えられますが、本ページの範囲を超えるので割愛いたします。Gauche のユーザリファレンス <a href="http://practical-scheme.net/gauche/man/gauche-refj_75.html#SEC223">9.3 gauche.collection - コレクションフレームワーク</a> にわかりやすい説明があるので、興味のある方はお読みください。
</p>

<p> ところで、実際に双方向リストを Gauche で使用するのであれば、&lt;enumerable&gt; のような独自のクラスを作成するよりも、&lt;collection&gt; または列 (シーケンス) を表すクラス &lt;sequence&gt; を継承したほうが便利です。そこで、次回は &lt;collection&gt; と &lt;sequence&gt; について詳しく説明します。
</p>

<h4 id="cite">●参考文献</h4>
<ol>
  <li>Patrick Henry Winston, Berthold Klaus Paul Horn, 『LISP 原書第 3 版 (1) (2)』, 培風館, 1992
</ol>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
;
; dlist1.scm : 双方向リスト (Mix-in のテスト)
;
;              Copyright (C) 2010 Makoto Hiroi
;

; セルの定義
(define-class &lt;cell&gt; ()
  ((item :accessor cell-item :init-value #f :init-keyword :item)
   (prev :accessor cell-prev :init-value #f :init-keyword :prev)
   (next :accessor cell-next :init-value #f :init-keyword :next)))

; 空リストを作る
(define (make-empty)
  (let ((cp (make &lt;cell&gt;)))
    (set! (cell-prev cp) cp)
    (set! (cell-next cp) cp)
    cp))

; 双方向リストの定義
(define-class &lt;dlist&gt; ()
  ((top :accessor dlist-top :init-form (make-empty))))

; n 番目のセルを返す (作業用関数)
(define (cell-nth d n next)
  (let loop ((i -1) (cp (dlist-top d)))
    (cond ((and (&lt;= 0 i) (eq? (dlist-top d) cp))
           (error "cell-nth --- oops!"))
          ((= n i) cp)
          (else
           (loop (+ i 1) (next cp))))))

; 参照
(define-method dlist-ref ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (cell-item
    (if (negative? n)
        (cell-nth d (abs (+ n 1)) cell-prev)       
      (cell-nth d n cell-next))))

; 書き換え
(define-method dlist-set! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (set! (cell-item (if (negative? n)
                       (cell-nth d (abs (+ n 1)) cell-prev)
                     (cell-nth d n cell-next)))
        value))

; 挿入
(define-method dlist-insert! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (define (cell-insert! n next prev)
    (let* ((p (cell-nth d (- n 1) next))
           (q (next p))
           (cp (make &lt;cell&gt; :item value)))
      (set! (next cp) q)
      (set! (prev cp) p)
      (set! (prev q) cp)
      (set! (next p) cp)))
  ;
  (if (negative? n)
      (cell-insert! (abs (+ n 1)) cell-prev cell-next)
    (cell-insert! n cell-next cell-prev)))

; 削除
(define-method dlist-delete! ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (define (cell-delete! n next prev)
    (let* ((cp (cell-nth d n next))
           (p (prev cp))
           (q (next cp)))
      (set! (next p) q)
      (set! (prev q) p)
      (cell-item cp)))
  ;
  (if (negative? n)
      (cell-delete! (abs (+ n 1)) cell-prev cell-next)
    (cell-delete! n cell-next cell-prev)))

; 畳み込み
(define-method dlist-fold ((d &lt;dlist&gt;) func init . args)
  (let ((next (if (get-keyword :from-end args #f) cell-prev cell-next)))
    (let loop ((cp (next (dlist-top d))) (a init))
      (if (eq? cp (dlist-top d))
          a
        (loop (next cp)
              (if (eq? next cell-prev)
                  (func (cell-item cp) a)
                (func a (cell-item cp))))))))

; サイズ
(define-method dlist-length ((d &lt;dlist&gt;))
  (dlist-fold d (lambda (x y) (+ x 1)) 0))

; クリア
(define-method dlist-clear ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (set! (cell-next cp) cp)
    (set! (cell-prev cp) cp)))

; 空リストか？
(define-method dlist-empty? ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (eq? cp (cell-next cp))))

; 変換
(define-method list-&gt;dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;dlist&gt;)))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))

;
(define-method dlist-&gt;list ((d &lt;dlist&gt;))
  (dlist-fold d
              (lambda (x y) (cons x y))
              '()
              :from-end #t))

; 巡回
(define-method dlist-for-each ((d &lt;dlist&gt;) func . args)
  (if (get-keyword :from-end args #f)
      (dlist-fold d (lambda (x y) (func x)) #f :from-end #t)
    (dlist-fold d (lambda (x y) (func y)) #f)))


;;; Mix-in 畳み込みバージョン

; enum-fold の定義
(define-method enum-fold ((d &lt;dlist&gt;) func init . opts)
  (apply dlist-fold d func init opts))

; Mix-in 用クラスの定義
(define-class &lt;enumerable&gt; () ())

; func が真となる要素を返す
(define-method enum-find ((d &lt;enumerable&gt;) func)
  (call/cc
    (lambda (exit)
      (enum-fold d (lambda (a x) (if (func x) (exit x) #f)) #f))))

; func が真となる要素の位置を返す
(define-method enum-position ((d &lt;enumerable&gt;) func)
  (call/cc
   (lambda (exit)
     (enum-fold d (lambda (n x) (if (func x) (exit n) (+ n 1))) 0)
     #f)))

; func が真となる要素の個数を返す
(define-method enum-count ((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (n x) (if (func x) (+ n 1) n)) 0))

; マッピング
(define-method enum-map ((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (x a) (cons (func x) a)) '() :from-end #t))

; フィルター
(define-method enum-filter((d &lt;enumerable&gt;) func)
  (enum-fold d (lambda (x a) (if (func x) (cons x a) a)) '() :from-end #t))

;;; Mix-in イテレータバージョン

; イテレータを渡して proc を実行する
(define-method call-with-iterator ((d &lt;dlist&gt;) proc . opts)
  (let* ((next (if (get-keyword :from-end opts #f) cell-prev cell-next))
         (cp (next (dlist-top d))))
    (proc
      (lambda () (eq? cp (dlist-top d)))
      (lambda ()
        (if (eq? cp (dlist-top d))
            #f
          (begin0 (cell-item cp)
                  (set! cp (next cp))))))))

; Mix-in 用クラスの定義
(define-class &lt;enumerable1&gt; () ())

; func が真となる要素を返す
(define-method enum-find ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ()
        (if (end?)
            #f
          (let ((x (next)))
            (if (func x) x (loop))))))))

; func が真となる要素の位置を返す
(define-method enum-position ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((n 0))
        (if (end?)
            #f
          (let ((x (next)))
            (if (func x) n (loop (+ n 1)))))))))

; func が真となる要素の個数を返す
(define-method enum-count ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((c 0))
        (cond ((end?) c)
              ((func (next)) (loop (+ c 1)))
              (else (loop c)))))))

; マッピング
(define-method enum-map ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a '()))
        (if (end?)
            a
          (loop (cons (func (next)) a)))))
    :from-end #t))

; フィルター
(define-method enum-filter ((d &lt;enumerable1&gt;) func)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a '()))
        (if (end?)
            a
          (let ((x (next)))
            (if (func x) (loop (cons x a)) (loop a))))))
    :from-end #t))

; 畳み込み
(define-method enum-fold-left ((d &lt;enumerable1&gt;) func init)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a init))
        (if (end?)
            a
          (loop (func a (next))))))))

; 畳み込み
(define-method enum-fold-right ((d &lt;enumerable1&gt;) func init)
  (call-with-iterator d
    (lambda (end? next)
      (let loop ((a init))
        (if (end?)
            a
          (loop (func (next) a)))))
    :from-end #t))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj04.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>