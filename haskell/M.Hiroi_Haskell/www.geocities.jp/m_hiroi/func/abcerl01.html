<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Erlang プログラミング入門</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">

</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Erlang プログラミング入門</h2>
<div class="small">
[ PrevPage | <a href="erlang.html">Erlang</a> | <a href="abcerl02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">はじめに</h3>
<p> Erlang (アーラン) は 1987 年ごろスウェーデンの電話会社 Ericsson (エリクソン) で開発された「関数型言語」です。Erlang は <a href="../prolog/index.html">Prolog</a> (論理型言語) の影響を強く受けているので、一般的な関数型言語とはちょっと毛色が異なっているところがあります。たとえば、リストのパターンマッチングは Prolog にそっくりで、このような関数型言語があったのかと M.Hiroi はとても驚きました。Prolog を知っていると、Erlang にもすぐに馴染めるのではないかと思っています。
</p>

<p> M.Hiroi は Erlang でプログラミングするのは初めてです。Erlang の特徴である「プロセス」による並行プログラミングを目標に、簡単なプログラムを作りながら Erlang を勉強していきたいと思っております。たいしたことはできませんが、よろしければお付き合いくださいませ。
</p>

<h4>●ダウンロード</h4>
<p> Erlang は次のサイトからダウンロードできます。Windows 用のバイナリが用意されているので、簡単にインストールすることができます。
</p>
<ul>
  <li><a href="http://www.erlang.org/">Erlang Programming Language</a>
</ul>
<p> なお、M.Hiroi がダウンロードしたインストーラではパス (環境変数 Path) の設定が行われません。Windows 10 でパスを設定する場合、コントロールパネル &gt; システムとセキュリティ &gt; システム の左端にある「システムの詳細設定」をクリックしてください。「システムのプロパティ」が表示されるので、その下側にある「環境変数」をクリックすると環境変数を設定することができます。
</p>
<p> コントロールパネルは スタートボタン > Windows システムツール > コントロールパネル で起動することができますが、シェルや「ファイル名を指定して実行」から control と打ち込んでも OK です。実はもうひとつ簡単な方法があって、[Windows] キーと [Pause] キーを同時に押すと、コントロールパネルのシステム画面を表示することができます。
</p>
<p> ubuntu 系の OS の場合、次のコマンドで Erlang をインストールすることができます。
</p>
<pre class="item">
sudo apt install erlang
</pre>
<p> なお、これでインストールされる Erlang は最新バージョンではないことに注意してください。
</p>
<h4>●プログラムの実行</h4>
<p> プログラムの実行は Eshell (Erlang shell) 上で行うと簡単です。Windows の場合、werl.exe を実行すると Eshell のウィンドウが開き、プログラムを入力して簡単に実行することができます。コマンドプロンプト (cmd.exe) や PowerShell で実行する場合は erl.exe を使います。Linux の場合はコマンド erl を実行してください。
</p>
<p> 終了する場合は halt(). または q(). を入力します。なお、Erlang では入力の終わりにピリオド ( . ) が必要になります。ご注意くださいませ。
</p>
<ul>
  <li>Windows 10
</ul>
<pre>
C&gt;erl
Eshell V10.1  (abort with ^G)
1&gt; halt().

C&gt;
</pre>
<ul>
  <li>xubunts 18.04
</ul>
<pre>
mhiroi@mhiroi-VirtualBox:~$ erl
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.2  (abort with ^G)
1&gt; halt().
mhiroi@mhiroi-VirtualBox:~$ 
</pre>
</ul>
<p> ただし、Eshell 上で関数を定義することはできません。プログラムはファイルに記述して、それを読み込むことになります。ファイルの拡張子は .erl です。ファイルの読み込みは Eshell に用意されている関数 c() を使います。c(filename) はファイル名 filename のファイルを読み込み、バイトコードにコンパイルします。たとえば、階乗を求める関数 fact がファイル fact.erl に記述されている場合は次のようになります。
</p>
<pre class="list">
リスト : 階乗

-module(fact).
-export([fact/1]).

fact(0) -&gt; 1;
fact(N) -&gt; N * fact(N - 1).
</pre>
<pre>
Eshell V9.2  (abort with ^G)
1&gt; c(fact).
{ok,fact}
2&gt; fact:fact(9).
362880
3&gt; fact:fact(10).
3628800
4&gt; fact:fact(20).
2432902008176640000
</pre>
<p> fact.erl をコンパイルすると fact.beam というファイルが生成されます。関数 l() を使って beam ファイルをロードすることもできます。
</p>
<pre>
Eshell V9.2  (abort with ^G)
1&gt; l(fact).
{module,fact}
2&gt; fact:fact(10).
3628800
</pre>

<p> なお、Erlang には HiPE (High Performance Erlang) というネイティブコードにコンパイルする仕組みが用意されています。たとえば、Eshell で c(fact, [native]). のように native を指定すると、ネイティブコードにコンパイルすることができます。ただし、HiPE はすべてのプラットフォームで利用できるわけではありません。M.Hiroi がダウンロードした Windows 版ではサポートされていませんでした。
</p>
<p> ubunts 系の OS の場合、HiPE が使用可能なパッケージ erlang-base-hipe と使用不可のパッケージ erlang-base の 2 つが用意されています。apt install erlang でインストールすると、後者のパッケージがインストールされるので、HiPE を使用することはできません。この場合、あとからパッケージ erlang-base-hipe をインストールすると、erlang-base と置き換えられて HiPE が有効になります。
</p>

<h4>●簡単なベンチマーク</h4>
<p> さて、気になる実行速度ですが、たらいまわし関数を使って調べてみました。
</p>
<pre class="list">
リスト : たらいまわし関数 (Erlang)

-module(tak).
-export([tak/3]).

tak(X, Y, Z) when X =&lt; Y -&gt; Z;
tak(X, Y, Z) -&gt; tak(tak(X - 1, Y, Z), tak(Y - 1, Z, X), tak(Z - 1, X, Y)).
</pre>

<p> それでは実行結果を示します。tak(22, 11, 0) を計算しました。なお、Erlang の時間計測には timer モジュールの関数 tc を使いました。
</p>

<pre>
Eshell V9.2  (abort with ^G)
1>&gt;c(tak).
{ok,tak}
2&gt; timer:tc(tak, tak, [22, 11, 0]).
{8015500,11}
3&gt; c(tak, [native]).               
{ok,tak}
4&gt; timer:tc(tak, tak, [22, 11, 0]).
{2225149,11}
</pre>
<p> 返り値はタプル (Tuple) で、先頭要素が時間 (μsec)、二番目の要素が関数の返り値です。
</p>
<table border=1>
<caption>表 : tak(22, 11, 0) の結果</caption>
<thead>
  <tr><th>処理系</th><th>秒</th></tr>
</thead>
<tbody>
  <tr><td>Python (ver 2.7.12+)</td><td>71.0</td></tr>
  <tr><td>Ruby (ver 2.3.1p112)</td><td>29.4</td></tr>
  <tr><td>Gauche (ver 0.9.4)</td><td>22.9</td></tr>
  <tr><td>ocamlc (ver 4.02.3)</td><td>16.6</td></tr>
  <tr><td>Erlang/OTP 20.2</td><td>8.02</td></tr>
  <tr><td>SBCL (ver 1.3.3)</td><td>5.20</td></tr>
  <tr><td>JavaScript (Node.js v4.2.6)</td><td>3.17</td></tr>
  <tr><td>SML/NJ (ver 110.79)</td><td>3.14</td></tr>  
  <tr><td>Erlang (HiPE)</td><td>2.23</td></tr>
  <tr><td>Julia (ver 1.0.0)</td><td>2.05</td></tr>
  <tr><td>Go (ver 1.6.3)</td><td>1.97</td></tr>
  <tr><td>SBCL (最適化)</td><td>1.67</td></tr>
  <tr><td>C# (Mono, ver 4.2.1.0)</td><td>1.63</td></tr>
  <tr><td>GCC -O2 (ver 6.2.0)</td><td>1.40</td></tr>
  <tr><td>Clang -O2 (ver 3.8.1)</td><td>1.20</td></tr>  
  <tr><td>Rust -O (ver 1.18)</td><td>1.20</td></tr>
  <tr><td>ocamlopt (ver 4.02.3)</td><td>1.11</td></tr>
</tbody>
</table>
<ul>
  <li>実行環境 : xubuntu 18.04 on VirtualBox, Intel Core i5-6200U 2.30GHz
</ul>

<p> バイトコードの場合、Erlang の実行速度は高速で、Python, Ruby, Gauche, ocamlc よりも速くなりました。HiPE を使うと、さらに高速化することができます。Ｃ/Ｃ++ にはかないませんが、JIT を使っている Node.js や Julia に匹敵する速度を叩き出しています。バイトコードでも十分に速いので、学習が目的であれば HiPE を使わなくてもよさそうです。興味のある方はいろいろ試してみてください。
</p>
<hr>
<div align="right">
初出 2011 年 10 月 2 日<br>
改訂 2018 年 12 月 9 日
</div>
</section>
<hr>
<section class="contents">
<h3 id="chap02">Erlang の基礎知識</h3>
<h4>●使ってみよう</h4>
<p> それでは、さっそく Erlang を使ってみましょう。Eshell を立ち上げてください。本稿では Eshell のプロンプトを &gt; で表すことにします。終了する場合は halt(). または q(). と入力してください。プロンプトのあとに式を入力すると、Eshell は式を評価して結果を返します。
</p>
<pre>
&gt; 1 + 2 * 3.
7
&gt; -3 * 4.
-12
</pre>
<p> 対話モードで式を入力する場合、最後にピリオド ( . ) を入力してからリターンキーを押します。1 + 2 * 3 の結果を見ると、値が 7 であることがわかります。負の数を表す場合、Erlang は普通の数式と同じく - を使います。
</p>
<h4>●整数と実数</h4>
<p> Erlang の場合、数には「整数 (integer)」と「浮動小数点数 (float)」の 2 種類があります。整数は 10 進数で表しますが、先頭に n# を付けると n 進数で表すことができます。
</p>
<pre>
&gt; 16#abcd.
43981
&gt; 8#777.
511
&gt; 2#1010.
10
</pre>
<p> Erlang の場合、多倍長整数をサポートしているので整数の範囲に制限はありません。Erlang の実数は IEEE754 形式という倍精度浮動小数点数で表されていて、範囲は絶対値で約 1.0e-323 から 1.0e+308 までになります。
</p>

<h4>●算術演算子</h4>
<p> ここで、よく使われる算術演算子をまとめておきましょう。
</p>
<ul>
  <li><b>+</b> 加算
  <li><b>-</b> 減算
  <li><b>*</b> 乗算
  <li><b>/</b> 除算
  <li><b>div</b> 整数除算の商
  <li><b>rem</b> 整数除算の剰余
</ul>

<p> 一般のプログラミング言語と同様に、四則演算は演算子 +, -, *, / を使います。ただし、Erlang で整数同士の割り算を行うと、結果は実数になることに注意してください。整数の割り算で商を求める場合は div を、剰余を求める場合は rem を使います。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; 1.234 + 5.678.
6.912
&gt; 1.234 * 5.678.
7.006652
&gt; 1.234 - 5.678.
-4.444
&gt; 1.234 / 5.678.
0.2173300457907714
&gt; 10 / 5.
2.0
&gt; 1 / 2.
0.5
&gt; 10 div 5.
2
&gt; 1 div 2.
0
&gt; 10 rem 5.
0
&gt; 10 rem 3.
1
</pre>
<h4>●アトム (atom)</h4>
<p> アトムは名前 (識別子) を表すデータ型です。プログラミング言語の場合、名前は英数字や特定の記号 (アンダーラインや @ など) を並べたものですが、Erlang の場合は英小文字から始めます。英大文字から始める場合や、空白などの記号を含めたい場合はクオート ( ' ) で囲ってください。
</p>
<pre>
&gt; foo.
foo
&gt; bar.
bar
&gt; baz.
baz
&gt; foo_bar.
foo_bar
&gt; 'foo bar'.
'foo bar'
</pre>
<p> Erlang の場合、アトムの値は自分自身になります。Eshell 上で foo, bar, baz を入力すると、入力したアトムがそのまま返されます。Lisp / Scheme のシンボル、Prolog のアトムと同様に、Erlang のアトムは記号として使うことができます。
</p>

<h4>●変数とパターンマッチング</h4>
<p> Erlang では、半角英大文字またはアンダーライン ( _ ) から始まる名前を「変数」として扱います。関数型言語では、変数に値を割り当てることを「束縛 (binding)」といいます。純粋な関数型言語の場合、束縛された変数は値を書き換えることができません。手続き型言語は代入により変数の値を書き換えることができますが、純粋な関数型言語に代入操作はありません。ちなみに、Lisp / Scheme は不純な関数型言語なので、変数の値を書き換えることができます。
</p>

<p> Erlang の場合、変数の束縛は「パターンマッチング」により行われます。そして、一度束縛された変数は、その後で値を参照することはできても、値を書き換えることはできなくなります。束縛されていない変数のことを「未束縛変数」もしくは「自由変数」といいます。未束縛変数はどのようなデータにでもマッチングします。この動作は Prolog の変数にそっくりです。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; X = 10.
10
&gt; X.
10
&gt; X + 10.
20
&gt; Y = X.
10
&gt; Y.
10
&gt; X = 20.
** exception error: no match of right hand side value 20
&gt; X = 10.
10
&gt; A = B.
* 1: variable 'B' is unbound
&gt; B = foo.
foo
&gt; A = B.
foo
&gt; A.
foo
</pre>
<p> 演算子 = はパターンマッチングを行います。最初、X は未束縛変数なので、X = 10. はマッチングに成功して X の値は 10 になります。その後、X の値を参照して X + 10 を計算したり、X の値を使って未束縛変数 Y とマッチングさせることができます。この場合、Y の値は 10 になります。
</p>
<p> ただし、X = 20. のように、X の値を書き換えることはできません。この場合、X の値 10 と整数値 20 を照合しますが、値が等しくないのでマッチングは失敗してエラーになります。また、X = 10. は X の値 10 と整数値 10 を照合します。この場合、値が等しいのでマッチングは成功となります。A と B 両方が未束縛変数の場合、A = B. のマッチングはエラー <sup><a href="abcerl01.html#note1">[*1]</a></sup> になります。B = foo. で B と foo をマッチングし、そのあとで A = B. とすればマッチングは成功します。
</p>
<p> Erlang において、パターンマッチングの動作はとても重要です。マッチングの成否により、条件分岐と同じ動作を行わせることができます。これはあとで詳しく説明します。
</p>
<p> Eshell でマッチングした変数を自由変数に戻したい場合は f(Var) を使います。引数を省略すると、すべての変数が自由変数になります。
</p>
<pre>
&gt; X.
10
&gt; f(X).
ok
&gt; X.
* 1: variable 'X' is unbound
&gt; Y.
10
&gt; A.
foo
&gt; B.
foo
&gt; f().
ok
&gt; Y.
* 1: variable 'Y' is unbound
&gt; A.
* 1: variable 'A' is unbound
&gt; B.
* 1: variable 'B' is unbound
</pre>
<div class="note">
<a name="note1">-- note --------</a><br>
[*1] Prolog の場合、自由変数同士のマッチングは成功します。Erlang の場合、演算子 = の右辺値に未束縛変数が含まれているとエラーになります。
</div>
<h4>●比較演算子</h4>
<p> 数値の大小を比較する場合は、次の演算子を使います。
</p>
<table border=1>
<caption>数値を比較する演算子</caption>
<thead>
  <tr><th>演算子</th><th>条件</th></tr>
</thead>
<tbody>
  <tr><td>Expr1 &gt; Expr2</td><td>Expr1 が Expr2 より大きい</td></tr>
  <tr><td>Expr1 &lt; Expr2</td><td>Expr1 が Expr2 より小さい</td></tr>
  <tr><td>Expr1 &gt;= Expr2</td><td>Expr1 が Expr2 より大きいかまたは等しい</td></tr>
  <tr><td>Expr1 =&lt; Expr2</td><td>Expr1 が Expr2 より小さいかまたは等しい</td></tr>
  <tr><td>Expr1 == Expr2</td><td>Expr1 が Expr2 と等しい</td></tr>
  <tr><td>Expr1 /= Expr2</td><td>Expr1 が Expr2 と等しくない</td></tr>
  <tr><td>Expr1 =:= Expr2</td><td>Expr1 が Expr2 と厳密に等しい</td></tr>
  <tr><td>Expr1 =/= Expr2</td><td>Expr1 が Expr2 と厳密に等しくない</td></tr>
</tbody>
</table>
<p> 比較演算子は条件を満たせば true を、そうでなければ false を返します。Erlang の場合、真偽値は true と false というアトムで表します。簡単な例を示しましょう。
</p>
<pre>
&gt; 1 &lt; 2.
true
&gt; 1 &gt; 2.
false
&gt; 1 =&lt; 2.
true
&gt; 1 &gt;= 2.
false
&gt; 1 == 1.
true
&gt; 1 == 1.0.
true
&gt; 1 =:= 1.0.
false
&gt; 1 /= 1.
false
&gt; 1 /= 1.0.
false
&gt; 1 =/= 1.0.
true
</pre>
<p> == と =:=, /= と =/= の違いはデータ型をチェックするところです。たとえば、整数と実数を比較する場合、値が等しければ == は真を返しますが、=:= はデータ型が異なれば値が等しくても偽を返します。なお、比較演算子は整数や実数だけではなく、他のデータ型にも適用することができます。
</p>
<h4>●論理演算子</h4>
<p> Erlang には not, and, andalso, or, orelse, xor という論理演算子があります。
</p>
<ul>
  <li><b>not</b> : 否定
  <li><b>and</b> : 論理積
  <li><b>andalso</b> : 論理積 (短絡演算子)
  <li><b>or </b> : 論理和
  <li><b>orelse</b> : 論理和 (短絡演算子)
  <li><b>xor</b> : 排他的論理和
</ul>
<p> Erlang の and と or は短絡演算子ではなく、右辺式と左辺式の両方を評価することに注意してください。andalso は短絡演算子で、左辺式が偽ならば右辺式を評価せずに偽を返します。orelse は短絡演算子で、左辺式が真ならば右辺式を評価せずに真を返します。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; true and true.
true
&gt; true and false.
false
&gt; false or true.
true
&gt; false or false.
false
&gt; true xor true.
false
&gt; true xor false.
true
&gt; not true.
false
&gt; not false.
true
</pre>

<h4>●条件分岐</h4>
<p> 条件分岐は if を使います。if の構文を下図に示します。
</p>
<pre class="item">
if
    条件式1 -&gt; 式1a, 式1b, ..., 式1n;
    条件式2 -&gt; 式2a, 式2b, ..., 式2n;
          ・・・・・
    条件式n -&gt; 式na, 式nb, ..., 式nn
end
</pre>
<p> Erlang では、すべてのデータをまとめて「項 (term)」と呼びます。整数、実数、アトムは項になります。また、あとで説明する「リスト (list)」や「タプル (tuple)」も項になります。条件分岐は if ... end の中に "条件式 -&gt; 式, ..., 式" を記述します。これを「節 (clause)」と呼びます。
</p>
<p> Erlang の場合、「式」は通常の計算式だけではなく、if などの構文や項も「式」になります。Erlang の if は式なので値を返します。また、if 式を入れ子にすることもできます。
</p>
<p> 複数の節を指定する場合はセミコロン ( ; ) で区切ります。if は節の条件式を順番に評価していき、結果が真となった節を選択します。-&gt; の右辺で指定した式が評価されます。それ以降の節は評価されません。-&gt; の右辺で複数の式を評価したい場合はカンマ ( , ) で区切ってください。if は最後に評価した式の値を返します。
</p>

<p> Lisp / Scheme ユーザーであれば、Erlang の if は cond と同じと考えればよいでしょう。また、Prolog ユーザーであれば、セミコロンの意味を「選言 (OR)」、カンマの意味を「連言 (AND)」と考えてください。Erlang の場合、if 以外でもセミコロンやカンマを使います。
</p>

<p> なお、if の条件式は比較演算子や論理演算子などのほかに、Erlang の組み込み関数 (Built In Functions : BIF) の中の一部の関数しか指定することができません。Lisp / Scheme の cond と違って Erlang の if には制限があることに注意してください。詳細は Erlang のリファレンスマニュアル <a href="http://erlang.org/doc/reference_manual/expressions.html#guard-sequences">8.25  Guard Sequences</a> をお読みください。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; if 10 rem 2 == 0 -&gt; even; true -&gt; odd end.
even
&gt; if 11 rem 2 == 0 -&gt; even; true -&gt; odd end.
odd
</pre>
<p> 最初の例では、10 rem 2 == 0 が真になるので、その節の右辺を評価して even を返します。次の例では、11 rem 2 == 0 が偽になるので、次の節を評価します。この節の条件式は true なので無条件に成功します。右辺の式を評価して odd を返します。
</p>

<h4>●関数</h4>
<p> Erlang の関数定義はとても簡単です。次の図を見てください。
</p>
<pre class="item">
関数名(仮引数, ,,,) -&gt; 式, ..., 式.

        図 : 関数定義
</pre>
<p> 関数名のあとのカッコで仮引数を指定します。そして、-&gt; の右辺に評価する式を記述します。複数の式を記述する場合はカンマで区切ってください。最後にピリオド ( . ) を付けます。最後に評価した式の値が関数の返り値になります。
</p>
<p> 簡単な例を示しましょう。数値を 2 乗する関数 square は次のようになります。
</p>
<pre class="list">
リスト : 数の二乗

-module(test).
-export([square/1]).

% 引数を二乗する
square(X) -&gt; X * X.
</pre>
<p> Erlang の関数は「モジュール (module)」の中で定義します。-module はモジュールを宣言する文です。モジュールについてはあとで詳しく説明します。この場合、モジュール名は test で、ファイル名はモジュールと同じ名前 (test.erl) でなければなりません。それから、Erlang は % から改行までが「コメント」になります。
</p>
<p> -export は公開する関数名をリストで宣言します。リストはあとで詳しく説明します。関数名のあとに「引数の個数 (arity)」を指定します。関数 square の引数は X しかないので、square/1 とします。Erlang の場合、引数の個数が異なれば同名の関数をいくつでも定義することができます。square の定義は簡単ですね。X * X を計算して返すだけです。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
&gt; c(test).
{ok,test}
&gt; test:square(10).
100
&gt; test:square(11).
121
</pre>
<p> Eshell 上で関数を呼び出す場合は "モジュール名:関数名(実引数, ...)." とします。test:square(10). とすれば 10 * 10 = 100 を求めることができます。同じモジュール内にある関数を呼び出す場合は "モジュール名:" を省略することができます。
</p>

<h4>●関数とパターンマッチング</h4>
<p> Erlang の場合、関数は次のように複数の節に分けて定義することができます。
</p>
<pre class="item">
関数名(仮引数, ,,,) -&gt; 式, ..., 式;
        ・・・・・
関数名(仮引数, ,,,) -&gt; 式, ..., 式.
</pre>
<p> 複数の節をセミコロンで区切るところは if と同じです。この場合、Erlang は関数の仮引数と実引数との間でパターンマッチングを行います。そして、マッチングに成功した節を選択し、-&gt; の右辺に記述された式を評価します。
</p>
<p> 簡単な例を示しましょう。モジュール test に関数 foo を追加します。
</p>
<pre class="list">
リスト : 関数のパターンマッチング

foo(0) -&gt; zero;
foo(1) -&gt; one;
foo(2) -&gt; two;
foo(X) -&gt; others.
</pre>
<p> foo(0) は最初の節とマッチングするので zero を返します。同様に、foo(1), foo(2) は one, two を返します。最後の節で、関数を評価する前の仮引数 X は未束縛変数です。0, 1, 2 以外の値は X とマッチングするので、最後の節が選択されて others を返します。
</p>
<p> なお、最後の X はどこからも参照されていません。このような場合、次のように書き換えることができます。
</p>
<pre class="item">
foo(_) -&gt; others.
</pre>
<p> アンダーラインだけの変数を「無名変数 (anonymous variable)」と呼び、プログラム上でその変数の値が不用のときに使われます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; test:foo(0).
zero
&gt; test:foo(1).
one
&gt; test:foo(2).
two
&gt; test:foo(3).
others
&gt; test:foo(-3).
others
&gt; test:foo(bar).
others
</pre>

<p> ところで、節を定義するときにはその順番に気を付けてください。たとえば、最初に foo(_) -> others; を定義すると、引数が 0, 1, 2 の場合でも foo(_) とマッチングするので、他の節を選択することができなくなります。特定的な節から定義するように注意してください。
</p>

<h4>●Erlang の変数は局所変数</h4>
<p> 関数の引数は「局所変数 (local variable)」として扱われます。局所変数は「有効範囲 (scope : スコープ)」が決まっています。引数の有効範囲は、関数が定義されている式の中だけです。また、-&gt; の右辺で初めて出現する変数も局所変数として扱われます。つまり、Erlang には「大域変数 (global variable)」がないのです <sup><a href="abcerl01.html#note2">[*2]</a></sup>。
</p>
<p> たとえば、2 点間の距離を求める関数 distance/4 を作ってみましょう。モジュール test に次のリストを追加します。
</p>
<pre class="list">
リスト : 2 点間の距離を求める

distance(X1, Y1, X2, Y2) -&gt;
    Dx = X1 - X2,
    Dy = Y1 - Y2,
    math:sqrt(Dx * Dx + Dy * Dy).
</pre>
<p> 2 点の座標は X1, Y1 と X2, Y2 で表します。x 座標の差分を変数 Dx に、y 座標の差分を変数 Dy に求めます。Dx = X1 - X2 の Dx は初めて出現する変数なので、局所変数 (未束縛変数) になります。Dx と X1 - X2 のマッチングは成功します。Dy = Y1 - Y2 の Dy も同様です。
</p>
<p> あとは、√(Dx * Dx + Dy * Dy) を計算するだけです。Erlang の場合、数学関数はモジュール math に定義されています。Eshell 上で m(モジュール名). を実行すると、モジュールに定義されている関数の一覧が得られます。
</p>
<pre>
&gt; m(math).
Module: math
MD5: e590ec1ddb56403fce047355eb252842
Compiled: No compile time info available
Object file: c:/Program Files/erl10.1/lib/stdlib-3.6/ebin/math.beam
Compiler options:  [debug_info, ... 省略 ...]

Exports:
acos/1                        floor/1
acosh/1                       fmod/2
asin/1                        log/1
asinh/1                       log10/1
atan/1                        log2/1
atan2/2                       module_info/0
atanh/1                       module_info/1
ceil/1                        pi/0
cos/1                         pow/2
cosh/1                        sin/1
erf/1                         sinh/1
erfc/1                        sqrt/1
exp/1                         tan/1
                              tanh/1
ok
</pre>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
&gt; test:distance(0, 0, 2, 2).
2.8284271247461903
&gt; test:distance(0, 0, 10, 10).
14.142135623730951
</pre>
<div class="note">
<a name="note2">-- note --------</a><br>
[*2] 大域変数の代わりになるデータ構造 (プロセス辞書) はありますが、できるだけ使わないほうが良いでしょう。
</div>
<h4>●タプル (tuple)</h4>
<p> タプルは複数の項を格納したデータ構造です。タプルは複数の項をカンマ ( , ) で区切り、中カッコ { } で囲んで表します。次の例を見てください。
</p>
<pre>
&gt; A = {1, 2}.
{1,2}
&gt; B = {10, 20.5}.
{10,20.5}
&gt; C = {1, 2.5, foo}.
{1,2.5,foo}
&gt; D = {1 + 2, 3 * 4}.
{3,12}
</pre>
<p> このように、タプルにはデータ型が異なる要素を格納することができます。また、最後の例のようにカッコの中に式を書くと、それを評価した値がタプルの要素になります。
</p>
<p> タプルは入れ子にしてもかまいません。簡単な例を示します。
</p>
<pre>
&gt; E = {{1, 2}, {3, 4}}.
{{1,2},{3,4}}
&gt; F = {1, {2, {3}, 4}, 5}.
{1,{2,{3},4},5}
</pre>
<p> タプルから要素を取り出すには、パターンマッチングを使うと簡単です。
</p>
<pre>
&gt; {X, Y} = A.
{1,2}
&gt; X.
1
&gt; Y.
2
&gt; {X0, Y0} = E.
{{1,2},{3,4}}
&gt; X0.
{1,2}
&gt; Y0.
{3,4}
&gt; {{X1, Y1}, {X2, Y2}} = E.
{{1,2},{3,4}}
&gt; X1.
1
&gt; Y1.
2
&gt; X2.
3
&gt; Y2.
4
</pre>
<p> パターン {X, Y} と左辺 A の値 {1, 2} を照合して、変数部分に対応する要素を取り出します。そして、変数をその値に束縛します。次の例のように、{X0, Y0} と {{1, 2}, {3, 4}} を照合すると、X0 は {1, 2} になり、Y0 は {3, 4} になります。
</p>
<p> パターンは入れ子にしてもかまいません。{{X1, Y1}, {X2, Y2}} と {{1, 2}, {3, 4}} を照合すると、X1 = 1, Y1 = 2, X2 = 3, Y2 = 4 となります。このように、パターンを使ってタプルの要素を取り出すことができます。
</p>
<p> ただし、マッチングに失敗した場合は次のようにエラーになります。
</p>
<pre>
&gt; {{Z0}, Z1} = {1,2}.
** exception error: no match of right hand side value {1,2}
&gt; {{Z0}, Z1} = {{1},2}.
{{1},2}
&gt; Z0.
1
&gt; Z1.
2
</pre>
<p> 簡単な例を示しましょう。座標をタプル {x, y} で表すことにすると、関数 distance/2 は次のようになります。
</p>
<pre class="list">
リスト : 2 点間の距離を求める (2)

distance({X1, Y1}, {X2, Y2}) -&gt;
    Dx = X1 - X2,
    Dy = Y1 - Y2,
    math:sqrt(Dx * Dx + Dy * Dy).
</pre>
<p> この場合、distance の arity は 2 になります。そして、パターンマッチングでタプルから座標を取り出して距離を計算します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; test:distance({0,0}, {2,2}).
2.8284271247461903
&gt; X = {0,0}.
{0,0}
&gt; Y = {10,10}.
{10,10}
&gt; test:distance(X, Y).
14.142135623730951
</pre>

<p> また、Erlang のパターンマッチングでは、左辺式で同じ名前の変数を使うことができます。次の例を見てください。
</p>
<pre>
&gt; {Y, Y} = {2, 3}.
** exception error: no match of right hand side value {2,3}
&gt; {X, X} = {2, 2}.
{2,2}
&gt; X.
2
</pre>
<p> {Y, Y} と {2, 3} をマッチングする場合、Y は未束縛変数なので、最初に Y と 2 を照合して Y の値は 2 になります。次に、Y と 3 を照合しますが、Y は未束縛変数ではなく 2 に束縛されています。この値を使ってパターンマッチングを行うため、2 と 3 を照合することになり、マッチングは失敗します。{X, X} と {2, 2} をマッチングする場合は、最初に X と 2 を照合して X の値が 2 になり、次に 2 に束縛された X と 2 を照合するので、マッチングは成功します。
</p>

<h4>●リスト (list)</h4>
<p> 「リスト (list)」は複数の項を一列に並べたデータ構造です。Erlang で扱うリストは、Lisp / Scheme や Prolog のリストと同じです。リストの構造を図で表すと次のようになります。
</p>

<pre class="fig">
┌─┬─┐    ┌─┬─┐    ┌─┬─┐
│・│・┼─→│・│・┼─→│・│・┼─→ [] (空リスト)
└┼┴─┘    └┼┴─┘    └┼┴─┘
  ↓            ↓            ↓
  １            ２            ３

        図 : リスト内部の構造
</pre>

<p> リストは貨物列車にたとえるとわかりやすいでしょう。車両に相当するものを「コンスセル (cons cell)」といいます。貨物列車には多数の車両が接続されて運行されるように、リストは複数のコンスセルを接続して構成されます。1 つのコンスセルには、貨物（データ）を格納する場所と、連結器に相当する場所があります。
</p>

<p> 上図では、コンスセルを箱で表しています。コンスセルの左側がデータを格納する場所で、右側が次のコンスセルと連結しています。この例では、3 つのコンスセルが接続されています。それから、最後尾のコンスセルには、リストの終わりを示す特別なデータが格納されます。要素が一つもないリストを「空リスト」といって、Erlang では [ ] で表します。一般に、リストの終端は空リストで表しますが、リスト以外のデータであれば何でもかまいません。
</p>

<p> Erlang では、リストの両側を [ と ] で囲んで表し、項はカンマ ( , ) で区切ります。簡単な例を示しましょう。
</p>
<pre class="item">
[spring, summer, autumn, winter]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[X, Y, Z]
[[a, b, c], [d, e, f], [g, h, i]]
</pre>
<p> 最初の例では、四季のデータを格納しています。次の例では数値を格納しています。そして、変数を格納することもできますし、リストの中にリストを格納することもできます。このように、リストに格納する要素に制限はありません。100 個でも 1000 個でも、Erlang システムが許容する範囲内であればいくつでも格納することができます。
</p>

<p> リストの長所は要素の追加や削除が簡単にできるところです。Erlang の場合、パターンマッチングを使って柔軟にリストを操作することができます。その動作は Prolog のリストにそっくりです。次の例を見てください。
</p>
<pre>
&gt; [A, B, C, D] = [spring, summer, autumn, winter].
[spring,summer,autumn,winter]
&gt; A.
spring
&gt; B.
summer
&gt; C.
autumn
&gt; D.
winter
</pre>
<p> このように、リスト同士のマッチングは先頭の要素から順番に行います。
</p>
<p> パターンマッチングを使って、リストを分解することができます。次の例を見てください。
</p>
<pre>
&gt; [X | Y] = [spring, summer, autumn, winter].
[spring,summer,autumn,winter]
&gt; X.
spring
&gt; Y.
[summer,autumn,winter]
</pre>
<p> X と Y の間にある "|" に意味があります。| でリストを区切ると、それより後ろの変数は「残りのリストすべて」とマッチングします。この場合、X が先頭の要素とマッチングし、spring を取り除いた残りのリストと Y がマッチングします。もう少し例を見てみましょう。
</p>
<pre>
&gt; [X1, Y1 | Z1] = [spring, summer, autumn, winter].
[spring,summer,autumn,winter]
&gt; X1.
spring
&gt; Y1.
summer
&gt; Z1.
[autumn,winter]
</pre>
<p> この例では、X1 が spring、Y1 が summer にマッチングし、残りのリストと Z1 がマッチングします。このように、| の前にはいくつでも変数を置くことができますが、| の後ろには変数をひとつしか置けません。「残りのリストすべて」とマッチングするのですから、複数の変数を書いても意味がありません。また、| を同じリストに複数書くこともできません。次の例はすべてエラーになります。
</p>
<pre class="item">
[X | Y, Z]     % | の後ろに変数が複数ある
[X | Y | Z]    % | が複数ある
[ | X]         % | の前にデータがない
[X | ]         % | の後ろにデータがない
</pre>
<p> Lisp / Scheme ユーザーであれば、[X | Y] がドットリスト (X . Y) と同じであることに気づかれたことでしょう。Lisp / Scheme では、関数 car でリストの先頭の要素を、関数 cdr で先頭要素を取り除いた残りのリストを求めることができます。Erlang の場合はパターンマッチングを行うことで、リストを分解することができます。
</p>

<h4>●文字と文字列</h4>
<p> Erlang の場合、文字を表すデータ型は用意されていません。文字は整数で表します。文字の前に $ を付けると、その文字のアスキーコードに変換されます。
</p>
<pre>
&gt; $a.
97
&gt; $b.
98
&gt; $c.
99
</pre>
<p> 文字列 (string) は "foo" や "bar" のように二重引用符 ( " ) で囲みます。これを「文字列リスト」といいます。Erlang の場合、文字列は文字を表すアスキーコード (ASCII CODE) のリストと同じです。
</p>
<pre>
&gt; [C1, C2, C3] = "abc".
"abc"
&gt; C1.
97
&gt; C2.
98
&gt; C3.
99
&gt; [$a, $b, $c].
"abc"
</pre>
<p> UTF-8 が扱える端末であれば日本語を扱うこともできます。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/work/erlang$ erl
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.2  (abort with ^G)
1&gt; "あいうえお".
[12354,12356,12358,12360,12362]
2> $あ.
12354
3&gt; halt().

mhiroi@mhiroi-VirtualBox:~/work/erlang$ erl +pc unicode
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.2  (abort with ^G)
1&gt; "あいうえお".
"あいうえお"
2&gt; $あ.
12354
</pre>
<p> Eshell の起動時にオプション +pc unicode を指定すると、UTF-8 の文字リストを日本語で表示することができます。ただし、Windows ではコマンドプロンプトの文字コードを UTF-8 に切り替えても、上記のような動作にはなりませんでした。werl を使うと上記と同じ動作になります。ご注意くださいませ。
</p>
<hr>
<div align="right">
初出 2011 年 10 月 2 日<br>
改訂 2018 年 12 月 9 日
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011-2018 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="erlang.html">Erlang</a> | <a href="abcerl02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>