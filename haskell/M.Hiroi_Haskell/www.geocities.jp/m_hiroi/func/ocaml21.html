<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881751</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml20.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml22.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">パズルの解法 (3)</h3>
<p> 今回は反復深化で 8 パズルを解いてみましょう。<a href="ocaml18.html">経路の探索</a> で説明したように、反復深化は最短手数を求めることができるアルゴリズムです。幅優先探索と違って局面を保存する必要が無いため、必要となるメモリは深さ優先探索と同程度で済みます。また、プログラムも深さ優先探索と同じくらい簡単に作成することができます。
</p>

<p> ただし、同じ探索を何度も繰り返すため実行時間が増大する、という欠点があります。ようするに、使用するメモリは少ないが実行時間が長くなるアルゴリズムなのです。実行時間が長くなるといっても、枝刈りを工夫することでパズルを高速に解くことができます。メモリ不足になる場合には、積極的に使ってみたいアルゴリズムといえるでしょう。
</p>

<p> なお、このドキュメントは拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo27.html">幅優先探索と反復深化</a> のプログラムを OCaml で書き直したものです。内容は重複していますが、ご了承くださいませ。
</p>

<h4>●反復深化による解法</h4>
<p> 幅優先探索では全ての局面を保存しましたが、反復深化ではその必要はありません。盤面は配列 board で表します。駒の移動は board を書き換えて、バックトラックする時は元に戻すことにします。動かした駒はリスト move_list に格納します。動かした駒がわかれば局面を再現できるので、それで移動手順を表すことにします。
</p>

<p> それでは、解を求める関数 solve を作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト 1 : 単純な反復深化による解法

let solve board goal =
  let count = ref 0 in
  let rec ids n limit space move_list =
    if n = limit then
      if board = goal then
        begin
          count := !count + 1;
          print_answer (List.tl (List.rev move_list))
        end
      else ()
    else
      List.iter
        (fun x -&gt;
          let p = board.(x) in
          if p &lt;&gt; List.hd move_list then
            begin
              (* 駒を動かす *)
              board.(space) &lt;- p;
              board.(x) &lt;- 0;
              (* 再帰呼び出し *)
              ids (n+1) limit x (p::move_list);
              (* 元に戻す *)
              board.(space) &lt;- 0;
              board.(x) &lt;- p
            end
          else ())
        adjacent.(space)
  in
    let i = ref 1 in
    while (!i &lt;= 31 &amp;&amp; !count = 0) done
      ids 0 !i (position 0 board) [-1];
      i := !i + 1
    done
</pre>
<p> 探索処理は局所関数 ids で行います。ids の引数 n が手数、limit が反復深化の上限値、space が空き場所の位置、move_list が移動手順を表します。n が limit に達したら、パズルが解けたかチェックします。solve の引数 goal が完成形を表す配列です。完成形に到達したら、変数 count の値を +1 してから関数 print_answer で手順を表示します。上限値に達していない場合は、駒を移動して新しい局面を作ります。
</p>

<p> 8 パズルのように、元の局面に戻すことが可能（可逆的）なパズルの場合、単純な深さ優先探索では同じ移動手順を何度も繰り返すことがあります。そうなると、とんでもない解を出力するだけではなく、再帰呼び出しが深くなるとスタックがオーバーフローしてプログラムの実行が停止してしまいます。
</p>

<p> このような場合、局面の履歴を保存しておいて同じ局面がないかチェックすることで、解を求めることができるようになります。ただし、同一局面をチェックする分だけ時間が余分にかかりますし、最初に見つかる解が最短手数とは限りません。
</p>

<p> 反復深化では深さが制限されているため、同一局面のチェックを行わなくてもスタックオーバーフローが発生することはありません。そのかわり、無駄な探索はどうしても避けることができません。8 パズルの場合、1 手前に動かした駒を再度動かすと 2 手前の局面に戻ってしまいます。完全ではありませんが、このチェックを入れるだけでもかなりの無駄を省くことができます。
</p>

<p> プログラムでは、リスト move_list に移動した駒を格納しているので、1 手前と同じ駒は動かさないようにチェックしています。なお、move_list の初期値はダミーデータを入れて [-1] としています。
</p>

<p> 最後に、関数 ids を呼び出します。変数 i が上限値を表します。i を 1 手ずつ増やして関数 ids を呼び出します。変数 count が 0 より大きい場合、解が見つかったので while ループを終了します。プログラムはこれで完成です。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
let () =
  let a = Sys.time () in
  solve [|8;6;7;2;5;4;3;0;1|] [|1;2;3;4;5;6;7;8;0|];
  print_float (Sys.time () -. a);;
</pre>
<p> 当然ですが最短手数は 31 手で 40 通りの手順が表示されました。実行時間は 184 秒 (Windows XP, celeron 1.40 GHz, ocamlc 3.10.0) かかりました。約 3 分かかるのですから、やっぱり遅いですね。反復深化の場合、枝刈りを工夫しないと高速に解くことはできません。そこで、反復深化の常套手段である「下限値枝刈り法」を使うことにしましょう。
</p>

<h4>●下限値枝刈り法</h4>
<p> 下限値枝刈り法は難しいアルゴリズムではありません。たとえば、5 手進めた局面を考えてみます。探索の上限値が 10 手とすると、あと 5 手だけ動かすことができますね。この時、パズルを解くのに 6 手以上かかることがわかれば、ここで探索を打ち切ることができます。
</p>
<p> このように、必要となる最低限の手数が明確にわかる場合、この値を「下限値 (Lower Bound)」と呼びます。この下限値を求めることができれば、「今の移動手数＋下限値」が探索手数を超えた時点で、枝刈りすることが可能になります。これが下限値枝刈り法の基本的な考え方です。
</p>

<p> さて、下限値を求める方法ですが、これにはいろいろな方法が考えられます。今回は、各駒が正しい位置へ移動するまでの手数 (移動距離) <sup><a href="ocaml21.html#note1">[*1]</a></sup> を下限値として利用することにしましょう。次の図を見てください。
</p>

<pre class="fig">
┌─┬─┬─┐    ┌──┬──┬──┐
│１│２│３│    │8(3)│6(2)│7(4)│
├─┼─┼─┤    ├──┼──┼──┤
│４│５│６│    │2(2)│5(0)│4(2)│
├─┼─┼─┤    ├──┼──┼──┤
│７│８│  │    │3(4)│    │1(4)│
└─┴─┴─┘    └──┴──┴──┘
                   (n) : n は移動距離

  (1) 完成形     (2) 初期状態：合計 21

        図 1 : 下限値の求め方
</pre>

<p> たとえば、右下にある 1 の駒を左上の正しい位置に移動するには、最低でも 4 手必要です。もちろん、ほかの駒との関連で、それ以上の手数が必要になる場合もあるでしょうが、4 手より少なくなることは絶対にありません。同じように、各駒について最低限必要な手数を求めることができます。そして、その合計値はパズルを解くのに最低限必要な手数となります。これを下限値として利用することができます。ちなみに、図 1 (2) の初期状態の下限値は 21 手になります。
</p>

<p> 下限値枝刈り法を使う場合、下限値の計算を間違えると正しい解を求めることができなくなります。たとえば、10 手で解ける問題の下限値を 11 手と計算すれば、最短手数を求めることができなくなります。それどころか、10 手の解しかない場合は、答えを求めることすらできなくなります。下限値の計算には十分に注意してください。
</p>

<div class="note">
-- note -----<br>
<a name="note1">[*1]</a> これを「マンハッタン距離」と呼ぶことがあります。
</div>
<h4>●下限値枝刈り法のプログラム</h4>
<p> それでは、プログラムを作りましょう。下限値の求め方ですが、駒を動かすたびに各駒の移動距離を計算していたのでは時間がかかります。8 パズルの場合、1 回に一つの駒しか移動しないので、初期状態の下限値を求めておいて、動かした駒の差分だけ計算すればいいでしょう。
</p>
<p> また、駒の移動距離はいちいち計算するのではなく、あらかじめ計算した結果を配列に格納しておきます。この配列を distance とすると、盤面から移動距離を求めるプログラムは次のようになります。
</p>

<pre class="list">
リスト 2 : 移動距離を求める

let distance = [|
  [|0; 0; 0; 0; 0; 0; 0; 0; 0|];
  [|0; 1; 2; 1; 2; 3; 2; 3; 4|];
  [|1; 0; 1; 2; 1; 2; 3; 2; 3|];
  [|2; 1; 0; 3; 2; 1; 4; 3; 2|];
  [|1; 2; 3; 0; 1; 2; 1; 2; 3|];
  [|2; 1; 2; 1; 0; 1; 2; 1; 2|];
  [|3; 2; 1; 2; 1; 0; 3; 2; 1|];
  [|2; 3; 4; 1; 2; 3; 0; 1; 2|];
  [|3; 2; 3; 2; 1; 2; 1; 0; 1|]
|]

(* 移動距離を求める *)
let rec get_distance n board a =
  if n = 9 then a
  else get_distance (n+1) board (a + distance.(board.(n)).(n))
</pre>
<p>  distance は 2 次元配列で「駒の種類×駒の位置」を表しています。空き場所は関係ないので、distance.(0) はダミーとなります。関数 get_distance は盤面 board にある駒と位置から移動距離を求めます。引数 n が盤面の位置。a が移動距離を表す累積変数です。この処理は distance.(board.(n)).(n) の合計値を求めるだけです。
</p>

<p> 次は、下限値枝刈り法による反復深化を行う関数 solve を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト 3 : 下限値枝刈り法

let solve board goal =
  let count = ref 0 in
  let rec ids n limit space move_list lower =
    if n = limit then
      if board = goal then
        begin
          count := !count + 1;
          print_answer (List.tl (List.rev move_list))
        end
      else ()
    else
      List.iter
        (fun x -&gt;
          let p = board.(x) in
          if p &lt;&gt; List.hd move_list then
            let new_lower = lower - distance.(p).(x) + distance.(p).(space) in
            if new_lower + n &lt;= limit then
              begin
                (* 駒を動かす *)
                board.(space) &lt;- p;
                board.(x) &lt;- 0;
                (* 再帰呼び出し *)
                ids (n+1) limit x (p::move_list) new_lower;
                (* 元に戻す *)
                board.(space) &lt;- 0;
                board.(x) &lt;- p
              end
            else ()
          else ())
        adjacent.(space)
  in
    let lower = get_distance 0 board 0 in
    let i = ref lower in
    while (!i &lt;= 31 &amp;&amp; !count = 0) do
      ids 0 limit (position 0 board) [-1] lower;
      i := !i + 1
    done
</pre>
<p> 局所関数 ids の引数 lower は現在の盤面 board の下限値を表しています。動かす駒の差分を計算して、新しい下限値 new_lower を求めます。そして、new_lower + n が上限値 limit を越えたら枝刈りを行います。limit 以下であれば ids を再帰呼び出しします。
</p>

<p> 最後に ids を呼び出す処理を修正します。関数 get_distance で初期状態の下限値 lower を求めます。下限値がわかるのですから、上限値 i は 1 手からではなく下限値 lower からスタートします。あとは ids に下限値 lower を渡して呼び出すだけです。
</p>

<p> プログラムの主な修正はこれだけです。実際に実行してみると、実行時間は 0.187 秒 (Windows XP, celeron 1.40 GHz, ocamlc 3.10.0) でした。約 1000 倍という高速化に驚いてしまいました。下限値枝刈り法の効果は極めて高いですね。
</p>
<h4 id="cite">●参考文献</h4>
<ol>
  <li>高橋謙一郎, 『特集 悩めるプログラマに効くアルゴリズム』, C MAGAZINE 2000 年 11 月号, ソフトバンク
</ol>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
(*
 * eight3.ml : 8 Puzzle (反復深化)
 *
 *             Copyright (C) 2008 Makoto Hiroi
 *)

(* 隣接リスト *)
let adjacent = [|
  [1; 3];
  [0; 2; 4];
  [1; 5];
  [0; 4; 6];
  [1; 3; 5; 7];
  [2; 4; 8];
  [3; 7];
  [4; 6; 8];
  [5; 7]
|]


(* 駒の位置を返す *)
let position x ary =
  let rec iter n =
    if n = Array.length ary then raise Not_found
    else if x = ary.(n) then n
    else iter (n + 1)
  in
    iter 0

(* 手順の表示 *)
let print_answer ls =
  List.iter (fun x -&gt; print_int x; print_string " ") ls;
  print_newline ()

(* 反復深化 *)
let solve board goal =
  let count = ref 0 in
  let rec ids n limit space move_list =
    if n = limit then
      if board = goal then
        print_answer (List.tl (List.rev move_list))
      else ()
    else
      List.iter
        (fun x -&gt;
          let p = board.(x) in
          if p &lt;&gt; List.hd move_list then
            begin
              (* 駒を動かす *)
              board.(space) &lt;- p;
              board.(x) &lt;- 0;
              (* 再帰呼び出し *)
              ids (n+1) limit x (p::move_list);
              (* 元に戻す *)
              board.(space) &lt;- 0;
              board.(x) &lt;- p
            end
          else ())
        adjacent.(space)
  in
    let i = ref 1 in
    while (!i &lt;= 31 &amp;&amp; !count = 0) do
      ids 0 !i (position 0 board) [-1];
      i := !i + 1
    done

(* 実行 *)
let () =
  let a = Sys.time () in
  solve [|8;6;7;2;5;4;3;0;1|] [|1;2;3;4;5;6;7;8;0|];
  print_float (Sys.time () -. a)
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
(*
 * eight4.ml : 8 Puzzle (反復深化 + 下限値枝刈り法)
 *
 *             Copyright (C) 2008 Makoto Hiroi
 *)

(* 隣接リスト *)
let adjacent = [|
  [1; 3];
  [0; 2; 4];
  [1; 5];
  [0; 4; 6];
  [1; 3; 5; 7];
  [2; 4; 8];
  [3; 7];
  [4; 6; 8];
  [5; 7]
|]

(* 移動距離 *)
let distance = [|
  [|0; 0; 0; 0; 0; 0; 0; 0; 0|];
  [|0; 1; 2; 1; 2; 3; 2; 3; 4|];
  [|1; 0; 1; 2; 1; 2; 3; 2; 3|];
  [|2; 1; 0; 3; 2; 1; 4; 3; 2|];
  [|1; 2; 3; 0; 1; 2; 1; 2; 3|];
  [|2; 1; 2; 1; 0; 1; 2; 1; 2|];
  [|3; 2; 1; 2; 1; 0; 3; 2; 1|];
  [|2; 3; 4; 1; 2; 3; 0; 1; 2|];
  [|3; 2; 3; 2; 1; 2; 1; 0; 1|]
|]

(* 駒の位置を返す *)
let position x ary =
  let rec iter n =
    if n = Array.length ary then raise Not_found
    else if x = ary.(n) then n
    else iter (n + 1)
  in
    iter 0

(* 手順の表示 *)
let print_answer ls =
  List.iter (fun x -&gt; print_int x; print_string " ") ls;
  print_newline ()

(* 移動距離を求める *)
let rec get_distance n board a =
  if n = 9 then a
  else get_distance (n+1) board (a + distance.(board.(n)).(n))


(* 反復深化 *)
let solve board goal =
  let count = ref 0 in
  let rec ids n limit space move_list lower =
    if n = limit then
      if board = goal then
        begin
          count := !count + 1;
          print_answer (List.tl (List.rev move_list))
        end
      else ()
    else
      List.iter
        (fun x -&gt;
          let p = board.(x) in
          if p &lt;&gt; List.hd move_list then
            let new_lower = lower - distance.(p).(x) + distance.(p).(space) in
            if new_lower + n &lt;= limit then
              begin
                (* 駒を動かす *)
                board.(space) &lt;- p;
                board.(x) &lt;- 0;
                (* 再帰呼び出し *)
                ids (n+1) limit x (p::move_list) new_lower;
                (* 元に戻す *)
                board.(space) &lt;- 0;
                board.(x) &lt;- p
              end
            else ()
          else ())
        adjacent.(space)
  in
    let lower = get_distance 0 board 0 in
    let i = ref lower in
    while (!i &lt;= 31 &amp;&amp; !count = 0) do
      ids 0 limit (position 0 board) [-1] lower;
      i := !i + 1
    done

let () =
  let a = Sys.time () in
  solve [|8;6;7;2;5;4;3;0;1|] [|1;2;3;4;5;6;7;8;0|];
  print_float (Sys.time () -. a)
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">組み合わせの生成 (2)</h3>
<p> 組み合わせの生成は拙作のページ <a href="ocaml05.html#chap02">順列と組み合わせ</a> で説明しました。このほかに、n 個の中から m 個を選ぶ組み合わせは、ビットのオンオフで表すことができます。たとえば、5 個の数字 (0 - 4) から 3 個を選ぶ場合、数字を 0 bit から 4 bit に対応させます。すると、1, 3, 4 という組み合わせは 11010 と表すことができます。
</p>
<p> 今回はビットを使って組み合わせを求めてみましょう。最初に OCaml のビット演算について説明します。なお、このドキュメントは拙作のページ <a href="index.html#sml">お気楽 Standard ML of New Jersey 入門</a> <a href="smlnj12.html#yori10">ちょっと寄り道「組み合わせの生成 (2)」</a> のプログラムを OCaml に書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>

<h4>●ビット演算子</h4>
<p> OCaml にはビット演算を行う演算子が用意されています。主な演算子を表に示します。
</p>
<table border=1>
<caption>表 1 : ビット演算子</caption>
<thead>
  <tr><th>演算子</th><th>型</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>land</td><td>int -&gt; int -&gt; int</td><td>ビットごとの論理積を返す</td></tr>
  <tr><td>lor</td><td>int -&gt; int -&gt; int</td><td>ビットごとの論理和を返す</td></tr>
  <tr><td>lxor</td><td>int -&gt; int -&gt; int</td><td>ビットごとの排他的論理和を返す</td></tr>
  <tr><td>lnot</td><td>int -&gt; int</td><td>ビットごとの論理的な否定を返す</td></tr>
  <tr><td>lsl</td><td>int -&gt; int -&gt; int</td><td>m lsl n は m を n ビットだけ左シフトする</td></tr>
  <tr><td>lsr</td><td>int -&gt; int -&gt; int</td><td>m lsr n は m を n ビットだけ右シフトする</td></tr>
  <tr><td>asr</td><td>int -&gt; int -&gt; int</td><td>m lsr n は m を n ビットだけ算術右シフトする</td></tr>
</tbody>
</table>

<p> land はビットごとの論理積を返します。
</p>
<pre>
# 5 land 3;;
- : int = 1
</pre>
<pre class="fig">
     0101
 and 0011
---------
     0001
</pre>
<p> lor はビットごとの論理和を返します。
</p>
<pre>
# 5 lor 3;;
- : int = 7
</pre>
<pre class="fig">
    0101
 or 0011
--------
    0111
</pre>
<p> lxor はビットごとの排他的論理和を返します。
</p>
<pre>
# 5 lxor 3;;
- : int = 6
</pre>
<pre class="fig">
     0101
 xor 0011
---------
     0110
</pre>
<p> lnot はビットごとの論理的な否定を返します。
</p>
<pre>
# lnot 0;;
- : int = -1
# lnot 1;;
- : int = -2
</pre>
<p> m lsl n は m を n ビット左シフトします。m lsr n は m を n ビット右シフトします。
</p>
<pre>
# 1 lsl 8;;
- : int = 256
# 256 lsr 4;;
- : int = 16
</pre>
<p> このほかに、算術右シフトを行う演算子 asr もあります。
</p>

<h4>●プログラムの作成</h4>
<p> 組み合わせを求めるプログラムは次のようになります。
</p>
<pre class="list">
リスト 4 : 組み合わせの生成

let rec gen_comb n m a =
  if m = 0 then Printf.printf "%x\n" a
  else if m = n then Printf.printf "%x\n" (a lor ((1 lsl m) - 1))
  else begin
    gen_comb (n - 1) m a;
    gen_comb (n - 1) (m - 1) (a lor (1 lsl (n - 1)))
  end
</pre>

<p> 関数 gen_comb は n 個の中から m 個を選ぶ組み合わせを生成して出力します。組み合わせは引数 a にセットします。m が 0 になったら、組み合わせがひとつできたので a を出力します。n が m と等しくなったならば、残り m 個を全て選びます。(1 lsl m) - 1 で m 個のビットをオンにして出力します。
</p>
<p> あとは gen_comb を再帰呼び出しします。最初の呼び出しは n 番目の数字を選ばない場合です。n - 1 個の中から m 個を選びます。次の呼び出しが n 番目の数字を選ぶ場合で、a の n - 1 ビットをオンにします。そして、n - 1 個の中から m - 1 個を選びます。
</p>
<p> それでは 5 個の中から 3 個を選ぶ gen_comb 5 3 0 の実行例を示します。
</p>
<pre>
 7 (00111)
 b (01011)
 d (01101)
 e (01110)
13 (10011)
15 (10101)
16 (10110)
19 (11001)
1a (11010)
1c (11100)
</pre>
<p> この場合、最小値は 0x07 (00111) で最大値は 0x1c (11100) になります。このように、gen_comb は組み合わせを表す数を昇順で出力します。
</p>

<h4>●組み合わせに番号を付ける方法</h4>
<p> 次は、N 通りある組み合わせに 0 から N - 1 までの番号を付ける方法を紹介しましょう。たとえば、6 個の中から 3 個を選ぶ組み合わせは 20 通りありますが、この組み合わせに 0 から 19 までの番号を付けることができます。1 1 1 0 0 0 を例題に考えてみましょう。次の図を見てください。
</p>
<pre class="fig">
  5 4 3 2 1 0
  ─────────
  0 0 0 1 1 1    ↑
  0 0 1 0 1 1    │
  0 0 1 1 0 1    │
  0 0 1 1 1 0    │
  0 1 0 0 1 1    │
  0 1 0 1 0 1   5Ｃ3 = 10 通り
  0 1 0 1 1 0    │
  0 1 1 0 0 1    │
  0 1 1 0 1 0    │
  0 1 1 1 0 0    ↓
  ─────────
  1 0 0 0 1 1    ↑
  1 0 0 1 0 1    │
  1 0 0 1 1 0    │
  1 0 1 0 0 1   4Ｃ2 = 6 通り
  1 0 1 0 1 0    │
  1 0 1 1 0 0    ↓
    ────────
  1 1 0 0 0 1    ↑
  1 1 0 0 1 0   3Ｃ1 = 3 通り
  1 1 0 1 0 0    ↓
      ───────
  1 1 1 0 0 0    19 番目
  ─────────

  図：6Ｃ3 の組み合わせ
</pre>

<p> 最初に 5 をチェックします。5 を選ばない場合は <SUB>5</SUB>Ｃ<SUB>3</SUB> = 10 通りありますね。この組み合わせに 0 から 9 までの番号を割り当てることにすると、5 を選ぶ組み合わせの番号は 10 から 19 までとなります。
</p>
<p> 次に、4 をチェックします。4 を選ばない場合は、<SUB>4</SUB>Ｃ<SUB>2</SUB> = 6 通りあります。したがって、5 を選んで 4 を選ばない組み合わせに 10 から 15 までの番号を割り当てることにすると、5 と 4 を選ぶ組み合わせには 16 から 19 までの番号となります。
</p>
<p> 最後に、3 をチェックします。同様に 3 を選ばない場合は 3 通りあるので、これに 16 から 18 までの番号を割り当て、5, 4, 3 を選ぶ組み合わせには 19 を割り当てます。これで組み合わせ 1 1 1 0 0 0 の番号を求めることができました。
</p>
<p> では、0 0 0 1 1 1 はどうなるのでしょうか。左から順番にチェックしていくと、最初の 1 が見つかった時点で、その数字を選ばない組み合わせは存在しません。つまり、残りの数字をすべて選ぶしかないわけです。したがって、これが 0 番目となります。
</p>

<p> このように、数字を選ぶときに、数字を選ばない場合の組み合わせの数を足し算していけば、その組み合わせの番号を求めることができるのです。
</p>

<h4>●組み合わせを番号に変換</h4>
<p> 組み合わせを番号に変換するプログラムは次のようになります。
</p>

<pre class="list">
リスト 5 : 組み合わせを番号に変換

(* 組み合わせの数を求める *)
let rec comb n r =
  if n = r || r = 0 then 1
  else (comb n (r - 1)) * (n - r + 1) / r

(* 組み合わせを番号に変換 *)
let rec comb_to_num c n r v =
  if r = 0 || n = r then v
  else if c land (1 lsl (n - 1)) &lt;&gt; 0 then
    comb_to_num c (n - 1) (r - 1) (v + comb (n - 1) r)
  else
    comb_to_num c (n - 1) r v
</pre>

<p> 関数 comb_to_num の引数 c はビットのオンオフで表した組み合わせ、引数 n と r は <SUB>n</SUB>Ｃ<SUB>r</SUB> の n と r を表しています。引数 v は求める番号を表します。n と r の値が同じになるか、もしくは r が 0 になれば、組み合わせの番号を計算できたので value を返します。
</p>
<p> そうでない場合、c の n - 1 ビットの値を調べます。ビットがオンであれば、v に comb (n - 1) r の値を足し算し、r を -1 して comb_to_num を再帰呼び出しします。そうでなければ、v と r の値はそのままで comb_to_num を再帰呼び出しします。
</p>

<h4>●番号を組み合わせに変換</h4>
<p> 逆に、番号から組み合わせを求めるプログラムも簡単に作ることができます。次のリストを見てください。
</p>

<pre class="list">
リスト 6 : 番号を組み合わせに変換

let rec num_to_comb v n r c =
  if r = 0 then c
  else if n = r then c lor ((1 lsl n) - 1)
  else
    let k = comb (n - 1) r in
    if v &gt;= k then
      num_to_comb (v - k) (n - 1) (r - 1) (c lor (1 lsl (n - 1)))
    else
      num_to_comb v (n - 1) r c
</pre>


<p> 引数 v が番号で、引数 n と r は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。引数 c が求める組み合わせです。たとえば、n = 5, r = 3 の場合、ビットが 1 になるのは <sub>4</sub>C<sub>2</sub> = 6 通りあり、0 になるのは <sub>4</sub>C<sub>3</sub> = 4 通りあります。したがって、数値が 0 - 3 の場合はビットを 0 にし、4 - 9 の場合はビットを 1 にすればいいわけです。
</p>
<p> ビットを 0 にした場合、残りは <sub>4</sub>C<sub>3</sub> = 4 通りになるので、同様に次のビットを決定します。ビット 1 にした場合、残りは <sub>4</sub>C<sub>2</sub> = 6 通りになるので、v から 4 を引いて num_to_comb を再帰呼び出しして次のビットを決定します。
</p>

<p> r が 0 の場合は、組み合わせが完成したので c を返します。n と r が等しい場合は、残りのビットをすべて 1 にセットしてから c を返します。それ以外の場合は、<sub>n-1</sub>C<sub>r</sub> の値を comb (n - 1) r で求めて変数 k にセットします。v が k 以上であれば変数 c のビットを 1 にセットし、v から k を引き算して comb_to_num を再帰呼び出しします。そうでなければ、num_to_comb を再帰呼び出しするだけです。
</p>

<p> それでは、n = 5, r = 3 の場合の実行例を示します。
</p>
<pre>
# for i = 0 to 9 do
    let v = num_to_comb i 5 3 0 in
    let n = comb_to_num v 5 3 0 in
    Printf.printf "%d =&gt; %x =&gt; %d\n" i v n
  done;;
0 =&gt; 7 =&gt; 0
1 =&gt; b =&gt; 1
2 =&gt; d =&gt; 2
3 =&gt; e =&gt; 3
4 =&gt; 13 =&gt; 4
5 =&gt; 15 =&gt; 5
6 =&gt; 16 =&gt; 6
7 =&gt; 19 =&gt; 7
8 =&gt; 1a =&gt; 8
9 =&gt; 1c =&gt; 9
</pre>
<p> 正常に動作していますね。この方法を使うと、n 個ある組み合わせの中の i 番目 (0 &lt;= i &lt n) の組み合わせを簡単に求めることができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml20.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml22.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>