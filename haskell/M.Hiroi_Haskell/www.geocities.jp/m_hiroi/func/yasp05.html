<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Scheme Problems</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scheme Programming</h1>
<h2>Yet Another Scheme Problems</h2>
<div class="small">
[ <a href="yasp04.html">PrevPage</a> | <a href="scheme.html#yasp">Scheme</a> | <a href="yasp06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h4 id="p71">●問題71</h4>
<p> 前置記法の数式を後置記法に変換する関数 prefix-&gt;postfix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。
</p>
<pre>
gosh&gt; (prefix-&gt;postfix '(* (+ 1 2) (- 3 4)))
(1 2 + 3 4 - *)
gosh&gt; (prefix-&gt;postfix '(* (+ 1 2) (- 3 (/ 4 5))))
(1 2 + 3 4 5 / - *)
</pre>
<p> <a href="yasp05.html#ans71">解答</a>
</p>
<h4 id="p72">●問題72</h4>
<p> 後置記法の数式を前置記法に変換する関数 postfix-&gt;prefix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。
</p>
<pre>
gosh&gt; (postfix-&gt;prefix '(1 2 + 3 4 - *))
(* (+ 1 2) (- 3 4))
gosh&gt; (postfix-&gt;prefix '(1 2 + 3 4 5 / - *))
(* (+ 1 2) (- 3 (/ 4 5)))
</pre>
<p> <a href="yasp05.html#ans72">解答</a>
</p>
<h4 id="p73">●問題73</h4>
<p> 前置記法の数式を中置記法に変換する関数 prefix-&gt;infix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。なお、中置記法はカッコを使うことができます。
</p>
<pre>
gosh&gt; (prefix-&gt;infix '(* (+ 1 2) (- 3 4)))
((1 + 2) * (3 - 4))
gosh&gt; (prefix-&gt;infix '(* (+ 1 2) (- 3 (/ 4 5))))
((1 + 2) * (3 - (4 / 5)))
</pre>
<p> <a href="yasp05.html#ans73">解答</a>
</p>
<h4 id="p74">●問題74</h4>
<p> 中置記法で冗長なカッコをはずす関数 flatexpr expr を定義してください。
</p>
<pre>
gosh&gt; (flatexpr '((1 + 2) * (3 - 4)))
((1 + 2) * (3 - 4))
gosh&gt; (flatexpr '((1 + 2) + (3 - 4)))
(1 + 2 + 3 - 4)
gosh&gt; (flatexpr '((1 * 2) + (3 / 4)))
(1 * 2 + 3 / 4)
</pre>
<p> <a href="yasp05.html#ans74">解答</a>
</p>
<h4 id="p75">●問題75</h4>
<p> 中置記法の数式を前置記法に変換する関数 infix-&gt;prefix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。中置記法はカッコを使うことができます。
</p>
<pre>
gosh&gt; (infix-&gt;prefix '(1 + 2 + 3 + 4))
(+ (+ (+ 1 2) 3) 4)
()
gosh&gt; (infix-&gt;prefix '((1 + 2) * (3 - 4)))
(* (+ 1 2) (- 3 4))
()
gosh&gt; (infix-&gt;prefix '(1 * 2 + 3 / 4))
(+ (* 1 2) (/ 3 4))
()
</pre>
<p> <a href="yasp05.html#ans75">解答</a>
</p>
<h4 id="p76">●問題76</h4>
<p> 後置記法の数式を中置記法に変換する関数 postfix-&gt;infix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。中置記法はカッコを使うことができます。
</p>
<pre>
gosh&gt; (postfix-&gt;infix '(1 2 + 3 4 - *))
((1 + 2) * (3 - 4))
gosh&gt; (postfix-&gt;infix '(1 2 + 3 4 5 / - *))
((1 + 2) * (3 - (4 / 5)))
</pre>
<p> <a href="yasp05.html#ans76">解答</a>
</p>
<h4 id="p77">●問題77</h4>
<p> 中置記法の数式を後置記法に変換する関数 infix-&gt;postfix expr を定義してください。数式はリストで表して、演算子は +, -, *, / とします。中置記法はカッコを使うことができます。
</p>
<pre>
gosh&gt; (infix-&gt;postfix '(1 + 2 - 3 + 4))
(1 2 + 3 - 4 +)
()
gosh&gt; (infix-&gt;postfix '((1 + 2) * (3 - 4)))
(1 2 + 3 4 - *)
()
gosh&gt; (infix-&gt;postfix '((1 + 2) * (3 - 4 / 5)))
(1 2 + 3 4 5 / - *)
()
</pre>
<p> <a href="yasp05.html#ans77">解答</a>
</p>
<h4 id="p78">●問題78</h4>
<p> リスト ls のべき集合を求める関数 power-set ls を定義してください。たとえばリスト (a b c) のべき集合は nil, (a), (b), (c), (a b), (a c), (b c), (a b c) になります。
</p>
<pre>
gosh&gt; (power-set '(a b c))
(() (c) (b) (b c) (a) (a c) (a b) (a b c))
gosh&gt; (power-set1 display '(a b c))
(a b c)(a b)(a c)(a)(b c)(b)(c)()#&lt;undef&gt;
</pre>

<p> <a href="yasp05.html#ans78">解答</a>
</p>

<h4 id="p79">●問題79</h4>
<p> 複雑なデータ構造をファイルなどに保存する場合、データ構造を線形なデータに変換できると便利です。このような操作を「シリアライズ (serialize) 」とか「シリアル化」といいます。逆に、元のデータ構造に戻す操作を「デシリアライズ」といいます。
</p>
<p> リストを二分木として考えて、二分木をシリアライズする関数 serialize tree を定義してください。二分木は次の方法で簡単にシリアライズすることができます。
</p>
<ol>
  <li>二分木を行きがけ順に巡回する。
  <li>節ではフラグ 0 を出力して左右の枝をたどる。
  <li>葉に到達したらフラグ 1 と要素を出力する。
</ol>
<p> なお、シリアライズしたデータはリストに格納して返すことにします。
</p>
<pre>
gosh&gt; (serialize '(a . b))
(0 1 a 1 b)
gosh&gt; (serialize '((a . b) . c))
(0 0 1 a 1 b 1 c)
gosh&gt; (serialize '((a . b) (c . d)))
(0 0 1 a 1 b 0 0 1 c 1 d 1 ())
gosh&gt; (serialize '(a (b (c . d) e) f))
(0 1 a 0 0 1 b 0 0 1 c 1 d 0 1 e 1 () 0 1 f 1 ())
</pre>
<p> <a href="yasp05.html#ans79">解答</a>
</p>
<h4 id="p80">●問題80</h4>
<p> 関数 seriallize でシリアライズしたデータを復元する関数 deserialize ls を定義してください。
</p>
<pre>
gosh&gt; (deserialize '(0 1 a 1 b))
(a . b)
()
gosh&gt; (deserialize '(0 0 1 a 1 b 1 c))
((a . b) . c)
()
gosh&gt; (deserialize '(0 0 1 a 1 b 0 0 1 c 1 d 1 ()))
((a . b) (c . d))
()
</pre>
<p> <a href="yasp05.html#ans80">解答</a>
</p>
<h4 id="p81">●問題81</h4>
<p> バランスの取れた n 対のカッコ列を生成する高階関数 kakko func n を定義してください。カッコ列は ( と ) からなる列のことで、バランスが取れているカッコ列は、右カッコで閉じることができる、つまり右カッコに対応する左カッコがある状態のことをいいます。たとえば n = 1 の場合、( ) はバランスの取れたカッコ列ですが、) ( はバランスが取れていません。
</p>
<pre>
gosh&gt; (kakko print 3)
((()))
(()())
(())()
()(())
()()()
#&lt;undef&gt;
gosh&gt; (kakko print 4)
(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())(())
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()
#&lt;undef&gt;
</pre>
<p> <a href="yasp05.html#ans81">解答</a>
</p>
<h4 id="p82">●問題82</h4>
<p> カッコ列は二分木に対応させることができます。二分木の節をリスト (N L L) で表すことにします。N は節を表すシンボル、L は葉を表すシンボルとします。二分木をカッコ列に変換する関数 tree-&gt;kakko ls を定義してください。
</p>
<pre>
gosh&gt; (tree-&gt;kakko '(N (N (N L L) L) L))
"((()))"
gosh&gt; (tree-&gt;kakko '(N (N L L) (N L L)))
"(())()"
gosh&gt; (tree-&gt;kakko '(N L (N L (N L L))))
"()()()"
gosh&gt; (tree-&gt;kakko '(N L (N (N L L) L)))
"()(())"
gosh&gt; (tree-&gt;kakko '(N (N L (N L L)) L))
"(()())"
</pre>
<p> <a href="yasp05.html#ans82">解答</a>
</p>
<h4 id="p83">●問題83</h4>
<p> tree-&gt;kakko の逆変換を行う関数 kakko-&gt;tree を定義してください。
</p>
<pre>
gosh&gt; (kakko-&gt;tree "((()))")
(N (N (N L L) L) L)
()
gosh&gt; (kakko-&gt;tree "(())()")
(N (N L L) (N L L))
()
gosh&gt; (kakko-&gt;tree "()()()")
(N L (N L (N L L)))
()
gosh&gt; (kakko-&gt;tree "()(())")
(N L (N (N L L) L))
()
gosh&gt; (kakko-&gt;tree "(()())")
(N (N L (N L L)) L)
()
</pre>
<p> <a href="yasp05.html#ans83">解答</a>
</p>
<h4 id="p84">●問題84</h4>
<p> バランスの取れた n 対のカッコ列の総数を求める関数 kakko-num n を定義してください。
</p>
<pre>
gosh&gt; (kakko-num 1)
1
gosh&gt; (kakko-num 2)
2
gosh&gt; (kakko-num 3)
5
gosh&gt; (kakko-num 4)
14
gosh&gt; (kakko-num 5)
42
gosh&gt; (kakko-num 10)
16796
gosh&gt; (kakko-num 50)
1978261657756160653623774456
gosh&gt; (kakko-num 100)
896519947090131496687170070074100632420837521538745909320
</pre>
<p> <a href="yasp05.html#ans84">解答</a>
</p>
<h4 id="p85">●問題85</h4>
<p> 1 桁の 4 つの数字 (0 - 9 から 4 つ選ぶ) と *, -, *, /, ( ,) を使って、値が N になる式を求めるプログラムを作ってください。数字は並べ替えて使うことができます。ただし、18 や 26 のように複数の数字を連結して使ってはいけません。－を符号として使うことも禁止します。
</p>

<p> <a href="yasp05.html#ans85">解答</a>
</p>
<hr>
<h4 id="ans71">●解答71</h4>
<p> 前置記法を後置記法に変換するのは簡単です。次の図を見てください。
</p>
<pre class="fig">
          ＊
        ／  ＼
      ／      ＼
    ＋          －
  ／  ＼      ／  ＼
１      ２  ３      ４

図 : 数式 (* (+ 1 2) (- 3 4))
</pre>
<p> 上図のように、前置記法の数式は二分木そのものです。再帰呼び出しで二分木をたどり、(op x y) を (x y op) に変換すればいいだけです。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 前置記法 -&gt; 後置記法

(define (prefix-&gt;postfix expr)
  (cond ((pair? expr)
         (append (prefix-&gt;postfix (cadr expr))
                 (prefix-&gt;postfix (caddr expr))
                 (list (car expr))))
        (else (list expr))))
</pre>
<p> 引数 expr が数式を表すリストです。expr がリストの場合、prefix-&gt;postfix を再帰呼び出します。prefix-&gt;postfix の返り値はリストなので、カッコを外すために append で連結します。expr がリストでない場合、list で expr をリストに格納して返します。
</p>
<h4 id="ans72">●解答72</h4>
<p> postfix-&gt;prefix は、後置記法の計算で作成した関数 rpn を改造すると簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 後置記法 -&gt; 前置記法

(define (postfix-&gt;prefix expr)
  (let loop ((xs expr) (a '()))
    (cond ((null? xs)
           (if (null? (cdr a))
               (car a)
             (error "invalid expression")))
          ((number? (car xs))
           (loop (cdr xs) (cons (car xs) a)))
          ((symbol? (car xs))
           (loop (cdr xs) (cons (list (car xs) (cadr a) (car a)) (drop a 2))))
          (else
           (error "invalid data")))))
</pre>
<p> 演算子を処理する場合、値を計算するかわりに前置記法に変換した数式 (op x y) をスタック a に追加するだけです。
</p>
<h4 id="ans73">●解答73</h4>
<p> 前置記法から中置記法へ変換する場合、冗長なカッコを取り除かないでよければとても簡単です。数式 (op x y) を (x op y) に変換するだけでいいのです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 前置記法 -&gt; 中置記法

(define (prefix-&gt;infix expr)
  (if (pair? expr)
      (list (prefix-&gt;infix (cadr expr))
            (car expr)
            (prefix-&gt;infix (caddr expr)))
    expr))
</pre>

<p> 最初に expr をチェックして、リストでなければ expr をそのまま返します。これが再帰の停止条件になります。リストの場合は記法の変換を行います。prefix-&gt;infix を再帰呼び出しして引数を中置記法に変換します。そして、演算子を引数の間にセットして返します。
</p>

<h4 id="ans74">●解答74</h4>
<p> 冗長なカッコは、演算子の優先度を考慮することで取り除くことができます。たとえば、数式が ((1 + 2) * (3 / 4)) の場合を考えてみましょう。
</p>
<pre class="item">
 ((1 + 2) * (3 / 4)) =&gt; ((1 + 2) * 3 / 4)
</pre>
<p> 演算子 * と + では、+ の方の重みが小さいですね。この場合、+ の方はカッコをはずすことができません。次の演算子 / は * と重みが同じなので、カッコをはずすことができます。
</p>
<p> 基本的な処理はこれでいいのですが、ひとつだけ問題があります。それは演算子が - と / のときにカッコをはずす場合です。次の例を見てください。
</p>
<pre class="item">
(1 - (2 - (3 - 4))) =&gt; (1 - (2 - 3 + 4))
                    =&gt; (1 - 2 + 3 - 4)
(1 / (2 / (3 / 4))) =&gt; (1 / (2 / 3 * 4))
                    =&gt; (1 / 2 * 3 / 4)
</pre>
<p> このように、演算子が - のときはカッコ内の + と - を、/ のときはカッコ内の * と / を反転させないといけません。この処理は map を使うと簡単に実現できます。
</p>
<pre>
gosh&gt; (map (lambda (x) (case x (+ '-) (- '+) (else x))) '(2 - 3 + 4))
(2 + 3 - 4)
gosh&gt; (map (lambda (x) (case x (+ '-) (- '+) (else x))) '(2 * (3 - 4)))
(2 * (3 - 4))
</pre>
<p> リストの要素が + であれば - に、- であれば + に変更します。それ以外の要素はそのまま出力します。map はリストのトップレベルの要素に対してラムダ式を適用するので、たとえば、数式 (2 * (3 - 4)) の - を + に変更することはありません。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 余分なカッコをはずす

(define (change-op1 expr)
  (map (lambda (x)
         (case x
           ((+) '-)
           ((-) '+)
           (else x)))
       expr))

(define (change-op2 expr)
  (map (lambda (x)
         (case x
           ((*) '/)
           ((/) '*)
           (else x)))
       expr))

(define (check-op1 expr)
  (if (pair? (cdr expr))
      (case (cadr expr)
        ((+ -) (list expr))
        (else expr))
    expr))

(define (flatexpr expr)
  (if (pair? expr)
      (let ((e1 (flatexpr (car expr)))
            (e2 (flatexpr (caddr expr))))
        (case (cadr expr)
          ((+)
           (append e1 (list '+) e2))
          ((-)
           (append e1 (list '-) (change-op1 e2)))
          ((*)
           (append (check-op1 e1) (list '*) (check-op1 e2)))
          ((/)
           (append (check-op1 e1) (list '/) (change-op2 (check-op1 e2))))))
    (list expr)))
</pre>

<p> 関数 change-op1 は + と - を反転します。関数 change-op2 は * と / を反転します。関数 check-op1 は、演算子が + と - のとき、数式 expr をリストに格納して返します。これは演算子が * と / のときに呼び出します。
</p>

<p> 関数 flatexpr は引数 expr の余分なカッコをはずします。expr がリストの場合、flatexpr を再帰呼び出しします。(x op y) の x を変換して e1 に、y を変換して e2 にセットします。次に、op によって処理を分けます。+ の場合、append で e1 と (+) と e2 を連結するだけです。- の場合、change-op1 で e2 を変換して append で連結します。
</p>

<p> * の場合、check-op1 で e2 の演算子をチェックします。+ と - の場合、e2 はリストに格納されて返されるので、カッコがはずされることはありません。* と / の場合はカッコがはずされます。/ の場合は、check-op1 の返り値を change-op2 で変換します。これでカッコをはずしたあとで、* と / を反転することができます。
</p>

<h4 id="ans75">●解答75</h4>
<p> 中置記法を前置記法に変換する関数 infix-&gt;prefix は、中置記法を数式を計算する関数 expression を改造すると簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 中置記法 -&gt; 前置記法

(define (inf-pre-factor ls)
  (cond ((number? (car ls))
         (values (car ls) (cdr ls)))
        ((pair? (car ls))
         (values (infix-&gt;prefix (car ls)) (cdr ls)))
        (else
         (error "invalid expression"))))

(define (inf-pre-term ls)
  (receive (x xs) (inf-pre-factor ls)
    (let loop ((x x) (xs xs))
      (cond ((null? xs) (values x '()))
            ((= (weight (car xs)) 2)
             (receive (y ys) (inf-pre-factor (cdr xs))
               (loop (list (car xs) x y) ys)))
            (else (values x xs))))))

(define (infix-&gt;prefix ls)
  (receive (x xs) (inf-pre-term ls)
    (let loop ((x x) (xs xs))
      (cond ((null? xs) (values x '()))
            ((= (weight (car xs)) 1)
             (receive (y ys) (inf-pre-term (cdr xs))
               (loop (list (car xs) x y) ys)))
            (else (values x xs))))))
</pre>
<p> 項の処理を関数 inf-pre-term で、因子の処理を inf-pre-factor で行います。値を計算するかわりに、x op y を (op x y) に変換して返すだけです。
</p>

<h4 id="ans76">●解答76</h4>
<p> postfix-&gt;infix は、後置記法の計算で作成した関数 rpn を改造すると簡単に作成できます。次のリストを見てください。
</p>
<pre class="list">
リスト : 後置記法 -&gt; 中置記法

(define (postfix-&gt;infix expr)
  (let loop ((ls expr) (a '()))
    (cond ((null? ls)
           (if (null? (cdr a))
               (car a)
             (error "invalid expression")))
          ((number? (car ls))
           (loop (cdr ls) (cons (car ls) a)))
          ((symbol? (car ls))
           (if (null? (cdr a))
               (error "stack underflow")
             (loop (cdr ls)
                   (cons (list (cadr a) (car ls) (car a))
                         (drop a 2)))))
          (else
           (error "invalid data")))))
</pre>
<p> 演算子を処理する場合、値を計算するかわりに中置記法に変換した数式 (x op y) をスタック a に追加するだけです。余分なカッコをはずす場合は flatexpr を適用してください。
</p>
<h4 id="ans77">●解答77</h4>
<p> 中置記法を後置記法に変換する関数 infix-&gt;postfix は、中置記法を数式を計算する関数 expression を改造すると簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 中置記法 -&gt; 後置記法

(define (inf-post-factor ls)
  (cond ((number? (car ls))
         (values (list (car ls)) (cdr ls)))
        ((pair? (car ls))
         (values (infix-&gt;postfix (car ls)) (cdr ls)))
        (else
         (error "invalid expression"))))

(define (inf-post-term ls)
  (receive (x xs) (inf-post-factor ls)
    (let loop ((x x) (xs xs))
      (cond ((null? xs) (values x '()))
            ((= (weight (car xs)) 2)
             (receive (y ys) (inf-post-factor (cdr xs))
               (loop (append x y (list (car xs))) ys)))
            (else (values x xs))))))

(define (infix-&gt;postfix ls)
  (receive (x xs) (inf-post-term ls)
    (let loop ((x x) (xs xs))
      (cond ((null? xs) (values x '()))
            ((= (weight (car xs)) 1)
             (receive (y ys) (inf-post-term (cdr xs))
               (loop (append x y (list (car xs))) ys)))
            (else (values x xs))))))
</pre>
<p> 項の処理を関数 inf-post-term で、因子の処理を inf-post-factor で行います。値を計算するかわりに、x op y を (x y op) に変換します。このとき、append で連結してカッコをはずすことに注意してください。
</p>
<h4 id="ans78">●解答78</h4>
<pre class="list">
リスト : べき集合

; べき集合
(define (power-set ls)
  (if (null? ls)
      (list '())
    (append (power-set (cdr ls))
            (map (lambda (xs) (cons (car ls) xs))
                 (power-set (cdr ls))))))

; 別解
(define (power-set1 func ls)
  (define (power-sub ls a)
    (if (null? ls)
        (func (reverse a))
      (begin
        (power-sub (cdr ls) (cons (car ls) a))
        (power-sub (cdr ls) a))))
  ;
  (power-sub ls '()))
</pre>
<p> べき集合を求める関数 power-set は簡単です。ls が空リストの場合は nil を格納したリストを返します。そうでなければ power-set を再帰呼び出しして (cdr ls) のべき集合を求め、その集合に先頭要素 (car ls) を追加します。そして、その集合と (cdr ls) のべき集合を append で連結します。
</p>
<p> 別解の power-set1 は高階関数バージョンです。リストの長さを N とすると、べき集合の要素数は 2 ^ N になります。N が大きくなると、べき集合をリストに格納して返すことは困難になります。その場合は高階関数を使うとよいでしょう。
</p>

<h4 id="ans79">●解答79</h4>
<pre class="list">
リスト : 二分木のシリアライズ

(define (serialize tree)
  (if (pair? tree)
      (append (list 0)
              (serialize (car tree))
              (serialize (cdr tree)))
    (list 1 tree)))
</pre>
<p> 二分木のシリアライズは簡単です。引数 tree がリストの場合、0 を出力してから再帰呼び出しして CAR 部をたどり、それから CDR 部をたどります。その結果を append で連結すればいいわけです。葉 (要素) の場合は 1 と要素を格納したリストを返します。
</p>

<h4 id="ans80">●解答80</h4>
<pre class="list">
リスト : 二分木のデシリアライズ

(define (deserialize ls)
  (case (car ls)
    ((0)
     (receive (x ls1) (deserialize (cdr ls))
       (receive (y ls2) (deserialize ls1)
         (values (cons x y) ls2))))
    ((1)
     (values (cadr ls) (cddr ls)))
    (else
     (error "deserialize error"))))
</pre>

<p> デシリアライズも簡単です。関数 deserialize は生成した二分木と残りのデータを多値で返します。リスト ls の先頭要素が 0 の場合、deserialize を再帰呼び出しして CAR 部の部分木 x を生成し、それから CDR 部の部分木 y を生成します。あとは (cons x y) を返すだけです。ls の先頭要素が 1 の場合は葉なので、次の要素 (cadr ls) を返すだけです。
</p>
<h4 id="ans81">●解答81</h4>
<pre class="list">
リスト : カッコ列の生成

(define (kakko func m)
  (define (kakko-sub x y a)
    (cond ((= x y m)
           (func (list-&gt;string (reverse a))))
          (else
           (when (&lt; x m)
             (kakko-sub (+ 1 x) y (cons #\( a)))
           (when (&lt; y x)
             (kakko-sub x (+ 1 y) (cons #\) a))))))
  ;
  (kakko-sub 0 0 '()))
</pre>
<p> カッコ列の生成は簡単です。局所関数 kakko-sub の引数 x が左カッコの個数、引数 y が右カッコの個数を表します。引数 a は累積変数で、文字 #\(, #\) を格納したリストです。
</p>
<p>  バランスの取れたカッコ列の場合、x, y, m には y &lt;= x &lt;= m の関係が成り立ちます。x = y = m の場合、カッコ列がひとつ完成しました。リスト a を反転して list-&gt;string で文字列に変換し、引数の関数 func を呼び出します。そうでなければ、kakko-sub を再帰呼び出しします。x &lt; m であれば左カッコを追加し、y &lt; x であれば右カッコを追加します。これでカッコ列を生成することができます。
</p>

<h4 id="ans82">●解答82</h4>
<p> バランスの取れたカッコ列と二分木は 1 対 1 に対応します。二分木を行きがけ順で巡回するとき、途中の節では左カッコ ( を出力して左右の枝をたどり、葉に到達したら右カッコ ) を出力すると、カッコ列を生成することができます。
</p>
<pre class="list">
リスト : 二分木をカッコ列に変換

(define (tree-&gt;kakko ls)
  (define (tree-kakko-sub ls)
    (cond ((pair? ls)
           (append (list #\()
                   (tree-kakko-sub (cadr ls))
                   (tree-kakko-sub (caddr ls))))
          (else (list #\)))))
  ;
  (list-&gt;string (drop-right (tree-kakko-sub ls) 1)))
</pre>
<p> 実際の処理は局所関数 tree-kakko-sub で行います。基本的な考え方は関数 serialize と同じです。ただし、最後に余分な右カッコが付いてくるので、関数 drop-right で最後の要素を削除してから、list-&gt;string で文字列に変換しています。drop-right は SRFI-1 に定義されている関数です。
</p>
<h4 id="ans83">●解答83</h4>
<pre class="list">
リスト : カッコ列を二分木に変換

(define (kakko-&gt;tree ks)
  (define (kakko-sub ls)
    (cond ((null? ls) 
           (values 'L '()))
          ((eqv? (car ls) #\))
           (values 'L (cdr ls)))
          (else
           (receive (x xs) (kakko-sub (cdr ls))
             (receive (y ys) (kakko-sub xs)
               (values (list 'N x y) ys))))))
 ;
 (kakko-sub (string-&gt;list ks)))
</pre>
<p> 実際の処理は局所関数 kakko-sub で行います。基本的な考え方は関数 deserialize と同じです。ただし、右カッコがひとつ少ないので、引数 ls が空リストの場合は葉 L を返すようにします。
</p>

<h4 id="ans84">●解答84</h4>
<p> <a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%82%BF%E3%83%A9%E3%83%B3%E6%95%B0">カタラン数 - Wikipedia</a> によると、
</p>
カッコ列の総数は「カタラン数 (Catalan number) 」になるとのことです。カタラン数は次に示す公式で求めることができます。
<pre class="item">
         (2n)!
Ｃ<SUB>n</SUB> = ----------
       (n+1)!n!
</pre>
<p> これをそのままプログラムしてもいいのですが、それではちょっと面白くないので別な方法でプログラムを作ってみましょう。カタラン数は次に示す経路図において、A から B までの最短距離の道順を求めるとき、対角線を超えないものの総数に一致します。
</p>
<pre class="fig">
                    Ｂ                      Ｂ  
  ┌─┬─┬─┬─┐      ┌─┬─┬─０─14    
  │  │  │  │  │      │  │  │  │  │    
  ├─┼─┼─┼─┤      ├─┼─０─５─14    
  │  │  │  │  │      │  │  │  │  │    
  ├─┼─┼─┼─┤      ├─０─２─５─９    
  │  │  │  │  │      │  │  │  │  │    
  ├─┼─┼─┼─┤      ０─１─２─３─４    
  │  │  │  │  │      │  │  │  │  │    
  └─┴─┴─┴─┘      １─１─１─１─１    
Ａ                      Ａ                      

            図 : 道順の総数の求め方
</pre>
<p> A からある地点にいたる最短距離の道順の総数は、左隣と真下の地点の値を足したものになります。一番下の地点は 1 で、対角線を越えた地点は 0 になります。あとは下から順番に足し算していけば、A から B までの道順の総数を求めることができます。上図の場合はカラタン数 Ｃ<SUB>4</SUB> に相当し、その値は 14 となります。
</p>
<p> これをそのままプログラムすると、次のようになります。
</p>
<pre class="list">
リスト : カッコ列の総数

(define (kakko-num m)
  (let loop ((a (make-list (+ m 1) 1)))
    (cond ((null? (cdr a))
           (car a))
          (else
           (loop (cdr (reverse (fold (lambda (x b) (cons (+ x (car b)) b))
                                     (list 0)
                                     (cdr a)))))))))
</pre>
<p> 最初に make-list で一番下の地点の道順の総数 (1) を格納したリスト生成します。これが変数 a の初期値になります。引数 m のカラタン数を求める場合、リストの大きさは m + 1 になります。あとは、リストの要素がひとつになるまで named-let で処理を繰り返します。
</p>
<p> 一段上の地点の値を求める場合、畳み込み fold を使うと簡単です。初期値はリスト (0) とします。これが対角線を越えた地点の値を表します。a の先頭要素は不要なので、cdr で削除してから fold に渡します。ラムダ式の引数 x が真下の地点の値、引数 b の先頭要素が左隣の地点の値になります。
</p>
<p> あとは x と (car b) を足し算して、それを cons でリスト b の先頭に追加すればいいわけです。この場合、fold が返すリストは逆順になるので、reverse で反転してから cdr で先頭要素 (対角線を越えた地点の値) を削除します。これでカッコ列の総数 (カラタン数) を求めることができます。
</p>
<section class="contents">
<h4 id="120108">●別解 (2012/01/08)</h4>
<p> ベクタを使うともっと簡単になります。次の図を見てください。
</p>
<pre class="fig">
0 : #(1 1 1 1 1)

1 : #(1 1 1 1 1)

2 : #(1 1 1+1=2 2+1=3 3+1=4)
 =&gt; #(1 1 2 3 4)

3 : #(1 1 2 3+2=5 5+4=9)
 =&gt; #(1 1 2 5 9)

4 : #(1 1 2 5 5+9=14)
 =&gt; #(1 1 2 5 14)
</pre>
<p> 上図は Ｃ<SUB>n</SUB> (n = 4) を求める場合です。大きさが n + 1, 要素の値が 1 のベクタを用意します。n = 0, 1 の場合は n 番目の要素をそのまま返します。n が 2 よりも大きい場合、変数 i を 2 に初期化して、i - 1 番目以降の要素の累積和を求めます。<p> たとえば i = 2 の場合、2 番目の要素は 1 番目の要素と自分自身を加算した値 2 になります。3 番目の要素は 2 番目の要素と自分自身を足した値 3 になり、4 番目の要素は 3 + 1 = 4 になります。次に i を +1 して同じことを繰り返します。3 番目の要素は 2 + 3 = 5 になり、4 番目の要素は 5 + 4 = 9 になります。i = 4 のとき、4 番目の要素は 5 + 9 = 14 となり、Ｃ<SUB>4</SUB> の値を求めることができました。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : カッコ列の総数

(define (kakko-num1 n)
  (let ((table (make-vector (+ n 1) 1)))
    (do ((i 2 (+ i 1)))
        ((&lt; n i) (vector-ref table n))
      (do ((j i (+ j 1)))
          ((&lt; n j))
        (inc! (vector-ref table j) (vector-ref table (- j 1)))))))
</pre>
<p> 説明したことをそのままプログラムしただけなので、とくに難しいところはないと思います。
</p>
</section>
<h4 id="ans85">●解答85</h4>
<p> それではプログラムを作りましょう。数式を二分木で表すと、次に示す 5 つのパターンになります。
</p>
<pre class="fig">
            Ｘ                Ｘ                          Ｘ
          ／  ＼            ／  ＼                      ／  ＼
        ／      ＼        ａ      Ｙ                  Ｙ      ｄ  
      Ｙ          Ｚ            ／  ＼              ／  ＼
    ／  ＼      ／  ＼        ｂ      Ｚ          Ｚ      ｃ
  ａ     ｂ   ｃ      ｄ            ／  ＼      ／  ＼
                                  ｃ      ｄ  ａ      ｂ

          （１）             （２）                    （３）

      Ｘ                   Ｘ
    ／  ＼               ／  ＼
  ａ      Ｙ           Ｙ      ｄ
        ／  ＼       ／  ＼
      Ｚ      ｄ   ａ      Ｚ
    ／  ＼               ／  ＼
  ｂ      ｃ           ｂ      ｃ

    （４）               （５）

                図：数式のパターン（二分木）
</pre>
<p> X, Y, Z が演算子を表します。これを式で表すと、次のようになります。
</p>
<pre class="item">
(1) (a Y b) X (c Z d)
(2) a X (b Y (c Z d))
(3) ((a Z b) Y c) X d
(4) a X ((b Z c) Y d)
(5) (a Y (b Z c)) X d
</pre>
<p> あとは、a, b, c, d に数字を、X, Y, Z に演算子 +, -, *, / を入れて数式を計算すればいいわけです。ただし、注意事項がひとつあります。Gauche の場合、0 で除算してもエラーにはなりません。次の例を見てください。
</p>
<pre>
gosh&gt; (/ 1 0)
+inf.0
gosh&gt; (+ (/ 1 0) 1)
+inf.0
gosh&gt; (= 10 +inf.0)
#f
</pre>
<p> このように、Gauche では +inf.0 のまま計算できますが、0 で除算したときにエラーを送出する処理系の場合は、エラーを捕捉する処理が必要になります。ご注意くださいませ。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 切符番号の問題

; 数式を作る
(define (make-expr x y z a b c d)
  `(((,a ,y ,b) ,x (,c ,z ,d))
    (,a ,x (,b ,y (,c ,z ,d)))
    (((,a ,z ,b) ,y ,c) ,x ,d)
    (,a ,x ((,b ,z ,c) ,y ,d))
    ((,a ,y (,b ,z ,c)) ,x ,d)))

; 判定関数の生成
(define (make-checker n)
  (let ((table '()))
    (lambda (expr)
      (let ((e1 (flatexpr expr)))
        (when (and (= (expression e1) n)
                   (not (member e1 table)))
          (push! table e1)
          (print e1))))))

; 解法
(define (solve fn ls)
  (for-each
    (lambda (op)
      (for-each
        (lambda (nums)
          (for-each
            (lambda (expr) (fn expr))
            (apply make-expr (append op nums))))
        (permutation 4 ls)))
    (repeat-perm 3 '(+ - * /))))
</pre>
<p> 関数 make-expr は数字と演算子から 5 つ数式をリストに格納して返します。関数 make-checker は数式をチェックする関数を生成して返します。この関数の中で数式 expr を計算します。数式の計算は expression を使うと簡単です。このとき、flatexpr で冗長なカッコをはずしておきます。値が引数 n と等しくて、今までに出現していない数式であれば、それを table に格納して print で表示します。
</p>
<p> 関数 solve は for-each を 3 重で使います。最初に演算子の組み合わせを求めます。これは重複順列になるので関数 repeat-perm を使うと簡単です。次に数字の並びを求めます。これは順列になるので関数 permutaiton を使います。最後に、make-expr で 5 つの数式を生成し、引数として渡された関数 fn を呼び出して、条件を満たしている数式を出力します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
gosh&gt; (solve (make-checker 10) '(6 7 8 9))
(6 + 8 / (9 - 7))
(8 / (9 - 7) + 6)
(8 * (9 - 7) - 6)
((9 - 7) * 8 - 6)
(6 - 8 / (7 - 9))
((7 + 8) * 6 / 9)
((8 + 7) * 6 / 9)
(6 * (7 + 8) / 9)
(6 * (8 + 7) / 9)
(6 / 9 * (7 + 8))
(6 / 9 * (8 + 7))
((7 + 8) / 9 * 6)
((8 + 7) / 9 * 6)
#&lt;undef&gt;
gosh&gt; (solve (make-checker 10) '(1 2 6 9))
(6 + (9 - 1) / 2)
((9 - 1) / 2 + 6)
(2 * (9 - 1) - 6)
((9 - 1) * 2 - 6)
(6 - (1 - 9) / 2)
#&lt;undef&gt;
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011-2012 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="yasp04.html">PrevPage</a> | <a href="scheme.html#yasp">Scheme</a> | <a href="yasp06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>