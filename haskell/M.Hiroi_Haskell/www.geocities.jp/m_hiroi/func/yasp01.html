<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Scheme Problems</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881785</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scheme Programming</h1>
<h2>Yet Another Scheme Problems</h2>
<div class="small">
[ PrevPage | <a href="scheme.html#yasp">Scheme</a> | <a href="yasp02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 今回はちょっと便利な関数を問題形式で紹介します。元ネタは <a href="http://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">P-99: Ninety-Nine Prolog Problems</a> です。問題は拙作のページ <a href="../prolog/index.html">Prolog Programming</a> <a href="../prolog/yapp01.html">Yet Anotehr Prolog Problems</a> と同じですが、あしからずご了承くださいませ。
</p>

<h4 id="p01">●問題１</h4>
<p> リストの要素がただひとつか調べる述語 single? を定義してください。
</p>
<pre>
gosh&gt; (single? '(a))
#t
gosh&gt; (single? '(a b))
#f
gosh&gt; (single? '())
#f
</pre>
<p><a href="yasp01.html#ans01">解答</a>
</p>
<h4 id="p02">●問題２</h4>
<p> リストの要素が二つあるか調べる述語 double? を定義してください。
</p>
<pre>
gosh&gt; (double? '(a b))
#t
gosh&gt; (double? '(a b c))
#f
gosh&gt; (double? '(a))
#f
</pre>
<p><a href="yasp01.html#ans02">解答</a>
</p>
<h4 id="p03">●問題３</h4>
<p> リスト xs はリスト ys よりも長いか調べる述語 longer? xs ys を定義してください。
</p>
<pre>
gosh&gt; (longer? '(a b c) '(a b))
#t
gosh&gt; (longer? '(a b) '(a b))
#f
gosh&gt; (longer? '(a) '(a b))
#f
</pre>
<p><a href="yasp01.html#ans03">解答</a>
</p>
<h4 id="p04">●問題４</h4>
<p> リスト xs の最後尾を求める関数 last と、最後尾の要素を取り除く関数 butlast を定義してください。
</p>
<pre>
gosh&gt; (last '(a b c))
(c)
gosh&gt; (last '(a))
(a)
gosh&gt; (butlast '(a b c))
(a b)
gosh&gt; (butlast '(a))
()
</pre>
<p><a href="yasp01.html#ans04">解答</a>
</p>
<h4 id="p05">●問題５</h4>
<p> リスト xs の先頭から n 個の要素を取り出す関数 take xs n を定義してください。
</p>
<pre>
gosh&gt; (take '(a b c d e) 3)
(a b c)
gosh&gt; (take '(a b c d e) 0)
()
gosh&gt; (take '(a b c d e) 6)
(a b c d e)
</pre>
<p><a href="yasp01.html#ans05">解答</a>
</p>
<h4 id="p06">●問題６</h4>
<p> リスト xs の先頭から n 個の要素を取り除く関数 drop xs n を定義してください。
</p>
<pre>
gosh&gt; (drop '(a b c d e) 3)
(d e)
gosh&gt; (drop '(a b c d e) 0)
(a b c d e)
gosh&gt; (drop '(a b c d e) 6)
()
</pre>
<p><a href="yasp01.html#ans06">解答</a>
</p>
<h4 id="p07">●問題７</h4>
<p> リスト xs の n 番目から m - 1 番目までの要素を部分リストとして取り出す関数 subseq xs n m を定義してください。なお、リストの要素は 0 から数え始めるものとします。
</p>
<pre>
gosh&gt; (subseq '(a b c d e) 2 4)
(c d)
gosh&gt; (subseq '(a b c d e) 0 5)
(a b c d e)
gosh&gt; (subseq '(a b c d e) 0 0)
()
</pre>
<p><a href="yasp01.html#ans07">解答</a>
</p>
<h4 id="p08">●問題８</h4>
<p> リスト xs の末尾から n 個の要素を取り除く関数 butlastn xs n を定義してください。
</p>
<pre>
gosh&gt; (butlastn '(a b c d e) 3)
(a b)
gosh&gt; (butlastn '(a b c d e) 0)
(a b c d e)
gosh&gt; (butlastn '(a b c d e) 5)
()
</pre>
<p><a href="yasp01.html#ans08">解答</a>
</p>
<h4 id="p09">●問題９</h4>
<p> リスト xs を長さ n の部分リストに分割する関数 group xs n を定義してください。
</p>
<pre>
gosh&gt; (group '(a b c d e f) 2)
((a b) (c d) (e f))
gosh&gt; (group '(a b c d e f) 3)
((a b c) (d e f))
gosh&gt; (group '(a b c d e f) 4)
((a b c d) (e f))
</pre>
<p><a href="yasp01.html#ans09">解答</a>
</p>
<h4 id="p10">●問題10</h4>
<p> リスト ls の中から x と等しい要素の位置 n を求める関数 position x ls を定義してください。なお、リストの要素は 0 から数え始めるものとします。
</p>
<pre>
gosh&gt; (position 'a '(a b c d e))
0
gosh&gt; (position 'c '(a b c d e))
2
gosh&gt; (position 'e '(a b c d e))
4
gosh&gt; (position 'f '(a b c d e))
#f
</pre>
<p><a href="yasp01.html#ans10">解答</a>
</p>
<h4 id="p11">●問題11</h4>
<p> リスト ls から x と等しい要素の個数 n を求める関数 count x ls を定義してください。
</p>
<pre>
gosh&gt; (count 'a '(a b a b c a b c d))
3
gosh&gt; (count 'c '(a b a b c a b c d))
2
gosh&gt; (count 'd '(a b a b c a b c d))
1
gosh&gt; (count 'e '(a b a b c a b c d))
0
</pre>
<p><a href="yasp01.html#ans11">解答</a>
</p>
<h4 id="p12">●問題12</h4>
<p> リストの要素の合計値を求める関数 sum-list を定義してください。
</p>
<pre>
gosh&gt; (sum-list '(1 2 3 4 5))
15
</pre>
<p><a href="yasp01.html#ans12">解答</a>
</p>
<h4 id="p13">●問題13</h4>
<p> リストの中から最大値を求める関数 max-list と最小値を求める関数 min-list を定義してください。
</p>
<pre>
gosh&gt; (max-list '(5 6 4 7 3 8 2 9 1))
9
gosh&gt; (min-list '(5 6 4 7 3 8 2 9 1))
1
</pre>
<p><a href="yasp01.html#ans13">解答</a>
</p>
<h4 id="p14">●問題14</h4>
<p> リスト ls の中で要素 x の右隣に要素 y があるかチェックする述語 adjacent? x y ls を定義してください。
</p>
<pre>
gosh&gt; (adjacent? 'a 'b '(a b c d e f))
#t
gosh&gt; (adjacent? 'e 'f '(a b c d e f))
#t
gosh&gt; (adjacent? 'f 'e '(a b c d e f))
#f
</pre>
<p><a href="yasp01.html#ans14">解答</a>
</p>
<h4 id="p15">●問題15</h4>
<p> リスト ls の中で要素 x が 要素 y よりも前に出現しているか調べる述語 before? x y ls を定義してください。
</p>
<pre>
gosh&gt; (before? 'a 'b '(a b c d e f))
(b c d e f)
gosh&gt; (before? 'c 'b '(a b c d e f))
#f
</pre>
<p><a href="yasp01.html#ans15">解答</a>
</p>
<h4 id="p16">●問題16</h4>
<p> 整数 n から m までを格納したリストを作る関数 iota n m を定義してください。
</p>
<pre>
gosh&gt; (iota 1 5)
(1 2 3 4 5)
</pre>
<p><a href="yasp01.html#ans16">解答</a>
</p>
<h4 id="p17">●問題17</h4>
<p> リストから重複要素を取り除いて集合を生成する関数 set-of-list を定義してください。
</p>
<pre>
gosh&gt; (set-of-list '(a b c d e f a b c))
(d e f a b c)
</pre>
<p><a href="yasp01.html#ans17">解答</a>
</p>
<h4 id="p18">●問題18</h4>
<p> 2 つの集合の和を求める関数 union を定義してください。
</p>
<pre>
gosh&gt; (union '(a b c d) '(c d e f))
(a b c d e f)
</pre>
<p><a href="yasp01.html#ans18">解答</a>
</p>
<h4 id="p19">●問題19</h4>
<p> 2 つの集合の積を求める関数 intersection を定義してください。
</p>
<pre>
gosh&gt; (intersection '(a b c d) '(c d e f))
(c d)
</pre>
<p><a href="yasp01.html#ans19">解答</a>
</p>
<h4 id="p20">●問題20</h4>
<p> 2 つの集合の差を求める関数 difference を定義してください。
</p>
<pre>
gosh&gt; (difference '(a b c d) '(c d e f))
(a b)
</pre>
<p><a href="yasp01.html#ans20">解答</a>
</p>
<h4 id="p21">●問題21</h4>
<p> 2 つのソート済みのリストをひとつのソート済みのリストにまとめる関数 merge-list を定義してください。
</p>
<pre>
gosh&gt; (merge-list &lt; '(1 3 5 7) '(2 4 6 8))
(1 2 3 4 5 6 7 8)
</pre>
<p><a href="yasp01.html#ans21">解答</a>
</p>
<h4 id="p22">●問題22</h4>
<p> 関数 merge-list を使ってリストをソートする merge-sort を定義してください。
</p>
<pre>
gosh&gt; (merge-sort &lt; 9 '(5 6 4 7 8 3 2 9 1 10))
(1 2 3 4 5 6 7 8 9)
gosh&gt; (merge-sort &lt; 10 '(5 6 4 7 8 3 2 9 1 10))
(1 2 3 4 5 6 7 8 9 10)
gosh&gt; (merge-sort &lt; 11 '(5 6 4 7 8 3 2 9 1 10 0))
(0 1 2 3 4 5 6 7 8 9 10)
</pre>
<p><a href="yasp01.html#ans22">解答</a>
</p>
<h4 id="p23">●問題23</h4>
<p> リスト ps がリスト ls の「接頭辞 (prefix) 」か判定する関数 prefix ls ps を定義してください。接頭辞とは、列の先頭からある位置までの部分列のことです。リスト [a, b, c, d] の接頭辞は [ ], [a], [a, b], [a, b, c], [a, b, c, d] の 5 つになります。
</p>
<pre>
gosh&gt; (prefix '(a b c d e f) '(a b c))
#t
gosh&gt; (prefix '(a b c d e f) '(a b c e))
#f
gosh&gt; (prefix '(a b c d e f) '())
#t
</pre>
<p><a href="yasp01.html#ans23">解答</a>
</p>
<h4 id="p24">●問題24</h4>
<p> リスト ss がリスト ls の「接尾辞 (suffix) 」か判定する関数 suffix ls ss を定義してください。接尾辞とは、列のある位置から末尾までの部分列のことです。リスト [a, b, c, d] の接尾辞は [a, b, c, d], [b, c, d], [c, d], [d], [ ] の 5 つになります。
</p>
<pre>
gosh&gt; (suffix '(a b c d e f) '(d e f))
#t
gosh&gt; (suffix '(a b c d e f) '())
#t
gosh&gt; (suffix '(a b c d e f) '(f g))
#f
</pre>
<p><a href="yasp01.html#ans24">解答</a>
</p>
<h4 id="p25">●問題25</h4>
<p> リスト xs がリスト ls の部分リストか判定する関数 sublist xs ls を定義してください。
</p>
<pre>
gosh&gt; (sublist '(c d e) '(a b c d e f))
#t
gosh&gt; (sublist '(d e) '(a b c d e f))
#t
gosh&gt; (sublist '(d e g) '(a b c d e f))
#f
gosh&gt; (sublist '() '(a b c d e f))
#t
</pre>
<p><a href="yasp01.html#ans25">解答</a>
</p>
<hr>
<h4 id="ans01">●解答１</h4>
<pre class="list">
リスト : 要素がただひとつか

(define (single? ls) 
  (and (pair? ls) (null? (cdr ls))))
</pre>
<p> Scheme の場合、引数 ls がリストで、かつ (cdr ls) が空リストであれば、そのリストの要素は一つしかないことがわかります。length でリストの長さを求める必要はありません。
</p>
<h4 id="ans02">●解答２</h4>
<pre class="list">
リスト : 要素が二つあるか

(define (double? ls)
  (and (pair? ls) (single? (cdr ls))))
</pre>
<p> Scheme の場合、述語 pair? が真であればリストに一つ以上の要素があることがわかります。あとは (cdr ls) が一つしか要素がないことを述語 single? で確認します。length でリストの長さを求める必要はありません。
</p>
<h4 id="ans03">●解答３</h4>
<pre class="list">
リスト : リスト xs は ys よりも長いか

(define (longer? xs ys)
  (cond ((null? xs) #f)
        ((null? ys) #t)
        (else
         (longer? (cdr xs) (cdr ys)))))

; 別解
(define (longer? xs ys)
  (and (pair? xs)
       (or (null? ys)
           (longer? (cdr xs) (cdr ys)))))
</pre>
<p> リストの先頭から順番にたどり、途中で ys が空リストになれば ys の方が長いことがわかります。length でリストの長さを求めて比較するよりも、このプログラムの方が効率的だと思います。
</p>
<h4 id="ans04">●解答４</h4>
<pre class="list">
リスト :  リストの最後尾を求める

(define (last ls)
  (if (null? (cdr ls))
      ls
    (last (cdr ls))))
</pre>
<p> 関数 last は単純な再帰定義でリストの最後尾を求めています。Gauche には同じ働きをする関数 last-pair があります。
</p>
<pre class="list">
リスト : 最後尾の要素を取り除く

(define (butlast ls)
  (if (single? ls)
      '()
    (cons (car ls) (butlast (cdr ls)))))

; 別解
(define (butlast ls)
  (let loop ((ls ls) (a '()))
    (if (single? ls)
        (reverse! a)
      (loop (cdr ls) (cons (car ls) a)))))
</pre>
<p> butlast は引数のリスト ls の要素が一つになるまで再帰呼び出しをします。要素が一つになったら空リストを返します。あとは、再帰呼び出しからの返り値に cons で要素を追加していくだけです。
</p>
<p> 別解は named let による末尾再帰バージョンです。累積変数 a に要素を格納し、引数 ls の要素がひとつになったならば、reverse! でリスト a を破壊的に反転して返します。reverse を使うよりも効率的です。
</p>

<h4 id="ans05">●解答５</h4>
<pre class="list">
リスト : リストの先頭から n 個の要素を取り出す

(define (take ls n)
  (if (or (&lt;= n 0) (null? ls))
      '()
    (cons (car ls) (take (cdr ls) (- n 1)))))

; 別解
(define (take ls n)
  (let loop ((ls ls) (n n) (a '()))
    (if (or (&lt;= n 0) (null? ls))
        (reverse! a)
      (loop (cdr ls) (- n 1) (cons (car ls) a)))))
</pre>
<p> 引数 n が 0 以下または引数 ls が空リストの場合は空リストを返します。そうでなければ take を再帰呼び出しして、その返り値にリストの先頭要素 (car ls)  を追加します。別解は named let による末尾再帰バージョンです。累積変数 a に要素を格納して、n が 0 以下または ls が空リストになったら、reverse! でリスト a を破壊的に反転して返します。
</p>
<p> なお、take は Scheme のライブラリ SRFI-1 に用意されています。
</p>
<h4 id="ans06">●解答６</h4>
<pre class="list">
リスト : リストの先頭から n 個の要素を削除する

(define (drop ls n)
  (if (or (&lt;= n 0) (null? ls))
      ls
    (drop (cdr ls) (- n 1))))
</pre>
<p> drop は簡単です。引数 n が 0 以下または引数 ls が空リストになるまで drop を再帰呼び出しするだけです。なお、drop は Scheme のライブラリ SRFI-1 に用意されています。
</p>
<h4 id="ans07">●解答７</h4>
<pre class="list">
リスト : 部分リストを取り出す

(define (subseq ls s e)
  (take (drop ls s) (- e s)))
</pre>
<p> subseq は drop と take を使うと簡単です。drop で ls から s 個の要素を取り除き、そのリストから e - s 個の要素を take で取り出すだけです。
</p>

<h4 id="ans08">●解答８</h4>
<pre class="list">
リスト : リストの末尾から n 個の要素を取り除く

(define (butlastn ls n)
  (take ls (- (length ls) n)))
</pre>
<p> リスト ls の長さを m とすると、リストの末尾から n 個の要素を取り除くことは、リストの先頭から m - n 個の要素を取り出すことと同じになります。取り出す要素の個数を (- (length ls) n)) で求めて take で要素を取り出します。
</p>
<h4 id="ans09">●解答９</h4>
<pre class="list">
リスト : リストの分割

(define (group ls n)
  (if (null? ls)
      '()
    (cons (take ls n) (group (drop ls n) n))))

; 別解
(define (group ls n)
  (let loop ((ls ls) (a '()))
    (if (null? ls)
        (reverse! a)
      (loop (drop ls n) (cons (take ls n) a)))))
</pre>
<p> 関数 group は take と drop を使うと簡単に定義できます。ls が空リストの場合は分割できないので空リストを返します。これが再帰の停止条件になります。ls が空リストでない場合、まず take で n 個の要素を格納したリストを求めます。次に、n 個の要素を取り除いたリストを drop で求めて group を再帰呼び出しします。その返り値に take で取り出したリストを cons で追加すればいいわけです。
</p>

<p> 別解は named let による末尾再帰バージョンです。take で取り出したリストを累積変数 a に格納し、ls が空リストになったら reverse! でリスト a を破壊的に反転して返します。
</p>
<h4 id="ans10">●解答10</h4>
<pre class="list">
リスト : 要素の位置を求める

(define (position x ls)
  (let loop ((ls ls) (n 0))
    (cond ((null? ls) #f)
          ((eqv? (car ls) x) n)
          (else
           (loop (cdr ls) (+ n 1))))))
</pre>
<p> named let の引数 n が要素の位置を表します。ls が空リストの場合、x と等しい要素は見つからなかったので #f を返します。そうでなければ、述語 eqv? でリストの先頭要素 (car ls) と x を比較します。等しい場合は n を返します。等しくない場合は loop を再帰呼び出しして次の要素を調べます。
</p>

<h4 id="ans11">●解答11</h4>
<pre class="list">
リスト : 要素の個数を求める

(define (count x ls)
  (let loop ((ls ls) (n 0))
    (cond ((null? ls) n)
          ((eqv? (car ls) x) (loop (cdr ls) (+ n 1)))
          (else (loop (cdr ls) n)))))

; 別解
(define (count x ls)
  (fold (lambda (y n) (if (eqv? x y) (+ n 1) n)) 0 ls))
</pre>
<p> named let でリストの要素を順番に調べ、x と等しい要素が見つかれば累積変数 n の値を +1 します。別解は畳み込みを行う関数 fold を使ったバージョンです。fold は Gauche で定義されているものを使いました。
</p>

<h4 id="ans12">●解答12</h4>
<pre class="list">
リスト : 要素の合計値を求める

(define (sum-list ls)
  (let loop ((ls ls) (sum 0))
    (if (null? ls)
        sum
      (loop (cdr ls) (+ (car ls) sum)))))

; 別解
(define (sum-list ls)
  (fold (lambda (x sum) (+ x sum)) 0 ls))
</pre>
<p> sum-list は named let でリストの要素を累積変数 sum に加算するだけです。別解は畳み込みを行う関数 fold を使ったバージョンです。
</p>

<h4 id="ans13">●解答13</h4>
<pre class="list">
リスト : リストから最大値と最小値を求める

(define (max-list ls)
  (let loop ((ls (cdr ls)) (a (car ls)))
    (cond ((null? ls) a)
          ((&lt; a (car ls)) (loop (cdr ls) (car ls)))
          (else (loop (cdr ls) a)))))

(define (min-list ls)
  (let loop ((ls (cdr ls)) (a (car ls)))
    (cond ((null? ls) a)
          ((&gt; a (car ls)) (loop (cdr ls) (car ls)))
          (else (loop (cdr ls) a)))))

; 別解
(define (max-list ls)
  (fold (lambda (x a) (if (&lt; a x) x a)) (car ls) (cdr ls)))

(define (min-list ls)
  (fold (lambda (x a) (if (&gt; a x) x a)) (car ls) (cdr ls)))
</pre>
<p> max_list と min_list は named let でプログラムしています。累積変数 a にリスト ls の先頭要素をセットします。あとは、残りの要素を順番に調べ、a よりも大きい (小さい) 要素を見つけたら、その値を a にセットします。別解は fold を使ったバージョンです。
</p>

<h4 id="ans14">●解答14</h4>
<pre class="list">
リスト : x と y は隣り合っているか

(define (adjacent x y ls)
  (if (and (pair? ls) (pair? (cdr ls)))
      (if (and (eqv? (car ls) x) (eqv? (cadr ls) y))
          #t
        (adjacent x y (cdr ls)))
    #f))

; 別解
(define (adjacent x y ls)
  (let ((xs (memv x ls)))
    (if xs
        (if (eqv? (cadr xs) y)
            #t
          (adjacent x y (cdr xs)))
      #f)))
</pre>
<p> 最初にリストの要素が二つ以上あることをチェックします。次に、先頭の要素が x と等しくて、次の要素が y と等しいことをチェックします。そうであれば #t を返し、そうでなければ adjacent を再帰呼び出しして、次の要素を調べます。別解は関数 memv を使ったバージョンです。
</p>

<h4 id="ans15">●解答15</h4>
<pre class="list">
リスト : x は y よりも前に出現しているか

(define (before x y ls)
  (let ((xs (memv x ls)))
    (if xs
        (memv y (cdr xs))
      #f)))
</pre>
<p> 関数 before は関数 memv を使うと簡単にプログラムすることができます。ls から x を memv で探します。x を見つけた場合、xs の先頭要素は x になります。それを取り除いたリストから memv で y を探せばいいわけです。
</p>

<h4 id="ans16">●解答16</h4>
<pre class="list">
リスト : 数列の生成

(define (iota n m)
  (if (&gt; n m)
      '()
    (cons n (iota (+ n 1) m))))

; 別解
(define (iota n m)
  (let loop ((m m) (a '()))
    (if (&lt; m n)
        a
      (loop (- m 1) (cons m a)))))
</pre>
<p> 関数 iota は簡単です。n が m より大きい場合は空リストになります。n が m 以下の場合、iota を再帰呼び出しして n + 1 から m までのリストを生成し、その先頭に n を追加するだけです。別解は named let を使ったバージョンです。この場合、後ろから数値を生成していることに注意してください。m が n よりも小さくなったならばリスト a を返します。
</p>
<h4 id="ans17">●解答17</h4>
<pre class="list">
リスト : 集合の生成

(define (set-of-list ls)
  (cond ((null? ls) '())
        ((memv (car ls) (cdr ls))
         (set-of-list (cdr ls)))
        (else
         (cons (car ls) (set-of-list (cdr ls))))))

; 別解
(define (set-of-list ls)
  (let loop ((ls ls) (a '()))
    (cond ((null? ls) (reverse! a))
          ((memv (car ls) (cdr ls))
           (loop (cdr ls) a))
          (else
           (loop (cdr ls) (cons (car ls) a))))))
</pre>
<p> 述語 set-of-list はリストから重複要素を取り除きます。空リストは重複要素がないので空リストのままです。次の節で、リストの先頭要素 (car ls) が残りのリスト (cdr ls) にあるか memv で調べ、同じ要素があれば集合に加えません。else 節で同じ要素がない場合はそれを集合に加えます。別解は named let を使った末尾再帰バージョンです。
</p>
<h4 id="ans18">●解答18</h4>
<pre class="list">
リスト : 集合の和

(define (union xs ys)
  (cond ((null? xs) ys)
        ((memv (car xs) ys)
         (union (cdr xs) ys))
        (else
         (cons (car xs) (union (cdr xs) ys)))))

; 別解 1
(define (union xs ys)
  (let loop ((xs xs) (a ys))
    (cond ((null? xs) a)
          ((memv (car xs) ys)
           (loop (cdr xs) a))
          (else
           (loop (cdr xs) (cons (car xs) a))))))

; 別解 2
(define (union xs ys)
  (fold (lambda (x a) (if (memv x ys) a (cons x a))) ys xs))
</pre>
<p> 最初の節は空集合 (空リスト) と集合 ys の和は ys であることを表しています。次の節で、要素 (car xs) が集合 ys に含まれていれば、それを新しい集合に加えません。else 節で (car xs) が ys に含まれていなければ、それを集合に追加します。別解は named let と fold を使ったバージョンです。
</p>
<h4 id="ans19">●解答19</h4>
<pre class="list">
リスト : 集合の積

(define (intersection xs ys)
  (cond ((null? xs) '())
        ((memv (car xs) ys)
         (cons (car xs) (intersection (cdr xs) ys)))
        (else
         (intersection (cdr xs) ys))))

; 別解 1
(define (intersection xs ys)
  (let loop ((xs xs) (a '()))
    (cond ((null? xs) a)
          ((memv (car xs) ys)
           (loop (cdr xs) (cons (car xs) a)))
          (else
           (loop (cdr xs) a)))))

; 別解 2
(define (intersection xs ys)
  (fold (lambda (x a) (if (memv x ys) (cons x a) a)) '() xs))
</pre>
<p> 最初の節は空集合 (空リスト) と集合 ys の積は空集合であることを表しています。次の節で、要素 (car xs) が集合 ys に含まれていれば、それを新しい集合に追加します。そうでなければ、else 節で要素 (car xs) を集合に追加しません。別解は named let と fold を使ったバージョンです。
</p>
<h4 id="ans20">●解答20</h4>
<pre class="list">
リスト : 集合の差

(define (difference xs ys)
  (cond ((null? xs) '())
        ((memv (car xs) ys)
         (difference (cdr xs) ys))
        (else
         (cons (car xs) (difference (cdr xs) ys)))))

; 別解 1
(define (difference xs ys)
  (let loop ((xs xs) (a '()))
    (cond ((null? xs) a)
          ((memv (car xs) ys)
           (loop (cdr xs) a))
          (else
           (loop (cdr xs) (cons (car xs) a))))))

; 別解 2
(define (difference xs ys)
  (fold (lambda (x a) (if (memv x ys) a (cons x a))) '() xs))
</pre>
<p> 最初の節は、空集合と集合 ys の差は空集合であることを表しています。次の節で、要素 (car xs) が ys に含まれいる場合は集合にそれを追加しません。そうでなければ、else 節で要素 (car xs) を集合に追加します。別解は named let と fold を使ったバージョンです。
</p>
<h4 id="ans21">●解答21</h4>
<pre class="list">
リスト : リストのマージ

(define (merge-list pred xs ys)
  (cond ((null? xs) ys)
        ((null? ys) xs)
        ((pred (car xs) (car ys))
         (cons (car xs) (merge-list pred (cdr xs) ys)))
        (else
         (cons (car ys) (merge-list pred xs (cdr ys))))))
</pre>
<p> 最初の節は、空リストとリスト ys をマージすると ys になることを表しています。次の節は、リスト xs と空リストをマージすると xs になることを表しています。この 2 つの節が、再帰呼び出しの停止条件になります。
</p>
<p> 3 番目の節で、それぞれのリストの先頭要素を述語 pred で比較し、pred が真を返す場合は (car xs) をマージしたリストの先頭に追加し、そうでなければ最後の節で (car ys) をマージしたリストの先頭に追加します。merge-list を再帰呼び出しするときは、xs または ys の先頭要素を取り除いて呼び出すことに注意してください。
</p>
<h4 id="ans22">●解答22</h4>
<p> マージソートはリストの長さを 1, 2, 4, 8, ... と増やしていくよりも、再帰的に考えた方が簡単です。まず、ソートするリストを 2 つに分割して、前半部分をソートします。次に、後半部分をソートして、その結果をマージすればいいわけです。
</p>

<p> 再帰呼び出しするたびにリストは 2 つに分割されるので、最後にリストの要素はひとつとなります。これはソート済みのリストなので、ここで再帰呼び出しを終了してマージ処理を行えばいいわけです。プログラムは次のようになります。
</p>

<pre class="list">
リスト : マージソート

(define (merge-sort pred n ls)
  (if (= n 1)
      (list (car ls))
    (let ((m (quotient n 2)))
      (merge-list
        pred
        (merge-sort pred m ls)
        (merge-sort pred (- n m) (drop ls m))))))
</pre>

<p> 関数 merge-sort の引数 pred が要素を比較する述語、引数 ls がソートするリスト、引数 n がリストの長さを表します。merge-sort はリストを分割する処理で、新しいリストを作らないことに注意してください。merge-sort はソートするリストの範囲を開始位置と長さで表しています。リストを二分割する場合、前半部分は ls と m (= n / 2) で表し、後半部分を (drop ls m) と (- n m) で表します。
</p>
<p> あとは merge-sort を再帰呼び出しでリストを分割していき、リストの長さが 1 になったならば新しいリストを返します。そして、merge-sort でソートしたリストを merge-list でマージすればいいわけです。
</p>

<h4 id="ans23">●解答23</h4>
<pre class="list">
リスト : 接頭辞の判定

(define (prefix ls ps)
  (cond ((null? ps) #t)
        ((eqv? (car ls) (car ps))
         (prefix (cdr ls) (cdr ps)))
        (else #f)))
</pre>
<p> 接頭辞の判定は簡単です。最初の節は、空リストは接頭辞であることを表しています。次の節で、リストの先頭要素が等しい場合は、残りのリスト (cdr ps) が (cdr ls) の接頭辞であることを確かめます。
</p>
<h4 id="ans24">●解答24</h4>
<pre class="list">
リスト : 接尾辞の判定

(define (suffix ls ss)
  (prefix (drop ls (- (length ls) (length ss))) ss))
</pre>
<p> 接尾辞の判定も簡単です。リスト ls と ss の長さの差分を求め、ls の先頭から差分の個数だけ要素を取り除きます。これで ls と ss の長さが等しくなるので、あとは prefix で比較するだけです。
</p>

<h4 id="ans25">●解答25</h4>
<pre class="list">
リスト : 部分リストの判定

(define (sublist ks ls)
  (cond ((null? ls) #f)
        ((prefix ls ks) #t)
        (else (sublist ks (cdr ls)))))
</pre>
<p> sublist は prefix を使うと簡単です。最初の節で ls が空リストの場合、ks は部分リストではないので #f を返します。次の節で、ks が ls の接頭辞であれば部分リストなので #t を返します。それ以外の場合は ls の先頭要素を取り除いて、sublist を再帰呼び出しするだけです。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="scheme.html#yasp">Scheme</a> | <a href="yasp02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>