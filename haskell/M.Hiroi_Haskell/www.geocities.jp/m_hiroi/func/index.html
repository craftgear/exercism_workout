<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>M.Hiroi's Home Page / Functional Programming</title>
  <meta name="description" content="Functional Programming,関数型プログラミング,SML/NJ,OCaml,Haskell,Scheme,Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881748</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
</div>
<div class="small">
[ <a href="../index.html">Home</a> ]
<hr>
</div>
<section class="contents">
<h2>WHAT'S NEW</h2>
<ul>
  <li>2013/01/06 <a href="haskell.html">Haskell Programming</a> を追加
</ul>
<hr>
<h2>CONTENTS</h2>
<ul>
  <li><a href="index.html#sml">お気楽 Standard ML of New Jersey 入門</a>
  <li><a href="index.html#yasmlp">Yet Another SML/NJ Problems</a>
  <li><a href="ocaml.html">お気楽 OCaml プログラミング入門</a> (別ページへ移動)
  <li><a href="scheme.html">Scheme Programming</a> (別ページへ移動)
  <li><a href="erlang.html">Erlang Programming</a> (別ページへ移動)
  <li><a href="haskell.html">Haskell Programming</a> (別ページへ移動)
  <li><a href="index.html#cite">参考文献</a>
  <li><a href="index.html#copyright">権利・免責事項など</a>
</ul>
</section>
<hr>
<section class="contents">
<h2 id="sml">お気楽 Standard ML of New Jersey 入門</h2>
<h3>CONTENTS</h3>
<ul>
  <li>2005/05/03 <a href="index.html#begin">はじめに</a>
  <li>2005/05/03 <a href="smlnj01.html">関数型言語の特徴</a>
  <li>2005/05/03 <a href="smlnj01.html#chap02">SML/NJ の基礎知識</a> (改訂 2012/05/26)<BR>
さっそく使ってみよう、整数と実数、算術演算子、文字と文字列、比較演算子、論理演算子、条件分岐、変数、組、リスト、関数、局所変数、再帰定義
  <li>2005/05/05 <a href="smlnj02.html">let による局所変数の定義</a><BR>
累乗の計算、高速化
  <li>2005/05/05 <a href="smlnj02.html#chap04">リスト操作と多相型関数</a><BR>
多相型関数、リストの連結、リストの反転、リストの探索
  <li>2005/05/05 <a href="smlnj02.html#chap05">パターンの基礎知識</a><BR>
定数と変数はパターンになる、リストのパターン、クイックソート
  <li>2005/05/05 <a href="smlnj02.html#chap06">相互再帰と末尾再帰</a><BR>
相互再帰、末尾再帰、フィボナッチ関数の高速化
  <li>2005/05/07 <a href="smlnj03.html">高階関数</a><BR>
マッピング、フィルター、reduce (畳み込み)
  <li>2005/05/07 <a href="smlnj03.html#chap08">簡単な入出力</a><BR>
print と unit 型、標準入出力
  <li>2005/05/07 <a href="smlnj03.html#chap09">データ型の定義</a><BR>
datatype 宣言、型変数の使い方、再帰的なデータ型、連想リスト
  <li>2005/05/07 <a href="smlnj03.html#yori01">ちょっと寄り道「素数を求める」</a>
  <li>2005/05/14 <a href="smlnj04.html">レキシカルスコープ</a><BR>
レキシカルスコープとダイナミックスコープ、レキシカルスコープと局所的な関数、クイックソートの改良
  <li>2005/05/14 <a href="smlnj04.html#chap11">カリー化関数</a><BR>
クロージャ、カリー化関数、高階関数のカリー化、関数の合成
  <li>2005/05/14 <a href="smlnj04.html#yori02">ちょっと寄り道「組み合わせの数」</a> (改訂 2012/05/26)
  <li>2005/05/14 <a href="smlnj04.html#yori03">ちょっと寄り道「順列の生成」</a>
  <li>2005/05/21 <a href="smlnj05.html">パターンと照合</a><BR>
case、照合による関数の定義、as、挿入ソート
  <li>2005/05/21 <a href="smlnj05.html#chap13">例外</a><BR>
例外の定義、例外の送出、例外の捕捉
  <li>2005/05/21 <a href="smlnj05.html#chap14">配列と参照</a><BR>
配列、配列の操作関数、参照、繰り返し
  <li>2005/05/21 <a href="smlnj05.html#yori04">ちょっと寄り道「組み合わせの生成」</a>
  <li>2005/05/21 <a href="smlnj05.html#yori05">ちょっと寄り道「マージソート」</a><BR>
リストのマージ、マージソート
  <li>2005/05/28 <a href="smlnj06.html">レコード</a><BR>
レコードの定義、レコードのパターン、データの個数を求める
  <li>2005/05/28 <a href="smlnj06.html#chap15">モジュール (1)</a><BR>
スタックとは？、スタックの定義、ストラクチャの定義、シグネチャの使い方、補足１：多相性の制限、補足２：参照を使ったスタックの実装例
  <li>2005/05/28 <a href="smlnj06.html#yori06">ちょっと寄り道「8 クイーン」</a><BR>
プログラムの作成、実行結果、8 クイーンの高速化
  <li>2005/06/04 <a href="smlnj07.html">モジュール (2)</a><BR>
二分探索木、木構造、二分木、二分探索木の実装、データの探索、データの挿入、二分木の巡回、実行例、ファンクタ
  <li>2005/06/04 <a href="smlnj07.html#chap17">ハッシュ法</a><BR>
ハッシュ法とは？、プログラムの作成、ハッシュ関数の作成、実行例
  <li>2005/06/04 <a href="smlnj07.html#yori07">ちょっと寄り道「小町算」</a><BR>
プログラムの作成、実行結果
  <li>2005/06/11 <a href="smlnj08.html">モジュール (3)</a><BR>
キューとは？、キューの実装、データ抽象、local と open、ファンクタの引数、その他
  <li>2005/06/11 <a href="smlnj08.html#chap19">ファイル入出力</a><BR>
ストリーム、ファイルのオープンとクローズ、input1 と output1、inputLine と output、ファイルの書き込み
  <li>2005/06/11 <a href="smlnj08.html#yori08">ちょっと寄り道「配列によるキューの実装」</a><BR>
プログラムの作成、使用例
  <li>2005/06/18 <a href="smlnj09.html">経路の探索</a><BR>
グラフの表現方法、深さ優先探索、幅優先探索、経路の管理、プログラムの作成、反復深化、反復深化のプログラム
  <li>2005/06/25 <a href="smlnj09.html#yori09">ちょっと寄り道「末尾再帰と繰り返し」</a> 
  <li>2005/07/02 <a href="smlnj10.html">幅優先探索とスライドパズル (1)</a><BR>
スライドパズルの説明、6 パズルの解法、プログラムの作成、実行結果、幅優先探索の高速化、プログラムの修正
  <li>2005/07/09 <a href="smlnj11.html">幅優先探索とスライドパズル (2)</a><BR>
最長手数の求め方、プログラムの作成、実行結果、ハッシュ法による高速化
  <li>2005/07/09 <a href="smlnj11.html#chap23">反復深化と下限値枝刈り法</a><BR>
反復深化で 6 パズルを解く、下限値枝刈り法、下限値枝刈り法のプログラム
  <li>2005/07/18 <a href="smlnj12.html">整数の論理演算とビット操作</a><BR>
word の操作関数、データの変換、Word8 と Wrod32、組み合わせの生成、パズル「ライツアウト」、ライツアウトの解法、ライツアウトの解法プログラム、実行結果
  <li>2005/07/23 <a href="smlnj12.html#yori10">ちょっと寄り道「組み合わせの生成 (2)」</a>
  <li>2005/08/03 <a href="smlnj13.html">パズルに挑戦!</a><BR>
問題１「騎士の周遊」、問題２「変形魔方陣」、問題３「チャイニーズ・チェッカー」、問題４「７パズル」
  <li>2012/06/03 <a href="smlnj14.html">パズルに挑戦!!</a> (2012/06/09 <a href="smlnj14.html#ans05">解答</a>)<BR>
問題５「マスターマインド」、問題６「カークマンの 15 人の女生徒」、問題７「ナンバープレース」、問題８「三目並べ」
  <li>2012/06/10 <a href="smlnj15.html">有理数</a><BR>
有理数の定義と生成、算術演算子の定義、比較演算子の定義、データ型の変換、実行例、小町分数、単位分数の和、Four Four's、数式のパターン、データ型の定義、数式の計算、数式の生成、実行結果
  <li>2012/06/30 <a href="smlnj16.html">遅延評価と遅延ストリーム</a><BR>
たらいまわし関数、遅延評価、delay と force の使い方、lazy の使い方、遅延評価による高速化、delay と force による高速化、クロージャによる遅延評価、lazy による遅延評価、実行結果、遅延ストリームの構造、遅延ストリームの生成、遅延ストリームの操作関数、高階関数、Appendix : lazy を使う場合
  <li>2012/07/01 <a name="new" href="smlnj17.html">遅延ストリーム (2)</a><BR>
遅延ストリームの操作関数 (2)、高階関数 (2)、組 (pair) を生成するストリーム、無限ストリームで組 (pari) を生成する場合 (<a href="smlnj17.html#update1">別解(2012/12/16)</a>)、素数の生成 (<a href="smlnj17.html#update2">別解(2012/12/16)</a>)、順列の生成、遅延ストリーム版、８クイーンの解法
  <li>2012/07/07 <a href="smlnj18.html">継続渡しスタイル</a><BR>
継続とは？、継続渡しスタイル (CPS) とは？、再帰呼び出しと継続渡しスタイル、二重再帰と継続渡しスタイル、CPS の便利な使い方、二分木の巡回を CPS で実装、二分木と遅延ストリーム、遅延ストリームを使わない方法
  <li>2012/07/08 <a href="smlnj19.html">継続 (continuation)</a><BR>
SML/NJ の継続、大域脱出、繰り返しの中断、再帰呼び出しからの脱出、継続の保存と再開、リストの要素をひとつずつ取り出す、木の要素をひとつずつ取り出す、ジェネレータを生成する関数
  <li>2012/07/14 <a href="smlnj20.html">コルーチン</a><BR>
コルーチンの動作、コルーチンの作成、簡単なテスト、coroutine_resume で値を返す場合、高階関数をジェネレータに変換、順列の生成、エラトステネスの篩
  <li>2012/07/15 <a href="smlnj21.html">コルーチン (2)</a><BR>
並行プログラミングとは？、簡単なマルチプロセスの作成、簡単な実行例、配列によるキューの実装、キューによる同期処理、哲学者の食事、実行結果 (1)、デッドロックの防止 (1)、実行結果 (2)、デッドロックの防止 (2)、実行結果 (3)
  <li>2012/07/21 <a href="smlnj22.html">非決定性</a><BR>
amb の動作、amb の作成、順列の生成、解をすべて求める、論理パズル、データ構造の定義、補助関数の作成、論理パズルの解法、経路の探索、幅優先探索版 amb の作成、経路の探索 (2)、水差し問題
  <li>2012/08/11 <a href="smlnj23.html">電卓プログラムの作成</a><BR>
プログラミング言語処理系の基本的な構造、文法の表現、式の構文、字句解析、構文解析、式の評価、式の入力と評価、実行例
  <li>2012/08/12 <a href="smlnj24.html">電卓プログラムの作成 (2)</a><BR>
変数、関数、変数と関数の操作、字句解析、構文解析、式の評価、実行例
  <li>2012/08/13 <a href="smlnj25.html">電卓プログラムの作成 (3)</a><BR>
文法の変更、字句解析、構文解析、引数の処理、変数の評価、ユーザ関数の評価、関数定義、実行例
  <li>2012/08/14 <a href="smlnj26.html">電卓プログラムの作成 (4)</a><BR>
論理演算子と比較演算子の優先順位、条件分岐、文法の修正、字句解析の修正、構文解析の修正、条件分岐の処理、式の評価、再帰呼び出しの対応、実行例
  <li>2012/08/15 <a href="smlnj27.html">電卓プログラムの作成 (5)</a><BR>
begin 式と while 式、構文解析、while 式の処理、begin 式の処理、式の評価、実行例
  <li>2012/08/25 <a href="smlnj28.html">関数型電卓プログラムの作成</a><BR>
匿名関数と let 式の構文、式の定義、構文解析の修正、eval_expr の修正、関数定義の修正、ファイルのロード、実行例、末尾再帰最適化、相互再帰
  <li>2012/08/26 <a href="smlnj29.html">関数型電卓プログラムの作成 (2)</a><BR>
クロージャによる連結リストの実装、空リストとデータ型の判定、リストの表示、リストの生成、リストの基本的な操作、高階関数、等値の判定、簡単な例題、リストの破壊的な修正
  <li>2012/09/01 <a href="smlnj30.html">関数型電卓プログラムの作成 (3)</a><BR>
連結リストの定義、連結リストの表示、連結リストの基本関数、連結リストの生成、簡単な実行例
  <li>2012/09/02 <a href="smlnj31.html">関数型電卓プログラムの作成 (4)</a><BR>
ベクタの生成とアクセス方法、データ型の定義、値の表示、ベクタの操作関数、構文解析の修正、eval_expr の修正、簡単な実行例
  <li>2012/09/08 <a href="smlnj32.html">関数型電卓プログラムの作成 (5)</a><BR>
ベクタのサンプルプログラム、データの探索、二分探索、バブルソート、選択ソート、単純挿入ソート、クイックソート、エラトステネスの篩、素因数分解、木の操作関数
  <li>2012/09/09 <a href="smlnj33.html">関数型電卓プログラムの作成 (6)</a><BR>
継続の実装、継続の使い方、継続を表すデータ型の定義、構文解析の修正、eval_expr の修正、末尾再帰のチェック
  <li>2012/09/15 <a href="smlnj34.html">関数型電卓プログラムの作成 (7)</a><BR>
継続のサンプルプログラム、大域脱出、繰り返しの中断、再帰呼び出しからの脱出、ジェネレータの生成、コルーチンの作成、ジェネレータの生成 (2)、順列の生成、エラトステネスの篩、非決定性、順列の生成 (2)、解をすべて求める、経路の探索
  <li>2012/09/22 <a href="smlnj35.html">関数型電卓プログラムの改良</a><BR>
局所変数と大域変数のアクセス方法、文法の修正、データ型の定義、文字列の切り出し、構文解析の修正、eval_expr の修正、文字列の操作関数、簡単な実行例、実行時間の計測
  <li>2012/09/23 <a href="smlnj36.html">関数型電卓プログラムの改良 (付録A)</a><BR>
関数型電卓プログラム用ライブラリ、数値演算、述語、リストのアクセス、リストの生成、簡単なリスト操作、探索、マッピング、フィルター、畳み込み、foreach と copy、集合、マージとソート、順列と組み合わせ、スタックとキュー
 <li>2012/09/29 <a href="smlnj37.html">関数型電卓プログラムの改良 (付録B)</a><BR>
パズルの解法、小町算、覆面算、魔方陣、８クイーン、マスターマインド、蛙飛びゲーム、ペグ・ソリテア、水差しの問題、５パズル、ナンバープレース
 <li>2012/10/06 <a href="smlnj38.html">関数型電卓プログラムの改良 (付録C)</a><BR>
二分木、問題「８パズル」、解答「８パズル」、平衡木 (AA tree)、８パズルの実行結果、ハッシュ表、ハッシュ表による「８パズル」の解法
 <li>2012/10/07 <a href="smlnj39.html">関数型電卓プログラムの改良 (付録D)</a><BR>
Yet Another fcalc Problems
</ul>
<h3 id="yasmlp">Yet Another SML/NJ Problems</h3>
<ul>
  <li>2012/05/20 <a href="yasmlp01.html">Yet Another SML/NJ Problems (1)</a>
  <li>2012/05/20 <a href="yasmlp01.html#ans01">解答 (1)</a>
  <li>2012/05/26 <a href="yasmlp02.html">Yet Another SML/NJ Problems (2)</a>
  <li>2012/05/26 <a href="yasmlp02.html#ans26">解答 (2)</a> (<a href="yasmlp02.html#ans50update">別解 (2012/10/08)</a>)
  <li>2012/05/27 <a href="yasmlp03.html">Yet Another SML/NJ Problems (3)</a>
  <li>2012/05/27 <a href="yasmlp03.html#ans51">解答 (3)</a>
  <li>2012/06/02 <a href="yasmlp04.html">Yet Another SML/NJ Problems (4)</a>
  <li>2012/06/02 <a href="yasmlp04.html#ans61">解答 (4)</a>
  <li>2012/06/17 <a href="yasmlp05.html">Yet Another SML/NJ Problems (5)</a>
  <li>2012/06/17 <a href="yasmlp05.html#ans76">解答 (5)</a>
  <li>2012/06/23 <a href="yasmlp06.html">Yet Another SML/NJ Problems (6)</a>
  <li>2012/06/23 <a href="yasmlp06.html#ans91">解答 (6)</a>
  <li>2012/11/25 <a href="yasmlp07.html">Yet Another SML/NJ Problems (7)</a>
  <li>2012/11/26 <a href="yasmlp07.html#ans111">解答 (7)</a>
</ul>
</section>
<hr>
<section class="contents">
<h3 id="begin">はじめに</h3>
<p> Standard ML of New Jersey (SML/NJ) は ML (Meta Language) という関数型プログラミング言語の一つです。ML は 1970 年代後半に Edinburgh 大学で定理証明を行うシステム Edinburgh LCF を記述するため、R. Minler 博士を中心に開発された言語です。その後、改良が重ねられ、いくつかの ML 処理系が作られました。SML/NJ はその一つで、AT&T の MacQueen 氏と Princeton 大学の Appel 氏によって作成された実用的な ML 処理系です。
</p>
<p> SML/NJ は次のサイトからダウンロードできます。Windows 用のバイナリが用意されているので、とても簡単にインストールすることができます。
</p>
<ul>
  <li><a href="http://www.smlnj.org/">Standard ML of New Jersey</a>
</ul>

<p> 関数型言語というと Lisp (Common Lisp, Scheme) が有名です。Lisp の場合、データに型はありますが、変数に型はありません。これに対し ML は強く型づけされた言語で、コンパイル時に静的な型チェックを行うことで、多くのエラーを検出することができます。
</p>
<p> ML で一番有名な機能は「型推論」でしょう。ML はプログラムから変数などのデータ型を見つけてくれるので、プログラマが型を宣言する必要はほとんどありません。推論できない場合にかぎり、ML は型宣言を要求します。この機能により、ML は静的な型チェックを行う「型付きの言語」でありながら、 Lisp のような柔軟なプログラミングが可能になっています。この他にも、パターンマッチング、多相型関数、モジュール・システムなど、ML には興味深い機能がたくさんあります。
</p>
<h4 id="tarai">●簡単なベンチマーク (改訂 2012/05/20)</h4>
<p> SML/NJ はプログラムをネイティブコードにコンパイルして実行するので、バイトコードにコンパイルする処理系よりもプログラムを高速に実行することができます。その実行速度ですが、たらいまわし関数を使って調べてみました。
</p>
<pre class="list">
リスト：たらいまわし関数 (SML/NJ)

fun tak(x, y, z) = 
  if x &lt;= y then z
  else tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))

(* 時間計測用 *)
fun tak_exec(x, y, z) =
  let 
    val a = Timer.startRealTimer()
  in
    tak(x, y, z);
    Timer.checkRealTimer( a )
  end
</pre>

<p> SML/NJ の場合、プログラムを入力すると自動的にコンパイルされます。対話モードの場合、use "ファイル名"; と入力すると、ファイルをロードしてプログラムがコンパイルされます。SML/NJ を実行するときに、"C&gt; sml ファイル名" のようにコマンドラインからファイル名を入力してもかまいません。
</p>
<p> それでは実行結果を示します。tak(20, 10, 0) を計算しました。使用した SML/NJ のバージョンは 110.74 です。比較のため、Ruby, Python, CLISP (Common Lisp), SBCL (Common Lisp), Gauche (Scheme), OCaml (ocamlc, ocamlopt), GCC (Ｃ言語) の実行結果を示します。 GCC, SBCL, ocamlopt, SML/NJ 以外の処理系はプログラムをバイトコードにコンパイルするものです。
</p>
<TABLE border=1>
<caption>表 : tak(20, 10, 0) の結果</caption>
<thead>
  <tr><th>処理系</th><th>秒</th></tr>
</thead>
<tbody>
  <tr><td>Python (ver 2.7.3)</td><td>14.51</td></tr>
  <tr><td>Ruby (ver 1.9,3)</td><td>11.35</td></tr>
  <tr><td>CLISP (ver 2.48)</td><td>5.71</td></tr>
  <tr><td>Gauche (ver 0.9.2)</td><td>4.65</td></tr>
  <tr><td>ocamlc (ver 3.12.1)</td><td>3.14</td></tr>
  <tr><td>SBCL (ver 1.0.55)</td><td>0.94</td></tr>
  <tr><td>SML/NJ (ver 110.74)</td><td>0.57</td></tr>
  <tr><td>GCC -O (ver 4.5.3)</td><td>0.37</td></tr>
  <tr><td>SBCL (最適化)</td><td>0.34</td></tr>
  <tr><td>GCC -O2 (ver 4.5.3)</td><td>0.30</td></tr>
  <tr><td>ocamlopt (ver 3.12.1)</td><td>0.16</td></tr>
</tbody>
</table>
<ul>
  <li>実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</ul>

<p> SML/NJ は SBCL (Common Lisp) より速い結果になりましたが、GCC と OCaml にはかないませんでした。ただし、SBCL は最適化オプションを指定すると SML/NJ よりも速くなります。最適化オプションを指定したプログラムは拙作のページ <a href="../clisp/index.html">Common Lisp Programming</a> をお読みください。興味のある方は、ほかのプログラムでも試してみてください。
</p>
<div class="note">
-- 改訂 --------<br>
2012/05/20 たらいまわし関数の実行結果を更新
</div>
</section>
<hr>
<section class="contents">
<h3><a name="cite">参考文献と URL</a></h3>
<h4>関数型言語全般</h4>
<ol>
  <li><a href="http://qiita.com/esumii/items/ec589d138e72e22ea97e">「関数型言語」に関するFAQ形式の一般的説明</a>, (住井英二郎さん)
  <li><a href="http://www.itpl.co.jp/tech/func/essense_of_fp(sea0305).pdf">函数プログラミングのエッセンスと考え方(PDF)</a>. (小笠原啓さん)
  <li><a href="http://www.slideshare.net/tanakh/ss-3580292">関数プログラミング入門</a>, (田中英行さん)
</ol>
<H4><a name="cite_sml">Standard ML of New Jersey</a></H4>
<ol>
  <li>Jeffrey D.Ullman (著), 神林靖 (訳), 『プログラミング言語ML』, 株式会社アスキー, 1996
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995
  <li>児玉靖司, 『SML 演習 The Meta Language』, <a href="http://yk.i.hosei.ac.jp/">http://yk.i.hosei.ac.jp/</a>
  <li>大黒学, 『初級 ML 講座』, <a href="http://tutorial.jp/prog/index.html">無料チュートリアル：プログラミング</a>
</ol>
</section>
<hr>
<section class="contents">
<h3 id="copyright">権利・免責事項など</h3>
<p> 『お気楽 Standard ML of New Jersey 入門』の著作権は筆者「広井誠 (Makoto Hiroi) 」が保持します。無断使用や無断転載は禁止いたします。お気楽 Standard ML of New Jersey 入門で作成したプログラムはフリーソフトウェアとします。ご自由にお使いください。プログラムの改造や配布もご自由にどうぞ。その際は、出典を明記してくださるようお願いいたします。
</p>
<p> ただし、これらのプログラムは無保証であり、使用したことにより生じた損害について、作者「広井誠 (Makoto Hiroi) 」は一切の責任を負いません。また、これらのプログラムを販売することで利益を得るといった商行為は禁止いたします。
</p>
<div align="right">
<b>Copyright (C) 2005-2012 Makoto Hiroi<br>All rights reserved.</b>
</div>
</section>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>