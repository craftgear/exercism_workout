<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881789</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell11.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell13.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">Functor</h3>
<p> 今回は Haskell の Functor (ファンクタ) について説明します。ファンクタというと、SML/NJ や OCaml ユーザーにはお馴染み機能だと思います。これら ML 系言語のファンクタは、ストラクチャを受け取って新しいストラクチャを生成する機能ですが、Haskell のファンクタはこれらとはまったく異なる機能です。といっても難しいことは全然なく、Haskell では単なる「型クラス」のひとつにすぎません。データ型を Functor のインスタンスに設定すると、リスト以外のデータ型でも map と同様の働きをさせることができます。
</p>

<h4>●Functor とは？</h4>
<p> Functor の定義をコマンド :info で調べると、次のように表示されます。
</p>
<pre>
Prelude&gt; :i Functor
class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
  (GHC.Base.&lt;$) :: a -&gt; f b -&gt; f a
        -- Defined in `GHC.Base'
instance Functor Maybe -- Defined in `Data.Maybe'
instance Functor [] -- Defined in `GHC.Base'
instance Functor IO -- Defined in `GHC.Base'
</pre>
<p> ここで、関数 fmap に注目してください。これが Functor の主な関数です。最初の引数が関数 a -&gt; b で、a を b に変換する関数であることがわかります。次の引数 f a は型変数 a をひとつ持っているので、f は a を格納するデータ型 (型構築子) であることがわかります。そして、最後の引数が f b なので、f a からデータを取り出し、それを関数 a -&gt; b に適用し、その結果を f に格納して返すことがわかります。
</p>

<p> fmap の定義は map の定義と良く似ています。
</p>
<pre class="item">
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</pre>
<p> リストの型 [a] は [ ] a のことなので、次のように書き直すことができます。
</p>
<pre class="item">
map :: (a -&gt; b) -&gt; [] a -&gt; [] b
</pre>
<p> つまり、fmap は汎用のマップ関数なのです。簡単な実行例を示しましょう。
</p>
<pre>
Prelude&gt; fmap (*2) [1,2,3,4,5]
[2,4,6,8,10]
Prelude&gt; fmap (*2) []
[]
Prelude&gt; fmap (*2) (Just 10)
Just 20
Prelude&gt; fmap (*2) Nothing
Nothing
Prelude&gt; fmap reverse getLine
hello, world
"dlrow ,olleh"
</pre>
<p> リストの Functor は関数 map と同じ動作になります。Maybe の Functor は、Just からデータを取り出して、それに関数を適用して返り値を Just に格納して返します。Nothing はデータを格納していないので Nothing をそのまま返します。getLine のデータ型は IO String です。Haskell では IO も Functor のインスタンスで、IO に格納されているデータを取り出して、それに関数適用して返り値を IO に格納して返します。
</p>

<p> Haskell では「文脈」という用語を使うことがあります。たとえば、Maybe の Nothing は計算が失敗したことを表わしています。つまり、Maybe は失敗するかもしれない計算を表している、と考えることができるわけです。リストにはリストの意味を考えることができますし、I/O アクションもその意味を考えることができます。このようなプログラム上の意味を文脈といいますが、ここでは値を格納している型構築子のことを文脈と考えてもらってもかまいません。
</p>

<p> fmap は文脈が表している値に、文脈を保ったまま関数を適用する働きをします。fmap に渡される関数は文脈に依存していません。文脈に合わせて関数を適用することを「関数を持ち上げる」といいます。fmap は関数を持ち上げて文脈の値に適用し、文脈を保ったままその結果を返すわけです。ちょっと耳慣れない用語で難しく感じるかもしれませんが、実際にプログラムを作っていくうちに慣れてくると思います。
</p>

<h4>●自分で Functor を定義する</h4>
<p> それではここで Functor の理解を深めるため、私たちで Functor を定義してみましょう。型クラスの名前は Mfunctor とします。fmap は Haskell で使われているので、記号 &lt;$&gt; を使いましょう。Mfunctor の定義は次のようになります。
</p>

<pre class="list">
リスト : Mfunctor の定義

class Mfunctor f where
  (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p> Mfunctor の定義は関数名が異なるだけで Functor と同じです。
</p>
<p> 次はリスト, Maybe, IO を Mfunctor のインスタンスに設定します。次のリストを見てください。
</p>
<pre class="list">
リスト : インスタンスの設定

instance Mfunctor [] where
  (&lt;$&gt;) = map

instance Mfunctor Maybe where
  f &lt;$&gt; Nothing = Nothing
  f &lt;$&gt; Just x  = Just (f x)

instance Mfunctor IO where
  f &lt;$&gt; action = do
    x &lt;- action
    return (f x)
</pre>
<p> リストの &lt;$&gt; は map と同じです。Maybe の場合、右辺が Nothing であれば Nothing をそのまま返し、Just x であれば Just (f x) を返します。IO の &lt;$&gt; は do 構文を使うと簡単に実装できます。I/O アクション action から &lt;- でデータ x を取り出し、f x の返り値を return で IO に格納して返します。
</p>
<p>それでは実行してみましょう。
</p>
<pre>
*Main&gt; (*2) &lt;$&gt; [1,2,3,4,5]
[2,4,6,8,10]
*Main&gt; (*2) &lt;$&gt; []
[]
*Main&gt; (*2) &lt;$&gt; (Just 10)
Just 20
*Main&gt; (*2) &lt;$&gt; Nothing
Nothing
*Main&gt; reverse &lt;$&gt; getLine
hello, world
"dlrow ,olleh"
</pre>
<h4>●Either</h4>
<p> 次は Either というデータ型で試してみましょう。Either の定義を示します。
</p>
<pre class="list">
リスト : Either の定義

data Either a b = Left a | Right b
</pre>
<p> Either は Maybe を改良したデータ型で、左 (Left) 右 (Right) のどちらかにデータを格納することができます。左右のデータ型は異なっていてもかまいません。通常は Maybe の Nothing の代わりに Left a を使い、Just の代わりに Right b を使います。たとえば、エラーがあったときに Left にエラーを表すデータを入れて返す、という使い方をします。
</p>
<p> 簡単な例を示します。
</p>
<pre>
*Main&gt; Right 10
Right 10
*Main&gt; :t Right 10
Right 10 :: Num b =&gt; Either a b

*Main&gt; Left "error"
Left "error"
*Main&gt; :t Left "error"
Left "error" :: Either [Char] b
</pre>

<h4>●Either も Functor になる</h4>
<p> Either は Maybe と同じ考え方で Functor のインスタンスにすることができます。つまり、Left のデータであればそのまま返し、Right のデータであれば関数を適用します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : Either の Functor

instance Mfunctor (Either a) where
  f &lt;$&gt; Left x  = Left x
  f &lt;$&gt; Right x = Right (f x)
</pre>
<p> &lt;$&gt; の定義は簡単ですね。Left x ならば Left x をそのまま返し、Right x ならば Right (f x) を返します。ここで Either の型に注目してください。Either は型変数を 2 つ指定しますが、&lt;$&gt; の定義は (a -&gt; b) -&gt; f a -&gt; f b なので、型構築子 f で指定できる型変数はひとつだけになります。このため、instance 宣言で Either または (Either a b) と指定するとエラーになります。
</p>
<p> Haskell の場合、型構築子における型変数の指定は、カリー化関数のように部分適用することができます。Either の Functor は Right のデータに関数を適用するので、データ型が変化することがありますが、Left のデータ型は変化しません。この場合、Either a を型構築子 f と考えればいいのです。これを図に示すと次のようになります。
</p>
<pre class="item">
&lt;$&gt; :: (a -&gt; b) -&gt; f a -&gt; f b
=&gt; (a -&gt; b) -&gt; (Either a') a -&gt; (Either a') b
=&gt; (a -&gt; b) -&gt; Either a' a -&gt; Either a' b
</pre>
<p> これで Right 側のデータに関数が適用され、Left 側のデータは変化しないことを表すことができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; (*2) &lt;$&gt; (Right 10)
Right 20
*Main&gt; (*2) &lt;$&gt; (Left "error")
Left "error"
</pre>

<h4>●連想リストも Functor になる</h4>
<p> 拙作のページ <a href="haskell07.html">データ型の定義</a> で作成した連想リストも Functor のインスタンスにすることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 連想リストの Functor

-- 連想リストの定義
data Alist k v = Nil | Cell k v (Alist k v) deriving Show

-- Functor
instance Mfunctor (Alist k) where
  f &lt;$&gt; Nil = Nil
  f &lt;$&gt; (Cell k v next) = Cell k (f v) (f &lt;$&gt; next)
</pre>
<p> 連想リストの型は Alist k v なので、Either と同じようにキーはそのままとして、データ (値) に関数を適用することにします。したがって、instance 宣言では型を (Alist k) と指定します。あとは関数 f を値 v に適用して新しい連想リストを生成するだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; let a = Cell 'a' 1 (Cell 'b' 2 (Cell 'c' 3 Nil))
*Main&gt; a
Cell 'a' 1 (Cell 'b' 2 (Cell 'c' 3 Nil))
*Main&gt; (*2) &lt;$&gt; a
Cell 'a' 2 (Cell 'b' 4 (Cell 'c' 6 Nil))
*Main&gt; (+10) &lt;$&gt; a
Cell 'a' 11 (Cell 'b' 12 (Cell 'c' 13 Nil))
</pre>
<h4>●関数も Functor になる</h4>
<p> 今まで関数の型は r -&gt; a で表していました。Haskell の場合、-&gt; は中置演算子で、関数の型は (-&gt;) r a と書くこともできます。Either と同じように、(-&gt;) r を型構築子と考えると、次のように &lt;$&gt; の定義を導くことができます。
</p>
<pre class="item">
(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b
=&gt; (a -&gt; b) -&gt; (-&gt;) r a -&gt; (-&gt;) r b
=&gt; (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)
</pre>
<p> これは関数合成を行う演算子 (.) の定義とまったく同じです。
</p>
<pre class="item">
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</pre>
<p> つまり、関数の Functor は関数合成と同じ動作でよいわけです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 関数の Functor

instance Mfunctor ((-&gt;) r) where
  (&lt;$&gt;) = (.)
</pre>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; Just 10
Just 26
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; Nothing
Nothing
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; [1..5]
[8,10,12,14,16]
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; []
[]
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; Right 20
Right 46
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; Left "error"
Left "error"
*Main&gt; (*2) &lt;$&gt; (+3) &lt;$&gt; Cell 'a' 10 (Cell 'b' 20 (Cell 'c' 30 Nil))
Cell 'a' 26 (Cell 'b' 46 (Cell 'c' 66 Nil))
</pre>
<p> (*2) &lt;$&gt; (+3) で関数を合成して関数 (x + 3) * 2 を作り、その関数をデータに適用します。Just 10 は Just 26 に、[1,2,3,4,5] は [8,10,12,14,16] に、Right 20 は Right 46 になります。もちろん、連想リストに適用することもできます。このように、Functor を定義すると、いろいろなデータ構造に関数を適用していくことができます。
</p>

<h4>●Functor の規則</h4>
<p> Functor には満たすべき規則が 2 つあります。
</p>
<ol>
  <li> fmap id  ==  id
  <li> fmap (f . g)  ==  fmap f . fmap g
</ol>
<p> 最初の規則は、データに fmap id を適用した結果は id を適用した結果と等しい、という意味です。つまり、fmap は関数をデータに適用するだけで、他の操作は一切行わない、ということです。
</p>
<p> 2 番目の規則は引数を与えて考えるとわかりやすくなります。
</p>
<pre class="item">
fmap (f . g) x = fmap f (fmap g x)
</pre>
<p> fmap (f . g) を x に適用した結果は、fmap g を x に適用してから fmap f を適用した結果と同じになります。左辺は fmap を 1 回だけ、右辺は fmap を 2 回適用しています。たとえば、fmap がリストの要素を逆に並べ替えるとしましょう。当然ですが、右辺と左辺では結果が異なりますね。つまり、fmap によって要素の並び方は変更されない、ということを意味しています。
</p>

<p> なお、Functor の規則は Haskell が自動的にチェックしてくれるわけではありません。Functor を作ったならば、規則を満たしているかプログラマ自らが確かめる必要があります。
</p>
<p> それでは規則を満たしているか実際に試してみましょう。
</p>
<pre>
*Main&gt; id &lt;$&gt; Just 10
Just 10
*Main&gt; id &lt;$&gt; Nothing
Nothing
*Main&gt; id &lt;$&gt; [1,2,3,4,5]
[1,2,3,4,5]
*Main&gt; id &lt;$&gt; []
[]
*Main&gt; id &lt;$&gt; Right 10
Right 10
*Main&gt; id &lt;$&gt; Left "error"
Left "error"
*Main&gt; id &lt;$&gt; Cell 'a' 10 (Cell 'b' 20 (Cell 'c' 30 Nil))
Cell 'a' 10 (Cell 'b' 20 (Cell 'c' 30 Nil))
*Main&gt; id &lt;$&gt; Nil
Nil
</pre>
<p> 最初の規則は満たしているようですね。次は 2 番目の規則を満たしているかチェックしてみましょう。
</p>
<pre>
*Main&gt; ((+2) . (*3)) &lt;$&gt; Just 10
Just 32
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; Just 10)
Just 32
*Main&gt; ((+2) . (*3)) &lt;$&gt; Nothing
Nothing
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; Nothing)
Nothing
*Main&gt; ((+2) . (*3)) &lt;$&gt; Right 10
Right 32
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; Right 10)
Right 32
*Main&gt; ((+2) . (*3)) &lt;$&gt; Left "error"
Left "error"
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; Left "error")
Left "error"
*Main&gt; ((+2) . (*3)) &lt;$&gt; [1,2,3,4,5]
[5,8,11,14,17]
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; [1,2,3,4,5])
[5,8,11,14,17]
*Main&gt; ((+2) . (*3)) &lt;$&gt; Cell 'a' 10 (Cell 'b' 20 (Cell 'c' 30 Nil))
Cell 'a' 32 (Cell 'b' 62 (Cell 'c' 92 Nil))
*Main&gt; (+2) &lt;$&gt; ((*3) &lt;$&gt; Cell 'a' 10 (Cell 'b' 20 (Cell 'c' 30 Nil)))
Cell 'a' 32 (Cell 'b' 62 (Cell 'c' 92 Nil))
</pre>
<p> 2 番目の規則も満たしていますね。
</p>
<h4>●Functor による関数の部分適用</h4>
<p> Functor で関数の部分適用を行うこともできます。この場合、部分適用で生成された関数はデータ型の中に格納されます。たとえば、関数 a -&gt; b -&gt; c は a -&gt; (b -&gt; c) のことですから、fmap に適用すると次のようになります。
</p>
<pre class="item">
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
fmap (a -&gt; b -&gt; c) =&gt; (a -&gt; (b -&gt; c)) -&gt; f a -&gt; f (b -&gt; c)
</pre>
<p> ただし、生成された関数は fmap で実行することができません。なぜなら、関数はデータ型 f の中に格納されているからです。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; :t fmap (+) (Just 2)
fmap (+) (Just 2) :: Num a =&gt; Maybe (a -&gt; a)
Prelude&gt; :t fmap (+) [1,2,3,4,5]
fmap (+) [1,2,3,4,5] :: Num a =&gt; [a -&gt; a]
</pre>
<p> 最初の例は関数 (+2) が生成されますが、その関数は Maybe 型の中に格納されます。リスト [1, 2, 3, 4, 5] の場合は、関数 (+1), (+2), (+3), (+4), (+5) が生成され、それがリストに格納されます。
</p>
<p> このような場合、文脈の値に同じ文脈にある関数を適用する処理が必要になります。型で表すと次のようになります。
</p>
<pre class="item">
f (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p> Haskell では、このような処理を行う型クラス Applicative が用意されています。Applicative については次回以降で詳しく説明します。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">パズルの解法 (3)</h3>
<p> 今回は基本的な探索手法である「幅優先探索」を使って簡単なパズルを解いてみましょう。
</p>
<h4>●水差し問題</h4>
<div class="question">
<b>[問題]</b> 水差し問題
<p> 大きな容器に水が入っています。目盛の付いていない 8 リットルと 5 リットルの容器を使って、大きな容器から 4 リットルの水を汲み出してください。4 リットルの水は、どちらの容器に入れてもかまいません。水をはかる最短手順を求めてください。なお、水の総量に制限はありません。
</p>
</div>
<p>「水差し問題」はいろいろな呼び方があって、「水をはかる問題」とか「水を測り出す問題」と呼ばれることもあります。なお、この問題は拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/water_jug.html">水差し問題</a> と同じです。内容は重複しましが、あしからずご了承ください。
</p>
<h4>●プログラムの作成</h4>
<p> 水差し問題の場合、次に示す 3 通りの操作があります。
</p>
<ol>
  <li>容器いっぱいに水を満たす。
  <li>容器を空にする。
  <li>他の容器に水を移す。
</ol>
<p> 3 の操作は、容器が空になるまで水を移す場合と、もう一方の容器が満杯になるまで水を移す場合があります。容器は 2 つあるので、全部で 6 通りの操作があります。最初に、これらの操作を行う関数を定義します。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 容器の操作

-- A を空にする
transfer1 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer1 _ (a, b) = (0, b)

-- A を満たす
transfer2 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer2 (ma, _) (_, b) = (ma, b)

-- A から B へ
transfer3 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer3 (_, mb) (a, b) =
  if c &gt;= a then (0, a + b) else (a - c, b + c)
  where c = mb - b

-- B を空にする
transfer4 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer4 _ (a, b) = (a, 0)

-- B を満たす
transfer5 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer5 (_, mb) (a, b) = (a, mb)

-- B から A へ
transfer6 :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
transfer6 (ma, _) (a, b) =
  if c &gt;= b then (a + b, 0) else (a + c, b - c)
  where c = ma - a
</pre>
<p> 状態はタプル (a, b) で表します。A は 8 リットルの容器の水の量、B は 5 リットルの容器の水の量を表します。最初の引数は容器の大きさを表し、次の引数が容器に入っている水の量を表します。容器を水で満たす、または空にする操作は簡単ですね。他の容器へ移す場合、たとえば transfer3 では、B の空き容量と A の水の量を比較して、少ない方が移す水の量になります。
</p>

<p> あとは幅優先探索で最短手順を求めるだけです。次のリストを見てください。
</p>
<pre class="list">
リスト : 水差し問題の解法

import Queue

solver :: (Int, Int) -&gt; Int -&gt; [(Int, Int)]
solver size goal = iter (singleton [(0, 0)]) where
  isGoal ((a, b):_) = a == goal || b == goal
  transfer = [transfer1, transfer2, transfer3, transfer4, transfer5, transfer6]
  check move q f =
    if news `elem` move then q else enqueue q (news:move)
    where news = f size (head move)
  iter q
    | isEmptyQueue q = []
    | otherwise =
        let (move, q1) = dequeue q
        in if isGoal move then reverse move
           else iter $ foldl (check move) q1 transfer
</pre>
<p> 関数 solver の引数 size は容器の大きさを格納したタプル、goal は求める水の量です。実際の処理は局所関数 iter で行います。手順はタプルを格納したリストで表します。最初に [(0, 0)] をキューに格納し、キューからデータを取り出して探索を行います。
</p>
<p> A または B に水が goal リットルあれば解を見つけることができました。reverse で move を逆順にして返します。そうでなければ、foldl で操作関数を順番に適用して、新しい状態 news を生成します。news が今までの手順 move の中に出現していれば、堂々巡りになっているのでキューに追加しません。そうでなければ、news : move をキューに追加します。この処理を関数 check で行っています。
</p>
<h4>●実行結果</h4>
<p> 結果は次のようになりました。
</p>
<pre>
*Main&gt; solver (8, 5) 4
[(0,0),(0,5),(5,0),(5,5),(8,2),(0,2),(2,0),(2,5),(7,0),(7,5),(8,4)]
</pre>
<p> このように、最短手順は 10 手になります。
</p>

<h4>●数字の並べ替え</h4>
<div class="question">
<b>[問題]</b>数字の並べ替え
<pre class="fig">
 ┌─┬─┬─┬─┬─┐
 │１│２│３│４│  │スタート 
 └─┴─┴─┴─┴─┘
 ┌─┬─┬─┬─┬─┐
 │  │４│３│２│１│ゴール   
 └─┴─┴─┴─┴─┘

    図 : 数字の並べ替え
</pre>
<p> 上図のスタートのように並んでいる数字を、ゴールのように逆順に並べ替える最短手順を求めてください。数字を動かす規則は次のとおりです。
</p>
<ul>
<li>数字の隣が空いていれば、その数字は空いている場所へ移動できる。
<li>隣に数字があってもその数字の隣が空いていれば、隣の数字を跳び越して空き場所へ移動できる。
</ul>
<p> スタートの状態では、4 は隣が空き場所なので移動することができます。また、3 は隣に 4 がありますが、それを跳び越して空き場所へ移動することができます。ほかの数字は空き場所へ移動できません。
</p>
<p> このパズルは、高木茂男氏の著書「パズル遊びへの招待」(PHP研究所 1994) の <a href="http://www.torito.jp/puzzles/puzzle_asobi.shtml">オンライン版</a> にある
</p>
<a href="http://www.torito.jp/puzzles/112.shtml">おしどりの遊びと入れ替え問題</a> を参考にさせていただきました。数字を逆順に並べることは同じですが、空き場所の位置が異なっているので少しだけ難しくなっていると思います。
</DIV>
<p> なお、このドキュメントは拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/changenum1.html">続・数字の並べ替え</a> を Haskell 用に書き直したものです。内容は重複しますが、あしからずご了承ください。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。盤面はリスト [Int] で、空き場所は 0 で表すことにします。数字を動かして新しい盤面を作る関数は次のようになります。
</p>

<pre class="list">
リスト :  数字を動かす

movePiece :: Int -&gt; [Int] -&gt; [Int]
movePiece _ [] = []
movePiece n (x:xs) 
  | x == n    = 0 : movePiece n xs
  | x == 0    = n : movePiece n xs
  | otherwise = x : movePiece n xs
</pre>
<p> 関数 movePiece は数字 n を空き場所の位置へ移動します。リストの要素 x が n ならば 0 に、0 ならば n に置き換えるだけです。
</p>

<p> 次は移動可能な数字を動かして新しい状態を生成する関数 makeState を作ります。
</p>
<pre class="list">
リスト : 新しい状態を作る

-- 状態を表すデータ型
data State = State {board :: [Int], space :: Int} deriving (Eq, Show)

makeState :: State -&gt; [State]
makeState s =
  foldr (\x a -&gt; let b = board s
                     n = x + space s
                     p = b !! n
                 in if n &lt; 0 || n &gt;= length b
                    then a
                    else State (movePiece p b) n : a)
        []
        [-2, -1, 1, 2]
</pre>
<p> データ型 State は盤面 board と空き場所の位置 space を格納します。空き場所の位置を x とすると、そこに移動できる数字の位置は x - 2, x - 1, x + 1, x + 2 の 4 通りあります。あとは、その位置が盤面の範囲内にあるかチェックして、そうであれば movePiece で新しい盤面を作ります。この処理を畳み込み foldr で行っています。
</p>
<p> 最後に幅優先探索で最短手順を求めます。
</p>
<pre class="list">
リスト : 幅優先探索

solver :: State -&gt; State -&gt; [State]
solver start goal = iter (singleton [start]) where
  check xs q s =
    if s `elem` xs then q else enqueue q (s:xs)
  iter q
    | isEmptyQueue q = []
    | otherwise =
        let (xs, q1) = dequeue q
            s1 = head xs
        in if s1 == goal then reverse xs
           else iter $ foldl (check xs) q1 (makeState s1)
</pre>
<p> 関数 solver の引数 start がスタートの状態、goal がゴールの状態を表します。実際の処理は局所関数 iter で行います。手順は State を格納したリストで表します。最初に [start] をキューに格納し、キューからデータを取り出して探索を行います。
</p>
<p> 手順 xs の先頭要素 s1 が goal と等しければ、解を求めることができました。xs を反転してから返します。そうでなければ、makeState で新しい状態を生成し、それを foldl でキューに追加します。このとき、関数 check で堂々巡りしていないことをチェックします。
</p>
<h4>●実行結果</h4>
<p> 結果は次のようになりました。
</p>
<pre>
*Main&gt; solver (State [1,2,3,4,0] 4) (State [0,4,3,2,1] 0)
[State {board = [1,2,3,4,0], space = 4},
 State {board = [1,2,3,0,4], space = 3},
 State {board = [1,2,0,3,4], space = 2},
 State {board = [1,0,2,3,4], space = 1},
 State {board = [1,3,2,0,4], space = 3},
 State {board = [1,3,2,4,0], space = 4},
 State {board = [1,3,0,4,2], space = 2},
 State {board = [0,3,1,4,2], space = 0},
 State {board = [3,0,1,4,2], space = 1},
 State {board = [3,4,1,0,2], space = 3},
 State {board = [3,4,1,2,0], space = 4},
 State {board = [3,4,0,2,1], space = 2},
 State {board = [0,4,3,2,1], space = 0}]
</pre>
<p> 12 手で解くことができました。実は、これが最長手数の局面になります。
</p>
<h4>●嫉妬深い夫の問題</h4>
<div class="question">
<b>[問題]</b> 嫉妬深い夫の問題
<p> 三組の夫婦が川を渡ることになりました。ボートには二人しか乗ることができません。どの夫も嫉妬深く、彼自身が一緒にいない限り、ボートでも岸でも妻が他の男といることを許しません。なお、六人ともボートをこぐことができます。この条件で、三組の夫婦が川を渡る最短手順を考えてください。
</p>

<p> 「嫉妬深い夫の問題」は「川渡りの問題」と呼ばれる古典的なパズルの一種です。このパズルにはたくさんのバリエーションがありますが、その中で <a href="../puzzle/farmer.html">「農夫と山羊と狼とキャベツの問題」</a> や「宣教師と人食い人」という危険な名前のパズルが有名です。
</p>
</div>
<p> なお、このドキュメントは拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/husband.html">嫉妬深い夫の問題</a> を Haskell 用に書き直したものです。内容は重複しますが、あしからずご了承ください。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作ります。今回は左岸から右岸へ渡ることにしましょう。まず最初に、夫婦と岸の状態を表すデータ構造を決めます。次のリストを見てください。
</p>
<pre class="list">
リスト : データ型の定義

-- ボートの位置
data Boat = LEFT | RIGHT deriving (Show, Eq)

-- 夫婦
data Person = Ha | Wa | Hb | Wb | Hc | Wc deriving (Show, Eq)

-- 状態を表す
data State = State {boat :: Boat, left :: [Person], right :: [Person]}
  deriving Show
</pre>
<p> いろいろな方法が考えられますが、今回は 3 組の夫婦をデータ型 Person のデータ構築子 Ha, Wa, Hb, Wb, Hc, Wc で、岸の状態をリスト [Person] で表すことにします。H で始まるデータ構築子が夫、W で始まるデータ構築子が妻を表します。そして、ボートの位置を表すデータ型 Boat (LEFT or RIGHT)、左岸 left の状態 [Person]、右岸 right の状態 [Person] をデータ型 State に格納します。したがって、最初の局面は State LEFT [Ha, Hb, Hc, Wa, Wb, Wc] [ ]、ゴールの局面は State RIGHT [ ] [Ha, Hb, Hc, Wa, Wb, Wc] と表すことができます。
</p>
<h4>●リストの集合演算</h4>
<p> 岸の状態はデータ構築子の集まりなので、リストを「集合 (set) 」として扱うと操作が簡単になります。Haskell のモジュール Data.List に用意されているリストの集合演算を下表に示します。
</p>

<table border=1>
<caption>表 : リストの集合演算</caption>
<thead>
  <tr><th>関数名</th><th>型</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>union xs ys</td><td>Eq a =&gt; [a] -&gt; [a] -&gt; [a]</td><td>xs と ys の和を求める</td></tr>
  <tr><td>intersect xs ys</td><td>Eq a =&gt; [a] -&gt; [a] -&gt; [a]</td><td>xs と ys の積を求める</td></tr>
  <tr><td>xs \\ ys</td><td>Eq a =&gt; [a] -&gt; [a] -&gt; [a]</td><td>ys に現れない xs の要素をリストにして返す (集合の差を求める)</td></tr>
  <tr><td>nub xs</td><td>Eq a =&gt; [a] -&gt; [a]</td><td>xs の重複要素を削除する</td></tr>
</tbody>
</table>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude Data.List&gt; nub [1,2,3,1,2,3,4,1,2,3,4,5]
[1,2,3,4,5]
Prelude Data.List&gt; union [1,2,3,4] [3,4,5,6]
[1,2,3,4,5,6]
Prelude Data.List&gt; intersect [1,2,3,4] [3,4,5,6]
[3,4]
Prelude Data.List&gt; [1,2,3,4] \\ [3,4,5,6]
[1,2]
Prelude Data.List&gt; [3,4,5,6] \\ [1,2,3,4]
[5,6]
</pre>
<p> このほかに集合 xs, ys が等しいか判定する述語が必要になります。
</p>
<pre class="list">
リスト : 集合の等値判定

isEqSet :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool
isEqSet xs ys = null(xs \\ ys) &amp;&amp; null(ys \\ xs)
</pre>
<p> 関数名は isEqSet としました。集合 xs と ys の差を求め、それが空リストであれば、xs は ys の部分集合 (xs ⊆ ys) であることがわかります。次に、ys と xs の差を求めます。それが空リストであれば、ys は xs の部分集合 (xs ⊇ ys) となり、 xs ⊆ ys かつ xs ⊇ ys が成り立つので、xs と ys は等しい集合であることがわかります
</p>

<p> 次に、State 型の等値を判定する処理を作ります。
</p>
<pre class="list">
リスト : State 型の等値判定

instance Eq State where
  State b1 l1 r1 == State b2 l2 r2 =
    b1 == b2 &amp;&amp; isEqSet l1 l2 &amp;&amp; isEqSet r1 r2
</pre>
<p> instance 宣言で State 型を型クラス Eq のインスタンスに設定します。Boat 型は演算子 == で比較し、左右の岸の状態は関数 isEqSet で比較します。
</p>
<h4>●安全確認</h4>
<p> 次はボートや岸の状態が安全か確認する処理を作ります。
</p>

<pre class="list">
リスト : 安全確認

safe :: [Person] -&gt; Bool
safe xs = null(intersect xs [Ha, Hb, Hc]) || iter xs where
  iter [] = True
  iter (Wa:ys) = if Ha `elem` xs then iter ys else False
  iter (Wb:ys) = if Hb `elem` xs then iter ys else False
  iter (Wc:ys) = if Hc `elem` xs then iter ys else False
  iter (_:ys)  = iter ys
</pre>

<p> 関数 safe の引数 xs はボートまたは岸の状態を表すリストです。xs に男性がいない場合は安全です。intersect で xs と [Ha, Hb, Hc] の積を求め、それが空リストであれば男性がいないことがわかります。そうでなければ、局所関数 iter で安全を確認します。要素が女性の場合、リスト xs に夫がいることを確認します。夫がいない場合、夫以外の男性と一緒にいることになるので False を返します。
</p>
<h4>●ボートに乗る組み合わせ</h4>
<p> 次はボートに乗る組み合わせを求める処理を作ります。
</p>
<pre class="list">
リスト : ボートに乗る組み合わせを作る

-- 組み合わせの生成
combinations :: Int -&gt; [a] -&gt; [[a]]
combinations n xs = comb n xs [] [] where
  comb 0 _      ys zs = reverse ys : zs
  comb _ []     _  zs = zs
  comb n (x:xs) ys zs = comb (n - 1) xs (x:ys) (comb n xs ys zs)

selectPerson :: [Person] -&gt; [[Person]]
selectPerson xs = filter safe $ combinations 1 xs ++ combinations 2 xs
</pre>
<p> 関数 combinations はリスト xs から n 個を取り出す組み合わせを求めます。これは拙作のページ <a href="haskell06.html">順列と組み合わせ</a> で作成したプログラムと同じです。
</p>
<p> 関数 selectPerson は引数 xs からボートに乗り込む組み合わせを作ります。xs から 1 人選ぶ組み合わせと 2 人選ぶ組み合わせを求めて演算子 ++ で連結します。そして、filter で安全な状態のみを取り出して返します。
</p>

<h4>●新しい局面の生成</h4>
<p> 次はボートを動かして新しい局面を生成する処理を作ります
</p>

<pre class="list">
リスト : ボートを動かして新しい局面を生成する

isLeft s = boat s == LEFT

toLeft :: State -&gt; [Person] -&gt; State
toLeft s xs = State LEFT (union (left s) xs) ((right s) \\ xs)

toRight :: State -&gt; [Person] -&gt; State
toRight s xs = State RIGHT ((left s) \\ xs) (union (right s) xs)

check :: State -&gt; [State] -&gt; Bool
check s xs = safe (left s) &amp;&amp; safe (right s) &amp;&amp; s `notElem` xs

moveBoat q xs@(s:_) =
  foldl (\a x -&gt; let s1 = if isLeft s then toRight s x else toLeft s x
                 in if check s1 xs then enqueue a (s1:xs) else a)
        q
        (selectPerson (if isLeft s then left s else right s))
</pre>
<p> 関数 isLeft はボートが左岸にあるとき真を返します。関数 toLeft は xs の人達を右岸から左岸へ移動します。新しい状態は boat を LEFT に設定します。左岸は left に xs の人達を追加します。これは集合の和を求める関数 union を使うと簡単です。右岸の状態は、集合の差を求める演算子 \\ を使って、right から xs の人達を取り除きます。関数 toRight は xs の人達を左岸から右岸へ移動します。toRight は toLeft の処理と左右が反転するだけです。
</p>

<p> 関数 moveBoat は局面 s から新しい局面を生成し、それを引数のキュー q に追加します。ボートに乗る組み合わせを selectPerson で作成し、それを foldl で一つずつ取り出して新しい局面 s1 を生成します。s1 が安全な状態でかつ xs に含まれていないことを関数 check で確認します。そうであれば、s1 : xs をキューに追加します。
</p>

<h4>●幅優先探索による解法</h4>
<p> あとは幅優先探索で最短手順を求めるだけです。
</p>
<pre class="list">
リスト : 解法

solver :: [State]
solver = iter (singleton [State LEFT person []])
  where
    person = [Ha, Wa, Hb, Wb, Hc, Wc]
    isGoal s = s == State RIGHT [] person
    iter q
      | isEmptyQueue q = []
      | otherwise =
          let (xs@(s:_), q1) = dequeue q
          in if isGoal s then reverse xs
             else iter $ moveBoat q1 xs
</pre>
<p> solver は単純な幅優先探索なので、とくに難しいところはないと思います。
</p>
<h4>●実行結果</h4>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; solver2
[State {boat = LEFT,  left = [Ha,Wa,Hb,Wb,Hc,Wc], right = []},
 State {boat = RIGHT, left = [Hb,Wb,Hc,Wc],       right = [Ha,Wa]},
 State {boat = LEFT,  left = [Hb,Wb,Hc,Wc,Ha],    right = [Wa]},
 State {boat = RIGHT, left = [Hb,Hc,Ha],          right = [Wa,Wb,Wc]},
 State {boat = LEFT,  left = [Hb,Hc,Ha,Wa],       right = [Wb,Wc]},
 State {boat = RIGHT, left = [Ha,Wa],             right = [Wb,Wc,Hb,Hc]},
 State {boat = LEFT,  left = [Ha,Wa,Wb,Hb],       right = [Wc,Hc]},
 State {boat = RIGHT, left = [Wa,Wb],             right = [Wc,Hc,Ha,Hb]},
 State {boat = LEFT,  left = [Wa,Wb,Wc],          right = [Hc,Ha,Hb]},
 State {boat = RIGHT, left = [Wc],                right = [Hc,Ha,Hb,Wa,Wb]},
 State {boat = LEFT,  left = [Wc,Hc],             right = [Ha,Hb,Wa,Wb]},
 State {boat = RIGHT, left = [],                  right = [Ha,Hb,Wa,Wb,Wc,Hc]}]
</pre>
<p> 11 手で解くことができました。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell11.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell13.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>