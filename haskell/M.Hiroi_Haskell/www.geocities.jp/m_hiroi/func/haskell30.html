<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881791</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell29.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell31.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">モナド変換子 (2)</h3>
<p> モナド変換子の続きです。今回は状態系のモナド変換子 WriterT, ReaderT, StateT について説明します。
</p>

<h4>●WriterT の使い方</h4>
<p> まずは最初に、WriterT から説明しましょう。WriterT は Writer のモナド変換子で、モジュール Control.Monad.Writer に定義されています。データ型は WriterT w m a で、w がログを表すデータ型 (モノイド)、m がモナド、a が値を表すデータ型です。WriterT は (a, w) をモナド m で包んだ m (a, w) になります。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
Prelude&gt; :m Control.Monad.Writer
Prelude Control.Monad.Writer&gt; runWriterT (return 1 :: WriterT String Maybe Int)
Just (1,"")
Prelude Control.Monad.Writer&gt; runWriterT (return 1 :: WriterT String [] Int)
[(1,"")]
Prelude Control.Monad.Writer&gt; runWriterT (return 1 :: WriterT String IO Int)
(1,"")

Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String Maybe Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x * 2)
Just (2,"oops")
Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String [] Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x * 2)
[(2,"oops")]
Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String IO Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x * 2)
(2,"oops")
Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String IO Int) &gt;&gt;= \x -&gt; liftIO(print "oops") &gt;&gt; return (x * 2)
"oops"
(2,"")

Prelude Control.Monad.Writer&gt; runWriterT $ (fail "" :: WriterT String Maybe Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x * 2)
Nothing
Prelude Control.Monad.Writer&gt; runWriterT $ (fail "" :: WriterT String [] Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x * 2)
[]

Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String Maybe Int) `mplus` return 2
Just (1,"")
Prelude Control.Monad.Writer&gt; runWriterT $ (mzero :: WriterT String Maybe Int) `mplus` return 2
Just (2,"")
Prelude Control.Monad.Writer&gt; runWriterT $ (mzero :: WriterT String Maybe Int) `mplus` mzero
Nothing

Prelude Control.Monad.Writer&gt; runWriterT $ (return 1 :: WriterT String [] Int) `mplus` return 2
[(1,""),(2,"")]
Prelude Control.Monad.Writer&gt; runWriterT $ (mzero :: WriterT String [] Int) `mplus` return 2
[(2,"")]
Prelude Control.Monad.Writer&gt; runWriterT $ (mzero :: WriterT String [] Int) `mplus` mzero
[]
</pre>

<h4>●自分で WriterT を作る</h4>
<p> それでは Haskell のお勉強ということで、あえて自分で WriterT を作ってみましょう。WriterT は Writer をモナドに包んだものなので、Writer モナドの定義とよく似ています。次のリストを見てください。
</p>
<pre class="list">
リスト : Writer モナドの定義

-- データ型の定義
newtype Writer w a = Writer {runWriter :: (a, w)}

-- インスタンスの設定
instance Monoid w =&gt; Monad (Writer w) where
  return x = Writer (x, mempty)
  (Writer (x, v)) &gt;&gt;= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')
</pre>
<pre class="list">
リスト : モナド変換子 WriterT

newtype WriterT w m a = WriterT {runWriterT :: m (a, w)}

instance (Monoid w, Monad m) =&gt; Monad (WriterT w m) where
  return x = WriterT $ return (x, mempty)
  m &gt;&gt;= k  = WriterT $ do (y, v) &lt;- runWriterT m
                          (z, v') &lt;- runWriterT (k y)
                          return (z, v `mappend` v')
  fail s   = WriterT $ fail s

-- ログの書き込み
tell :: (Monoid w, Monad m) =&gt; w -&gt; WriterT w m ()
tell s = WriterT $ return ((), s)
</pre>
<p> return x は (x, empty) をモナドに包んで返します。バインド演算子は、最初にモナド m から値とログ (y, v) を取り出します。次に、値 y を関数 k に適用して、その値とログ (z, v') を取り出します。あとは、ログ v, v' を mappend で結合して、z と一緒にモナドに包んで返します。
</p>
<p>ログを書き込む tell も簡単です。引数 s をタプル ((), s) に格納し、それをモナドに包んで返すだけです。ここではプログラムを簡単にするため、tell を関数として定義しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runWriterT $ (return 1 :: WriterT String [] Int)
[(1,"")]
*Main&gt; runWriterT $ (return 1 :: WriterT String [] Int) &gt;&gt;= \x -&gt; return (x*2)
[(2,"")]
*Main&gt; runWriterT $ (return 1 :: WriterT String [] Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x*2)
[(2,"oops")]
*Main&gt; runWriterT $ (return 1 :: WriterT String IO Int)
(1,"")
*Main&gt; runWriterT $ (return 1 :: WriterT String IO Int) &gt;&gt;= \x -&gt; tell("oops") &gt;&gt; return (x*2)
(2,"oops")
</pre>
<h4>●WriterT の Functor</h4>
<p> WriterT の Functor は簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : WriterT の Functor

instance Monad m =&gt; Functor (WriterT w m) where
  fmap f x = WriterT $ do (a, w) &lt;- runWriterT x
                          return (f a, w)
</pre>
<p> fmap はモナド x に格納されている値 a に関数 f を適用するだけです。ログ w はそのままとします。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runWriterT $ fmap (*2) (return 1 :: WriterT String [] Int)
[(2,"")]
*Main&gt; runWriterT $ fmap (*2) (return 1 :: WriterT String IO Int)
(2,"")
*Main&gt; runWriterT $ fmap (*2) (return 1 :: WriterT String Maybe Int)
Just (2,"")
</pre>

<h4>●WriterT の lift 関数と MonadPlus</h4>
<p> lift 関数と MonadPlus の定義も簡単です。
</p>
<pre class="list">
リスト : WriterT の lift 関数と MonadPlus

instance Monoid w =&gt; MonadTrans (WriterT w) where
  lift m = WriterT $ m &gt;&gt;= (\x -&gt; return (x, mempty))

instance (Monoid w, MonadIO m) =&gt; MonadIO (WriterT w m) where
  liftIO = lift . liftIO

instance (Monoid w, MonadPlus m) =&gt; MonadPlus (WriterT w m) where
  mzero = WriterT mzero
  x `mplus` y = WriterT $ runWriterT x `mplus` runWriterT y
</pre>
<p> lift はモナド m から値 x を取り出して、それをタプル (x, mempty) にまとめてモナドに包んで返します。ログは mempty とします。WriterT の MonadPlus は MonadPlus m の mzero, mplus を呼び出すだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runWriterT $ (return 1 :: WriterT String IO Int) &gt;&gt;= \x -&gt; lift(print "oops") &gt;&gt; return (x*2)
"oops"
(2,"")
*Main&gt; runWriterT $ (return 1 :: WriterT String IO Int) &gt;&gt;= \x -&gt; liftIO(print "oops") &gt;&gt; return (x*2)
"oops"
(2,"")
</pre>
<pre>
*Main&gt; runWriterT $ (return 1 :: WriterT String Maybe Int) `mplus` (return 2)
Just (1,"")
*Main&gt; runWriterT $ (mzero :: WriterT String Maybe Int) `mplus` (return 2)
Just (2,"")
*Main&gt; runWriterT $ (mzero :: WriterT String Maybe Int) `mplus` mzero
Nothing
*Main&gt; runWriterT $ (return 1 :: WriterT String [] Int) `mplus` (return 2)
[(1,""),(2,"")]
*Main&gt; runWriterT $ (mzero :: WriterT String [] Int) `mplus` (return 2)
[(2,"")]
*Main&gt; runWriterT $ (mzero :: WriterT String [] Int) `mplus` mzero
[]
</pre>

<h4>●WriterT の簡単な例題</h4>
<p> それでは簡単な例題として、拙作のページ <a href="haskell18.html">モナド (2)</a> で作成したフィボナッチ関数の呼び出し履歴を求めるプログラムで、履歴を画面へ出力するように修正してみましょう。
</p>
<pre class="list">
リスト : フィボナッチ関数の履歴

type WriterIO w a = WriterT w IO a

fibo :: Int -&gt; WriterIO [String] Int
fibo n = do
  let s1 = "fibo " ++ show n ++ " called"
  tell [s1]
  liftIO (print s1)
  if n &lt; 2 then do
    let s2 = "fibo " ++ show n ++ " = 1"
    tell [s2]
    liftIO (print s2)
    return 1
  else do 
    a &lt;- fibo (n - 1)
    b &lt;- fibo (n - 2)
    let s3 = "fibo " ++ show n ++ "= " ++ show (a + b)
    tell [s3]
    liftIO (print s3)
    return (a + b)
</pre>
<p> プログラムは簡単です。type で WriterT w IO a に別名 WriterIO w a をつけます。関数 fibo の返り値のデータ型は WriterIO [String] Int になります。あとは、liftIO でログに追加する文字列を print で画面に出力するだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; runWriterT $ fibo 4
"fibo 4 called"
"fibo 3 called"
"fibo 2 called"
"fibo 1 called"
"fibo 1 = 1"
"fibo 0 called"
"fibo 0 = 1"
"fibo 2= 2"
"fibo 1 called"
"fibo 1 = 1"
"fibo 3= 3"
"fibo 2 called"
"fibo 1 called"
"fibo 1 = 1"
"fibo 0 called"
"fibo 0 = 1"
"fibo 2= 2"
"fibo 4= 5"
(5,["fibo 4 called","fibo 3 called","fibo 2 called","fibo 1 called","fibo 1 = 1",
"fibo 0 called","fibo 0 = 1","fibo 2= 2","fibo 1 called","fibo 1 = 1","fibo 3=3",
"fibo 2 called","fibo 1 called","fibo 1 = 1","fibo 0 called","fibo 0 = 1","fibo 2= 2","fibo 4= 5"])
</pre>
<p> 正常に動作していますね。
</p>
<h4>●ReaderT の使い方</h4>
<p> 次は ReaderT について説明します。ReaderT はモジュール Control.Monad.Reader に定義されています。データ型は ReaderT r m a で、m がモナドを表します。Reader r a は関数 r -&gt; a を格納したものです。ReaderT r m a は関数 r -&gt; a をモナド m で包むのではなく、返り値 a だけをモナド m で包みます。つまり、m (r -&gt; a) ではなく、r -&gt; m a になることに注意してください。
</p>

<p> 簡単な例を示します。
</p>
<pre>
Prelude&gt; :m Control.Monad.Reader
Prelude Control.Monad.Reader&gt; runReaderT (return 1 :: ReaderT Int Maybe Int) 0
Just 1
Prelude Control.Monad.Reader&gt; runReaderT (return 1 :: ReaderT Int [] Int) 0
[1]
Prelude Control.Monad.Reader&gt; runReaderT (return 1 :: ReaderT Int IO Int) 0
1
Prelude Control.Monad.Reader&gt; runReaderT ((ask :: ReaderT Int Maybe Int) &gt;&gt;= \x -&gt; return (x + 10)) 0
Just 10
Prelude Control.Monad.Reader&gt; runReaderT ((ask :: ReaderT Int [] Int) &gt;&gt;= \x -&gt; return (x + 10)) 0
[10]
Prelude Control.Monad.Reader&gt; runReaderT ((ask :: ReaderT Int IO Int) &gt;&gt;= \x -&gt; return (x + 10)) 0
10

Prelude Control.Monad.Reader&gt; runReaderT ((fail "" :: ReaderT Int Maybe Int) &gt;&gt;= \x -&gt; return (x + 10)) 0
Nothing
Prelude Control.Monad.Reader&gt; runReaderT ((fail "" :: ReaderT Int [] Int) &gt;&gt;= \x -&gt; return (x + 10)) 0
[]

Prelude Control.Monad.Reader&gt; runReaderT ((ask :: ReaderT Int Maybe Int) `mplus` return 1) 0
Just 0
Prelude Control.Monad.Reader&gt; runReaderT ((mzero :: ReaderT Int Maybe Int) `mplus` return 1) 0
Just 1
Prelude Control.Monad.Reader&gt; runReaderT ((mzero :: ReaderT Int Maybe Int) `mplus` mzero) 0
Nothing

Prelude Control.Monad.Reader&gt; runReaderT ((ask :: ReaderT Int [] Int) `mplus` return 1) 0
[0,1]
Prelude Control.Monad.Reader&gt; runReaderT ((mzero :: ReaderT Int [] Int) `mplus` return 1) 0
[1]
Prelude Control.Monad.Reader&gt; runReaderT ((mzero :: ReaderT Int [] Int) `mplus` mzero) 0
[]
</pre>
<h4>●自分で ReaderT を作る</h4>
<p> それでは Haskell のお勉強ということで、自分で ReaderT を作ってみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : Reader モナドの定義

-- データ型の定義
newtype Reader e a = Reader {runReader :: e -&gt; a}

-- インスタンスの設定
instance Monad (Reader e) where
  return x         = Reader $ \_ -&gt; x
  (Reader f) &gt;&gt;= g = Reader $ \e -&gt; runReader (g (f e)) e

ask :: Reader a a
ask = Reader id

local :: (e -&gt; e) -&gt; Reader e a -&gt; Reader e a
local f c = Reader $ \e -&gt; runReader c (f e)
</pre>
<pre class="list">
リスト : ReaderT の定義

newtype ReaderT r m a = ReaderT {runReaderT :: r -&gt; m a}

instance Monad m =&gt; Monad (ReaderT r m) where
  return x = ReaderT $ \_ -&gt; return x
  m &gt;&gt;= k  = ReaderT $ \r -&gt; do a &lt;- runReaderT m r
                                runReaderT (k a) r
  fail s   = ReaderT $ \_ -&gt; fail s

ask :: Monad m =&gt; ReaderT a m a
ask = ReaderT return

local :: Monad m =&gt; (e -&gt; e) -&gt; ReaderT e m a -&gt; ReaderT e m a
local f c = ReaderT $ \e -&gt; runReaderT c (f e)
</pre>

<p> Reader の return x は Reader $ \_ -&gt; x でした。ReaderT は返り値をモナドに包めばよいので、ReaderT $ \_ -&gt; return x となります。バインド演算子は runReaderT m r でモナド m に r を渡して評価し、do 構文の &lt;- でモナドから値を取り出して変数 a にセットします。k a の返り値は ReaderT 型になるので、runReaderT で関数を取り出して引数 r に適用します。fail は引数 s をモナド m の fail に渡すだけです。
</p>

<p> 関数 ask も簡単です。return で引数をモナドに包み、それを ReaderT に格納するだけです。local は引数 e に関数 f を適用して環境を更新し、それに runReaderT c を適用します。ここではプログラムを簡単にするため、ask と local を関数として定義しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runReaderT (return 1 :: ReaderT Int [] Int) 0
[1]
*Main&gt; runReaderT (return 1 :: ReaderT Int Maybe Int) 0
Just 1
*Main&gt; runReaderT (return 1 :: ReaderT Int IO Int) 0
1
*Main&gt; runReaderT (ask :: ReaderT Int [] Int) 10
[10]
*Main&gt; runReaderT (ask :: ReaderT Int Maybe Int) 10
Just 10
*Main&gt; runReaderT (ask :: ReaderT Int IO Int) 10
10
*Main&gt; runReaderT ((ask :: ReaderT Int [] Int) &gt;&gt;= \x -&gt; return (x * 10)) 10
[100]
*Main&gt; runReaderT ((ask :: ReaderT Int Maybe Int) &gt;&gt;= \x -&gt; return (x * 10)) 10
Just 100
*Main&gt; runReaderT ((ask :: ReaderT Int IO Int) &gt;&gt;= \x -&gt; return (x * 10)) 10
100
*Main&gt; runReaderT (local (+10) ((ask :: ReaderT Int IO Int) &gt;&gt;= \x -&gt; return (x * 10))) 10
200
*Main&gt; runReaderT (local (+10) ((ask :: ReaderT Int [] Int) &gt;&gt;= \x -&gt; return (x * 10))) 10
[200]
*Main&gt; runReaderT (local (+10) ((ask :: ReaderT Int Maybe Int) &gt;&gt;= \x -&gt; return (x * 10))) 10
Just 200
</pre>

<h4>●ReaderT の Functor</h4>
<p> ReaderT も Functor を定義することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : ReaderT の Functor

instance (Monad m) =&gt; Functor (ReaderT r m) where
  fmap f x = ReaderT $ \r -&gt; do a &lt;- runReaderT x r
                                return (f a)
</pre>
<p> runReaderT でモナド x に引数 r を与えて、その返り値を変数 a に受け取ります。あとは、変数 a に関数 f を適用して、その返り値を return でモナドに包んで返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runReaderT (fmap (*2) (ask :: ReaderT Int IO Int)) 1
2
*Main&gt; runReaderT (fmap (*2) (ask :: ReaderT Int [] Int)) 1
[2]
*Main&gt; runReaderT (fmap (*2) (ask :: ReaderT Int Maybe Int)) 1
Just 2
</pre>
<h4>●ReaderT の lift 関数と MonadPlus</h4>
<p> lift 関数と MonadPlus の定義も簡単です。
</p>
<pre class="list">
リスト : ReaderT の lift 関数と MonadPlus

instance MonadTrans (ReaderT r) where
  lift m = ReaderT $ \_ -&gt; m

instance (MonadIO m) =&gt; MonadIO (ReaderT r m) where
  liftIO = lift . liftIO

instance MonadPlus m =&gt; MonadPlus (ReaderT r m) where
  mzero       = ReaderT $ \_ -&gt; mzero
  x `mplus` y = ReaderT $ \r -&gt; runReaderT x r `mplus` runReaderT y r
</pre>
<p> ReaderT のデータ型は r -&gt; m a なので、lift はモナド m をラムダ式に包んで返すだけで実現できます。ReaderT の MonadPlus は MonadPlus m の mzero, mplus を呼び出すだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runReaderT ((ask :: ReaderT Int IO Int) &gt;&gt;= \x -&gt; lift(print x) &gt;&gt; return (x * 2)) 10
10
20
*Main&gt; runReaderT ((ask :: ReaderT Int IO Int) &gt;&gt;= \x -&gt; liftIO(print x) &gt;&gt; return (x * 2)) 10
10
20

*Main&gt; runReaderT ((ask :: ReaderT Int Maybe Int) `mplus` ask) 10
Just 10
*Main&gt; runReaderT ((mzero :: ReaderT Int Maybe Int) `mplus` ask) 10
Just 10
*Main&gt; runReaderT ((mzero :: ReaderT Int Maybe Int) `mplus` mzero) 10
Nothing
*Main&gt; runReaderT ((ask :: ReaderT Int [] Int) `mplus` ask) 10
[10,10]
*Main&gt; runReaderT ((ask :: ReaderT Int [] Int) `mplus` mzero) 10
[10]
*Main&gt; runReaderT ((mzero :: ReaderT Int [] Int) `mplus` mzero) 10
[]
</pre>
<h4>●ReaderT の簡単な例題</h4>
<p> それでは簡単な例題として、ReaderT モナドを使って果物の値段を求めるプログラムを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 果物の値段を求める

type ReaderMaybe r a = ReaderT r Maybe a

data Fruit = Apple | Grape | Orange | Peach deriving (Show, Eq)
type Price = (Fruit, Int)

priceList :: [Price]
priceList = [(Apple, 100), (Grape, 150), (Orange, 200)]

lookupPrice :: Fruit -&gt; ReaderMaybe [Price] Int
lookupPrice x =
  ask &gt;&gt;= \ps -&gt; case lookup x ps of
                   Nothing -&gt; fail ""
                   Just v  -&gt; return v
</pre>

<p> 最初に、type で ReaderT r Maybe a の別名 ReaderMaybe r a をつけます。次に、果物を表すデータ型 Fruit と果物の値段を表すデータ型 Price を定義します。果物の値段は連想リスト priceList に定義します。関数 lookupPrice は果物 x の値段を求めます。ask で環境の値 ps を求め、関数 lookup で果物 x の値段を ps から探索します。見つけた場合は値 v を return でモナド (Maybe) に包んで返します。そうでなければ、fail で Nothing を返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runReaderT (lookupPrice Apple) priceList
Just 100
*Main&gt; runReaderT (lookupPrice Grape) priceList
Just 150
*Main&gt; runReaderT (lookupPrice Orange) priceList
Just 200
*Main&gt; runReaderT (lookupPrice Peach) priceList
Nothing
</pre>
<p> Peach は priceList に定義されていないので、返り値は Nothing になります。
</p>

<h4>●StateT の使い方</h4>
<p> 次は StateT について説明します。StateT は State のモナド変換子で、モジュール Control.Monad.State に定義されています。データ型は StateT s m a で、s が状態を表すデータ型、m がモナド、a が値を表します。State s a は関数 s -&gt; (a, s) を格納したものですが、StateT s m a は関数 s -&gt; (a, s) をモナド m で包むのではなく、返り値 (a, s) だけをモナド m で包みます。つまり、m (s -&gt; (a, s)) ではなく、s -&gt; m (a, s) になることに注意してください。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; :m Control.Monad.State
Prelude Control.Monad.State&gt; runStateT (return 1 :: StateT Int Maybe Int) 0
Just (1,0)
Prelude Control.Monad.State&gt; runStateT (return 1 :: StateT Int [] Int) 0
[(1,0)]
Prelude Control.Monad.State&gt; runStateT (return 1 :: StateT Int IO Int) 0
(1,0)

Prelude Control.Monad.State&gt; runStateT ((get :: StateT Int Maybe Int) &gt;&gt;= \x -&gt; return (x * 2)) 1
Just (2,1)
Prelude Control.Monad.State&gt; runStateT ((get :: StateT Int [] Int) &gt;&gt;= \x -&gt; return (x * 2)) 1
[(2,1)]
Prelude Control.Monad.State&gt; runStateT ((get :: StateT Int IO Int) &gt;&gt;= \x -&gt; return (x * 2)) 1
(2,1)

Prelude Control.Monad.State&gt; runStateT ((fail "" :: StateT Int Maybe Int) &gt;&gt;= \x -&gt; return (x * 2)) 1
Nothing
Prelude Control.Monad.State&gt; runStateT ((fail "" :: StateT Int [] Int) &gt;&gt;= \x -&gt; return (x * 2)) 1
[]

Prelude Control.Monad.State&gt; runStateT ((get :: StateT Int Maybe Int) `mplus` return 2) 1
Just (1,1)
Prelude Control.Monad.State&gt; runStateT ((mzero :: StateT Int Maybe Int) `mplus` return 2) 1
Just (2,1)
Prelude Control.Monad.State&gt; runStateT ((mzero :: StateT Int Maybe Int) `mplus` mzero) 1
Nothing

Prelude Control.Monad.State&gt; runStateT ((get :: StateT Int [] Int) `mplus` return 2) 1
[(1,1),(2,1)]
Prelude Control.Monad.State&gt; runStateT ((mzero :: StateT Int [] Int) `mplus` return 2) 1
[(2,1)]
Prelude Control.Monad.State&gt; runStateT ((mzero :: StateT Int [] Int) `mplus` mzero) 1
[]
</pre>

<h4>●自分で StateT を作る</h4>
<p> それでは Haskell のお勉強ということで、自分で StateT を作ってみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : State モナドの定義

-- データ型の定義
newtype State s a = State {runState :: s -&gt; (a, s)} 

-- インスタンスの設定
instance Mmonad (State s) where
  return x = State $ \s -&gt; (x, s)
  (State f) &gt;&gt;= g = State $ \s -&gt; let (x, s1) = f s
                                  in runState (g x) s1

-- 状態を取得する
get :: State s s
get = State $ \s -&gt; (s, s)

-- 状態を更新する
put :: s -&gt; State s ()
put s = State $ \_ -&gt; ((), s)
</pre>
<pre class="list">
リスト : モナド変換子 StateT の定義

newtype StateT s m a = StateT {runStateT :: s -&gt; m (a, s)}

instance Monad m =&gt; Monad (StateT s m) where
  return x = StateT $ \s -&gt; return (x, s)
  m &gt;&gt;= k  = StateT $ \s -&gt; do (a, s') &lt;- runStateT m s
                               runStateT (k a) s'
  fail s   = StateT $ \_ -&gt; fail s

-- 状態を取得する
get :: Monad m =&gt; StateT s m s
get = StateT $ \s -&gt; return (s, s)

-- 状態を更新する
put :: Monad m =&gt; s -&gt; StateT s m ()
put s = StateT $ \_ -&gt; return ((), s)
</pre>

<p> State の return x は State $ \s -&gt; (x, s) でした。StateT は返り値をモナドに包めばよいので、StateT $ \s -&gt; return (x, s) となります。バインド演算子は runStateT m s でモナド m に s を渡して評価し、do 構文の &lt;- でモナドから値を取り出して変数 (a, s') にセットします。k a の返り値は StateT 型になるので、runStateT で関数を取り出して新しい状態 s' に適用します。fail は引数 s をモナド m の fail に渡すだけです。
</p>
<p> get, put は簡単です。get はラムダ式に渡された状態 s をタプルに格納してモナドに包んで返すだけです。put はラムダ式に渡された状態を無視して、引数 s を新しい状態としてタプルに格納してモナドに包んで返します。なお、プログラムを簡単にするため、get, put は関数として定義しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runStateT (return 1 :: StateT Int [] Int) 0
[(1,0)]
*Main&gt; runStateT (return 1 :: StateT Int Maybe Int) 0
Just (1,0)
*Main&gt; runStateT (return 1 :: StateT Int IO Int) 0
(1,0)
*Main&gt; runStateT (get :: StateT Int [] Int) 0
[(0,0)]
*Main&gt; runStateT (get :: StateT Int Maybe Int) 0
Just (0,0)
*Main&gt; runStateT (get :: StateT Int [] Int) 0
[(0,0)]
*Main&gt; runStateT (put 10 :: StateT Int [] ()) 0
[((),10)]
*Main&gt; runStateT (put 10 :: StateT Int Maybe ()) 0
Just ((),10)
*Main&gt; runStateT (put 10 :: StateT Int IO ()) 0
((),10)
*Main&gt; runStateT ((get :: StateT [Int] [] [Int]) &gt;&gt;= \a -&gt; put (10:a)) [1,2,3]
[((),[10,1,2,3])]
*Main&gt; runStateT ((get :: StateT [Int] Maybe [Int]) &gt;&gt;= \a -&gt; put (10:a)) [1,2,3]
Just ((),[10,1,2,3])
*Main&gt; runStateT ((get :: StateT [Int] IO [Int]) &gt;&gt;= \a -&gt; put (10:a)) [1,2,3]
((),[10,1,2,3])
</pre>
<h4>●StateT の Functor</h4>
<p> StateT も Functor を定義することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : StateT の Functor

instance (Monad m) =&gt; Functor (StateT s m) where
  fmap f x = StateT $ \s -&gt; do (a, s') &lt;- runStateT x s
                               return (f a, s')
</pre>
<p> runStateT でモナド x に引数 s を与えて、その返り値と新しい状態を変数 a と s' に受け取ります。あとは、変数 a に関数 f を適用して、その返り値と s' を return でモナドに包んで返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runStateT (fmap (*2) (return 1 :: StateT Int [] Int)) 0
[(2,0)]
*Main&gt; runStateT (fmap (*2) (return 1 :: StateT Int Maybe Int)) 0
Just (2,0)
*Main&gt; runStateT (fmap (*2) (return 1 :: StateT Int IO Int)) 0
(2,0)
</pre>
<h4>●StateT の lift 関数と MonadPlus</h4>
<p> lift 関数と MonadPlus の定義も簡単です。
</p>
<pre class="list">
リスト : StateT の lift 関数と MonadPlus

instance MonadTrans (StateT s) where
  lift m = StateT $ \s -&gt; do a &lt;- m
                             return (a, s)

instance (MonadIO m) =&gt; MonadIO (StateT s m) where
  liftIO = lift . liftIO

instance MonadPlus m =&gt; MonadPlus (StateT s m) where
  mzero       = StateT $ \_ -&gt; mzero
  x `mplus` y = StateT $ \s -&gt; runStateT x s `mplus` runStateT y s
</pre>
<p> lift はモナド m から値 a を取り出して、それをタプル (a, s) にまとめてモナドに包んで返します。StateT の MonadPlus は MonadPlus m の mzero, mplus を呼び出すだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; runStateT ((get :: StateT [Int] IO [Int]) &gt;&gt;= \a -&gt; lift(print a) &gt;&gt; put (10:a)) [1,2,3]
[1,2,3]
((),[10,1,2,3])
*Main&gt; runStateT ((get :: StateT [Int] IO [Int]) &gt;&gt;= \a -&gt; liftIO(print a) &gt;&gt; put (10:a)) [1,2,3]
[1,2,3]
((),[10,1,2,3])

*Main&gt; runStateT ((return 1 :: StateT Int Maybe Int) `mplus` (return 2)) 0
Just (1,0)
*Main&gt; runStateT ((mzero :: StateT Int Maybe Int) `mplus` (return 2)) 0
Just (2,0)
*Main&gt; runStateT ((mzero :: StateT Int Maybe Int) `mplus` mzero) 0
Nothing
*Main&gt; runStateT ((return 1 :: StateT Int [] Int) `mplus` (return 2)) 0
[(1,0),(2,0)]
*Main&gt; runStateT ((mzero :: StateT Int [] Int) `mplus` (return 2)) 0
[(2,0)]
*Main&gt; runStateT ((mzero :: StateT Int [] Int) `mplus` mzero) 0
[]
</pre>
<h4>●StateT の簡単な例題</h4>
<p> それでは簡単な例題として、StackT を使って簡単なスタックを作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : StateT を使ったスタック

type Stack a = [a]

type StateE s a = StateT s Maybe a

pop :: StateE (Stack Int) Int
pop = do (x:xs) &lt;- get 
         put xs
         return x

push :: Int -&gt; StateE (Stack Int) ()
push x = do xs &lt;- get
            put (x:xs)

stackTest :: StateE (Stack Int) ()
stackTest = do a &lt;- pop
               b &lt;- pop
               push (a + b)
</pre>
<p> スタックを pop するとき、空リストの場合は Nothing を返すようにします。最初に、StateT s Maybe a に別名 StateE s a を付けます。pop のデータ型は StateE (Stack Int) Int になります。次に、get でスタックを取り出して変数 (x : xs) にセットします。put で状態を xs に書き換えて、x を return で Just に包んで返します。スタックが空リストの場合、(x : xs) &lt;- get のパターンマッチングで失敗します。ここで fail が呼び出されて Nothing が返されます。push も簡単で、get でリストを取り出して、put でリストを (x : xs) に更新するだけです。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
*Main&gt; runStateT stackTest [1,2,3]
Just ((),[3,3])
*Main&gt; runStateT stackTest []
Nothing
</pre>
<p> 正常に動作していますね。
</p>
<h4>●Error クラスと MonadError クラス</h4>
<p> ここで Error クラスについてもう少し詳しく説明します。Error は失敗を表すクラスで、モジュール Control.Monad.Error.Class に定義されています。
</p>
<pre class="list">
リスト : Error の定義

class Error a where
  noMsg  :: a
  strMsg :: String -&gt; a
</pre>
<p> noMsg はエラー情報なし、strMsg は文字列を受け取り、それをエラーを表すデータ型に変換します。
</p>
<p> モジュール Control.Monad.Error に定義されている Either モナドの場合、Left に格納されるデータ型は Error のインスタンスでなければいけません。次のリストを見てください。
</p>
<pre class="list">
リスト ; Either モナドの定義

instance Error e =&gt; Monad (Either e) where
  return = Right
  Left l  &gt;&gt;= _ = Left l
  Right r &gt;&gt;= k = k r
  fail msg      = Left (strMsg msg)
</pre>
<p> この Either モナドを「エラーモナド」と呼びます。String は Error のインスタンスに設定されていて、noMsg は空文字列、strMsg は恒等関数 id になります。したがって、String の strMsg は引数の文字列をそのまま返すことになります。
</p>

<p> エラーモナドを使ってエラーを送出したい場合は throwError を使います。また、cathcError を使ってエラーを捕捉することもできます。throwError と catchError はモジュール Control.Monad.Error.Class にある MonadError クラスで定義されています。
</p>

<pre class="list">
リスト : MonadError の定義

class (Monad m) =&gt; MonadError e m | m -&gt; e where
  throwError :: e -&gt; m a
  catchError :: m a -&gt; (e -&gt; m a) -&gt; m a
</pre>
<p> M,Hiroi は "| m -&gt; e" の部分がよくわかりません。Haskell は難しいですね。まだまだ勉強が足りないようです。
</p>
<p> エラーモナドの場合、throwError と catchError は次のように定義されています。
</p>
<pre class="list">
リスト : throwError, catchError の定義

instance (Error e) =&gt; MonadError e (Either e) where
  throwError             = Left
  Left  l `catchError` h = h l
  Right r `catchError` _ = Right r
</pre>
<p> throwError は引数を Left に格納するだけ、catchError は、左辺が Left ならば右辺を実行し、左辺が Right ならばそのまま返すだけです。Maybe の MonadPlus と似たような動作になりますが、catchError で右辺を実行するとき、左辺のモナドから値を取り出して右辺の関数に渡していることに注意してください。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Prelude> :m Control.Monad.Error
Prelude Control.Monad.Error&gt; return 1 :: Either String Int
Right 1
Prelude Control.Monad.Error&gt; throwError noMsg :: Either String Int
Left ""
Prelude Control.Monad.Error&gt; throwError (strMsg "oops") :: Either String Int
Left "oops"
Prelude Control.Monad.Error&gt; (return 1 :: Either String Int) `catchError` \e -&gt; return 10
Right 1
Prelude Control.Monad.Error&gt; (throwError noMsg :: Either String Int) `catchError` \e -&gt; return 10
Right 10
Prelude Control.Monad.Error&gt; (throwError (strMsg "oops") :: Either String Int) `catchError` \e -&gt; throwError (strMsg e)
Left "oops"
</pre>
<p> catchError の定義を見ればおわかりのように、左辺と右辺の返り値は同じデータ型、つまり Either String Int でなければなりません。
</p>
<p> throwError と catchError はモナド変換子にも定義されています。ErrorT で試してみましょう。
</p>
<pre>
Prelude Control.Monad.Error&gt; runErrorT  (return 1 :: ErrorT String IO Int)
Right 1
Prelude Control.Monad.Error&gt; runErrorT (throwError noMsg :: ErrorT String IO Int)
Left ""
Prelude Control.Monad.Error&gt; runErrorT $ (return 1 :: ErrorT String IO Int) 
 `catchError` \e -&gt; do{liftIO(print e); return 0}
Right 1
Prelude Control.Monad.Error&gt; runErrorT $ (throwError noMsg :: ErrorT String IO Int)
 `catchError` \e -&gt; do{liftIO(print e); return 0}
""
Right 0
Prelude Control.Monad.Error&gt; runErrorT $ (throwError (strMsg "oops") :: ErrorT String IO Int)
 `catchError` \e -&gt; do{liftIO(print e); return 0}
"oops"
Right 0
Prelude Control.Monad.Error&gt; runErrorT $ (throwError (strMsg "oops") :: ErrorT String IO Int) 
`catchError` \e -&gt; do{liftIO(print e); throwError (strMsg e)}
"oops"
Left "oops"
</pre>
<p> このように、throwError と catchError を使うと、モナド変換子でもエラーを簡単に扱うことができます。
</p>

<p> 今回はここまでです。次回は StateT を使って電卓プログラムを書き直してみましょう。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell29.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell31.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>