<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj05.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj07.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>コレクションとシーケンス</h3>
<p> 今回はコレクション &lt;collection&gt; とシーケンス &lt;sequence&gt; について説明します。Gauche のオブジェクト指向システムは、ハッシュテーブル &lt;hash-table&gt;、リスト &lt;list&gt;、文字列 &lt;string&gt;、ベクタ &lt;vector&gt; などをコレクションとして統一的に扱うことができます。また、コレクションのサブクラスであるシーケンスを使うと、リスト、文字列、ベクタを同じメソッドで操作することもできます。まず最初に、既存のデータ型とクラスの関係を簡単に説明します。
</p>
<h4>●既存のデータ型とクラスの関係</h4>
<p> Gauche の場合、Gauche (Scheme) で定義されているおもなデータ型をクラスとして利用することができます。そして、それらのクラスには「クラス優先順位リスト」が設定されています。おもなクラスの優先順位リストを示します。
</p>
<pre class="fig">
 データ型を調べる述語        クラス優先順位リスト
------------------------------------------------------------------------------------
 boolean?    (真偽値)        (&lt;boolean&gt; &lt;top&gt;)
 char?       (文字)          (&lt;char&gt; &lt;top&gt;)
 complex?    (複素数)        (&lt;complex&gt; &lt;number&gt; &lt;top&gt;)
 hash-table? (ハッシュ表)    (&lt;hash-table&gt; &lt;dictionary&gt; &lt;collection&gt; &lt;top&gt;)
 integer?    (整数値)        (&lt;integer&gt; &lt;rational&gt; &lt;real&gt; &lt;complex&gt; &lt;number&gt; &lt;top&gt;)
 list?       (リスト)        (&lt;list&gt; &lt;sequence&gt; &lt;collection&gt; &lt;top&gt;)
 null?       (空リスト)      (&lt;null&gt; &lt;list&gt; &lt;sequence&gt; &lt;collection&gt; &lt;top&gt;)
 number?     (数)            (&lt;number&gt; &lt;top&gt;)
 pair?       (コンスセル)    (&lt;pair&gt; &lt;list&gt; &lt;sequence&gt; &lt;collection&gt; &lt;top&gt;)
 procedure?  (関数)          (&lt;procedure&gt; &lt;top&gt;)
 port?       (入出力)        (&lt;port&gt; &lt;top&gt;)
 rational?   (有理数)        (&lt;rational&gt; &lt;real&gt; &lt;complex&gt; &lt;number&gt; &lt;top&gt;)
 real?       (浮動小数点数)  (&lt;real&gt; &lt;complex&gt; &lt;number&gt; &lt;top&gt;)
 string?     (文字列)        (&lt;string&gt; &lt;sequence&gt; &lt;collection&gt; &lt;top&gt;)
 symbol?     (シンボル)      (&lt;symbol&gt; &lt;top&gt;)
 vector?     (配列)          (&lt;vector&gt; &lt;sequence&gt; &lt;collection&gt; &lt;top&gt;)
</pre>
<p> Gauche の場合、すべてのクラスのスーパークラスとして &lt;top&gt; が設定されています。また、define-class でスーパークラスの指定がない場合、暗黙のうちに &lt;object&gt; がスーパークラスとして設定されますが、&lt;object&gt; のスーパークラスも &lt;top&gt; になります。なお、define-method で引数特定子を省略することができましたが、これは &lt;top&gt; を指定していることと同じになります。
</p>

<p> これらのクラスは「組み込みクラス (builtin class) 」と呼ばれます。組み込みクラスは make でインスタンスを生成することはできません。また、define-class で組み込みクラスのサブクラスを定義することもできません。ただし、define-method の引数特定子として指定することができます。
</p>
<p> なお、&lt;collection&gt; や &lt;sequence&gt; は「抽象クラス」と呼ばれていて、make でインスタンスを生成することはできませんが、それらを継承 (Mix-in) して独自のコレクションクラスやシーケンスクラスを作ることができます。
</p>

<h4>●コレクションのメソッド</h4>
<p> Gauche のクラス &lt;hash-table&gt;, &lt;list&gt;, &lt;string&gt;, &lt;vector&gt; はクラス &lt;collection&gt; を継承しています。gauche.coolection をロードすると、これらのデータをコレクションというデータ型として統一的に操作することができます。
</p>
<p> 高階関数 fold, map, for-each, filter, remove はコレクションを扱えるように拡張されます。map, filter, remove の返り値はリストになります。
</p>
<pre class="item">
fold func init coll1 coll2 ...
map func coll1 coll2 ...
for-each func coll1 coll2 ...
filter func coll
remove func coll
</pre>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (use gauche.collection)
#&lt;undef&gt;
gosh&gt; (fold (lambda (x y) (+ x y)) 0 '(1 2 3 4 5))
15
gosh&gt; (fold (lambda (x y) (+ x y)) 0 #(1 2 3 4 5))
15
gosh&gt; (map (lambda (x) (* x x)) '(1 2 3 4 5))
(1 4 9 16 25)
gosh&gt; (map (lambda (x) (* x x)) #(1 2 3 4 5))
(1 4 9 16 25)
gosh&gt; (for-each (lambda (x) (print x)) '(a b c d e))
a
b
c
d
e
#&lt;undef&gt;
gosh&gt; (for-each (lambda (x) (print x)) "abcde")
a
b
c
d
e
#t
gosh&gt; (filter even? '(1 2 3 4 5))
(2 4)
gosh&gt; (filter even? #(1 2 3 4 5))
(2 4)
gosh&gt; (remove even? '(1 2 3 4 5))
(1 3 5)
gosh&gt; (remove even? #(1 2 3 4 5))
(1 3 5)
</pre>
<p> fold, map, for-each に複数のコレクションを渡す場合、データ型が異なっていてもかまいません。
</p>
<pre>
gosh&gt; (map (lambda (x y) (+ x y)) '(1 2 3 4 5) #(10 20 30 40 50))
(11 22 33 44 55)
gosh&gt; (fold (lambda (x y a) (cons (list x y) a)) '() '(1 2 3) #(4 5 6))
((3 6) (2 5) (1 4))
gosh&gt; (for-each (lambda (x y) (format #t "~S ~S~%" x y)) '(1 2 3) #(4 5 6))
1 4
2 5
3 6
#t
</pre>
<p> 返り値のデータ型を指定したい場合は、map-to, filter-to, remove-to を使います。
</p>
<pre class="item">
map-to class func coll1 coll2 ...
filter-to class func coll
remove-to class func coll
</pre>
<pre>
gosh&gt; (map-to &lt;vector&gt; (lambda (x) (* x x)) '(1 2 3 4 5))
#(1 4 9 16 25)
gosh&gt; (map-to &lt;list&gt; (lambda (x) (* x x)) #(1 2 3 4 5))
(1 4 9 16 25)
gosh&gt; (filter-to &lt;list&gt; even? #(1 2 3 4 5))
(2 4)
gosh&gt; (remove-to &lt;vector&gt; even? '(1 2 3 4 5))
#(1 3 5)
</pre>
<p> メソッド find は述語 pred が真となる collection の要素を返します。
</p>
<pre class="item">
find pred collection
</pre>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (find even? '(1 3 5 8 9))
8
gosh&gt; (find even? #(1 3 5 8 9))
8
</pre>
<p> このほかにも便利なメソッドが用意されています。詳細は Gauche のユーザリファレンス <a href="http://practical-scheme.net/gauche/man/gauche-refj_75.html#SEC223">gauche.collection - コレクションフレームワーク</a> をお読みください。
</p>
<h4>●シーケンスのメソッド</h4>
<p> Gauche のクラス &lt;list&gt;, &lt;string&gt;, &lt;vector&gt; はクラス &lt;sequence&gt; も継承しています。gauche.sequence をロードすると、これらのデータをシーケンスというデータ型として統一的に操作することができます。
</p>
<p> シーケンスの要素はメソッド ref でアクセスすることができます。
</p>
<pre class="item">
ref sequence index
</pre>
<p> 添字 index は 0 から数えます。ref は汎変数として使うことができます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (use gauche.sequence)
#&lt;undef&gt;
gosh&gt; (define a '(1 2 3 4 5))
a
gosh&gt; (define b #(1 2 3 4 5))
b
gosh&gt; (ref a 2)
3
gosh&gt; (ref b 3)
4
gosh&gt; (set! (ref a 1) 20)
#&lt;undef&gt;
gosh&gt; a
(1 20 3 4 5)
gosh&gt; (set! (ref b 0) 10)
#&lt;undef&gt;
gosh&gt; b
#(10 2 3 4 5)
</pre>

<p> クラス &lt;sequence&gt; には添字を引数に渡す高階関数 (メソッド) が用意されています。
</p>
<pre class="item">
fold-with-index func init seq1 seq2 ...
map-with-index func seq1 seq2 ...
map-to-with-index class func seq1 seq2 ...
for-each-with-index func seq1 seq2 ...
</pre>
<p> 関数 func の第 1 引数に添字が渡されます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (fold-with-index (lambda (n x a) (cons (cons n x) a)) '() '(a b c d e))
((4 . e) (3 . d) (2 . c) (1 . b) (0 . a))
gosh&gt; (map-with-index (lambda (n x) (cons n x)) '(a b c d e))
((0 . a) (1 . b) (2 . c) (3 . d) (4 . e))
gosh&gt; (map-to-with-index &lt;vector&gt; (lambda (n x) (cons n x)) '(a b c d e))
#((0 . a) (1 . b) (2 . c) (3 . d) (4 . e))
gosh&gt; (for-each-with-index (lambda (n x) (format #t "~D:~S~%" n x)) '(a b c d e))
0:a
1:b
2:c
3:d
4:e
#t
</pre>
<p> シーケンスの末尾から畳み込みを行う fold-right もあります。
</p>
<pre class="item">
fold-right func init seq1 seq2 ...
</pre>
<p> func の第 1 引数にシーケンスの要素、第 2 引数に累積変数が渡されます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (fold-right list '() '(a b c d e))
(a (b (c (d (e ())))))
gosh&gt; (fold-right list '() #(a b c d e))
(a (b (c (d (e ())))))
</pre>
<p> 述語 pred が真となる要素の位置が知りたい場合は find-with-index を使うと便利です。
</p>
<pre class="item">
find-with-index pred seq1 seq2 ...
</pre>
<p> find-with-index は見つけた要素の位置とその値の 2 つを返します。見つからない場合は #f を 2 つ返します。簡単な例を示します。
</p>
<pre>
gosh&gt; (find-with-index even? '(1 3 5 7 8 9))
4
8
gosh&gt; (find-with-index odd? '(1 3 5 7 8 9))
0
1
gosh&gt; (find-with-index even? '(1 3 5 7 9))
#f
#f
</pre>
<p> Gauche はメソッド subseq でシーケンスのスライス操作を行うことができます。
</p>
<pre class="item">
subseq seq [start [end]]
</pre>
<p> subseq はシーケンス seq の部分列を取り出します。subseq の start と end はコピーする範囲を指定します。end を省略すると列の最後尾が範囲となります。start 位置の要素はコピー範囲に含まれますが、end 位置の要素は範囲外になることに注意してください。次の図を見てください。
</p>
<pre class="fig">
           範  囲
       │←───→│
       │          │
 （ａ  ｂ  ｃ  ｄ  ｅ  ｆ  ｇ） 
       ↑              ↑
       │              │
      start (1)        end (5)

   (subseq '(a b c d e f) 1 5)
   =&gt; (b c d e)

    図 1 : subseq の範囲指定
</pre>
<p> 1 番目の要素 b は範囲内ですが 5 番目の要素 f は範囲外なので、コピーされたリストに f は含まれません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (subseq '(a b c d e) 1 4)
(b c d)
gosh&gt; (subseq '(a b c d e) 1)
(b c d e)
gosh&gt; (subseq '(a b c d e))
(a b c d e)
gosh&gt; (subseq #(a b c d e) 1 3)
#(b c)
gosh&gt; (subseq #(a b c d e) 1 1)
#()
gosh&gt; (subseq "abcde" 1 4)
"bcd"
</pre>
<p> set! と subseq を組み合わせて、シーケンスを破壊的に修正することができます。
</p>
<pre class="item">
(set! (subseq seq start end) value-seq)
(set! (subseq seq start) value-seq)
</pre>
<p> value-seq はシーケンスの型であれば何でもかまいません。seq の start 番目から end - 1 番目の値を value-seq の値で書き換えます。value-seq の要素数が end - start よりも少ない場合はエラーになります。end が省略された場合は、start 番目から value-seq の要素数だけ書き換えられます。
</p>
<p> 簡単な例を示します。
</p>
<pre>
gosh&gt; (define a '(1 2 3 4 5))
a
gosh&gt; (set! (subseq a 1 4) '(a b c))
#t
gosh&gt; a
(1 a b c 5)
gosh&gt; (set! (subseq a 0) '(A B))
#t
gosh&gt; a
(A B b c 5)
</pre>
<p> このほかにも便利なメソッドが用意されています。詳細は Gauche のユーザリファレンス <a href="http://practical-scheme.net/gauche/man/gauche-refj_91.html#SEC261">gauche.sequence - シーケンスフレームワーク</a> をお読みください。
</p>

<h4>●コレクションクラスの実装</h4>
<p> 次は、コレクションクラスを作成する方法を説明します。基本的にはユーザが定義したクラスに &lt;collection&gt; を Mix-in するだけなので簡単です。このとき、基本となるメソッドを 2 つ実装します。ひとつが前回説明した call-with-iterator です。これで filter, find, fold, map, remove などの基本的なメソッドが動作します。もうひとつが call-with-builder です。このメソッドは map-to, remove-to, filter-to などでコレクションを &lt;dlist&gt; に変換するときに呼び出されます。
</p>

<p> call-with-builder を実装するとき、&lt;dlist&gt; のメタクラスが必要になります。ここで、メタクラスについて簡単に説明します。
</p>

<h4>●メタクラスとは？</h4>
<p> 今までクラスはオブジェクトの「雛形」で、それをもとにして生成される実体がインスタンスと説明しました。この関係を拡張して、「クラスを生み出すためのクラス」というものを考えることができます。これを「メタクラス (meta class) 」といいます。この場合、クラスはメタクラスのインスタンス (オブジェクト) になります。これを「クラスオブジェクト」といいます。
</p>

<p> メタクラスを持つオブジェクト指向言語の場合、クラスオブジェクトの動作は、それが属するメタクラスによって規定されています。つまり、メタクラスで定義されているスロットやメソッドにより、インスタンスを生成するといったオブジェクト指向の標準的な動作が決められているわけです。オブジェクト指向言語によっては、この標準的な動作をカスタマイズできるような機能を持っているものもあります。
</p>

<p> この仕組みを「メタオブジェクトプロトコル (Meta Object Protocol : MOP) 」といいます。CLOS の MOP は Common Lisp の規格 (ANSI Common Lisp) に含まれていませんが、多くの処理系でサポートされているようです。もちろん、Gauche も MOP をサポートしています。
</p>

<p> コレクションクラスの実装では MOP の複雑な機能を使うことはありません。メタクラスを使う目的は、クラスオブジェクトをメソッドの引数に渡すとき、データ型によってメソッドの選択が行われるようにするためです。簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト 1 : クラスオブジェクトによる処理の振り分け (1)

(define-class &lt;foo&gt; () ())
(define-class &lt;bar&gt; () ())

(define-method baz ((x &lt;class&gt;))
  (cond ((eq? x &lt;foo&gt;) (print "foo!"))
        ((eq? x &lt;bar&gt;) (print "bar!"))
        (else (print "baz --- oops!"))))
</pre>
<p> 実行結果は次のようになります。
</p>
<pre>
gosh&gt; (class-of &lt;foo&gt;)
#&lt;class &lt;class&gt;&gt;
gosh&gt; (class-of &lt;bar&gt;)
#&lt;class &lt;class&gt;&gt;
gosh&gt; (baz &lt;foo&gt;)
foo!
#&lt;undef&gt;
gosh&gt; (baz &lt;bar&gt;)
bar!
#&lt;undef&gt;
gosh&gt; (define-class &lt;foo1&gt; () ())
&lt;foo1&gt;
gosh&gt; (baz &lt;foo1&gt;)
baz --- oops!
#&lt;undef&gt;
</pre>
<p> define-class で定義されたクラスのメタクラスは &lt;class&gt; になります。したがって、メソッド baz の引数にクラスオブジェクトを渡す場合、引数特定子は &lt;class&gt; になりますが、クラスオブジェクト &lt;foo&gt; と &lt;bar&gt; を区別することができずに、同じメソッドが選択されることになります。クラスオブジェクトによって処理を振り分けたい場合、baz の中で引数 x の型をチェックすることになります。
</p>
<p> この場合、メタクラスを定義すると簡単です。
</p>
<pre class="list">
リスト 2 : クラスオブジェクトによる処理の振り分け (2)

(define-class &lt;foo-meta&gt; (&lt;class&gt;) ())
(define-class &lt;bar-meta&gt; (&lt;class&gt;) ())

(define-class &lt;foo&gt; () () :metaclass &lt;foo-meta&gt;)
(define-class &lt;bar&gt; () () :metaclass &lt;bar-meta&gt;)

(define-method baz ((x &lt;foo-meta&gt;)) (print "foo!"))
(define-method baz ((x &lt;bar-meta&gt;)) (print "bar!"))
(define-method baz ((x &lt;class&gt;)) (print "baz --- oops!"))
</pre>
<p> メタクラスは &lt;class&gt; のサブクラスとして定義します。そして、define-class でクラスを定義するとき、オプション ;metaclass でメタクラスを指定します。&lt;foo&gt; の :metaclass には &lt;foo-meta&gt; が指定されているので、&lt;foo&gt; のメタクラスは &lt;foo-meta&gt; になります。同様に、&lt;bar&gt; のメタクラスに &lt;bar-meta&gt; を指定します。これでメソッド baz の引数特定子に &lt;foo-meta&gt; と &lt;bar-meta&gt; を指定して、クラスオブジェクトの型によって処理を振り分けることができます。
</p>
<p> 実行例を示します。
</p>
<pre>
gosh&gt; (class-of &lt;foo&gt;)
#&lt;class &lt;foo-meta&gt;&gt;
gosh&gt; (class-of &lt;bar&gt;)
#&lt;class &lt;bar-meta&gt;&gt;
gosh&gt; (baz &lt;foo&gt;)
foo!
#&lt;undef&gt;
gosh&gt; (baz &lt;bar&gt;)
bar!
#&lt;undef&gt;
gosh&gt; (define-class &lt;foo1&gt; () ())
&lt;foo1&gt;
gosh&gt; (baz &lt;foo1&gt;)
baz --- oops!
#&lt;undef&gt;
</pre>
<p> class-of で &lt;foo&gt; と &lt;bar&gt; のメタクラスを確かめると、&lt;foo-meta&gt; と &lt;bar-meta&gt; になっています。あとはメソッド baz にクラスオブジェクトを渡すと、その型によって適切なメソッドが実行されます。Gauche の場合、コレクションクラスに属するクラスにはメタクラスが定義されています。
</p>

<h4>●クラスの定義</h4>
<p> それでは双方向リストクラス &lt;dlist&gt; に &lt;collection&gt; を Mix-in してみましょう。最初に必要なクラスを定義します。
</p>
<pre class="list">
リスト 3 : 双方向リストクラスの定義

(use gauche.collection)

; メタクラスの定義
(define-class &lt;dlist-meta&gt; (&lt;class&gt;) ())

; 双方向リストの定義
(define-class &lt;dlist&gt; (&lt;collection&gt;)
  ((top :accessor dlist-top :init-form (make-empty)))
  :metaclass &lt;dlist-meta&gt;)
</pre>
<p> call-with-builder の動作に必要なメタクラス &lt;dlist-meta&gt; を定義します。そして、define-class で &lt;dlist&gt; を定義するとき、クラス &lt;collection&gt; を継承してオプション :metaclass で &lt;dlist-meta&gt; を指定します。これで &lt;dlist&gt; のメタクラスが &lt;dlist-meta&gt; に設定されます。
</p>

<h4>●メソッドの定義</h4>
<p> 次はメソッドを定義します。必要なメソッドは call-with-iterator と call-with-builder の 2 つだけです。次のリストを見てください。
</p>
<pre class="list">
リスト 4 : メソッドの定義

; イテレータ
(define-method call-with-iterator ((coll &lt;dlist&gt;) proc . opts)
  (let ((cp (cell-nth coll (get-keyword :start opts 0) cell-next)))
    (proc
      (lambda () (eq? cp (dlist-top coll)))
      (lambda ()
        (if (eq? cp (dlist-top coll))
            #f
          (begin0 (cell-item cp)
                  (set! cp (cell-next cp))))))))

; ビルダー
(define-method call-with-builder ((class &lt;dlist-meta&gt;) proc . opts)
  (let ((dlist (make &lt;dlist&gt;)))
    (proc (lambda (val) (dlist-insert! dlist -1 val))
          (lambda () dlist))))
</pre>
<p> call-with-iterator は前回のプログラムとほぼ同じです。キーワード引数 :start は &lt;sequence&gt; を Mix-in するときに必要になります。なお、&lt;collection&gt; と &lt;sequence&gt; はキーワード引数 :from-end に対応していません。もしも、:from-end を使いたいメソッドがある場合は、そのメソッドをオーバーライドしてください。
</p>

<p> call-with-builder は関数 proc に 2 つの関数を渡して呼び出します。ひとつはコレクションに要素を追加する関数、もうひとつは生成したコレクションをクロージャから取り出して返す関数です。&lt;dlist&gt; のインスタンスを生成して変数 dlist にセットします。最初の関数は dlist-insert! で最後尾に値 val を追加します。次の関数は変数 dlist を返すだけです。
</p>
<h4>●コレクションの実行例</h4>
<p> それでは、簡単な実行例を示しましょう。
</p>
<pre>
gosh&gt; (use gauche.collection)
#&lt;undef&gt;
gosh&gt; (define a (coerce-to &lt;dlist&gt; '(1 2 3 4 5 6 7 8)))
a
gosh&gt; a
#<&lt;dlist&gt; 0pd6a640>
gosh&gt; (coerce-to &lt;vector&gt; a)
#(1 2 3 4 5 6 7 8)
gosh&gt; (size-of a)
8
gosh&gt; (find even? a)
2
gosh&gt; (filter even? a)
(2 4 6 8)
gosh&gt; (remove even? a)
(1 3 5 7)
gosh&gt; (map (lambda (x) (* x x)) a)
(1 4 9 16 25 36 49 64)
gosh&gt; (map (lambda (x y) (* x y)) a '(10 20 30 40 50 60 70 80))
(10 40 90 160 250 360 490 640)
gosh&gt; (fold (lambda (x y) (+ x y)) 0 a)
36
gosh&gt; (for-each (lambda (x) (format #t "~D " x)) a)
1 2 3 4 5 6 7 8 #t
gosh&gt; (map-to &lt;vector&gt; (lambda (x) (* x x)) a)
#(1 4 9 16 25 36 49 64)
gosh&gt; (define b (map-to &lt;dlist&gt; (lambda (x) (* x x)) a))
b
gosh&gt; (for-each (lambda (x) (format #t "~D " x)) b)
1 4 9 16 25 36 49 64 #t
gosh&gt; (partition even? a)
(2 4 6 8)
(1 3 5 7)
gosh&gt; (partition-to &lt;vector&gt; even? a)
#(2 4 6 8)
#(1 3 5 7)
</pre>
<p> このほかにもコレクションクラスのメソッドがあるので、興味のある方はいろいろ試してみてください。
</p>
<h4>●シーケンスクラスの実装</h4>
<p> コレクションクラスの実装が完成すれば、シーケンスクラスは簡単に実装することができます。次のリストを見てください。
</p>
<pre class="list">
リスト 5 : シーケンスクラスを Mix-in する場合

; 双方向リストの定義
(define-class &lt;dlist&gt; (&lt;sequence&gt;)
  ((top :accessor dlist-top :init-form (make-empty)))
  :metaclass &lt;dlist-meta&gt;)

;;; &lt;sequence&gt; 用メソッド
(define-method referencer ((dlist &lt;dlist&gt;)) dlist-ref)
(define-method modifier ((dlist &lt;dlist&gt;)) dlist-set!)
</pre>
<p> &lt;dlist&gt; の定義で &lt;collection&gt; ではなく &lt;sequence&gt; を継承するように変更します。&lt;sequence&gt; は &lt;collection&gt; のサブクラスなので、&lt;sequence&gt; を継承すればスーパークラス &lt;collection&gt; のメソッドも利用することができます。あとは、メソッド referencer と modifier を定義します。
</p>
<pre class="item">
(referencer) sequence n
(modifier) sequence n val
</pre>
<p> referencer は sequence の n 番目の要素を参照する関数 (メソッド) を返し、modifier は sequence の n 番目の要素の値を val に書き換える関数 (メソッド) を返します。&lt;dlist&gt; の場合、referencer は dlist-ref を、modifier は dlist-set! を返すように定義するだけです。これで &lt;sequence&gt; のメソッドを利用できるようになります。
</p>
<h4>●シーケンスの実行例</h4>
<p> 簡単な実行例を示します。
</p>
<pre>
gosh&gt; (define a (coerce-to &lt;dlist&gt; '(1 2 3 4 5 6 7 8)))
a
gosh&gt; (dotimes (x (size-of a)) (format #t "~D " (ref a x)))
1 2 3 4 5 6 7 8 #t
gosh&gt; (dotimes (x (size-of a)) (set! (ref a x) (+ x 10)))
#t
gosh&gt; (dotimes (x (size-of a)) (format #t "~D " (ref a x)))
10 11 12 13 14 15 16 17 #t
gosh&gt; (fold-with-index (lambda (n x a) (cons (cons n x) a)) '() a)
((7 . 17) (6 . 16) (5 . 15) (4 . 14) (3 . 13) (2 . 12) (1 . 11) (0 . 10))
gosh&gt; (map-with-index (lambda (n x) (cons n x)) a)
((0 . 10) (1 . 11) (2 . 12) (3 . 13) (4 . 14) (5 . 15) (6 . 16) (7 . 17))
gosh&gt; (define b (map-to-with-index &lt;dlist&gt; (lambda (n x) (cons n x)) a))
b
gosh&gt; (for-each-with-index (lambda (n x) (format #t "~D:~S~%" n x)) b)
0:(0 . 10)
1:(1 . 11)
2:(2 . 12)
3:(3 . 13)
4:(4 . 14)
5:(5 . 15)
6:(6 . 16)
7:(7 . 17)
#t
gosh&gt; (fold-right list '() a)
(10 (11 (12 (13 (14 (15 (16 (17 ()))))))))
gosh&gt; (find-with-index even? a)
0
10
gosh&gt; (find-with-index odd? a)
1
11
gosh&gt; (define c (subseq a 1 7))
c
gosh&gt; (coerce-to &lt;list&gt; c)
(11 12 13 14 15 16)
gosh&gt; (set! (subseq c 1 4) '(a b c))
#t
gosh&gt; (coerce-to &lt;list&gt; c)
(11 a b c 15 16)
</pre>
<p> このほかにもシーケンスクラスのメソッドがあるので、興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; dlist2.scm : 双方向リスト (シーケンスクラスを継承)
;
;              Copyright (C) 2010 Makoto Hiroi
;
(use gauche.sequence)

; メタクラスの定義
(define-class &lt;dlist-meta&gt; (&lt;class&gt;) ())

; セルの定義
(define-class &lt;cell&gt; ()
  ((item :accessor cell-item :init-value #f :init-keyword :item)
   (prev :accessor cell-prev :init-value #f :init-keyword :prev)
   (next :accessor cell-next :init-value #f :init-keyword :next)))

; 空リストを作る
(define (make-empty)
  (let ((cp (make &lt;cell&gt;)))
    (set! (cell-prev cp) cp)
    (set! (cell-next cp) cp)
    cp))

; 双方向リストの定義
(define-class &lt;dlist&gt; (&lt;sequence&gt;)
  ((top :accessor dlist-top :init-form (make-empty)))
  :metaclass &lt;dlist-meta&gt;)

; n 番目のセルを返す (作業用関数)
(define (cell-nth d n next)
  (let loop ((i -1) (cp (dlist-top d)))
    (cond ((and (&lt;= 0 i) (eq? (dlist-top d) cp))
           (error "cell-nth --- oops!"))
          ((= n i) cp)
          (else
           (loop (+ i 1) (next cp))))))

; 参照
(define-method dlist-ref ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (cell-item
    (if (negative? n)
        (cell-nth d (abs (+ n 1)) cell-prev)       
      (cell-nth d n cell-next))))

; 書き換え
(define-method dlist-set! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (set! (cell-item (if (negative? n)
                       (cell-nth d (abs (+ n 1)) cell-prev)
                     (cell-nth d n cell-next)))
        value))

; 挿入
(define-method dlist-insert! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (define (cell-insert! n next prev)
    (let* ((p (cell-nth d (- n 1) next))
           (q (next p))
           (cp (make &lt;cell&gt; :item value)))
      (set! (next cp) q)
      (set! (prev cp) p)
      (set! (prev q) cp)
      (set! (next p) cp)))
  ;
  (if (negative? n)
      (cell-insert! (abs (+ n 1)) cell-prev cell-next)
    (cell-insert! n cell-next cell-prev)))

; 削除
(define-method dlist-delete! ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (define (cell-delete! n next prev)
    (let* ((cp (cell-nth d n next))
           (p (prev cp))
           (q (next cp)))
      (set! (next p) q)
      (set! (prev q) p)
      (cell-item cp)))
  ;
  (if (negative? n)
      (cell-delete! (abs (+ n 1)) cell-prev cell-next)
    (cell-delete! n cell-next cell-prev)))

; 畳み込み
(define-method dlist-fold ((d &lt;dlist&gt;) func init . args)
  (let ((next (if (get-keyword :from-end args #f) cell-prev cell-next)))
    (let loop ((cp (next (dlist-top d))) (a init))
      (if (eq? cp (dlist-top d))
          a
        (loop (next cp)
              (if (eq? next cell-prev)
                  (func (cell-item cp) a)
                (func a (cell-item cp))))))))

; サイズ
(define-method dlist-length ((d &lt;dlist&gt;))
  (dlist-fold d (lambda (x y) (+ x 1)) 0))

; クリア
(define-method dlist-clear ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (set! (cell-next cp) cp)
    (set! (cell-prev cp) cp)))

; 空リストか？
(define-method dlist-empty? ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (eq? cp (cell-next cp))))

; 変換
(define-method list-&gt;dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;dlist&gt;)))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))

;
(define-method dlist-&gt;list ((d &lt;dlist&gt;))
  (dlist-fold d
              (lambda (x y) (cons x y))
              '()
              :from-end #t))

; 巡回
(define-method dlist-for-each ((d &lt;dlist&gt;) func . opts)
  (if (get-keyword :from-end opts #f)
      (dlist-fold d (lambda (x y) (func x)) #f :from-end #t)
    (dlist-fold d (lambda (x y) (func y)) #f)))


;;; &lt;collection&gt; 用メソッド

; イテレータ
(define-method call-with-iterator ((coll &lt;dlist&gt;) proc . opts)
  (let ((cp (cell-nth coll (get-keyword :start opts 0) cell-next)))
    (proc
      (lambda () (eq? cp (dlist-top coll)))
      (lambda ()
        (if (eq? cp (dlist-top coll))
            #f
          (begin0 (cell-item cp)
                  (set! cp (cell-next cp))))))))

; ビルダー
(define-method call-with-builder ((class &lt;dlist-meta&gt;) proc . opts)
  (let ((dlist (make &lt;dlist&gt;)))
    (proc (lambda (val) (dlist-insert! dlist -1 val))
          (lambda () dlist))))

;;; &lt;sequence&gt; 用メソッド
(define-method referencer ((dlist &lt;dlist&gt;)) dlist-ref)
(define-method modifier ((dlist &lt;dlist&gt;)) dlist-set!)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj05.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj07.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>