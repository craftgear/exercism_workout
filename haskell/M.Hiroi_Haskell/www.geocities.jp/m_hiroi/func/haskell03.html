<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881788</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell02.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>パターンマッチングとガード</h3>
<h4>●定数と変数はパターンになる</h4>
<p> 関数を定義する場合、引数に「パターン (pattern)」を使うことができます。Haskell は ML 系統の言語なので、そのパターンマッチングは論理型言語 Prolog のそれとよく似ています。たとえば、パターンを使って階乗を求める関数 fact を定義すると次のようになります。
</p>
<pre class="list">
リスト : 階乗

fact :: Integer -&gt; Integer
fact n =
  if n == 0 then 1
  else n * fact (n - 1)

-- パターンを使う場合
fact' :: Integer -&gt; Integer
fact' 0 = 1
fact' n = n * fact' (n - 1)
</pre>

<p> Haskell で関数を定義する場合、同じ関数名で複数の定義 (節) を記述することができます。このとき、各節で記述した仮引数がパターンになります。Haskell は実引数とパターンを照合し、マッチングする節を選択して実行します。当然ですが、各節の返り値は同じデータ型でなければなりません。
</p>
<p> パターンが定数の場合、同じ値の実引数とマッチングします。fact' の最初の定義はパターンが 0 なので、実引数が 0 の場合にマッチングします。これは if n == 0 then 1 と同じ処理です。パターンが変数の場合、どんな値とでもマッチングします。したがって、n が 0 以外の場合は 2 番目の節と一致します。ここで再帰呼び出しが行われます。このように、if を使わなくてもパターンマッチングでプログラムを作ることができます。
</p>

<p> パターンを使うときは、関数を定義する順番に気をつけてください。fact' の場合、最初に fact' n を定義すると、実引数が 0 の場合でもマッチングするので、fact' 0 の節が選択されなくなります。引数を特定するパターンから定義するように注意してください。
</p>

<p> もうひとつ、簡単な例題としてフィボナッチ関数 fibo をパターンを使って書き直してみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : フィボナッチ関数

fibo :: Integer -&gt; Integer
fibo n =
  if n == 0 || n == 1 then 1
  else fibo (n - 1) + fibo (n - 2)

-- パターンを使う場合
fibo' :: Integer -&gt; Integer
fibo' 0 = 1
fibo' 1 = 1
fibo' n = fibo' (n - 1) + fibo' (n - 2)
</pre>
<p> fibo' の最初の節は実引数が 0 のとき、2 番目の節は 1 のときに選択されます。それ以外の場合は最後の節が選択され、fibo を 2 回再帰呼び出しします。
</p>

<h4>●ガード (guard)</h4>
<p> 実引数を定数ではなく範囲で場合分けしたいときは「ガード (guard) 」を使うと便利です。ガードを使って fact を書き直すと次のようになります。
</p>

<pre class="list">
リスト : 階乗

fact :: Integer -&gt; Integer
fact n =
  if n == 0 then 1
  else n * fact (n - 1)

-- ガードを使う場合
fact' :: Integer -&gt; Integer
fact' n 
  | n &lt; 0     = error "fact' out of range"
  | n == 0    = 1
  | otherwise = n * fact' (n - 1)
</pre>
<p> ガードは引数の後ろに複数の節を縦線 ( | )で分けて記述します。縦線の後ろには条件式と記号 = が続き、その後ろに節の本体 (式) を定義します。ガードは各節の条件式を順番に評価し、真を返す節を選択します。そして、記号 = の右辺にある式を評価し、その結果が関数の返り値となります。当然ですが、各節の返り値は同じデータ型でなければなりません。
</p>
<p> 関数 fact' の最初の節は n が負の場合です。この場合、引数は範囲外の値なので関数 error でエラーを送出します。ここで詳しい説明はしませんが、error は引数の文字列を画面 (標準エラー出力) に表示して、プログラムの実行を中断する関数です。ghci の場合、プログラムの実行を中断してトップレベルに戻ります。
</p>
<p> 2 番目の節は n が 0 のときに選択され、返り値は 1 となります。3 番目の節の otherwise は True と同じ意味で、最後には必ずこの節が選択されます。ここで fact' が再帰呼び出しされます。
</p>

<p> もうひとつ簡単な例題として、関数 fibo をガードを使って書き直してみましょう。
</p>
<pre class="list">
リスト : フィボナッチ関数

fibo :: Integer -&gt; Integer
fibo n =
  if n == 0 || n == 1 then 1
  else fibo (n - 1) + fibo (n - 2)

-- ガードを使う場合
fibo' :: Integer -&gt; Integer
fibo' n 
  | n &lt; 0     = error "fibo' out of range"
  | n &lt; 2     = 1
  | otherwise = fibo' (n - 1) + fibo' (n - 2)
</pre>
<p> 関数 fibo' の最初の節は、n が負のときに選択されます。引数が範囲外の値なのでエラーを送出します。n が 0 または 1 の場合は 2 番目の節が選択され、返り値は 1 になります。それ以外の場合は最後の節が選択されて、fibo' を 2 回再帰呼び出しします。
</p>

<p> パターンとガードは併用することができます。たとえば、関数 fact と fibo は次のように記述することができます。
</p>
<pre class="list">
リスト : パターンとガードの併用

-- 階乗
fact'' :: Integer -&gt; Integer
fact'' n
  | n &lt; 0 = error "fact out of range"
fact'' 0  = 1
fact'' n  = n * fact' (n - 1)

-- フィボナッチ関数
fibo'' :: Integer -&gt; Integer
fibo'' n
  | n &lt; 0  = error "fibo out of range"
fibo'' 0   = 1
fibo'' 1   = 1
fibo'' n   = fibo'' (n - 1) + fibo'' (n - 2)
</pre>
<p> fact'' の最初の節にガードが設定されています。n が負の場合はエラーを送出し、それ以外の場合は条件を満たすガード節がないので、次の節 fact'' 0 と実引数を照合します。最初の節のガード節に otherwise を追加すると、それ以降の節が選択されなくなります。ご注意ください。関数 fibo'' の場合も同様です。
</p>

<h4>●リストのパターン</h4>
<p> リストもパターンとマッチングすることができます。リストのパターンはコンス演算子 : を使って表します。たとえば、パターンを使って関数 append を定義すると次のようになります。
</p>

<pre class="list">
リスト：リストの連結

append :: ([a], [a]) -&gt; [a]
append (xs, ys) =
  if null xs then ys
  else head xs : append (tail xs, ys)

-- パターンを使う場合
append' :: ([a], [a]) -&gt; [a]
append' ([], ys)   = ys
append' (x:xs, ys) = x : append' (xs, ys)
</pre>
<p> append' の最初の節を見てください。タプルの第 1 要素は空リスト [ ] とマッチングします。次の節の x : xs がパターンを表します。このパターンはリストとマッチングして、先頭の要素が変数 x に、先頭要素を取り除いた残りのリストが変数 xs に束縛されます。このように、関数 head や tail を使わなくてもリストを分解することができます。
</p>

<p> 簡単な例として、前回作成した関数 length', reverse', member をパターンを使って書き直してみます。
</p>
<pre class="list">
リスト : パターンを使ったリスト操作

-- リストの長さ
length' :: [a] -&gt; Int
length' xs =
  if null xs then 0
  else 1 + length (tail xs)

-- パターンを使う場合
length'' :: [a] -&gt; Int
length'' []     = 0
length'' (x:xs) = 1 + length xs

-- リストの反転
reverse' :: [a] -&gt; [a]
reverse' xs =
  if null xs then []
  else reverse' (tail xs) ++ [head xs]

-- パターンを使う場合
reverse'' :: [a] -&gt; [a]
reverse'' []     = []
reverse'' (x:xs) = reverse'' xs ++ [x]

-- リストの探索
member :: Eq a =&gt; (a, [a]) -&gt; [a]
member (x, xs) =
  if null xs then []
  else if x == head xs then xs
  else member (x, tail xs)

-- パターンを使う場合
member' :: Eq a =&gt; (a, [a]) -&gt; [a]
member' (_, []) = []
member' (x, xs@(y:ys))
  | x == y      = xs
  | otherwise   = member' (x, ys)
</pre>
<p> ここで、member' の最初の節を見てください。引数のアンダーライン ( _ ) は「匿名変数 (anonymous variable) 」を表します。匿名変数はどの値ともマッチングするワイルドカードとして機能します。ただし、マッチングした値を参照することはできません。値を必要としない引数は匿名変数を使うと便利です。
</p>
<p> 第 2 節で、パターン y : ys を使ってリストを分解しますが、分解した値 y や ys だけではなく、元のリストの値を参照したいときがあります。このような場合、記号 @ を使うと変数とパターンを同時に設定することができます。これを「as パターン」といいます。
</p>
<pre class="item">
変数名 @ パターン
</pre>
<p> たとえば、xs@(y : ys) と [1, 2, 3] をマッチングさせると、次のようになります。
</p>
<pre class="item">
xs =&gt; [1, 2, 3]
y  =&gt; 1
ys =&gt; [2, 3]
</pre>
<p> このように、パターン xs@(y : ys) とマッチングした場合、変数 xs の値は分解する前の [1, 2, 3] になります。
</p>

<p> ところで、リストを表すパターンは x : xs だけではありません。よく使われるパターンを次に示します。
</p>
<pre class="item">
(1) [x]       要素が 1 つのリストとマッチング
(2) [x, y]    要素が 2 つのリストとマッチング
(3) x:xs      要素が 1 つ以上あるリストとマッチング
(4) x1:x2:xs  要素が 2 つ以上あるリストとマッチング
(5) x1:x1:xs  エラー
</pre>
<p> (5) のように、パターンの中に同名の変数を使うことはできません。この場合、x1:x2:xs とマッチングさせてから if またはガードで x1 と x2 が等しいかチェックすることになります。また、もっと複雑なリストもパターンで表すことができます。
</p>
<pre class="item">
(1) (x, y):xs  要素がタプルのリストとマッチング
    ex) [(1, 2), (3, 4), (5, 6)] =&gt; x = 1, y = 2, xs = [(3, 4), (5, 6)]

(2) (x::xs):ys 要素がリストのリスト [[a]] とマッチング
    ex) [[1, 2, 3], [4, 5], [6]] =&gt; x = 1, xs = [2, 3], ys = [[4, 5], [6]]
</pre>
<p> このように、パターンはとても強力な機能です。Haskell は型チェックを厳密に行う関数型言語ですが、型推論、多相型関数、パターンなどの機能により、とても柔軟にプログラミングすることができます。
</p>

<h4>●case 式</h4>
<p> パターンは Common Lisp の cond や case のような条件分岐にも使うことができます。Haskell には case 式が用意されています。
</p>
<pre class="item">
case expr of pat1 -&gt; expr1
             pat2 -&gt; expr2
                  ..... 
             patN -&gt; exprN
</pre>
<p> of のあとはレイアウトを使用することができます。pat はパターン (pattern) のことです。最初に case は式 expr を評価します。その結果とマッチングするパターンの節を選択し、対応する式を評価します。そして、その結果が case 式の返り値となります。
</p>
<p> なお、一度節が選択されたら、それ以降の節は選択されません。それから、節の式 expr1, ..., exprN の返り値は同じデータ型でなければいけません。ご注意ください。
</p>
<p> 簡単な例を示します。関数 fact と fibo は case 式を使って次のように書くことができます。
</p>
<pre class="list">
リスト : case 式の例

-- 階乗
fact :: Integer -&gt; Integer
fact n =
  case n of
    0 -&gt; 1
    _ -&gt; n * fact (n - 1)

-- フィボナッチ関数
fibo :: Integer -&gt; Integer
fibo n =
  case n of
    0 -&gt; 1
    1 -&gt; 1
    _ -&gt; fibo (n - 1) + fibo (n - 2)
</pre>
<p> どちらの関数も最後の節は匿名変数を使っているので、どんな値でも最後の節で照合は成功します。
</p>
<p> case 式の中でガードを使うこともできます。
</p>
<pre class="list">
リスト : case 式とガードの例

-- 階乗
fact' :: Integer -&gt; Integer
fact' n =
  case n of
    0 -&gt; 1
    _  | n &lt; 0     -&gt; error "fact out of range"
       | otherwise -&gt; n * fact' (n - 1)

-- フィボナッチ関数
fibo' :: Integer -&gt; Integer
fibo' n =
  case n of
    0 -&gt; 1
    1 -&gt; 1
    _  | n &lt; 0     -&gt; error "fibo out of range"
       | otherwise -&gt; fibo' (n - 1) + fibo' (n - 2)
</pre>
<p> case 式の中で階乗を使う場合、パターンの後ろで複数の節を縦線 ( | ) で区切ります。そのあと、"条件式 -&gt; 式" を記述します。関数定義のガードと違って、記号は -&gt; を使うことに注意してください。
</p>

<p> case 式を使っていろいろな機能を実現することができます。たとえば、if-then-else は次のように case 式で表すことができます。
</p>
<pre class="item">
if E then F else G  ==&gt; case E of
                          Ture  -&gt; F
                          False -&gt; G
</pre>
<p> パターンの定義は True と False しかありません。したがって、式 E が bool 以外のデータ型だとエラーになるわけです。
</p>

<p> case 式のパターンには変数を使うことができます。変数は局所変数として扱われ、有効範囲は対応する規則の式の中だけになります。たとえば、リストの操作関数 length', append, reverse', member を case 式を使って書き直すと次のようになります。
</p>

<pre class="list">
リスト : リスト操作関数を case 式で書き換え

length' :: [a] -&gt; Int
length' xs =
  case xs of
    []     -&gt; 0
    (_:ys) -&gt; 1 + length ys

append :: ([a],[a]) -&gt; [a]
append (xs, ys) =
  case xs of
    []     -&gt; ys
    (z:zs) -&gt; z : append (zs, ys)

reverse' :: [a] -&gt; [a]
reverse' xs =
  case xs of
    []     -&gt; []
    (y:ys) -&gt; reverse' ys ++ [y]

member :: Eq a =&gt; (a, [a]) -&gt; [a]
member (x, xs) =
  case xs of
    [] -&gt; []
    (y:ys) | x == y    -&gt; xs
           | otherwise -&gt; member (x, ys)
</pre>
<p> 実際のところ、関数定義でパターンマッチングやガードが使えるので、case 式を使う機会はそれほど多くないと思います。
</p>

<h4>●挿入ソート</h4>
<p> それでは、簡単な例題としてリストをソート (sort) するプログラムを作ってみましょう。ソートは、ある規則に従ってデータを順番に並べることです。たとえば、データが整数であれば、大きい順かもしくは小さい順に並べます。ソートは昔から研究されている分野で、優秀なアルゴリズムが確立しています。
</p>
<p> まずは簡単なソートアルゴリズムである「挿入ソート (insert sort) 」を作ってみましょう。挿入ソートの考え方はとても簡単です。ソート済みのリストに新しいデータを挿入していくことでソートを行います。たとえば、リスト [2, 4, 6] に 5 を挿入する場合、リストの要素 n と 5 を順番に比較して、5 &lt; n を満たす位置に 5 を挿入すればいいわけです。この場合は、4 と 6 の間に 5 を挿入すればいいですね。
</p>
<p> ソートするリストは、tail で分解していくと空リストになります。これをソート済みのリストと考えて、ここにデータを挿入していきます。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 挿入ソート

insert_element :: Ord a =&gt; (a, [a]) -&gt; [a]
insert_element (x, []) = [x]
insert_element (x, xs@(y:ys))
  | x &lt;= y    = x:xs
  | otherwise = y : insert_element (x, ys)

insert_sort :: Ord a =&gt; [a] -&gt; [a]
insert_sort []     = []
insert_sort (x:xs) = insert_element(x, insert_sort xs)
</pre>
<p> 関数型の宣言で型クラス制約に Ord を指定しています。これは比較演算子を定義している型クラスです。Haskell の場合、基本的な型は Ord <STRIKE>を継承しています。</STRIKE> のインスタンスになっています。逆に言えば、<STRIKE>Ord を継承している型であれば、</STRIKE>型が Ord のインスタンスであれば、関数 insert_sort を適用することができます。
</p>

<p> 関数 insert_sort は引数のリストを再帰呼び出しで分解します。insert_sort を再帰呼び出ししてリスト ys をソートし、そのリストに先頭要素 y を関数 insert_element で挿入します。
</p>
<p> 関数 insert_element は再帰呼び出しでリストをたどり、データ x を挿入する位置を探します。x &lt;= y が真であれば、その位置にデータを挿入します。ここで、as パターン xs@(y:ys) の変数 xs を使っています。x : xs とすることでリストに x を挿入することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; insert_sort [5,6,4,7,3,8,2,9,1,0]
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; insert_sort [9,8,7,6,5,4,3,2,1,0]
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; insert_sort [1,2,3,4,5,6,7,8,9,10]
[1,2,3,4,5,6,7,8,9,10]
</pre>
<p> 挿入ソートはデータ数が多くなると実行時間がかかります。データ数を N とすると、実行時間は N の 2 乗に比例します。挿入ソートは簡単ですが遅いアルゴリズムなのです。
</p>

<h4>●クイックソート</h4>
<p> 次は、高速なアルゴリズムとして有名な「クイックソート (quick sort) 」を取り上げます。クイックソートはある値を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。基準になる値のことを「枢軸」といいます。枢軸は要素の中から適当な値を選んでいいのですが、リストの場合は任意の要素を簡単に選ぶことができません。この場合、いちばん簡単に求めることができる先頭の要素を枢軸とします。
</p>
<p> リストを 2 つに分けたら、それらを同様にソートします。これは、再帰を使えば簡単に実現できます。その結果を枢軸を挟んで結合します。これを図に表すと次のようになります。
</p>

<pre class="fig">
    [5, 3, 7, 6, 9, 8, 1, 2, 4]

          5 を枢軸に分割

   [3, 1, 2, 4]  5  [7, 6, 9, 8]

   3を枢軸に分割    7を枢軸に分割

 [1, 2]  3  [4] | 5 | [6]  7  [9, 8]

  ・・・分割を繰り返していく・・・    

        図 : クイックソート
</pre>
<p> このようにリストを分割していくと、最後は空リストになります。ここが再帰の停止条件になります。あとは分割したリストを結合していけばいいわけです。プログラムは次のようになります。
</p>

<pre class="list">
リスト：クイックソート

-- リストの分割
partition :: Ord a =&gt; (a, [a]) -&gt; ([a],[a])
partition (_, [])   = ([], [])
partition (x, y:ys) =
  if y &lt; x then (y:a, b) else (a, y:b)
  where (a, b) = partition (x, ys)

-- クイックソート
quick_sort :: Ord a =&gt; [a] -&gt; [a]
quick_sort [] = []
quick_sort (x:xs) = quick_sort a ++ (x : quick_sort b)
  where (a, b) = partition (x, xs)
</pre>

<p> 関数 partition はリストを枢軸 x よりも小さい要素とそれ以外の要素の 2 つに分けます。最初の節が空リストの場合です。これが再帰呼び出しの停止条件になります。空リストの場合はタプル ([ ], [ ]) を返します。
</p>

<p> 次の節でリストを分割します。引数のリストをパターン y : ys で分解し、where 節で partition を再帰呼び出ししてリスト ys を 2 つに分割します。返り値は局所変数 a, b で受け取ります。あとは、枢軸 x と要素 y を比較して、y が x よりも小さければ y をリスト a に追加して返します。そうでなければ、y をリスト b に追加して返します。これで枢軸 x を基準にしてリストを 2 分割することができます。
</p>

<p> 次は関数 quick_sort を説明します。最初の節が空リストの場合で、再帰呼び出しの停止条件になります。次の節でリストを分割してソートを行います。パターン x : xs でリストを分解し、リストの先頭要素 x を枢軸とします。リストの分割は関数 partition で行います。where 節で partition を呼び出して、返り値を局所変数 a, b で受け取ります。そして、quick_sort を再帰呼び出しして、リスト a, b をソートします。あとは、その結果を枢軸 x を挟んで結合すればいいわけです。
</p>

<p> それでは、簡単な実行例を示しましょう。
</p>
<pre>
*Main&gt; quick_sort [5,6,4,7,3,8,2,9,1,0]
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; quick_sort [0,1,2,3,4,5,6,7,8,9]
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; quick_sort [9,8,7,6,5,4,3,2,1,0]
[0,1,2,3,4,5,6,7,8,9]
</pre>
<p> 正常に動作していますね。
</p>
<h4>●クイックソートの弱点</h4>
<p> クイックソートの実行時間は、データ数を N とすると平均して N * log<SUB>2</SUB> N に比例します。ところが、枢軸の選び方によっては、最悪で N の 2 乗に比例するところまで劣化します。つまり、挿入ソートと同じくらい遅くなってしまうのです。たとえば、リストの先頭要素を枢軸として選ぶ場合、リストの要素が昇順または降順に並んでいると最悪の結果になります。
</p>
<p> このため、クイックソートをプログラムする場合、枢軸の選び方を工夫するのが一般的です。たとえば、データの中からいくつかの要素を選び、その中で中間の値を持つ要素を枢軸に選びます。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、中間の値を選ぶのに時間がかかってしまいます。実際には、3 つから 5 つの要素を選んで、その中で中間の値を枢軸とする場合が多いようです。
</p>
<p> ただし、この改良方法はリストには不向きであることに注意してください。リストはデータ数が多くなるほど、後ろのデータを取り出すのに時間がかかるようになります。先頭から 3 つのデータを取り出して枢軸を選んだとしても、降順または昇順に並んだデータには効果が無いのは明らかです。このため、リストのソートはクイックソートよりも「マージソート (merge sort) 」の方が適しているといわれています。マージソートについては、あとで取り上げる予定です。
</p>
<div class="note">
-- <a name="update1"><b>[修正 (2013/02/03)]</b></a> --------<br>
「継承」ではなく「インスタンス」を使うように修正しました。
</div>
</section>
<hr>
<section class="contents">
<h3 id="chap02">高階関数</h3>
<p> Lisp. ML, Haskell などの関数型言語は、関数を他のデータ型と同等に取り扱うことができます。つまり、関数を変数に代入したり、引数として渡すことができます。また、値として関数を返すこともできるので、関数を作る関数を定義することもできます。関数を引数にとる関数のことを「汎関数 (functional) 」とか「高階関数 (higher order function) 」と呼びます。
</p>

<p> Haskell は高階関数を簡単に定義することができます。もちろん、値として関数を返すこともできるので、関数を作る関数を定義することも簡単です。実際、関数の操作は Common Lisp よりも柔軟で簡単です。
</p>

<h4>●関数を引数にとる関数</h4>
<p> 簡単な例として、整数 n から m までの和を求める関数 sum_of_integer を作ってみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 整数の和

sum_of_integer :: (Integer, Integer) -&gt; Integer
sum_of_integer (n, m)
  | n &gt; m     = 0
  | otherwise = n + sum_of_integer (n + 1, m)
</pre>
<p> 実行例を示します。
</p>
<pre>
*Main&gt; sum_of_integer (1, 10)
55
*Main&gt; sum_of_integer (1, 100)
5050
</pre>
<p> プログラムは簡単なので説明は不要でしょう。それでは、整数の 2 乗の和と 3 乗の和を求めるプログラムはどうなるでしょうか。次のリストを見てください。
</p>
<pre class="list">
リスト : 整数の 2 乗の和と 3 乗の和

-- 2 乗
square :: Num a =&gt; a -&gt; a
square x = x * x

-- 3 乗
cube :: Num a =&gt; a -&gt; a
cube x = x * x * x

-- 2 乗の和
sum_of_square :: (Integer, Integer) -&gt; Integer
sum_of_square (n, m)
  | n &gt; m     = 0
  | otherwise = square n + sum_of_square (n + 1, m)

-- 3 乗の和
sum_of_cube :: (Integer, Integer) -&gt; Integer
sum_of_cube (n, m)
  | n &gt; m     = 0
  | otherwise = cube n + sum_of_square (n + 1, m)
</pre>

<p> 実行例を示します。
</p>
<pre>
*Main&gt; sum_of_square (1, 10)
385
*Main&gt; sum_of_square (1, 100)
338350
*Main&gt; sum_of_cube (1, 10)
3025
*Main&gt; sum_of_cube (1, 100)
25502500
</pre>
<p> n を加算する処理で、関数 square を呼び出すと 2 乗の和を、関数 cube を呼び出すと 3 乗の和を求めることができます。関数 sum_of_square と sum_of_cube の違いはこれだけです。ここで、square や cube を引数として渡すことができれば、sum_of_square や sum_of_cube を一つの関数で済ますことができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 高階関数 sum_of

sum_of :: (Integer -&gt; Integer, Integer, Integer) -&gt; Integer
sum_of (f, n, m)
  | n &gt; m     = 0
  | otherwise = f n + sum_of (f, n + 1, m)
</pre>
<p> 関数 sum_of の引数 f に関数を渡します。渡された関数は、今までと同じ方法で呼び出すことができます。square や cube のかわりに f n + sum_of ... とすることで、関数 f に整数 n を適用した結果を sum_of の返り値に加算することができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; sum_of (square, 1, 10)
385
*Main&gt; sum_of (cube, 1, 10)
3025
</pre>

<h4>●ラムダ式</h4>
<p> 高階関数を使うようになると、数を 2 乗する square のような小さな関数をいちいち定義するのが面倒になります。とくに、その高階関数でしか使わないのであれば、なおさらそう思うでしょう。Haskell には Lisp と同様の「ラムダ式」という名前のない関数が用意されています。
</p>
<p> Haskell の場合、ラムダ式は次のように定義します。
</p>
<pre class="item">
\ 引数 -&gt; 式
</pre>
<p> 関数定義はラムダ式を用いて次のように表すことができます。
</p>
<pre class="item">
func = \ 引数 -&gt; 式
</pre>
<p> ラムダ式は関数型のデータを生成して返します。そして、関数定義は変数 func をその値に束縛するだけなのです。また、Haskell はラムダ式をそのまま実行することができますし、関数の引数にラムダ式を渡すこともできます。
</p>
<p> 簡単な例を示します。
</p>
<pre>
*Main&gt; (\x -&gt; x * x) 5
25
*Main&gt; (\(x,y) -&gt; x + y) (1, 2)
3
*Main&gt; sum_of (\x -&gt; x * x, 1, 10)
385
</pre>
<h4>●カリー化関数</h4>
<p> ところで、今まではタプルを使って複数の引数を受け取る関数を実現しましたが、Haskell にはもう一つ方法があります。関数型言語は関数をデータ型の一つとして扱うことができるので、関数の返り値として関数を返すことができます。この「関数を返す関数」を使うと、関数の引数が一つでも複数の引数を処理することができます。このような関数を「カリー化関数 (curried function) 」といいます。
</p>

<p> たとえば、fun (x, y) -&gt; x + y の場合、引数 x を受け取ると「引数 y を受け取って x + y を計算する関数」を返し、その関数に引数 y を渡せば x + y を計算することができます。Haskell では、次のように定義することができます。
</p>
<pre>
*Main&gt; :t \x -&gt; \y -&gt; x + y
\x -&gt; \y -&gt; x + y :: Num a =&gt; a -&gt; a -&gt; a
</pre>
<p> 関数の型が少し複雑になりました。-&gt; は右結合なので、a -&gt; a -&gt; a は a -&gt; (a -&gt; a) となります。これは引数 a を受け取り、a -&gt; a という型の関数を返すことを表しています。これで引数を一つだけ与えれば、関数を返すことになります。もちろん、引数を 2 つ与えれば、それらを加算した結果を返します。つまり、最初の引数を受け取って関数を生成し、その関数を 2 番目の引数に適用する、という動作になります。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
*Main&gt; :t (\x -&gt; \y -&gt; x + y) 1
(\x -&gt; \y -&gt; x + y) 1 :: Num a =&gt; a -&gt; a
*Main&gt; (\x -&gt; \y -&gt; x + y) 1 2
3
</pre>
<p> 引数を一つだけ渡すと「引数 y を受け取って x + y を計算する関数」を返します。引数を 2 つ渡すと、それを足し算した値を返します。カリー化関数の場合、引数は空白で区切ることに注意してください。
</p>
<p> ラムダ式を入れ子にするのは面倒なので、Haskell は次のようにカリー化関数を定義することができます。
</p>
<pre class="item">
\ 引数1 引数2 ... 引数n -&gt; 式
</pre>
<p> また、関数定義でも同様にカリー化関数を定義することができます。
</p>
<pre class="item">
名前 引数1 引数2 ... 引数n = 式
</pre>
<p> 関数をカリー化する場合、引数をカッコで囲わず、カンマでも区切りません。たとえば、関数 sum_of をカリー化すると次のようになります。
</p>
<pre class="list">
リスト : 関数 sum_of のカリー化

sum_of' :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer -&gt; Integer
sum_of' f n m
  | n &gt; m     = 0
  | otherwise = f n + sum_of' f (n + 1) m
</pre>
<p> そして、この sum_of' を使うと、sum_of_integer, sum_of_square, sum_of_cube を簡単に定義することができます。
</p>
<pre>
*Main&gt; let sum_of_integer' = sum_of' id
*Main&gt; let sum_of_square' = sum_of' square
*Main&gt; let sum_of_cube' = sum_of' cube
*Main&gt; :t sum_of_integer'
sum_of_integer' :: Integer -&gt; Integer -&gt; Integer
*Main&gt; :t sum_of_square'
sum_of_square' :: Integer -&gt; Integer -&gt; Integer
*Main&gt; :t sum_of_cube'
sum_of_cube' :: Integer -&gt; Integer -&gt; Integer
*Main&gt; sum_of_integer' 1 10
55
*Main&gt; sum_of_square' 1 10
385
*Main&gt; sum_of_cube' 1 10
3025
</pre>
<p> sum_of_integer', sum_of_square', sum_of_cube' は引数 s, e を省略して定義していますね。このような関数定義を「ポイントフリースタイル」といいます。関数 g の定義が g x = f x とすると、引数 x のことを「ポイント」と呼びます。この場合、引数 x を省略して関数定義を g = f と表すことができます。
</p>
<p> sum_of_cube' の場合、引数を記述すると次のようになります。
</p>
<pre class="item">
   sum_of_cube' s e = sum_of' cube s e
=&gt; sum_of_cube' s = sum_of' cube s
=&gt; sum_of_cube' = sum_of' cube
</pre>
<p> 右辺と左辺で最後の引数は同じ e なので、省略することが可能です。e を省略したあと、右辺左辺ともに最後の引数は s になりますね。これも省略することができます。したがって、関数定義は sum_of_cube' = sum_of' cube となります。
</p>
<p> このように、カリー化された関数の一部の引数に値を与えて、残りの引数を受け取る関数を生成することを「部分適用 (partial application) 」といいます。カリー化関数は部分適用が簡単にできるのでとても便利です。Haskell の場合、カリー化関数はよく使われる方法です。
</p>

<h4>●リストの生成</h4>
<p> Haskell は数列を表すリストを簡単に生成することができます。この機能を「レンジ (range) 」といいます。構文は次のようになります。
</p>
<pre class="item">
(1) [s .. e] => [s, s+1, s+2, ..., e-1, e]
(2) [s, s+a, .. e] => [s, s+a, s+a*2, s+a*3, ..., e]
</pre>
<p> (1) のように開始 s と終了 e の値 (s &lt; e) を指定すると、s 以上 e 以下の数列が生成されます。s &gt; e の場合は空リストになります。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; [1 ..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; [10 .. 1]
[]
</pre>
<p> (2) は初項と第 2 項で差分を指定します。つまり、公差 a の等差数列になります。差分が負の場合、s &lt; e は空リストになります。簡単な例を示しましょう。
</p>
<pre>
Prelude&gt; [1,3 .. 10]
[1,3,5,7,9]
Prelude&gt; [1,4 .. 10]
[1,4,7,10]
Prelude&gt; [10, 9 .. 1]
[10,9,8,7,6,5,4,3,2,1]
Prelude&gt; [10, 9 .. 11]
[]
</pre>
<p> レンジは整数だけではなく型クラス Enum <STRIKE>を継承している型</STRIKE>のインスタンスであれば使用することができます。簡単な例を示します。
</p>
<pre>
Prelude> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
Prelude> ['a', 'c' .. 'z']
"acegikmoqsuwy"
Prelude> [1.0 .. 10.0]
[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
Prelude> [1.0, 1.25 .. 2.0]
[1.0,1.25,1.5,1.75,2.0]
</pre>
<p> レンジを使ってリストを簡単に生成できるので、リストの要素の総和を求める関数があると sum_of_integer は簡単に実装することができます。Haskell にはリストの総和を求める関数 sum がありますが、私たちでも簡単にプログラムすることができます。次のリストを見てください。ここでは関数名を sum' としました。
</p>
<pre class="list">
リスト : リストの総和を求める

sum' :: Num a =&gt; [a] -&gt; a
sum' []     = 0
sum' (x:xs) = x + sum' xs
</pre>
<p> 最初の節で引数が空リストであれば 0 を返します。そうでなければ、リストを x : xs で分解し、sum' xs の返り値に x を加算します。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
*Main&gt; sum' [1..10]
55
*Main&gt; sum' [1..100]
5050
*Main&gt; sum' [1..1000]
500500
</pre>

<p> sum' を使って sum_of_integer を定義すると次のようになります。
</p>
<pre>
*Main&gt; let sum_of_integer n m = sum' [n .. m]
*Main&gt; sum_of_integer 1 10
55
*Main&gt; sum_of_integer 1 100
5050
*Main&gt; sum_of_integer 1 1000
500500
</pre>
<p> 正常に動作していますね。ところで、関数 sum_of は sum だけでは簡単に定義できません。必要となるピース (関数) は次回説明することにします。
</p>

<h4>●セクション</h4>
<p> Haskell は中置演算子をカッコで囲むとカリー化関数として扱うことができます。簡単な例を示しましょう。
</p>
<pre>
*Main&gt; (+) 1 2
3
*Main&gt; (*) 1 2
2
*Main&gt; (^) 2 3
8
</pre>
<p> 中置演算子の場合、部分適用には特別な構文が用意されています。次の例を見てください。
</p>
<pre>
*Main&gt; (+1) 2
3
*Main&gt; (*10) 2
20
*Main&gt; (^2) 3
9
*Main&gt; (2^) 3
8
</pre>
<p> 演算子を op, 引数を x, y とすると、 (op y) x は x op y を意味し、(y op) x は y op x を意味します。この機能を「セクション」と呼びます。高階関数を使う場合、セクションはとても役に立ちます。たとえば、sum_of_square, sum_of_cube は次のように定義できます。
</p>
<pre class="list">
リスト : sum_of_square, sum_of_cube の定義

sum_of_square = sum_of' (^2)
sum_of_cube   = sum_of' (^3)
</pre>
<p> なお、演算子 - を部分適用することはできません。(-2) は -2 という負の数として解釈されます。ご注意くださいませ。
</p>
<div class="note">
-- <a name="update2"><b>[修正 (2013/02/03)]</b></a> --------<br>
「継承」ではなく「インスタンス」を使うように修正しました。
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell02.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>