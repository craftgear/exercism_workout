<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881749</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml04.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">レキシカルスコープとクロージャ</h3>
<p> 変数の有効範囲を表す用語に「スコープ (scope) 」があります。この用語を使うと、厳密ではありませんが、変数の有効範囲は「レキシカルスコープ (lexical scope) 」と「ダイナミックスコープ (dynamic scope) 」の 2 つに分けることができます。伝統的な Lisp はダイナミックスコープですが、現在のプログラミング言語、たとえば、Scheme, Common Lisp, SML/NJ, OCaml はレキシカルスコープを採用しています。
</p>
<h4>●レキシカルスコープ</h4>
<p> それでは、レキシカルスコープについて詳しく見てみましょう。変数 x を表示する関数 foo を定義します。
</p>
<pre>
# let x = "global\n";;
val x : string = "global\n"
# let foo () = print_string x;;
val foo : unit -&gt; unit = &lt;fun&gt;
# foo ();;
global
- : unit = ()
</pre>
<p> OCaml の場合、引数のない関数は unit を使って定義します。その関数を呼び出すときも、引数として unit を渡します。
</p>
<p> 関数 foo には局所変数 x を定義していないので、foo を実行した場合は大域変数の値を参照します。その結果 global が表示されます。それでは、foo1 という関数から foo を呼び出す場合を考えてみましょう。foo1 には let で局所変数 x を定義します。この場合、foo はどちらの値を表示するのでしょうか。実際に試してみましょう。
</p>
<pre>
# let foo1 () = let x = "local\n" in foo ();;

... 警告メッセージ ...

val foo1 : unit -&gt; unit = &lt;fun&gt;
# foo1();;
global
- : unit = ()
</pre>

<p> 局所変数 x を使っていないという警告が出ますが気にしないでください。foo1 を実行すると大域変数の値 global を表示しました。このように、foo1 で定義した局所変数 x は、foo から参照することはできません。次の図を見てください。
</p>
<pre class="fig">
┌──────  OCaml system  ──────┐ 
│                                        │
│              大域変数  x ←────┐  │
│                                    │  │
│  ┌→┌─ 関数 foo ──────┐  │  │
│  │  │                ┌───┼─┘  │
│  │  │   print_string x       │      │
│  │  │                        │      │
│  │  └────────────┘      │
│  │  ┌─ 関数 foo1  ─────┐      │
│  │  │                        │      │
│  │  │  ┌─let : x ───┐  │      │
│  │  │  │                │  │      │
│  └─┼─┼─ foo()        │  │      │
│      │  └────────┘  │      │
│      └────────────┘      │
│                                        │
└────────────────────┘

        図 1 : レキシカルスコープ
</pre>
<p> 上図では変数の有効範囲を枠で表しています。foo1 の let で定義した局所変数 x は、let の枠の中でのみ有効です。もしも、この枠で変数が見つからない場合は、ひとつ外側の枠を調べます。順番に外側の枠を調べていくと、最後には関数定義の枠に行き着きます。ここで変数（引数）が見つからない場合は大域変数を調べます。
</p>
<p> 関数 foo は関数定義の枠しかありません。そこに変数 x が定義されていないので、大域変数を調べることになるのです。このように、関数 foo から foo1 の枠と let の枠を超えて変数 x にアクセスすることはできないのです。これを「レキシカルスコープ」といいます。レキシカルには文脈上いう意味があり、変数が定義されている構造の範囲内 (枠内) でないと、その変数にアクセスすることはできません。
</p>
<p> ところが伝統的な Lisp の場合、foo1 で定義した変数 x は呼び出された関数 foo からアクセスすることができます。これを「ダイナミックスコープ」といいます。foo1 で定義された変数 x は、foo1 の実行が終了するまで存在します。そして、foo1 から呼ばれた関数ならば、どこからでも参照することができるのです。もしも、foo1 をダイナミックスコープの処理系、たとえば Emacs Lisp で実行するならば、foo で表示される x の値は local になります。
</p>

<h4>●レキシカルスコープと局所関数</h4>
<p> それでは、関数の中で定義された局所関数や匿名関数の場合はどうなるのでしょうか。次の例を見てください。
</p>

<pre class="list">
リスト 1 : リストの要素を n 倍する

let times_element n xs =
  List.map (fun x -&gt; x * n) xs
</pre>

<p> 匿名関数の引数は x だけなので、変数 n は大域変数を参照するように思われるかもしれません。ところが、変数 n は関数 times_element の引数 n を参照するのです。これを図に示すと、次のようになります。
</p>

<pre class="fig">
┌────── OCaml system ──────┐
│                                      │
│    ┌─ times_element : n xs ─┐    │
│    │                  ↑      │    │
│    │                  └─┐  │    │
│    │  ┌── fun : x  ─┐│  │    │
│    │  │          ↑    ││  │    │
│    │  │    ┌──┘    ││  │    │
│    │  │     x * n      ││  │    │
│    │  │        └───┼┘  │    │
│    │  └────────┘    │    │
│    └─────────────┘    │
│                                      │
└───────────────────┘

        図 2 : 匿名関数内の変数
</pre>

<p> ポイントは、匿名関数が times_element 内で定義されているところです。変数 n は関数の引数として定義されていて、その有効範囲は関数の終わりまでです。匿名関数はその範囲内に定義されているため、変数 n にアクセスすることができるのです。つまり、関数内で定義された匿名関数は、そのとき有効な局所変数にアクセスすることができるのです。
</p>

<p> これは let で定義された局所的な関数も同じです。times_element は次のように書き換えることができます。
</p>

<pre class="list">
リスト 2 : リストの要素を n 倍する

let times_element n xs =
  let timesN x = x * n in
  List.map timesN xs
</pre>
<p> 局所関数 timesN は times_element 内で定義されているので、timesN から times_element の引数 n を参照することができます。
</p>

<h4>●クロージャ</h4>
<p> Lisp などの関数型言語では、関数を生成する関数を簡単に作ることができます。このとき使われる機能が「クロージャ (closure) 」です。クロージャは評価する関数と参照可能な局所変数をまとめたものです。クロージャは関数のように実行することができますが、クロージャを生成するときに参照可能な局所変数を保持するところが異なります。参照可能な局所変数の集合を「環境」と呼ぶことがあります。
</p>

<p> OCaml の関数はカリー化できるので、関数を返す関数はとても簡単に作成することができます。また、OCaml は関数型言語なので、当然ですがクロージャも使うことができます。OCaml でクロージャを生成するには「匿名関数」を使うか、局所的な関数を定義して、その関数を返します。たとえば、「引数を n 倍する関数」を生成する関数は、匿名関数を使うと次のようになります。
</p>
<pre>
# let foo n = fun x -&gt; n * x;;
val foo : int -&gt; int -&gt; int = &lt;fun&gt;
# let foo10 = foo 10;;
val foo10 : int -&gt; int = &lt;fun&gt;
# foo10 100;;
- : int = 1000
# let foo5 = foo 5;;
val foo5 = int -&gt; int = &lt;fun&gt;
# foo5 11;;
- : int = 55
</pre>
<p> 関数 foo は引数を n 倍する関数を生成します。関数 foo の型 int -&gt; int -&gt; int は int -&gt; (int -&gt; int) を意味しています。これは引数 int を受け取り int -&gt; int という関数を返すことを表しています。変数 foo10 に foo 10 の返り値をセットします。すると、foo10 は引数を 10 倍する関数として使うことができます。同様に、変数 foo5 に foo 5 の返り値をセットすると、foo5 は引数を 5 倍する関数になります。
</p>

<p> 匿名関数を生成するとき、評価する関数のほかに、そのとき参照可能な局所変数、つまり「環境」もいっしょに保存されます。この場合、参照可能な局所変数は foo の引数 n です。そして、クロージャを実行するときは、保存されている局所変数を参照することができるのです。
</p>
<p> foo 10 を実行して無名関数を生成するとき、定義されている局所変数は n で、その値は 10 ですね。この値がクロージャに保存されているので、foo10 の関数は引数を 10 倍した結果を返します。foo 5 を評価すると n の値は 5 で、それがクロージャに保存されているので、foo5 の関数は引数を 5 倍した結果を返すのです。
</p>

<p> また、let で局所的な関数を定義して、その関数を返すとクロージャを生成することができます。let を使った例を示します。
</p>
<pre>
# let foo n = let bar x = n * x in bar;;
val foo = int -&gt; int -&gt; int = &lt;fun&gt;
# let foo100 = foo 100;;
val foo100 : int -&gt; int = &lt;fun&gt;
# foo100 11;;
- : int = 1100
</pre>
<p> let で関数 bar を定義して、bar を返します。すると、foo は「引数を n 倍する関数」を生成する関数になります。
</p>
<p> もっとも、OCaml では関数をカリー化するだけで同様の関数を作ることができます。
</p>
<pre>
# let foo n x = n * x;;
val foo : int -&gt; int -&gt; int = &lt;fun&gt;
# let foo10 = foo 10;;
val foo10 : int -&gt; int = &lt;fun&gt;
# foo10 5;;
- : int = 50
# let foo100 = foo 100;;
val foo100 : int -&gt; int = &lt;fun&gt;
# foo100 5;;
- : int = 500
</pre>
<p> このように、OCaml は関数をカリー化できるので、部分適用により目的の関数を簡単に生成することができます。
</p>
<h4>●連想リスト</h4>
<p> クロージャを理解する場合、環境を「連想リスト (association list : a-list) 」で考えるとわかりやすいと思います。ここで簡単に連想リストについて説明します。
</p>

<p> 連想リストは Lisp でよく用いられるデータ構造で、OCaml ではキーとデータの組を要素とするリストで実現することができます。データ型で記述すると ('a * 'b) list になり、'a がキーで 'b がデータに対応します。
</p>

<pre class="fig">
                    ┌────┬────┬────┬──→ データ 
                    │        │        │        │
連想リスト =&gt; [("a", 1), ("b", 2), ("c", 3), ("d", 4)]
                │        │        │        │
                └────┴────┴────┴──→ キー

                図 3 : 連想リストの構造
</pre>

<p> 上図の場合、文字列 "a", "b", "c", "d" がキーで、整数 1, 2, 3, 4 がデータとなります。OCaml の List モジュールには連想リストを操作する関数が用意されています。
</p>

<p> 一般に、関数を呼び出す場合、関数を評価するための環境は空リストです。最初に、引数がこの環境に追加されます。let で定義される局所変数もこの環境に追加されます。もしも、環境に該当する変数が存在しない場合は大域変数を参照します。
</p>
<p> たとえば、foo 5 と呼び出すと環境は次のようになります。
</p>
<pre class="item">
foo 5 ==&gt; 環境 : [(n, 5)]
</pre>
<p> 連想リストのキー n が変数名で、その値が 5 です。クロージャを生成するとき、この連想リストを保持すると考えてください。そして、クロージャを評価するときは、保存していた環境を使います。したがって、foo5 11 を評価すると、環境 [(n, 5)] に引数 x の値が追加され、[(x, 11), (n, 5)] になります。この環境で式 n * x を評価するので、5 * 11 = 55 を返すわけです。
</p>
<p> 関数の評価が終了すると、環境に追加された変数は削除されます。foo5 11 の評価で追加された変数は x なので、(x, 11) が削除され [(n, 5)] になります。このように、クロージャに保存された環境は変化しません。
</p>
<p> ただし、Common Lisp や Scheme のように、変数の値を書き換えることができる処理系では、クロージャに保存された変数の値を変更することが可能です。興味のある方は Common Lisp 入門：<a href="../xyzzy_lisp/abclisp11.html#chap23">クロージャ</a> を読んでみてください。
</p>
<h4>●ダイナミックスコープ</h4>
<p> ところで、伝統的な Lisp はレキシカルスコープではなくダイナミックスコープです。ここで簡単にダイナミックスコープについて説明します。もしも、OCaml がダイナミックスコープであれば、最初の例題で示した関数 foo は関数 foo1 から呼び出されると、foo1 の局所変数にアクセスすることができます。これを図に示すと次のようになります。
</p>

<pre class="fig">
┌──────────────┐    ┌─定義された局所変数─┐
│let foo () = print_string x │    │  []                  │
└──────────────┘    └───────────┘
                                       定義された変数はなし
    （１） bar を評価する

┌──────────────┐    ┌─定義された局所変数─┐
│let foo1 () =               │─→│  [(x, "local")]      │
│  let x = "local" in foo () │    └───────────┘
└──────────────┘
                        ↓  呼び出し
┌──────────────┐    ┌─定義された局所変数─┐
│let foo () = print_string x │←─│  [(x, "local")]      │
└──────────────┘    └───────────┘
      x は "local" となる              foo で定義した変数 a

    （２） foo から bar を呼び出す

                    図 4 : ダイナミックスコープ
</pre>
<p> ダイナミックスコープの場合、局所変数はひとつの連想リストで管理されていると考えてください。この場合、キーが局所変数を表し、データがその値に対応します。局所変数にアクセスするときは、この連想リストから該当する変数を探すのです。見つからない場合は大域変数を検索します。
</p>
<p> 関数呼び出しや let などで局所変数が定義されたときに、変数とその値が連想リストの先頭へ追加されます。そして、関数や let の評価が終了したときに、連想リストから変数が削除されます。関数が呼び出されるたびに、新しい変数が連想リストに追加されますが、呼び出した側で定義した局所変数も、この連想リストの中に残っています。
</p>
<p> たとえば、(1) のように関数 foo を呼び出した場合、関数の引数がなくて局所変数の定義もないので連想リストは空です。ところが、(2) のように関数 foo1 を呼び出した場合、局所変数 x が定義されているので、連想リストに (x, "local") がセットされます。この状態で関数 foo が呼び出されると、連想リストには foo1 で定義した (x, "local") が残っているので、foo では x の値が "local" となるのです。
</p>
<p> このように、ダイナミックスコープでは、変数のアクセスは関数を評価する順番に左右されます。したがって、関数の中で定義されていない変数があっても、それがグローバル変数として扱われるとは限らないのです。
</p>
<p> ダイナミックスコープで便利なところは、ほかの関数から他の関数の局所変数にアクセスできるところです。そのかわり、プログラムを見ただけでは、どの変数にアクセスしているのかわからないという欠点があります。プログラムの可読性の点でいえば、レキシカルスコープの方が優れていると思います。
</p>

<h4>●関数の合成</h4>
<p> 最後に、関数 f(x) と g(x) を合成して新しい関数 h(x) を作ることを考えてみましょう。関数 h(x) を次のように定義します。
</p>
<pre class="item">
h(x) = g( f(x) )
</pre>
<p> たとえば、f(x) = 2 * x + 1, g(y) = y * y + 3 * y とすると、h(x) は次のようになります。
</p>
<pre class="item">
h(x) = g( f(x) )
     = (2 * x + 1) * (2 * x + 1) + 3 * (2 * x + 1)
     = 4 * x * x + 4 * x + 1 + 6 * x + 3
     = 4 * x * x + 10 * x + 4
</pre>
<p> 実際のプログラムは数式を展開するのではなく、f(x) の評価結果を g(x) に渡すだけなので簡単です。第 1 引数と第 2 引数に関数 f と g を受け取り、それらを第 3 引数に適用する関数 compose は次のようになります。
</p>
<pre>
# let compose f g x = g (f x);;
val compose : ('a -&gt; 'b) -&gt; ('b -&gt; 'c) -&gt; 'a -&gt; 'c = &lt;fun&gt;
</pre>

<p> 関数 f(x) の返り値が関数 g(x) の引数になるので、関数 g(x) が受け付ける値でなければいけません。そうでないと関数を合成することはできません。この条件を関数 compose の型が表しています。関数 f の返り値が型 'b ならば、関数 g の引数も型は 'b でなければいけません。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
# let foo x = 2 * x + 1;;
val foo = int -&gt; int = &lt;fun&gt;
# let bar y = y * y + 3 * y;;
val bar = int -&gt; int = &lt;fun&gt;
# bar (foo 4);;
- : int = 108
# let baz = compose foo bar;;
val baz : int -&gt; int = &lt;fun&gt;
# baz 4;;
- : int = 108
</pre>
<p> 関数 foo と bar を定義します。foo と bar の合成は bar( foo( x ) ) と表すことができます。実際に 4 を計算すると 108 になります。この関数は compose で合成することができます。compose foo bar の返り値を変数 baz に束縛すると、baz を合成関数として使うことができます。
</p>
<hr>
<h3 id="chap02">順列と組み合わせ</h3>
<p> 今回は簡単な例題として、「順列 (permutation) 」と「組み合わせ (combination) 」を取り上げます。
</p>
<h4>●順列の生成</h4>
<p> 異なる n 個の順列の総数は、n の階乗 (n!) だけあります。たとえば、3 つの整数 1, 2, 3 の順列は次に示すように 6 通りあります。
</p>
<pre class="item">
1 2 3,  1 3 2,  2 1 3,  2 3 1,  3 1 2,  3 2 1
</pre>
<p> 順列を生成するプログラムは再帰定義で簡単に作ることができます。[1; 2; 3] の順列を生成する場合、最初に 1 で始まる順列を生成します。これは 1 を取り除いた数字 [2; 3] の順列を生成することで実現できます。次は 2 で始まる順列を生成します。同様に、2 を取り除いた数字 [1; 3] の順列を生成すればいいわけです。[2; 3] や [1; 3] の順列を生成する場合も同じように考えることができます。
</p>

<p> ここでは、リストの中から n 個の要素を取り出す順列を求めます。プログラムは次のようになります。
</p>
<pre class="list">
リスト 3 : 順列の生成 (1)

(* int list の表示 *)
let print_intlist xs =
  List.iter (fun x -&gt; print_int x; print_string " ") xs;
  print_newline ()

(* リストから要素を削除する *)
let rec remove x = function
  [] -&gt; []
| y :: ys -&gt; if x = y then remove x ys else y :: remove x ys

(* 順列の生成 *)
let gen_perm n xs f = 
  let rec perm n xs a =
    if n = 0 then f (List.rev a)
    else List.iter (fun x -&gt; perm (n - 1) (remove x xs) (x :: a)) xs
  in
    perm n xs []
</pre>

<p> 関数 gen_perm は高階関数で、引数 n が選ぶ要素の個数、引数 xs がリスト、引数 f が生成した順列に適用する関数です。たとえば、順列が数字のリストであれば、int list を表示する関数 print_intlist を渡すことで、生成した順列を表示することができます。実際の処理は局所関数 perm で行います。
</p>

<p> perm の引数 n が選ぶ要素の個数、引数 xs がリストです。引数 a は累積変数で、選んだ数字を格納するリストです。n が 0 の場合、順列がひとつ完成したので List.rev で a を逆順にして関数 f に渡します。選んだ数字はリストの先頭に追加していくので、逆順になることに注意してください。
</p>

<p> n が 0 でなければ、数字を一つ選んで perm を再帰呼び出しします。数字の選択はリストの先頭から順番に行えばいいので、高階関数 List.iter を使っています。iter の定義をリスト 4 に示します
</p>

<pre class="list">
リスト 4 : 高階関数 iter の定義

let rec iter f = function
  [] -&gt; ()
| x :: xs -&gt; f x; iter f xs
</pre>
<p> iter はリストの要素に関数 f を適用します。その結果は捨てられることに注意してください。つまり、副作用を目的とした関数なのです。iter の返り値は unit になります。
</p>

<p> 匿名関数でリストの要素 x を受け取り、この中で prem を再帰呼び出しします。perm の第 1 引数は  n - 1、第 2 引数は xs から x を削除したリスト、第 3 引数は選択した数字のリスト a に x を追加したものです。これで数字 x を選択したことになります。x の削除は関数 remove で行います。
</p>

<p> 関数 remove はリストから x を探し、見つけた x をすべて削除します。List.filter を使う場合は、次のようになります。
</p>
<pre class="list">
リスト 5 : 要素の削除

let remove x xs = List.filter (fun y -&gt; x &lt;&gt; y) xs
</pre>

<p> 関数 print_intlist は int list を表示します。List.iter を使って print_int で要素を表示します。print_newline は改行を出力する関数です。
</p>

<p> それでは、実際に試してみましょう。
</p>
<pre>
# gen_perm 3 [1; 2; 3] print_intlist;;
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
- : unit = ()
</pre>
<p> 正常に動作していますね。
</p>
<h4>●順列をリストに格納する</h4>
<p> 生成した順列をリストに格納して返す場合は、List.fold_right を使うと簡単です。プログラムは次のようになります。
</p>

<pre class="list">
リスト 6 : 順列の生成 (2)

let gen_perm_list n xs =
  let rec perm n xs a b =
    if n = 0 then a::b
    else List.fold_right (fun x y -&gt; perm (n-1) (remove x xs) (x::a) y) xs b
  in
    perm n xs [] []
</pre>
<p> 局所関数 perm は gen_perm の局所関数を改造したもので、生成した順列を第 4 引数 b のリストに格納します。perm は順列を格納したリスト (第 4 引数) をそのまま返します。perm を呼び出す場合、この返り値を第 4 引数に渡すことで、生成した順列を格納していくことができます。
</p>
<p> List.fold_right の初期値 (第 3 引数) に引数 b を渡すことで、匿名関数の第 2 引数 y に順列を格納するリストを渡します。あとは perm を再帰呼び出しすると、その返り値は次に匿名関数を呼び出すときの引数 y に渡されるので、順列を格納したリストを perm に渡していくことができます。
</p>
<p> それでは実行結果を示します。
</p>
<pre class="item">
val gen_perm_list = 'a list -&gt; 'a list list = &lt;fun&gt;
</pre>
<pre>
# perm_list 3 [1; 2; 3];;
- : int list list = [[1; 2; 3]; [1; 3; 2]; [2; 1; 3];
 [2; 3; 1]; [3; 1; 2]; [3; 2; 1]]
</pre>
<p> 正常に動作していますね。
</p>
<h4>●組み合わせの生成</h4>
<p> 次は「組み合わせ (combination) 」を生成するプログラムを作ってみましょう。たとえば、リスト [1; 2; 3; 4; 5] の中から 3 個を選ぶ組み合わせは次のようになります。
</p>
<pre class="item">
1 2 3, 1 2 4, 1 2 5, 1 3 4, 1 3 5, 1 4 5
2 3 4, 2 3 5, 2 4 5, 3 4 5
</pre>
<p> 最初に 1 を選択した場合、次は [2; 3; 4; 5] の中から 2 個を選べばいいですね。2 番目に 2 を選択したら、次は [3; 4; 5] の中から 1 個を選べばいいわけです。これで、[1; 2; 3], [1; 2; 4], [1; 2; 5] が生成されます。[2; 3; 4; 5] の中から 2 個選ぶとき、2 を選ばない場合があります。この場合は [3; 4; 5] の中から 2 個を選べばいいわけです。ここで 3 を選ぶと [1; 3; 4], [1; 3; 5] が生成できます。同様に、3 を除いた [4; 5] の中から 2 個をえらぶと [1; 4; 5] を生成することができます。
</p>
<p> これで 1 を含む組み合わせを生成したので、次は 1 を含まない組み合わせ、つまり [2; 3; 4; 5] から 3 個を選ぶ組み合わせを生成すればいいわけです。けっきょく、この処理の考え方は次に示す組み合わせの公式と同じです。
</p>
<pre class="item">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r-1</sub> + <sub>n-1</sub>C<sub>r</sub>
</pre>
<p>これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト 7 : 組み合わせの生成

(* 例外の定義 *)
exception GenComb

let gen_comb n xs f =
  let rec comb n xs a =
    match (n, xs) with
      (0, _) -&gt; f (List.rev a)
    | (_, []) -&gt; raise GenComb
    | (_, y::ys) when List.length xs = n -&gt; f (List.rev a @ xs)
    | (_, y::ys) -&gt; comb (n - 1) ys (y::a); comb n ys a
  in
    comb n xs []
</pre>
<p> 局所関数 comb は引数 xs のリストから n 個を選ぶ組み合わせを生成します。選んだ数字は第 3 引数 a のリストに格納します。最初の節で n が 0 になったら組み合わせを一つ生成できたので、a を rev で逆順にして関数 f に渡します。3 番目の節で、リスト xs の長さが n と等しくなったならば、リストの要素を全て選択します。List.rev で a を逆順にして演算子 @ でリスト xs と結合してから関数 f に渡します。
</p>
<p> この 2 つの条件が再帰呼び出しの停止条件になります。これ以外で xs が [ ] になる場合は、引数 n にリスト xs の長さよりも大きな値を指定した場合です。この場合は raise で例外 GenComb を送出します。例外はあとで詳しく説明します。
</p>
<p> あとは最後の節で関数 comb を再帰呼び出しするだけです。最初の呼び出しは先頭の要素を選択する場合です。先頭要素 y を a に追加して、リスト ys の中から n - 1 個の要素を選びます。最後の呼び出しが先頭の要素を選ばない場合です。リスト ys の中から n 個の要素を選びます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# comb 3 [1; 2; 3; 4; 5] print_intlist;;
1 2 3
1 2 4
1 2 5
1 3 4
1 3 5
1 4 5
2 3 4
2 3 5
2 4 5
3 4 5
- : unit = ()
</pre>
<p> 正常に動作していますね。
</p>
<h4>●組み合わせをリストに格納する</h4>
<p> 生成した組み合わせをリストに格納して返す場合も簡単です。プログラムは次のようになります。
</p>

<pre class="list">
リスト 8 : 組み合わせの生成 (2)

let gen_comb_list n xs =
  let rec comb n xs a b =
    match (n, xs) with
      (0, _) -&gt; (List.rev a)::b
    | (_, []) -&gt; raise GenComb
    | (_, y::ys) when List.length xs = n -&gt; (List.rev a @ xs)::b
    | (_, y::ys) -&gt; comb (n - 1) ys (y::a) (comb n ys a b)
  in
    comb n xs [] []
</pre>
<p> 局所関数 comb は gen_comb の局所関数を改造したもので、生成した組み合わせを第 4 引数のリストに格納します。comb は組み合わせを格納したリスト (第 4 引数) をそのまま返します。comb を再帰呼び出しする場合、この返り値を第 4 引数に渡すことで、生成した組み合わせを格納していくことができます。
</p>
<p> 具体的には、comb を再帰呼び出しするところで、1 回目の呼び出しの返り値を 2 回目の呼び出しの第 4 引数に渡します。これで生成した組み合わせをリストに格納することができます。
</p>
<p> それでは実行結果を示します。
</p>
<pre class="item">
val comb_list = fn : int -&gt; 'a list -&gt; 'a list list
</pre>
<pre>
# gen_comb_list 3 [1; 2; 3; 4; 5];; 
- : int list list = [[1; 2; 3]; [1; 2; 4]; [1; 2; 5]; [1; 3; 4]; [1; 3; 5];
[1; 4; 5]; [2; 3; 4]; [2; 3; 5]; [2; 4; 5]; [3; 4; 5]]
</pre>
<p> 正常に動作していますね。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml04.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>