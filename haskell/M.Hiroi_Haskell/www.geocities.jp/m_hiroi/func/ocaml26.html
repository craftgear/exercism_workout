<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881751</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml25.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml27.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">便利なリスト操作関数</h3>
<p> 関数型言語の場合、リスト操作関数の多くは高階関数として定義されています。OCaml にも便利な高階関数がモジュール List に用意されています。今回は OCaml の勉強として、ちょっと便利なリスト操作関数や高階関数を実際に作ってみましょう。なお、本稿の内容は拙作のページ <a href="yaop01.html">Yet Another OCaml Problems</a> と重複している部分がありますが、あしからずご了承くださいませ。
</p>

<h4>●iota と tabulate</h4>
<p> 最初は数列を生成する関数 iota と tabulate を作りましょう。iota は n から始まり step ずつ増加していく数値を m 個リストに格納して返します。拙作のページ <a href="yaop01.html">Yet Another OCaml Problems</a> と仕様が異なっていることに注意してください。プログラムは次のようになります。
</p>

<pre class="list">
リスト 1 : 数列の生成

let rec iota n ?(step=1) m =
  if m &lt;= 0 then []
  else n :: iota (n + step) ~step (m - 1)
</pre>
<pre class="item">
val iota : int -&gt; ?step:int -&gt; int -&gt; int list = &lt;fun&gt;
</pre>
<p> 引数 step はオプショナル引数としました。簡単な実行例を示します。
</p>
<pre>
# iota 1 10;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
# iota 1 10 ~step:2;;
- : int list = [1; 3; 5; 7; 9; 11; 13; 15; 17; 19]
# iota 10 10 ~step:(-1);;
- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
</pre>
<p> iota を末尾再帰と繰り返しに変換すると次のようになります。
</p>
<pre class="list">
リスト 2 : 数列の生成 (2)

let iota_i n ?(step=1) m =
  let rec iter n m a =
    if m &lt;= 0 then List.rev a
    else iter (n + step) (m - 1) (n::a)
  in
    iter n m []

let iota_l n ?(step=1) m =
  let i = ref n and a = ref [] in
  for j = m downto 1 do
    a := (!i :: !a);
    i := !i + step
  done;
  List.rev !a
</pre>

<p> どちらの関数も累積変数 a に数値を格納し、List.rev でリストを反転して返します。とくに難しいところはないでしょう。
</p>

<p> 関数 tabulate は iota で生成した数列に関数 fn を適用した結果をリストに格納して返します。List.map fn (iota n m) と同じですが、この方法では iota で新しいリストを生成し、なおかつ map で新しいリストを生成することになります。tabulate は数列を生成しながら関数 fn を適用するので、無駄なリストを生成することがありません。プログラムは次のようになります。
</p>

<pre class="list">
リスト 3 : 数列の生成 (3)

let rec tabulate fn n ?(step=1) m =
  if m &lt;= 0 then []
  else fn n :: tabulate fn (n + step) ~step (m - 1)
</pre>
<pre class="item">
val tabulate : (int -&gt; 'a) -&gt; int -&gt; ?step:int -&gt; int -&gt; 'a list = &lt;fun&gt;
</pre>
<p> tabulate は生成した数値 n に関数 fn を適用した結果をリストに格納するだけです。簡単な実行例を示します。
</p>
<pre>
# tabulate (fun x -&gt; x * x) 1 10;;
- : int list = [1; 4; 9; 16; 25; 36; 49; 64; 81; 100]
# tabulate (fun x -&gt; x * x) 1 10 ~step:2;;
- : int list = [1; 9; 25; 49; 81; 121; 169; 225; 289; 361]
</pre>
<p> tabulate を末尾再帰と繰り返しに変換すると次のようになります。
</p>
<pre class="list">
リスト 4 : 数列の生成 (4)

let tabulate_i fn n ?(step=1) m =
  let rec iter n m a =
    if m &lt;= 0 then List.rev a
    else iter (n + step) (m - 1) (fn n::a)
  in
    iter n m []

let tabulate_l fn n ?(step=1) m =
  let j = ref n and a = ref [] in
  for i = m downto 1 do
    a := (fn !j :: !a);
    j := !j + step
  done;
  List.rev !a
</pre>
<p> これらの関数も累積変数 a を使って結果をリストに格納し、それを List.rev で反転して返します。とくに難しいところはないと思います。
</p>

<h4>●リストの分割</h4>
<p> 次は一つのリストを長さ n の部分リストに分ける関数 group を作ってみましょう。この処理はリストの先頭から n 個の要素を取り出す関数 take と、先頭から n 個の要素を取り除く関数 drop を作ると簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト 5 : リストの分割 (1)

let rec take ls n =
  if n &lt;= 0 || ls = [] then []
  else List.hd ls :: take (List.tl ls) (n - 1)

let rec drop ls n =
  if n &lt;= 0 || ls = [] then ls
  else drop (List.tl ls) (n - 1)

let rec group ls n =
  if ls = [] then []
  else take ls n :: group (drop ls n) n
</pre>
<pre class="item">
val take : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
val drop : 'a list -&gt; int -&gt; 'a list = &lt;fun&gt;
val group : 'a list -&gt; int -&gt; 'a list list = &lt;fun&gt;
</pre>
<p> 関数 take はリスト ls の先頭から n 個の要素を取り出してリストに格納して返します。リストの長さが n 未満の場合は、リストをコピーして返すことになります。関数 drop はリスト ls の先頭から n 個の要素を取り除きます。これは Common Lisp の関数 nthcdr と同じ動作になります。
</p>
<p> 関数 group は take の返り値と group を再帰呼び出しした返り値を演算子 :: で連結するだけです。group を再帰呼び出しするときは、drop で先頭から n 個の要素を取り除くことに注意してください。
</p>

<p> それでは実行例を示します。
</p>
<pre>
# take [1; 2; 3; 4; 5; 6] 3;;
- : int list = [1; 2; 3]
# drop [1; 2; 3; 4; 5; 6] 3;;
- : int list = [4; 5; 6]
# group [1; 2; 3; 4; 5; 6] 3;;
- : int list list = [[1; 2; 3]; [4; 5; 6]]
# group [1; 2; 3; 4; 5; 6] 2;;
- : int list list = [[1; 2]; [3; 4]; [5; 6]]
# group [1; 2; 3; 4; 5; 6] 4;;
- : int list list = [[1; 2; 3; 4]; [5; 6]]
</pre>

<p> take と group を末尾再帰に変換すると次のようになります。
</p>

<pre class="list">
リスト 6 : リストの分割 (2)

let take_i ls n =
  let rec iter ls n a =
    if n &lt;= 0 || ls = [] then List.rev a
    else iter (List.tl ls) (n - 1) (List.hd ls :: a)
  in
    iter ls n []

let group_i ls n =
  let rec iter ls a =
    if ls = [] then List.rev a
    else iter (drop ls n) (take ls n :: a)
  in
    iter ls []
</pre>

<p> 次は、take と drop を合わせたような関数 split_nth を作りましょう。split_nth はリストを n 番目の要素で二分割します。プログラムは次のようになります。
</p>
<pre class="list">
リスト 7 : リストの分割 (3)

let rec split_nth ls n =
  if n &lt;= 0 || ls = [] then ([], ls)
  else
    let (a, b) = split_nth (List.tl ls) (n - 1) in
    (List.hd ls :: a, b)

(* 末尾再帰バージョン *)
let split_nth_i ls n =
  let rec iter ls n a =
    if n &lt;= 0 || ls = [] then (List.rev a, ls)
    else iter (List.tl ls) (n - 1) (List.hd ls :: a)
  in
    iter ls n []
</pre>
<pre class="item">
val split_nth : 'a list -&gt; int -&gt; 'a list * 'a list = &lt;fun&gt;
</pre>
<p> split_nth はタプルを使って 2 つの値を返します。一つは取り出した要素を格納したリストで、もう一つが残りのリストです。末尾再帰版は累積変数 a に取り出す要素を格納し、最後に Liet.rev で反転して返しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# split_nth [1; 2; 3; 4; 5; 6] 3;;
- : int list * int list = ([1; 2; 3], [4; 5; 6])
# split_nth [1; 2; 3; 4; 5; 6] 0;;
- : int list * int list = ([], [1; 2; 3; 4; 5; 6])
# split_nth [1; 2; 3; 4; 5; 6] 6;;
- : int list * int list = ([1; 2; 3; 4; 5; 6], [])
</pre>
<p> split_nth を使うと、関数 group で drop を呼び出す必要がなくなります。
</p>
<pre class="list">
リスト 8 : リストの分割 (4)

let rec group_s ls n =
  if ls = [] then []
  else let (a, b) = split_nth ls n in
    a :: group_s b n
</pre>
<p> group_s では split_nth の返り値を局所変数 (a, b) で受け取ります。そして、リスト b に対して group_s を再帰呼び出しして、その返り値にリスト a を追加します。
</p>

<p> もう一つ、リストを分割する関数を作りましょう。関数 partition は述語 pred の返り値 (true, false) でリストを二分割します。次のリストを見てください。
</p>
<pre class="list">
リスト 9 : リストの分割 (4)

let rec partition pred = function
  [] -&gt; ([], [])
| x::xs -&gt; let (a, b) = partition pred xs in
           if pred x then (x::a, b) else (a, x::b)

(* 末尾再帰バージョン *)
let partition_i pred ls =
  let rec iter a b = function
    [] -&gt; (List.rev a, List.rev b)
  | x::xs -&gt; if pred x then iter (x::a) b xs
             else iter a (x::b) xs
  in
    iter [] [] ls
</pre>
<pre class="item">
val partition_i : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list = &lt;fun&gt;
</pre>
<p> 引数のリストが空リストの場合、タプルで空リストを 2 つ返します。次の節で、リストを x と xs に分解します。xs に対して partition を再帰呼び出しして、返り値を (a, b) で受け取ります。そして、pred x が真を返す場合は x を a に追加し、そうでなければ b に追加します。末尾再帰版の場合、pred x が真のときは累積変数 a に、偽のときは累積変数 b に要素 x を追加します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# partition (fun x -&gt; x mod 2 = 0) [1; 2; 3; 4; 5; 6];;
- : int list * int list = ([2; 4; 6], [1; 3; 5])
# partition (fun x -&gt; x mod 3 = 0) [1; 2; 3; 4; 5; 6];;
- : int list * int list = ([3; 6], [1; 2; 4; 5])
</pre>
<h4>●リストの置換</h4>
<p> 次はリストの要素を置換する関数を作ります。関数 substitute は y と等しいリストの要素を全て x に置換します。関数 substitute_if は述語 pred が真を返す要素を全て x に置換します。
</p>
<pre class="list">
リスト 10 : リストの置換

let rec substitute x y = function
  [] -&gt; []
| z::zs -&gt; if y = z then x :: substitute x y zs
           else z :: substitute x y zs

let rec substitute_if x pred = function
  [] -&gt; []
| z::zs -&gt; if pred z then x :: substitute_if x pred zs
           else z :: substitute_if x pred zs
</pre>
<pre class="item">
val substitute : 'a -&gt; 'a -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val substitute_if : 'a -&gt; ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
</pre>
<p> substitute はリストの要素 z が引数 y と等しい場合、その要素を引数 x に置き換えます。そうでなければ、要素 z をそのままリストに追加します。substitute_if は pred z が真を返す場合、その要素を引数 x に置き換えます。そうでなければ、要素 z をそのままリストに追加します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# substitute 1 2 [1; 2; 3; 4; 1; 2; 3; 4];;
- : int list = [1; 1; 3; 4; 1; 1; 3; 4]
# substitute_if 2 (fun x -&gt; x mod 2 = 1) [1; 2; 3; 4; 1; 2; 3; 4];;
- : int list = [2; 2; 2; 4; 2; 2; 2; 4]
</pre>

<h4>●any と every</h4>
<p> 次はリストの要素に述語を適用する関数を作りましょう。関数 any はリストの要素に述語 pred を適用し、一つでも真を返す要素があれば真を返します。関数 every は一つでも偽を返す要素があれば偽を返します。つまり、全てが真の場合にかぎり真を返すことになります。
</p>
<pre class="list">
リスト 11 : any と every

let rec any pred = function
  [] -&gt; false
| x::xs -&gt; if pred x then true else any pred xs

let rec every pred = function
  [] -&gt; true
| x::xs -&gt; if pred x then every pred xs else false
</pre>
<pre class="item">
val any : ('a -&gt; bool) -&gt; 'a list -&gt; bool = &lt;fun&gt;
val every : ('a -&gt; bool) -&gt; 'a list -&gt; bool = &lt;fun&gt;
</pre>
<p> any と every は簡単です。リストを x と xs に分解して、pred x が真を返す場合、any は true を返します。逆に偽を返す場合、every は false を返します。それ以外の場合は再帰呼び出しして次の要素をチェックします。引数のリストが空リストになった場合、any は false を返し、every は true を返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# any (fun x -&gt; x mod 2 = 0) [1; 3; 5; 7; 9];;
- : bool = false
# any (fun x -&gt; x mod 2 = 0) [1; 2; 3; 5; 7; 9];;
- : bool = true
# every (fun x -&gt; x mod 2 = 0) [2; 4; 6; 8; 10];;
- : bool = true
# every (fun x -&gt; x mod 2 = 0) [2; 4; 5; 6; 8; 10];;
- : bool = false
</pre>
<p> なお、OCaml の標準モジュール List には同等の働きをする関数 exists と for_all があります。
</p>

<h4>●マッピング</h4>
<p> マップ関数 map fn xs はリスト xs の要素に関数 fn を適用します。これに対して、関数 maplist は関数 fn にリストそのものを渡します。ただし、繰り返すたびにリストの先頭要素は取り除かれていきます。この動作は Common Lisp の関数 maplist と同じです。プログラムは次のようになります。
</p>
<pre class="list">
リスト 12 : マップ関数 maplist

let rec maplist fn = function
  [] -&gt; []
| _::xs as ls -&gt; (fn ls) :: maplist fn xs
</pre>
<pre class="item">
val maplist : ('a list -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
</pre>
<p> maplist は簡単です。関数 fn に引数のリスト ls をそのまま渡すだけです。maplist を再帰呼び出しするときは、先頭の要素を取り除いたリスト xs を渡します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
# maplist (fun x -&gt; x) [1; 2; 3; 4; 5];;
- : int list list = [[1; 2; 3; 4; 5]; [2; 3; 4; 5]; [3; 4; 5]; [4; 5]; [5]]
# maplist (fun x -&gt; List.fold_left (fun a b -&gt; a + b) 0 x) [1; 2; 3; 4; 5];;
- : int list = [15; 14; 12; 9; 5]
</pre>
<p> maplist を使うと map は次のように定義することができます。
</p>
<pre class="list">
リスト 13 : maplist を使った map の定義

let map fn ls = maplist (fun x -&gt; fn (List.hd x)) ls
</pre>

<h4>●リスト操作関数の一般化</h4>
<p> ところで、今まで説明したリスト操作は次のように一般化することができます。
</p>
<pre class="list">
リスト 14 : リスト操作の一般化

let rec for_each_list fn comb term = function
  [] -&gt; term
| x::xs -&gt; comb (fn x) (for_each_list fn comb term xs)
</pre>
<pre class="item">
val for_each_list : ('a -&gt; 'b) -&gt; ('b -&gt; 'c -&gt; 'c) -&gt; 'c -&gt; 'a list -&gt; 'c = &lt;fun&gt;
</pre>
<p> 関数 for_each_list の引数 fn はリストの要素に適用する関数、comb は fn の返り値と for_each_list の返り値を結合する関数、term はリストの終端で返す値です。プログラムは簡単で、引数のリストが空リストならば term を返します。そうでなければ、リストの要素 x に関数 fn を適用し、その返り値と for_each_list の返り値を関数 comb で結合します。 
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
# for_each_list (fun x -&gt; x) (+) 0 [1; 2; 3; 4; 5];;
- : int = 15
# for_each_list (fun x -&gt; x * x) (+) 0 [1; 2; 3; 4; 5];;
- : int = 55
# for_each_list (fun x -&gt; x) (@) [] [[1; 2]; [3]; [4; 5; 6]];;
- : int list = [1; 2; 3; 4; 5; 6]
</pre>

<p> たとえば、map, filter, fold_right を for_each_list を使ってプログラムすると、次のようになります。
</p>
<pre class="list">
リスト 15 : for_each_list の使用例

let cons a b = a::b

let map fn ls = for_each_list fn cons [] ls

let filter fn ls =
  for_each_list (fun x -&gt; if fn x then [x] else []) (@) [] ls

(* 別解 *)
let filter1 fn ls =
  for_each_list (fun x -&gt; x) (fun x a -&gt; if fn x then x::a else a) [] ls

let fold_right fn a ls =
  for_each_list (fun x -&gt; x) (fun x y -&gt; (fn x y)) a ls
</pre>
<pre class="item">
val cons : 'a -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val filter1 : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b = &lt;fun&gt;
</pre>
<p> 演算子 :: は (::) で関数化することができないので、関数 cons を定義します。map は comb に cons を、term に [ ] を渡せば実現できます。filter はリストの要素 x に関数 fn を適用し、真を返す場合は [x] を返し、偽の場合は [ ] を返します。それを演算子 @ で連結すると、[ ] はリストの要素に含まれないので、フィルターとして動作します。
</p>
<p> filter1 は filter の別解です。(fun x -&gt; x) でリストの要素をそのまま返し、結合する関数 comb の中で引数の関数 fn を呼び出します。返り値が真であれば引数 x を引数 a に追加します。そうでなければ x を a に追加しません。fold_right も簡単です。(fun x -&gt; x) でリストの要素をそのまま返し、要素を連結する関数の中で fn を呼び出します。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
# map (fun x -&gt; x) [1; 2; 3; 4; 5];;
- : int list = [1; 2; 3; 4; 5]
# filter (fun x -&gt; x mod 2 = 0) [1;2; 3; 4; 5];;
- : int list = [2; 4]
# fold_right (+) 0 [1;2;3;4;5];;
- : int = 15
</pre>
<p> ところで、for_each_list を末尾再帰に変換すると次のようになります。
</p>
<pre class="list">
リスト 16 : リスト操作の一般化 (2)

let for_each_list_i fn comb term ls =
  let rec iter a = function
    [] -&gt; a
  | x::xs -&gt; iter (comb (fn x) a) xs
  in
    iter term ls
</pre>
<p> この場合、リストの先頭から関数 fn を適用していくので、map や filter を実現する場合は List.rev で返り値のリストを反転してください。また、fold_left は簡単に実現できますが、fold_right は引数のリスト ls を List.rev rev で反転する必要があります。ご注意くださいませ。
</p>

<p> ところで、for_each_list は関数 fn にリストの要素を渡していますが、このままでは maplist を実現することができません。そこで、要素ではなくリストそのものを渡すことにします。このほうが便利な場合もあります。次のリストを見てください。
</p>
<pre class="list">
リスト 17 : リスト操作の一般化 (3)

let rec for_each_list1 fn comb term = function
  [] -&gt; term
| (_::xs) as ls -&gt; comb (fn ls) (for_each_list1 fn comb term xs)
</pre>
<pre class="item">
val for_each_list1 : ('a list -&gt; 'b) -&gt; ('b -&gt; 'c -&gt; 'c) -&gt; 'c -&gt; 'a list -&gt; 'c = &lt;fun&gt;
</pre>
<p> この場合、for_each_list1 の動作は次のようになります。
</p>
<pre>
# for_each_list1 (fun x -&gt; x) cons [] [1; 2; 3; 4; 5];;
- : int list list = [[1; 2; 3; 4; 5]; [2; 3; 4; 5]; [3; 4; 5]; [4; 5]; [5]]
</pre>
<p> このように、maplist の動作と同じになります。マップ関数、フィルター、畳み込みなどの高階関数は、for_each_list1 を使って次のように定義することができます。
</p>
<pre class="list">
リスト 18 : for_each_list1 の使用例

; マッピング
let map_1 fn ls =
  for_each_list1 (fun xs -&gt; fn (List.hd xs)) cons [] ls

let maplist_1 fn ls =
  for_each_list1 fn cons [] ls

; フィルター
let filter_1 fn ls =
  for_each_list1 List.hd (fun x a -&gt; if fn x then x::a else a) [] ls

; 畳み込み
let fold_right_1 fn a ls =
  for_each_list1 List.hd (fun x y -&gt; fn x y) a ls
</pre>
<pre class="item">
val map_1 : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
val maplist_1 : ('a list -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
val filter_1 : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
val fold_right_1 : ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b = &lt;fun&gt;
</pre>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
# map_1 (fun x -&gt; (x, x)) [1; 2; 3; 4; 5];;
- : (int * int) list = [(1, 1); (2, 2); (3, 3); (4, 4); (5, 5)]
# maplist_1 (fun x -&gt; (List.hd x, List.length x)) [1; 2; 3; 4; 5];;
- : (int * int) list = [(1, 5); (2, 4); (3, 3); (4, 2); (5, 1)]
# filter_1 (fun x -&gt; x mod 2 = 0) [1; 2; 3; 4; 5; 6];;
- : int list = [2; 4; 6]
# fold_right_1 (+) 0 [1; 2; 3; 4; 5; 6];;
- : int = 21
</pre>
<p> もう一つ簡単な例を示しましょう。リストから重複した要素を取り除く関数 remove_dup は、for_each_list1 を使って次のように定義することができます。
</p>
<pre class="list">
リスト 19 : 重複した要素を取り除く

let remove_dup ls =
  for_each_list1
    (fun x -&gt; x)
    (fun (x::xs) a -&gt; if List.mem x xs then a else x::a)
    []
    ls
</pre>
<pre class="item">
val remove_dup : 'a list -&gt; 'a list = &lt;fun&gt;
</pre>
<p> 実行例を示します。
</p>
<pre>
# remove_dup [1; 1; 2; 1; 2; 3; 1; 2; 3; 4; 1; 2; 3; 4; 5];;
- : int list = [1; 2; 3; 4; 5]
</pre>
<h4>●解きほぐし (逆畳み込み)</h4>
<p> ところで、iota や tabulate のようなリストを生成する関数は、次のように一般化することができます。
</p>

<pre class="list">
リスト 20 : 解きほぐし

let rec unfold p f g seed tail_gen =
  if p seed then tail_gen seed
  else f seed :: unfold p f g (g seed) tail_gen

let unfold_right p f g seed tail =
  let rec iter seed a =
    if p seed then a
    else iter (g seed) (f seed :: a)
  in
    iter seed tail
</pre>
<pre class="item">
val unfold :
  ('a -&gt; bool) -&gt;
  ('a -&gt; 'b) -&gt; ('a -&gt; 'a) -&gt; 'a -&gt; ('a -&gt; 'b list) -&gt; 'b list = &lt;fun&gt;
val unfold_right :
  ('a -&gt; bool) -&gt; ('a -&gt; 'b) -&gt; ('a -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'b list = &lt;fun&gt;
</pre>
<p> 関数 unfold と unfold_right は畳み込みを行う fold_right とfold_left の逆変換に相当する処理で、「解きほぐし」とか「逆畳み込み」と呼ばれています。unfold と unfold_right の仕様は Scheme のライブラリ SRFI-1 を参考にしました。
</p>

<p> unfold は値 seed に関数 f を適用し、その要素をリストに格納して返します。引数 p は終了条件を表す関数で、p が真を返すときリストの終端を関数 tail_gen で生成して返します。一般に、tail_gen は空リスト [ ] を返すのが普通です。関数 g は seed の値を更新するために使用します。したがって、生成されるリストの要素は次のようになります。
</p>
<pre class="fig">
( (f (g seed))                   ; g を 1 回適用
  (f (g (g seed)))               ; g を 2 回適用
  (f (g (g (g seed))))           ; g を 3 回適用
  ...
  (f (g (g ... (g seed) ...))) ) ; g を n 回適用
</pre>
<p> リストの長さが n の場合、最後の要素は g を n 回適用し、その結果に f を適用することになります。unfold_right は生成されるリストの要素が unfold の逆になります。また、引数 tail は関数値ではなくリストの終端を表す値になります。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
# unfold (fun x -&gt; x &gt; 10) (fun x -&gt; x) (fun x -&gt; x + 1) 1 (fun _ -&gt; []);;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
# unfold_right (fun x -&gt; x &gt; 10) (fun x -&gt; x) (fun x -&gt; x + 1) 1 [];;
- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
</pre>
<p> このように、unfold を使って iota を実現することができます。また、(fun x -&gt; x) のかわりに他の関数を渡すことで、関数 tabulate と同じ動作を実現できます。
</p>
<p> もう一つ簡単な例を示しましょう。start から始まって増分値が step で合計値が sum 以上になる数列で、要素が最小個数となるものを求めます。次のリストを見てください。
</p>

<pre class="list">
リスト 21 : 合計値が sum 以上になる数列を求める

let unfold_sum sum ?(step=1) start =
  unfold (fun (x, _) -&gt; sum &lt;= x)
         (fun (_, y) -&gt; y)
         (fun (x, y) -&gt; (x + y, y + step))
         (0, start)
         (fun _ -&gt; [])
</pre>
<pre class="item">
val unfold_sum : int -&gt; ?step:int -&gt; int -&gt; int list = &lt;fun&gt;
</pre>
<p> 関数名は unfold_sum としました。プログラムは簡単で、リストの要素を start から始めて step ずつ値を増やしていき、合計値が sum 以上になったらリストの生成を終了します。
</p>
<p> リストの生成中には、要素の値とそれまでの合計値が必要になります。そこで、これらの値をタプル (x, y) にまとめて unfold の seed に渡すことにします。x が合計値で、y が要素の値です。したがって、終了条件は引数の x が sum 以上になったときで、seed の更新は "x + y" と "y + step" の値をタプルでまとめたものになります。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
# fold_right (+) 0 [1; 2; 3; 4; 5];;
- : int = 15
# unfold_sum 15 1;;
- : int list = [1; 2; 3; 4; 5]
# unfold_sum 16 1;;
- : int list = [1; 2; 3; 4; 5; 6]
# fold_right (+) 0 [1; 3; 5; 7; 9];;
- : int = 25
# unfold_sum 25 1 ~step:2;;
- : int list = [1; 3; 5; 7; 9]
# unfold_sum 26 1 ~step:2;;
- : int list = [1; 3; 5; 7; 9; 11]
</pre>
<p> 要素の合計値がちょうど sum にならない場合もありますが、合計値は sum 以上で要素の個数は最小になっています。なお、合計値が sum 以下で、できるだけ sum に近い数列を生成することもできます。興味のある方はプログラムを作ってみてください。
</p>
<p> ところで、unfold と unfold_right の seed は、数値だけではなくリストを渡すこともできます。たとえば、畳み込みを行う fold_right に cons を渡すと copy_list を実現できますが、解きほぐしを行う unfold で List.hd と List.tl を渡しても copy_list を実現することができます。
</p>

<pre>
# fold_right cons [] [1; 2; 3; 4; 5; 6];;
- : int list = [1; 2; 3; 4; 5; 6]
# unfold (fun x -&gt; x = []) List.hd List.tl [1; 2; 3; 4; 5; 6] (fun _ -&gt; []);;
- : int list = [1; 2; 3; 4; 5; 6]
</pre>

<p> また、unfold を使って関数 maplist を実現することもできます。次の例を見てください。
</p>
<pre>
# maplist (fun x -&gt; x) [1; 2; 3; 4; 5];;
- : int list list = [[1; 2; 3; 4; 5]; [2; 3; 4; 5]; [3; 4; 5]; [4; 5]; [5]]
# unfold (fun x -&gt; x = []) (fun x -&gt; x) List.tl [1; 2; 3; 4; 5] (fun _ -&gt; []);;
- : int list list = [[1; 2; 3; 4; 5]; [2; 3; 4; 5]; [3; 4; 5]; [4; 5]; [5]]
</pre>
<p> unfold で (fun x -&gt; x) のかわりに他の関数を渡すと、maplist と同じ動作になります。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2009 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml25.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml27.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>