<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Erlang Problems</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881788</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Erlang Programming</h1>
<h2>Yet Another Erlang Problems</h2>
<div class="small">
[ <a href="yaep03.html">PrevPage</a> | <a href="erlang.html#yaep">Erlang</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h4 id="p66">●問題66</h4>
<p> 自然数 N を素因数分解する関数 factorization(N) を定義してください。返り値はリスト [{P, Q}, ...] で、{P . Q} は P<sup>Q</sup> を表します。
</p>
<pre>
&gt; yaep:factorization(6).
[{2,1},{3,1}]
&gt; yaep:factorization(12345678).
[{2,1},{3,2},{47,1},{14593,1}]
&gt; yaep:factorization(123456789).
[{3,2},{3607,1},{3803,1}]
&gt; yaep:factorization(1234567890).
[{2,1},{3,2},{5,1},{3607,1},{3803,1}]
&gt; yaep:factorization(1111111111).
[{11,1},{41,1},{271,1},{9091,1}]
</pre>
<p> <a href="yaep04.html#ans66">解答66</a>
</p>
<h4 id="p67">●問題67</h4>
<p> 自然数 N の約数の個数を求める関数 divisor_num(N) を定義してください。
</p>
<pre>
&gt; yaep:divisor_num(6).
4
&gt; yaep:divisor_num(12345678).
24
&gt; yaep:divisor_num(123456789).
12
&gt; yaep:divisor_num(1234567890).
48
&gt; yaep:divisor_num(1111111111).
16
</pre>
<p> <a href="yaep04.html#ans67">解答67</a>
</p>
<h4 id="p68">●問題68</h4>
<p> 自然数 N の約数の合計値を求める関数 divisor_sum(N) を定義してください。
</p>
<pre>
&gt; yaep:divisor_sum(6).
12
&gt; yaep:divisor_sum(12345678).
27319968
&gt; yaep:divisor_sum(123456789).
178422816
&gt; yaep:divisor_sum(1234567890).
3211610688
&gt; yaep:divisor_sum(1111111111).
1246404096
</pre>
<p> <a href="yaep04.html#ans68">解答68</a>
</p>
<h4 id="p69">●問題69</h4>
<p> 自然数 N の約数をリストに格納して返す関数 divisor(N) を定義してください。
</p>
<pre>
&gt; yaep:divisor(6).
[1,2,3,6]
&gt; yaep:divisor(12345678).
[1,2,3,6,9,18,47,94,141,282,423,846,14593,29186,43779,87558,
 131337,262674,685871,1371742,2057613,4115226,6172839,
 12345678]
&gt; yaep:divisor(123456789).
[1,3,9,3607,3803,10821,11409,32463,34227,13717421,41152263,
 123456789]
&gt; yaep:divisor(1234567890).
[1,2,3,5,6,9,10,15,18,30,45,90,3607,3803,7214,7606,10821,
 11409,18035,19015,21642,22818,32463,34227,36070,38030,54105,
 57045,64926|...]
&gt; yaep:divisor(1111111111).
[1,11,41,271,451,2981,9091,11111,100001,122221,372731,
 2463661,4100041,27100271,101010101,1111111111]
</pre>
<p> <a href="yaep04.html#ans69">解答69</a>
</p>
<h4 id="p70">●問題70</h4>
<p> <a href="http://ja.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E6%95%B0">完全数 - Wikipedia</a> によると、<CITE>『完全数（かんぜんすう，perfect number）とは、その数自身を除く約数の和が、その数自身と等しい自然数のことである。』</CITE> とのことです。自然数 N 以下の完全数を求める関数 perfect_number(N) を定義してください。
</p>
<pre>
&gt; yaep:perfect_number(10000).
6
28
496
8128
ok
</pre>
<p> <a href="yaep04.html#ans70">解答70</a>
</p>
<h4 id="p71">●問題71</h4>
<p><a href="http://ja.wikipedia.org/wiki/%E5%8F%8B%E6%84%9B%E6%95%B0">友愛数 - Wikipedia</a> によると、<CITE>『友愛数（ゆうあいすう）とは、異なる2つの自然数の組で、自分自身を除いた約数の和が、互いに他方と等しくなるような数をいう。』</CITE> とのことです。自然数 N 以下の友愛数を求める関数 yuuai_number(N) を定義してください。
</p>
<pre>
&gt; yaep:yuuai_number(100000).
{220,284}
{1184,1210}
{2620,2924}
{5020,5564}
{6232,6368}
{10744,10856}
{12285,14595}
{17296,18416}
{63020,76084}
{66928,66992}
{67095,71145}
{69615,87633}
{79750,88730}
ok
</pre>
<p> <a href="yaep04.html#ans71">解答71</a>
</p>
<h4 id="p72">●問題72</h4>
<p> 整数 N を 1 以上の自然数の和で表すことを考えます。これを「整数の分割」といいます。整数を分割するとき、同じ自然数を何回使ってもかまいませんが、並べる順序が違うだけのものは同じ分割とします。簡単な例を示します。
</p>
<pre class="item">
n = 6
6 分割 : 1 + 1 + 1 + 1 + 1 + 1
5 分割 : 1 + 1 + 1 + 1 + 2
4 分割 : 1 + 1 + 1 + 3
         1 + 1 + 2 + 2
3 分割 : 1 + 1 + 4
         1 + 2 + 3
         2 + 2 + 2
2 分割 : 1 + 5
         2 + 4
         3 + 3
1 分割 : 6
</pre>
<p> 6 の場合、分割の仕方は 11 通りあります。この数を「分割数」といいます。自然数 N の分割数を求める関数 partition_number を定義してください。
</p>
<pre>
&gt; lists:foreach(fun(X) -&gt; io:write(yaep:part_num(X)), io:nl() end, yaep:iota(1, 20)).
1
2
3
5
7
11
15
22
30
42
56
77
101
135
176
231
297
385
490
627
ok
</pre>
<p> <a href="yaep04.html#ans72">解答72</a>
</p>
<h4 id="p73">●問題73</h4>
<p> 整数 N の分割の仕方をすべて求める高階関数 partition_of_integer(F, N) を定義してください。
</p>
<pre>
&gt; yaep:partition_of_integer(fun io:write/1, 5).
[5][4,1][3,2][3,1,1][2,2,1][2,1,1,1][1,1,1,1,1]ok
&gt; yaep:partition_of_integer(fun io:write/1, 6).
[6][5,1][4,2][4,1,1][3,3][3,2,1][3,1,1,1][2,2,2][2,2,1,1][2,1,1,1,1][1,1,1,1,1,1]ok
&gt; yaep:partition_of_integer(fun io:write/1, 7).
[7][6,1][5,2][5,1,1][4,3][4,2,1][4,1,1,1][3,3,1][3,2,2][3,2,1,1][3,1,1,1,1]
[2,2,2,1][2,2,1,1,1][2,1,1,1,1,1][1,1,1,1,1,1,1]ok
</pre>
<p> <a href="yaep04.html#ans73">解答73</a>
</p>
<h4 id="p74">●問題74</h4>
<p> M 個の整数 1, 2, ..., M の順列を考えます。このとき、i 番目の要素が整数 i ではない順列を「完全順列」といいます。1 から M までの整数値で完全順列を生成する高階関数 perfect_permutation(F, M) を定義してください。
</p>
<pre>
&gt; yaep:perfect_permutation(fun io:write/1, 3).
[2,3,1][3,1,2]ok
&gt; yaep:perfect_permutation(fun io:write/1, 4).
[2,1,4,3][2,3,4,1][2,4,1,3][3,1,4,2][3,4,1,2][3,4,2,1][4,1,2,3][4,3,1,2][4,3,2,1]ok
</pre>
<p> <a href="yaep04.html#ans74">解答74</a>
</p>
<h4 id="p75">●問題75</h4>
<p> 完全順列の総数を「モンモール数 (Montmort number) 」といいます。モンモール数は次の漸化式で求めることができます。
</p>
<pre class="item">
A<sub>1</sub> = 0
A<sub>2</sub> = 1
A<sub>n</sub> = (n - 1) * (A<sub>n-1</sub> + A<sub>n-2</sub>)  ; n &gt;= 3
</pre>
<p> モンモール数を求める関数 montmort_number を定義してください。
</p>
<pre>
&gt; yaep:montmort_number(1).
0
&gt; yaep:montmort_number(2).
1
&gt; yaep:montmort_number(3).
2
&gt; yaep:montmort_number(4).
9
&gt; yaep:montmort_number(5).
44
&gt; yaep:montmort_number(10).
1334961
&gt; yaep:montmort_number(20).
895014631192902121
&gt; yaep:montmort_number(30).
97581073836835777732377428235481
</pre>
<p> <a href="yaep04.html#ans75">解答75</a>
</p>
<h4 id="p76">●問題76</h4>
<p> リストで表した集合 Xs を分割することを考えます。たとえば、集合 [1, 2, 3] は次のように分割することができます。
</p>
<pre class="item">
1 分割 : [[1, 2, 3]]
2 分割 : [[1, 2]. [3]], [[1, 3] [2]], [[1], [2, 3]]
3 分割 ; [[1], [2], [3]]
</pre>
<p> このように、分割した集合 Ys は元の集合 Xs の部分集合になります。分割した部分集合の積は空集合になり、分割した部分集合のすべての和を求めると元の集合になります。
</p>
<p> Xs の分割の仕方をすべて求める高階関数 parititon_of_set(F, Xs) を定義してください。
</p>
<pre>
&gt; yaep:partition_of_set(fun(X) -&gt; io:write(X), io:nl() end, [1,2,3]).
[[1,2,3]]
[[1],[2,3]]
[[1,2],[3]]
[[1,3],[2]]
[[1],[2],[3]]
ok
&gt; yaep:partition_of_set(fun(X) -&gt; io:write(X), io:nl() end, [1,2,3,4]).
[[1,2,3,4]]
[[1],[2,3,4]]
[[1,2],[3,4]]
[[1,3,4],[2]]
[[1],[2],[3,4]]
[[1,2,3],[4]]
[[1,4],[2,3]]
[[1],[2,3],[4]]
[[1,2,4],[3]]
[[1,3],[2,4]]
[[1],[2,4],[3]]
[[1,2],[3],[4]]
[[1,3],[2],[4]]
[[1,4],[2],[3]]
[[1],[2],[3],[4]]
ok
</pre>
<p> <a href="yaep04.html#ans76">解答76</a>
</p>

<h4 id="p77">●問題77</h4>
<p> 集合を分割する方法の総数を「ベル数 (Bell Number) 」といい、次の漸化式で求めることができます。
</p>
<pre class="item">
B(0) = 1
          n
B(n+1) =  Σ <sub>n</sub>Ｃ<sub>k</sub> * B(k)    ; n &gt;= 1
          k=0
</pre>
<p> ベル数を求める関数 bell_number(N) を定義してください。
</p>
<pre>
&gt; yaep:bell_number(0).
1
&gt; yaep:bell_number(1).
1
&gt; yaep:bell_number(2).
2
&gt; yaep:bell_number(3).
5
&gt; yaep:bell_number(4).
15
&gt; yaep:bell_number(5).
52
&gt; yaep:bell_number(10).
115975
&gt; yaep:bell_number(20).
51724158235372
&gt; yaep:bell_number(30).
846749014511809332450147
&gt; yaep:bell_number(40).
157450588391204931289324344702531067
&gt; yaep:bell_number(50).
185724268771078270438257767181908917499221852770
</pre>
<p> <a href="yaep04.html#ans77">解答77</a>
</p>

<h4 id="p78">●問題78</h4>
<p> K 個の要素をもつ集合 Xs を要素数が等しい M 個の部分集合に分割することを考えます。部分集合の要素数 N は K / M になります。分割の仕方をすべて求める高階関数 group_partition(F, N, M, Xs) を定義してください。
</p>
<pre>
&gt; yaep:group_partition(fun(X) -&gt; io:write(X), io:nl() end, 2, 2, [1,2,3,4]).
[[1,2],[3,4]]
[[1,4],[2,3]]
[[1,3],[2,4]]
ok
&gt; yaep:group_partition(fun(X) -&gt; io:write(X), io:nl() end, 2, 3, [1,2,3,4,5,6]).
[[1,2],[3,4],[5,6]]
[[1,4],[2,3],[5,6]]
[[1,3],[2,4],[5,6]]
[[1,2],[3,6],[4,5]]
[[1,6],[2,3],[4,5]]
[[1,3],[2,6],[4,5]]
[[1,2],[3,5],[4,6]]
[[1,5],[2,3],[4,6]]
[[1,3],[2,5],[4,6]]
[[1,6],[2,5],[3,4]]
[[1,5],[2,6],[3,4]]
[[1,6],[2,4],[3,5]]
[[1,4],[2,6],[3,5]]
[[1,5],[2,4],[3,6]]
[[1,4],[2,5],[3,6]]
ok
</pre>
<p> <a href="yaep04.html#ans78">解答78</a>
</p>

<h4 id="p79">●問題79</h4>
<p> 集合を group_partition で分割するとき、その仕方の総数を求める関数 group_partition_number(N, M) を定義してください。引数 N は部分集合の要素数、M は部分集合の個数です。
</p>
<pre>
&gt; yaep:group_partition_number(2, 2).
3
&gt; yaep:group_partition_number(2, 3).
15
&gt; yaep:group_partition_number(3, 3).
280
&gt; yaep:group_partition_number(3, 4).
15400
&gt; yaep:group_partition_number(3, 5).
1401400
</pre>
<p> <a href="yaep04.html#ans79">解答79</a>
</p>
<h4 id="p80">●問題80</h4>
<p> 中置記法で書かれた数式を計算するプログラムを作ってください。演算子は +, -, *, - で、カッコを使用することができます。数式はリストで表すことにします。
</p>
<pre>
&gt; yaep:expression([1, '+', 2, '+', 3, '+', 4]).
10
&gt; yaep:expression([1, '+', 2, '-', 3, '+', 4]).
4
&gt; yaep:expression([1, '+', 2, '*', 3, '+', 4]).
11
&gt; yaep:expression([[1, '+', 2], '*', [3, '+', 4]]).
21
&gt; yaep:expression([[1, '+', 2], '/', [3, '+', 4]]).
0.42857142857142855
&gt; yaep:expression([[1, '+', 2], '/', [3, '-', 4]]).
-3.0
</pre>
</DIV>
<HR>
<DIV class="contents">
<h4 id="ans66">●解答66</h4>
<pre class="list">
リスト : 素因数分解

factor_sub(N, M, C) when N rem M =/= 0 -&gt; {N, C};
factor_sub(N, M, C) -&gt; factor_sub(N div M, M, C + 1).

factor_loop(I, N, A) when N &lt; I * I -&gt;
  if
    N &gt; 1 -&gt; lists:reverse([{N, 1} | A]);
    true -&gt; lists:reverse(A)
  end;
factor_loop(I, N, A) -&gt;
  {M, C} = factor_sub(N, I, 0),
  I2 = I + 2,
  if
    C &gt; 0 -&gt; factor_loop(I2, M, [{I, C} | A]);
    true -&gt; factor_loop(I2, N, A)
  end.

factorization(N) -&gt;
  {M, C} = factor_sub(N, 2, 0),
  if
    C &gt; 0 -&gt; factor_loop(3, M, [{2, C}]);
    true  -&gt; factor_loop(3, N, [])
  end.
</pre>
<p> 素因数分解は素数 2, 3, 5, ... で順番に割り算していけばいいのですが、いちいち素数を求めるのは大変なので、2 と 3 以上の奇数列で割り算していきます。関数 factor_sub は N を M で割り算します。このとき、M で割り切れる回数を求めます。factor_sub は M で割った回数と商をタプルに格納して返します。
</p>

<p> 関数 factor_loop は奇数列を生成します。変数 I は 3 で初期化します。A は結果を格納するリストです。N が 1 になる、または √N &lt; I になったら繰り返しを終了します。そうでなければ、factor_sub を呼び出して N を I で割り算します。奇数列には素数ではないものがありますが、その前に小さな素数で素因数分解されているので、N がその値で割り切れることはありません。あとは、2 で割り算してから factor_loop を呼び出すだけです。
</p>

<h4 id="ans67">●解答67</h4>
<p> 整数 N の素因数分解ができると、約数の個数を求めるのは簡単です。N = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> とすると、約数の個数は (a + 1) * (b + 1) * (c + 1) になります。たとえば、12 は 2<sup>2</sup> * 3<sup>1</sup> になるので、約数の個数は 3 * 2 = 6 になります。実際、12 の約数は 1, 2, 3, 4, 6, 12 の 6 個です。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数の個数

divisor_num(N) -&gt;
  lists:foldl(fun ({_, X}, A) -&gt; A * (X + 1) end, 1, factorization(N)).
</pre>
<p> divisor_num は lists:foldl を使って X + 1 を a に掛け算していくだけです。 
</p>

<h4 id="ans68">●解答68</h4>
<p> 整数 N の素因数分解ができると、約数の合計値を求めるのは簡単です。N の素因数分解が p<sup>a</sup> だった場合、その約数の合計値は次の式で求めることができます。
</p>
<pre class="item">
σ(p, a) = p<sup>a</sup> + p<sup>a-1</sup> + ... + p<sup>2</sup> + p + 1
</pre>
<p> たとえば、8 の素因数分解は 2<sup>3</sup> になり、素数の合計値は 8 + 4 + 2 + 1 = 15 になります。
</p>
<p> p<sup>a</sup> の約数の合計値を σ(p, a) で表すことにします。n = p<sup>a</sup> * q<sup>b</sup> * r<sup>c</sup> の場合、n の約数の合計値は σ(p, a) * σ(q, b) * σ(r, c) になります。たとえば、12 は 2<sup>2</sup> * 3 に素因数分解できますが、その合計値は (4 + 2 + 1) * (3 + 1) = 28 となります。12 の約数は 1, 2, 3, 4, 6, 12 なので、その合計値は確かに 28 になります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数の合計値

% 整数の累乗
pow(_, 0) -&gt; 1;
pow(X, Y) when Y &gt; 0, Y rem 2 =:= 0 -&gt;
    Z = pow(X, Y div 2),
    Z * Z;
pow(X, Y) when Y &gt; 0 -&gt;
    Z = pow(X, Y div 2),
    X * Z * Z.

prime_sum(_, 0, A) -&gt; A + 1;
prime_sum(P, N, A) -&gt; prime_sum(P, N - 1, A + pow(P, N)).

divisor_sum(N) -&gt;
  lists:foldl(fun({P, M}, A) -&gt; prime_sum(P, M, 0) * A end, 1, factorization(N)).
</pre>
<p> 関数 prime_sub は σ(p, n) を計算します。あとは lists:foldl で prime_sub の返り値を累積変数 a に掛け算していくだけです。
</p>

<h4 id="ans69">●解答69</h4>
<p> p が素数の場合、p<sup>a</sup> の約数は次のように簡単に求めることができます。
</p>
<pre class="item">
p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1
</pre>
<p> n の素因数分解が p<sup>a</sup> * q<sup>b</sup> だったとすると、その約数は次のようになります。
</p>
<pre class="item">
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>b-1</sup>,
        .....
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q<sup>2</sup>,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * q,
(p<sup>a</sup>, p<sup>a-1</sup>, ... p<sup>2</sup>, p, 1) * 1
</pre>
<p> たとえば、12 の約数は 2<sup>4</sup> = (1, 2, 4) と 3 = (1, 3) から、(1, 2, 4) * 1 と (1, 2, 4) * 3 のすべての要素 (1, 2, 4, 3, 6, 12) になります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 約数をすべて求める

% P ^ N の約数を求める
divisor_sub(_, 0, A) -&gt; [1 | A];
divisor_sub(P, N, A) when N &gt; 0 -&gt; divisor_sub(P, N - 1, [pow(P, N) | A]).

divisor_product(Xs, Ys) -&gt; [X * Y || X &lt;- Xs, Y &lt;- Ys].

divisor_sub1([], A) -&gt; A;
divisor_sub1([{P, N} | Xs], A) -&gt;
  divisor_sub1(Xs, divisor_product(A, divisor_sub(P, N, []))).

divisor(N) -&gt; 
  insert_sort(fun(X, Y) -&gt; X &lt; Y end, divisor_sub1(factorization(N), [1])).
</pre>
<p> 関数 divisor_sub は P<sup>N</sup> の約数をリストに格納して返します。関数 divisor_product は 2 つのリスト Xs, Ys の要素を掛け合わせた結果をリストに格納して返します。あとは divisor_sub1 で素因数分解した結果を順番に取り出し、{P, N} を divisor_sub でリストに変換して、それを divisor_product で累積変数 a のリストと掛け合わせていくだけです。
</p>

<h4 id="ans70">●解答70</h4>
<pre class="list">
リスト : 完全数

perfect_number(N, X) when N &lt; X -&gt; ok;
perfect_number(N, X) -&gt;
  M = divisor_sum(X),
  if
    M - X =:= X -&gt; io:write(X), io:nl();
    true -&gt; false
  end,
  perfect_number(N, X + 1).
perfect_number(N) -&gt; perfect_number(N, 2).
</pre>
<p> 完全数を求める perfect_number は簡単です。X の約数の合計値 M を divisor_sub で求め、その値から X を引いた値が X と等しければ完全数です。io:write で X を表示します。
</p>
<h4 id="ans71">●解答71</h4>
<pre class="list">
リスト : 友愛数

yuuai_number(N, X) when N &lt; X -&gt; ok;
yuuai_number(N, X) -&gt;
  M = divisor_sum(X) - X,
  if
    X &lt; M -&gt; M1 = divisor_sum(M),
             if
               X =:= M1 - M -&gt; io:write({X, M}), io:nl();
               true -&gt; false
             end;
    true -&gt; false
  end,
  yuuai_number(N, X + 1).
yuuai_number(N) -&gt; yuuai_number(N, 2).
</pre>
<p> 友愛数を求める yuuai_number も簡単です。divisor_sum で X の約数の合計値を求め、その値から X を引いた値を変数 M にセットします。M の約数の合計値 M1 から M を引いた値が X と等しければ、X と M は友愛数です。io:write で {X, M} を表示します。同じ組を表示しないようにするため、X &lt; M を条件に入れています。
</p>

<h4 id="ans72">●解答72</h4>
<p> 整数 n を k 以下で分割する総数を求める関数を p(n, k) で表します。<a href="yaep04.html#cite1">参考文献 [1]</a> によると、p(n, k) は次の式で表すことができるそうです。
</p>
<pre class="item">
p(n, 1) = 1
p(1, k) = 1
p(0, k) = 1
p(n, k) = p(n - 1, 1) + p(n - 2, 2) + ... + p(n - k, k)
</pre>
<p> r = 1 の場合は簡単ですね。n 個の 1 を選ぶ方法しかありません。同様に n = 1 の場合も、1 を選ぶ方法しかありません。なお、n = 0 の場合は 1 とします。
</p>
<p> p(n, k) の場合、まず 1 を選ぶとすると、残りの n - 1 から 1 で分割する方法は p(n - 1, 1) 通りになります。2 を選ぶとすると、残りの n - 2 から 2 以下で分割する方法は p(n - 2, 2) 通りになります。つまり、1 から k までを選んだあとの分割数を計算し、その総和を求めればいいわけです。
</p>
<p> 簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
p(6, 6) = p(5, 1)

        + p(4, 2) =&gt; p(3, 1) + p(2, 2)
                            =&gt; p(1, 1) + p(0, 2)

        + p(3, 3) =&gt; p(2, 1) + p(1, 2) + p(0, 3)

        + p(2, 4) =&gt; p(1, 1) + p(0, 2) 

        + p(1, 5)

        + p(0, 6)

        = 11 通り
</pre>
<p> p(6, 6) は p(5, 1) + p(4, 2) + p(3, 3) + p(2, 4) + p(1, 5) + p(0, 6) の総和になります。このうち、p(5, 1), p(1, 5), p(0, 6) は 1 になります。p(3, 3) は p(2, 1) + p(1, 2) + p(0, 3) になるので 3 通り、p(2, 4) は p(1, 1) + p(0, 2) になるので、2 通りになります。p(4, 2) はちょっと複雑です。p(4, 2) = p(3, 1) + p(2, 2) になります。ここで、p(2, 2) を求めると p(2, 2) = p(1, 1) + p(0, 2) になるので 2 通りになります。したがって、合計は 11 通りになります。
</p>
<p> これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 分割数

part_num(0, _) -&gt; 1;
part_num(1, _) -&gt; 1;
part_num(_, 1) -&gt; 1;
part_num(N, K) when N &lt; 0; K &lt; 1 -&gt; 0;
part_num(N, K) -&gt;
  part_num(N - K, K) + part_num(N, K - 1).

part_num(N) -&gt; part_num(N, N).
</pre>

<p> 実際の処理は述語 part_num で行います。最初の 3 つの規則で、分割数が 1 になる場合を定義しています。次の規則は N が負または K が 1 未満の場合を表します。この場合、分割数は 0 になります。最後の規則で、p(n - 1, 1) + ... + p(n - k, k) を計算します。プログラムでは K の値をひとつずつ減らしていることに注意してください。なお、このプログラムはナイーブな実装なため、実行速度はとても遅いです。ご注意くださいませ。
</p>

<DIV class="note">
-- <a name="cite1">参考文献</a> -------- <BR>
[1] 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</DIV>

<h4 id="ans73">●解答73</h4>
<pre class="list">
リスト : 整数の分割

part_int(F, 0, _, A) -&gt; F(lists:reverse(A));
part_int(F, 1, _, A) -&gt; F(lists:reverse([1 | A]));
part_int(F, N, 1, A) -&gt; F(lists:reverse(yaep:make_list(1, N) ++ A));
part_int(F, N, K, A) -&gt;
  if 
    N - K &gt;= 0 -&gt; part_int(F, N - K, K, [K | A]);
    true -&gt; false
  end,
  part_int(F, N, K - 1, A).

partition_of_integer(F, N) -&gt; part_int(F, N, N, []).
</pre>
<p> 基本的な考え方は partition_number と同じです。関数 part_int に累積変数 A を追加して、選んだ数値を A に格納していくだけです。N が 0 の場合は F を評価し、N が 1 の場合は A に 1 を追加してから F を評価します。K が 1 の場合は make_list で要素が 1 で長さが N のリストを作成します。そして、それを演算子 ++ で A と連結してから F を評価します。最後の規則で、N - K が 0 以上であれば part_int を再帰呼び出しします。そのあとで、K の値を -1 して part_int を再帰呼び出しします。
</p>

<h4 id="ans74">●解答74</h4>

<pre class="list">
リスト : 完全順列

perfect_perm(F, _, [], A) -&gt; F(lists:reverse(A));
perfect_perm(F, N, Xs, A) -&gt;
  lists:foreach(
    fun(X) -&gt; 
      if
        N =/= X -&gt; perfect_perm(F, N + 1, lists:delete(X, Xs), [X | A]);
        true -&gt; false
      end
    end,
    Xs).
perfect_permutation(F, N) -&gt; perfect_perm(F, 1, iota(1 , N), []).
</pre>
<p> perfect_permutation は簡単です。実際の処理は関数 perfect_perm で行います。iota で 1 から N までの数値を格納したリストを生成し、それを引数 Xs に渡します。引数 N が順番を表します。lists:foreach の無名関数で、数字 X が N と等しくない場合、その数字を選択することできます。等しい場合は選択しません。Xs が空リストになったら、reverse で A を反転して F を評価します。これで完全順列を生成することができます。
</p>

<h4 id="ans75">●解答75</h4>

<pre class="list">
リスト : 完全順列の総数

montmort_number(1) -&gt; 0;
montmort_number(2) -&gt; 1;
montmort_number(N) when N &gt; 2 -&gt;
  (N - 1) * (montmort_number(N - 1) + montmort_number(N - 2)).

% 別解
montmort_number1(N, N, A, _) -&gt; A;
montmort_number1(I, N, A, B) -&gt; montmort_number1(I + 1, N, B, (I + 1) * (A + B)).
mont_mort_number1(N) when N &gt;= 1 -&gt; montmort_number1(1, N, 0, 1).
</pre>
<p> 関数 montmort_number は公式をそのままプログラムしただけです。二重再帰になっているので、実行速度は大変遅くなります。これを繰り返しに変換すると別解のようになります。考え方はフィボナッチ数列と同じです。累積変数 A に i 番目の値を、B に i + 1 番目の値を保存しておきます。すると、i + 2 番目の値は (I + 1) * (A + B) で計算することができます。あとは、B の値を A に、新しい値を B にセットして処理を繰り返すだけです。
</p>
<h4 id="ans76">●解答76</h4>
<p> 集合を分割するアルゴリズムは簡単です。たとえば、n -1 個の要素 x<sub>1</sub>, ..., x<sub>n-1</sub> を持つ集合を分割したところ、i 個の部分集合 S<sub>1</sub>, ..., S<sub>i</sub> が生成されたとしましょう。ここに、n 番目の要素 x<sub>n</sub> を追加すると、要素が n 個の集合を分割することができます。
</p>
<p> 新しい要素を追加する場合は次に示す手順で行います。
</p>
<ol>
  <li>部分集合 S<sub>k</sub> (k = 1 から i まで) に要素 x<sub>n</sub> を追加する
  <li>新しい部分集合 S<sub>i+1</sub> (要素が x<sub>n</sub> だけの集合) を生成する
</ol>
<p> 簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
[] ─ [[1]] ─┬─ [[1, 2]] ─┬─ [[1, 2, 3]]
              │              │
              │              └─ [[1, 2], [3]]
              │
              └─ [[1], [2]] ─┬─ [[1, 3], [2]]
                                │
                                ├─ [[1], [2, 3]]
                                │
                                └─ [[1], [2], [3]]

        図 : 集合 [1, 2, 3] を分割する
</pre>
<p> 部分集合を格納するリストを用意します。最初、部分集合は空集合なので空リストに初期化します。次に、要素 1 を追加します。部分集合は空リストなので、手順 1 は適用できません。手順 2 を適用して新しい部分集合 [1] を追加します。
</p>
<p> 次に要素 2 を追加します。[[1]] に 手順 1 を適用すると、部分集合 [1] に要素を追加して [[1, 2]] になります。手順 2 を適用すると、新しい部分集合 [2] を追加して [[1], [2]] になります。最後に 3 を追加します。[[1, 2]] に手順 1 を適用すると [[1, 2, 3]] に、手順 2 を適用すると [[1, 2], [3]] になります。[[1], [2]] に手順 1 を適用すると [[1, 3], [2]] と [[1], [2, 3]] になり、手順 2 を適用すると [[1], [2], [3]] になります。
</p>
<p> このように、簡単な方法で集合を分割することができます。実際にプログラムを作る場合、上図を木と考えて、深さ優先で木をたどると簡単です。次のリストを見てください。
</p>

<pre class="list">
リスト : 集合の分割

part_set(F, [], A) -&gt; F(A);
part_set(F, [X | Xs], A) -&gt;
  lists:foreach(fun(Y) -&gt; part_set(F, Xs, [[X | Y] | lists:delete(Y, A)]) end, A),
  part_set(F, Xs, [[X] | A]).
partition_of_set(F, Xs) -&gt; part_set(F, lists:reverse(Xs), []).
</pre>
<p> 実際の処理は関数 part_set で行います。最初の規則が再帰呼び出しの停止条件です。次の規則の lists:foreach で、部分集合に要素 X を追加します。無名関数 でリスト A から要素 Y を順番に取り出し、A から Y を取り除いたリストに [X | Y] を追加します。最後に、新しい部分集合 [X] を A に追加します。ただし、このままでは要素の並び方が逆順になるので、part_set を呼び出す前に reverse でリスト Xs を反転しています。これで集合の分割をすべて求めることができます。
</p>

<h4 id="ans77">●解答77</h4>
<pre class="list">
リスト : ベル数

fold_with_index(_, _, A, []) -&gt; A;
fold_with_index(F, I, A, [X | Xs]) -&gt;
  fold_with_index(F, I + 1, F(X, I, A), Xs).

bell_number(N, N, [X | _]) -&gt; X;
bell_number(I, N, Bs) -&gt;
  bell_number(I + 1,
              N,
              [fold_with_index(
                 fun(X, K, A) -&gt; A + comb_num(I, K) * X end,
                 0,
                 0,
                 Bs) | Bs]).
bell_number(N) -&gt; bell_number(0, N, [1]).
</pre>
<p> bell_number は公式をそのままプログラムするだけです。累積変数 Bs にベル数を逆順で格納します。<sub>n</sub>Ｃ<sub>k</sub> は関数 comb_num で求めます。<sub>n</sub>Ｃ<sub>k</sub> * B(k) の総和は関数 fold_with_index で計算します。fold_with_index は添字を関数に渡して畳み込みを行います。無名関数の引数 X がリストの要素、K が添字、A が累積変数です。Bs は逆順になっていますが、二項係数は <sub>n</sub>Ｃ<sub>i</sub> と <sub>n</sub>Ｃ<sub>n - i</sub> の値が同じになるので、そのまま計算しても大丈夫です。もちろん、reverse で Bs を逆順にしてから計算してもかまいません。
</p>

<h4 id="ans78">●解答78</h4>
<pre class="list">
リスト : 集合のグループ分け

group_part(F, _, _, [], A) -&gt; F(A);
group_part(F, N, M, [X | Xs], A) -&gt;
  lists:foreach(fun(Y) -&gt;
      if
        length(Y) &lt; N -&gt; group_part(F, N, M, Xs, [[X | Y] | lists:delete(Y, A)]);
        true -&gt; false
      end
    end,
    A),
  if
    length(A) &lt; M -&gt; group_part(F, N, M, Xs, [[X] | A]);
    true -&gt; ok
  end.
group_partition(F, N, M, Xs) -&gt; group_part(F, N, M, lists:reverse(Xs), []).
</pre>
<p> group_partition は partition_of_set を改造するだけで簡単に作成することができます。生成する部分集合の大きさを N に、部分集合の個数を M に制限するだけです。部分集合 Y に X を追加する場合、length(Y) &lt; N であることをチェックします。新しい部分集合 [X] を追加する場合、length(A) &lt; M であることをチェックします。これで集合をグループに分けることができます。
</p>

<h4 id="ans79">●解答79</h4>
<p> グループ分けの総数は次の式で求めることができます。
</p>
<pre class="item">
k = n * m
<sub>k</sub>Ｃ<sub>n</sub> * <sub>k-n</sub>Ｃ<sub>n</sub> * <sub>k-2*n</sub>Ｃ<sub>n</sub> * ... * <sub>2*n</sub>Ｃ<sub>n</sub> * <sub>n</sub>Ｃ<sub>n</sub> / m!
</pre>
<p> たとえば、n = 3, m = 5 の場合は次のようになります。
</p>
<pre class="fig">
<sub>15</sub>Ｃ<sub>3</sub> * <sub>12</sub>Ｃ<sub>3</sub> * <sub>9</sub>Ｃ<sub>3</sub> * <sub>6</sub>Ｃ<sub>3</sub> * <sub>3</sub>Ｃ<sub>3</sub> / 5! = 1401400
</pre>
<p> これをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : グループ分けの総数

fact(0) -&gt; 1;
fact(N) when N &gt; 0 -&gt; N * fact(N - 1).

group_part_num(0, _, M, A) -&gt; A div fact(M);
group_part_num(K, N, M, A) -&gt; group_part_num(K - N, N, M, A * comb_num(K, N)).

group_partition_number(N, M) -&gt; group_part_num(N * M, N, M, 1).
</pre>
<p> 階乗は関数 fact で、組み合わせの個数は関数 comb_num で計算します。要素の個数を変数 K にセットし、累積変数 a に comb_num(K, N) を乗算します。あとは K から N を減算し、K が 0 でなければ処理を繰り返すだけです。最後に A div fact(M) を計算して返します。
</p>
<h4 id="ans80">●解答80</h4>
<p> <a href="yaep04.html#cite2">参考文献 [1]</a> の「式の評価」によると、四則演算の数式は次の構文規則で表すことができます。
</p>
<pre class="item">
式 := 項 (+ | -) 項 (+ | -) 項 ...
項 :- 因子 (* | /) 因子 (* | /) 因子 ...
因子 := 数 | (式)
</pre>
<p> これをそのままプログラムすると、次のようになります。
</p>
<pre class="list">
リスト : 数式の計算 (中置記法)

% 因子の評価
factor([X | Xs]) when is_number(X) -&gt; {X, Xs};
factor([X | Xs]) when is_list(X) -&gt; {expression(X), Xs}.

% 項の評価
term_sub(V, [X | Xs]) when X =:= '*' -&gt;
  {Y, Ys} = factor(Xs), term_sub(V * Y, Ys);
term_sub(V, [X | Xs]) when X =:= '/' -&gt;
  {Y, Ys} = factor(Xs), term_sub(V / Y, Ys);
term_sub(V, Xs) -&gt; {V, Xs}.

term(Xs) -&gt; {Y, Ys} = factor(Xs), term_sub(Y, Ys).

% 式の評価
expr_sub(V, []) -&gt; V;
expr_sub(V, [X | Xs]) when X =:= '+' -&gt;
  {Y, Ys} = term(Xs), expr_sub(V + Y, Ys);
expr_sub(V, [X | Xs]) when X =:= '-' -&gt;
  {Y, Ys} = term(Xs), expr_sub(V - Y, Ys);

expression(Xs) -&gt; {Y, Ys} = term(Xs), expr_sub(Y, Ys).
</pre>
<p> 関数 expression は「式」を評価します。最初に関数 term を呼び出して「項」を評価します。次に関数 expr_sub を呼び出します。最初の節で、リストが空であれば評価結果 V を返します。演算子が + または - の場合は term を呼び出して評価を行い、返り値を Y と Ys にセットします。そして、V + Y または V - Y を計算します。
</p>
<p> 関数 term も同様の処理を行います。この場合は最初に関数 factor を呼び出して「因子」を評価します。そして、演算子が * または / の場合は factor を呼び出して評価を続行します。そうでなければ、評価結果 V と残りのリスト Xs をタプルに格納して返します。関数 factor は簡単で、リストの先頭要素 X が数値の場合はそれをそのまま返し、リストであればそれを expression に渡して評価します。
</p>
<p> 数値の判定は組み込み関数 is_number で、リストの判定は組み込み関数 is_list で行うことができます。それ以外の場合はマッチングしないのでエラーになります。
</p>

<div class="note">
-- <a name="cite2">参考文献</a> --------<br>
[1] 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="yaep03.html">PrevPage</a> | <a href="erlang.html#yaep">Erlang</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>