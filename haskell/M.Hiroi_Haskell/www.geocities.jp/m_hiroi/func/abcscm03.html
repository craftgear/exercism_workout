<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881781</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm02.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Scheme の基礎知識 (その３)</h3>
<p> 前回は「変数」と「評価」について説明して、基本的なリスト操作を行う関数を紹介しました。今回は「条件分岐」と「再帰定義」について説明します。
</p>

<h4>●条件分岐</h4>
<p> 条件分岐は難しい話ではありません。たとえば、「暑いからアイスコーヒーを飲もう」とか、「雨が降りそうだから傘を持っていこう」というように、私たちはそのときの状況によって自分の行動を決めています。プログラミングの世界でも、状況によって次に実行する処理を選択しなければならないことがよくあります。これを「条件分岐」といいます。
</p>

<p> 先ほどの例では、「暑いから・・・」と「雨が降りそうだから・・・」が「条件」を示しています。ただし、このままでは条件部分があいまいなので、もっと具体的に条件部を書き換えてみます。
</p>

<pre class="item">
  「もしも気温が 30 ℃以上であれば、アイスコーヒーを飲む」
          ~~~~~~~~~~~~~~~~

  「もしも降水確率が 50 ％以上であれば、傘を持っていく」
          ~~~~~~~~~~~~~~~~~~~~
</pre>
<p> これだと条件部がよくわかると思います。そして、実際に「気温が 30 ℃以上になる」ことを「条件を満たす」または「条件が成立する」といいます。条件が成立したときに「アイスコーヒーを飲む」という行動が実行されます。降水確率が 40 ％であれば、条件が成立しないので、「傘を持っていく」という行動は実行されません。
</p>

<p> これを図に示すと、次のようになります。
</p>
<pre class="fig">
      ↓                        ↓
┌─────┐false       ┌─────┐false
│  条  件  │─┐        │  条  件  │─────┐
└─────┘  │        └─────┘          │
      ↓true    │              ↓true            ↓
┌─────┐  │        ┌─────┐    ┌─────┐
│  処理Ａ  │  │        │  処理Ａ  │    │  処理Ｂ  │
└─────┘  │        └─────┘    └─────┘
      │        │              │                │
      ├←───┘              ├←───────┘
      ↓                        ↓

     (1)                        (2)

                 図 : 条件分岐
</pre>
<p> (1) では、「もしも条件を満たすならば、処理 A を実行する」となります。この場合、条件が成立しないと処理は何も実行されませんが、(2) のように条件が成立しない場合でも処理を実行することができます。(2) の場合では、「もしも条件を満たすならば、処理 A を実行し、そうでなければ処理 B を実行する」となります。すなわち、条件によって処理 A か処理 B のどちらかが実行されることになります。
</p>

<p> プログラミングの世界では、条件が成立することを「真 (true) 」といい、条件が不成立のことを「偽 (false) 」といいます。実際のプログラミングでは、true と false を表すデータが必要になります。Scheme の場合、真偽を表すデータ型 (boolean) として #t (真) と #f (偽) が用意されています。Scheme 処理系では #f を偽と判断し、それ以外の値を真と判断します。#t は真を表すデータの代表として使います。
</p>

<p> それでは、Scheme で条件分岐を表してみましょう。Scheme には、条件分岐を実行する関数がいくつかありますが、いちばん簡単な関数が if です。if は英語で「もしも」という意味ですから、まさに条件分岐そのものを表しています。if の基本的な使い方は次のようになります。
</p>

<pre class="item">
(if &lt;条件部&gt; &lt;処理Ａ&gt; &lt;処理Ｂ&gt;)
</pre>

<p> if は 3 つの引数を受け取りますが、シンタックス形式なので評価されずにそのまま if に渡されます。最初に、if は &lt;条件部&gt; を評価します。この評価結果が #f 以外の値であれば、条件を満たしていると判断し、処理 A を評価します。この場合、処理 B は評価されません。評価結果が #f であれば、処理 B を評価します。この場合、処理 A は評価されません。また、条件部が成立したときに実行する処理を「then 節」、不成立のときに実行する処理を「else 節」といいます。
</p>

<h4>●述語</h4>
<p> Scheme (Lisp) では、条件部で使用する関数を「述語 (predicate) 」といいます。述語は真か偽を返す関数です。先ほど説明したように、#f 以外の値は真と判断されるのですが、述語では条件を満たす場合は #t を返します。#t は真を表す代表選手なのです。
</p>

<p> それでは、実際にプログラミングしてみましょう。「もしも気温が 30 ℃以上であれば、アイスコーヒーを飲む」をプログラムしてみましょう。
</p>

<pre class="list">
リスト : 飲物を選ぶプログラム

(define (select-drink degree)
  (if (&lt;= 30 degree)
      (display "Drink ice coffee\n")
      (display "Don't drink ice coffee\n")))
</pre>

<p> 関数名や変数名には、その機能を表す名前をつけるようにしましょう。この場合、名前は selectdrink と続けて書くよりも、間に '-' (ハイフン) を含めたほうが、一目でわかるようになります。関数名にハイフンを使うことができないプログラミング言語では、'_' (アンダーライン) を使って select_drink と書くことで同様の効果を得ることができます。このほかに SelectDrink と大文字を使う場合もあります。一般に、Scheme (Lisp) では単語と単語の間をハイフンで繋ぐことが多いようです。
</p>

<p> select-drink は、気温 degree によって飲物を選びます。&lt;= は数値を比較する述語です。右側の引数が左側の引数以上であれば #t を返し、そうでなければ #f を返します。ここで数値を比較する述語をまとめて紹介しましょう。
</p>

<ol>
  <li>= N1 N2 N3 ...  ==&gt; （N1 ＝ N2 ＝ N3 ＝ .... ）<br>
引数がすべて等しければ #t を、それ以外であれば #f を返す。
  <li>&lt; N1 N2 N3 ... ==&gt; （N1 ＜ N2 ＜ N3 ＜ .... ）<br>
引数を左から見て、単調に増加していれば #t を、それ以外であれば #f を返す。
  <li>&gt; N1 N2 N3 ... ==&gt; （N1 ＞ N2 ＞ N3 ＞ .... ）<br>
引数を左から見て、単調に減少していれば #t を、それ以外であれば #f を返す。
  <li>&lt;= N1 N2 N3 ... ==&gt; （N1 ≦ N2 ≦ N3 ≦ .... ）<br>
引数を左から見て、単調に減少していなければ #t を、それ以外であれば #f を返す。
  <li>&gt;= N1 N2 N3 ... ==&gt; （N1 ≧ N2 ≧ N3 ≧ .... ）<br>
引数を左から見て、単調に増加していなければ #t を、それ以外であれば #f を返す。
</ol>

<p> これらの述語は、右側に書いた数式の関係を満たせば #t を返し、そうでなければ #f を返します。引数は 2 つ以上与えてもかまいません。数値は整数値以外にも浮動小数点数、有理数、複素数を使うことができます。
</p>

<p> それでは実際に select-drink を実行してみましょう。
</p>

<pre>
gosh&gt; (select-drink 35)
Drink ice coffee       &lt;== display による画面表示
#&lt;undef&gt;               &lt;== select-drink の返り値
gosh&gt;
</pre>

<p> まず、述語 (&lt;= 30 degree) が評価されます。degree は 35 なので条件を満たし、then 節である (display "Drink ice coffee\n") が評価されます。display の副作用により画面に Drink ice coffee が表示され、display の返り値が if の返り値となり、それが select-drink の返り値となって #&lt;undef&gt; が表示されます。
</p>

<p> 関数 if は、条件部が不成立になったときに実行する処理を省略することができます。
</p>

<pre class="list">
リスト : 飲物を選ぶプログラム

(define (select-drink1 degree)
  (if (&lt;= 30 degree)
      (display "Drink ice coffee\n")))
</pre>

<p> 条件部が不成立で実行する処理がない場合、Gauche は #&lt;undef&gt; を返します。実際に select-drink1 の引数に 30 未満の数値を与えて試してみてください。
</p>

<h4>●数と算術演算</h4>
<p> ここで、Scheme で用意されている数と算術演算についてまとめておきましょう。Scheme では、整数 (integer)、有理数 (rational)、浮動小数点数 (floating-point number)、複素数 (complex number) という 4 種類の数があります。Gauche でもこれらの数を使うことができます。
</p>

<h4>●整数</h4>
<p> Scheme の場合、整数の大きさには制限がありません。これは Gauche も同じで、5000! や 10000! でも求めることができます。整数は通常 10 進表記ですが、次に示す基数でも書くことができます。
</p>
<ul>
  <li> 2 進表記<BR>
      #b の後ろに 0 と 1 の数値を記述
  <li> 8 進表記<BR>
      #o の後ろに 0 から 7 までの数値を記述
  <li>16 進表記<BR>
      #x の後ろに 0 から f までの数値を記述
</ul>
<p> 簡単な例を示しましょう。
</p>
<pre class="item">
#b10101010 =&gt; 170
#o1234567  =&gt; 342391
#o-127     =&gt; -87
#xabcdef   =&gt; 11259375
</pre>
<h4>●有理数</h4>
<p> Scheme は有理数 (分数) を扱うことができます。有理数は 2 つの整数を / で区切って表します。簡単な例を示します。
</p>
<pre class="item">
1/2, 2/3, 4/3, 11/13, -51/100, 30517578125/32768
</pre>
<p> また、4/6 や 3/12 のような入力もできますが、この場合は約分されることになります。とくに、4/2 のような割り切れる有理数は、ただちに整数に変換されます。次の例を見てください。
</p>
<pre class="item">
4/6  =&gt; 2/3
3/12 =&gt; 1/4
10/5 =&gt; 2    ; 整数に変換される
</pre>
<h4>●浮動小数点数</h4>
<p> Scheme は浮動小数点数を扱うことができます。Scheme の場合、浮動小数点数は一種類だけではなく、短精度 (short)、単精度 (single)、倍精度 (double)、長精度 (long) という 4 つの形式がありますが、すべてをサポートしなければならないわけではなく、処理系によっては 4 つより少なくてもかまいません。<a href="http://practical-scheme.net/gauche/man/gauche-refj_40.html#SEC57">Gauche ユーザリファレンス 6.2 数値</a> によると、<CITE>『実装に使われるC言語のdouble型で表現されます。通常IEEE 64bit浮動少数点数です。』</CITE> とのことです。
</p>

<p> 浮動小数点の表記法は次のようになります。
</p>
<pre class="item">
[+|-] 数字 小数点 数字 指数マーカ [+|-] 数字

例： 0.1234, 1.2345e10, -9.876542999999999e-100
</pre>
<p> なお、指数マーカには s (短精度), f (単精度), d (倍精度), l (長精度), e (デフォルト精度) を使うことができますが、Gauche の浮動小数点数は 1 種類 (double) しかないので、どれを指定しても倍精度の浮動小数点数になります。
</p>

<h4>●複素数</h4>
<p> Scheme は複素数を扱うことができます。形式は "数+数i" または "数-数i"です。最初の数が実部で、虚部の数は後ろに i を付けて表します。簡単な例を示しましょう。
</p>
<pre class="item">
5-3i =&gt; 5.0-3.0i
1.2+2.4i =&gt; 1.2+2.4i
1/2+1/4i =&gt; 0.5+0.25i
</pre>
<p> 実部と虚部の指定には、整数、浮動小数点数、有理数を使うことができますが、Gauche では浮動小数点数に変換して扱います。
</p>

<h4>●算術演算</h4>
<p> 次は簡単な算術演算を説明します。
</p>
<p> + は足し算を、* は掛け算を、- は引き算を行います。これらの関数は引数をいくつでも取ることができます。数以外のデータを引数に与えるとエラーになります。引数の型が異なる場合は強制的に型変換が行われます。簡単な例を示しましょう。
</p>
<pre class="item">
(+)           =&gt; 0
(+ 1)         =&gt; 1
(+ 1 2 3)     =&gt; 6
(+ 1 2 3 1/2) =&gt; 13/2
(+ 1 2 3 4.5) =&gt; 10.5

(*)           =&gt; 1
(* 1)         =&gt; 1
(* 1 2 3)     =&gt; 6
(* 1 2 3 1/4) =&gt; 3/2
(* 1 2 3 4.5) =&gt; 27.0

(- 1)         =&gt; -1
(- 10 5 4)    =&gt; 1
(- 10 5/2)    =&gt; 15/2
(- 10 4.5)    =&gt; 5.5
(-)           =&gt; エラー  ; 引数が足りない
</pre>

<p> / は割り算を行います。整数同士の割り算で割り切れない場合は分数になります。0 で割り算した場合、Gauche は +inf.0 または -inf.0 という無限大を表すデータを返します。
</p>
<pre class="item">
(/ 2)     =&gt; 1/2    ; 引数の逆数を求める
(/ 8 4 2) =&gt; 1      ; 約分されて整数になる
(/)       =&gt; エラー ; 引数が足りない
(/ 1 0)   =&gt; +inf.0 ; 0 で除算した場合
(/ -1 0)  =&gt; -inf.0
</pre>

<p> 2 つの整数 n1 と n2 の商は関数 quotient で、剰余は関数 remainder, modulo で求めることができます。
</p>
<pre class="item">
(quotient 4 2)   =&gt; 2
(remainder 4 2)  =&gt; 0
(modulo 4 2)     =&gt; 0

(quotient 5 2)   =&gt; 2
(remainder 5 2)  =&gt; 1
(modulo 5 2)     =&gt; 1

(quotient -5 2)  =&gt; -2
(remainder -5 2) =&gt; -1
(modulo -5 2)    =&gt; 1

(quotient 5 -2)  =&gt; -2
(remainder 5 -2) =&gt; 1
(modulo 5 -2)    =&gt; -1
</pre>
<p> quotient は n1 / n2 が割り切れない場合、0 の方向へ丸めた値を返します。remainder は n1 / n2 の剰余で、その符号は n1 と同じになります。modulo も n1 / n2 の剰余ですが、その符号は n2 と同じになります。
</p>
<p> このほかにも、Scheme には数値演算に関する関数がたくさん定義されています。興味のある方は Scheme の仕様書 R5RS や <a href="http://practical-scheme.net/gauche/man/gauche-refj.html">Gauche ユーザリファレンス</a> をお読みください。
</p>
<h4>●再帰定義</h4>
<p> 条件分岐が理解できると、同じ処理を何回も繰り返すプログラムを書くことができるようになります。まずは簡単な例として、階乗を計算するプログラムを考えてみます。
</p>

<pre class="item">
階乗の定義
0! = 1
n! = n * (n - 1)!
</pre>

<p> 階乗の定義からわかるように、n の階乗を求めるには (n - 1) の階乗の答えがわかれば求めることができます。実は、これをそのままプログラミングすることができるのです。
</p>

<pre class="list">
リスト : 階乗を計算する

(define (fact n)
    (if (= n 0)
        1
        (* n (fact (- n 1)))))
</pre>

<p> 本当にこれで階乗を計算できるのか、実際に試してみると次のような計算結果となります。
</p>

<pre class="item">
n = 0 =&gt; 1
n = 1 =&gt; 1
n = 2 =&gt; 2
n = 3 =&gt; 6
n = 4 =&gt; 24
n = 5 =&gt; 120
n = 6 =&gt; 720
n = 7 =&gt; 5040
n = 8 =&gt; 40320
n = 9 =&gt; 362880
</pre>

<p> 確かに階乗の答えを求めることができるようです。それでは、関数の処理内容について詳しく見ていきましょう。
</p>

<p> 関数 fact の内容は、「もしも n が 0 ならば 1 を返し、そうでなければ、(* n (fact (- n 1))) を実行する」というものです。条件が成立する場合が、0! = 1 を表していることは直ぐに理解できると思います。問題は条件が不成立になる場合です。(* n (fact (- n 1))) では、n * (n - 1)! を計算しています。この S 式で注目すべき点は、(n - 1)! を求めるときに、関数 fact 自身を再び呼び出しているところです。これを「再帰定義 (recursive definition) 」とか「再帰呼び出し (recursive call) 」といいます
</p>

<p> 関数の定義に自分自身を使うことができるなんて、何か特別な仕掛があるのではないかと思われるかもしれません。筆者が最初に再帰定義を見たときは、ヘビが自分の尻尾を食べていくような奇妙な感覚に陥って、なかなか理解できませんでした。
</p>

<p> ところが、再帰定義は特別なことではありません。ましてや、Scheme (Lisp) の専売特許でもないのです。Ｃ言語や Pascal など近代的なプログラミング言語であれば、再帰定義を使うことができるのです。残念なことですが、Scheme (Lisp) などの関数型言語以外では、再帰定義は難しいテクニックのひとつと思い込んでしまい、初心者の方は避けて通ることが多いように思います。
</p>

<p> 実は、再帰呼び出しは、今まで説明した関数の呼び出しとまったく同じなので、難しく考える必要はないのです。とくに Scheme (Lisp) の場合、再帰定義を積極的に活用してプログラミングを行うので、初心者の方が覚えるべき基礎テクニックのひとつにすぎません。慣れるまでちょっと苦労するかもしれませんが、ポイントさえつかめば簡単に使いこなすことができるようになります。
</p>

<p> それでは、このプログラムの動作を説明します。
</p>
<pre class="fig">
┌───── (fact 4) =&gt; 24 ─────┐
│  n = 4                             │
│  (* 4 (fact 3))                    │
│                                    │
│┌──── (fact 3) =&gt; 6  ────┐│
││  n = 3                         ││
││  (* 3 (fact 2))                ││
││                                ││
││┌─── (fact 2) =&gt; 2  ───┐││
│││  n = 2                     │││
│││  (* 2 (fact 1))            │││
│││                            │││
│││┌── (fact 1) =&gt; 1  ──┐│││
││││  n = 1                 ││││
││││  (* 1 (fact 1))        ││││
││││                        ││││
││││┌─ (fact 0) =&gt; 1  ─┐││││
│││││  n = 0             │││││
│││││  1                 │││││
││││└──────────┘││││
│││└────────────┘│││
││└──────────────┘││
│└────────────────┘│
└──────────────────┘

           図 : 再帰呼び出し
</pre>
<p> fact に 4 を与えて呼び出してみましょう。引数 n には 4 が代入されます。この引数 n の値は (fact 4) が実行されている間有効です。上図では、そのことを枠で示しています。この場合、n は 0 ではないので、else 節が実行されます。最初の枠の中を見てください。ここで n の値から １ 引いた値で自分自身を呼び出しています。
</p>

<p> 次に、2 番目の枠の中を見てください。引数 n には 3 が代入されます。ここで、関数を実行するときの動作を思い出してください。Scheme 処理系は、引数 n に対応するメモリ領域を割り当て、その領域に実引数を書き込み、関数本体を実行するのでしたね。再帰呼び出しであっても、普通の関数呼び出しには違いありません。
</p>
<p> したがって、(fact 3) を実行する場合も、引数 n に対応するメモリ領域を割り当て、そこに実引数である 3 を代入します。つまり、(fact 4) と (fact 3) の呼び出しでは、引数 n に割り当てられるメモリ領域は異なっているのです。ここが再帰呼び出しを理解するポイントのひとつです。
</p>

<ul>
  <li>ポイント１<br>
関数の呼び出しが行われると、引数（局所変数）は新しいメモリ領域に割り当てられる
</ul>

<p> プログラムを見ると引数 n はひとつしかないように見えますが、関数を呼び出すたびに、局所変数は新しいメモリ領域に割り当てられていくのです。したがって、(fact 4) を呼び出したときの n の値が更新されるのではなく、(fact 4) を実行しているときの n は 4 で、(fact 3) を実行しているときの n は 3 なのです。再帰呼び出しが行われるたびに、新しい変数 n がメモリ領域に割り当てられていくと考えてください。
</p>
<p> 同様に (fact 2), (fact 1), (fact 0) と順番に呼び出していきます。(fact 0) の場合、n は 0 ですから then 節が実行されます。ここで再帰呼び出しが止まります。ここが第 2 のポイントです。
</p>

<ul>
  <li>ポイント２<br>
再帰呼び出しを止める条件（停止条件）を設定すること
</ul>

<p> 停止条件を作らなかったり、作ってもその条件を満たさないならプログラムは正常に動作しません。停止条件がなかったり条件を満たさない場合、関数呼び出しが限りなく行われるので、Scheme のシステム資源 (メモリ) を食い潰し、いつかはプログラムの実行ができなくなります。
</p>

<p> (fact 0) は 1 を返します。実行が終了したので、引数 n の値は元に戻ります。これも局所変数の特徴でしたね。では、どの値に戻るのでしょうか。関数を呼び出した場合、それを呼び出した関数に必ず戻ってきます。この場合は (fact 0) が終了したので、(fact 1) の実行に戻るのです。(fact 1) の実行は終了していないので、引数 n の値は 1 に戻ります。図でいえば、実行が終了したら枠が壊れていくと考えてください。いちばん内側の枠が壊れて、その前に値を代入された局所変数が顔を出すのです。
</p>

<p> (fact 0) が 1 を返してきたので、(fact 1) を計算することができます。(* 1 1) を評価して (fact 1) は 1 を返します。同様に、順番に値を計算していき、最後に (fact 4) の値を求めることができるのです。
</p>

<h4>●再帰定義とリスト操作</h4>
<p> 基本的なポイントを押さえたら、あとは「習うより慣れろ」です。そこで、再帰定義を使って、リスト操作を行う関数を作ってみましょう。実は、リスト操作と再帰定義は相性が良いのです。これが Scheme (Lisp) で再帰定義が頻繁に使われる理由でもあります。
</p>

<p> それでは手始めに、リストの n 番目の要素を求めるプログラムを作ってみましょう。Scheme (Lisp) の場合、リストの要素は 0 から数えます。したがって、リストの先頭の要素は 0 番目の要素となります。Scheme には list-ref という関数がありますが、私たちでも簡単にプログラムすることができます。関数名は retrieve とし、引数に数値 n とリスト ls を与えます。
</p>

<p> リスト ls の 0 番目の要素を求めることは簡単に実現できます。リストの先頭の要素を取り出す関数 car を適用すればいいだけです。それでは、n 番目の要素を求めるにはどうしたらいいのでしょうか。実はこれも簡単です。階乗の計算を思い出してください。n! を求めるには (n - 1)! がわかれば十分でした。リスト ls の n 番目の要素は、ls の先頭の要素を取り除いたリストの n - 1 番目の要素がわかればいいのです。
</p>
<pre class="fig">
n : 2  ls : (1 2 3 4)    │
                         │  やさしい問題へ置き換えていく
n : 1  ls : (2 3 4)      │
                         │
n : 0  ls : (3 4)        ↓

=&gt; car を適用し 3 を取り出す

                図 : retrieve の考え方
</pre>
<p> 再帰定義の場合、複雑な問題を簡単な問題へ置き換えるように考えていきます。階乗の場合は、n! が 0! まで簡単になりましたね。この場合も、n 番目の要素を 0 番目の要素になるように再帰させるのです。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : リストの n 番目の要素を取り出す

(define (retrieve ls n)
    (if (zero? n)
        (car ls)
        (retrieve (cdr ls) (- n 1))))
</pre>

<p> 関数 zero? は引数が 0 かチェックする述語です。Scheme の場合、述語には ? マークを付ける習慣があります。述語 zero? は (= 0 n) と同じ働きをします。
</p>

<p> 処理内容は簡単です。もしも n が 0 ならば、リスト ls に car を適用して先頭の要素を返します。これが再帰呼び出しの停止条件になります。そうでなければ、retrieve を再帰呼び出しします。このとき、n の値をひとつ減らし、リスト ls に cdr を適用して先頭の要素を取り除いた値を retrieve に渡します。
</p>

<p> それでは実際に動かしてみましょう。
</p>

<pre>
gosh&gt; (retrieve '(a b c d) 0)
a
gosh&gt; (retrieve '(a b c d) 1)
b
gosh&gt; (retrieve '(a b c d) 2)
c
gosh&gt; (retrieve '(a b c d) 3)
d
</pre>
<p> 正常に動作していますね。
</p>

<p> 次は、前回紹介したリストとリストを結合する関数 append を作ってみましょう。関数名は my-append とし、引数としてリスト x と y を渡して、それを結合したリストを返します。
</p>

<p> 再帰に慣れていないと、どうしたらよいのか見当もつかないかもしれません。retrieve のときと同様に、簡単な場合から考えていきましょう。まず、リスト x が空リスト () ならば、リスト y を返すだけでいいですね。次に、リスト x に要素がひとつしかない場合を考えてみます。これは、リスト x に car を適用して要素を取り出し、それを cons でリスト y の先頭に追加すればいいでしょう。
</p>

<p> ここでちょっと考えてみてください。x が空リストの場合は y をそのまま返しますよね。それでは、「リスト y の先頭に追加する」という処理は、「空リストとリスト y を結合したリストの先頭に追加する」と置き換えることができるはずです。リスト x に cdr を適用すれば空リストになりますから、この処理は再帰定義で実現できるはずです。
</p>
<p> つまり、リスト x とリスト y を結合するには、リスト x の cdr とリスト y を結合したリストに、リスト x の car を cons すればいいのです。これを図に示すと次のようになります。
</p>
<pre class="fig">
┌────────────────────────────┐
│(my-append '(1 2) '(3 4))                               │
├────────────────────────────┤
│ ( 1  2  )                                              │
│  ┬  ── cdr  ─┐                                    │
│ car              ↓                                    │
│  │    ┌──────────────────────┐│
│  │    │(my-append '(2) '(3 4))                     ││
│  │    ├──────────────────────┤│
│  │    │ (  2     )                                 ││
│  │    │    ┬  ─ cdr  ─┐                        ││
│  │    │    car           ↓                        ││
│  │    │    │  ┌────────────────┐││
│  │    │    │  │(my-append () '(3 4)) =&gt; (3 4)  │││
│  │    │    │  └────────────────┘││
│  │    │    │            │                        ││
│  │    │    └→ cons ←─┘                        ││
│  │    │        (2 3 4)                             ││
│  │    └─────┼────────────────┘│
│  └──→ cons ←─┘                                  │
└──────┼─────────────────────┘
              ↓
          (1 2 3 4)

               図 : my-append の動作
</pre>
<p> これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : リストの結合

(define (my-append x y)
    (if (null? x)
        y
        (cons (car x) (my-append (cdr x) y))))
</pre>

<p> 関数 null? は、引数が空リストであれば真を返す述語です。null? のようにデータ型をチェックする述語を「型述語」といいます。このほかにも、次に示すような型述語があります。
</p>

<ul>
  <li>number?   : 数値か？
  <li>integer?  : 整数か？
  <li>real?     : 浮動小数点数か？
  <li>rational? : 有理数か？
  <li>complex?  : 複素数か？
  <li>symbol?   : シンボルか？
  <li>string?   : 文字列か？
  <li>list?     : リストか？
  <li>pair?     : ペア (コンスセル) か？
</ul>

<p> いずれの述語も引数をひとつ取り、引数がテスト条件を満たせば #t を、そうでなければ #f を返します。
</p>

<p> プログラムに戻りましょう。if で ls が空リストかチェックし、そうであればリスト y をそのまま返します。そうでなければ、リスト ls に cdr を適用した値を my-append に渡して再帰呼び出しします。その結果とリスト x の car を cons で接続すればいいのです。それでは、実際に実行してみましょう。
</p>

<pre>
gosh&gt; (my-append '(a b) '(c d))
(a b c d)
gosh&gt; (my-append '((a b) (c d)) '((e f) (g h)))
((a b) (c d) (e f) (g h))
</pre>

<p> 正常に動作していますね。
</p>
<h4>●まとめ</h4>
<p> 今回はここまでです。最後に、今まで説明したことについて、簡単に復習しておきましょう。
</p>
<ol>
<li> 条件分岐には if を使う。
<li> 述語は真か偽を返す関数である。
<li> =, &lt;, &gt;, &lt;=, &gt;= は数値を比較する述語である。
<li> +, -, *, / は算術演算を行う関数である。商は quotient で、剰余は remainder, modulo で求める。
<li> 再帰は関数にそれ自身の呼び出しを許す。
<li> リスト操作は再帰定義を使うと簡単にプログラムできる。
<li> null?, number?, symbol?, string?, list?, pair? などはデータ型の述語である。
</ol>
<p> 次回は「局所変数の定義」と「繰り返し (末尾再帰) 」について説明します。お楽しみに。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2007 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm02.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>