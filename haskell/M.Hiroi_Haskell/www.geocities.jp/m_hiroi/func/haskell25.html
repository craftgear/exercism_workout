<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881791</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell24.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell26.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">配列のソート (2)</h3>
<p> ソートの続きです。今回はクイックソート、ヒープソート、マージソートについて説明します。
</p>
<p> なお、このドキュメントは拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo06.html">整列 [1]</a> <a href="../light/pyalgo07.html">[2]</a> のプログラムを Haskell で書き直したものです。内容は重複しますが、あしからずご了承くださいませ。
</p>
<h4>●クイックソート</h4>
<p> 最初に、高速なソートアルゴリズムとして有名な「クイックソート (quick sort) 」を取り上げます。要素数を N とすると、クイックソートの平均的な実行時間は N * log N に比例しますが、最悪の場合は N の 2 乗に比例する遅いソートになってしまいます。
</p>

<p> クイックソートはある値を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。2 つに分けた各々の区間を同様に分割して 2 つの区間に分けます。最後は区間の要素がひとつになってソートが完了します。
</p>
<pre class="fig">
  9 5 3 7 6 4 2 8     最初の状態

  9 5 3 7 6 4 2 8     7 を枢軸にして左側から 7 以上の値を探し、
  L           R       右側から 7 以下の値を探す。

  2 5 3 7 6 4 9 8     交換する
  L           R

  2 5 3 7 6 4 9 8     検索する
        L   R

  2 5 3 4 6 7 9 8     交換する
        L   R

  2 5 3 4 6 7 9 8     検索する。R と L が交差したら分割終了。
          R L

  [2 5 3 4 6] [7 9 8] この 2 つの区間について再び同様な分割を行う

                図 : クイックソート
</pre>
<p>  基準になる値のことを「枢軸 (pivot) 」といいます。枢軸は要素の中から適当な値を選びます。今回は区間の中央に位置する要素を選ぶことにしましょう。上図を見てください。左側から枢軸 7 以上の要素を探し、左側から 7 以下の要素を探します。探索のときは枢軸が番兵の役割を果たすので、ソート範囲外の要素を探索することはありません。見つけたらお互いの要素を交換します。探索位置が交差したら分割は終了です。
</p>
<p>  あとは同じ手順を分割した 2 つの区間に適用します。これは再帰定義を使えば簡単に実現できます。分割した区間の要素数が 1 になったときが再帰の停止条件になります。プログラムは次のようになります。
</p>
<pre class="list">
リスト : クイックソート (1)

quickSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
quickSort buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high = do
      pv &lt;- readArray buff (low + (high - low) `div` 2)
      (i, j) &lt;- partition pv low high
      when (low &lt; i - 1)  $ qsort low (i - 1)
      when (high &gt; j + 1) $ qsort (j + 1) high
</pre>
<p> 実際の処理は局所関数 qsort で行います。引数 low が区間の下限値、high が区間の上限値です。qsort は buff の low から high までの区間をソートします。最初に、区間の中央にあるデータを枢軸 (pv) として選びます。そして、局所関数 partition で pv を基準にして区間を 2 つに分けます。
</p>

<p> partition では、局所関数 search1 で左側から枢軸以上の要素を探しています。ここでは枢軸以上という条件を、枢軸より小さい間は探索位置を進める、というように置き換えています。同様に局所関数 search2 で右側から枢軸以下の要素を探します。お互いの探索位置 i, j が交差したら分割は終了です。そうでなければお互いの要素を交換します。交換したあとは i と j の値を更新して partition を再帰呼び出しします。
</p>

<p>  そして、分割した区間に対して qsort を再帰呼び出しします。このとき要素数をチェックして、2 個以上ある場合に再帰呼び出しを行います。この停止条件を忘れると正常に動作しません。ご注意ください。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
*Main&gt; a &lt;- newListArray (0,9) [5,6,4,7,3,8,2,9,1,0] :: IO (IOArray Int Int)
*Main&gt; quickSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; b &lt;- newListArray (0,9) [9,8..0] :: IO (IOArray Int Int)
*Main&gt; quickSort b
*Main&gt; getElems b
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; c &lt;- newListArray (0,9) [0..9] :: IO (IOArray Int Int)
*Main&gt; quickSort c
*Main&gt; getElems c
[0,1,2,3,4,5,6,7,8,9]
</pre>
<pre>
  表 : quickSort の結果 (単位 : 秒)

 [IOArray]
 個数  : 乱数   昇順   逆順   山型
-------------------------------------
 40000 : 0.088  0.005  0.010    2.657
 80000 : 0.114  0.000  0.016   10.566
160000 : 0.244  0.016  0.031   42.328
320000 : 0.525  0.031  0.047  169.442

 [IOUArray]
 個数  : 乱数   昇順   逆順   山型
-------------------------------------
 40000 : 0.016  0.005  0.000    2.387
 80000 : 0.026  0.010  0.010    9.542
160000 : 0.052  0.016  0.031   38.080
320000 : 0.109  0.031  0.047  152.085

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>

<p>  クイックソートは、枢軸の選び方で効率が大きく左右されます。区間の中央値 <sup><a href="haskell25.html#note">[*1]</a></sup> を枢軸に選ぶと、区間をほぼ半分に分割することができます。この場合がいちばん効率が良く、データ数を N とすると N * log N に比例する時間でソートすることができます。
</p>

<p>  逆に、区間での最大値または最小値を枢軸に選ぶと、その要素と残りの要素の 2 つに分割にされることになります。これが最悪の場合で、分割のたびに最大値もしくは最小値を選ぶと、実行時間は要素数の 2 乗に比例することになります。つまり、単純挿入ソートと同じくらい遅いソートになります。それだけでなく、要素数が多くなるとスタックがオーバーフローする危険性もあります。
</p>

<p> 今回は区間の中央に位置する要素を枢軸としたので、中央付近に大きい要素があるデータが最悪の場合にあてはまります。つまり、山型データがこのプログラムでは最悪の結果になります。実行結果を見ると、データ数が 2 倍になると実行時間が約 4 倍になっている、つまり N<sup>2</sup> に比例する遅いソートになっていることがわかります。
</p>

<div class="note">
-- <a name="note">note</a> --------<br>
[*1] N 個の要素を昇順に並べたとき、中央に位置する要素 (N / 2 番目の要素) を「中央値」といいます。中央値のことを「メディアン (median) 」と呼びます。
</div>
<h4>●クイックソートの改良</h4>
<p> それでは、クイックソートのプログラムを改良してみましょう。まずは枢軸の選び方を工夫します。区間の中からいくつかの要素を選び、その中で中央値を持つ要素を枢軸とします。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、中央値を選ぶのに時間がかかってしまいます。今回は 9 つの要素を選んで、その中から枢軸を選ぶことにしましょう。
</p>

<p> 次に、2 つに分割した区間の短い方からソートしていきます。そうすると、再帰呼び出しの深さは要素数を N とすると log<sub>2</sub> N 程度におさまります。たとえば、100 万個の要素をソートする場合でも、再帰呼び出しの深さは 20 程度ですみます。最後に、要素数が少なくなったらクイックソートを打ち切り、単純挿入ソートに切り替えます。データ数が少ない場合は、クイックソートよりも単純なソートアルゴリズムの方が高速です。
</p>

<p> まずは枢軸を選択するプログラムを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 枢軸の選択

median3 :: Ord a =&gt; a -&gt; a -&gt; a -&gt; a
median3 a b c =
  if a &gt; b
    then if b &gt; c
           then b
           else if a &lt; c then a else c
    else if b &lt; c
           then b
           else if a &lt; c then c else a

selectPv9 :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO a
selectPv9 buff low high = do
  x1 &lt;- readArray buff low
  x2 &lt;- readArray buff (low + m8)
  x3 &lt;- readArray buff (low + m4)
  x4 &lt;- readArray buff (low + m2 - m8)
  x5 &lt;- readArray buff (low + m2)
  x6 &lt;- readArray buff (low + m2 + m8)
  x7 &lt;- readArray buff (high - m4)
  x8 &lt;- readArray buff (high - m8)
  x9 &lt;- readArray buff high
  return (median3 (median3 x1 x2 x3)
                  (median3 x4 x5 x6)
                  (median3 x7 x8 x9))
  where m2 = (high - low) `div` 2
        m4 = m2 `div` 2
        m8 = m4 `div` 2
</pre>

<p> 関数 median3 は引数 a, b, c の中から中央値を返します。関数 selectPv9 は区間 (low, high) から 9 つの要素を選びます。区間を (0, 1) とすると、0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1 の位置にある要素を選びます。次に、9 つの要素を 3 つのグループ (0, 1/8, 1/4), (3/18, 1/2, 5/8), (3/4, 7/8, 1) に分けて、おのおののグループの中央値を median3 で求めます。さらに、その 3 つから中央値を median3 で選び、その値が枢軸となります。
</p>
<p> M.Hiroi はこの方法をネットで検索して知りました。3 つの要素から枢軸を選ぶ方法を median-of-3 といい、9 つの要素から枢軸を選ぶ方法を median-of-9 と呼ぶようです。今回の方法は 9 つの要素の中から中央値を選択しているわけではありませんが、これでも十分に効果を発揮するようです。
</p>

<p> 次はクイックソートのプログラムを改良します。
</p>
<pre class="list">
リスト : クイックソートの改良

quickSort' :: Ord a =&gt; IOArray Int a -&gt; IO ()
quickSort' buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high =
      if high - low &lt; 16
        then insertSort' buff low high
        else do
          pv &lt;- selectPv9 buff low high
          (i, j) &lt;- partition pv low high
          let a = (i - 1) - low
              b = high - (j + 1)
          if a &lt; b
            then do qsort low (i - 1)
                    qsort (j + 1) high
            else do qsort (j + 1) high
                    qsort low (i - 1)
</pre>

<p> 局所関数 qsort は、最初に high - low の値をチェックして 16 未満になったらクイックソートを打ち切り、単純挿入ソート (insertSort') に切り替えます。区間が 16 以上の場合はクイックソートを行います。区間の分割は今までのプログラムと同じです。そして、短い方の区間からクイックソートします。
</p>

<p> 次は挿入ソートを修正します。関数 insertSort' は次のようになります。
</p>
<pre class="list">
リスト : 単純挿入ソート

search_move :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; a -&gt; Int -&gt; Int -&gt; IO Int
search_move buff low x i g
  | i &lt; low = return (i + g)
  | otherwise = do
      y &lt;- readArray buff i
      if x &lt; y
        then do writeArray buff (i + g) y
                search_move buff low x (i - g) g
        else return (i + g)

insertElement :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; Int -&gt; IO ()
insertElement buff low i gap = do
  tmp &lt;- readArray buff i
  pos &lt;- search_move buff low tmp (i - gap) gap
  writeArray buff pos tmp

insertSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
insertSort buff = do
  (low, high) &lt;- getBounds buff
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)

insertSort' :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
insertSort' buff low high = do
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)
</pre>
<p> insertSort' はソートする区間を引数 low, high で指定します。insertElement と search_move の引数に下限値 low を指定して、引数 i から low までの間でデータを挿入する位置を探します。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
  表 : quickSort' の結果 (単位 : 秒)

 [IOArray]
 個数    乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.104  0.010  0.016  0.026
160000 : 0.239  0.021  0.031  0.052
320000 : 0.504  0.057  0.052  0.099
640000 : 1.082  0.099  0.109  0.224

 [IOUArray]
 個数    乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.021  0.010  0.010  0.021
160000 : 0.047  0.016  0.026  0.036
320000 : 0.104  0.036  0.047  0.083
640000 : 0.218  0.083  0.094  0.172

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>
<p> 昇順、降順のデータは qickSort よりも遅くなりましたが、乱数のデータは quickSort よりも速くなりました。山型のデータも高速にソートすることができます。枢軸の選択を改良した効果は十分に出ていると思います。median-of-9 は少ないコストで最悪のケースを回避する優れた方法だと思います。もちろん、median-of-9 でも最悪のケースが存在するはずですが、最悪のケースに遭遇する確率は median-of-3 よりも低くなると思います。興味のある方はいろいろ試してみてください。
</p>

<h4>●ヒープソート</h4>
<p> ヒープ (heap) は拙作のページ <a href="haskell22.html#chap02">ヒープ</a> で説明したデータ構造です。実は、このヒープを使ったソートも優秀なアルゴリズムの一つです。実行時間は N * log<sub>2</sub> N に比例しますが、平均するとクイックソートよりも遅くなります。しかし、クイックソートとは違って、データの種類によって性能が劣化することはありません。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : ヒープソート

-- 葉の方向に向かってヒープを構築
downheap :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
downheap buff n h = do
  x &lt;- readArray buff n
  iter x n h
  where
    selectChild c1 h = do
      let c2 = c1 + 1
      a &lt;- readArray buff c1
      if c2 &gt; h
        then return (c1, a)
        else do
          b &lt;- readArray buff c2
          if a &lt; b
            then return (c2, b)
            else return (c1, a)
    iter x n h = do
      let c1 = 2 * n + 1
      if c1 &lt;= h
        then do
          (c, y) &lt;- selectChild c1 h
          if x &lt; y
            then do
              writeArray buff n y
              iter x c h
            else writeArray buff n x
        else writeArray buff n x

-- ヒープソート
heapSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
heapSort buff = do
  (low, high) &lt;- getBounds buff
  iterR_ (low, (high - low + 1) `div` 2 - 1)
         (\i -&gt; downheap buff i high)
  iterR_ (low + 1, high)
         (\i -&gt; do swapItem buff 0 i
                   downheap buff 0 (i - 1))
</pre>
<p> heapSort の前半部分で関数 downheap を呼び出してヒープを構築します。親子関係が <a href="haskell22.html#chap02">ヒープ</a> の説明と逆になっていることに注意してください。つまり、親が子より大きいという関係を満たすようにヒープを構築します。したがって、配列の先頭 (buff[0]) が最大値になります。
</p>

<p> 後半部分で、最大値を取り出してヒープを再構築します。配列の先頭には最大値がセットされているので、これを配列の最後尾のデータと交換します。あとは、そのデータを除いた範囲でヒープを再構築すれば、その次に大きいデータを求めることができます。これを繰り返すことで、大きいデータが配列の後ろから整列していくことになります。
</p>

<p> なお、downheap は compItem と swapItem を使わずにプログラムしています。downheap の中で swapItem を呼び出すと、実行速度はかなり遅くなります。ご注意くださいませ。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
*Main&gt; a &lt;- newListArray (0,9) [5,6,4,7,3,8,2,9,1,0] :: IO (IOArray Int Int)
*Main&gt; heapSort a
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; a &lt;- newListArray (0,9) [9,8..0] :: IO (IOArray Int Int)
*Main&gt; heapSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; a &lt;- newListArray (0,9) [0..9] :: IO (IOArray Int Int)
*Main&gt; heapSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
</pre>
<pre>
  表 : heap sort の結果 (単位 : 秒)

 [IOArray]
  個数   乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.130  0.036  0.031  0.042
160000 : 0.302  0.078  0.078  0.083
320000 : 0.744  0.161  0.166  0.198
640000 : 1.929  0.343  0.369  0.432  <a href="haskell25.html#note2">[*2]</a>

 [IOUArray]
  個数   乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.021  0.026  0.021  0.021
160000 : 0.057  0.052  0.052  0.052
320000 : 0.125  0.099  0.104  0.109
640000 : 0.260  0.218  0.208  0.224

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>
<p> このように、ヒープソートはどのデータに対しても、そこそこの速度でソートすることができます。ただし、実行時間はクイックソートよりも遅くなりました。<a href="index.html#cite">参考文献 2</a> によると、ヒープソートの速度はクイックソートの半分くらいといわれています。ヒープソートの処理内容はクイックソートよりも複雑なので、時間がかかるのは仕方がないところでしょう。
</p>
<div class="note">
-- <a name="note2">note</a> --------<br>
[*2] IOArray 版の heapSort は個数 640000 のときにスタックオーバーフローします。次のように、スタックのサイズを実行時に指定してください。
<pre>
C&gt;ghc -O sort1 -rtsopts
[1 of 1] Compiling Main             ( sort1.hs, sort1.o )
Linking sort1.exe ...

C&gt;sort1 heapSort +RTS -K100M
.....
</pre>
ところで、ヒープソートでスタックがオーバーフローする原因がわかりません。何かお気づきの点がありましたらご教示お願いいたします。
</div>
<h4>●マージソート</h4>
<p> マージ（併合 : merge）とはソート済みの複数の列を一つの列にまとめる操作のことです。このマージを使ったソートを「マージソート (merge sort) 」といいます。最初にマージについて簡単に説明します。次の図を見てください。
</p>
<pre class="fig">
      ┌─ (1, 3, 5)  ; リスト a 
 () ←┤
      └─ (2, 4, 6)  ; リスト b 

    小さい方をセットする

       ┌─ (3, 5)    ; リスト a 
 (1) ←┘
            (2, 4, 6) ; リスト b 

    1 をセットする

               (3, 5) ; リスト a 
 (1, 2) ←┐
          └─ (4, 6) ; リスト b 

    2 をセットする

 データがなくなるまで繰り返す

    図 : マージの考え方
</pre>
<p> 2 つのリスト a と b があります。これらのリストはソート済みとしましょう。これらのリストをソート済みのリストにまとめることを考えます。 a と b はソート済みなので先頭のデータがいちばん小さな値です。したがって、上図のように先頭のデータを比較し、小さい方のデータを取り出して順番に並べていけば、ソート済みのリストにまとめることができます。途中でどちらかのリストが空になったら、残ったリストのデータをそのまま追加します。当たり前だと思われるでしょうが、これがマージソート (merge sort) の原理です。次の図を見てください。
</p>

<pre class="fig">
  9 5 3 7 6 4 2 8  最初の状態

 |5 9|3 7|4 6|2 8| 長さ２の列に併合

 |3 5 7 9|2 4 6 8| 長さ４の列に併合 

  2 3 4 5 6 7 8 9  ソート終了

        図 : マージソート
</pre>
<p> マージをソートに応用する場合、最初は各要素をソート済みの配列 (リスト) として考えます。この状態で隣の配列とマージを行い、長さ 2 の配列を作ります。次に、この配列に対して再度マージを行い、長さ 4 の配列を作ります。このように順番にマージしていくと、最後には一つの配列にマージされソートが完了します。
</p>

<p> それではプログラムを作りましょう。配列の長さを 1, 2, 4, 8, ... と増やしていくよりも、再帰的に考えた方が簡単です。マージは 2 つの列を一つの列にまとめる操作です。そこで、まずソートする配列を 2 つに分けて、前半部分をソートします。次に後半部分をソートして、その結果をマージすればいいわけです。
</p>
<p> では、どうやってソートするのかというと、再帰呼び出しするのです。そうすると、どんどん配列を 2 つに割っていくことになり、最後にデータが一つとなります。それはソート済みの配列と考えることができるので、再帰呼び出しを終了してマージ処理に移ることができます。あとはデータを順番にマージしていってソートが完了します。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : マージソート

mergeSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
mergeSort buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOArray Int a)
  msort low high work
  where
    msort low high work
      | high - low &lt; 16 = insertSort' buff low high
      | otherwise = do
          let mid = low + (high - low) `div` 2
          msort low mid work
          msort (mid + 1) high work
          -- low から mid までの要素を work に退避
          iter_ (low, mid) (\i -&gt; do x &lt;- readArray buff i
                                     writeArray work i x)
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  a &lt;- readArray work i
                  b &lt;- readArray buff j
                  if a &lt;= b
                    then do writeArray buff k a
                            merge mid (i + 1) j (k + 1)
                    else do writeArray buff k b
                            merge mid i (j + 1) (k + 1)
              | otherwise =
                  if i &lt;= mid
                    then move i k
                    else return ()
                    where move i k
                            | i &lt;= mid = do x &lt;- readArray work i
                                            writeArray buff k x
                                            move (i + 1) (k + 1)
                            | otherwise = return ()
</pre>
<p> 最初に作業用の配列を newArray_ で生成して、それを局所関数 msort に渡します。今回のプログラムでは、ソートする配列と同じ大きさの作業用領域を用意しましたが、<a href="haskell25.html#cite">参考文献 1</a> によると、作業用領域の大きさはソートする配列の半分ですむそうです。興味のある方はプログラムを改良してください。
</p>
<p> msort は、最初に区間の幅が 16 未満になったかチェックします。そうであれば、単純挿入ソート (insertSort') に切り替えてソートします。この方が少しですが速くなります。これが再帰呼び出しの停止条件になります。区間の幅が 16 以上の場合はマージソートを行います。
</p>
<p> まず列の中央の位置を求めて変数 mid にセットします。最初に前半部、それから後半部をマージソートします。これは msort を再帰呼び出しするだけです。再帰呼び出しから戻ってくると、配列の前半部分と後半部分はソートされているのでマージ処理を行います。この処理を局所関数 merge で行います。
</p>

<p> まず前半部分を作業領域 work に退避してから、merge を呼び出します。前半部分もしくは後半部分どちらかにデータがある間、データの比較と移動を繰り返し行います。前半部分と後半部分を先頭から順番に比較し、小さい方を区間の先頭から順番にセットしていきます。後半部分のデータが先になくなって、作業領域 work にデータが残っている場合は、局所関数 move でデータを後ろに追加します。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
*Main&gt; a &lt;- newListArray (0,9) [5,6,4,7,3,8,2,9,1,0] :: IO (IOArray Int Int)
*Main&gt; mergeSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; a &lt;- newListArray (0,9) [9,8..0] :: IO (IOArray Int Int)
*Main&gt; mergeSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
*Main&gt; a &lt;- newListArray (0,9) [0..9] :: IO (IOArray Int Int)
*Main&gt; mergeSort a
*Main&gt; getElems a
[0,1,2,3,4,5,6,7,8,9]
</pre>
<pre>
  表 : merge sort の結果 (単位 : 秒)

 [IOArray]
 個数  : 乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.120  0.031  0.047  0.036
160000 : 0.244  0.062  0.094  0.078
320000 : 0.452  0.135  0.218  0.172
640000 : 1.087  0.286  0.411  0.354

 [IOUArray]
 個数  : 乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.042  0.016  0.047  0.026
160000 : 0.094  0.052  0.078  0.068
320000 : 0.203  0.109  0.161  0.135
640000 : 0.411  0.234  0.333  0.286

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>

<p> マージソートの実行時間は、要素数を N とすると平均して N * log N に比例します。マージソートはクイックソートと同様に高速なアルゴリズムですが、実際にプログラムを作って比較してみると、クイックソートの方が高速になります。マージソートとヒープソートを比べると、一般的にはマージソートのほうが速いといわれていますが、IOUArray の結果を見ると、ヒープソートのほうが速くなりました。マージソートは配列と作業領域との間でデータの転送が行われます。このときに時間がかかっていると思われます。
</p>

<p> マージソートは配列を単純に二分割していくため、クイックソートと違ってデータの種類によって性能が劣化することはありません。ヒープソートと同様に、どのようなデータに対しても力を発揮してくれるわけです。ただし、ヒープソートとは違って作業領域が必要になります。
</p>

<h4>●マージソートの改良</h4>
<p> ところで、配列 buff と同じ大きさの作業領域 work を使うのであれば、最初に buff を work にコピーしておいて、再帰のたびに buff と work を交互に入れ換えることで、マージソートの実行速度を改善することができます。
</p>
<p> なお、この方法は <a href="http://www.moon.sannet.ne.jp/okahisa/sort/sort.html">C++によるソート(sort)のページ</a> <a href="http://www.moon.sannet.ne.jp/okahisa/sort/node18.html">修正マージソート</a> を参考にさせていただきました。同ページによると、<CITE>『修正マージソートは、Java のクラス型のソートに採用されています。』</CITE> とのことです。有用な情報を公開されている作者様に感謝いたします。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : マージソート (改良版)

mergeSort' :: Ord a =&gt; IOArray Int a -&gt; IO ()
mergeSort' buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOArray Int a)
  copy buff work low high
  msort work buff low high
  where
    copy src dst low high =
      iter_ (low, high) (\i -&gt; do x &lt;- readArray src i
                                  writeArray dst i x)
    msort a b low high
      | high - low &lt; 16 = insertSort' b low high
      | otherwise = do
          let mid = (low + high) `div` 2
          msort b a low mid
          msort b a (mid + 1) high
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  x &lt;- readArray a i
                  y &lt;- readArray a j
                  if x &lt;= y
                    then do writeArray b k x
                            merge mid (i + 1) j (k + 1)
                    else do writeArray b k y
                            merge mid i (j + 1) (k + 1)
              | otherwise = do
                  move a b i mid k
                  move a b j high k
                  where
                    move a b i j k
                      | i &gt; j = return ()
                      | otherwise = do
                          x &lt;- readArray a i
                          writeArray b k x
                          move a b (i + 1) j (k + 1)
</pre>
<p> 最初に、作業用の配列 work を確保して、局所関数 copy で buff の内容を work へコピーします。局所関数 msort a b low high は、配列 a の区間 (low, high) を二分割してソートし、その結果をマージするときに配列 b を使います。したがって、msort は msort work buff low high のように呼び出します。これで配列 buff をソートすることができます。msort を再帰呼び出しするときは、msort b a ... のように a と b を逆にすることに注意してください。
</p>

<p> 二つの区間をソートしたあと、配列 a の前半部分と後半部分はソートされているので、局所関数 merge で 2 つの区間をマージします。二つの区間をマージした結果は配列 b の区間 (low, high) にセットします。改良前の mergeSort では、あらかじめ buff の前半部分を work に退避していましたが、buff を work にコピーしておいて、buff と work を交互に切り替えることで、buff の前半部分を退避する処理が不要になります。最後に、区間内に要素が残っていたら局所関数 move で配列 b に転送します。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
  表 : mergeSort' の結果 (単位 : 秒)

 [IOArray]
 個数  : 乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.151  0.026  0.036  0.036
160000 : 0.218  0.062  0.078  0.062
320000 : 0.406  0.125  0.187  0.140
640000 : 0.983  0.270  0.338  0.302

 [IOUArray]
 個数  : 乱数   昇順   逆順   山型
-----------------------------------
 80000 : 0.031  0.031  0.031  0.026
160000 : 0.073  0.052  0.062  0.062
320000 : 0.146  0.104  0.130  0.120
640000 : 0.328  0.229  0.265  0.255

実行環境 : 実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHC ver 7.4.1
</pre>
<p> mergeSort よりも mergeSort' のほうが速くなりました。改良の効果は十分に出ていると思います。メモリを多く使用することになりますが、このような簡単な方法でマージソートを改良できるとは驚きました。
</p>
<p> なお、プログラムの実行時間は、筆者のコーディング、実行したマシン、使用するプログラミング言語（またはコンパイラ）などの環境に大きく依存しています。また、これらの環境だけではなく、データの種類によっても実行時間は大きく左右されます。興味のある方は、いろいろなデータをご自分の環境で試してみてください。
</p>

<h4 id="cite">●参考文献</h4>
<ol>
  <li>奥村晴彦, 『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
  <li>近藤嘉雪, 『Ｃプログラマのためのアルゴリズムとデータ構造』, ソフトバンク, 1998
</ol>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
--
-- sort1.hs : ソート
--
--            Copyright (C) 2013 Makoto Hiroi
--
import Data.Array.IO
import Control.Monad
import Data.Time
import System.Random
import System.Environment

-- 要素の比較
compItem :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO Ordering
compItem buff i j = liftM2 (compare) (readArray buff i) (readArray buff j)

-- 要素の交換
swapItem :: IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
swapItem buff i j = do
  a &lt;- readArray buff i
  b &lt;- readArray buff j
  writeArray buff i b
  writeArray buff j a

-- イテレータ
iter_ :: (Int, Int) -&gt; (Int -&gt; IO ()) -&gt; IO ()
iter_ (low, high) fn
  | low &gt; high = return ()
  | otherwise  = do
      fn low
      iter_ (low + 1, high) fn

iterR_ :: (Int, Int) -&gt; (Int -&gt; IO ()) -&gt; IO ()
iterR_ (low, high) fn
  | low &gt; high = return ()
  | otherwise  = do
      fn high
      iterR_ (low, high - 1) fn

-- 単純挿入ソート
search_move :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; a -&gt; Int -&gt; Int -&gt; IO Int
search_move buff low x i g
  | i &lt; low = return (i + g)
  | otherwise = do
      y &lt;- readArray buff i
      if x &lt; y
        then do writeArray buff (i + g) y
                search_move buff low x (i - g) g
        else return (i + g)

insertElement :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; Int -&gt; IO ()
insertElement buff low i gap = do
  tmp &lt;- readArray buff i
  pos &lt;- search_move buff low tmp (i - gap) gap
  writeArray buff pos tmp

insertSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
insertSort buff = do
  (low, high) &lt;- getBounds buff
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)

insertSort' :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
insertSort' buff low high = do
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)

-- ヒープソート

-- 葉の方向に向かってヒープを構築
downheap :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO ()
downheap buff n h = do
  x &lt;- readArray buff n
  iter x n h
  where
    selectChild c1 h = do
      let c2 = c1 + 1
      a &lt;- readArray buff c1
      if c2 &gt; h
        then return (c1, a)
        else do
          b &lt;- readArray buff c2
          if a &lt; b
            then return (c2, b)
            else return (c1, a)
    iter x n h = do
      let c1 = 2 * n + 1
      if c1 &lt;= h
        then do
          (c, y) &lt;- selectChild c1 h
          if x &lt; y
            then do
              writeArray buff n y
              iter x c h
            else writeArray buff n x
        else  writeArray buff n x

heapSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
heapSort buff = do
  (low, high) &lt;- getBounds buff
  iterR_ (low, (high - low + 1) `div` 2 - 1)
         (\i -&gt; downheap buff i high)
  iterR_ (low + 1, high)
         (\i -&gt; do swapItem buff 0 i
                   downheap buff 0 (i - 1))

-- クイックソート
quickSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
quickSort buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high = do
      pv &lt;- readArray buff (low + (high - low) `div` 2)
      (i, j) &lt;- partition pv low high
      when (low &lt; i - 1)  $ qsort low (i - 1)
      when (high &gt; j + 1) $ qsort (j + 1) high

median3 :: Ord a =&gt; a -&gt; a -&gt; a -&gt; a
median3 a b c =
  if a &gt; b
    then if b &gt; c
           then b
           else if a &lt; c then a else c
    else if b &lt; c
           then b
           else if a &lt; c then c else a

selectPv9 :: Ord a =&gt; IOArray Int a -&gt; Int -&gt; Int -&gt; IO a
selectPv9 buff low high = do
  x1 &lt;- readArray buff low
  x2 &lt;- readArray buff (low + m8)
  x3 &lt;- readArray buff (low + m4)
  x4 &lt;- readArray buff (low + m2 - m8)
  x5 &lt;- readArray buff (low + m2)
  x6 &lt;- readArray buff (low + m2 + m8)
  x7 &lt;- readArray buff (high - m4)
  x8 &lt;- readArray buff (high - m8)
  x9 &lt;- readArray buff high
  return (median3 (median3 x1 x2 x3)
                  (median3 x4 x5 x6)
                  (median3 x7 x8 x9))
  where m2 = (high - low) `div` 2
        m4 = m2 `div` 2
        m8 = m4 `div` 2

quickSort' :: Ord a =&gt; IOArray Int a -&gt; IO ()
quickSort' buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high =
      if high - low &lt; 16
        then insertSort' buff low high
        else do
          pv &lt;- selectPv9 buff low high
          (i, j) &lt;- partition pv low high
          let a = (i - 1) - low
              b = high - (j + 1)
          if a &lt; b
            then do qsort low (i - 1)
                    qsort (j + 1) high
            else do qsort (j + 1) high
                    qsort low (i - 1)

-- マージソート
mergeSort :: Ord a =&gt; IOArray Int a -&gt; IO ()
mergeSort buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOArray Int a)
  msort low high work
  where
    msort low high work
      | high - low &lt; 16 = insertSort' buff low high
      | otherwise = do
          let mid = low + (high - low) `div` 2
          msort low mid work
          msort (mid + 1) high work
          -- low から mid までの要素を work に退避
          iter_ (low, mid) (\i -&gt; do x &lt;- readArray buff i
                                     writeArray work i x)
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  a &lt;- readArray work i
                  b &lt;- readArray buff j
                  if a &lt;= b
                    then do writeArray buff k a
                            merge mid (i + 1) j (k + 1)
                    else do writeArray buff k b
                            merge mid i (j + 1) (k + 1)
              | otherwise =
                  if i &lt;= mid
                    then move i k
                    else return ()
                    where move i k
                            | i &lt;= mid = do x &lt;- readArray work i
                                            writeArray buff k x
                                            move (i + 1) (k + 1)
                            | otherwise = return ()

-- 改良版
mergeSort' :: Ord a =&gt; IOArray Int a -&gt; IO ()
mergeSort' buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOArray Int a)
  copy buff work low high
  msort work buff low high
  where
    copy src dst low high =
      iter_ (low, high) (\i -&gt; do x &lt;- readArray src i
                                  writeArray dst i x)
    msort a b low high
      | high - low &lt; 16 = insertSort' b low high
      | otherwise = do
          let mid = (low + high) `div` 2
          msort b a low mid
          msort b a (mid + 1) high
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  x &lt;- readArray a i
                  y &lt;- readArray a j
                  if x &lt;= y
                    then do writeArray b k x
                            merge mid (i + 1) j (k + 1)
                    else do writeArray b k y
                            merge mid i (j + 1) (k + 1)
              | otherwise = do
                  move a b i mid k
                  move a b j high k
                  where
                    move a b i j k
                      | i &gt; j = return ()
                      | otherwise = do
                          x &lt;- readArray a i
                          writeArray b k x
                          move a b (i + 1) j (k + 1)

test :: (IOArray Int Int -&gt; IO ()) -&gt; Int -&gt; IO ()
test sort n = do
  let m = n `div` 2
      check i ary 
        | i == n    = return ()
        | otherwise = do
            t &lt;- compItem ary (i - 1) i
            if t == GT then error "test error"
            else check (i + 1) ary
  a &lt;- newListArray (0, n - 1) (take n (randoms (mkStdGen 11) :: [Int])) :: IO (IOArray Int Int)
  b &lt;- newListArray (0, n - 1) [1..n] :: IO (IOArray Int Int)
  c &lt;- newListArray (0, n - 1) [n,n-1..1] :: IO (IOArray Int Int)
  d &lt;- newListArray (0, n - 1) ([1..m] ++ [m,m-1..1]) :: IO (IOArray Int Int)
  x1 &lt;- getCurrentTime
  sort a
  x2 &lt;- getCurrentTime
  check 1 a
  print (diffUTCTime x2 x1)
  x3 &lt;- getCurrentTime
  sort b
  x4 &lt;- getCurrentTime
  check 1 b
  print (diffUTCTime x4 x3)
  x5 &lt;- getCurrentTime
  sort c
  x6 &lt;- getCurrentTime
  check 1 c
  print (diffUTCTime x6 x5)
  x7 &lt;- getCurrentTime
  sort d
  x8 &lt;- getCurrentTime
  check 1 d
  print (diffUTCTime x8 x7)

main :: IO ()
main = do
  let xs2 = [40000, 80000, 160000, 320000, 640000]
  (x:_) &lt;- getArgs
  case x of
    "heapSort"   -&gt; mapM_ (test heapSort)   xs2
    "mergeSort"  -&gt; mapM_ (test mergeSort)  xs2
    "mergeSort'" -&gt; mapM_ (test mergeSort') xs2
    "quickSort"  -&gt; mapM_ (test quickSort)  xs2
    "quickSort'" -&gt; mapM_ (test quickSort') xs2
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
--
-- sortu1.hs : ソート (unboxed type)
--
--            Copyright (C) 2013 Makoto Hiroi
--
import Data.Array.IO
import Control.Monad
import Data.Time
import System.Random
import System.Environment

-- 要素の比較
compItem :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO Ordering
compItem buff i j = liftM2 (compare) (readArray buff i) (readArray buff j)

-- 要素の交換
swapItem :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO ()
swapItem buff i j = do
  a &lt;- readArray buff i
  b &lt;- readArray buff j
  writeArray buff i b
  writeArray buff j a

-- イテレータ
iter_ :: (Int, Int) -&gt; (Int -&gt; IO ()) -&gt; IO ()
iter_ (low, high) fn
  | low &gt; high = return ()
  | otherwise  = do
      fn low
      iter_ (low + 1, high) fn

iterR_ :: (Int, Int) -&gt; (Int -&gt; IO ()) -&gt; IO ()
iterR_ (low, high) fn
  | low &gt; high = return ()
  | otherwise  = do
      fn high
      (iterR_ (low, high - 1) fn)

-- 単純挿入ソート
search_move :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; IO Int
search_move buff low x i g
  | i &lt; low = return (i + g)
  | otherwise = do
      y &lt;- readArray buff i
      if x &lt; y
        then do writeArray buff (i + g) y
                search_move buff low x (i - g) g
        else return (i + g)

insertElement :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; Int -&gt; IO ()
insertElement buff low i gap = do
  tmp &lt;- readArray buff i
  pos &lt;- search_move buff low tmp (i - gap) gap
  writeArray buff pos tmp

insertSort :: IOUArray Int Int -&gt; IO ()
insertSort buff = do
  (low, high) &lt;- getBounds buff
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)

insertSort' :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO ()
insertSort' buff low high = do
  iter_ (low + 1, high) (\i -&gt; insertElement buff low i 1)

-- ヒープソート

-- 葉の方向に向かってヒープを構築
selectChild :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO (Int, Int)
selectChild buff c1 h = do
  let c2 = c1 + 1
  a &lt;- readArray buff c1
  if c2 &gt; h
    then return (c1, a)
    else do
      b &lt;- readArray buff c2
      if a &lt; b
        then return (c2, b)
        else return (c1, a)

downheap :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO ()
downheap buff n h = do
  x &lt;- readArray buff n
  iter x n h
  where
    iter x n h = do
      let c1 = 2 * n + 1
      if c1 &lt;= h
        then do
          (c, y) &lt;- selectChild buff c1 h
          if x &lt; y
            then do
              writeArray buff n y
              iter x c h
            else writeArray buff n x
        else  writeArray buff n x

heapSort :: IOUArray Int Int -&gt; IO ()
heapSort buff = do
  (low, high) &lt;- getBounds buff
  iterR_ (low, (high - low + 1) `div` 2 - 1)
         (\i -&gt; downheap buff i high)
  iterR_ (low + 1, high)
         (\i -&gt; do swapItem buff 0 i
                   downheap buff 0 (i - 1))

-- クイックソート
quickSort :: IOUArray Int Int -&gt; IO ()
quickSort buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high = do
      pv &lt;- readArray buff (low + (high - low) `div` 2)
      (i, j) &lt;- partition pv low high
      when (low &lt; i - 1)  $ qsort low (i - 1)
      when (high &gt; j + 1) $ qsort (j + 1) high

median3 :: Int -&gt; Int -&gt; Int -&gt; Int
median3 a b c =
  if a &gt; b
    then if b &gt; c
           then b
           else if a &lt; c then a else c
    else if b &lt; c
           then b
           else if a &lt; c then c else a

selectPv9 :: IOUArray Int Int -&gt; Int -&gt; Int -&gt; IO Int
selectPv9 buff low high = do
  x1 &lt;- readArray buff low
  x2 &lt;- readArray buff (low + m8)
  x3 &lt;- readArray buff (low + m4)
  x4 &lt;- readArray buff (low + m2 - m8)
  x5 &lt;- readArray buff (low + m2)
  x6 &lt;- readArray buff (low + m2 + m8)
  x7 &lt;- readArray buff (high - m4)
  x8 &lt;- readArray buff (high - m8)
  x9 &lt;- readArray buff high
  return (median3 (median3 x1 x2 x3)
                  (median3 x4 x5 x6)
                  (median3 x7 x8 x9))
  where m2 = (high - low) `div` 2
        m4 = m2 `div` 2
        m8 = m4 `div` 2

quickSort' :: IOUArray Int Int -&gt; IO ()
quickSort' buff = do
  (low, high) &lt;- getBounds buff
  qsort low high
  where
    search1 pv i = do
      x &lt;- readArray buff i
      if pv &gt; x
        then search1 pv (i + 1)
        else return i
    search2 pv j = do
      x &lt;- readArray buff j
      if pv &lt; x
        then search2 pv (j - 1)
        else return j
    partition pv low high = do
      i &lt;- search1 pv low
      j &lt;- search2 pv high
      if i &lt; j
        then do swapItem buff i j
                partition pv (i + 1) (j - 1)
        else return (i, j)
    qsort low high =
      if high - low &lt; 16
        then insertSort' buff low high
        else do
          pv &lt;- selectPv9 buff low high
          (i, j) &lt;- partition pv low high
          let a = (i - 1) - low
              b = high - (j + 1)
          if a &lt; b
            then do qsort low (i - 1)
                    qsort (j + 1) high
            else do qsort (j + 1) high
                    qsort low (i - 1)

-- マージソート
mergeSort :: IOUArray Int Int -&gt; IO ()
mergeSort buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOUArray Int Int)
  msort low high work
  where
    msort low high work
      | high - low &lt; 16 = insertSort' buff low high
      | otherwise = do
          let mid = low + (high - low) `div` 2
          msort low mid work
          msort (mid + 1) high work
          -- low から mid までの要素を work に退避
          iter_ (low, mid) (\i -&gt; do x &lt;- readArray buff i
                                     writeArray work i x)
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  a &lt;- readArray work i
                  b &lt;- readArray buff j
                  if a &lt;= b
                    then do writeArray buff k a
                            merge mid (i + 1) j (k + 1)
                    else do writeArray buff k b
                            merge mid i (j + 1) (k + 1)
              | otherwise =
                  if i &lt;= mid
                    then move i k
                    else return ()
                    where move i k
                            | i &lt;= mid = do x &lt;- readArray work i
                                            writeArray buff k x
                                            move (i + 1) (k + 1)
                            | otherwise = return ()

-- 改良版
mergeSort' :: IOUArray Int Int -&gt; IO ()
mergeSort' buff = do
  (low, high) &lt;- getBounds buff
  work &lt;- newArray_ (low, high) :: IO (IOUArray Int Int)
  copy buff work low high
  msort work buff low high
  where
    copy src dst low high =
      iter_ (low, high) (\i -&gt; do x &lt;- readArray src i
                                  writeArray dst i x)
    msort a b low high
      | high - low &lt; 16 = insertSort' b low high
      | otherwise = do
          let mid = (low + high) `div` 2
          msort b a low mid
          msort b a (mid + 1) high
          -- マージする
          merge mid low (mid + 1) low
          where
            merge mid i j k
              | i &lt;= mid &amp;&amp; j &lt;= high = do
                  x &lt;- readArray a i
                  y &lt;- readArray a j
                  if x &lt;= y
                    then do writeArray b k x
                            merge mid (i + 1) j (k + 1)
                    else do writeArray b k y
                            merge mid i (j + 1) (k + 1)
              | otherwise = do
                  move a b i mid k
                  move a b j high k
                  where
                    move a b i j k
                      | i &gt; j = return ()
                      | otherwise = do
                          x &lt;- readArray a i
                          writeArray b k x
                          move a b (i + 1) j (k + 1)

test :: (IOUArray Int Int -&gt; IO ()) -&gt; Int -&gt; IO ()
test sort n = do
  let m = n `div` 2
      check i ary 
        | i == n    = return ()
        | otherwise = do
            t &lt;- compItem ary (i - 1) i
            if t == GT then error "test error"
            else check (i + 1) ary
  a &lt;- newListArray (0, n - 1) (take n (randoms (mkStdGen 11) :: [Int])) :: IO (IOUArray Int Int)
  b &lt;- newListArray (0, n - 1) [1..n] :: IO (IOUArray Int Int)
  c &lt;- newListArray (0, n - 1) [n,n-1..1] :: IO (IOUArray Int Int)
  d &lt;- newListArray (0, n - 1) ([1..m] ++ [m,m-1..1]) :: IO (IOUArray Int Int)
  x1 &lt;- getCurrentTime
  sort a
  x2 &lt;- getCurrentTime
  --check 1 a
  print (diffUTCTime x2 x1)
  x3 &lt;- getCurrentTime
  sort b
  x4 &lt;- getCurrentTime
  --check 1 b
  print (diffUTCTime x4 x3)
  x5 &lt;- getCurrentTime
  sort c
  x6 &lt;- getCurrentTime
  --check 1 c
  print (diffUTCTime x6 x5)
  x7 &lt;- getCurrentTime
  sort d
  x8 &lt;- getCurrentTime
  --check 1 d
  print (diffUTCTime x8 x7)

main :: IO ()
main = do
  let xs2 = [80000, 160000, 320000, 640000]
  (x:_) &lt;- getArgs
  case x of
    "heapSort"   -&gt; mapM_ (test heapSort)   xs2
    "mergeSort"  -&gt; mapM_ (test mergeSort)  xs2
    "mergeSort'" -&gt; mapM_ (test mergeSort') xs2
    "quickSort"  -&gt; mapM_ (test quickSort)  xs2
    "quickSort'" -&gt; mapM_ (test quickSort') xs2
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell24.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell26.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>