<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881791</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell35.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell37.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Haskell で作る micro Scheme (4)</h3>
<p> 今回は micro Scheme に「マクロ (macro) 」という機能を追加しましょう。define で定義できる関数は引数を評価するタイプで、シンタックス形式のように引数を評価しない関数を定義することはできません。Scheme (Lisp) でプログラミングする場合、ほとんどの処理は define で定義する関数で作ることができますが、シンタックス形式のように引数を評価しない関数を定義した方が便利な場合もあります。このようなとき、役に立つのがマクロです。
</p>

<p> Scheme の場合、マクロは二種類あります。一つは仕様書 (R5RS など) で定義されているマクロで、これを「健全なマクロ」といいます。これに対し、昔から Lisp で使われているマクロを「伝統的なマクロ」といいます。多くの Scheme 処理系では、どちらのマクロも使えるようになっています。健全なマクロは作るのが大変なので、今回は伝統的なマクロを追加することにします。
</p>

<p> まずは最初に伝統的なマクロについて簡単に説明します。
</p>

<h4>●伝統的なマクロ</h4>
<p> Lisp ではマクロを関数のように定義します。伝統的なマクロを定義するには define-macro を使います。
</p>
<pre class="item">
(define-macro マクロ名 (lambda (&lt;仮引数&gt; ...) Ｓ式 ...))
</pre>

<p> define-macro の構文は define と同じです。define-macro で定義されたマクロは、次のような特徴を持ちます。
</p>

<ul>
<li> 引数は評価されない。
<li> S 式を順番に評価し、いちばん最後の評価結果を再度評価して、その結果を返す。
</ul>

<p> この 2 番目の機能が Lisp におけるマクロの特徴です。これを図に示すと、次のようになります。
</p>
<pre class="fig">
[Ｓ式] ─  評価  → [新しいＳ式] ─ 評価 → [マクロの返り値]
      （マクロ展開）

                   図 : マクロの動作
</pre>
<p> S 式を評価することで新しい S 式を組み立てます。この部分がマクロ展開に相当します。そして、その S 式を評価した値がマクロの返り値となります。S 式を組み立てるということは、自動的にプログラムを作ることと同じですね。これは、リストにプログラムとデータの 2 つの役割を持たせている Lisp だからこそ可能なことなのです。
</p>

<p> まず、マクロと関数の違いを理解するために、数を 2 乗する処理をマクロと関数で作ってみましょう。関数は簡単ですね。
</p>
<pre class="list">
リスト : 数を 2 乗する関数

(define square (lambda (x) (* x x)))
</pre>

<p> マクロは次のように定義します。
</p>
<pre class="list">
リスト : 数を 2 乗するマクロ

(define-macro m-square (lambda (x) (list '* x x)))
</pre>

<p> マクロ名は m-square としました。それでは、引数に (+ 1 2) を与えて m-square を評価してみます。
</p>
<pre class="fig">
(m-square (+ 1 2))

仮引数 x に (+ 1 2) がセット（評価されないことに注意）

マクロの本体 (list '* x x) を評価する

=&gt; (* (+ 1 2) (+ 1 2)) （Ｓ式が組み立てられる）

=&gt; 9                   （Ｓ式を評価した結果）

        図 : マクロの実行
</pre>
<p> 関数であれば引数 (+ 1 2) が評価されて、その返り値である 3 が square に渡されますね。マクロの場合、引数は評価されないので、仮引数 x には S 式である (+ 1 2) がそのままセットされます。
</p>
<p> 次に、マクロ本体を評価します。マクロを使いこなすポイントですが、まず評価したい S 式を組み立てることを考えます。最初の評価で S 式を組み立て、それを評価することで目的の処理を実現するのがマクロなのです。
</p>
<p> この場合、引数の 2 乗する (* x x) という S 式を作ればいいわけです。list は引数を要素とする新しいリストを返す関数でしたね。この場合、シンボル * と x の値である (+ 1 2) が要素となったリストが返されます。
</p>
<p> これでマクロ展開が終了しました。マクロの仮引数は、マクロ展開されるときだけ有効です。マクロ展開されたＳ式を評価するときは、それらの値は破棄されます。あとは、この S 式を評価して 9 という値が結果となります。
</p>

<h4>●バッククオート</h4>
<p> ところで、マクロを定義するとき、S 式を組み立てるため list をたくさん使うことになり少々面倒です。実は、「バッククォート ( ` ) 」という機能を使うと、S 式を簡単に組み立てることができます。
</p>
<p> バッククォートはクォート ( ' ) と同様に引数の評価を行いません。ですが、バッククォートの中でコンマ ( , ) で始まる S 式があると、その S 式を評価した値で置き換えられます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define var 'pen)
var
gosh&gt; var
pen
gosh&gt; `(this is a ,var)
(this is a pen)
</pre>

<p> 変数 var にはシンボル pen がセットされています。次の S 式の中で ,var は var を評価した値、つまり pen に置き換わるのです。また、S 式の評価結果がリストの場合は、コンマアットマーク (,@) を使うことができます。,@ を使うと、リストをはずした値と置き換わります。,@ を使う場合、値がリストでなければエラーになります。次の例を見てください。
</p>
<pre>
gosh&gt; (define var '(pen))
var
gosh&gt; var
(pen)
gosh&gt; `(this is a ,var)
(this is a (pen))
gosh&gt; `(this is a ,@var)
(this is a pen)
</pre>
<p> 今度は変数 var にリスト (pen) がセットされました。次の S 式の中で ,varは (pen) に置き換わります。そして、その次の S 式の中では、,@var は pen に置き換わるのです。それから、コンマやコンマアットマークはバッククォートの中でしか使うことができません。ほかの S 式の中で評価した場合はエラーとなります。ご注意ください。
</p>

<h4>●マクロとコンパイラの関係</h4>
<p> 昔の Lisp 処理系では、引数を評価するタイプを EXPR 型や SUBR 型、引数を評価しないタイプを NEXPR 型や FSUBR 型と呼び、ユーザーが NEXPR 型の関数を定義することができました。Scheme や Common Lisp の場合、ユーザーが定義できるのは関数とマクロだけです。シンタックス形式の関数を定義する場合はマクロを使うことになります。
</p>

<p> マクロを実行する場合、必ずマクロ展開が行われるため、通常の関数よりも実行時間は遅くなります。だったら、NEXPR 型の関数を定義できるようにした方が実行速度の点で有利なはずです。ところが、Scheme や Common Lisp では必要最低限のシンタックス形式を定義し、よく使われる制御構造はマクロで定義されています。これではインタプリタでの動作が遅くなります。
</p>

<p> では、なぜ実行速度が遅くなるのにマクロを使っているのでしょう。それは、Common Lisp や多くの Scheme 処理系がコンパイラの使用を前提としているからです。たとえば、Gauche はプログラムをバイトコードにコンパイルしてから実行します。また、Common Lisp の処理系である CLISP も、プログラムをバイトコードにコンパイルすることができます。今の実用的な Scheme (Common Lisp) 処理系のほとんどは、プログラムをバイトコードまたはネイティブコードにコンパイルすることができます。
</p>

<p> プログラムでマクロを呼び出している場所は、コンパイル時にマクロ展開されるため、コンパイル済みのコードにはマクロ呼び出しがなくなってしまうのです。つまり、コンパイル済みのコードは、マクロを呼び出す処理とマクロ展開の処理がなくなることにより、確実にインタプリタよりも高速に実行することができるのです。逆にいえば、コンパイラを使わないとマクロを効果的に使うことはできません。ご注意くださいませ。
</p>

<h4>●マクロの定義</h4>
<p> それではプログラムを作りましょう。まず最初に、マクロを表すデータ型を定義します。
</p>
<pre class="list">
リスト : S 式の定義

type ScmFunc = Env -&gt; SExpr -&gt; Scm SExpr

data SExpr = INT  !Integer
           | REAL !Double
           | SYM  String
           | STR  String
           | CELL SExpr SExpr
           | NIL
           | PRIM ScmFunc
           | SYNT ScmFunc
           | CLOS SExpr LEnv
           | MACR SExpr
</pre>
<p> ScmFunc は PRIM と SYNT の関数の型を表します。今回から PRIM の関数にも環境 Env を渡すように修正します。マクロはシンタックス形式 define-macro で定義します。マクロはラムダ式で表します。マクロのデータ型は MACR SExpr で、引数の SExpr にはラムダ式の評価結果であるクロージャをセットします。この処理を関数 evalDefM で行います。
</p>

<pre class="list">
リスト : マクロの定義

evalDefM :: Env -&gt; SExpr -&gt; Scm SExpr
evalDefM env (CELL sym@(SYM name) (CELL expr NIL)) = do
  v &lt;- eval env expr
  lift $ H.update (fst env) name (MACR v)
  return sym
evalDefM _ _ = throwError $ strMsg "invalid define-macro form"
</pre>
<p> 処理内容は evalDef とほぼ同じですが、eval の返り値 v (クロージャ) を MACR に格納し、それと変数名 name をタプルにまとめて大域変数の環境に追加します。
</p>

<h4>●記号の変換処理</h4>
<p> 次はバッククオートで使用する記号を処理するため、S 式を読み込む関数 readSExpr を修正します。バッククオートで使う記号 (` , ,@) は省略形で、次に示す S 式に変換されます。
</p>
<pre class="item">
`(...) : (quasiquote (...))
,expr  : (unquote expr)
,@expr : (unquote-splicing expr)
</pre>
<p> この変換処理を関数 readSExpr で行います。プログラムは次のようになります。
</p>
<pre class="list">
リスト : S 式の読み込み

quote           = SYM "quote"
quasiquote      = SYM "quasiquote"
unquote         = SYM "unquote"
unquoteSplicing = SYM "unquote-splicing"

readSExpr :: String -&gt; Parser (SExpr, String)
readSExpr [] = throwError $ strMsg "EOF"
readSExpr (x:xs) 
  | isSpace x  = readSExpr xs

      ・・・ 省略 ・・・

  | otherwise  =
      case x of
        '('  -&gt; readCell 0 xs
        ';'  -&gt; readSExpr $ dropWhile (/= '\n') xs
        '"'  -&gt; case reads (x:xs) of
                  [] -&gt; throwError noMsg
                  [(y, ys)] -&gt; return (STR y, ys)
        '\'' -&gt; readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL quote (CELL e NIL), ys)
        '`'  -&gt; readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL quasiquote (CELL e NIL), ys)
        ','  -&gt; if not (null xs) &amp;&amp; head xs == '@'
                  then readSExpr (tail xs) &gt;&gt;= \(e, ys) -&gt; return (CELL unquoteSplicing (CELL e NIL), ys)
                  else readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL unquote (CELL e NIL), ys)
        _    -&gt; throwError $ ParseErr xs ("unexpected token: " ++ show x)
</pre>
<p> 考え方は quote の処理と同じです。x が記号 ` であれば、readSExpr xs で次の S 式を読み込み、CELL quasiquote (CELL e NIL) を返します。記号 , の場合は、次の記号をチェックして、@ であれば CELL unquoteSplicing (CELL e NIL) を返し、そうでなければ CELL unquote (CELL e NIL) を返します。
</p>

<h4>●マクロの評価</h4>
<p> 次は eval にマクロを評価する処理を追加します。
</p>
<pre class="list">
リスト : eval の修正

eval :: Env -&gt; SExpr -&gt; Scm SExpr
eval env NIL        = return NIL

    ・・・ 省略 ・・・

eval env (CELL func args) = do
  v &lt;- eval env func
  case v of
    SYNT f -&gt; f env args
    MACR f -&gt; do expr &lt;- apply env f args
                 eval env expr
    _      -&gt; do vs &lt;- evalArguments env args
                 apply env v vs
</pre>
<p> 引数 func の評価結果がマクロ MACR f の場合、f にはクロージャが格納されているので、それを apply で評価します。このとき、引数 args は評価しないでそのまま渡すことに注意してください。apply の返り値は S 式なので、それを eval で再度評価します。
</p>
<p> もし、S 式の中でマクロが使われていたら、そこでまたマクロ展開が行われ、組み立てられた S 式が評価されます。これでマクロの再帰呼び出しも処理することができます。実行速度は遅くなりますが、たったこれだけの処理でマクロの強力な機能を実現することができます。
</p>

<h4>●高階関数 apply の作成</h4>
<p> 次は高階関数 apply を作りましょう。Scheme の関数 apply は次のように使います。
</p>
<pre class="item">
apply func args-list
</pre>
<p> apply は最初の引数 func を関数として呼び出します。このとき、第 2 引数のリストの要素が func の引数として渡されます。apply は func の評価結果を返します。簡単な使用例を示しましょう。
</p>
<pre>
gosh&gt; (apply + '(1 2 3))
6
gosh&gt; (apply car '((1 2 3)))
1
</pre>
<p> また apply は次のように、func と args-list の間に引数を与えることができます。
</p>
<pre>
gosh&gt; (apply + 4 5 6 '(1 2 3))
21
</pre>
<p> apply はリストに格納されている要素を引数として関数に渡す場合に便利です。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 高階関数 apply

apply' :: ScmFunc
apply' _ (CELL _ NIL) = throwError $ strMsg $ "apply : " ++ errNEA
apply' env (CELL func args) = do
  xs &lt;- iter args
  apply env func xs
  where iter (CELL NIL NIL) = return NIL
        iter (CELL xs@(CELL _ _) NIL) = return xs
        iter (CELL _ NIL) = throwError $ strMsg errCELL
        iter (CELL x xs) = do ys &lt;- iter xs
                              return (CELL x ys)
apply' _ _ = throwError $ strMsg $ "apply : " ++ errNEA
</pre>
<p> 局所関数 iter で、引数を順番に最後尾の引数 (リスト) に追加します。最後尾の引数がリストまたは空リストでなければエラーを返します。あとは、iter の返り値を apply に渡して関数 func を呼び出すだけです。
</p>

<h4>●エラーの送出</h4>
<p> 次はエラーメッセージを表示する micro Scheme の関数 error を作ります。
</p>
<pre class="list">
リスト : エラーの表示

error' :: ScmFunc
error' _ (CELL (STR x) NIL) = throwError $ strMsg $ "ERROR: " ++ x
error' _ (CELL (STR x) (CELL y _)) = throwError $ strMsg $ "ERROR: " ++ x ++ " " ++ show y
error' _ (CELL x _) = throwError $ strMsg $ "ERROR: " ++ show x
error' _ _ = throwError $ strMsg "ERROR: "
</pre>
<p> 関数 error は第 1 引数が文字列で、第 2 引数が S 式です。第 2 引数は省略することができます。第 1 引数が文字列で無い場合はそれをそのまま表示します。引数が無い場合は "ERROR: " だけを表示します。あとは throwError でエラーを返すだけです。
</p>

<h4>●ファイルの読み込み</h4>
<p> 最後にファイルに書かれたプログラムを読み込む micro Scheme の関数 load を作りましょう。ファイル名は文字列で指定します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : ファイルの読み込み (load)

load :: ScmFunc
load env (CELL (STR filename) _) = do
  xs &lt;- lift $ readFile filename
  r &lt;- lift $ iter xs
  if r then return true else return false
  where
    iter :: String -&gt; IO Bool
    iter xs = 
      case readSExpr xs of
        Left  (ParseErr xs' mes) -&gt; if mes == "EOF"
                                      then return True
                                      else do print mes
                                              return False
        Right (expr, xs') -&gt; do result &lt;- runErrorT $ eval env expr 
                                case result of
                                  Left mes -&gt; do print mes
                                                 return False
                                  Right _  -&gt; iter xs'
load _ _ = throwError $ strMsg "invalid load form"
</pre>
<p> 処理内容は repl とほぼ同じです。局所関数 iter でファイルの終了 "EOF" を検出するまでプログラムを読み込み、それを eval で評価するだけです。途中でエラーが返された場合はエラーメッセージを表示して false を返します。プログラムを正常にロードできた場合は true を返します。
</p>

<h4>●簡単な実行例</h4>
<p> それでは実行してみましょう。まず最初に簡単なマクロを試してみます。
</p>
<pre>
Scm&gt; (define-macro m-square (lambda (x) (list '* x x)))
m-square
Scm&gt; (m-square 10)
100
Scm&gt; (define-macro add (lambda (xs) (cons '+ xs)))
add
Scm&gt; (add (1 2 3 4 5))
15
</pre>
<p> 正常に動作していますね。次は apply を試してみましょう。
</p>
<pre>
Scm&gt; (apply + '(1 2 3 4 5))
15
Scm&gt; (apply + 10 11 12 '(1 2 3 4 5))
48
Scm&gt; (define length (lambda (xs) (if (pair? xs) (+ 1 (length (cdr xs))) 0)))
length
Scm&gt; (length '(1 2 3 4 5))
5
Scm&gt; (define avg (lambda (xs) (/ (apply + xs) (length xs))))
avg
Scm&gt; (avg '(1.0 2.0 3.0 4.5 5.7 6.9))
3.85
</pre>
<p> 関数 length はリストの要素の個数を返します。length と apply を使うと、リストの要素の平均値を求める関数 avg は簡単に作成することができます。
</p>
<p> 今回はここまでです。次回はバッククォートの処理を実装して、micro Scheme 用の簡単なライブラリを作ってみましょう。
</p>

<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li>黒川利明, 『LISP 入門』, 培風館, 1982
  <li>Patrick Henry Winston, Berthold Klaus Paul Horn, 『LISP 原書第 3 版 (1)』, 培風館, 1992<br>
18. Lisp で書く Lisp
  <li>R. Kent Dybvig (著), 村上雅章 (訳), 『プログラミング言語 SCHEME』, 株式会社ピアソン・エデュケーション, 2000<br>
9.2 Scheme のメタ循環インタプリタ
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995<br>
第 11 章 定義インタプリタ
  <li>Harold Abelson, Gerald Jay Sussman, Julie Sussman, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs"</a>, <br><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1">4.1  The Metacircular Evaluator</a>
  <li><a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/index-j.html">稲葉雅幸</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/index-j.html">ソフトウェア特論</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/soft4-scheme-interp/index.html">Scheme インタプリタ</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
--
-- mscheme.hs : microScheme
--
--              Copyright (C) 2013 Makoto Hiroi
--
import Data.Char
import Data.IORef
import qualified Data.HashTable as H
import Control.Monad.Error
import System.IO

-- S 式の定義
type ScmFunc = Env -&gt; SExpr -&gt; Scm SExpr

data SExpr = INT  !Integer
           | REAL !Double
           | SYM  String
           | STR  String
           | CELL SExpr SExpr
           | NIL
           | PRIM ScmFunc
           | SYNT ScmFunc
           | CLOS SExpr LEnv
           | MACR SExpr

-- 等値の定義
instance Eq SExpr where
  INT x  == INT y  = x == y
  REAL x == REAL y = x == y
  SYM x  == SYM y  = x == y
  STR x  == STR y  = x == y
  NIL    == NIL    = True
  _      == _      = False

-- パーサエラーの定義
data ParseErr = ParseErr String String deriving Show

instance Error ParseErr where
  noMsg    = ParseErr "" ""
  strMsg s = ParseErr "" s

-- パーサの定義
type Parser a = Either ParseErr a

-- 評価器の定義
type Scm a = ErrorT String IO a

-- ローカル環境の定義
type LEnv = [(String, IORef SExpr)]

pushLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO LEnv
pushLEnv s v env = do
  a &lt;- v `seq` newIORef v
  return ((s, a):env)

lookupLEnv :: String -&gt; LEnv -&gt; IO (Maybe SExpr)
lookupLEnv s env = 
  case lookup s env of
    Nothing -&gt; return Nothing
    Just v  -&gt; do a &lt;- readIORef v
                  return (Just a)

updateLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO (LEnv)
updateLEnv s v env =
  case lookup s env of
    Nothing -&gt; pushLEnv s v env
    Just a  -&gt; do writeIORef a v
                  return env

-- グローバルな環境
type GEnv = H.HashTable String SExpr

-- 両方の環境を保持する
type Env = (GEnv, LEnv)

-- 真偽値
true  = SYM "true"
false = SYM "false"

-- Primitive の定義
errNUM  = "Illegal argument, Number required"
errINT  = "Illegal argument, Integer required"
errNEA  = "Not enough arguments"
errCELL = "Illegal argument, List required"
errZERO = "Divide by zero"

-- リスト操作
car, cdr, cons, pair :: ScmFunc
car _ NIL = throwError $ strMsg $ "car : " ++ errNEA
car _ (CELL (CELL a _) _) = return a
car _ _                   = throwError $ strMsg $ "car : " ++ errCELL

cdr _ NIL = throwError $ strMsg $ "cdr : " ++ errNEA
cdr _ (CELL (CELL _ d) _) = return d
cdr _ _                   = throwError $ strMsg $ "cdr : " ++ errCELL

cons _ (CELL a (CELL b _)) = return (CELL a b)
cons _ _                   = throwError $ strMsg $ "cons : " ++ errNEA

pair _ NIL                 = throwError $ strMsg $ "pair? : " ++ errNEA
pair _ (CELL (CELL _ _) _) = return true
pair _ _                   = return false

-- 畳み込み
foldCell :: (SExpr -&gt; SExpr -&gt; Scm SExpr) -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
foldCell _ a NIL = return a
foldCell f a (CELL x rest) = do v &lt;- f a x
                                foldCell f v rest
foldCell _ _ _ = throwError $ strMsg $ errCELL

-- 四則演算
adds, subs, muls, divs, mod' :: ScmFunc
add, sub, mul, div' :: SExpr -&gt; SExpr -&gt; Scm SExpr

add (INT x)  (INT y)  = return (INT (x + y))
add (INT x)  (REAL y) = return (REAL (fromIntegral x + y))
add (REAL x) (INT y)  = return (REAL (x + fromIntegral y))
add (REAL x) (REAL y) = return (REAL (x + y))
add _        _        = throwError $ strMsg $ "+ : " ++ errNUM

adds _ xs = foldCell add (INT 0) xs

sub (INT x)  (INT y)  = return (INT (x - y))
sub (INT x)  (REAL y) = return (REAL (fromIntegral x - y))
sub (REAL x) (INT y)  = return (REAL (x - fromIntegral y))
sub (REAL x) (REAL y) = return (REAL (x - y))
sub _        _        = throwError $ strMsg $ "- : " ++ errNUM

subs _ NIL = throwError $ strMsg $ "- : " ++ errNEA
subs _ (CELL (INT a) NIL)  = return (INT (-a))
subs _ (CELL (REAL a) NIL) = return (REAL (-a))
subs _ (CELL a rest) = foldCell sub a rest

mul (INT x)  (INT y)  = return (INT (x * y))
mul (INT x)  (REAL y) = return (REAL (fromIntegral x * y))
mul (REAL x) (INT y)  = return (REAL (x * fromIntegral y))
mul (REAL x) (REAL y) = return (REAL (x * y))
mul _        _        = throwError $ strMsg $ "- : " ++ errNUM

muls _ xs = foldCell mul (INT 1) xs

div' _        (INT 0)  = throwError $ strMsg errZERO
div' _        (REAL 0) = throwError $ strMsg errZERO
div' (INT x)  (INT y)  = return (INT (x `div` y))
div' (INT x)  (REAL y) = return (REAL (fromIntegral x / y))
div' (REAL x) (INT y)  = return (REAL (x / fromIntegral y))
div' (REAL x) (REAL y) = return (REAL (x / y))
div' _        _        = throwError $ strMsg $ "- : " ++ errNUM

divs _ NIL = throwError $ strMsg $ "/ : " ++ errNEA
divs _ (CELL a NIL)  = div' (INT 1) a
divs _ (CELL a rest) = foldCell div' a rest

mod' _ NIL          = throwError $ strMsg $ "mod : " ++ errNEA
mod' _ (CELL _ NIL) = throwError $ strMsg $ "mod : " ++ errNEA
mod' _ (CELL _ (CELL (INT 0) _))  = throwError $ strMsg errZERO
mod' _ (CELL _ (CELL (REAL 0) _)) = throwError $ strMsg errZERO
mod' _ (CELL (INT x) (CELL (INT y) _)) = return (INT (mod x y))
mod' _ _ = throwError $ strMsg $ "mod : " ++ errINT

-- 等値の判定
eq', equal' :: ScmFunc

eq' _ (CELL x (CELL y _)) =
  if x == y then return true else return false
eq' _ _ = throwError $ strMsg $ "eq : " ++ errNEA

equal' _ (CELL x (CELL y _)) =
  if iter x y then return true else return false
  where iter (CELL a b) (CELL c d) = iter a c &amp;&amp; iter b d
        iter x y = x == y
equal' _ _ = throwError $ strMsg $ "equal : " ++ errNEA

-- 数値の比較演算子
compareNum :: SExpr -&gt; SExpr -&gt; Scm Ordering
compareNum (INT x)  (INT y)  = return $ compare x y
compareNum (INT x)  (REAL y) = return $ compare (fromIntegral x) y
compareNum (REAL x) (INT y)  = return $ compare x (fromIntegral y)
compareNum (REAL x) (REAL y) = return $ compare x y
compareNum _ _ = throwError $ strMsg errNUM

compareNums :: (Ordering -&gt; Bool) -&gt; SExpr -&gt; Scm SExpr
compareNums _ NIL          = throwError $ strMsg errNEA
compareNums _ (CELL _ NIL) = throwError $ strMsg errNEA
compareNums p (CELL x (CELL y NIL)) = do
  r &lt;- compareNum x y
  if p r then return true else return false
compareNums p (CELL x ys@(CELL y _)) = do
  r &lt;- compareNum x y
  if p r then compareNums p ys else return false
compareNums _ _ = throwError $ strMsg "invalid function form"

eqNum, ltNum, gtNum, ltEq, gtEq :: ScmFunc
eqNum _ = compareNums (== EQ)
ltNum _ = compareNums (== LT)
gtNum _ = compareNums (== GT)
ltEq  _ = compareNums (&lt;= EQ)
gtEq  _ = compareNums (&gt;= EQ)

-- apply
apply' :: ScmFunc
apply' _ (CELL _ NIL) = throwError $ strMsg $ "apply : " ++ errNEA
apply' env (CELL func args) = do
  xs &lt;- iter args
  apply env func xs
  where iter (CELL NIL NIL) = return NIL
        iter (CELL xs@(CELL _ _) NIL) = return xs
        iter (CELL _ NIL) = throwError $ strMsg errCELL
        iter (CELL x xs) = do ys &lt;- iter xs
                              return (CELL x ys)
apply' _ _ = throwError $ strMsg $ "apply : " ++ errNEA

-- エラー
error' :: ScmFunc
error' _ (CELL (STR x) NIL) = throwError $ strMsg $ "ERROR: " ++ x
error' _ (CELL (STR x) (CELL y _)) = throwError $ strMsg $ "ERROR: " ++ x ++ " " ++ show y
error' _ (CELL x _) = throwError $ strMsg $ "ERROR: " ++ show x
error' _ _ = throwError $ strMsg "ERROR: "

-- load
load :: ScmFunc
load env (CELL (STR filename) _) = do
  xs &lt;- lift $ readFile filename
  r &lt;- lift $ iter xs
  if r then return true else return false
  where
    iter :: String -&gt; IO Bool
    iter xs = 
      case readSExpr xs of
        Left  (ParseErr xs' mes) -&gt; if mes == "EOF"
                                      then return True
                                      else do print mes
                                              return False
        Right (expr, xs') -&gt; do result &lt;- runErrorT $ eval env expr 
                                case result of
                                  Left mes -&gt; do print mes
                                                 return False
                                  Right _  -&gt; iter xs'
load _ _ = throwError $ strMsg "invalid load form"

--
-- S 式の表示
--
showCell :: SExpr -&gt; String
showCell (CELL a d) =
  show a ++ case d of
              NIL      -&gt; ""
              PRIM _   -&gt; "&lt;primitive&gt;"
              CLOS _ _ -&gt; "&lt;closure&gt;"
              SYNT _   -&gt; "&lt;syntax&gt;"
              MACR _   -&gt; "&lt;macro&gt;"
              INT x    -&gt; " . " ++ show x
              REAL x   -&gt; " . " ++ show x
              SYM x    -&gt; " . " ++ x
              STR x    -&gt; " . " ++ show x
              _        -&gt; " " ++ showCell d
showCell xs = show xs

instance Show SExpr where
  show (INT x)    = show x
  show (REAL x)   = show x
  show (SYM x)    = x
  show (STR x)    = show x
  show NIL        = "()"
  show (SYNT _)   = "&lt;syntax&gt;"
  show (PRIM _)   = "&lt;primitive&gt;"
  show (CLOS _ _) = "&lt;closure&gt;"
  show (MACR _)   = "&lt;macro&gt;"
  show xs         = "(" ++ showCell xs ++ ")"

--
-- S 式の読み込み
--

isAlpha' :: Char -&gt; Bool
isAlpha' x = elem x "!$%&amp;*+-/:&lt;=&gt;?@^_~"

isIdent0 :: Char -&gt; Bool
isIdent0 x = isAlpha x || isAlpha' x

isIdent1 :: Char -&gt; Bool
isIdent1 x = isAlphaNum x || isAlpha' x

isREAL :: Char -&gt; Bool
isREAL x = elem x ".eE"

quote           = SYM "quote"
quasiquote      = SYM "quasiquote"
unquote         = SYM "unquote"
unquoteSplicing = SYM "unquote-splicing"

isNUM :: String -&gt; Bool
isNUM (x:_) = isDigit x
isNUM _     = False

getNumber :: String -&gt; Parser (SExpr, String)
getNumber xs =
  let (s, ys) = span isDigit xs
  in if not (null ys) &amp;&amp; isREAL (head ys)
     then case reads xs of
            [] -&gt; throwError noMsg  -- ありえないエラー
            [(y', ys')] -&gt; return (REAL y', ys')
     else return (INT (read s), ys)

readSExpr :: String -&gt; Parser (SExpr, String)
readSExpr [] = throwError $ strMsg "EOF"
readSExpr (x:xs) 
  | isSpace x  = readSExpr xs
  | isDigit x  = getNumber (x:xs)
  | isIdent0 x = if x == '+' &amp;&amp; isNUM xs
                 then getNumber xs
                 else if x == '-' &amp;&amp; isNUM xs
                 then do (y, ys) &lt;- getNumber xs
                         case y of
                           INT x  -&gt; return (INT  (- x), ys)
                           REAL x -&gt; return (REAL (- x), ys)
                 else let (name, ys) = span isIdent1 (x:xs)
                      in return (SYM name, ys)
  | otherwise  =
      case x of
        '('  -&gt; readCell 0 xs
        ';'  -&gt; readSExpr $ dropWhile (/= '\n') xs
        '"'  -&gt; case reads (x:xs) of
                  [] -&gt; throwError noMsg
                  [(y, ys)] -&gt; return (STR y, ys)
        '\'' -&gt; readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL quote (CELL e NIL), ys)
        '`'  -&gt; readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL quasiquote (CELL e NIL), ys)
        ','  -&gt; if not (null xs) &amp;&amp; head xs == '@'
                  then readSExpr (tail xs) &gt;&gt;= \(e, ys) -&gt; return (CELL unquoteSplicing (CELL e NIL), ys)
                  else readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL unquote (CELL e NIL), ys)
        _    -&gt; throwError $ ParseErr xs ("unexpected token: " ++ show x)

readCell :: Int -&gt; String -&gt; Parser (SExpr, String)
readCell _ [] = throwError $ strMsg "EOF"
readCell n (x:xs)
  | isSpace x = readCell n xs
  | otherwise =
      case x of
        ')' -&gt; return (NIL, xs)
        '.' -&gt; if n == 0
               then throwError $ ParseErr xs "invalid dotted list"
               else do (e, ys) &lt;- readSExpr xs
                       case dropWhile isSpace ys of
                         ')':zs -&gt; return (e, zs)
                         _      -&gt; throwError $ ParseErr xs "invalid dotted list"
        '(' -&gt; do (a, ys) &lt;- readCell 0 xs
                  (d, zs) &lt;- readCell 1 ys
                  return (CELL a d, zs)
        _   -&gt; do (a, ys) &lt;- readSExpr (x:xs)
                  (d, zs) &lt;- readCell 1 ys
                  return (CELL a d, zs)

--
-- S 式の評価
--
eval :: Env -&gt; SExpr -&gt; Scm SExpr
eval env NIL        = return NIL
eval env v@(INT _)  = return v
eval env v@(REAL _) = return v
eval env v@(STR _)  = return v
eval env (SYM name) = do
  a &lt;- liftIO $ lookupLEnv name $ snd env
  case a of
    Nothing -&gt; do b &lt;- liftIO $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just v  -&gt; return v
    Just v -&gt; return v
eval env (CELL func args) = do
  v &lt;- eval env func
  case v of
    SYNT f -&gt; f env args
    MACR f -&gt; do expr &lt;- apply env f args
                 eval env expr
    _      -&gt; do vs &lt;- evalArguments env args
                 apply env v vs

-- 引数の評価
evalArguments :: Env -&gt; SExpr -&gt; Scm SExpr
evalArguments env NIL = return NIL
evalArguments env (CELL expr rest) = do
  v  &lt;- eval env expr
  vs &lt;- evalArguments env rest
  return (CELL v vs)
evalArguments _ _ = throwError $ strMsg "invalid function form"

-- 変数束縛
makeBindings :: LEnv -&gt; SExpr -&gt; SExpr -&gt; Scm LEnv
makeBindings lenv NIL        _    = return lenv
makeBindings lenv (SYM name) rest = lift $ pushLEnv name rest lenv
makeBindings lenv (CELL (SYM name) parms) (CELL v args) = do
  lenv' &lt;- makeBindings lenv parms args
  lift (pushLEnv name v lenv')
makeBindings lenv _ NIL = throwError $ strMsg errNEA
makeBindings lenv _ _   = throwError $ strMsg "invalid arguments form"

-- 関数適用
apply :: Env -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
apply env func actuals =
  case func of
    PRIM f -&gt; f env actuals
    CLOS (CELL parms body) lenv0 -&gt; do
      lenv1 &lt;- makeBindings lenv0 parms actuals
      evalBody (fst env, lenv1) body
    _ -&gt; throwError $ strMsg $ "Not Function: " ++ show func

-- 本体の評価
evalBody :: Env -&gt; SExpr -&gt; Scm SExpr
evalBody env (CELL expr NIL) = eval env expr
evalBody env (CELL expr rest) = do
  eval env expr
  evalBody env rest
evalBody _ _ = throwError $ strMsg "invalid body form"

--
-- シンタックス形式
--

-- quote
evalQuote :: Env -&gt; SExpr -&gt; Scm SExpr
evalQuote env (CELL expr _) = return expr
evalQuote _ _ = throwError $ strMsg "invalid quote form"

-- define
evalDef :: Env -&gt; SExpr -&gt; Scm SExpr
evalDef env (CELL sym@(SYM name) (CELL expr NIL)) = do
  v &lt;- eval env expr
  lift $ H.update (fst env) name v
  return sym
evalDef _ _ = throwError $ strMsg "invalid define form"

-- define-macro
evalDefM :: Env -&gt; SExpr -&gt; Scm SExpr
evalDefM env (CELL sym@(SYM name) (CELL expr NIL)) = do
  v &lt;- eval env expr
  lift $ H.update (fst env) name (MACR v)
  return sym
evalDefM _ _ = throwError $ strMsg "invalid define-macro form"

-- if
evalIf :: Env -&gt; SExpr -&gt; Scm SExpr
evalIf env (CELL pred (CELL thenForm rest)) = do
  v &lt;- eval env pred
  if v /= false
  then eval env thenForm
  else case rest of
         CELL elseForm _ -&gt; eval env elseForm
         _               -&gt; return false
evalIf _ _ = throwError $ strMsg $ "if : " ++ errNEA

-- lambda
evalLambda :: Env -&gt; SExpr -&gt; Scm SExpr
evalLambda env expr = return (CLOS expr (snd env))

-- set!
evalSet :: Env -&gt; SExpr -&gt; Scm SExpr
evalSet env (CELL (SYM name) (CELL expr _)) = do
  v &lt;- eval env expr
  a &lt;- lift $ lookupLEnv name (snd env)
  case a of
    Nothing -&gt; do b &lt;- lift $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just _ -&gt; do lift $ H.update (fst env) name v
                                 return v
    Just _  -&gt; do lift $ updateLEnv name v (snd env)
                  return v
evalSet _ _ = throwError (strMsg "invalid set! form")

--
-- 大域変数の初期化
--
initGEnv :: [(String, SExpr)]
initGEnv = [("true",   true),
            ("false",  false),
            ("quote",  SYNT evalQuote),
            ("define", SYNT evalDef),
            ("lambda", SYNT evalLambda),
            ("if",     SYNT evalIf),
            ("set!",   SYNT evalSet),
            ("define-macro", SYNT evalDefM),
            ("eq?",    PRIM eq'),
            ("equal?", PRIM equal'),
            ("pair?",  PRIM pair),
            ("+",      PRIM adds),
            ("-",      PRIM subs),
            ("*",      PRIM muls),
            ("/",      PRIM divs),
            ("mod",    PRIM mod'),
            ("=",      PRIM eqNum),
            ("&lt;",      PRIM ltNum),
            ("&gt;",      PRIM gtNum),
            ("&lt;=",     PRIM ltEq),
            ("&gt;=",     PRIM gtEq),
            ("car",    PRIM car),
            ("cdr",    PRIM cdr),
            ("cons",   PRIM cons),
            ("load",   PRIM load),
            ("apply",  PRIM apply'),
            ("error",   PRIM error')]

-- read-eval-print-loop
repl :: Env -&gt; String -&gt; IO ()
repl env xs = do
  putStr "Scm&gt; "
  hFlush stdout
  case readSExpr xs of
    Left  (ParseErr xs' mes) -&gt; do putStrLn mes
                                   repl env $ dropWhile (/= '\n') xs'
    Right (expr, xs') -&gt; do result &lt;- runErrorT $ eval env expr 
                            case result of
                              Left mes -&gt; putStrLn mes
                              Right v  -&gt; print v
                            repl env xs'

main :: IO ()
main = do
  xs &lt;- hGetContents stdin
  ht &lt;- H.fromList H.hashString initGEnv
  repl (ht, []) xs
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell35.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell37.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>