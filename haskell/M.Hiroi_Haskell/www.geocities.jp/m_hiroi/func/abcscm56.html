<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881784</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm55.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm57.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>●関数型電卓プログラム fncalc の作成 (2)</h3>
<p> 前回は fncalc のコンパイラを作成しました。今回は fncalc 用の SECD 仮想マシンを作成し、実際にプログラムを動かしてみましょう。
</p>
<h4>●SECD 仮想マシンの作成</h4>
<p> SECD 仮想マシンのプログラムは次のようになります。
</p>
<pre class="list">
リスト : SECD 仮想マシン

(define (vm s e c d)
  (case (car c)
    ((+)
     (vm (cons (+ (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((-)
     (vm (cons (- (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((*)
     (vm (cons (* (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((/)
     (vm (cons (/ (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((%)
     (vm (cons (modulo (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((==)
     (vm (cons (if (= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((!=)
     (vm (cons (if (= (cadr s) (car s)) 0 1) (cddr s)) e (cdr c) d))
    ((&lt;)
     (vm (cons (if (&lt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;=)
     (vm (cons (if (&lt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;)
     (vm (cons (if (&lt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;=)
     (vm (cons (if (&lt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&gt;)
     (vm (cons (if (&gt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&gt;=)
     (vm (cons (if (&gt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((eq)
     (vm (cons (if (eqv? (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((and)
     (vm (cons (if (zero? (logand (cadr s) (car s))) 0 1) (cddr s)) e (cdr c) d))
    ((or)
     (vm (cons (if (zero? (logior (cadr s) (car s))) 0 1) (cddr s)) e (cdr c) d))
    ((neg)
     (vm (cons (- (car s)) (cdr s)) e (cdr c) d))
    ((not)
     (vm (cons (if (zero? (car s)) 1 0) (cdr s)) e (cdr c) d))
    ((ld)
     (let ((pos (cadr c)))
       (vm (cons (get-lvar e (car pos) (cdr pos)) s) e (cddr c) d)))
    ((ldc)
     (vm (cons (cadr c) s) e (cddr c) d))
    ((ldg)
     ; c = (ldg (sym . val) ...)
     (vm (cons (cdr (cadr c)) s) e (cddr c) d))
    ((ldf)
     (vm (cons (list 'closure (cadr c) e) s) e (cddr c) d))
    ((lset)
     (let ((pos (cadr c)))
       (set-lvar! e (car pos) (cdr pos) (car s))
       (vm s e (cddr c) d)))
    ((gset)
     ; c = (gset (sym . val) ...)
     (set-cdr! (cadr c) (car s))
     (vm s e (cddr c) d))
    ((app)
     (let ((clo (car s)) (lvar (cadr s)))
       (case (car clo)
         ((primitive)
          ; (primitive function)
          (vm (cons (apply (cadr clo) lvar) (cddr s)) e (cdr c) d))
         (else
          ; (closure code env)
          (vm '()
              (cons lvar (caddr clo))
              (cadr clo)
              (cons (list (cddr s) e (cdr c)) d))))))
    ((rtn)
     (let ((save (car d)))
       (vm (cons (car s) (car save)) (cadr save) (caddr save) (cdr d))))
    ((sel)
     (let ((t-clause (cadr c))
           (e-clause (caddr c)))
       (if (zero? (car s))
           (vm (cdr s) e e-clause (cons (cdddr c) d))
         (vm (cdr s) e t-clause (cons (cdddr c) d)))))
    ((join)
     (vm s e (car d) (cdr d)))
    ((pop)
     (vm (cdr s) e (cdr c) d))
    ((args)
     (let loop ((n (cadr c)) (a '()))
       (if (zero? n)
           (vm (cons a s) e (cddr c) d)
         (loop (- n 1) (cons (pop! s) a)))))
    ((bgn)
     (vm s e (cdr c) (cons (cdr c) d)))
    ((whl)
     (if (zero? (car s))
         (vm (cons 0 (cdr s)) e (cddr c) (cdr d))
       (vm (cdr s) e (cadr c) d)))
    ((rpt)
     (vm (cdr s) e (car d) d))
    ((halt)
     (car s))
    (else
     (error "vm: unexpected code:" (car c)))))
</pre>
<p> プログラムリストは少々長いですが、やっていることは簡単です。関数 vm の引数 s がスタック、c がコード、e が局所変数の環境、d がダンプです。c の先頭からコードを取り出して case で分岐します。あとは命令にしたがって s, e, c. d の値を操作するだけです。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="abcscm56.html#list1">プログラムリスト</a> をお読みください。
</p>

<h4>●実行例</h4>
<p> それでは実行してみましょう。
</p>
<pre>
gosh> (calc)
Calc&gt; 1 + 2;
=&gt; 3
Calc&gt; 1 + 2 * 3 - 4;
=&gt; 3
Calc&gt; (1 + 2) * (3 - 4);
=&gt; -3
Calc&gt; begin print(1); print(2); print(3); end
1
2
3
=&gt; 3
Calc&gt; if 1 &lt; 2 then 3; else 4; end
=&gt; 3
Calc&gt; if 1 &gt; 2 then 3; else 4; end
=&gt; 4
Calc&gt; if 1 &gt; 2 then 3; end
=&gt; 0
</pre>
<p> 式文、if 文、begin 文は正しく動作しています。次は let 文と while 文を試してみましょう。
</p>
<pre>
Calc&gt; let a = 0 in a + 10; end
=&gt; 10
Calc&gt; let a = 1, b = 2 in a + b; end
=&gt; 3
Calc&gt; let a = 0, b = 0 in while a &lt;= 10 do b = b + a; a = a + 1; end b; end
=&gt; 55
Calc&gt; begin a = b = 0; while a &lt;= 10 do b = b + a; a = a + 1; end b; end
=&gt; 55
Calc&gt; b;
=&gt; 55
</pre>
<p> let 文も while 文も正常に動作していますね。次は関数定義を試してみましょう。
</p>
<pre>
Calc&gt; def square(x) x * x; end
=&gt; closure
Calc&gt; square(10);
=&gt; 100
Calc&gt; def fact(n) if n == 0 then 1; else n * fact(n - 1); end end
=&gt; closure
Calc&gt; fact(8);
=&gt; 40320
Calc&gt; fact(9);
=&gt; 362880
Calc&gt; fact(10);
=&gt; 3628800
</pre>
<p> これも正常に動作していますね。最後に匿名関数 (クロージャ) を試してみましょう。
</p>
<pre>
Calc&gt; fn(x) x * x; end;
=&gt; closure
Calc&gt; fn(x) x * x; end(10);
=&gt; 100
Calc&gt; let a = fn(x) x * x; end in a(100); end
=&gt; 10000
Calc&gt; def makeAdder(x) fn(y) x + y; end; end
=&gt; closure
Calc&gt; a = makeAdder(10);
=&gt; closure
Calc&gt; a(10);
=&gt; 20
Calc&gt; a(100);
=&gt; 110
</pre>
<p> クロージャも正常に動作していますね。ただし、局所関数で再帰呼び出しを行う場合は注意が必要です。次のリストを見てください。
</p>
<pre class="list">
リスト : 局所関数の再帰定義

# 階乗 (末尾再帰)
def fact(n)
  let iter = 0 in
    iter = fn(x, a)
      if x == 0 then
        a;
      else
        iter(x - 1, a * x);
      end
    end;
    iter(n, 1);
  end
end
</pre>
<p> let 文で局所変数を定義する場合、右辺の式を評価するとき、左辺の局所変数はまだ存在していません。左辺の式でその局所変数を使用することはできないのです。この場合、局所変数を適当な値で初期化しておき、let 文本体の中で局所変数の値を fn 式で書き換えるようにしてください。これで局所関数でも再帰呼び出しが可能になります。
</p>
<p> それでは、実際に試してみましょう。
</p>
<pre>
Calc&gt; def fact(n)
  let iter = 0 in
    iter = fn(x, a)
      if x == 0 then
        a;
      else
        iter(x - 1, a * x);
     end
   end;
   iter(n, 1);
  end
end
=&gt; closure
Calc&gt; fact(9);
=&gt; 362880
Calc&gt; fact(10);
=&gt; 3628800
Calc&gt; fact(11);
=&gt; 39916800
</pre>
<h4>●連結リストの作成</h4>
<p> それではクロージャを使って「連結リスト」を作ってみましょう。Lisp / Scheme の場合、ラムダ式だけで cons, car, cdr を実現することができます。cons, car, cdr は次の関係が成り立ちます。
</p>
<pre class="item">
(eq? x (car (cons x y))) =&gt; #t
(eq? y (cdr (cons x y))) =&gt; #t
</pre>
<p> 実際に Gauche で実行してみると、次のようになります。
</p>
<pre>
gosh> (define a 10)
a
gosh> (define b 20)
b
gosh> (eq? a (car (cons a b)))
#t
gosh> (eq? b (cdr (cons a b)))
#t
</pre>
<p> ここで (cons x y) で生成したオブジェクトがコンスセルではない場合を考えてみましょう。もし、そのオブジェクトに car を適用すれば cons の第 1 引数 x を返し、cdr を適用すれば第 2 引数を返すことができれば、コンスセルと同じことが実現できます。そこで、cons はコンスセルではなくクロージャを返すことにしましょう。クロージャは引数 x, y の値を保持することができます。そして、このクロージャは引数に関数を受け取ることにします。あとは、この関数に引数 x, y を渡して評価すれば car と cdr を実現することができます。
</p>
<p> Gauche でプログラムすると次のようになります。
</p>
<pre>
gosh&gt; (define (cons2 x y) (lambda (z) (z x y)))
cons2
gosh&gt; (define (car2 x) (x (lambda (a b) a)))
car2
gosh&gt; (define (cdr2 x) (x (lambda (a b) b)))
cdr2
gosh&gt; (car2 (cons2 'a 'b))
a
gosh&gt; (cdr2 (cons2 'a 'b))
b
gosh&gt; (define a (cons2 1 (cons2 2 (cons2 3 4))))
a
gosh&gt; (car2 a)
1
gosh&gt; (car2 (cdr2 a))
2
gosh&gt; (car2 (cdr2 (cdr2 a)))
3
gosh&gt; (cdr2 (cdr2 (cdr2 a)))
4
</pre>
<p> 関数 cons2 はクロージャを返します。このクロージャは引数 z に関数を受け取り、その関数に x, y を渡して評価します。car2 は引数 x にクロージャを渡して評価し、第 1 引数 a を返します。これで car と同じ動作になります。同様に、cdr2 は引数 x にクロージャを渡して評価し、第 2 引数 b を返します。これで cdr と同じ動作になります。
</p>

<p> クロージャをサポートしているプログラミング言語であれば、Lisp / Scheme と同じように cons, car, cdr を作ることができます。fncalc で cons, car, cdr をプログラムすると次のようになります。
</p>
<pre class="list">
リスト ; 連結リストの基本関数

def cons(x, y)
  fn(z) z(x, y); end;
end

def car(z)
  z(fn(x, y) x; end);
end

def cdr(z)
  z(fn(x, y) y; end);
end
</pre>
<p> それでは実際に試してみましょう。
</p>
<pre>
Calc&gt; def cons(x, y) fn(z) z(x, y); end; end
=&gt; closure
Calc&gt; def car(z) z(fn(x, y) x; end); end
=&gt; closure
Calc&gt; def cdr(z) z(fn(x, y) y; end); end
=&gt; closure
Calc&gt; a = cons(1, 0);
=&gt; closure
Calc&gt; car(a);
=&gt; 1
Calc&gt; cdr(a);
=&gt; 0
Calc&gt; b = cons(2, a);
=&gt; closure
Calc&gt; car(b);
=&gt; 2
Calc&gt; cdr(b);
=&gt; closure
Calc&gt; car(cdr(b));
=&gt; 1
</pre>
<p> このように、クロージャを使って連結リストを作成することができます。ご参考までに、簡単な連結リストライブラリとその実行例を示します。なお、データ型を判定するため、組み込み関数に述語 number, string, function を追加しています。
</p>
<pre class="list">
#
# list.cal : Linked List Library
#
#            Copyright (C) 2011 Makoto Hiroi
#

#
nil = "nil";

#
def null(x)
 x eq nil;
end

def pair(x)
  function(x);
end

def cons(x, y)
  fn(z) z(x, y); end;
end

def car(z)
  z(fn(x, y) x; end);
end

def cdr(z)
  z(fn(x, y) y; end);
end

#
def append(xs, ys)
  if null(xs) then
    ys;
  else
    cons(car(xs), append(cdr(xs), ys));
  end
end

def list_ref(xs, n)
  if null(xs) then
    nil;
  else
    if n == 0 then
      car(xs);
    else
      list_ref(cdr(xs), n - 1);
    end
  end
end

def member(x, ls)
  if null(ls) then
    nil;
  else
    if car(ls) == x then
      ls;
    else
      member(x, cdr(ls));
    end
  end
end

def remove(x, ls)
  if null(ls) then
    nil;
  else
    if x == car(ls) then
      remove(x, cdr(ls));
    else
      cons(car(ls), remove(x, cdr(ls)));
    end
  end
end

#
def map(f, ls)
  if null(ls) then
    nil;
  else
    cons(f(car(ls)), map(f, cdr(ls)));
  end
end

def filter(pred, ls)
  if null(ls) then
    nil;
  else
    if pred(car(ls)) then
      cons(car(ls), filter(pred, cdr(ls)));
    else
      filter(pred, cdr(ls));
    end
  end
end

def foldl(f, a, ls)
  if null(ls) then
    a;
  else
    foldl(f, f(a, car(ls)), cdr(ls));
  end
end

def foldr(f, a, ls)
  if null(ls) then
    a;
  else
    f(foldr(f, a, cdr(ls)), car(ls));
  end
end

def for_each(f, ls)
  if not null(ls) then
    begin
      f(car(ls));
      for_each(f, cdr(ls));
    end
  end
end

#
def zip(xs, ys)
  if null(xs) or null(ys) then
    nil;
  else
    cons(cons(car(xs), car(ys)), zip(cdr(xs), cdr(ys)));
  end
end

def flatten(ls)
  if null(ls) then
    nil;
  else
    if pair(ls) then
      append(flatten(car(ls)), flatten(cdr(ls)));
    else
      cons(ls, nil);
    end
  end
end

def iota(n, m)
  let a = nil in
    while m &gt;= n do
      a = cons(m, a);
      m = m - 1;
    end
    a;
  end
end

#
def printlist_sub(ls)
  display("(");
  while pair(ls) do
    if pair(car(ls)) then
      printlist_sub(car(ls));
    else
      display(car(ls));
    end
    ls = cdr(ls);
    if not null(ls) then display(" "); end
  end
  if not null(ls) then
    begin
      display(". ");
      display(ls);
    end
  end
  display(")");
end

def printlist(ls)
  printlist_sub(ls);
  newline();
end
</pre>
<pre>
Calc&gt; a = iota(1, 8);
=&gt; closure
Calc&gt; printlist(a);
(1 2 3 4 5 6 7 8)
=&gt; 0
Calc&gt; printlist(member(5, a));
(5 6 7 8)
=&gt; 0
Calc&gt; printlist(member(9, a));
()
=&gt; 0
Calc&gt; list_ref(a, 0);
=&gt; 1
Calc&gt; list_ref(a, 7);
=&gt; 8
Calc&gt; printlist(append(iota(1, 5), iota(6, 10)));
(1 2 3 4 5 6 7 8 9 10)
=&gt; 0
Calc&gt; printlist(remove(5, a));
(1 2 3 4 6 7 8)
=&gt; 0
Calc&gt; printlist(map(fn(x) x * x; end, a));
(1 4 9 16 25 36 49 64)
=&gt; 0
Calc&gt; printlist(filter(fn(x) x % 2 == 0; end, a));
(2 4 6 8)
=&gt; 0
Calc&gt; foldl(fn(x, y) x + y; end, 0, a);
=&gt; 36
Calc&gt; foldr(fn(x, y) x + y; end, 0, a);
=&gt; 36
Calc&gt; for_each(print, a);
1
2
3
4
5
6
7
8
=&gt; 0
Calc&gt; b = zip(iota(1, 5), iota(11, 15));
=&gt; closure
Calc&gt; printlist(b);
((1 . 11) (2 . 12) (3 . 13) (4 . 14) (5 . 15))
=&gt; 0
Calc&gt; printlist(flatten(b));
(1 11 2 12 3 13 4 14 5 15)
=&gt; 0
</pre>
<p> リストの終端を表すため変数 nil に文字列 "nil" をセットしましたが、これはクロージャを使ってもかまいません。
</p>

<h4>●リストの破壊的な修正</h4>
<p> なお、このままでは CAR 部と CDR 部を破壊的に修正することはできません。set-car!, set-cdr! と同じ動作を実現する場合、cons が返すクロージャに値を書き換える処理を追加します。プログラムは次のようになるでしょう。
</p>
<pre class="list">
リスト : リストの破壊的な修正

def cons(x, y)
  fn(n, v)
    if n < 2 then
      if n == 0 then
        x;      # car
      else
        y;      # cdr
      end
    else
      if n == 2 then
        x = v;  # set_car
      else
        y = v;  # set_cdr
      end
    end
  end;
end

#
def car(z) z(0, 0); end

def cdr(z) z(1, 0); end

def set_car(z, v) z(2, v); end

def set_cdr(z, v) z(3, v); end

#
def list_set(xs, n, v)
  if null(xs) then
    nil;
  else
    if n == 0 then
      set_car(xs, v);
    else
      list_set(cdr(xs), n - 1, v);
    end
  end
end
</pre>
<p> クロージャの第 1 引数 n で実行する処理を指定します。0 が car, 1 が cdr です。2 が set_car で x の値を引数 v に書き換えます。3 が set_cdr で y の値を v に書き換えます。あとは、関数 car, cdr, set_car, set_cdr で適切な値を指定してクロージャを呼び出すだけです。あとのプログラムは修正しなくても大丈夫です。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
Calc&gt; a = cons(1, 2);
=&gt; closure
Calc&gt; printlist(a);
(1 . 2)
=&gt; 0
Calc&gt; car(a);
=&gt; 1
Calc&gt; cdr(a);
=&gt; 2
Calc&gt; set_car(a, 10);
=&gt; 10
Calc&gt; car(a);
=&gt; 10
Calc&gt; set_cdr(a, 20);
=&gt; 20
Calc&gt; cdr(a);
=&gt; 20
Calc&gt; printlist(a);
(10 . 20)
=&gt; 0
Calc&gt; a = iota(1, 10);
=&gt; closure
Calc&gt; printlist(a);
(1 2 3 4 5 6 7 8 9 10)
=&gt; 0
Calc&gt; list_set(a, 5, 100);
=&gt; 100
Calc&gt; list_ref(a, 5);
=&gt; 100
Calc&gt; printlist(a);
(1 2 3 4 5 100 7 8 9 10)
=&gt; 0
</pre>

<h4>●ファイルのロード</h4>
<p> fncalc は簡単なプログラミング言語ですが、プログラムを標準入力から打ち込むだけではなく、ファイルから読み込むことができると便利です。そこで、ファイルからプログラムをロードする組み込み関数 load を作りましょう。load は関数 load-file を呼び出します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : ファイルのロード

(define (load-file name)
  (call-with-input-file name
    (lambda (in)
      (let ((save-input *input*)
            (save-token *token*)
            (save-value *value*)
            (save-ch    *ch*)
            (save-line  *line*)
            (save-col   *col*))
        (set! *input* in)
        (set! *line* 1)
        (set! *col*  0)
        (nextch)
        (unwind-protect
          (let loop ()
            (get-token)
            (when (not (eq? *token* 'eof))
              (vm '() '() (append (compile) (list 'halt)) '())
              (loop)))
          (begin
            (set! *input* save-input)
            (set! *token* save-token)
            (set! *value* save-value)
            (set! *ch*    save-ch)
            (set! *line*  save-line)
            (set! *col*   save-col)))))))
</pre>
<p> 引数 name にはファイル名を表す文字列を渡します。最初に、call-with-input-file でファイルをオープンします。次に、字句解析で使用する大域変数を局所変数に保存し、*input* をポート in に切り替えます。あとは、ファイルの終了までプログラムを読み込み、compile でコンパイルして vm で実行します。最後に、大域変数の値を元に戻します。途中でエラーが送出される場合もあるので、unwind-protect を使っていることに注意してください。
</p>
<p> あとは *global-environment* に (load . ,(lambda (name) (load-file name) 1)) を追加します。たとえば、連結リストライブラリのファイル名が list.cal とすると、次のようにプログラムをロードすることができます。
</p>
<pre>
Calc&gt; load("list.cal");
=&gt; 1
Calc&gt;
</pre>
<p> 今回はここまでです。次回は「末尾再帰最適化」と「継続」を実装してみましょう。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;
; fncalc1.scm : 関数型電卓プログラム
;
;              Copyright (C) 2011 Makoto Hiroi
;

;;;
;;; 大域変数
;;;
(define *ch*    #f)
(define *token* #f)
(define *value* #f)
(define *input* (standard-input-port))
(define *line*  #f)
(define *col*   #f)

;;;
;;; グローバルな環境
;;;
(define *global-environment*
  `((exp     primitive ,exp)
    (log     primitive ,log)
    (sin     primitive ,sin)
    (cos     primitive ,cos)
    (tan     primitive ,tan)
    (asin    primitive ,asin)
    (acos    primitive ,acos)
    (atan    primitive ,atan)
    (sqrt    primitive ,sqrt)
    (expt    primitive ,expt)
    (number   primitive ,(lambda (x) (if (number? x) 1 0)))
    (string   primitive ,(lambda (x) (if (string? x) 1 0)))
    (function primitive ,(lambda (x) (if (pair? x) 1 0)))
    (load     primitive ,(lambda (x) (load-file x) 1))
    (display  primitive ,(lambda (x) (display (if (pair? x) (car x) x)) x))
    (newline  primitive ,(lambda ()  (newline) 0))
    (print    primitive ,(lambda (x) (print (if (pair? x) (car x) x)) x))))

; 大域変数を求める
(define (get-gvar sym)
  (let ((val (assoc sym *global-environment*)))
    (unless val
      (set! val (cons sym 0))
      (push! *global-environment* val))
    val))

;;;
;;; 入力処理
;;;

; 文字の読み込み
(define (nextch)
  (set! *ch* (read-char *input*))
  (cond ((eof-object? *ch*)
         (set! *ch* #\null))
        ((eqv? *ch* #\newline)
         (inc! *line*)
         (set! *col* 0))
        (else
         (inc! *col*))))

; コンパイルエラー
(define (compile-error mes)
  (errorf "~A: token ~A, line ~D, column ~D" mes *token* *line* *col*))

; 先読み記号の取得
(define (getch) *ch*)

; 数値
(define (get-number)
  (let ((buff '()))
    ; 整数を buff に格納
    (define (get-numeric)
      (while (char-numeric? (getch))
        (push! buff (getch))
        (nextch)))
    ; 整数部
    (get-numeric)
    (case (getch)
      ((#\.)
       ; 小数部
       (push! buff (getch))
       (nextch)
       (get-numeric)
       (case (getch)
         ((#\d #\D #\e #\E)
          ; 指数部
          (push! buff (getch))
          (nextch)
          (when (or (eqv? (getch) #\+)
                    (eqv? (getch) #\-))
            (push! buff (getch))
            (nextch))
          ; 指数の数字
          (get-numeric))))
      ((#\/)
       ; 分数
       (push! buff (getch))
       (nextch)
       (get-numeric)))
    (string-&gt;number (list-&gt;string (reverse buff)))))

; 識別子
(define (get-ident)
  (let loop ((a '()))
    (if (and (not (char-alphabetic? (getch)))
             (not (char-numeric? (getch)))
             (not (eqv? (getch) #\_)))
        (string->symbol (list->string (reverse a)))
      (loop (begin0 (cons (getch) a) (nextch))))))

; 文字列
(define (escape-code c)
  (case c
    ((#\t) #\tab)
    ((#\n) #\newline)
    (else c)))

(define (get-string)
  (nextch)
  (let loop ((buff '()))
    (cond ((eqv? (getch) #\")
           (nextch)
           (list-&gt;string (reverse buff)))
          ((eqv? (getch) #\\)
           ; エスケープ記号
           (nextch)
           (loop (begin0 (cons (escape-code (getch)) buff) (nextch))))
          (else
           (loop (begin0 (cons (getch) buff) (nextch)))))))

; トークンの切り出し
(define (get-token)
  ; 空白文字の読み飛ばし
  (while (char-whitespace? (getch))
    (nextch))
  (cond ((char-numeric? (getch))
         (set! *token* 'number)
         (set! *value* (get-number)))
        ((char-alphabetic? (getch))
         (set! *value* (get-ident))
         (case *value*
           ((def end if then else and or not while do begin let in fn eq)
            (set! *token* *value*))
           (else
            (set! *token* 'ident))))
        (else
         (case (getch)
          ((#\#)
           ; コメントの読み飛ばし
           (while (not (eqv? (getch) #\newline))
             (nextch))
           (get-token))
          ((#\")
           ; 文字列
           (set! *token* 'string)
           (set! *value* (get-string)))
          ((#\=)
           (set! *token* '=)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '==)
             (nextch)))
          ((#\+)
           (set! *token* '+)
           (nextch))
          ((#\-)
           (set! *token* '-)
           (nextch))
          ((#\*)
           (set! *token* '*)
           (nextch))
          ((#\%)
           (set! *token* '%)
           (nextch))
          ((#\/)
           (set! *token* '/)
           (nextch))
          ((#\()
           (set! *token* 'lpar)
           (nextch))
          ((#\))
           (set! *token* 'rpar)
           (nextch))
          ((#\&lt;)
           (set! *token* '&lt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&lt;=)
             (nextch)))
          ((#\&gt;)
           (set! *token* '&gt;)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '&gt;=)
             (nextch)))
          ((#\!)
           (set! *token* 'not)
           (nextch)
           (when (eqv? (getch) #\=)
             (set! *token* '!=)
             (nextch)))
          ((#\,)
           (set! *token* 'comma)
           (nextch))
          ((#\;)
           (set! *token* 'semic)
           (nextch))
          ((#\null)
           (set! *token* 'eof))
          (else
           (set! *token* 'others))))))

;;;
;;; 式の評価
;;;

(define (expression env)
  (let ((val (expr1 env)))
    (case *token*
      ((=)
       (get-token)
       (case (car val)
         ((ld)
          ; 局所変数の代入
          (append (expression env) (list 'lset (cadr val))))
         ((ldg)
          ; 大域変数の代入
          (append (expression env) (list 'gset (cadr val))))
         (else
          (compile-error "invalid assignment form"))))
      (else val))))

; 論理演算子 (and と or の優先順位は同じとする)
(define (expr1 env)
  (let loop ((val1 (expr2 env)))
    (case *token*
      ((and)
       (get-token)
       (loop (append val1 (expr2 env) (list 'and))))
      ((or)
       (get-token)
       (loop (append val1 (expr2 env) (list 'or))))
      (else val1))))

; 比較演算子 (==, !=, &lt;, &lt;=, &gt;, &gt;= の優先順位は同じとする)
(define (expr2 env)
  (let ((val1 (expr3 env)))
    (case *token*
      ((==)
       (get-token)
       (append val1 (expr3 env) (list '==)))
      ((!=)
       (get-token)
       (append val1 (expr3 env) (list '!=)))
      ((&lt;)
       (get-token)
       (append val1 (expr3 env) (list '&lt;)))
      ((&lt;=)
       (get-token)
       (append val1 (expr3 env) (list '&lt;=)))
      ((&gt;)
       (get-token)
       (append val1 (expr3 env) (list '&gt;)))
      ((&gt;=)
       (get-token)
       (append val1 (expr3 env) (list '&gt;=)))
      ((eq)
       (get-token)
       (append val1 (expr3 env) (list 'eq)))
      (else val1))))

(define (expr3 env)
  (let loop ((val (term env)))
    (case *token*
      ((+)
       (get-token)
       (loop (append val (term env) (list '+))))
      ((-)
       (get-token)
       (loop (append val (term env) (list '-))))
      (else val))))

; 項
(define (term env)
  (let loop ((val (factor env)))
    (case *token*
      ((*)
       (get-token)
       (loop (append val (factor env) (list '*))))
      ((/)
       (get-token)
       (loop (append val (factor env) (list '/))))
      ((%)
       (get-token)
       (loop (append val (factor env) (list '%))))
      (else val))))

; 実引数のコンパイル
(define (compile-argument env)
  (get-token)
  (if (eq? *token* 'rpar)
      (begin (get-token) (list 'args 0))
    (let loop ((n 1) (a '()))
      (let ((expr (expression env)))
        (case *token*
          ((rpar)
           (get-token)
           (append (append a expr) (list 'args n)))
          ((comma)
           (get-token)
           (loop (+ n 1) (append a expr)))
          (else
           (compile-error "unexpected token")))))))

; 仮引数の取得
(define (get-parameter)
  (get-token)
  (unless (eq? *token* 'lpar)
    (compile-error "'(' expected"))
  (get-token)
  (let loop ((a '()))
    (let ((val *value*))
      (case *token*
        ((rpar)
         (get-token)
         (reverse a))
        ((ident)
         (let ((val *value*))
           (get-token)
           (loop (cons val a))))
        ((comma)
         (get-token)
         (loop a))
        (else
         (compile-error "unexpected token"))))))

; 位置を求める
(define (position var ls)
  (let loop ((i 0) (ls ls))
    (cond ((null? ls) #f)
          ((eqv? var (car ls)) i)
          (else
           (loop (+ i 1) (cdr ls))))))

; フレームと局所変数の位置を求める
(define (location var ls)
  (let loop ((i 0) (ls ls))
    (if (null? ls)
        #f
      (let ((j (position var (car ls))))
        (if j
            (cons i j)
          (loop (+ i 1) (cdr ls)))))))

; 因子
(define (factor env)
  (case *token*
    ((lpar)
     (get-token)
     (let ((val (expression env)))
       (if (eq? *token* 'rpar)
           (get-token)
         (compile-error "')' expected"))
       val))
    ((number)
     (begin0 (list 'ldc *value*) (get-token)))
    ((string)
     (begin0 (list 'ldc *value*) (get-token)))
    ((not)
     (get-token)
     (append (factor env) (list 'not)))
    ((+)
     ; 単項演算子 (+ をはずすだけ)
     (get-token)
     (factor env))
    ((-)
     ; 単項演算子
     (get-token)
     (append (factor env) (list 'neg)))
    ((fn)
     ; クロージャの生成
     (let ((code (list 'ldf
                       (append (compile-block (cons (get-parameter) env))
                               (list 'rtn)))))
       (get-token)
       (if (eq? *token* 'lpar)
           ; 関数呼び出し
           (append (compile-argument env) code (list 'app))
         code)))
    ((ident)
     (let ((code #f)
           (pos (location *value* env)))
       (if pos
           ; 局所変数
           (set! code (list 'ld pos))
         ; 大域変数
         (set! code (list 'ldg (get-gvar *value*))))
       (get-token)
       (if (eq? *token* 'lpar)
           ; 関数呼び出し
           (append (compile-argument env) code (list 'app))
         ; 変数
         code)))
    (else
     (compile-error "unexpected token"))))

; if 文のコンパイル
(define (compile-if env)
  (let ((test-form (expression env))
        (then-form #f)
        (else-form #f))
    (unless (eq? *token* 'then)
      (compile-error "if: then expected"))
    (get-token)
    (set! then-form (append (compile-statement env) (list 'join)))
    (get-token)  ; end, semic を読み飛ばす
    (if (eq? *token* 'else)
        (begin (get-token)
               (set! else-form
                     (append (begin0 (compile-statement env)
                                     (get-token)) ; end, semic を読み飛ばす
                             (list 'join))))
      (set! else-form (list 'ldc 0 'join)))
    (unless (eq? *token* 'end)
      (compile-error "if: end expected"))
    (append test-form (list 'sel then-form else-form))))

; while 文のコンパイル
(define (compile-while env)
  (let ((test (expression env))
        (body #f))
    (unless (eq? *token* 'do)
      (compile-error "while: do expected"))
    (get-token)
    (set! body (append (compile-block env) (list 'rpt)))
    (append (list 'bgn) test (list 'whl body))))

; block 文のコンパイル
(define (compile-block env)
  (let loop ((code '()))
    (let ((code1 (compile-statement env)))
      (get-token)  ; 実行文の終端 (semic, end) を読み飛ばす
      (cond ((eq? *token* 'end)
             (append code code1))
            (else
             (loop (append code code1 (list 'pop))))))))

; let 文のコンパイル
(define (compile-let env)
  (let loop ((vars '()) (code '()))
    (cond ((eq? *token* 'in)
           (get-token)
           ; 本体コードの生成
           (append code
                   (list 'args
                         (length vars)
                         'ldf
                         (append (compile-block (cons (reverse vars) env))
                                 (list 'rtn))
                         'app)))
          ((eq? *token* 'ident)
           (let ((var *value*))
             (get-token)
             (unless (eq? *token* '=)
               (compile-error "let: invalid assignment form"))
             (get-token)
             (loop (cons var vars) (append code (expr1 env)))))
          ((eq? *token* 'comma)
           (get-token)
           (loop vars code))
          (else
           (compile-error "let: unexpected token")))))

; 実行文のコンパイル
(define (compile-statement env)
  (case *token*
    ((begin)
     (get-token)
     (compile-block env))
    ((if)
     (get-token)
     (compile-if env))
    ((while)
     (get-token)
     (compile-while env))
    ((let)
     (get-token)
     (compile-let env))
    (else
     ; 式文
     (begin0
       (expression env)
       (unless (eq? *token* 'semic)
         (compile-error "';' expected"))))))

; コンパイル
(define (compile)
  (cond ((eq? *token* 'def)
         ; 関数定義
         (get-token)
         (unless (eq? *token* 'ident)
           (compile-error "invalid def form"))
         (let ((name *value*)
               (code (append (compile-block (list (get-parameter)))
                             (list 'rtn))))
           (list 'ldf code 'gset (get-gvar name))))
        (else
         (compile-statement '()))))

;;;
;;; 仮想マシン
;;;

;
(define (drop ls n)
  (if (or (zero? n) (null? ls))
      ls
    (drop (cdr ls) (- n 1))))

; 局所変数の値を求める
(define (get-lvar e i j)
  (list-ref (list-ref e i) j))

; 局所変数の値を更新する
(define (set-lvar! e i j val)
  (set-car! (drop (list-ref e i) j) val))

(define (vm s e c d)
  (case (car c)
    ((+)
     (vm (cons (+ (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((-)
     (vm (cons (- (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((*)
     (vm (cons (* (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((/)
     (vm (cons (/ (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((%)
     (vm (cons (modulo (cadr s) (car s)) (cddr s)) e (cdr c) d))
    ((==)
     (vm (cons (if (= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((!=)
     (vm (cons (if (= (cadr s) (car s)) 0 1) (cddr s)) e (cdr c) d))
    ((&lt;)
     (vm (cons (if (&lt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;=)
     (vm (cons (if (&lt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;)
     (vm (cons (if (&lt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&lt;=)
     (vm (cons (if (&lt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&gt;)
     (vm (cons (if (&gt; (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((&gt;=)
     (vm (cons (if (&gt;= (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((eq)
     (vm (cons (if (eqv? (cadr s) (car s)) 1 0) (cddr s)) e (cdr c) d))
    ((and)
     (vm (cons (if (zero? (logand (cadr s) (car s))) 0 1) (cddr s)) e (cdr c) d))
    ((or)
     (vm (cons (if (zero? (logior (cadr s) (car s))) 0 1) (cddr s)) e (cdr c) d))
    ((neg)
     (vm (cons (- (car s)) (cdr s)) e (cdr c) d))
    ((not)
     (vm (cons (if (zero? (car s)) 1 0) (cdr s)) e (cdr c) d))
    ((ld)
     (let ((pos (cadr c)))
       (vm (cons (get-lvar e (car pos) (cdr pos)) s) e (cddr c) d)))
    ((ldc)
     (vm (cons (cadr c) s) e (cddr c) d))
    ((ldg)
     ; c = (ldg (sym . val) ...)
     (vm (cons (cdr (cadr c)) s) e (cddr c) d))
    ((ldf)
     (vm (cons (list 'closure (cadr c) e) s) e (cddr c) d))
    ((lset)
     (let ((pos (cadr c)))
       (set-lvar! e (car pos) (cdr pos) (car s))
       (vm s e (cddr c) d)))
    ((gset)
     ; c = (gset (sym . val) ...)
     (set-cdr! (cadr c) (car s))
     (vm s e (cddr c) d))
    ((app)
     (let ((clo (car s)) (lvar (cadr s)))
       (case (car clo)
         ((primitive)
          ; (primitive function)
          (vm (cons (apply (cadr clo) lvar) (cddr s)) e (cdr c) d))
         (else
          ; (closure code env)
          (vm '()
              (cons lvar (caddr clo))
              (cadr clo)
              (cons (list (cddr s) e (cdr c)) d))))))
    ((rtn)
     (let ((save (car d)))
       (vm (cons (car s) (car save)) (cadr save) (caddr save) (cdr d))))
    ((sel)
     (let ((t-clause (cadr c))
           (e-clause (caddr c)))
       (if (zero? (car s))
           (vm (cdr s) e e-clause (cons (cdddr c) d))
         (vm (cdr s) e t-clause (cons (cdddr c) d)))))
    ((join)
     (vm s e (car d) (cdr d)))
    ((pop)
     (vm (cdr s) e (cdr c) d))
    ((args)
     (let loop ((n (cadr c)) (a '()))
       (if (zero? n)
           (vm (cons a s) e (cddr c) d)
         (loop (- n 1) (cons (pop! s) a)))))
    ((bgn)
     (vm s e (cdr c) (cons (cdr c) d)))
    ((whl)
     (if (zero? (car s))
         (vm (cons 0 (cdr s)) e (cddr c) (cdr d))
       (vm (cdr s) e (cadr c) d)))
    ((rpt)
     (vm (cdr s) e (car d) d))
    ((halt)
     (car s))
    (else
     (error "vm: unexpected code:" (car c)))))

;;;
;;;
;;;

; ファイルのロード
(define (load-file name)
  (call-with-input-file name
    (lambda (in)
      (let ((save-input *input*)
            (save-token *token*)
            (save-value *value*)
            (save-ch    *ch*)
            (save-line  *line*)
            (save-col   *col*))
        (set! *input* in)
        (set! *line* 1)
        (set! *col*  0)
        (nextch)
        (unwind-protect
          (let loop ()
            (get-token)
            (when (not (eq? *token* 'eof))
              (vm '() '() (append (compile) (list 'halt)) '())
              (loop)))
          (begin
            (set! *input* save-input)
            (set! *token* save-token)
            (set! *value* save-value)
            (set! *ch*    save-ch)
            (set! *line*  save-line)
            (set! *col*   save-col)))))))

; 入力をクリアする
(define (clear-input-data)
  (while (not (eqv? *ch* #\return))
    (nextch)))

; プロンプトの表示
(define (prompt)
  (display "Calc&gt; ")
  (flush)
  (set! *line* 0)
  (set! *col* 0))

; 実行
(define (calc)
  (prompt)
  (nextch)
  (call/cc
    (lambda (break)
      (let loop ()
        (guard (err
                 ((&lt;error&gt; err)
                  (format #t "ERROR: ~S~%" (condition-ref err 'message))
                  (clear-input-data)))
          (get-token)
          (when (eqv? *token* 'eof) (break #t))
          (let ((val (vm '() '() (append (compile) (list 'halt)) '())))
            (display "=&gt; ")
            (display (if (pair? val) (car val) val))
            (newline)))
        (prompt)
        (loop)))))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm55.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm57.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>