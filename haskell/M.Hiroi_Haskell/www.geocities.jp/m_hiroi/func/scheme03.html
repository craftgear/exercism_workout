<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Scheme Junk Scripts</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scheme Programming</h1>
<h2>Scheme Junk Scripts</h2>
<div class="small">
[ <a href="scheme02.html">PrevPage</a> | <a href="scheme.html#junk">Scheme</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="prime">素数</h3>
<p> 素数を求めるプログラムです。
</p>
<h4>●プログラム</h4>
<pre class="list">
;
; prime.scm : 素数を求める
;

; 素数のチェック
(define (prime? x ls)
  (let loop ((ls ls))
    (cond ((null? ls) #t)
          ((&lt; (* x x) (car ls)) #t)
          ((zero? (modulo x (car ls))) #f)
          (else (loop (cdr ls))))))

; 素数を求める（単純版）
(define (prime n)
  (let loop ((m 3) (ls '(2)))
    (cond ((&lt; n m) ls)
          ((prime? m ls)
           (loop (+ m 2) (append ls (list m))))
          (else (loop (+ m 2) ls)))))

; テスト
(display (prime 100))

;
; エラトステネスの篩 (vector 版)
;

; 倍数を削除
(define (delete-number a n end inc)
  (when (&lt;= n end)
    (vector-set! a n #f)
    (delete-number a (+ n inc) end inc)))

; 素数を求める
(define (sieve n)
  (let ((count 1)
        (flag (make-vector (+ n 1) #t)))
    (format #t "~8D" 2)
    (let loop ((x 0))
      (when (&lt;= x n)
        (if (vector-ref flag x)
          (let ((p (+ (* 2 x) 3)))
            (format #t "~8D" p)
            ; p の倍数を削除
            (delete-number flag (+ x p) n p)
            (set! count (+ count 1))))
        (loop (+ x 1))))
    (format #t "~%total = ~D~%" count)))

; テスト
(sieve 50)

;
; stream 版 (参考文献 SICP 3.5)
;
(use util.stream)

(define (divisible? x y) (= (remainder x y) 0))

; 素数の生成
(define (sieve s)
  (stream-cons
    (stream-car s)
    (sieve (stream-filter
             (lambda (x) (not (divisible? x (stream-car s))))
             (stream-cdr s)))))

; テスト
(let loop ((n 0) (s (sieve (stream-iota -1 2))))
  (when (&lt; n 25)
    (format #t "~8D" (stream-car s))
    (loop (+ n 1) (stream-cdr s))))
</pre>
<h4>●実行例</h4>
<pre>
(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)
</pre>
<pre>
       2       3       5       7      11      13      17      19
      23      29      31      37      41      43      47      53
      59      61      67      71      73      79      83      89
      97     101     103
total = 27
</pre>
<pre>
       2       3       5       7      11      13      17      19
      23      29      31      37      41      43      47      53
      59      61      67      71      73      79      83      89
      97
</pre>
<hr>
<h3 id="keiro">経路の探索</h3>
<pre class="fig">
    1       3       5
    Ｂ───Ｄ───Ｆ
0 ／│      │
Ａ  │      │
  ＼│      │
    Ｃ───Ｅ───Ｇ
    2       4       6

    図 : 経路の探索
</pre>
<p> スタート (A) からゴール (F) までの経路を求めるプログラムです。
</p>
<h4>●プログラム</h4>
<pre class="list">
;
; 隣接リスト (連想リストで表現)
;
(define *adjacent*
  '((a b c)
    (b a c d)
    (c a b e)
    (d b e f)
    (e c d g)
    (f d)
    (g e)))

;
; 深さ優先探索
;
(define (depth-search goal path)
  (cond ((eq? goal (car path))
         (display (reverse path))
         (newline))
        (else
         (for-each
           (lambda (n)
             (unless (memq n path)
               (depth-search goal (cons n path))))
           (assq (car path) *adjacent*)))))

;
; 幅優先探索
;
(use util.queue)

(define (breadth-search start goal)
  (let ((q (make-queue)))
    (enqueue! q (list start))
    (while (not (queue-empty? q))
      (let ((path (dequeue! q)))
        (cond ((eq? (car path) goal)
               (display (reverse path))
               (newline))
              (else
               (for-each
                 (lambda (n)
                   (unless (memq n path)
                     (enqueue! q (cons n path))))
                 (assq (car path) *adjacent*))))))))

;
; 反復深化
;
(define (id-search limit goal path)
  (cond ((= limit (length path))
         (when (eq? (car path) goal)
           (display (reverse path))
           (newline)))
        (else
         (for-each
           (lambda (n)
             (unless (memq n path)
               (id-search limit goal (cons n path))))
           (assq (car path) *adjacent*)))))

; テスト
; 深さ優先探索
(depth-search 'g '(a))
(newline)

; 幅優先探索
(breadth-search 'a 'g)
(newline)

; 反復深化
(let loop ((n 1))
  (when (&lt; n 8)
    (format #t "~D move~%" n)
    (id-search n 'g '(a))
    (loop (+ n 1))))
</pre>
<h4>●実行例</h4>
<pre>
; 深さ優先探索
(a b c e g)
(a b d e g)
(a c b d e g)
(a c e g)

; 幅優先探索
(a c e g)
(a b c e g)
(a b d e g)
(a c b d e g)

; 反復深化
1 move
2 move
3 move
4 move
(a c e g)
5 move
(a b c e g)
(a b d e g)
6 move
(a c b d e g)
7 move
</pre>
<hr>
<h3 id="hanoi">ハノイの塔</h3>
<p> ハノイの塔は、棒に刺さっている大きさが異なる複数の円盤を、次の規則に従ってほかの棒に移動させるパズルです。
</p>
<ol>
  <li>一回に一枚の円盤しか移動できない。
  <li>小さな円盤の上に大きな円盤を置くことはできない。
  <li>最初すべての円盤は一本の棒に刺さっていて、各円盤はそれより大きな円盤の上に置かれている。
</ol>
<p> ハノイの塔は、再帰を使えば簡単に解ける問題です。
</p>
<h4>●プログラム</h4>
<pre class="list">
;
; hanoi.scm : ハノイの塔
;
(define (hanoi n from to via)
  (cond ((= n 1)
         (format #t "disk ~D: from ~A to ~A~%" n from to))
        (else
         (hanoi (- n 1) from via to)
         (format #t "disk ~D: from ~A to ~A~%" n from to)
         (hanoi (- n 1) via to from))))

(hanoi 3 'a 'b 'c)
</pre>
<h4>●実行結果</h4>
<pre>
disk 1: from a to b
disk 2: from a to c
disk 1: from b to c
disk 3: from a to b
disk 1: from c to a
disk 2: from c to b
disk 1: from a to b
</pre>
<HR>
<h3 id="komachi">小町算</h3>
<div class="question">
<b>[問題]</b> 小町算
<p>1 から 9 までの数字を順番に並べ、間に + と - を補って 100 になる式を作ってください。
</p>
<p> 例：1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
</p>
</div>
<p> パズルの世界では、1 から 9 までの数字を 1 個ずつすべて使った数字を <b>小町数</b> といいます。たとえば、123456789 とか 321654987 のような数字です。<b>小町算</b> というものもあり、たとえば 123 + 456 + 789 とか 321 * 654 + 987 のようなものです。この問題は小町算の中でも特に有名なパズルです。
</p>

<h4>●プログラム</h4>
<pre class="list">
;
; komachi.scm : 小町算
;
;                Copyright (C) 2006 Makoto Hiroi
;

; 解の表示
(define (print-answer expr)
  (cond ((null? expr) (format #t "= 100~%"))
        (else
         (format #t "~A " (car expr))
         (print-answer (cdr expr)))))

; 式を計算する
(define (calc-expr ls num expr)
  (cond ((null? ls)
         (if (= num 100)
             (print-answer (reverse expr))))
        (else
         (calc-expr (cdr ls) (+ num (car ls)) (cons (car ls) (cons '+ expr)))
         (calc-expr (cdr ls) (- num (car ls)) (cons (car ls) (cons '- expr))))))

; 数値の生成
(define (make-number n ls)
  (cond ((= n 10)
         (let ((rs (reverse ls)))
           (calc-expr (cdr rs) (car rs) (list (car rs)))))
        (else
         (make-number (+ n 1) (cons n ls))
         (make-number (+ n 1) (cons (+ (* (car ls) 10) n) (cdr ls))))))

; 実行
(make-number 2 '(1))
</pre>
<h4>●実行結果</h4>
<pre>
1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100
1 + 2 + 34 - 5 + 67 - 8 + 9 = 100
1 + 23 - 4 + 5 + 6 + 78 - 9 = 100
1 + 23 - 4 + 56 + 7 + 8 + 9 = 100
12 + 3 + 4 + 5 - 6 - 7 + 89 = 100
12 - 3 - 4 + 5 - 6 + 7 + 89 = 100
12 + 3 - 4 + 5 + 67 + 8 + 9 = 100
123 - 4 - 5 - 6 - 7 + 8 - 9 = 100
123 + 4 - 5 + 67 - 89 = 100
123 + 45 - 67 + 8 - 9 = 100
123 - 45 - 67 + 89 = 100
</pre>
<hr>
<h3 id="knight">騎士の巡歴</h3>
<p> 騎士（ナイト）はチェスの駒のひとつで、将棋の桂馬の動きを前後左右にとることができます。次の図を見てください。
</p>
<pre class="fig">
    ┌─┬─┬─┬─┬─┐
    │  │●│  │●│  │
    ├─┼─┼─┼─┼─┤        ┌─┬─┐ 
    │●│  │  │  │●│        │Ｋ│  │ 
    ├─┼─┼─┼─┼─┤    ┌─┼─┼─┼─┐ 
    │  │  │Ｋ│  │  │    │  │  │  │  │ 
    ├─┼─┼─┼─┼─┤    ├─┼─┼─┼─┤ 
    │●│  │  │  │●│    │  │  │  │  │ 
    ├─┼─┼─┼─┼─┤    └─┼─┼─┼─┘ 
    │  │●│  │●│  │        │  │  │ 
    └─┴─┴─┴─┴─┘        └─┴─┘ 

 ●：ナイト (K) が動ける位置        問題Ａ

                図 : 騎士の巡歴
</pre>
<p> このナイトを動かして、 N 行 M 列の盤面のどのマスにもちょうど一回ずつ訪れるような経路を求めるのが問題です。ちなみに、3 行 3 列、4 行 4 列の盤面には解がありませんが、5 行 5 列の盤面には解があります。大きな盤面を解くのは大変なので、問題 A の盤面でナイトの移動経路を求めてください。プログラムを作る前に、自分で考えてみるのも面白いでしょう。
</p>
<h4>●プログラム</h4>
<pre class="list">
;
; knight.scm : 騎士の巡歴
;
;              Copyright (C) 2006 Makoto Hiroi
;

; 盤面
;    0  1
; 2  3  4  5
; 6  7  8  9
;   10 11
;

; 隣接リスト
(define *adjacent*
        #((5 6 8)   ; 0
          (2 7 9)   ; 1
          (1 8 10)  ; 2
          (9 11)    ; 3
          (6 10)    ; 4
          (0 7 11)  ; 5
          (0 4 11)  ; 6
          (1 5)     ; 7
          (0 2)     ; 8
          (1 3 10)  ; 9
          (2 4 9)   ; 10 
          (3 5 6))) ; 11

; 単純な深さ優先探索
(define (knight-tour n path)
  (if (= n 12)
      ; 解を発見
      (format #t "~A~%" (reverse path))
      (dolist (x (vector-ref *adjacent* (car path)))
        (unless (memv x path)
          ; 再帰呼び出し
          (knight-tour (+ n 1) (cons x path))))))

; 実行
(knight-tour 1 '(0))
</pre>
<h4>●実行例</h4>
<pre>
(0 5 7 1 9 3 11 6 4 10 2 8)
(0 6 4 10 9 3 11 5 7 1 2 8)
(0 8 2 1 7 5 11 3 9 10 4 6)
(0 8 2 1 7 5 11 6 4 10 9 3)
(0 8 2 10 4 6 11 3 9 1 7 5)
(0 8 2 10 4 6 11 5 7 1 9 3)
</pre>
<hr>
<h3 id="queen">８クイーン</h3>
<div class="question">
<b>[問題] ８クイーン</b>
<p> 8 クイーンは 8 行 8 列のチェスの升目に 8 個のクイーンを互いの利き筋が重ならないように配置する問題です。これはコンピュータに解かせるパズルの中でもとくに有名な問題です。クイーンは将棋の飛車と角をあわせた駒で、縦横斜めに任意に動くことができます。解答の一例を次に示します。
</p>
<pre class="fig">
  *-----------------*
  | Q . . . . . . . |
  | . . . . Q . . . |
  | . . . . . . . Q |
  | . . . . . Q . . |
  | . . Q . . . . . |
  | . . . . . . Q . |
  | . Q . . . . . . |
  | . . . Q . . . . |
  *-----------------*

図 : 8 クイーンの解答例
</pre>
</div>
<h4>●プログラム</h4>
<pre class="list">
;
; queen.scm : 8 クイーンの解法
;
;             Copyright (C) 2006 Makoto Hiroi
;

; 盤面の表示
(define (print-board board)
  (define (print-line q size)
    (display "| ")
    (let loop ((x 0))
      (when (&lt; x size)
        (if (= x q)
            (display "Q ")
            (display ". "))
        (loop (+ x 1))))
    (display "|\n"))
  (define (print-waku size)
    (display "*-")
    (let loop ((x 0))
      (when (&lt; x size)
        (display "--")
        (loop (+ x 1))))
    (display "*\n"))
  (let ((size (length board)))
    (print-waku size)
    (let loop ((ls board))
      (when (pair? ls)
        (print-line (car ls) size)
        (loop (cdr ls))))
    (print-waku size)
    (newline)))


; 数字を削除する
(define (remove x ls)
  (cond ((null? ls) '())
        ((eqv? x (car ls))
         (remove x (cdr ls)))
        (else
         (cons (car ls) (remove x (cdr ls))))))

; 衝突するか
(define (attack x xs)
  (define (attack-sub x n ls)
    (cond ((null? ls) #t)
          ((or (= x (+ (car ls) n))
               (= x (- (car ls) n)))
           #f)
          (else
           (attack-sub x (+ n 1) (cdr ls)))))
  (attack-sub x 1 xs))

; 8 クイーンの解法
(define (queen nums board)
  (if (null? nums)
      (print-board board)
      (for-each
        (lambda (x)
          (if (attack x board)
              (queen (remove x nums) (cons x board))))
        nums)))

(queen '(0 1 2 3 4 5 6 7) '())
</pre>
<h4>●実行例</h4>
<pre>
*-----------------*
| . . . Q . . . . |
| . Q . . . . . . |
| . . . . . . Q . |
| . . Q . . . . . |
| . . . . . Q . . |
| . . . . . . . Q |
| . . . . Q . . . |
| Q . . . . . . . |
*-----------------*

 ・・・省略・・・

*-----------------*
| . . . . Q . . . |
| . . . . . . Q . |
| . Q . . . . . . |
| . . . . . Q . . |
| . . Q . . . . . |
| Q . . . . . . . |
| . . . Q . . . . |
| . . . . . . . Q |
*-----------------*
</pre>
<p> 解は重複解を含めて全部で 92 通りです。
</p>
<hr>
<h3 id="eight">８パズル</h3>
<div class="question">
<b>[問題] 8 パズル</b>
<pre class="fig">
 ┌─┬─┬─┐    ┌─┬─┬─┐  
 │１│２│３│    │？│？│？│  
 ├─┼─┼─┤    ├─┼─┼─┤  
 │４│５│６│ =&gt; │？│？│？│  
 ├─┼─┼─┤    ├─┼─┼─┤  
 │７│８│  │    │？│？│？│  
 └─┴─┴─┘    └─┴─┴─┘  
      GOAL         最長手数の局面
</pre>
<p> 8 パズルは上図 GOAL のように 1 から 8 までの駒を並べるパズルです。駒の動かし方は、1 回に 1 個の駒を空いている隣の場所に滑らせる、というものです。駒を飛び越したり持ち上げたりすることはできません。今回は GOAL までの最長手数とその局面をすべて求めてください。
</p>
</div>
<h4>●プログラム</h4>
<pre class="list">
;
; eight.scm : 8 パズル (最長手数を求める)
;
;             Copyright (C) 2006 Makoto Hiroi
;

; 盤面
; 0 1 2
; 3 4 5
; 6 7 8
;

; 隣接リスト
(define adjacent
        #((1 3)   (0 2 4)   (1 5)
          (0 4 6) (1 3 5 7) (2 4 8)
          (3 7)          (4 6 8)   (5 7)))

; 局面を格納するベクタとハッシュ
(define size 181440)
(define state (make-vector size))
(define space (make-vector size))
(define move  (make-vector size))
(define hash  (make-hash-table 'equal?))

; 駒を動かす (piece を space に移動)
(define (move-piece piece board)
  (cond ((null? board) '())
        ((= (car board) 0)
         (cons piece (move-piece piece (cdr board))))
        ((= (car board) piece)
         (cons 0 (move-piece piece (cdr board))))
        (else
         (cons (car board) (move-piece piece (cdr board))))))

; 解を表示
(define (print-answer n)
  (let ((mv (vector-ref move n)))
    (format #t "max move = ~D~%" mv)
    (let loop ((n n))
      (when (= mv (vector-ref move n))
        (format #t "~A~%" (vector-ref state n))
        (loop (- n 1))))))


; 幅優先探索
(define (solve)
  ; 初期化
  (vector-set! state 0 '(1 2 3 4 5 6 7 8 0))
  (vector-set! move  0 0)
  (vector-set! space 0 8)
  (hash-table-put! hash '(1 2 3 4 5 6 7 8 0) #t)
  ;
  (let loop ((rp 0) (wp 1))
    (if (= rp wp)
        (print-answer (- wp 1))
        (let ((st (vector-ref state rp))
              (mv (vector-ref move rp)))
          (dolist (x (vector-ref adjacent (vector-ref space rp)))
            (let ((new-st (move-piece (list-ref st x) st)))
              (unless (hash-table-get hash new-st #f)
                (vector-set! state wp new-st)
                (vector-set! move  wp (+ mv 1))
                (vector-set! space wp x)
                (hash-table-put! hash new-st #t)
                (set! wp (+ wp 1)))))
          (loop (+ rp 1) wp)))))

; 実行
(solve)
</pre>
<h4>●実行例</h4>
<pre>
max move = 31
(8 6 7 2 5 4 3 0 1)
(6 4 7 8 5 0 3 2 1)
</pre>
<hr>
<h3 id="tictactoe">三目並べ</h3>
<p> 三目並べは、皆さんお馴染みの二人で対戦するゲームです。ひとりが○側でもうひとりが×側を受け持ち、3 行 3 列のマス目に○×を書いて、3 つ並べた方が勝ちというゲームです。次の図は○側が先手で引き分けになった例です。
</p>
<pre class="fig">
 ┌─┬─┬─┐ 
 │×│○│○│ 
 ├─┼─┼─┤ 
 │○│○│×│ 
 ├─┼─┼─┤ 
 │×│×│○│ 
 └─┴─┴─┘ 

  図：三目並べ
</pre>
<p> <a href="scheme03.html#cite1">参考文献 [1]</a> によると、三目並べで両者が次の戦略を用いると、ゲームは常に引き分けになります。
</p>
<ol>
  <li>3 つ並べることができるならばそうする
  <li>相手が 3 つ並べるのを妨げる
  <li>可能ならば中央へ着手する
  <li>可能ならば隅へ着手する
</ol>
<p> プログラム１は、この戦略で指し手を選びます。また、三目並べは両者が最善を尽くすと引き分けになることが知られています。プログラム２はミニマックス法を使って、初手がどこでも結果は引き分けになることを確かめます。
</p>
<h4 id="cite1">●参考文献</h4>
<ol>
  <li>松原仁・竹内郁雄 編著,『bit別冊 ゲームプログラミング』, 共立出版, 1997
</ol>
<h4>●プログラム１</h4>
<pre class="list">
;
; tictactoe.scm : 三目並べ
;
;                 Copyright (C) 2006 Makoto Hiroi
;

; 盤面の大きさ
(define SIZE 9)

; 盤面
; まる maru, ばつ batu, 空き space
(define *board* (make-vector SIZE 'space))

; アクセサ
(define (get-piece x) (vector-ref *board* x))
(define (set-piece! x p) (vector-set! *board* x p))
(define (space? x) (eq? (get-piece x) 'space))

; 直線
(define *line*
        '((0 1 2) (3 4 5) (6 7 8)
          (0 3 6) (1 4 7) (2 5 8)
          (0 4 8) (2 4 6)))

; 位置から直線を求める
(define *position-line*
        #(((1 2) (4 8) (3 6))
          ((0 2) (4 7))
          ((0 1) (4 6) (5 8))
          ((0 6) (4 5))
          ((0 8) (1 7) (2 6) (3 5))
          ((2 8) (3 4))
          ((0 3) (2 4) (7 8))
          ((1 4) (6 8))
          ((0 4) (2 5) (6 7))))

; 同じ駒か
(define (same-piece? p a b)
  (and (eq? (get-piece a) p)
       (eq? (get-piece b) p)))

; 3 個並ぶ場所があるか
(define (win-position? x p)
  (let loop ((ls (vector-ref *position-line* x)))
    (cond ((null? ls) #f)
          ((apply same-piece? p (car ls)) #t)
          (else (loop (cdr ls))))))

; 3 個並ぶ場所を探す
(define (find-win-position p)
  (let loop ((x 0))
    (cond ((&lt;= SIZE x) #f)
          ((and (space? x) (win-position? x p)) x)
          (else (loop (+ x 1))))))

; 空いている隅を返す
(define (find-corner)
  (let loop ((ls '(0 2 6 8)))
    (cond ((null? ls) #f)
          ((space? (car ls)) (car ls))
          (else (loop (cdr ls))))))

; 空いている場所を探す
(define (find-space)
  (let loop ((x 0))
    (cond ((&lt;= SIZE x) #f)
          ((space? x) x)
          (else (loop (+ x 1))))))

; 3 つ並んだか
(define (check-line a b c)
  (let ((p (get-piece a)))
    (and (not (eq? 'space p))
         (eq? (get-piece b) p)
         (eq? (get-piece c) p)
         p)))

; 勝負の判定
(define (check-winner)
  (let loop ((ls *line*))
    (if (null? ls)
        #f
        (let ((result (apply check-line (car ls))))
          (if result
              result
              (loop (cdr ls)))))))

; 盤面を表示する
(define (print-board)
  (let ((piece-list '((maru . "O") (batu . "X") (space . "."))))
    (dotimes (x 9)
      (format #t "~A " (cdr (assq (get-piece x) piece-list)))
      (if (or (= x 2) (= x 5) (= x 8)) (newline)))))

; 終了判定
(define (game-over)
  (let ((win (check-winner)))
    (cond (win
           (format #t "~A win!" win)
           #t)
          ((not (find-space))
           (format #t "draw")
           #t)
          (else #f))))

; コンピュータの指し手を決める
(define (move-com turn)
  ; 自分の手番で勝ちがあるか
  (let ((pos (find-win-position turn)))
    (unless pos
      ; 相手の手番で勝ちがあるか
      (set! pos (find-win-position (if (eq? 'maru turn) 'batu 'maru)))
      (unless pos
        ; 中央が空いているか
        (set! pos 4)
        (unless (space? 4)
          ; 隅が取れるか
          (set! pos (find-corner))
          (unless pos
            ; 空き場所を返すだけ
            (set! pos (find-space))))))
    ; 場所を返す
    pos))

; 人間側の指し手
(define (move-human)
  (let loop ()
    (format #t "input number (0 - 8) &gt; ")
    (flush)
    (let ((pos (read)))
      (cond ((and (integer? pos) (&lt;= 0 pos 8) (space? pos))
             pos)
            (else
             (format #t "input error~%")
             (loop))))))

;
; 三目並べ
; trun = maru 先手
;        batu 後手
;
(define (tic-tac-toe human)
  (let ((pos #f) (turn 'maru))
    (print-board)
    (let loop ()
      (set! pos (if (eq? human turn)
                    (move-human)
                    (move-com turn)))
      (format #t "~%put ~D~%" pos)
      (set-piece! pos turn)
      (print-board)
      (set! turn (if (eq? turn 'maru) 'batu 'maru))
      ; ゲーム終了のチェック
      (if (game-over) #t (loop)))))

; 実行
(tic-tac-toe 'maru)
</pre>
<h4>●プログラム２</h4>
<pre class="list">
;
; tictactoe1.scm : 三目並べ
;
;                 Copyright (C) 2006 Makoto Hiroi
;

(define MIN-VALUE -2)
(define MAX-VALUE 2)
(define MARU 1)
(define BATU -1)
(define DRAW 0)
(define SIZE 9)

; 盤面
; まる maru, ばつ batu, 空き space
(define *board* (make-vector SIZE 'space))

; アクセサ
(define (get-piece x) (vector-ref *board* x))
(define (set-piece! x p) (vector-set! *board* x p))
(define (space? x) (eq? (get-piece x) 'space))

; 直線
(define *line*
        '((0 1 2) (3 4 5) (6 7 8)
          (0 3 6) (1 4 7) (2 5 8)
          (0 4 8) (2 4 6)))

; 3 つ並んだか
(define (check-line a b c)
  (let ((p (get-piece a)))
    (and (not (eq? 'space p))
         (eq? (get-piece b) p)
         (eq? (get-piece c) p)
         p)))

; 勝負の判定
(define (check-winner)
  (let loop ((ls *line*))
    (if (null? ls)
        DRAW
        (let ((result (apply check-line (car ls))))
          (cond ((eq? result 'maru) MARU)
                ((eq? result 'batu) BATU)
                (else (loop (cdr ls))))))))

; 先手（まる）
(define (think-maru n)
  (let ((value MIN-VALUE))
    (dotimes (x SIZE value)
      (when (space? x)
        (set-piece! x 'maru)
        (let ((v (check-winner)))
          (if (and (= v DRAW) (&lt; n (- SIZE 1)))
            (set! v (think-batu (+ n 1))))
          (if (&gt; v value) (set! value v)))
        (set-piece! x 'space)))))

; 後手（ばつ）
(define (think-batu n)
  (let ((value MAX-VALUE))
    (dotimes (x SIZE value)
      (when (space? x)
        (set-piece! x 'batu)
        (let ((v (check-winner)))
          (if (and (= v DRAW) (&lt; n (- SIZE 1)))
            (set! v (think-maru (+ n 1))))
          (if (&lt; v value) (set! value v)))
        (set-piece! x 'space)))))

; 
(define (solve)
  (dotimes (x SIZE)
    (set-piece! x 'maru)
    (format #t "~D: value = ~D~%" x (think-batu 1))
    (set-piece! x 'space)))

(solve)
</pre>
<h4>●プログラム２の実行例</h4>
<pre>
0: value = 0
1: value = 0
2: value = 0
3: value = 0
4: value = 0
5: value = 0
6: value = 0
7: value = 0
8: value = 0
</pre>
<p> 初手がどこでも引き分け (value = 0) になります。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2006 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scheme02.html">PrevPage</a> | <a href="scheme.html#junk">Scheme</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>