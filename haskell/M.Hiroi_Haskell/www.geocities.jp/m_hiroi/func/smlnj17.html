<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Standard ML of New Jersey 入門</title>
  <meta name="description" content="Standard ML of New Jersey,SML/NJ,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881757</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Standard ML of New Jersey 入門</h2>
<div class="small">
[ <a href="smlnj16.html">PrevPage</a> | <a href="index.html">SML/NJ</a> | <a href="smlnj18.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">遅延ストリーム (2)</h3>
<p> 遅延ストリームの続きです。今回は遅延ストリームを使った応用例として、素数や順列を生成するプログラムを作ってみましょう。遅延評価はモジュール SMLofNJ.Susp ではなくキーワード lazy を使うことにします。なお、このドキュメントは拙作のページ <a href="ocaml.html">OCaml 入門</a> <a href="ocaml24.html">遅延ストリーム (2)</a> のプログラムを SML/NJ で書き直したものです。内容は重複していますが、ご了承くださいませ。
</p>

<h4>●遅延ストリームの操作関数 (2)</h4>
<p> まずは最初に、2 つの遅延ストリームを受け取って 1 つのストリームを返す関数を考えます。一番簡単な操作は 2 つのストリームを結合することです。次のリストを見てください。
</p>

<pre class="list">
リスト : 遅延ストリームの結合

(* 例外 *)
exception Empty_stream

(* 遅延ストリームの定義 *)
datatype lazy 'a stream = Nils | Cons of 'a * 'a stream

(* 遅延ストリームの結合 *)
fun lazy stream_append(Nils, s2) = s2
|        stream_append(Cons(x, tail), s2) = Cons(x, stream_append(tail, s2))
</pre>

<p> 関数 stream_append はストリーム s1 と s2 を結合したストリームを返します。処理は簡単で、s1 の要素を順番に取り出していき、s1 が空になったら s2 を返すだけです。遅延ストリームの定義に lazy を指定しているので、tail と引数 Cons(...) をパターンマッチングするときに tail が評価 (force) されます。
</p>
<p> stream_append の型は次のようになります。
</p>
<pre class="item">
val stream_append = fn : 'a stream! susp * 'a stream! susp -&gt; 'a stream! susp
val stream_append_ = fn : 'a stream! susp * 'a stream! susp -&gt; 'a stream!
</pre>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
- val s1 = intgen(1, 4);
val s1 = $$ : int stream! susp
- val s2 = intgen(11, 14);
val s2 = $$ : int stream! susp
- val s3 = stream_append(s1, s2);
val s3 = $$ : int stream! susp
- stream_take(s3, 8);
val it = [1,2,3,4,11,12,13,14] : int list
</pre>
<p> 次はストリーム s1 と s2 の要素を交互に出力するストリームを作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : ストリームの要素を交互に出力

fun lazy interleave(Nils, s2) = s2
|        interleave(Cons(x, tail), s2) = Cons(x, interleave(s2, tail))
</pre>

<p> 関数 interleave はストリーム s1 と s2 を受け取ります。そして、s1 の要素を新しいストリームに格納したら、次は s2 の要素を新しいストリームに格納します。これは遅延オブジェクトで interleave を呼び出すとき、引数 s1 と s2 の順番を交換するだけです。これで s1 と s2 の要素を交互に出力することができます。
</p>
<p> interleave の型は次のようになります。
</p>
<pre class="item">
val interleave = fn : 'a stream! susp * 'a stream! susp -&gt; 'a stream! susp
val interleave_ = fn : 'a stream! susp * 'a stream! susp -&gt; 'a stream!
</pre>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
- val s4 = interleave(s1, s2);
val s4 = $$ : int stream! susp
- stream_take(s4, 8);
val it = [1,11,2,12,3,13,4,14] : int list
</pre>

<p> stream_append の場合、無限ストリームを結合することはできませんが、interleave ならば無限ストリームにも対応することができます。簡単な例を示しましょう。
</p>
<pre>
- val rec lazy ones = Cons(1, ones);
val ones = $$ : int stream! susp
- stream_take(ones, 8);
val it = [1,1,1,1,1,1,1,1] : int list
- val rec lazy twos = Cons(2, twos);
val twos = $$ : int stream! susp
- stream_take(interleave(ones, twos), 10);
val it = [1,2,1,2,1,2,1,2,1,2] : int list
</pre>

<p> ones は 1 を無限に出力するストリームで、twos は 2 を無限に出力するストリームです。stream_append で ones と twos を結合しても無限に 1 を出力するだけですが、interleave で ones と twos を結合すれば、1 と 2 を交互に出力することができます。これで無限ストリームの要素を混ぜ合わせることができます。
</p>

<h4>●高階関数 (2)</h4>
<p> 2 つのストリームを受け取るマップ関数 stream_map2 も簡単です。プログラムは次のようになります。
</p>
<pre class="list">
リスト : マップ関数

fun lazy stream_map2 _ Nils _ = Nils
|        stream_map2 _ _ Nils = Nils
|        stream_map2 f (Cons(x, t1)) (Cons(y, t2)) =
         Cons(f(x, y), stream_map2 f t1 t2)
</pre>
<p> ストリーム s1 と s2 から要素 x, y を取り出し、f(x, y) の評価結果を新しいストリームに格納します。stream_map2 の型は次のようになります。
</p>

<pre class="item">
val stream_map2 = fn : ('a * 'b -&gt; 'c) -&gt; 'a stream -&gt; 'b stream -&gt; 'c stream! susp
val stream_map2_ = fn : ('a * 'b -&gt; 'c) -&gt; 'a stream -&gt; 'b stream -&gt; 'c stream!
</pre>
<p> stream_map2 を使うと、ストリームに対していろいろな処理を定義することができます。次の例を見てください。
</p>
<pre>
- fun lazy add_stream(s1, s2) = stream_map2 (op +) s1 s2;
val add_stream = fn : int stream * int stream -&gt; int stream! susp
val add_stream_ = fn : int stream * int stream -&gt; int stream!
- val s1 = intgen(1, 4);
val s1 = $$ : int stream! susp
- val s2 = intgen(11, 14);
val s2 = $$ : int stream! susp
- val s5 = add_stream(s1, s2);
val s5 = $$ : int stream! susp
- stream_take(s5, 4);
val it = [12,14,16,18] : int list
</pre>
<p> add_stream は s1 と s2 の要素を加算したストリームを返します。この add_stream を使うと、整数を生成するストリームは次のように定義することができます。
</p>
<pre>
- val rec lazy ints = Cons(1, add_stream(ones, ints));
val ints = $$ : int stream! susp
- stream_take(ints, 10);
val it = [1,2,3,4,5,6,7,8,9,10] : int list
</pre>
<p> ストリーム ints は、現在の ints に 1 を足し算することで整数を生成しています。これで整数が生成できるとは不思議ですね。ints の動作を図に示すと、次のようになります。
</p>
<pre class="fig">
val rec lazy ones = Cons(1, ones)
                  = Cons(1, lazy_obj1)

val rec lazy ints = Cons(1, add_stream(ones. ints))
                  = Cons(1, lazy_obj2)

lazy_obj2 =&gt; Cons(1, lazy_obj1), Cons(1, lazy_obj2)
          =&gt; Cons(1+1, add_stream(lazy_obj1, lazy_obj2))
          =&gt; Cons(2, lazy_obj3)

lazy_obj3 =&gt; Cons(1, lazy_obj1), Cons(2, lazy_obj3)
          =&gt; Cons(3, add_stream(lazy_obj1, lazy_obj3))
          =&gt; Cons(3, lazy_obj4)

        図 : ストリーム ints の動作
</pre>
<p> ones を Cons(1, lazy_obj1) と表し、ints を Cons(1, lazy_obj2) と表します。lazy_obj は遅延オブジェクトを表します。ints で次の要素を生成するとき、lazy_obj2 が評価されます。すると、add_stream (stream_map2) に ones と ints が適用され、ストリームの要素 2 と遅延オブジェクト lazy_obj3 が生成されます。このとき、lazy_obj3 の内容は add_stream(lazy_obj1, lazy_obj2) になります。
</p>
<p> 次の要素を生成するときは、lazy_obj3 を評価します。lazy_obj1 は Cons(1, lazy_obj1) に、lazy_obj2 は Cons(2, lazy_obj3) に評価されるので、ストリームの要素は 1 + 2 = 3 になり、遅延オブジェクト lazy_obj4 の内容は add_stream(lazy_obj1, lazy_obj3) になります。そして、この遅延オブジェクトを評価することで次の要素を求めることができます。
</p>
<p> このように、遅延オブジェクトの中に現時点の整数を保持しておき、そこに 1 を足し算することで整数列を生成しているわけです。ここで、遅延オブジェクトは評価結果をキャッシュしているので、整数 n の次の値を簡単に計算できることに注意してください。もしも、遅延オブジェクトを単純なクロージャで実装した場合、整数 n を求めるため再計算が行われるので、効率はとても悪くなります。
</p>

<p> 同様の方法でフィボナッチ数列を生成するストリームを定義することができます。
</p>
<pre class="list">
リスト : フィボナッチ数列の生成

(* ストリームの次の要素を求める *)
fun lazy stream_tail(Nils) = raise Empty_stream
|        stream_tail(Cons(_, tail)) = tail

(* フィボナッチ数列 *)
val rec lazy fibs = Cons(1, Cons(1, add_stream(stream_tail fibs, fibs)))
</pre>
<pre class="item">
val stream_tail = fn : 'a stream! susp -&gt; 'a stream! susp
val stream_tail_ = fn : 'a stream! susp -&gt; 'a stream!
val fibs = $$ : int stream! susp
</pre>
<p> fibs が現在のフィボナッチ数列を表していて、stream_tail fibs で次の要素を求めます。そして、それらを足し算することで、その次の要素を求めています。この場合、ストリームの初期値として 2 つの要素が必要になることに注意してください。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
- stream_take(fibs, 10);
val it = [1,1,2,3,5,8,13,21,34,55] : int list
</pre>
<p> このように、2 つのストリームを使ってフィボナッチ数列を生成することができます。
</p>

<h4>●組 (pair) を生成するストリーム</h4>
<p> それでは簡単な例題として、2 つのストリームからその要素の組み合わせを生成するストリームを作りましょう。要素が n 個のストリームの場合、組み合わせは n * n 個あります。次の図を見てください。
</p>
<pre class="fig">
(a0, b0) (a0, b1) (a0, b2) ... (a0, bn)
(a1, b0) (a1, b1) (a1, b2) ... (a1, bn)
(a2, b0) (a2, b1) (a2, b2) ... (a2, bn)

                           ...

(an, b0) (an, b1) (an, b2) ... (an, bn)

        図 : n * n 個の組
</pre>
<p> この組み合わせを生成するストリームは簡単にプログラムできるように思います。次のリストを見てください。
</p>
<pre class="list">
リスト : 組を生成するストリーム

fun lazy pair_stream(Nils, _) = Nils
|        pair_stream(Cons(x, t1), s2) =
         stream_append(stream_map (fn(z) =&gt; (x, z)) s2, pair_stream(t1, s2))
</pre>
<p> 関数 pair_stream はストリーム s1 と s2 の要素の組を出力します。最初に、s1 の要素 x を取り出して、stream_map で x と s2 の要素の組を生成します。それを stream_append で出力してから、pair_stream を再帰呼び出しして s1 の次の要素と s2 の組を求めます。pair_stream には lazy の指定があるので、stream_append の第 2 引数で pair_stream を呼び出すとき、遅延評価が行われるため正常に動作します。lazy の指定を外すと遅延ストリームとして正常に動作しません。ご注意ください。
</p>

<p> pair_stream の型は次のようになります。
</p>
<pre class="item">
val pair_stream = fn : 'a stream! susp * 'b stream -&gt; ('a * 'b) stream! susp
val pair_stream_ = fn : 'a stream! susp * 'b stream -&gt; ('a * 'b) stream!
</pre>
<p> それでは実際に実行してみましょう。
</p>
<pre>
- val s1 = intgen(1, 4);
val s1 = $$ : int stream! susp
- val s2 = intgen(11, 14);
val s2 = $$ : int stream! susp
- val s3 = pair_stream(s1, s2);
val s3 = $$ : (int * int) stream! susp
- stream_take(s3, 16);
val it =
  [(1,11),(1,12),(1,13),(1,14),(2,11),(2,12),(2,13),(2,14),(3,11),(3,12),
   (3,13),(3,14),...] : (int * int) list
</pre>
<p> 正常に動作していますね。
</p>

<h4>●無限ストリームで組 (pair) を生成する場合</h4>
<p> ところで、pair_stream は無限ストリームに対応していません。実際、引数 s2 に無限ストリームを渡した場合、引数 s1 の最初の要素を a0 とすると (a0, s2 の要素) という組しか生成されません。そこで、図 3 に示すように、対角線上に組を生成していくことにします。
</p>
<pre class="fig">
   | a0  a1  a2  a3  a4  a5
---+-----------------------------
b0 | 1   2   4   7   11  16  ...
   |
b1 | 3   5   8   12  17  ...
   |
b2 | 6   9   13  18  ...
   |
b3 | 10  14  19  ...
   |
b4 | 15  20  ...
   |
b5 | 21 ...
   |
   | ...
   |

図 3 : 無限ストリームによる組の生成
</pre>
<p> ちなみに、このように順番を決めると、要素 (ai, bj) [ただし i &gt;= 0, j &gt;= 0] の番号 n は次の式で求めることができます。
</p>
<pre class="item">
n = (i + j + 1) * (i + j) / 2 + j + 1
</pre>
<p> それではプログラムを作りましょう。a0, a1, a2, ... を生成するストリームを s1 とし、b0, b1, b2, ... を生成するストリームを s2 とします。プログラムのポイントは、s1 の要素 ai と s2 の組を生成するストリームを順番に生成してリストに格納するところです。そして、そのリストに格納されたストリームの先頭要素を取り出していくと、対角線上に並んだ組を順番に生成することができます。次の図を見てください。
</p>
<pre class="fig">
x0 = (a0, b0), (a0, b1), (a0, b2), ...
x1 = (a1, b0), (a1, b1), (a1, b2), ...
x2 = (a2, b0), (a2, b1), (a2, b2), ...

[x0(0)] =&gt; 先頭要素を取り出す   =&gt; [(a0, b0)]
        =&gt; 次の要素を求める     =&gt; [x0(1)]
        =&gt; ストリームを追加する =&gt; [x1(0), x0(1)]

[x1(0); x0(1)] =&gt; 先頭要素を取り出す   =&gt; [(a1, b0), (a0, b1)]
               =&gt; 次の要素を求める     =&gt; [x1(1), x0(2)]
               =&gt; ストリームを追加する =&gt; [x2(0), x1(1), x0(2)]

        図 : 対角線上に組を生成する動作
</pre>

<p> 最初は a0 と s2 の組を生成するストリーム x0 をリストに格納します。次に、リストのストリームから先頭要素を取り出します。この場合は [(a0, b0)] になります。そして、ストリームの次の要素を求めます。x0(0) は x0(1) になります。
</p>
<p> 次に、a1 と s2 の組を生成するストリーム x1 をリストに格納します。このリストに対して、ストリームから先頭要素を取り出すと、[(a1, b0), (a0, b1)] になります。あとは同様に次の要素を求めて、新しいストリーム x2 を追加します。このリストから先頭要素を取り出すと、[(a2, b0), (a1, b1), (a0, b2)] となります。あとは、これを繰り返していくことで、対角線上の組を順番に生成することができます。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 無限ストリームによる組の生成

(* ストリームの先頭要素を取り出す *)
fun stream_head(Nils) = raise Empty_stream
|   stream_head(Cons(x, _)) = x

(* リストをストリームに変換 *)
fun lazy stream_of_list([]) = Nils
|        stream_of_list(x::xs) = Cons(x, stream_of_list(xs))

(* s1 と s2 の組を生成する *)
fun lazy pair_stream1(s1, s2) =
    let
      fun lazy make_pairs(s1) = stream_map (fn(x) =&gt; ((stream_head s1), x)) s2
      fun lazy pairs(s1, ls) =
          stream_append(stream_of_list(map stream_head ls),
                        pairs(stream_tail s1,
                              make_pairs(s1) :: (map stream_tail ls)))
    in
      pairs(stream_tail s1, [make_pairs s1])
    end
</pre>
<pre class="item">
val stream_head = fn : 'a stream! susp -&gt; 'a
val stream_of_list = fn : 'a list -&gt; 'a stream! susp
val stream_of_list_ = fn : 'a list -&gt; 'a stream!
val pair_stream1 = fn : 'a stream! susp * 'b stream -&gt; ('a * 'b) stream! susp
val pair_stream1_ = fn : 'a stream! susp * 'b stream -&gt; ('a * 'b) stream!
</pre>

<p> 関数 stream_head はストリームの先頭要素を返します。関数 stream_of_list は引数のリストをストリームに変換します。関数 pair_stream1 はストリーム s1 と s2 の要素の組を生成するストリームを返します。実際の処理は局所関数 pairs で行います。
</p>
<p> 局所関数 make_pairs は s1 の先頭要素と s2 の組を生成するストリームを返します。この処理は stream_map を使うと簡単ですね。stream_head で s1 の先頭要素を取り出して s2 の要素 x との組を生成します。
</p>
<p> pairs の引数 s1 がストリームで、ls がストリームを格納するリストです。まず、ls に格納されたストリームから先頭要素を取り出します。これは map を使うと簡単です。返り値はリストなので、これを stream_of_list でストリームに変換します。
</p>
<p> 次に、pairs を再帰呼び出しします。pairs を再帰呼び出しするとき、stream_tail で s1 の次の要素を求め、map stream_tail で ls に格納されたストリームの次の要素を求めます。そのリストに新しいストリームを make_pairs で生成して追加します。これで次の対角線上に並んだ組を生成することができます。
</p>

<p> それでは実行例を示しましょう。
</p>
<pre>
- val rec lazy ones = Cons(1, ones);
val ones = $$ : int stream! susp
- val rec lazy ints = Cons(1, add_stream(ones, ints));
val ints = $$ : int stream! susp
- stream_take(ints, 10);
val it = [1,2,3,4,5,6,7,8,9,10] : int list
- val s = pair_stream1(ints, ints);
val s = $$ : (int * int) stream! susp
- stream_take(s, 21);
val it =
  [(1,1),(2,1),(1,2),(3,1),(2,2),(1,3),(4,1),(3,2),(2,3),(1,4),(5,1),(4,2), ...] : (int * int) list
</pre>
<p> 正常に動作していますね。
</p>

<section class="contents">
<h4 id="update1">●別解 (2012/12/16)</h4>
<p> 無限ストリームによる組の生成ですが、実はもっと簡単な方法があります。図を見ればおわかりのように、対角線の要素数を n とすると、組は (an-1, b0), (an-2, b1), ..., (a1, bn-2), (a0, bn-1) となっています。これは、s1 から n 個の要素を取り出したリストと、s2 から n 個の要素を取り出して反転したリストを、zip で要素をタプルにまとめた形になっています。これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 無限ストリームによる組の生成 (2)

(* リストの要素をタプルにまとめる *)
fun zip(x::xs, y::ys) = (x, y) :: zip(xs, ys)
|   zip(_, _) = []

(* 組の生成 *)
fun lazy pair_stream2(s1, s2) =
    let
      fun lazy iter n =
          stream_append(stream_of_list(zip(stream_take(s1, n),
                                           rev (stream_take(s2, n)))),
                        iter (n + 1))
    in
      iter(1)
    end
</pre>
<p> 実際の処理は局所関数 iter で行っています。引数 n が対角線上の要素数を表します。stream_take で s1 と s2 から要素を取り出し、s2 から取り出したリストを rev で反転してから関数 zip で要素をタプルに格納します。結果はリストになるので、stream_of_list で遅延ストリームに変換します。そして、そのストリームと再帰呼び出しした iter の返り値を stream_append で連結します。これで組を対角線上の順番で生成することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
- val s = pair_stream2(ints, ints);
val s = $$ : (int * int) stream! susp
- stream_take(s, 10);
val it = [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1)]
  : (int * int) list
- stream_ref(s, 10);
val it = (4,1) : int * int
- stream_ref(s, 20);
val it = (5,2) : int * int
</pre>
</section>
<h4>●素数の生成</h4>
<p> 次はストリームを使って素数を求めるプログラムを作ってみましょう。考え方は簡単です。最初に、2 から始まる整数列を生成するストリームを用意します。2 は素数なので、素数ストリームの要素になります。次に、この整数列から 2 で割り切れる整数を取り除き除きます。これは stream_filter を使うと簡単です。
</p>

<p> 2 で割り切れる整数が取り除かれたので、次の要素は 3 になります。今度は 3 で割り切れる整数を取り除けばいいのです。これも stream_filter を使えば簡単です。このとき、入力用のストリームは 2 で割り切れる整数が取り除かれています。したがって、このストリームに対して 3 で割り切れる整数を取り除くように stream_filter を設定すればいいわけです。
</p>

<p> このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩」といいます。ようするに、2 から始まる整数ストリームに対して、見つけた素数 2, 3, 5, 7, 11, ... を順番に stream_fiter で設定して素数でない整数をふるい落としていくわけです。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 素数の生成

fun lazy sieve(Nils) = raise Empty_stream
|        sieve(Cons(x, tail)) =
         Cons(x, sieve(stream_filter (fn(a) =&gt; a mod x &lt;&gt; 0) tail))
</pre>
<pre class="item">
val sieve = fn : int stream! susp -&gt; int stream! susp
val sieve_ = fn : int stream! susp -&gt; int stream!
</pre>
<p> sieve には 2 から始まる整数列を生成するストリームを渡します。Cons の遅延オブジェクトを評価すると、stream_filter により整数列から 2 で割り切れる整数を取り除いたストリームが返されます。次の要素 3 を取り出すとき、このストリームに対して 3 で割り切れる整数を取り除くことになるので、2 と 3 で割り切れる整数が取り除かれることになります。次の要素は 5 になりますが、そのストリームからさらに 5 で割り切れる整数が stream_filter で取り除かれることになります。
</p>

<p> このように stream_filter が設定されていくことで、素数でない整数をふるい落としていくことができるわけです。それでは実行してみましょう。
</p>
<pre>
- val s = sieve(intgen(2, 1000));
val s = $$ : int stream! susp
- stream_take(s, 25);
val it = [2,3,5,7,11,13,17,19,23,29,31,37,...] : int list

- val rec lazy ones = Cons(1, ones);
val ones = $$ : int stream! susp
- val rec lazy ints = Cons(1, add_stream(ones, ints));
val ints = $$ : int stream! susp
- stream_take(sieve(stream_tail(ints)), 10);
val it = [2,3,5,7,11,13,17,19,23,29] : int list
</pre>
<p> 正常に動作していますね。
</p>
<section class="contents">
<h4 id="update2">●別解 (2012/12/16)</h4>
<p> 関数 sieve は簡単にプログラムできますが、生成する素数の個数が多くなると、その実行速度はかなり遅くなります。実をいうと、sieve なみに簡単で sieve よりも高速な方法があります。
</p>

<p> 整数 n が素数か確かめる簡単な方法は、√n 以下の素数で割り切れるか試してみることです。割り切れる素数 m があれば、n は素数ではありません。そうでなければ、n は素数であることがわかります。
</p>
<p> これをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 素数列の生成

(* 述語 pred が真となる要素が先頭から続く限り取り出す *)
fun take_while(pred, xs) =
    let
      val x = stream_head xs
    in
      if pred x then x :: take_while(pred, stream_tail xs) else []
    end

(* 素数のチェック *)
fun checkPrime n xs =
    List.all (fn(x) =&gt; n mod x &lt;&gt; 0) (take_while(fn(x) =&gt; x * x &lt;= n, xs))

(* 素数の生成 *)
fun lazy primes_from n xs =
    if checkPrime n xs
    then Cons(n, primes_from (n + 2) xs)
    else primes_from (n + 2) xs

(* 素数列 *)
val rec lazy primes = Cons(2, Cons(3, Cons(5, primes_from 7 primes)))
</pre>
<p> 関数 take_while は、述語 pred が真を返す要素が続く限り、遅延ストリーム xs から要素を取り出してリストに格納して返します。変数 primes は無限の素数列を表します。実際に素数を生成する処理は関数 primes_from で行います。primes_from は簡単で、関数 checkPrime を呼び出して n が素数かチェックします。primes_from を呼び出すときは素数列 primes を渡すことに注意してください。そうであれば、Cons で n を遅延ストリームに追加します。そうでなければ primes_from を再帰呼び出しするだけです。偶数は素数ではないので、引数 n には奇数を与えていることに注意してください。
</p>
<p> checkPrime も簡単です。take_while で xs (素数列 primes) から √n 以下の素数列を取り出します。√n 以下の素数は生成済みなので、xs から take_while で取り出すことが可能です。ここでは√n のかわりに条件を x * x &lt;= n としています。あとは、関数 List.all を使って、取り出した素数で n が割り切れないことを確認するだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
- stream_take(primes, 25);
val it = [2,3,5,7,11,13,17,19,23,29,31,37,...] : int list
- stream_ref(primes, 25);
val it = 97 : int
- stream_ref(primes, 100);
val it = 541 : int
- stream_ref(primes, 500);
val it = 3571 : int
</pre>
<p> 正常に動作していますね。
</p>
<p> 実行時間ですが、stream_ref で 5000 番目の素数を求めてみました。
</p>
<pre class="item">
sieve  : 1.94 秒
primes : 0.08 秒

実行環境 : Windows 7, Core i7-2670QM 2.20GHz, SML/NJ v110.74
</pre>
<p> sieve よりも primes のほうが高速になりました。興味のある方はいろいろ試してみてください。
</p>
<h4>●参考 URL</h4>
<p> 今回のプログラムは <a href="http://practical-scheme.net/gauche/man/gauche-refj_57.html">Gauche ユーザリファレンス: 6.19 遅延評価</a> を参考にさせていただきました。Shiro Kawai さんに感謝いたします。
</p>
</section>
<h4>●順列の生成</h4>
<p> 次は遅延ストリームを使って順列を生成するプログラムを作ってみましょう。遅延ストリームを使う場合、再帰呼び出しの一番深いところで順列が完成するようにプログラムするとうまくいきません。要素が n 個の順列を生成する場合、n - 1 個の順列を生成するストリームを生成し、そこに要素を一つ加えて n 個の順列を生成すると考えます。
</p>

<p> まずは簡単な例として、遅延ストリームではなく、リストを使ってプログラムを作ってみます。次のリストを見てください。
</p>

<pre class="list">
リスト : 順列の生成

(* 要素を取り除く *)
fun remove(x, ls) = List.filter (fn y =&gt; x &lt;&gt; y) ls

(* リストの平坦化 *)
fun flatten([]) = []
|   flatten(x::xs) = x @ flatten(xs)

(* map f ls の結果を平坦化する *)
fun flatmap f ls = flatten (map f ls)

(* 順列の生成 *)
fun perm(0, _) = [[]]
|   perm(n, ls) =
    flatmap (fn x =&gt; map (fn y =&gt; x :: y) (perm(n - 1, remove(x, ls)))) ls
</pre>

<p> 関数 perm は引数のリスト ls から n 個を選ぶ順列を生成し、それをリストに格納して返します。n = 0 が再帰の停止条件で、空リストを格納したリストを返します。このリストに対して要素を追加します。この処理は map を二重に使うと簡単に実現できそうです。次の例を見てください。
</p>
<pre>
- map (fn x =&gt; 5::x) [[1],[2],[3],[4],[5]];
val it = [[5,1],[5,2],[5,3],[5,4],[5,5]] : int list list
- map (fn y =&gt; map (fn x =&gt; y::x) [[1],[2],[3],[4],[5]]) [5, 6];
val it = [[[5,1],[5,2],[5,3],[5,4],[5,5]],[[6,1],[6,2],[6,3],[6,4],[6,5]]] : int list list list
</pre>
<p> リストの各要素に 5 を追加したい場合、map を使うと簡単ですね。次は、リスト [5, 6] の各要素を追加したリストを求めることを考えます。map を二重にして、[5, 6] の要素を匿名関数の引数 y に渡します。次の map で y をリストに追加します。すると、返り値のリストの型は int list list list になります。map を二重にしているので、リストの階層が 1 段深くなるわけです。
</p>
<p> そこで、リストのリストを平坦化する関数 flatten を使います。プログラムは簡単です。リストの先頭要素 x を取り出して、x と次の要素を @ で結合すればいいわけです。たとえば、flatten [[1], [2], [3]] は [1] と [2] と [3] を @ で結合するので、[1, 2, 3] になります。flatten のデータ型は次のようになります。
</p>

<pre class="item">
val flatten = fn : 'a list list -&gt; 'a list
</pre>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
- flatten(map (fn y =&gt; map (fn x =&gt; y::x) [[1],[2],[3],[4],[5]]) [5, 6]);
val it = [[5,1],[5,2],[5,3],[5,4],[5,5],[6,1],[6,2],[6,3],[6,4],[6,5]] : int list list
</pre>
<p> 実際のプログラムでは flatten と map を組み合わせた関数 flatmap を定義しておくと便利です。
</p>

<p> 関数 perm の説明に戻ります。匿名関数の中で perm を再帰呼び出しをして、n - 1 個を選ぶ順列を生成します。そして、その返り値にリスト ls の要素 x を追加すれば、n 個の順列を生成することができます。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
- perm(3, [1,2,3]);
val it = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] : int list list
</pre>
<h4>●遅延ストリーム版</h4>
<p> それでは、遅延ストリームを使ったプログラムを作ります。
</p>
<pre class="list">
リスト : 遅延ストリームによる順列の生成

(* ストリームの平坦化 *)
fun lazy stream_flatten(Nils) = Nils
|        stream_flatten(Cons(head, tail)) =
         stream_append(head, stream_flatten(tail))

(* stream_map の結果を平坦化する *)
fun lazy stream_flatmap proc s = stream_flatten(stream_map proc s)

(* 順列の生成 *)
fun lazy make_perm(0, _) = Cons([], Nils)
|        make_perm(n, s) =
         stream_flatmap (fn x =&gt; stream_map (fn y =&gt; x::y) (make_perm(n - 1, stream_filter (fn z =&gt; z &lt;&gt; x) s))) s
</pre>
<pre class="item">
val stream_flatten = fn : 'a stream! susp stream! susp -&gt; 'a stream! susp
val stream_flatten_ = fn : 'a stream! susp stream! susp -&gt; 'a stream!
val stream_flatmap = fn : ('a -&gt; 'b stream! susp) -&gt; 'a stream -&gt; 'b stream! susp
val stream_flatmap_ = fn : ('a -&gt; 'b stream! susp) -&gt; 'a stream -&gt; 'b stream!
val make_perm = fn : int * ''a stream -&gt; ''a list stream! susp
val make_perm_ = fn : int * ''a stream -&gt; ''a list stream!
</pre>
<p> flatten のかわりに stream_flatten を、flatmap のかわりに stream_flatmap を用意します。stream_map を二重に使うので、ストリームの中にストリームが格納されます。これを平坦化するために stream_flatten を使います。stream_flatten はストリームの先頭要素 head を取り出し、stream_apeend で head のストリームと残りのストリームを結合します。
</p>
<p> 関数 make_perm はストリーム s の中から要素を n 個選ぶ順列を生成します。n = 0 の場合は空リストを格納したストリームを返します。あとは、stream_flatmap の匿名関数の中で、make_perm を再帰呼び出しして n - 1 個を選ぶ順列を生成します。ストリーム s から要素 x を取り除くため、stream_filter を使っています。これで順列を生成するストリームを作ることができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
- val s = make_perm(3, intgen(1, 3));
val s = $$ : int list stream! susp
- stream_take(s, 6);
val it = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] : int list list
</pre>
<p> 6 通りの順列をすべて求めることができました。
</p>
<h4>●８クイーンの解法</h4>
<p> 同様に、遅延ストリームを使って 8 クイーンを解くことができます。
</p>
<pre class="list">
リスト 12 : 8 クイーンの解法 (遅延ストリーム版)

fun attack(x, xs) =
    let
      fun attack_sub(x, n, []) = true
      |   attack_sub(x, n, y::ys) =
          if x = y + n orelse x = y - n then false
          else attack_sub(x, n + 1, ys)
    in
      attack_sub(x, 1, xs)
    end

fun lazy queen(Nils) = Cons([], Nils)
|        queen(s) =
         stream_filter
           (fn [] =&gt; true | (x::xs) =&gt; attack(x, xs))
           (stream_flatmap (fn x =&gt; stream_map (fn y =&gt; x::y) (queen(stream_filter (fn z =&gt; z &lt;&gt; x) s))) s)
</pre>
<pre class="item">
val attack = fn : int * int list -&gt; bool
val queen = fn : int stream! susp -&gt; int list stream! susp
val queen_ = fn : int stream! susp -&gt; int list stream!
</pre>
<p> 関数 queen は make_perm とほぼ同じですが、stream_filter を使って追加したクイーンが他のクイーンと衝突しているものを取り除いています。衝突をチェックする関数 attack は <a href="smlnj06.html#yori06">ちょっと寄り道「8 クイーン」</a> で作成したものと同じです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
- stream_take(queen(intgen(1, 8)), 10);
val it =
  [[1,5,8,6,3,7,2,4],[1,6,8,3,7,4,2,5],[1,7,4,6,8,2,5,3],[1,7,5,8,2,4,6,3],
   [2,4,6,8,3,1,7,5],[2,5,7,1,3,8,6,4],[2,5,7,4,1,8,6,3],[2,6,1,7,4,8,3,5],
   [2,6,8,3,1,4,7,5],[2,7,3,6,8,5,1,4]] : int list list
</pre>
<p> 解の総数は全部で 92 通りあります。遅延ストリームを使うと、必要な分だけの計算しか行われないので効率的です。
</p>
<h4 id="cite">●参考文献</h4>
<ul>
<li><a href="http://www.cs.cmu.edu/~rwh/">Robert Harper</a>, <a href="http://www.cs.cmu.edu/~rwh/introsml/">"Programming in Standard ML"</a>, <a href="http://www.cs.cmu.edu/~rwh/introsml/core/lazydata.htm">Lazy Data Structures</a>
<LI><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs (SICP)"</a> <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">3.5  Streams</a>
</ul>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
(*
 * lazy.sml : lazy を使った遅延ストリーム
 *
 *            Copyright (C) 2012 Makoto Hiroi
 *
 *)

(*
 * lazy keyword を有効にする
 * コマンドラインから入力してもよい
 * sml -Cparser.lazy-keyword=true
 *)
Control.lazysml := true;
open Lazy

(* 遅延オブジェクトを評価する *)
fun force ($ x) = x

(* 例外 *)
exception Empty_stream

(* 遅延ストリームの定義 *)
datatype lazy 'a stream = Nils | Cons of 'a * 'a stream

(* 整数列の生成 *)
fun lazy intgen(low, high) =
    if low &gt; high then Nils else Cons (low, intgen(low + 1, high))

(* フィボナッチ数列の生成 *)
fun lazy fibgen(a, b) = Cons(a, fibgen(b, a + b))

(* n 番目の要素を取り出す *)
fun stream_ref(Nils, _) = raise Empty_stream
|   stream_ref(Cons(x, _), 1) = x
|   stream_ref(Cons(_, tail), n) = stream_ref(tail, n - 1)

(* n 個の要素を取り出す *)
fun stream_take(Nils, _) = raise Empty_stream
|   stream_take(Cons(x, _), 1) = [x]
|   stream_take(Cons(x, tail), n) = x :: stream_take(tail, n - 1)

(* 高階関数 *)
(* マッピング *)
fun lazy stream_map _ Nils = Nils
|        stream_map proc (Cons(x, tail)) =
         Cons (proc x, stream_map proc tail)

(* フィルター *)
fun lazy stream_filter _ Nils = Nils
|        stream_filter pred (Cons(x, tail)) =
         if pred x then Cons(x, stream_filter pred tail)
         else stream_filter pred tail

(* 畳み込み *)
fun stream_foldl _ a Nils = a
|   stream_foldl proc a (Cons(x, tail)) =
    stream_foldl proc (proc(x, a)) tail

fun stream_foldr _ a Nils = a
|   stream_foldr proc a (Cons(x, tail)) =
    proc(x, stream_foldr proc a tail)

(* ストリームの結合 *)
fun lazy stream_append(Nils, s2) = s2
|        stream_append(Cons(x, tail), s2) = Cons(x, stream_append(tail, s2))

(* ストリームの要素を交互に出力 *)
fun lazy interleave(Nils, s2) = s2
|        interleave(Cons(x, tail), s2) = Cons(x, interleave(s2, tail))

(* ２ストリームのマッピング *)
fun lazy stream_map2 _ Nils _ = Nils
|        stream_map2 _ _ Nils = Nils
|        stream_map2 f (Cons(x, t1)) (Cons(y, t2)) =
         Cons(f(x, y), stream_map2 f t1 t2)

(* ストリームの加算 *)
fun lazy add_stream(s1, s2) = stream_map2 (op +) s1 s2

(* ストリームの次の要素を求める *)
fun lazy stream_tail(Nils) = raise Empty_stream
|        stream_tail(Cons(_, tail)) = tail

(* フィボナッチ数列 *)
val rec lazy fibs = Cons(1, Cons(1, add_stream(stream_tail fibs, fibs)))

(* 組を生成するストリーム *)
fun lazy pair_stream(Nils, _) = Nils
|        pair_stream(Cons(x, t1), s2) =
         stream_append(stream_map (fn(z) =&gt; (x, z)) s2, pair_stream(t1, s2))

(* ストリームの先頭要素を取り出す *)
fun stream_head(Nils) = raise Empty_stream
|   stream_head(Cons(x, _)) = x

(* リストをストリームに変換 *)
fun lazy stream_of_list([]) = Nils
|        stream_of_list(x::xs) = Cons(x, stream_of_list(xs))

(* s1 と s2 の組を生成する *)
fun lazy pair_stream1(s1, s2) =
    let
      fun lazy make_pairs(s1) = stream_map (fn(x) =&gt; ((stream_head s1), x)) s2
      fun lazy pairs(s1, ls) =
          stream_append(stream_of_list(map stream_head ls),
                        pairs(stream_tail s1,
                              make_pairs(s1) :: (map stream_tail ls)))
    in
      pairs(stream_tail s1, [make_pairs s1])
    end

(* 素数の生成 *)
fun lazy sieve(Nils) = raise Empty_stream
|        sieve(Cons(x, tail)) =
         Cons(x, sieve(stream_filter (fn(a) =&gt; a mod x &lt;&gt; 0) tail))

(* 順列の生成 *)
fun remove(x, ls) = List.filter (fn y =&gt; x &lt;&gt; y) ls

(* リストの平坦化 *)
fun flatten([]) = []
|   flatten(x::xs) = x @ flatten(xs)

(* map f ls の結果を平坦化する *)
fun flatmap f ls = flatten (map f ls)

(* 順列の生成 *)
fun perm(0, _) = [[]]
|   perm(n, ls) =
    flatmap (fn x =&gt; map (fn y =&gt; x :: y) (perm(n - 1, remove(x, ls)))) ls

(* 遅延ストリーム版 *)
fun lazy stream_flatten(Nils) = Nils
|        stream_flatten(Cons(head, tail)) =
         stream_append(head, stream_flatten(tail))

(* stream_map の結果を平坦化する *)
fun lazy stream_flatmap proc s = stream_flatten(stream_map proc s)

(* 順列の生成 *)
fun lazy make_perm(0, _) = Cons([], Nils)
|        make_perm(n, s) =
         stream_flatmap (fn x =&gt; stream_map (fn y =&gt; x::y) (make_perm(n - 1, stream_filter (fn z =&gt; z &lt;&gt; x) s))) s

(* 8 クイーンの解法 *)
fun attack(x, xs) =
    let
      fun attack_sub(x, n, []) = true
      |   attack_sub(x, n, y::ys) =
          if x = y + n orelse x = y - n then false
          else attack_sub(x, n + 1, ys)
    in
      attack_sub(x, 1, xs)
    end

fun lazy queen(Nils) = Cons([], Nils)
|        queen(s) =
         stream_filter (fn [] =&gt; true | (x::xs) =&gt; attack(x, xs))
                       (stream_flatmap (fn x =&gt; stream_map (fn y =&gt; x::y) (queen(stream_filter (fn z =&gt; z &lt;&gt; x) s))) s)
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2012 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="smlnj16.html">PrevPage</a> | <a href="index.html">SML/NJ</a> | <a href="smlnj18.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>