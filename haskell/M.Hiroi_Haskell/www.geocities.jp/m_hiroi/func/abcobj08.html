<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj07.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj09.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap0801">インスタンスの初期化</h3>
<p> Gauche は make でクラスのインスタンスを生成します。スロットの初期値は make でセットすることができますが、このほかに総称関数 initialize を使ってインスタンスの初期化をカスタマイズすることができます。
</p>

<h4>●総称関数 initialize</h4>
<p> initialize は make から呼び出される総称関数です。インスタンスを生成するとき、initialize をオーバーライドすることで独自の初期化処理を行うことができます。
</p>
<pre class="item">
initialize instance initargs
</pre>
<p> initialize はインスタンスが生成されてから呼び出されます。このとき、スロットは未束縛であることに注意してください。スロットの初期値は :init-form や :init-value を使って設定することができますが、この処理は Gauche が提供する initialize の基本メソッドで行われます。したがって、単純に initialize をオーバーライドすると、スロットは未束縛のままになってしまいます。次の例を見てください。
</p>

<pre class="list">
リスト 1 : initialize の例 (1)

; クラス定義
(define-class &lt;foo&gt; ()
  ((a :accessor foo-a :init-value 1 :init-keyword :a)))

(define-method initialize ((x &lt;foo&gt;) initargs)
  (if (slot-bound? x 'a)
      (format #t "slot a is ~S~%" (foo-a x))
    (print "slot a is unbound")))
</pre>

<p> この例はクラス &lt;foo&gt; の initialize をオーバーライドしています。slot-bound? はスロットが束縛されているかチェックする関数です。
</p>
<pre class="item">
slot-bound? instance slot-name
</pre>
<p> slot-name はスロット名を表すシンボルです。instance のスロット slot-name が束縛されていれば #t を、未束縛であれば #f を返します。
</p>
<p> それから、任意のオブジェクトにスロットがあるかチェックする関数 slot-exists? もあります。
</p>
<pre class="item">
slot-exists? object slot-name
</pre>
<p> slot-exists? はオブジェクト object にスロット slot-name が存在すれば #t を、なければ #f を返します。
</p>
<p> それでは、クラス &lt;foo&gt; のインスタンスを生成してみましょう。
</p>
<pre>
gosh&gt; (define x (make &lt;foo&gt; :a 10))
slot a is unbound
x
gosh&gt; (slot-bound? x 'a)
#f
</pre>
<p> make からオーバライドした initialize が呼び出されますが、このときスロット a は未束縛の状態です。このあと、生成されたインスタンスのスロット a を slot-bound? でチェックすると #f が返ってきます。このように、initialize をオーバーライドすると、:init-value や :init-keyword で指定したスロットの初期化処理が行われないのです。
</p>

<p> この場合、next-method を呼び出してスーパークラスのメソッド initialize を呼び出すようにします。
</p>

<pre class="list">
リスト 2 : initialize の例 (2)

(define-method initialize ((x &lt;foo&gt;) initargs)
  (next-method)
  (if (slot-bound? x 'a)
      (format #t "slot a is ~S~%" (foo-a x))
    (print "slot a is unbound")))
</pre>

<p> 実行例は次のようになります。
</p>
<pre>
gosh&gt; (define x (make &lt;foo&gt; :a 10))
slot a is 10
x
gosh&gt; (slot-bound? x 'a)
#t
</pre>

<p> initialize を使ってインスタンスの初期化処理を行う場合は注意してください。
</p>
<h4>●ベクタによるキューの実装</h4>
<p> それでは簡単な例題として、ベクタを使って「キュー (queue) 」を実装してみましょう。ベクタの場合、先頭位置を示す front と末尾を示す rear を用意し、front と rear の間にあるデータをキューに格納されているデータとするのがポイントです。次の図を見てください。
</p>

<pre class="fig">
           0  1  2  3  4  5  6  7  8  9
rear = 0  ↓
QUEUE    [                              ]  : QUEUE は空
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : データの追加
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 10を取り出す
front= 1     ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 20,30を取り出す
front= 3           ↑

                    図 1 : キューの動作
</pre>

<p> まずキューは空の状態で、rear, front ともに 0 です。データの追加は、rear が示す位置にデータを書き込み、rear の値をインクリメントします。データ 10, 20, 30 を追加すると、図のようにデータが追加され rear は 3 になります。このとき front は 0 のままなので、先頭のデータは 10 ということになります。
</p>
<p> 次に、データを取り出す場合、front の示すデータを取り出してから front の値をインクリメントします。この場合、front が 0 なので 10 を取り出して front の値は 1 となり、次のデータ 20 が先頭になります。データを順番に 20, 30 と取り出していくと、3 つしかデータを書き込んでいないので当然キューは空になります。このとき front は 3 になり rear と同じ値になります。
</p>
<p> このように、front と rear の値が 0 の場合だけが空の状態ではなく、front と rear の値が等しくなる場合もキューは空になります。実際にプログラムを作る場合は、キューの要素数をカウントする変数を用意しておくと、キューの状態を簡単に判断することができるので便利です。
</p>
<p> rear, fornt ともに値は増加していく方向なので、いつかはベクタの範囲をオーバーします。このため、ベクタを先頭と末尾がつがっているリング状と考え、rear, front がベクタの範囲を超えたら 0 に戻すことにします。これを「循環配列」とか「リングバッファ」と呼びます。一般に、ベクタを使ってキューを実装する場合は、リングバッファとするのが普通です。
</p>
<h4>●プログラムの作成</h4>
<p> 最初に、キューを操作するためのメソッドを表 1 に示します。
</p>
<table border=1>
<caption>表 1 : キューのメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>enqueue! q x</td><td>キュー q にデータを追加する</td></tr>
  <tr><td>dequeue! q </td><td>キュー q からデータを取り出す</td></tr>
  <tr><td>queue-peek q </td><td>キュー q の先頭データを参照する</td></tr>
  <tr><td>queue-length q </td><td>キュー q に格納されている要素数を返す</td></tr>
  <tr><td>queue-clear! q </td><td>キュー q を空にする</td></tr>
  <tr><td>queue-empty? q </td><td>キュー q が空ならば #t を返す</td></tr>
  <tr><td>queue-full? q </td><td>キュー q が満杯ならば #t を返す</td></tr>
</tbody>
</table>

<p> 次に、キューを表すクラスを定義します。
</p>
<pre class="list">
リスト：クラス queue の定義

(define-class &lt;queue&gt; ()
  ((buff  :accessor queue-buff  :init-keyword :buff)
   (size  :accessor queue-size  :init-keyword :size)
   (nums  :accessor queue-nums  :init-keyword :nums  :init-value 0)
   (front :accessor queue-front :init-keyword :front :init-value 0)
   (rear  :accessor queue-rear  :init-keyword :rear  :init-value 0)))

; 初期化
(define-method initialize ((q &lt;queue&gt;) intargs)
  (next-method)
  (if (not (slot-bound? q 'size))
      (error "&lt;queue&gt; : slot size is unbound"))
  (set! (queue-buff q) (make-vector (queue-size q))))
</pre>
<p> スロット nums はキューに格納されたデータ数をカウントします。この変数を用意することで、キューの状態を簡単にチェックすることができます。スロット size はキューの大きさを表し、スロット buff にはベクタをセットします。ベクタは initialize で生成してスロット buff にセットします。これで大きさ size のベクタを用意することができます。
</p>

<p> 次はデータを挿入するメソッド enqueue! を作ります。次のリストを見てください。
</p>
<pre class="list">
リスト 3 : データの挿入

(define-method enqueue! ((q &lt;queue&gt;) value)
  (if (queue-full? q)
      (error "queue is full"))
  (vector-set! (queue-buff q) (queue-rear q) value)
  (inc! (queue-nums q))
  (inc! (queue-rear q))
  (if (= (queue-rear q) (queue-size q))
      (set! (queue-rear q) 0)))
</pre>

<p> まず、メソッド queue-full? を呼び出して、キューが満杯かチェックします。そうであればエラーを送出します。データ value は rear の位置に格納し、nums と rear の値を更新します。そして、rear の値がベクタの範囲を超えたならば 0 に戻します。rear の値を更新する処理は、次のようにプログラムしてもかまいません。
</p>
<pre class="list">
(set! (queue-rear q)
      (modulo (+ (queue-rear q) 1) (queue-size q)))
</pre>
<p> 剰余を求める関数 modulo を使うのがポイントです。
</p>

<p> 次は、キューの先頭データを参照するメソッド queue-peek と、キューからデータを取り出すメソッド dequeue! を作ります。
</p>

<pre class="list">
リスト 4 : データを取り出す

; 先頭データを参照
(define-method queue-peek ((q &lt;queue&gt;))
  (if (queue-empty? q)
      (error "queue is empty"))
  (vector-ref (queue-buff q) (queue-front q)))

; データの取り出し
(define-method dequeue! ((q &lt;queue&gt;))
  (begin0
    (queue-peek q)
    (dec! (queue-nums q))
    (inc! (queue-front q))
    (if (= (queue-front q) (queue-size q))
        (set! (queue-front q) 0))))
</pre>

<p> queue-peek はメソッド queue-empty? を呼び出してキューにデータがあるかチェックします。キューが空の場合はエラーを送出します。データがある場合、スロット front の位置にあるデータが先頭なので、vectore-ref で先頭データを取り出して返します。dequeue! は queue-peek で先頭の値を求め、その値を bigin0 で返します。あとはスロット nums を -1 して、front の値を +1 します。front の値がベクタの範囲を超えたら 0 に戻します。
</p>

<p> あとのメソッドは簡単なので説明は省略いたします。詳細は <a href="abcobj08.html#list1">プログラムリスト１</a> をお読みくださいませ。
</p>
<h4>●実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
gosh&gt; (define a (make &lt;queue&gt; :size 8))
a
gosh&gt; (dotimes (x 8) (enqueue! a x))
#t
gosh&gt; (enqueue! a 8)
*** ERROR: queue is full

gosh&gt; (queue-length a)
8
gosh&gt; (queue-full? a)
#t
gosh&gt; (queue-empty? a)
#f
gosh&gt; (dotimes (x 8) (format #t "~D " (dequeue! a)))
0 1 2 3 4 5 6 7 #t
gosh&gt; (queue-empty? a)
#t
gosh&gt; (queue-full? a)
#f
gosh&gt; (queue-length a)
0
</pre>
<p> 正常に動作していますね。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
;
; queue.scm : リングバッファによるキューの実装
;
;             Copyright (C) 2010 Makoto Hiroi
;

;;; キューの定義

(define-class &lt;queue&gt; ()
  ((buff  :accessor queue-buff  :init-keyword :buff)
   (size  :accessor queue-size  :init-keyword :size)
   (nums  :accessor queue-nums  :init-keyword :nums  :init-value 0)
   (front :accessor queue-front :init-keyword :front :init-value 0)
   (rear  :accessor queue-rear  :init-keyword :rear   :init-value 0)))

; 初期化
(define-method initialize ((q &lt;queue&gt;) intargs)
  (next-method)
  (if (not (slot-bound? q 'size))
      (error "&lt;queue&gt; : slot size is unbound"))
  (set! (queue-buff q) (make-vector (queue-size q))))

;;; メソッドの定義

; 空か？
(define-method queue-empty? ((q &lt;queue&gt;))
  (zero? (queue-nums q)))

; 満杯か？
(define-method queue-full? ((q &lt;queue&gt;))
  (= (queue-nums q) (queue-size q)))

; データの挿入
(define-method enqueue! ((q &lt;queue&gt;) value)
  (if (queue-full? q)
      (error "queue is full"))
  (vector-set! (queue-buff q) (queue-rear q) value)
  (inc! (queue-nums q))
  (inc! (queue-rear q))
  (if (= (queue-rear q) (queue-size q))
      (set! (queue-rear q) 0)))

; 先頭データを参照
(define-method queue-peek ((q &lt;queue&gt;))
  (if (queue-empty? q)
      (error "queue is empty"))
  (vector-ref (queue-buff q) (queue-front q)))

; データの取り出し
(define-method dequeue! ((q &lt;queue&gt;))
  (begin0
    (queue-peek q)
    (dec! (queue-nums q))
    (inc! (queue-front q))
    (if (= (queue-front q) (queue-size q))
        (set! (queue-front q) 0))))

; 要素数を求める
(define-method queue-length ((q &lt;queue&gt;))
  (queue-nums q))

; 空にする
(define-method queue-clear! ((q &lt;queue&gt;))
  (set! (queue-nums q) 0)
  (set! (queue-front q) 0)
  (set! (queue-rear q) 0))
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap0802">可変長ベクタ</h3>
<p> 今回はオブジェクト指向の簡単な例題として、ベクタを自動的に拡張する「可変長ベクタ (variable length vector) 」を作ってみましょう。Scheme のベクタは生成するときに大きさを指定しますが、その後で大きさを変更することはできません。可変長ベクタはデータを追加するとき、満杯の場合は自動的にベクタを拡張します。可変長ベクタ (配列) は Perl, Python, Ruby などでは標準でサポートされている機能です。
</p>
<h4>●可変長ベクタの仕様</h4>
<p> クラス名は &lt;vlvector&gt; とします。今回は簡単な例題ということで、ベクタの末尾にデータを追加するとき、ベクタが満杯ならば容量を 2 倍に増やすことにしましょう。ただし、ベクタの大きさを自動的に減らすことはしません。そのかわり、ベクタの大きさを変更するメソッドを用意することにします。
</p>

<p> 可変長ベクタクラス &lt;vlvector&gt; のメソッドを表 1 に示します。
</p>
<table border=1>
<caption>表 1 : 可変長ベクタクラスのメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>vlvector-ref v n</td><td>n 番目の要素を参照する</td></tr>
  <tr><td>vlvector-set! v n x </td><td>n 番目の要素を x に書き換える</td></tr>
  <tr><td>vlvector-push! v x</td><td>ベクタの末尾にデータ x を追加する</td></tr>
  <tr><td>vlvector-pop! v </td><td>ベクタの末尾からデータを取り出す</td></tr>
  <tr><td>vlvector-clear! v </td><td>ベクタを空にする</td></tr>
  <tr><td>vlvector-empty? v </td><td>ベクタが空ならば #t を返す</td></tr>
  <tr><td>vlvector-length v </td><td>ベクタの要素数を返す</td></tr>
  <tr><td>vlvector-size v </td><td>ベクタの大きさ (容量) を返す</td></tr>
  <tr><td>vlvector-resize v size</td><td>ベクタの大きさを size に変更する</td></tr>
  <tr><td>fill-pointer v </td><td>フィルポインタの値を返す</td></tr>
  <tr><td>fill-pointer-set! v n</td><td>フィルポインタの値を n に書き換える</td></tr>
</tbody>
</table>
<p> 引数 v はクラス &lt;vlvector&gt; のインスタンスで、引数 n と size は整数値です。プログラムのポイントはフィルポインタ (fill-pointer) の使い方です。ベクタの中で 0 番目から fill-pointer - 1 番目までの要素を有効なデータとして扱います。つまり、fill-pointer でデータの要素数を管理するわけです。
</p>
<p> vlvector-push! で末尾にデータを追加する場合、fill-pointer の位置にデータを書き込み、fill-pointer の値を +1 します。vlvector-pop! で末尾からデータを取り出す場合、fill-pointer の値を -1 してから、fill-pointer の位置にある要素を返します。これはスタックの動作と同じになります。
</p>
<p> データを追加するとき、fill-pointer の値とベクタの大きさを比較します。同じ値の場合、ベクタは満杯なので容量を 2 倍に増やします。Scheme の場合、ベクタの大きさを変更することはできないので、新しいベクタを生成して元のベクタからデータをコピーします。容量の変更はメソッド vlvector-resize で行います。ベクタを縮小することもできますが、fill-pointer よりも小さくすることはできません。
</p>
<p> fill-pointer の値はメソッド fill-pointer-set! で変更することができます。範囲は 0 からベクタの大きさまでです。値が範囲外の場合はエラーを送出します。あとは、クラス &lt;sequence&gt; を Mix-in します。&lt;sequence&gt; のメソッドはベクタの 0 番目から fill-pointer - 1 番目までの要素に対して働きますが、メソッド vlvector-ref と vlvector-set! はベクタ全体にアクセスできるものとします。なお、これらの仕様は Common Lisp の「配列 (array) 」を参考にしました。興味のある方は拙作のページ <a href="../xyzzy_lisp/abclisp05.html#yori04">ベクタとスタック</a> をお読みください。
</p>

<h4>●クラスの定義とベクタの初期化</h4>
<p> それではプログラムを作りましょう。最初にクラスを定義します。
</p>
<pre class="list">
リスト 1 : 可変長ベクタクラスの定義

; メタクラス
(define-class &lt;vlvector-meta&gt; (&lt;class&gt;) ())

; クラス
(define-class &lt;vlvector&gt; (&lt;sequence&gt;)
  ((buff :accessor get-buff :init-keyword :buff)
   (size :accessor get-size :init-value *min-size* :init-keyword :size)
   (nums :accessor get-nums :init-value 0))
  :metaclass &lt;vlvector-meta&gt;)
</pre>

<p> まず、&lt;sequence&gt; で必要になるメタクラス &lt;vlvector-meta&gt; を定義します。それから、クラス &lt;vlvector&gt; で &lt;sequence&gt; を Mix-in します。スロット buff にベクタを、size にベクタの大きさを、nums に要素数を格納します。この nums が fill-pointer になります。最後に :metaclass に &lt;vlvector-meta&gt; を指定します。
</p>

<p> スロット buff の初期化は総称関数 initialize で行います。次のリストを見てください。
</p>
<pre class="list">
リスト 2 : インスタンスの初期化

; 初期化
(define-method initialize ((obj &lt;vlvector&gt;) initargs)
  (next-method)
  (if (&lt; (get-size obj) *min-size*)
      (set! (get-size obj) *min-size*))
  (set! (get-buff obj) (make-vector (get-size obj))))
</pre>
<p> まず next-method でスーパークラスの initialize を呼び出します。それから、スロット size の値をチェックします。もしも、size がグローバル変数 *min-size* (4) よりも小さい場合は、その値を *min-size* に書き換えます。あとは大きさ size のベクタを make-vector で生成して buff にセットするだけです。
</p>

<h4>●汎変数の定義</h4>
<p> 次はフィルポインタを操作するメソッドを作ります。
</p>
<pre class="list">
リスト 3 : フィルポインタの操作

; フィルポインタを求める
(define-method fill-pointer ((v &lt;vlvector&gt;))
  (get-nums v))

; フィルポインタの変更
(define-method fill-pointer-set! ((v &lt;vlvector&gt;) (n &lt;integer&gt;))
  (if (or (negative? n) (&lt; (get-size v) n))
      (error "fill-pointer-set! : out of range"))
  (set! (get-nums v) n))

; 汎変数
(set! (setter fill-pointer) fill-pointer-set!)
</pre>
<p> メソッド fill-pointer は簡単です。メソッド get-nums でスロット nums の値を求めるだけです。メソッド fill-pointer-set! はスロット num の値を引数 n に書き換えるだけです。このとき、n の値が範囲内 (0 から size まで) であることを確認します。範囲外であればエラーを送出します。
</p>
<p> フィルポインタは set! で変更できると便利です。Gauche では汎変数を簡単に定義することができます。これには setter を使います。
</p>
<pre class="item">
setter proc
</pre>
<p> 関数 setter は引数 proc の setter 手続きを返します。Gauche の場合、setter 手続きは値を更新する関数のことです。たとえば、setter 手続きを update とすると、update は (proc args ...) が参照した値を次の形式で更新します。
</p>
<pre class="item">
update args ... value
</pre>
<p> 簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (setter car)
#&lt;subr set-car!&gt;
gosh&gt; (setter vector-ref)
#&lt;subr vector-set!&gt;
gosh&gt; (setter list-ref)
#f
gosh&gt; (define a '(1 2 3 4 5))
a
gosh&gt; (set! (car a) 10)
#&lt;undef&gt;
gosh&gt; a
(10 2 3 4 5)
</pre>
<p> car の setter 手続きは set-car! なので、(set! (car a) 10) は (set-car! a 10) に変換されて、リストの先頭要素が 10 に変更されます。また、vector-ref の setter 手続きは vector-set! ですが、list-ref の setter 手続きは定義されていません。
</p>
<p> setter 手続きの設定にも汎変数が使えるので簡単です。(set! (setter proc) update) とすれば、proc の setter 手続きを update に設定することができます。fill-pointer の場合も、(set! (setter fill-pointer) fill-pointer-set!) とすれば、fill-pointer の setter 手続きを fill-pointer-set! にすることができます。
</p>
<h4>●ベクタのリサイズ</h4>
<p> 次はベクタの大きさを変更するメソッド vlvector-resize を作ります。
</p>
<pre class="list">
リスト 4 : ベクタサイズの変更

(define-method vlvector-resize ((v &lt;vlvector&gt;) (new-size &lt;integer&gt;))
  (if (&lt; new-size (get-nums v))
      (error "vlvector-resize : not enough new-size"))
  (if (&lt; new-size *min-size*)
      (set! new-size *min-size*))
  (let ((new-buff (make-vector new-size)))
    (let loop ((i (- (get-nums v) 1)))
      (cond ((&lt;= 0 i)
             (vector-set! new-buff i (vector-ref (get-buff v) i))
             (loop (- i 1)))))
    (set! (get-buff v) new-buff)
    (set! (get-size v) new-size)))
</pre>
<p> 引数 new-size が新しいベクタの大きさです。new-size が要素数 nums よりも小さい場合はエラーを送出します。new-size が *min-size* よりも小さい場合は、new-size を *min-size* に変更します。あとは、大きさ new-size の新しいベクタを生成して、そこに buff からデータをコピーするだけです。
</p>

<h4>●データの追加と取り出し</h4>
<p> 次はメソッド vlvector-push! と vlvector-pop! を作ります。
</p>
<pre class="list">
リスト 5 : データの追加と取り出し

; 追加
(define-method vlvector-push! ((v &lt;vlvector&gt;) value)
  (if (= (get-size v) (get-nums v))
      (vlvector-resize v (* (get-size v) 2)))
  (vector-set! (get-buff v) (get-nums v) value)
  (inc! (get-nums v)))

; 取り出し
(define-method vlvector-pop! ((v &lt;vlvector&gt;))
  (if (vlvector-empty? v)
      (error "vlvector-pop! : &lt;vlvector&gt; is empty"))
  (dec! (get-nums v))
  (vector-ref (get-buff v) (get-nums v)))
</pre>
<p> vlvector-push! は簡単です。まず、ベクタが満杯かチェックし、そうであれば vlvector-resize を呼び出してベクタの大きさを 2 倍に拡張します。そして、nums の位置にデータ value をセットしてから nums の値を +1 します。
</p>
<p> vlvector-pop! は vevector-empty? を呼び出してベクタが空かチェックし、空の場合はエラーを送出します。そして、nums の値を -1 してから、その位置にある要素を取り出して返します。
</p>

<h4>●イテレータ</h4>
<p> 次は &lt;sequence&gt; で使うイテレータとビルダーを作ります。
</p>

<pre class="list">
リスト 6 : &lt;sequence&gt; 用メソッド

; イテレータ
(define-method call-with-iterator ((v &lt;vlvector&gt;) proc . opts)
  (let ((n (get-keyword :start opts 0)))
    (proc
      (lambda () (eqv? n (get-nums v)))
      (lambda ()
        (if (eqv? n (get-nums v))
            #f
          (begin0 (vector-ref (get-buff v) n)
                  (inc! n)))))))

; ビルダー
(define-method call-with-builder ((class &lt;vlvector-meta&gt;) proc . opts)
  (let ((v (make &lt;vlvector&gt;)))
    (proc (lambda (val) (vlvector-push! v val))
          (lambda () v))))

; 参照
(define-method referencer ((avec &lt;vlvector&gt;)) vlvector-ref)

; 更新
(define-method modifier ((avec &lt;vlvector&gt;)) vlvector-set!)

; オーバーライド
(define-method size-of ((v &lt;vlvector&gt;))
  (vlvector-length v))

(define-method lazy-size-of ((v &lt;vlvector&gt;))
  (vlvector-length v))
</pre>
<p> ベクタの有効範囲は 0 番目から nums - 1 番目までです。call-with-iterator は変数 n の位置にある要素を取り出して返すだけなので簡単です。call-with-builder も make で &lt;vlvector&gt; のインスタンスを生成して、vlvector-push! で要素を追加していくだけです。
</p>
<p> &lt;vlvector&gt; の要素数は簡単に求めることができるので、メソッド size-of と lazy-size-of をオーバーライドして、vlvector-length の値を返すようにします。デフォルトの動作は、call-with-iterator を呼び出してコレクションの大きさを求めています。 
</p>

<p> 後のメソッドは簡単なので説明は割愛いたします。詳細は <a href="abcobj08.html#list2">プログラムリスト２</a> をお読みください。
</p>
<h4>●実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
gosh&gt; (use vlvector)
#&lt;undef&gt;
gosh&gt; (use gauche.sequence)
#&lt;undef&gt;
gosh&gt; (define a (make &lt;vlvector&gt;))
a
gosh&gt; (vlvector-length a)
0
gosh&gt; (vlvector-size a)
4
gosh&gt; (vlvector-empty? a)
#t
gosh&gt; (dotimes (x 10) (vlvector-push! a x))
#t
gosh&gt; (vlvector-length a)
10
gosh&gt; (vlvector-size a)
16
gosh&gt; (vlvector-empty? a)
#f
gosh&gt; (for-each (lambda (x) (format #t "~D " x)) a)
0 1 2 3 4 5 6 7 8 9 #t
gosh&gt; (map (lambda (x) (* x x)) a)
(0 1 4 9 16 25 36 49 64 81)
gosh&gt; (define b (map-to &lt;vlvector&gt; (lambda (x) (* x x)) a))
b
gosh&gt; (for-each (lambda (x) (format #t "~D " x)) b)
0 1 4 9 16 25 36 49 64 81 #t
gosh&gt; (size-of b)
10
gosh&gt; (dotimes (x 10) (format #t "~D " (vlvector-pop! b)))
81 64 49 36 25 16 9 4 1 0 #t
gosh&gt; (size-of b)
0
gosh&gt; (vlvector-empty? b)
#t
gosh&gt; (set! (fill-pointer b) 10)
#&lt;undef&gt;
gosh&gt; (size-of b)
10
gosh&gt; (vlvector-empty? b)
#f
gosh&gt; (dotimes (x 10) (format #t "~D " (vlvector-pop! b)))
81 64 49 36 25 16 9 4 1 0 #t
</pre>
<p> 正常に動作しているようです。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
;
; vlvector.scm : 可変長ベクタクラス (variable-length vector)
;
;                Copyright (C) 2010 Makoto Hiroi
;

(define-module vlvector
  (use gauche.sequence)
  (export &lt;vlvector&gt;
          vlvector-ref    vlvector-set!
          vlvector-push!  vlvector-pop!
          vlvector-empty? vlvector-clear!
          vlvector-length vlvector-size
          fill-pointer    fill-pointer-set!
          vlvector-resize
          call-with-iterator
          call-with-builder
          referencer
          modifier))

(select-module vlvector)

;;; 定数
(define *min-size* 4)

;;; クラス定義

; メタクラス
(define-class &lt;vlvector-meta&gt; (&lt;class&gt;) ())

; クラス
(define-class &lt;vlvector&gt; (&lt;sequence&gt;)
  ((buff :accessor get-buff :init-keyword :buff)
   (size :accessor get-size :init-value *min-size* :init-keyword :size)
   (nums :accessor get-nums :init-value 0))
  :metaclass &lt;vlvector-meta&gt;)

; 初期化
(define-method initialize ((obj &lt;vlvector&gt;) initargs)
  (next-method)
  (if (&lt; (get-size obj) *min-size*)
      (set! (get-size obj) *min-size*))
  (set! (get-buff obj) (make-vector (get-size obj))))

;;; メソッドの定義

; 空にする
(define-method vlvector-clear! ((v &lt;vlvector&gt;))
  (set! (get-nums v) 0))

; 空か？
(define-method vlvector-empty? ((v &lt;vlvector&gt;))
  (zero? (get-nums v)))

; フィルポインタを求める
(define-method fill-pointer ((v &lt;vlvector&gt;))
  (get-nums v))

; フィルポインタの変更
(define-method fill-pointer-set! ((v &lt;vlvector&gt;) (n &lt;integer&gt;))
  (if (or (negative? n) (&lt; (get-size v) n))
      (error "fill-pointer-set! : out of range"))
  (set! (get-nums v) n))

; 汎変数
(set! (setter fill-pointer) fill-pointer-set!)

; 要素数を求める
(define-method vlvector-length ((v &lt;vlvector&gt;))
  (get-nums v))

; 大きさを求める
(define-method vlvector-size ((v &lt;vlvector&gt;))
  (get-size v))

; 参照 (ベクタ全体にアクセスできる)
(define-method vlvector-ref ((v &lt;vlvector&gt;) (n &lt;integer&gt;))
  (vector-ref (get-buff v) n))

; 更新 (ベクタ全体にアクセスできる)
(define-method vlvector-set! ((v &lt;vlvector&gt;) (n &lt;integer&gt;) value)
  (vector-set! (get-buff v) n value))

; 大きさの変更
(define-method vlvector-resize ((v &lt;vlvector&gt;) (new-size &lt;integer&gt;))
  (if (&lt; new-size (get-nums v))
      (error "vlvector-resize : not enough new-size"))
  (if (&lt; new-size *min-size*)
      (set! new-size *min-size*))
  (let ((new-buff (make-vector new-size)))
    (let loop ((i (- (get-nums v) 1)))
      (cond ((&lt;= 0 i)
             (vector-set! new-buff i (vector-ref (get-buff v) i))
             (loop (- i 1)))))
    (set! (get-buff v) new-buff)
    (set! (get-size v) new-size)))

; 追加
(define-method vlvector-push! ((v &lt;vlvector&gt;) value)
  (if (= (get-size v) (get-nums v))
      (vlvector-resize v (* (get-size v) 2)))
  (vector-set! (get-buff v) (get-nums v) value)
  (inc! (get-nums v)))

; 取り出し
(define-method vlvector-pop! ((v &lt;vlvector&gt;))
  (if (vlvector-empty? v)
      (error "vlvector-pop! : &lt;vlvector&gt; is empty"))
  (dec! (get-nums v))
  (vector-ref (get-buff v) (get-nums v)))

;;; イテレータ (fill-pointer までが有効)
(define-method call-with-iterator ((v &lt;vlvector&gt;) proc . opts)
  (let ((n (get-keyword :start opts 0)))
    (proc
      (lambda () (eqv? n (get-nums v)))
      (lambda ()
        (if (eqv? n (get-nums v))
            #f
          (begin0 (vector-ref (get-buff v) n)
                  (inc! n)))))))

; ビルダー
(define-method call-with-builder ((class &lt;vlvector-meta&gt;) proc . opts)
  (let ((avec (make &lt;vlvector&gt;)))
    (proc (lambda (val) (vlvector-push! avec val))
          (lambda () avec))))

; 参照
(define-method referencer ((avec &lt;vlvector&gt;)) vlvector-ref)

; 更新
(define-method modifier ((avec &lt;vlvector&gt;)) vlvector-set!)

; オーバーライド
(define-method size-of ((v &lt;vlvector&gt;))
  (vlvector-length v))

(define-method lazy-size-of ((v &lt;vlvector&gt;))
  (vlvector-length v))

(provide "vlvector")
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj07.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj09.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>