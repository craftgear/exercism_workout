<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 OCaml プログラミング入門</title>
  <meta name="description" content="OCaml,ML,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881750</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 OCaml プログラミング入門</h2>
<div class="small">
[ <a href="ocaml09.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml11.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap01">有理数</h3>
<p> 今回は簡単な例題として、有理数 (分数) を操作するモジュールを作ってみましょう。
</p>

<h4>●有理数の定義</h4>
<p> 有理数 (Rational) は分子と分母を整数の組で表すと簡単に定義できます。次のリストを見てください。
</p>
<pre class="list">
リスト 1 : 有理数の定義

type ratio = Rat of int * int
</pre>
<p> 最初の int が分子を表し、次の int が分母を表します。簡単な定義ですが、OCaml の整数は -1073741824 から 1073741823 までなので、このままでは実用的に使うことはできません。本格的な有理数モジュールを作るのであれば「多倍長整数」が必要になります。今回は簡単な例題ということで、このまま作ることにします。まあ、これでも簡単なパズルであれば解くことができるでしょう。
</p>
<p> なお、OCaml には Num というモジュールがあり、整数 (int)、有理数 (ratio)、多倍長整数 (big_int) という 3 種類の数を、num というデータ型で統一的に扱うことができます。Num は標準モジュールではありませんが、Ocaml の標準パッケージと一緒に配布されています。対話モードで使用するときは <del>num.cmo</del> nums.cma をロードしてください。
</p>

<h4>●有理数の生成</h4>
<p> 次は有理数を生成する関数 make_ratio を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト 2 : 有理数の生成

(* 最大公約数 *)
let rec gcd a b =
  if b = 0 then a else gcd b (a mod b)

(* データの生成 *)
let make_ratio a b =
  if b = 0 then raise Division_by_zero
  else
    let f = if b &lt; 0 then -1 else 1 and
        z = gcd (abs a) (abs b) in
    Rat ((f * a / z), (f * b / z))
</pre>

<p> make_ratio の引数 a が分子で、b が分母を表します。b が 0 の場合は例外 Division_by_zero を送出します。そうでなければ、Rat (a, b) を生成します。このとき、関数 gcd で最大公約数を求めて、約分することに注意してください。それから、有理数の符号は分子に付けることにします。分母 b が負の場合は a と b に -1 を掛け算します。
</p>

<h4>●算術演算子の定義</h4>
<p> 算術演算は make_ratio を使うと簡単に定義できます。このとき、算術演算を中置演算子として定義できると便利です。OCaml の場合、ある記号から始まるカリー化関数は中置演算子として用いることができます。中置演算子として使用できる記号の種類を示します。
</p>
<pre class="item">
先頭文字   = &lt; &gt; @ ^ | &amp; + - * / $ %
他の文字   ! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~ 
</pre>
<p> ただし、特定の記号列 (-&gt; や &lt;- など) は中置演算子として使うことはできません。なお、演算子の優先順位は先頭文字によって決められています。また、OCaml は前置演算子も定義することができます。詳細はリファレンスマニュアルをお読みください。
</p>
<p> たとえば、整数の演算子 +, -, *, / はカッコで囲むとカリー化関数として用いることができます。
</p>
<pre>
# (+);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# (+) 1 2;;
- : int = 3
</pre>

<p> 今回はモジュール Num に合わせて、算術演算子として +/, -/, */, -/ を使うことにしましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト 3 : 算術演算子の定義

let ( +/ ) (Rat (x1, y1)) (Rat (x2, y2)) =
  make_ratio (x1 * y2 + x2 * y1) (y1 * y2)

let ( -/ ) (Rat (x1, y1)) (Rat (x2, y2)) =
  make_ratio (x1 * y2 - x2 * y1) (y1 * y2)

let ( */ ) (Rat (x1, y1)) (Rat (x2, y2)) =
  make_ratio (x1 * x2) (y1 * y2)

let ( // ) (Rat (x1, y1)) (Rat (x2, y2)) =
  make_ratio (x1 * y2) (x2 * y1)
</pre>
<p> 演算子をカッコで囲み、カリー化関数として定義します。カッコと演算子の間に空白を入れていますが、(*) とするとコメントの開始記号になるので注意してください。単純な分数の計算なので、難しいところはないでしょう。この場合、演算子の優先順位は +, -, *, / と同じです。
</p>

<h4>●比較演算子の定義</h4>
<p> 次は比較演算子を定義します。最初に関数 compare_ratio を作ります。
</p>
<pre class="list">
リスト 4 : 有理数の比較

let compare_ratio (Rat (x1, y1)) (Rat (x2, y2)) =
  x1 * y2 - x2 * y1
</pre>
<p> compare_ratio は有理数 a と b を比較して、a &lt; b ならば負の整数を返し、a = b ならば 0 を返し、a &gt; b ならば正の整数を返します。この処理は a と b を通分して、a の分子から b の分子を引き算するだけで実現できます。
</p>

<p> compare_ratio を使うと比較演算子は簡単に定義できます。
</p>
<pre class="list">
リスト 5 : 比較演算子の定義

let ( =/ ) a b  = compare_ratio a b = 0
let ( &lt;&gt;/ ) a b = compare_ratio a b &lt;&gt; 0
let ( &lt;/ ) a b  = compare_ratio a b &lt; 0
let ( &gt;/ ) a b  = compare_ratio a b &gt; 0
let ( &lt;=/ ) a b = compare_ratio a b &lt;= 0
let ( &gt;=/ ) a b = compare_ratio a b &gt;= 0
</pre>
<p> 算術演算子に合わせて、名前の最後に / を付けています。
</p>

<h4>●データ型の変換</h4>
<p> 最後に有理数を他のデータ型に変換する関数を作ります。
</p>

<pre class="list">
リスト 6 : データ型の変換

(* 整数の判定 *)
let is_integer (Rat (_, y)) = y = 1

(* 整数に変換 *)
let int_of_ratio (Rat (x, y)) = x / y

(* 浮動小数点数に変換 *)
let float_of_ratio (Rat (x, y)) = (float_of_int x) /. (float_of_int y)

(* 文字列に変換 *)
let string_of_ratio (Rat (x, y)) =
  if y = 1 then string_of_int x
  else (string_of_int x) ^ "/" ^ (string_of_int y)

(* 表示 *)
let print_ratio n = print_string (string_of_ratio n)
</pre>

<p> 整数に変換する場合、無条件に x / y を計算しています。整数の判定には関数 is_integer を使ってください。あとはとくに難しいところはないでしょう。
</p>

<h4>●実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
# let a = make_ratio 1 2;;
val a : ratio = Rat (1, 2)
# let b = make_ratio 1 3;;
val b : ratio = Rat (1, 2)
# a +/ b;;
- : ratio = Rat (5, 6)
# a -/ b;;
- : ratio = Rat (1, 6)
# b -/ a;;
- : ratio = Rat (-1, 6)
# a */ b;;
- : ratio = Rat (1, 6)
# a // b;;
- : ratio = Rat (3, 2)
# a &lt;/ b;;
- : bool = false
# a &gt;/ b;;
- : bool = true
</pre>
<p> 正常に動作しているようです。モジュールとして使うのであれば、きちんとしたテストを行ったほうがよいでしょう。
</p>

<h4>●モジュールの作成</h4>
<p> それでは、テストを十分に行ったものとして、モジュールを作成しましょう。最初に mli ファイルを定義します。
</p>
<pre class="list">
リスト 7 : ratio,mli の内容

type ratio
val make_ratio : int -&gt; int -&gt; ratio
val is_integer : ratio -&gt; bool
val int_of_ratio : ratio -&gt; int
val float_of_ratio : ratio -&gt; float
val ( +/ ) : ratio -&gt; ratio -&gt; ratio
val ( -/ ) : ratio -&gt; ratio -&gt; ratio
val ( */ ) : ratio -&gt; ratio -&gt; ratio
val ( // ) : ratio -&gt; ratio -&gt; ratio
val compare_ratio : ratio -&gt; ratio -&gt; int
val ( =/ ) : ratio -&gt; ratio -&gt; bool
val ( &lt;&gt;/ ) : ratio -&gt; ratio -&gt; bool
val ( &lt;/ ) : ratio -&gt; ratio -&gt; bool
val ( &gt;/ ) : ratio -&gt; ratio -&gt; bool
val ( &lt;=/ ) : ratio -&gt; ratio -&gt; bool
val ( &gt;=/ ) : ratio -&gt; ratio -&gt; bool
val string_of_ratio : ratio -&gt; string
val print_ratio : ratio -&gt; unit
</pre>
<p> データ型は type ratio だけ記述します。これで ratio の詳細を隠蔽することができます。関数 gcd は非公開としました。必要であれば、コメントを書いておくとよいでしょう。
</p>
<p> あとはコンパイルするだけです。
</p>
<pre>
C&gt;ocamlc ratio.mli

C&gt;ocamlc -c ratio.ml

</pre>
<p> これでオブジェクトファイル ratio.cmo が生成されます。対話形式で利用する場合は、ocaml を起動するときに引数として ratio.cmo を与えるか、ディレクティブ #load で ratio.cmo をロードしてください。
</p>

<h4>●小町分数</h4>
<p> それではモジュール Ratio を使ってパズルをといてみましょう。なお、ここで紹介するパズルは、拙作のページ <a href="../clisp/clisp07.html#yori03">お気楽 CLOS プログラミング入門：ちょっと寄り道</a> で取り上げたものです。内容は重複しますが、ご了承くださいませ。
</p>

<p> それでは問題です。
</p>
<div class="question">
<b>[問題] 小町分数</b>
<p> 下図の A から I の場所に 1 から 9 までの数字をひとつずつ配置します。3 つの分数を足すと 1 / N になる配置を求めてください。
<pre class="fig">
  Ａ      Ｄ      Ｇ      １
 ---- ＋ ---- ＋ ---- ＝ ----
 ＢＣ    ＥＦ    ＨＩ     Ｎ

例： 3/27 + 6/54 + 9/81 = 1/3
     3/54 + 6/72 + 9/81 = 1/4

      図 1 : 小町分数
</pre>
</div>
<p> このパズルの元ネタは N = 1 の場合で、<a href="ocaml10.html#cite_1">参考文献 [10-1]</a> に掲載されています。ちなみに、3 つの分数の和が整数になる場合、その値は 1 しかありません。
</p>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト 8 : 小町分数 (1) の解法

open Ratio

(* 要素の削除 *)
let remove x xs = List.filter (fun y -&gt; x &lt;&gt; y) xs

(* 定数 *)
let one = make_ratio 1 1

(* 検定 *)
let check = function
  [n1; n2; n3; n4; n5; n6; n7; n8; n9] -&gt;
  let a = make_ratio n1 (n4 * 10 + n7) in
  let b = make_ratio n2 (n5 * 10 + n8) in
  let c = make_ratio n3 (n6 * 10 + n9) in
  let d = a +/ b +/ c in
  if is_integer (one // d) then begin
    Printf.printf "%d/%d%d + %d/%d%d + %d/%d%d = " n1 n4 n7 n2 n5 n8 n3 n6 n9;
    print_ratio d;
    print_newline ()
  end
| _ -&gt; raise (Failure "check")

(* 順列の生成 *)
let rec make_perm nums perm =
  if nums = [] then check (List.rev perm)
  else match perm with
    [n2; n1] when n1 &gt; n2 -&gt; ()
  | [n3; n2; _] when n2 &gt; n3 -&gt; ()
  | _ -&gt;  List.iter (fun x -&gt; make_perm (remove x nums) (x::perm)) nums

(* 実行 *)
let () = make_perm [1;2;3;4;5;6;7;8;9] []
</pre>

<p> 基本的には単純な生成検定法ですが、分子の数字を n1 &lt; n2 &lt; n3 と限定することで、重複解を生成しないように工夫しています。この処理は枝刈りの効果もあります。関数 make_perm の match 式で、n1 &gt; n2 のときと、n2 &gt; n3 のときに枝刈りを行っています。
</p>
<p> 関数 check は分数を生成して小町分数を計算します。その値を d とすると、1/d が整数であれば条件を満たします。関数 Printf.printf で数式を出力します。モジュール Printf にはＣ言語の標準ライブラリ関数 printf に相当する書式出力関数が定義されています。機能はＣ言語の printf とほぼ同じです。詳細は OCaml のリファレンスマニュアルをお読みください。
</p>
<p> 最後の let () = ... はＣ言語のメイン関数と同じ働きをします。ここで make_perm を呼び出します。コマンドラインの引数はモジュール Arg を使って、取得・解析することができます。
</p>

<p> それでは、実行してみましょう。ファイル名を bunsu.ml とするとコンパイルは次のように行います。
</p>
<pre>
C&gt; ocamlc -c bunsu.ml

C&gt; ocamlc -o bunsu.exe ratio.cmo bunsu.cmo

</pre>
<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;bunsu
1/38 + 2/95 + 4/76 = 1/10
1/24 + 3/56 + 7/98 = 1/6
1/56 + 3/72 + 9/84 = 1/6
1/26 + 5/39 + 7/84 = 1/4
1/32 + 5/96 + 7/84 = 1/6
1/48 + 5/32 + 7/96 = 1/4
1/96 + 5/32 + 7/84 = 1/4
1/96 + 5/48 + 7/32 = 1/3
2/19 + 4/57 + 6/38 = 1/3
2/18 + 5/63 + 7/49 = 1/3
3/48 + 5/16 + 9/72 = 1/2
3/27 + 6/54 + 9/81 = 1/3
3/54 + 6/72 + 9/81 = 1/4
5/34 + 7/68 + 9/12 = 1
</pre>
<p> 結果は全部で 14 通りになりました。
</p>

<p> ネイティブコードにコンパイルする場合は ocamlopt を使います。
</p>
<pre>
C&gt;ocamlopt -c ratio.ml

C&gt;ocamlopt -c bunsu.ml

C&gt;ocamlopt -o bunsu.exe ratio.cmx bunsu.cmx

</pre>
<p> ocamlopt で生成されるオブジェクトファイルは cmx という拡張子になります。なお、cmx ファイルは対話形式の ocaml で利用することはできません。ご注意くださいませ。あとは cmx ファイルはリンクするだけです。これで単独で実行できる bunsu.exe を作ることができます。
</p>

<h4>●単位分数の和</h4>
<p> パズルではありませんが、分数のお話を紹介します。分子が 1 の分数を「単位分数」といいますが、単位分数の和は古代エジプト人がよく研究していたそうです。この話は <a href="http://homepage2.nifty.com/m_kamada/index.htm">M.Kamada さん</a> からお聞きしたのですが、<a href="ocaml10.html#cite_2">参考文献 [10-2]</a> に「分数を単位分数の和で表す方法」がありましたので紹介します。
</p>

<p> 0 &lt; m / n &lt 1 の分数を単位分数の和で表します。まず、n / m の商 q を求めます。もし、割り切れれば単位分数になりますね。そうでなければ、m / n から 1 / (q + 1) を引き算して M / N を求めます。あとは、M / N に対して同じ処理を繰り返すだけです。次の式を見てください。
</p>
<pre class="item">
M / N = m / n - 1 / (q + 1)
M / N = (m(q + 1) - n) / n(q + 1)
M = m(q + 1) - n = m - (n - mq) = m - (n mod m)
</pre>
<p> 0 &lt; (n mod m) &lt; m ですから、M は必ず m より小さな値になります。つまり、この処理を繰り返していくと m は必ず 1 になるので、分数を単位分数の和で表すことができる、というわけです。なるほど納得のアルゴリズムですね。たとえば、11 / 13 を単位分数の和で表してみましょう。
</p>
<pre class="item">
11 / 13 =&gt; q = 1, 11 / 13 - 1 / 2 = 9 / 26
 9 / 26 =&gt; q = 2,  9 / 26 - 1 / 3 = 1 / 78
=&gt; 11 / 13 = 1 / 2 + 1 / 3 + 1 / 78
</pre>
<p> このように、分子 m の値は減少していきます。このアルゴリズムを OCaml でプログラムすると、次のようになります。
</p>

<pre class="list">
リスト 9 : 分数を単位分数の和で表す

let rec bunsu m n =
  if n mod m = 0 then Printf.printf "1/%d\n" (n / m)
  else
    let q = n / m + 1 in
      Printf.printf "1/%d + " q;
      bunsu ((m * q) - n) (n * q)
</pre>

<p> OCaml らしく再帰定義を使っています。関数名は適当なので、ふさわしい名前に変更してください。あとは、アルゴリズムをそのままプログラムしただけなので、特に難しいところはないでしょう。それでは実行してみましょう。
</p>
<pre>
# bunsu 11 13;;
1/2 + 1/3 + 1/78
- : unit = ()
# bunsu 12 13;;
1/2 + 1/3 + 1/12 + 1/156
- : unit = ()
# bunsu 19 23;;
1/2 + 1/4 + 1/14 + 1/215 + 1/138460
- : unit = ()
</pre>
<p> このほかにも、単位分数の和で表す方法は何通りもあるわけで、この方法はその中のひとつにすぎません。古代エジプトではどのような方法で求めたのでしょうか。興味深いところです。
</p>
<div class="note">
-- 参考文献 ------<br>
<a name="cite_1">[10-1]</a> 芦ヶ原伸之,『超々難問数理パズル 解けるものなら解いてごらん』, 講談社, 2002<br>
<a name="cite_2">[10-2]</a> 奥村晴彦, 『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</div>

<h4>●Four Four's</h4>
<p> Ratio を使ってもう一つパズルを解いてみましょう。Four Four's は数字を使ったパズルです。いろいろなルールがあるのですが、今回は簡易ルールで行きましょう。なお、このドキュメントは拙作のページ <a href="../puzzle/index.html"> Puzzle DE Programming</a> <a href="../puzzle/four.html">Four Four's</a> のプログラムを OCaml で書き直したものです。内容は重複しますが、ご了承くださいませ。
</p>
<p> それでは問題です。
</p>
<div class="question">
<b>[問題] Four Four's</b>
<p>数字 4 を 4 つと +, - *, /, () を使って、答えが 1 から 10 になる式を作りなさい。数字は 4 だけではなく、44 や 444 のように合体させてもよい。また、- を符号として使うことは禁止する。
</p>
</div>
<p> 数字の 4 を 4 つ使うので Four Four's という名前なのだと思います。ところで、このルールでは 11 になる式を作ることができません。ほかのルール、たとえば小数点を付け加えると、次のように作ることができます。
</p>
<pre class="item">
4 / .4 + 4 / 4 = 11
</pre>
<p> 今回は簡易ルールということで、小数点を使わないで 1 から 10 までの式を作ってください。まずは、ご自分の頭を使って解いてみましょう。気分転換や息抜きのときにでも考えてみてください。
</p>
<p> このほかに 4 つの数字を使ったパズルでは、M.Kamada さんの <a href="http://homepage2.nifty.com/m_kamada/index.htm">STUDIO KAMADA</a> に <a href="http://homepage2.nifty.com/m_kamada/kippu.htm">切符番号の問題</a> があります。また、未菜実さんの <a href="http://www.geocities.co.jp/Berkeley-Labo/6317/">未菜実の数理パズル入門</a> には <a href="http://www.geocities.co.jp/Berkeley-Labo/6317/kuruma.htm">車のナンバーは１０</a> というパズルがあります。ちなみに、Four Four's の話題もあります。実をいうと、M.Hiroi は未菜実さんのページで Four Four's を知りました。未菜実さんに感謝いたします。
</p>
<h4>●数式のパターン</h4>
<p> それではプログラムを作りましょう。基本的には、数式を生成して答えをチェックするだけです。Four Four's の場合、4 つの数値に 3 つの演算子しかありませんから、数式のパターンは簡単に求めることができます。数式を二分木で表すと、次に示す 5 つのパターンになります。
</p>

<pre class="fig">
          Ｘ                Ｘ                          Ｘ
        ／  ＼            ／  ＼                      ／  ＼
      ／      ＼        ４      Ｙ                  Ｙ      ４  
    Ｙ          Ｚ            ／  ＼              ／  ＼
  ／  ＼      ／  ＼        ４      Ｚ          Ｚ      ４
４     ４   ４      ４            ／  ＼      ／  ＼
                                ４      ４  ４      ４
        （１）             （２）                    （３）

    Ｘ                   Ｘ
  ／  ＼               ／  ＼
４      Ｙ           Ｙ      ４
      ／  ＼       ／  ＼
    Ｚ      ４   ４      Ｚ
  ／  ＼               ／  ＼
４      ４           ４      ４
  （４）               （５）

              図 2 : 数式のパターン (二分木)
</pre>
<p> X, Y, Z が演算子を表します。これを式で表すと、次のようになります。
</p>
<pre class="item">
(1) (4 Y 4) X (4 Z 4)
(2) 4 X (4 Y (4 Z 4))
(3) ((4 Z 4) Y 4) X 4
(4) 4 X ((4 Z 4) Y 4)
(5) (4 Y (4 Z 4)) X 4
</pre>
<p> あとは、X, Y, Z に演算子 +, -, *, / を入れて数式を計算すればいいわけです。
</p>
<p> Four Four's は数字を合体できるので、数字が 3 つで演算子が 2 つ、数字が 2 つで演算子がひとつ、というパターンもあります。演算子がひとつの場合は簡単ですね。演算子が 2 つの場合は、次の式になります。
</p>
<pre class="item">
(A) (a Y b) X c
(B) a X (b Y c)
</pre>
<p> a, b, c が数字で X, Y が演算子を表しています。数字は 4 か 44 になります。この場合、a, b, c の組み合わせを生成する必要があります。組み合わせを (a, b, c) で表すと、(4, 4, 44), (4, 44, 4), (44, 4, 4) の 3 通りとなります。これと演算子の組み合わせにより数式を生成して、答えを求めてチェックします。
</p>

<h4>●データ型の定義</h4>
<p> 最初に数式を表す二分木を定義します。
</p>
<pre class="list">
リスト 10 : 数式の定義

type op = Add | Sub | Mul | Div
type expr = Lf of ratio | Node of op * expr * expr
</pre>
<p> type op は演算子を表します。type expr は数式を表す二分木です。数式の場合、数値は葉 (Lf) に格納され、演算子は節 (Node) に格納されます。値を正確に計算するため、数値には ratio を使います。
</p>

<h4>●数式の計算</h4>
<p> 数式の計算は再帰定義を使うと簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト 11 : 数式の計算

let rec calc = function
  Lf n -&gt; n
| Node (Add, x, y) -&gt; (calc x) +/ (calc y)
| Node (Sub, x, y) -&gt; (calc x) -/ (calc y)
| Node (Mul, x, y) -&gt; (calc x) */ (calc y)
| Node (Div, x, y) -&gt; (calc x) // (calc y)

let calc_expr node = 
  let n = try calc node with Division_by_zero -&gt; zero in
  if is_integer n &amp;&amp; n &gt;=/ one &amp;&amp; n &lt;=/ ten then begin
    print_expr node; print_string " = "; print_ratio n; print_newline ()
  end
</pre>

<p> 引数が葉の場合、関数 calc は数値 n をそのまま返します。節の場合は、関数 calc を再帰呼び出しして部分木の値を求め、それを op に対応する演算子で計算するだけです。calc は関数 calc_expr から呼び出します。
</p>
<p> モジュール Ratio は 0 で除算すると例外 Division_by_zero を送出します。calc_expr では、これを try 式で受け取ります。zero は大域変数で make_ratio 0 1 で作成します。同様に one と ten も作成しておきます。計算結果 n が整数で 1 &lt;= n &lt;= 10 であれば式を関数 print_expr で出力します。
</p>
<h4>●数式の生成</h4>
<p> 次は数式を生成する処理を作ります。
</p>
<pre class="list">
リスト 12 : 数式の生成

let make_exprs4 = function
  [op1; op2; op3] -&gt;
  [Node (op1, Node (op2, Lf four, Lf four), Node (op3, Lf four, Lf four));
   Node (op1, Lf four, Node (op2, Lf four, Node (op3, Lf four, Lf four)));
   Node (op1, Node (op2, Node (op3, Lf four, Lf four), Lf four), Lf four);
   Node (op1, Lf four, Node (op2, Node (op3, Lf four, Lf four), Lf four));
   Node (op1, Node (op2, Lf four, Node (op3, Lf four, Lf four)), Lf four)]
| _ -&gt; raise (Failure "make_exprs4")

(* 重複を許す順列 *)
let rec solve4 n perm =
  if n = 3 then
    List.iter (fun x -&gt; calc_expr x) (make_exprs4 (List.rev perm))
  else
    List.iter (fun x -&gt; solve4 (n + 1) (x::perm)) [Add; Sub; Mul; Div]
</pre>

<p> 演算子の組み合わせは「重複を許す順列」と同じになります。関数 solve4 は演算子の順列を生成し、それを関数 make_expr に渡します。make_expr は 5 通りの数式をリストに格納して返すので、それを List.iter で一つずつ取り出して calc_expr に渡して計算します。
</p>

<p> 数字が 3 つで演算子が 2 つの場合も、基本的には同じプログラムになります。ただし、数字は引数として渡します。あとは特に難しいところはないでしょう。詳細は <a href="ocaml10.html#list">プログラムリスト</a> を参照してください。
</p>

<h4>●実行結果</h4>
<p> さっそく実行してみたところ、全部で 100 通りの式が出力されました。このプログラムは重複解のチェックを行っていないので、多数の式が出力されることに注意してください。実行結果の一部を示します。
</p>
<pre class="item">
((4 - 4) + (4 / 4)) = 1
((4 / 4) + (4 / 4)) = 2
(((4 + 4) + 4) / 4) = 3
(4 + (4 * (4 - 4))) = 4
(((4 * 4) + 4) / 4) = 5
(((4 + 4) / 4) + 4) = 6
(4 + (4 - (4 / 4))) = 7
((4 + 4) + (4 - 4)) = 8
((4 + 4) + (4 / 4)) = 9
((44 - 4) / 4) = 10
</pre>

<p> この中で、10 になる式は (44 - 4) / 4 しかありません。数字 4 を 4 つと +, -, *, / () だけでは、10 になる式を作ることはできないことがわかります。
</p>
<p> また、このプログラムはカッコをはずす処理を行っていないので、数式はちょっとわかりづらいですね。興味のある方は演算子の優先順位を考慮してカッコをはずすプログラムにも挑戦してみてください。
</p>
<hr>
<h4 id="list">●プログラムリスト</h4>
<pre class="list">
(* 
 * four.ml : Four Four's
 *
 *           Copyright (C) 2008 Makoto Hiroi
 *)

open Ratio

(* 定数 *)
let zero = make_ratio  0 1
let one  = make_ratio  1 1
let four = make_ratio  4 1
let ten  = make_ratio 10 1

(* 数式 *)
type op = Add | Sub | Mul | Div
type expr = Lf of ratio | Node of op * expr * expr

(* 演算子の表示 *)
let print_op = function
  Add -&gt; print_string " + "
| Sub -&gt; print_string " - "
| Mul -&gt; print_string " * "
| Div -&gt; print_string " / "

(* 数式の表示 *)
let rec print_expr = function
  Lf n -&gt; print_ratio n
| Node (op, x, y) -&gt;
    print_string "(";
    print_expr x;
    print_op op;
    print_expr y;
    print_string ")"

(* 計算 *)
let rec calc = function
  Lf n -&gt; n
| Node (Add, x, y) -&gt; (calc x) +/ (calc y)
| Node (Sub, x, y) -&gt; (calc x) -/ (calc y)
| Node (Mul, x, y) -&gt; (calc x) */ (calc y)
| Node (Div, x, y) -&gt; (calc x) // (calc y)

let calc_expr node = 
  let n = try calc node with Division_by_zero -&gt; zero in
  if is_integer n &amp;&amp; n &gt;=/ one &amp;&amp; n &lt;=/ ten then begin
    print_expr node; print_string " = "; print_ratio n; print_newline ()
  end

(* 数式の作成 *)
let make_exprs4 = function
  [op1; op2; op3] -&gt;
  [Node (op1, Node (op2, Lf four, Lf four), Node (op3, Lf four, Lf four));
   Node (op1, Lf four, Node (op2, Lf four, Node (op3, Lf four, Lf four)));
   Node (op1, Node (op2, Node (op3, Lf four, Lf four), Lf four), Lf four);
   Node (op1, Lf four, Node (op2, Node (op3, Lf four, Lf four), Lf four));
   Node (op1, Node (op2, Lf four, Node (op3, Lf four, Lf four)), Lf four)]
| _ -&gt; raise (Failure "make_exprs4")

let make_exprs3 x1 x2 x3 = function
  [op1; op2] -&gt;
  [Node (op1, Lf x1, Node(op2, Lf x2, Lf x3));
   Node (op1, Node(op2, Lf x1, Lf x2), Lf x3)]
| _ -&gt; raise (Failure "make_exprs3")

(* 重複を許す順列 *)
let rec solve4 n perm =
  if n = 3 then
    List.iter (fun x -&gt; calc_expr x) (make_exprs4 (List.rev perm))
  else
    List.iter (fun x -&gt; solve4 (n + 1) (x::perm)) [Add; Sub; Mul; Div]

let rec solve3 n x1 x2 x3 perm =
  if n = 2 then
    List.iter (fun x -&gt; calc_expr x) (make_exprs3 x1 x2 x3 (List.rev perm))
  else
    List.iter (fun x -&gt; solve3 (n + 1) x1 x2 x3 (x::perm)) [Add; Sub; Mul; Div]

let solve2 x1 x2 =
  List.iter (fun x -&gt; calc_expr x) 
            (List.map (fun x -&gt; Node(x, Lf x1, Lf x2)) [Add; Sub; Mul; Div])

(* 実行 *)
let () =
  let a = make_ratio 44 1 and
      b = make_ratio 444 1 in
    solve4 0 [];
    solve3 0 a four four [];
    solve3 0 four a four [];
    solve3 0 four four a [];
    solve2 four b;
    solve2 b four;
    solve2 a a
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2008 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="ocaml09.html">PrevPage</a> | <a href="ocaml.html">OCaml</a> | <a href="ocaml11.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>