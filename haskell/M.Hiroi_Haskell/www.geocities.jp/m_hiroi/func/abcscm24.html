<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門</title>
  <meta name="description" content="Lisp,Scheme,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881782</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<div class="small">
[ <a href="abcscm23.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm24a.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>遅延ストリーム (2)</h3>
<h4>●遅延ストリームの併合</h4>
<p> 次は、要素を昇順に出力する 2 つの遅延ストリームを併合 (マージ: merge) する関数を作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 遅延ストリームのマージ

;; 遅延ストリームの併合
(define (stream-merge s1 s2)
  (cond ((empty? s1) s2)
        ((empty? s2) s1)
        (else
         (if (&lt;= (stream-car s1) (stream-car s2))
             (stream-cons (stream-car s1) (stream-merge (stream-cdr s1) s2))
           (stream-cons (stream-car s2) (stream-merge s1 (stream-cdr s2)))))))
</pre>
<p> stream-merge は 2 つの遅延ストリームを併合して新しい遅延ストリームを返します。s1 が空であれば s2 を返し、s2 が空ならば s1 を返します。そうでなければ、遅延ストリームの先頭要素を比較します。s1 の要素が s2 の要素以下ならば s1 の要素を、そうでなければ s2 の要素を遅延ストリームに格納します。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
gosh> (define s1 (iterate (lambda (x) (+ x 2)) 1))
s1
gosh> (define s2 (iterate (lambda (x) (+ x 2)) 2))
s2
gosh> (define s3 (stream-merge s1 s2))
s3
gosh> (stream-take s3 20)
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)
gosh> (stream-take (stream-merge s1 s1) 20)
(1 1 3 3 5 5 7 7 9 9 11 11 13 13 15 15 17 17 19 19)
</pre>
<h4>●集合演算</h4>
<p> ここで、遅延ストリームには重複要素が存在せず、要素は昇順に出力されることを前提にすると、遅延ストリームでも集合演算を行うことができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 集合演算

;; 和集合
(define (stream-union s1 s2)
  (cond ((empty? s1) s2)
        ((empty? s2) s1)
        (else
         (cond ((&lt; (stream-car s1) (stream-car s2))
                  (stream-cons (stream-car s1)
                               (stream-union (stream-cdr s1) s2)))
                 ((&gt; (stream-car s1) (stream-car s2))
                  (stream-cons (stream-car s2)
                               (stream-union s1 (stream-cdr s2))))
                 (else
                  (stream-cons (stream-car s1)
                               (stream-union (stream-cdr s1) (stream-cdr s2))))))))

;; 積集合
(define (stream-intersect s1 s2)
  (cond ((or (empty? s1) (empty? s2)) nil)
        ((= (stream-car s1) (stream-car s2))
         (stream-cons (stream-car s1)
                      (stream-intersect (stream-cdr s1) (stream-cdr s2))))
        ((&lt; (stream-car s1) (stream-car s2))
         (stream-intersect (stream-cdr s1) s2))
        (else
         (stream-intersect s1 (stream-cdr s2)))))
</pre>
<p> stream-union は s1 と s2 から要素を取り出して、小さいほうを遅延ストリームに追加します。等しい場合は要素をひとつだけ追加します。このとき、s1 と s2 の両方から先頭要素を取り除くことに注意してください。
</p>
<p> stream-intersect も簡単です。s1, s2 の先頭要素を比較して、等しい場合はその要素を遅延ストリームに追加します。s1 の要素が s2 の要素よりも小さい場合は、s1 を一つ進めて次の要素を調べます。s2 の要素が小さい場合は s2 の次の要素を調べます。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
gosh&gt; (define xs (stream-map (lambda (x) (/ (* x (+ x 1)) 2)) (iterate (lambda (x) (+ x 1)) 1)))
xs
gosh&gt; (define ys (stream-map (lambda (x) (* x x)) (iterate (lambda (x) (+ x 1)) 1)))
ys
gosh&gt; (stream-take xs 20)
(1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210)
gosh&gt; (stream-take ys 20)
(1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400)
gosh&gt; (stream-take (stream-union xs ys) 20)
(1 3 4 6 9 10 15 16 21 25 28 36 45 49 55 64 66 78 81 91)
gosh&gt; (stream-take (stream-intersect xs ys) 7)
(1 36 1225 41616 1413721 48024900 1631432881)
</pre>
<p> 遅延ストリーム xs は「三角数」、ys は「四角数」を表します。これらの遅延ストリームを stream-union でまとめると、三角数または四角数の数列になります。stream-intersect でまとめると、三角数かつ四角数の数列 (平方三角数) になります。平方三角数は拙作のページ <a href="../puzzle/index.html">Puzzle DE Progamming</a> <a href="../puzzle/polynum.html">多角数</a> でも取り上げています。興味のある方はお読みくださいませ。
</p>

<h4>●ハミングの問題</h4>
<p> ここで stream-unio を使うと簡単に解ける問題を紹介しましょう。
</p>
<div class="question">
<b>[ハミングの問題]</b><br>
<p> 7 以上の素数で割り切れない正の整数を小さい順に N 個求めよ
</p>
<a name="cite0130">参考文献</a> : 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991 (361 ページより引用)
</div>
<p> 7 以上の素数で割り切れない正の整数は、素因子が 2, 3, 5 しかない自然数のことで、これを「ハミング数 (Hamming Numbers)」といいます。ハミング数は素因数分解したとき、2<sup>i</sup> * 3<sup>j</sup> * 5<sup>k</sup> (i, j, k &gt;= 0) の形式になります。たとえば、100 以下のハミング数は次のようになります。
</p>
<pre class="item">
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 
54, 60, 64, 72, 75, 80, 81, 90, 96, 100
</pre>
<p> 遅延ストリームを使うと「ハミングの問題」は簡単に解くことができます。小さい順にハミング数を出力する遅延ストリームを hs としましょう。hs は 1 から始まるので次のように定義できます。
</p>
<pre class="item">
(define hs (stream-cons 1 (...))
</pre>
<p> 最初の要素は 1 なので、それに 2, 3, 5 を掛け算した値 (2, 3, 5) もハミング数になります。この値は次の S 式で生成することができます。
</p>
<pre class="item">
(stream-map (lambda (x) (* x 2) hs)
(stream-map (lambda (x) (* x 3) hs)
(stream-map (lambda (x) (* x 5) hs)
</pre>
<p> あとは、これらの遅延ストリームを stream-union でひとつにまとめて、小さい順に出力すればいいわけです。
</p>
<p> プログラムと実行結果を示します。
</p>
<pre>
gosh&gt; (define hs (stream-cons 1
 (stream-union (stream-map (lambda (x) (* x 2)) hs)
 (stream-union (stream-map (lambda (x) (* x 3)) hs)
 (stream-map (lambda (x) (* x 5)) hs)))))
hs
gosh&gt; (stream-take hs 100)
(1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 45 48 50 54 60 64 72 75
80 81 90 96 100 108 120 125 128 135 144 150 160 162 180 192 200 216 225 240 243
250 256 270 288 300 320 324 360 375 384 400 405 432 450 480 486 500 512 540 576
600 625 640 648 675 720 729 750 768 800 810 864 900 960 972 1000 1024 1080 1125
1152 1200 1215 1250 1280 1296 1350 1440 1458 1500 1536)
</pre>
<h4>●順列の生成</h4>
<p> 次は遅延ストリームを使って順列を生成するプログラムを作ってみましょう。遅延ストリームを使う場合、再帰呼び出しの一番深いところで順列が完成するようにプログラムするとうまくいきません。要素が n 個の順列を生成する場合、n - 1 個の順列を生成するストリームを生成し、そこに要素を一つ加えて n 個の順列を生成すると考えます。
</p>

<p> まずは簡単な例として、遅延ストリームではなく、リストを使ってプログラムを作ってみます。次のリストを見てください。
</p>

<pre class="list">
リスト : 順列の生成

(use srfi-1)

; マッピングした結果を平坦化する
(define (flatmap fn ls)
  (apply append (map fn ls)))

; 順列の生成
(define (perm n ls)
  (if (zero? n)
      '(())
    (flatmap (lambda (x)
               (map (lambda (y) (cons x y))
                    (perm (- n 1) (remove (lambda (z) (eqv? x z)) ls))))
             ls)))
</pre>

<p> 関数 perm は引数のリスト ls から n 個を選ぶ順列を生成し、それをリストに格納して返します。n = 0 が再帰の停止条件で、空リストを格納したリストを返します。このリストに対して要素を追加します。この処理は map を二重に使うと簡単に実現できます。次の例を見てください。
</p>
<pre>
gosh&gt; (map (lambda (x) (cons 5 x)) '((1) (2) (3) (4) (5)))
((5 1) (5 2) (5 3) (5 4) (5 5))
gosh&gt; (display (map (lambda (y) (map (lambda (x) (cons y x))
 '((1) (2) (3) (4) (5)))) '(5 6)))
(((5 1) (5 2) (5 3) (5 4) (5 5)) ((6 1) (6 2) (6 3) (6 4) (6 5)))#&lt;undef&gt;
</pre>
<p> リストの各要素に 5 を追加したい場合、map を使うと簡単ですね。次は、リスト (5 6) の各要素を追加したリストを求めることを考えます。map を二重にして、(5 6) の要素を匿名関数の引数 y に渡します。次の map で y をリストに追加します。すると、返り値のリストには 5 を追加したリストと 6 を追加したリストが格納されます。map を二重にしているので、リストの階層が 1 段深くなるわけです。そこで、リストを一段階だけ平坦化する flatmap を使います。
</p>
<p> 関数 perm の説明に戻ります。ラムダ式の中で perm を再帰呼び出しをして、n - 1 個を選ぶ順列を生成します。そして、その返り値にリスト ls の要素 x を追加すれば、n 個の順列を生成することができます。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
gosh&gt; (perm 4 '(1 2 3 4))
((1 2 3 4) (1 2 4 3) (1 3 2 4) (1 3 4 2) (1 4 2 3) (1 4 3 2) (2 1 3 4) (2 1 4 3)
 (2 3 1 4) (2 3 4 1) (2 4 1 3) (2 4 3 1) (3 1 2 4) (3 1 4 2) (3 2 1 4) (3 2 4 1)
 (3 4 1 2) (3 4 2 1) (4 1 2 3) (4 1 3 2) (4 2 1 3) (4 2 3 1) (4 3 1 2) (4 3 2 1)
)
</pre>
<h4>●遅延ストリーム版</h4>
<p> それでは、遅延ストリームを使ったプログラムを作ります。
</p>
<pre class="list">
リスト : 遅延ストリームによる順列の生成

(define (make-perm n s)
  (if (zero? n)
      (stream-cons '() nil)
    (stream-flatmap
      (lambda (x)
        (stream-map (lambda (y) (cons x y))
                    (make-perm
                      (- n 1)
                      (stream-filter (lambda (z) (not (eqv? x z))) s))))
      s)))
</pre>
<p> 関数 make-perm はストリーム s の中から要素を n 個選ぶ順列を生成します。n = 0 の場合は空リストを格納したストリームを返します。あとは、stream-flatmap のラムダ式の中で、make-perm を再帰呼び出しして n - 1 個を選ぶ順列を生成します。ストリーム s から要素 x を取り除くため、stream-filter を使っています。これで順列を生成するストリームを作ることができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
gosh&gt; (define perms (make-perm 4 (range 1 4)))
perms
gosh&gt; (stream-take perms 24)
((1 2 3 4) (1 2 4 3) (1 3 2 4) (1 3 4 2) (1 4 2 3) (1 4 3 2) (2 1 3 4) (2 1 4 3)
 (2 3 1 4) (2 3 4 1) (2 4 1 3) (2 4 3 1) (3 1 2 4) (3 1 4 2) (3 2 1 4) (3 2 4 1)
 (3 4 1 2) (3 4 2 1) (4 1 2 3) (4 1 3 2) (4 2 1 3) (4 2 3 1) (4 3 1 2) (4 3 2 1)
)
</pre>
<p> 24 通りの順列をすべて求めることができました。拙作のページ <a href="abcscm20.html">継続と継続渡しスタイル</a> では、継続を使って順列を一つずつ生成するプログラムを作りましたが、遅延ストリームの方がちょっと複雑になったかもしれません。そのかわり、継続がなくても遅延評価があれば、このように順列を生成するプログラムを作ることができます。
</p>
<h4>●８クイーンの解法</h4>
<p> 同様に、遅延ストリームを使って 8 クイーンを解くことができます。
</p>
<pre class="list">
リスト : 8 クイーンの解法 (遅延ストリーム版)

;; 衝突のチェック
(define (attack x xs)
  (define (attack-sub x n ys)
    (cond ((null? ys) #t)
           ((or (= (+ (car ys) n) x)
                (= (- (car ys) n) x))
             #f)
          (else
           (attack-sub x (+ n 1) (cdr ys)))))
  (attack-sub x 1 xs))

;; N Queen の解法
(define (queen s)
  (if (empty? s)
      (stream-cons '() nil)
    (stream-filter
      (lambda (ls)
        (if (null? ls)
            #t
          (attack (car ls) (cdr ls))))
      (stream-flatmap
        (lambda (x)
          (stream-map (lambda (y) (cons x y))
                      (queen (stream-filter (lambda (z) (not (eqv? x z))) s))))
      s))))
</pre>

<p> 関数 queen は make-perm とほぼ同じですが、追加したクイーンが他のクイーンと衝突している場合は stream-filter を使って取り除いています。衝突をチェックする関数 attack は拙作のページ <a href="ocaml08.html#chap02">OCaml 入門：バックトラック法</a> の 8 クイーンで作成したプログラムを Scheme に直したものです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
gosh&gt; (stream-take (queen (range 1 8)) 10)
((1 5 8 6 3 7 2 4) (1 6 8 3 7 4 2 5) (1 7 4 6 8 2 5 3) (1 7 5 8 2 4 6 3)
 (2 4 6 8 3 1 7 5) (2 5 7 1 3 8 6 4) (2 5 7 4 1 8 6 3) (2 6 1 7 4 8 3 5)
 (2 6 8 3 1 4 7 5) (2 7 3 6 8 5 1 4))
</pre>
<p> 解の総数は全部で 92 通りあります。
</p>
<h4>●木の巡回と CPS</h4>
<p> 次はリストを木とみなして、木を巡回して要素を一つずつ出力するする遅延ストリームを作ってみましょう。ここでは、コンスセルを節 (node) とし要素を葉 (leaf) と考えます。木を巡回するプログラムは簡単です。次のリストを見てください。
</p>

<pre class="list">
リスト : 木の巡回

(define (for-each-tree fn ls)
  (cond ((null? ls) '())
        ((not (pair? ls)) (fn ls))
        (else
         (for-each-tree fn (car ls))
         (for-each-tree fn (cdr ls)))))
</pre>

<p> 関数 for-each-tree は木 ls を巡回して、各要素に関数 fn を適用します。for-each-tree は関数 fn の副作用が目的なので、返り値に意味はありません。ls が空リストならば何もせずに空リストを返します。ls がアトムならば葉なので関数 fn を適用します。あとは、ls を car と cdr で分解して、for-each-tree を再帰呼び出しするだけです。
</p>

<p> このプログラムを CPS に変換すると、次のようになります。
</p>
<pre class="list">
リスト : 木の巡回 (CPS)

(define (for-each-tree-cps fn ls cont)
  (cond ((null? ls) (cont))
        ((not (pair? ls))
         (fn ls)
         (cont))
        (else
         (for-each-tree-cps
           fn
           (car ls)
           (lambda () (for-each-tree-cps fn (cdr ls) (lambda () (cont))))))))
</pre>

<p> for-each-tree-cps は副作用が目的なので、継続に値を渡す必要はありません。ls が空リストの場合は cont を呼び出します。ls が葉の場合は fn を適用してから cont を呼び出します。次に、for-each-tree-cps を再帰呼び出しして CAR の部分木をたどり、その継続の中で CDR の部分木をたどります。そして、その継続の中で cont を呼び出します。これで生成された継続を呼び出して、木を巡回することができます。
</p>

<p> それでは実際に試してみましょう。
</p>
<pre>
gosh&gt; (for-each-tree-cps print '(a (b (c (d . e) f) g)) (lambda () '()))
a
b
c
d
e
f
g
()
</pre>
<p> このように、木を巡回して各要素に関数 fn を適用することができます。
</p>
<h4>●木の巡回と遅延ストリーム</h4>
<p> 木の巡回を CPS に変換すると、遅延ストリームに対応するのも簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 木の巡回 (遅延ストリーム版)

(define (stream-of-tree ls cont)
  (cond ((null? ls) (cont))
        ((not (pair? ls))
         (stream-cons ls (cont)))
        (else
         (stream-of-tree
           (car ls)
           (lambda () (stream-of-tree (cdr ls) (lambda () (cont))))))))
</pre>

<p> stream-of-tree は木を巡回してその要素を順番に出力する遅延ストリームを生成します。stream-of-tree は ls が葉の場合に stream-cons で遅延ストリームを生成して返します。このとき、ls が遅延ストリームの要素になり、遅延オブジェクトには継続 cont の呼び出しを格納します。この遅延オブジェクトを force することで、次の要素を求めることができます。
</p>
<p> なお、stream-of-tree を呼び出すときに渡す継続が一番最後に呼び出されるので、遅延ストリームの終端 nil を返すように定義してください。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
gosh&gt; (define trees (stream-of-tree '(a (b (c (d . e) f) g)) (lambda () nil)))
trees
gosh&gt; (stream-take trees 7)
(a b c d e f g)
</pre>

<h4>●ツリーマッチング</h4>
<p> stream-of-tree を使うと、2 つの木を比較する関数 same-fringe-p を簡単に作ることができます。同じ葉を同じ並びで持つ場合、same-fringe-p は t を返します。次の例を見てください。
</p>
<pre class="item">
(same-fringe-p '(1 2 (3) 4) '(1 2 (3 4)) =&gt; #t
(same-fringe-p '(1 2 (3) 4) '(1 2 (4) 3) =&gt; #f
</pre>
<p> 最初の例の場合、木の構造は違いますが、要素はどちらの木も 1, 2, 3, 4 の順番で並んでいるので、same-fringe-p は #t を返します。次の例では、木の構造は同じですが、 3 と 4 の順番が逆になっています。この場合、same-fringe-p は #f を返します。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : ツリーマッチング

(define (same-fringe-p tree1 tree2)
  (define (iter s1 s2)
    (cond ((and (empty? s1) (empty? s2)) #t)
          ((or (empty? s1) (empty? s2)) #f)
          ((eqv? (stream-car s1) (stream-car s2))
           (iter (stream-cdr s1) (stream-cdr s2)))
          (else #f)))
  (iter (stream-of-tree tree1 (lambda () nil))
        (stream-of-tree tree2 (lambda () nil))))
</pre>
<p> 実際の処理は局所関数 iter で行います。same-fringe-p は stream-of-tree で木の遅延ストリームを生成して iter に渡します。あとは、遅延ストリームから要素を一つずつ取り出して、それが等しいかチェックするだけです。
</p>
<p> それでは実行例を示します。
</p>
<pre>
gosh&gt; (same-fringe-p '(1 2 (3 4 (5 . 6) 7) 8) '(1 2 (3 4 (5 6) 7) 8))
#t
gosh&gt; (same-fringe-p '(1 2 (3 4 (5 . 6) 7) 8) '(1 2 (3 4 (6 5) 7) 8))
#f
</pre>
<p> 正常に動作していますね。
</p>
<h4 id="cite">●参考文献</h4>
<ol>
  <LI><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs (SICP)"</a> <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">3.5  Streams</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
;;
;; lazystream.scm : 遅延ストリーム
;;
;;                  Copyrighti (C) 2009-2017 Makoto Hiroi
;;
(use srfi-1)

;; 遅延ストリームの基本関数
(define-syntax stream-cons
  (syntax-rules ()
    ((_ a b) (cons a (delay b)))))

;; 先頭要素を取り出す
(define (stream-car s) (car s))

;; 先頭要素を取り除く
(define (stream-cdr s) (force (cdr s)))

;; ストリームの終端
(define nil '())
(define empty? null?)

;;
;; ストリームの生成
;;

;; 数列を生成するストリーム
(define (range low high)
  (if (&gt; low high)
      nil
    (stream-cons low
                 (range (+ 1 low) high))))

;; フィボナッチ数列を生成する遅延ストリーム
(define (fibonacci a b)
  (stream-cons a (fibonacci b (+ a b))))

;; 初項が a で次項を proc で生成する
(define (iterate proc a)
  (stream-cons a (iterate proc (proc a))))

;; リストを遅延ストリームに変換する
(define (list-&gt;stream xs)
  (if (null? xs)
      nil
    (stream-cons (car xs) (list-&gt;stream (cdr xs)))))

;;
;; 操作関数
;;

;; n 番目の要素を求める
(define (stream-ref s n)
  (if (zero? n)
      (stream-car s)
    (stream-ref (stream-cdr s) (- n 1))))

;; 先頭から n 個の要素を取り出す
(define (stream-take s n)
  (let loop ((s s) (n n) (a '()))
    (if (or (empty? s) (zero? n))
        (reverse! a)
      (loop (stream-cdr s) (- n 1) (cons (stream-car s) a)))))

;; 先頭から n 個の要素を取り除く
(define (stream-drop s n)
  (if (or (empty? s) (zero? n))
      s
    (stream-drop (stream-cdr s) (- n 1))))

;; 遅延ストリームの連結
(define (stream-append s1 s2)
  (if (empty? s1)
      s2
    (stream-cons (stream-car s1)
                 (stream-append (stream-cdr s1) s2))))

;; 遅延評価版
(define (stream-append-delay s1 s2)
  (if (empty? s1)
      (force s2)
    (stream-cons (stream-car s1)
                 (stream-append-delay (stream-cdr s1) s2))))

;; ストリームの要素を交互に出力
(define (interleave s1 s2)
  (if (empty? s1)
      s2
    (stream-cons (stream-car s1)
                 (interleave s2 (stream-cdr s1)))))

;;
;; 高階関数
;;

;; マッピング
(define (stream-map proc . s)
  (if (any empty? s)
      nil
    (stream-cons (apply proc (map stream-car s))
                 (apply stream-map proc (map stream-cdr s)))))

;; stream-map の結果を平坦化する
(define (stream-flatmap proc s)
  (if (empty? s)
      nil
    (stream-append-delay (proc (stream-car s))
                         (delay (stream-flatmap proc (stream-cdr s))))))

;; フィルター
(define (stream-filter pred s)
  (cond ((empty? s) nil)
        ((pred (stream-car s))
         (stream-cons (stream-car s)
                      (stream-filter pred (stream-cdr s))))
        (else
         (stream-filter pred (stream-cdr s)))))

;; 畳み込み
(define (stream-fold-left proc a s)
  (if (empty? s)
      a
    (stream-fold-left proc (proc a (stream-car s)) (stream-cdr s))))

(define (stream-fold-right proc a s)
  (if (empty? s)
      a
    (proc (stream-car s) (stream-fold-right proc a (stream-cdr s)))))

;; 巡回
(define (stream-for-each proc s)
  (cond ((not (empty? s))
         (proc (stream-car s))
         (stream-for-each proc (stream-cdr s)))))

;; 述語 pred が真を返す要素を取り出す
(define (stream-take-while pred s)
  (let loop ((s s) (a '()))
    (if (or (empty? s) (not (pred (stream-car s))))
        (reverse! a)
      (loop (stream-cdr s) (cons (stream-car s) a)))))

;; 述語 pred が真を返す要素を取り除く
(define (stream-drop-while pred s)
  (if (or (empty? s) (not (pred (stream-car s))))
      s
    (stream-drop-while pred (stream-cdr s))))

;; 遅延ストリームの併合
(define (stream-merge s1 s2)
  (cond ((empty? s1) s2)
        ((empty? s2) s1)
        (else
         (if (&lt;= (stream-car s1) (stream-car s2))
             (stream-cons (stream-car s1) (stream-merge (stream-cdr s1) s2))
           (stream-cons (stream-car s2) (stream-merge s1 (stream-cdr s2)))))))

;;
;; 集合演算
;;

;; 和集合
(define (stream-union s1 s2)
  (cond ((empty? s1) s2)
        ((empty? s2) s1)
        (else
         (cond ((&lt; (stream-car s1) (stream-car s2))
                  (stream-cons (stream-car s1)
                               (stream-union (stream-cdr s1) s2)))
                 ((&gt; (stream-car s1) (stream-car s2))
                  (stream-cons (stream-car s2)
                               (stream-union s1 (stream-cdr s2))))
                 (else
                  (stream-cons (stream-car s1)
                               (stream-union (stream-cdr s1) (stream-cdr s2))))))))

;; 積集合
(define (stream-intersect s1 s2)
  (cond ((or (empty? s1) (empty? s2)) nil)
        ((= (stream-car s1) (stream-car s2))
         (stream-cons (stream-car s1)
                      (stream-intersect (stream-cdr s1) (stream-cdr s2))))
        ((&lt; (stream-car s1) (stream-car s2))
         (stream-intersect (stream-cdr s1) s2))
        (else
         (stream-intersect s1 (stream-cdr s2)))))

;;
;; 素数の生成
;;
(define (sieve s)
  (stream-cons (stream-car s)
               (sieve (stream-filter
                        (lambda (x) (not (zero? (modulo x (stream-car s)))))
                        (stream-cdr s)))))

;; 別解
(define primes (stream-cons 2 (stream-cons 3 (stream-cons 5 (primes-from 7)))))

(define (primes-from n)
  (if (prime? n)
      (stream-cons n (primes-from (+ n 2)))
    (primes-from (+ n 2))))

(define (prime? n)
  (every (lambda (p) (not (zero? (modulo n p))))
         (stream-take-while (lambda (p) (&lt;= (* p p) n)) primes)))

;;
;; 順列の生成
;;
(define (make-perm n s)
  (if (zero? n)
      (stream-cons '() nil)
    (stream-flatmap
      (lambda (x)
        (stream-map (lambda (y) (cons x y))
                    (make-perm
                      (- n 1)
                      (stream-filter (lambda (z) (not (eqv? x z))) s))))
      s)))

;;
;; ８クイーンの解法 (遅延ストリーム版)
;;

;; 衝突のチェック
(define (attack x xs)
  (define (attack-sub x n ys)
    (cond ((null? ys) #t)
           ((or (= (+ (car ys) n) x)
                (= (- (car ys) n) x))
             #f)
          (else
           (attack-sub x (+ n 1) (cdr ys)))))
  (attack-sub x 1 xs))

;; N Queen の解法
(define (queen s)
  (if (empty? s)
      (stream-cons '() nil)
    (stream-filter
      (lambda (ls)
        (if (null? ls)
            #t
          (attack (car ls) (cdr ls))))
      (stream-flatmap
        (lambda (x)
          (stream-map (lambda (y) (cons x y))
                      (queen (stream-filter (lambda (z) (not (eqv? x z))) s))))
      s))))

;;
;; 木の巡回
;;
(define (for-each-tree fn ls)
  (cond ((null? ls) '())
        ((not (pair? ls)) (fn ls))
        (else
         (for-each-tree fn (car ls))
         (for-each-tree fn (cdr ls)))))

;; CPS 版
(define (for-each-tree-cps fn ls cont)
  (cond ((null? ls) (cont))
        ((not (pair? ls))
         (fn ls)
         (cont))
        (else
         (for-each-tree-cps
           fn
           (car ls)
           (lambda () (for-each-tree-cps fn (cdr ls) (lambda () (cont))))))))

;; 木の巡回 (遅延ストリーム版)
(define (stream-of-tree ls cont)
  (cond ((null? ls) (cont))
        ((not (pair? ls))
         (stream-cons ls (cont)))
        (else
         (stream-of-tree
           (car ls)
           (lambda () (stream-of-tree (cdr ls) (lambda () (cont))))))))

;; ツリーマッチング
(define (same-fringe-p tree1 tree2)
  (define (iter s1 s2)
    (cond ((and (empty? s1) (empty? s2)) #t)
          ((or (empty? s1) (empty? s2)) #f)
          ((eqv? (stream-car s1) (stream-car s2))
           (iter (stream-cdr s1) (stream-cdr s2)))
          (else #f)))
  (iter (stream-of-tree tree1 (lambda () nil))
        (stream-of-tree tree2 (lambda () nil))))
</pre>
</section>
<hr>
<div align="right">
初版 2009 年 6 月 14 日<br>
改訂 2017 年 2 月 5 日
</div>
<hr>
<div class="ce">
<b>Copyright (C) 2009-2017 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcscm23.html">PrevPage</a> | <a href="scheme.html">Scheme</a> | <a href="abcscm24a.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>