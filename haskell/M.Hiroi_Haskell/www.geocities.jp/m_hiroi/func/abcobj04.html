<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scheme プログラミング入門 / オブジェクト指向編</title>
  <meta name="description" content="Lisp,Scheme,オブジェクト指向,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881786</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Scheme プログラミング入門</h2>
<h2>オブジェクト指向編</h2>
<div class="small">
[ <a href="abcobj03.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj05.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>継承 (2)</h3>
<p> 今回は継承の簡単な例題として、前々回作成した双方向リスト &lt;dlist&gt; を継承して、格納する要素数を制限する双方向リスト &lt;fixed-dlist&gt; というクラスを作ってみましょう。そのあとで基本的なデータ構造である「スタック (stack) 」、「キュー (queue) 」、「ディーキュー (deque) 」を作成します。
</p>

<h4>●制限付き双方向リスト</h4>
<p> 制限付き双方向リストクラス &lt;fixed-dist&gt; は指定した上限値までしか要素を格納できません。&lt;dlist&gt; で要素を追加するメソッドは dlist-insert! で、削除するメソッドは dlist-delete! です。この 2 つのメソッドをオーバーライドすることで、&lt;fixed-dlist&gt; の機能を実現することができます。リスト 1 を見てください。
</p>

<pre class="list">
リスト 1 : 制限付き双方向リスト

; クラス定義
(define-class &lt;fixed-dlist&gt; (&lt;dlist&gt;)
  ((limit :accessor dlist-limit :init-value 8 :init-keyword :limit)
   (size  :accessor dlist-size  :init-value 0 :init-keyword :size)))

; 挿入
(define-method dlist-insert! ((d &lt;fixed-dlist&gt;) (n &lt;integer&gt;) value)
  (if (&lt; (dlist-size d) (dlist-limit d))
      (begin0 (next-method) (inc! (dlist-size d)))
    (error "&lt;fixed-dlist&gt; : size over")))

; 削除
(define-method dlist-delete! ((d &lt;fixed-dlist&gt;) (n &lt;integer&gt;))
  (begin0 (next-method) (dec! (dlist-size d))))
</pre>

<p> クラス &lt;fixed-dlist&gt; は &lt;dlist&gt; を継承するので、クラス名の後のカッコで &lt;dlist&gt; を指定します。スロット limit は要素数の上限値を表し、スロット size は双方向リストに格納されている要素数を表します。なお、make で &lt;fixed-dlist&gt; のインスタンスを生成するとき、スーパークラス &lt;dlist&gt; のスロットもきちんと初期化されます。
</p>

<p> dlist-insert! は limit と size を比較して、size が limit よりも小さい場合はデータを挿入します。next-method でスーパークラスの dlist-insert! を呼び出して、size の値を +1 します。dlist-delete! の場合、スーパークラスの dlist-delete! を呼び出してから size の値を -1 します。
</p>
<p> inc! と dec! は値を +1, -1 するマクロで、set! と同様に汎変数を使うことができます。
</p>
<pre class="item">
inc! (アクセス関数 引数 ...) [value]
dec! (アクセス関数 引数 ...) [value]
</pre>
<p> inc! と dec! は value を指定すると値を +value, -value します。value を省略すると値を +1, -1 します。value は評価されることに注意してください。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (define a '(1 2 3 4 5))
a
gosh&gt; (inc! (car a))
#&lt;undef&gt;
gosh> a
(2 2 3 4 5)
gosh&gt; (inc! (cadr a) (+ 1 2 3))
#&lt;undef&gt;
gosh&gt; a
(2 8 3 4 5)
</pre>
<p> このほかに、dlist-length と dlist-clear をオーバーライドし、dlist-full? と list-&gt;fixed-dlist を新しく作ります。
</p>
<pre class="list">
リスト 2 : 制限付き双方向リスト (2)

; サイズ
(define-method dlist-length ((d &lt;fixed-dlist&gt;))
  (dlist-size d))

; クリア
(define-method dlist-clear ((d &lt;fixed-dlist&gt;))
  (next-method)
  (set! (dlist-size d) 0))

; 満杯か？
(define-method dlist-full? ((d &lt;fixed-dlist&gt;))
  (= (dlist-size d) (dlist-limit d)))

; 変換
(define-method list-&gt;fixed-dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;fixed-dlist&gt; :limit (length xs))))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))
</pre>
<p> 要素の個数を求める dlist-length はスロット size の値を返すだけです。dlist-clear は &lt;dlist&gt; のメソッドを呼び出してから、size の値を 0 にします。dlist-full? は双方向リストが満杯ならば #t を返します。list-&gt;fixed-dlist はリスト xs を制限付き双方向リストに変換します。
</p>

<p> 簡単な実行例を示しましょう。
</p>

<pre>
gosh&gt; (define a (make &lt;fixed-dlist&gt; :limit 5))
a
gosh&gt; a
#&lt;&lt;fixed-dlist&gt; 0pbe1278&gt;
gosh&gt; (dlist-empty? a)
#t
gosh&gt; (dotimes (x 5) (dlist-insert! a -1 x))
#t
gosh&gt; (dlist-empty? a)
#f
gosh&gt; (dlist-full? a)
#t
gosh&gt; (dlist-insert! a -1 10)
*** ERROR: &lt;fixed-dlist&gt; : size over

gosh&gt; (dlist-&gt;list a)
(0 1 2 3 4)
gosh&gt; (dotimes (x 5) (format #t "~D " (dlist-delete! a 0)))
0 1 2 3 4 #t
gosh&gt; (dlist-empty? a)
#t
gosh&gt; (dlist-full? a)
#f
</pre>

<p> このように &lt;dlist&gt; を継承することで、&lt;fixed-dlist&gt; を簡単にプログラムすることができます。
</p>

<h4>●継承は is-a 関係を表す</h4>
<p> 今まで説明したように、オブジェクトは関数とデータをひとつにまとめたものです。オブジェクト指向プログラミングはこのオブジェクトを部品として扱います。実際には、クラス単位でプログラムを作るので、クラス間の関係がとても重要になります。ここで、クラス間の関係 is-a と has-a を簡単に説明します。
</p>

<p> is-a 関係は X is a Y. の略で、「X は Y の一種である」という意味になります。X がサブクラスで Y をスーパークラスと考えると、is-a 関係は継承で表すことができます。たとえば、&lt;fixed-dlist&gt; は格納する要素数に制限がありますが双方向リストの一種であることは明らかです。&lt;fixed-dlist&gt; クラスは &lt;dlist&gt; クラスを継承することで簡単に実装できましたが、それは双方向リストとの間に is-a 関係があるからです。
</p>

<p> has-a 関係は X has a Y. の略で、「X は Y を持っている」という意味です。たとえば、車にはエンジンやタイヤがありますが、車とエンジンやタイヤに成り立つ関係が has-a です。車はエンジンやタイヤがないと走ることができません。このように、has-a 関係は「X が成立するのに欠かせない要素が Y である」という関係を表しています。
</p>

<p> has-a 関係のほかに、is-implemented-using という関係があります。これは X is implemented using Y. の略で、「X は Y を使って実装される」という意味です。たとえばスタックの場合、配列でもリストでも実装することが可能です。つまり、Y の種類によらず X を実現できる関係が is-implemented-using 関係なのです。
</p>

<p> 一般に、has-a 関係や is-implemented-using 関係は、クラス X のスロット (インスタンス変数) にクラス Y のインスタンス（オブジェクト）を格納することで表します。これを「X は Y を包含している」といいます。そして、これらの関係を表すのに継承を使ってはいけない、ということに注意してください。
</p>

<p> たとえば、双方向リストを継承してスタックを作ることを考えてみましょう。PUSH は双方向リストの先頭にデータを追加することで、POP は双方向リストの先頭からデータを取り出すことで簡単に実現できます。しかし、双方向リストを継承すると、ほかの操作も可能になります。スタックの途中にデータを追加したり、途中からデータを取り出すなど、スタックを破壊する危険な操作が可能になってしまいます。
</p>

<p> また、クラスの関係を考えた場合、スタックと双方向リストには is-a 関係は成り立ちません。ところが、継承を使うとデータ型も引き継がれるため、プログラムの上でもスタックは双方向リストの一種になってしまいます。継承は強力な機能ですが万能ではありません。クラス間の関係を考えて、適切に使うことが大切です。 
</p>

<h4>●スタックの実装</h4>
<p> それでは、実際に双方向リストを使ってスタックを実装してみましょう。クラス名は &lt;stack&gt; とし、表 1 に示すメソッドを定義します。プログラムはリスト 3 のようになります。
</p>
<table border=1>
<caption>表 1 : スタックのメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>stack-push! s x </td><td>スタック s にデータを追加する</td></tr>
  <tr><td>stack-pop! s    </td><td>スタック s からデータを取り出す</td></tr>
  <tr><td>stack-length s  </td><td>スタック s に格納されている要素数を返す</td></tr>
  <tr><td>stack-empty? s</td><td>スタック s が空ならば #t を返す</td></tr>
</tbody>
</table>
<pre class="list">
リスト 3 : スタック

; クラス定義
(define-class &lt;stack&gt; ()
  ((top :accessor stack-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method stack-push! ((s &lt;stack&gt;) x)
  (dlist-insert! (stack-top s) 0 x))

; 取り出し
(define-method stack-pop! ((s &lt;stack&gt;))
  (dlist-delete! (stack-top s) 0))

; 空か？
(define-method stack-empty? ((s &lt;stack&gt;))
  (dlist-empty? (stack-top s)))

; サイズ
(define-method stack-length ((s &lt;stack&gt;))
  (dlist-length (stack-top s)))
</pre>
<p> &lt;stack&gt; のスロット top に &lt;dlist&gt; のインスタンスをセットします。&lt;stack&gt; の操作は、このインスタンスに &lt;dlist&gt; のメソッドを適用することで実現します。
</p>
<p> メソッド stack-push! はスタックにデータ x を追加します。これは双方向リストの先頭に x を追加すればいいので、(dlist-insert! (stack-top s) 0 x) を呼び出すだけです。メソッド stack-pop! は双方向リストの先頭の要素を削除してそれを返せばよいので、(dlist-delete! (stack-top s) 0) を呼び出すだけです。メソッド stack-empty? と stack-length は dlist-empty? と dlist-length を呼び出すだけです。
</p>

<p> それでは実行してみましょう。
</p>

<pre>
gosh&gt; (define a (make &lt;stack&gt;))
a
gosh&gt; a
#&lt;&lt;stack&gt; 0pbea098&gt;
gosh&gt; (dotimes (x 5) (stack-push! a x))
#t
gosh&gt; (stack-length a)
5
gosh&gt; (stack-empty? a)
#f
gosh&gt; (dotimes (x 5) (format #t "~D " (stack-pop! a)))
4 3 2 1 0 #t
gosh&gt; (stack-length a)
0
gosh&gt; (stack-empty? a)
#t
</pre>

<p> スタックに 0 から 4 まで stack-push! で格納し stack-pop! でデータを取り出すと 4, 3, 2, 1, 0 になります。このように、スタックは後から入れたデータが先に取り出されます。
</p>

<h4>●キューの実装</h4>
<p> 次は、双方向リスト &lt;dlist&gt; を使ってキューを作ってみましょう。定義するメソッドを表 2 に、プログラムをリスト 4 に示します。
</p>

<table border=1>
<caption>表 2 : キューのメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>enqueue! q x</td><td>キュー q にデータを追加する</td></tr>
  <tr><td>dequeue! q </td><td>キュー q からデータを取り出す</td></tr>
  <tr><td>queue-length q </td><td>キュー q に格納されている要素数を返す</td></tr>
  <tr><td>queue-empty? q </td><td>キュー q が空ならば #t を返す</td></tr>
</tbody>
</table>
<pre class="list">
リスト 4 : キュー

(define-class &lt;queue&gt; ()
  ((top :accessor queue-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method enqueue! ((q &lt;queue&gt;) x)
  (dlist-insert! (queue-top q) -1 x))

; 取り出し
(define-method dequeue! ((q &lt;queue&gt;))
  (dlist-delete! (queue-top q) 0))

; 空か？
(define-method queue-empty? ((q &lt;queue&gt;))
  (dlist-empty? (queue-top q)))

; サイズ
(define-method queue-length ((q &lt;queue&gt;))
  (dlist-length (queue-top q)))
</pre>
<p> &lt;queue&gt; のスロット top に &lt;dlist&gt; のインスタンスをセットします。&lt;queue&gt; の操作は、このインスタンスに &lt;dlist&gt; のメソッドを適用することで実現します。
</p>
<p> メソッド enqueue! はキューにデータ x を追加します。これは双方向リストの最後尾に x を追加すればいいので、(dlist-insert! (queue-top s) -1 x) を呼び出すだけです。メソッド dequeue! は双方向リストの先頭の要素を削除してそれを返せばよいので、(dlist-delete! (queue-top s) 0) を呼び出すだけです。メソッド queue-empty? と queue-length は dlist-empty? と dlist-length を呼び出すだけです。
</p>

<p> 簡単な実行例を示します。
</p>

<pre>
gosh&gt; (define a (make &lt;queue&gt;))
a
gosh&gt; a
#&lt;&lt;queue&gt; 0pbf6f98&gt;
gosh&gt; (dotimes (x 5) (enqueue! a x))
#t
gosh&gt; (queue-empty? a)
#f
gosh&gt; (queue-length a)
5
gosh&gt; (dotimes (x 5) (format #t "~D " (dequeue! a)))
0 1 2 3 4 #t
gosh&gt; (queue-empty? a)
#t
gosh&gt; (queue-length a)
0
</pre>

<p> キューに 0 から 4 まで enqueue! で格納して、dequeue! でデータを取り出すと 0, 1, 2, 3, 4 になります。スタックとは逆に、キューはデータを入れた順番にデータが取り出されます。
</p>

<h4>●ディーキューの実装</h4>
<p> 最後に、「ディーキュー : deque (double ended queue) 」というデータ構造を双方向リストを使って実装しましょう。ディーキューは「両端キュー」のことで、「デック」と呼ばれることもあります。キューの場合、データの追加は最後尾に、データの取り出しは先頭に対してのみ行えます。これに対しディーキューは、先頭および最後尾のどちらでもデータの追加と取り出しが行えるデータ構造です。ディーキューは双方向リストを使うと簡単に実現できます。
</p>

<p> 最初に作成するメソッドを表 3 に示します。データを追加するメソッドには push を、取り出すメソッドには pop を付けました。
</p>

<table border=1>
<caption>表 3 : ディーキューのメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>push-front! d x</td><td>ディーキュー d の先頭にデータを追加する</td></tr>
  <tr><td>push-back! d x</td><td>ディーキュー d の末尾にデータを追加する</td></tr>
  <tr><td>pop-front! d </td><td>ディーキュー d の先頭からデータを取り出す</td></tr>
  <tr><td>pop-back! d </td><td>ディーキュー d の末尾からデータを取り出す</td></tr>
  <tr><td>peek-front d </td><td>ディーキュー d の末尾にあるデータを求める</td></tr>
  <tr><td>peek-back d </td><td>ディーキュー d の先頭にあるデータを求める</td></tr>
  <tr><td>deque-length d </td><td>ディーキュー d に格納されている要素数を返す</td></tr>
  <tr><td>deque-empty? d </td><td>ディーキュー d が空ならば #t を返す</td></tr>
</tbody>
</table>
<p> プログラムはリスト 5 のようになります。
</p>
<pre class="list">
リスト 5 : ディーキュー

; クラス定義
(define-class &lt;deque&gt; ()
  ((top :accessor deque-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method push-front! ((d &lt;deque&gt;) x)
  (dlist-insert! (deque-top d) 0 x))

(define-method push-back! ((d &lt;deque&gt;) x)
  (dlist-insert! (deque-top d) -1 x))

; 取り出し
(define-method pop-front! ((d &lt;deque&gt;))
  (dlist-delete! (deque-top d) 0))

(define-method pop-back! ((d &lt;deque&gt;))
  (dlist-delete! (deque-top d) -1))

; 参照
(define-method peek-front ((d &lt;deque&gt;))
  (dlist-ref (deque-top d) 0))

(define-method peek-back ((d &lt;deque&gt;))
  (dlist-ref (deque-top d) -1))

; 空か
(define-method deque-empty? ((d &lt;deque&gt;))
  (dlist-empty? (deque-top d)))

; サイズ
(define-method deque-length ((d &lt;deque&gt;))
  (dlist-length (deque-top d)))
</pre>
<p> スタックとキューのプログラムとあまり変わりがないので、詳しい説明は不要でしょう。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
gosh&gt; (define a (make &lt;deque&gt;))
a
gosh&gt; a
#&lt;&lt;deque&gt; 0pbf8a40&gt;
gosh&gt; (dotimes (x 5) (push-back! a x))
#t
gosh&gt; (peek-front a)
0
gosh&gt; (peek-back a)
4
gosh&gt; (pop-front! a)
0
gosh&gt; (peek-front a)
1
gosh&gt; (pop-back! a)
4
gosh&gt; (peek-back a)
3
gosh&gt; (deque-length a)
3
gosh&gt; (dotimes (x 3) (format #t "~D " (pop-front! a)))
1 2 3 #t
gosh&gt; (deque-empty? a)
#t
</pre>
<hr>
<h4>●プログラムリスト</h4>
<pre class="list">
;
; dlist.scm : 双方向リスト
;
;             Copyright (C) 2010 Makoto Hiroi
;

; セルの定義
(define-class &lt;cell&gt; ()
  ((item :accessor cell-item :init-value #f :init-keyword :item)
   (prev :accessor cell-prev :init-value #f :init-keyword :prev)
   (next :accessor cell-next :init-value #f :init-keyword :next)))

; 空リストを作る
(define (make-empty)
  (let ((cp (make &lt;cell&gt;)))
    (set! (cell-prev cp) cp)
    (set! (cell-next cp) cp)
    cp))

; 双方向リストの定義
(define-class &lt;dlist&gt; ()
  ((top :accessor dlist-top :init-form (make-empty))))

; n 番目のセルを返す (作業用関数)
(define (cell-nth d n next)
  (let loop ((i -1) (cp (dlist-top d)))
    (cond ((and (&lt;= 0 i) (eq? (dlist-top d) cp))
           (error "cell-nth --- oops!"))
          ((= n i) cp)
          (else
           (loop (+ i 1) (next cp))))))

; 参照
(define-method dlist-ref ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (cell-item
    (if (negative? n)
        (cell-nth d (abs (+ n 1)) cell-prev)       
      (cell-nth d n cell-next))))

; 書き換え
(define-method dlist-set! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (set! (cell-item (if (negative? n)
                       (cell-nth d (abs (+ n 1)) cell-prev)
                     (cell-nth d n cell-next)))
        value))

; 挿入
(define-method dlist-insert! ((d &lt;dlist&gt;) (n &lt;integer&gt;) value)
  (define (cell-insert! n next prev)
    (let* ((p (cell-nth d (- n 1) next))
           (q (next p))
           (cp (make &lt;cell&gt; :item value)))
    (set! (next cp) q)
    (set! (prev cp) p)
    (set! (prev q) cp)
    (set! (next p) cp)))
  ;
  (if (negative? n)
      (cell-insert! (abs (+ n 1)) cell-prev cell-next)
    (cell-insert! n cell-next cell-prev)))

; 削除
(define-method dlist-delete! ((d &lt;dlist&gt;) (n &lt;integer&gt;))
  (define (cell-delete! n next prev)
    (let* ((cp (cell-nth d n next))
           (p (prev cp))
           (q (next cp)))
      (set! (next p) q)
      (set! (prev q) p)
      (cell-item cp)))
  ;
  (if (negative? n)
      (cell-delete! (abs (+ n 1)) cell-prev cell-next)
    (cell-delete! n cell-next cell-prev)))

; 畳み込み
(define-method dlist-fold ((d &lt;dlist&gt;) func init . args)
  (let ((next (if (get-keyword :from-end args #f) cell-prev cell-next)))
    (let loop ((cp (next (dlist-top d))) (a init))
      (if (eq? cp (dlist-top d))
          a
        (loop (next cp)
              (if (eq? next cell-prev)
                  (func (cell-item cp) a)
                (func a (cell-item cp))))))))

; サイズ
(define-method dlist-length ((d &lt;dlist&gt;))
  (dlist-fold d (lambda (x y) (+ x 1)) 0))

; クリア
(define-method dlist-clear ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (set! (cell-next cp) cp)
    (set! (cell-prev cp) cp)))

; 空リストか？
(define-method dlist-empty? ((d &lt;dlist&gt;))
  (let ((cp (dlist-top d)))
    (eq? cp (cell-next cp))))

; 変換
(define-method list-&gt;dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;dlist&gt;)))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))

;
(define-method dlist-&gt;list ((d &lt;dlist&gt;))
  (dlist-fold d
              (lambda (x y) (cons x y))
              '()
              :from-end #t))


; 巡回
(define-method dlist-for-each ((d &lt;dlist&gt;) func . args)
  (if (get-keyword :from-end args #f)
      (dlist-fold d (lambda (x y) (func x)) #f :from-end #t)
    (dlist-fold d (lambda (x y) (func y)) #f)))


;;; 制限付き双方向リスト

(define-class &lt;fixed-dlist&gt; (&lt;dlist&gt;)
  ((limit :accessor dlist-limit :init-value 8 :init-keyword :limit)
   (size  :accessor dlist-size  :init-value 0 :init-keyword :size)))

; 挿入
(define-method dlist-insert! ((d &lt;fixed-dlist&gt;) (n &lt;integer&gt;) value)
  (if (&lt; (dlist-size d) (dlist-limit d))
      (begin0 (next-method)
              (set! (dlist-size d) (+ (dlist-size d) 1)))
    (error "&lt;fixed-dlist&gt; : size over")))

; 削除
(define-method dlist-delete! ((d &lt;fixed-dlist&gt;) (n &lt;integer&gt;))
  (begin0 (next-method)
          (set! (dlist-size d) (- (dlist-size d) 1))))

; サイズ
(define-method dlist-length ((d &lt;fixed-dlist&gt;))
  (dlist-size d))

; クリア
(define-method dlist-clear ((d &lt;fixed-dlist&gt;))
  (next-method)
  (set! (dlist-size d) 0))

; 変換
(define-method list-&gt;fixed-dlist ((xs &lt;list&gt;))
  (let ((d (make &lt;fixed-dlist&gt; :limit (length xs))))
    (for-each
      (lambda (x) (dlist-insert! d -1 x))
      xs)
    d))

; 満杯か？
(define-method dlist-full? ((d &lt;fixed-dlist&gt;))
  (= (dlist-size d) (dlist-limit d)))


;;; スタック

(define-class &lt;stack&gt; ()
  ((top :accessor stack-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method stack-push! ((s &lt;stack&gt;) x)
  (dlist-insert! (stack-top s) 0 x))

; 取り出し
(define-method stack-pop! ((s &lt;stack&gt;))
  (dlist-delete! (stack-top s) 0))

; 空か？
(define-method stack-empty? ((s &lt;stack&gt;))
  (dlist-empty? (stack-top s)))

; サイズ
(define-method stack-length ((s &lt;stack&gt;))
  (dlist-length (stack-top s)))


;;; キュー

(define-class &lt;queue&gt; ()
  ((top :accessor queue-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method enqueue! ((q &lt;queue&gt;) x)
  (dlist-insert! (queue-top q) -1 x))

; 取り出し
(define-method dequeue! ((q &lt;queue&gt;))
  (dlist-delete! (queue-top q) 0))

; 空か？
(define-method queue-empty? ((q &lt;queue&gt;))
  (dlist-empty? (queue-top q)))

; サイズ
(define-method queue-length ((q &lt;queue&gt;))
  (dlist-length (queue-top q)))


;;; ディーキュー

(define-class &lt;deque&gt; ()
  ((top :accessor deque-top :init-form (make &lt;dlist&gt;) :init-keyword :top)))

; 追加
(define-method push-front! ((d &lt;deque&gt;) x)
  (dlist-insert! (deque-top d) 0 x))

(define-method push-back! ((d &lt;deque&gt;) x)
  (dlist-insert! (deque-top d) -1 x))

; 取り出し
(define-method pop-front! ((d &lt;deque&gt;))
  (dlist-delete! (deque-top d) 0))

(define-method pop-back! ((d &lt;deque&gt;))
  (dlist-delete! (deque-top d) -1))

; 参照
(define-method peek-front ((d &lt;deque&gt;))
  (dlist-ref (deque-top d) 0))

(define-method peek-back ((d &lt;deque&gt;))
  (dlist-ref (deque-top d) -1))

; 空か？
(define-method deque-empty? ((d &lt;deque&gt;))
  (dlist-empty? (deque-top d)))

; サイズ
(define-method deque-length ((d &lt;deque&gt;))
  (dlist-length (deque-top d)))
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2010 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcobj03.html">PrevPage</a> | <a href="scheme.html#abcobj">Scheme</a> | <a href="abcobj05.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>