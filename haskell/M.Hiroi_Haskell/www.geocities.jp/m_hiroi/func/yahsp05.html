<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Haskell Problems</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881792</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>Yet Another Haskell Problems</h2>
<div class="small">
[ <a href="yahsp04.html">PrevPage</a> | <a href="haskell.html#yahsp">Haskell</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h4>●問題81</h4>
<p> Word32 (無符号 32 bit 整数) とリストを使ってシンプルな無符号多倍長整数 (Bignum) を実装します。基数を 65536 とし、リストの先頭が下位の桁、末尾を上位の桁とします。簡単な例を示します。
</p>
<pre class="item">
0 =&gt; [0]
1 =&gt; [1]
65535 =&gt; [0xFFFF]
65536 =&gt; [0,1]
4294967295 =&gt; [0xFFFF,0xFFFF]
4294967296 =&gt; [0,0,1]
</pre>
<p> 整数 (Integer) を多倍長整数に変換する関数 toBignum n を定義してください。
</p>
<pre class="item">
type Bignum = [Word32]
toBignum :: Integer -&gt; Bignum
</pre>
<pre>
*Main&gt; toBignum 0
[0]
*Main&gt; toBignum 1
[1]
*Main&gt; toBignum 65535
[65535]
*Main&gt; toBignum 65536
[0,1]
*Main&gt; toBignum 0xffffffff
[65535,65535]
*Main&gt; toBignum 0x100000000
[0,0,1]
</pre>
<p><a href="yahsp05.html#ans81">解答</a>
</p>

<h4>●問題82</h4>
<p> 多倍長整数を整数 (Integer) に変換する関数 bignumToInteger xs を定義してください。
</p>
<pre class="item">
bignumToInteger :: Bignum -&gt; Integer
</pre>
<pre>
*Main&gt; bignumToInteger [0]
0
*Main&gt; bignumToInteger [1]
1
*Main&gt; bignumToInteger [65535]
65535
*Main&gt; bignumToInteger [0,1]
65536
*Main&gt; bignumToInteger [0,0,1]
4294967296
</pre>
<p><a href="yahsp05.html#ans82">解答</a>
</p>

<h4>●問題83</h4>
<p> 2 つの多倍長整数 xs, ys の論理積を求める関数 bignumAND xs ys を定義してください。
</p>
<pre class="item">
bignumAND :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumAND [1,1,1] [0]
[0]
*Main&gt; bignumAND [1,1,1] [1]
[1]
*Main&gt; bignumAND [1,2,1] [3,3,3]
[1,2,1]
*Main&gt; bignumAND [1,2,1] [3,3,2]
[1,2]
*Main&gt; bignumAND [1,2,1] [3,0,2]
[1]
</pre>
<p><a href="yahsp05.html#ans83">解答</a>
</p>

<h4>●問題84</h4>
<p> 2 つの多倍長整数 xs, ys の論理和を求める関数 bignumOR xs ys を定義してください。
</p>
<pre class="item">
bignumOR :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumOR [1,1,1] [0]
[1,1,1]
*Main&gt; bignumOR [1,1,1] [2,2,2]
[3,3,3]
*Main&gt; bignumOR [1,1,1] [2,2,2,2,2,2]
[3,3,3,2,2,2]
</pre>
<p><a href="yahsp05.html#ans84">解答</a>
</p>

<h4>●問題85</h4>
<p> 2 つの多倍長整数 xs, ys の排他的論理和を求める関数 bignumXOR xs ys を定義してください。
</p>
<pre class="item">
bignumXOR :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumXOR [0,1,2,3] [0]
[0,1,2,3]
*Main&gt; bignumXOR [0,1,2,3] [1]
[1,1,2,3]
*Main&gt; bignumXOR [0,1,2,3] [1,2,3,4]
[1,3,1,7]
*Main&gt; bignumXOR [0,1,2,3] [0,1,2,3]
[0]
</pre>
<p><a href="yahsp05.html#ans85">解答</a>
</p>

<h4>●問題86</h4>
<p> 多倍長整数 xs を左へ n bit シフトする関数 bignumShiftLeft xs n を定義してください。
</p>
<pre class="item">
bignumShiftLeft :: Bignum -&gt; Int -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumShiftLeft [1] 0
[1]
*Main&gt; bignumShiftLeft [1] 1
[2]
*Main&gt; bignumShiftLeft [1,1,1,1] 15
[32768,32768,32768,32768]
*Main&gt; bignumShiftLeft [1,1,1,1] 16
[0,1,1,1,1]
*Main&gt; bignumShiftLeft [1,1,1,1] 32
[0,0,1,1,1,1]
</pre>
<p><a href="yahsp05.html#ans86">解答</a>
</p>

<h4>●問題87</h4>
<p> 多倍長整数 xs を右へ n bit シフトする関数 bignumShiftRight xs n を定義してください。
</p>
<pre class="item">
bignumShiftRight :: Bignum -&gt; Int -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumShiftRight [0,1] 0
[0,1]
*Main&gt; bignumShiftRight [0,1] 1
[32768]
*Main&gt; bignumShiftRight [0,1] 15
[2]
*Main&gt; bignumShiftRight [0,1] 16
[1]
*Main&gt; bignumShiftRight [0,1] 17
[0]
*Main&gt; bignumShiftRight [0,0,1] 32
[1]
</pre>
<p><a href="yahsp05.html#ans87">解答</a>
</p>

<h4>●問題88</h4>
<p> 多倍長整数を比較する関数 bignumEQ, bignumNE, bignumGT, bignumGE, bignumLT, bignumLE を定義してください。
</p>
<pre class="item">
bignumEQ :: Bignum -&gt; Bignum -&gt; Bool  -- ==
bignumNE :: Bignum -&gt; Bignum -&gt; Bool  -- /=
bignumGT :: Bignum -&gt; Bignum -&gt; Bool  -- &gt;
bignumGE :: Bignum -&gt; Bignum -&gt; Bool  -- &gt;=
bignumLT :: Bignum -&gt; Bignum -&gt; Bool  -- &lt;
bignumLE :: Bignum -&gt; Bignum -&gt; Bool  -- &lt;=
</pre>
<pre>
*Main&gt; bignumEQ [1,1,1] [1,1,1]
True
*Main&gt; bignumEQ [1,1,1] [1,0,1]
False
*Main&gt; bignumNE [1,1,1] [1,1,1]
False
*Main&gt; bignumNE [1,1,1] [0,1,1]
True
*Main&gt; bignumGT [0,0,1] [0,1]
True
*Main&gt; bignumGT [0,0,1] [0,0,2]
False
*Main&gt; bignumGE [0,0,1] [0,0,1]
True
*Main&gt; bignumGE [0,0,2] [0,0,1]
True
*Main&gt; bignumGE [0,0,1] [0,0,2]
False
*Main&gt; bignumLT [0,0,2] [0,0,1]
False
*Main&gt; bignumLT [0,2] [0,0,1]
True
*Main&gt; bignumLE [0,0,1] [0,0,1]
True
*Main&gt; bignumLE [0,0,1] [0,0,2]
True
*Main&gt; bignumLE [0,0,1] [0,2]
False
</pre>
<p><a href="yahsp05.html#ans88">解答</a>
</p>

<h4>●問題89</h4>
<p> 多倍長整数 xs と基数未満の整数 n を加算する関数 bignumAddInt xs n を定義してください。
</p>
<pre class="item">
bignumAddInt :: Bignum -&gt; Word32 -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumAddInt [65535,65535] 0
[65535,65535]
*Main&gt; bignumAddInt [65535,65535] 1
[0,0,1]
*Main&gt; bignumAddInt [65535,65535] 65535
[65534,0,1]
</pre>
<p><a href="yahsp05.html#ans89">解答</a>
</p>

<h4>●問題90</h4>
<p> 多倍長整数 xs. ys を加算する関数 bignumAdd xs ys を定義してください。
</p>
<pre class="item">
bignumAdd :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumAdd [0,65535] [65535,1]
[65535,0,1]
*Main&gt; bignumAdd [65535,65535] [65535,65535]
[65534,65535,1]
*Main&gt; bignumAdd [65535,65535] [1,0,1]
[0,0,2]
</pre>
<p><a href="yahsp05.html#ans90">解答</a>
</p>

<h4>●問題91</h4>
<p> 多倍長整数 xs と基数未満の整数 n を減算する関数 bignumSubInt xs n を定義してください。
</p>
<pre class="item">
bignumSubInt :: Bignum -&gt; Word32 -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumSubInt [1] 0
[1]
*Main&gt; bignumSubInt [1] 1
[0]
*Main&gt; bignumSubInt [1] 2
[65535*** Exception: bignum: underflow
*Main&gt; bignumSubInt [0,1] 1
[65535]
*Main&gt; bignumSubInt [0,0,0,0,1] 1
[65535,65535,65535,65535]
*Main&gt; bignumSubInt [0,0,0,0,1] 65535
[1,65535,65535,65535]
</pre>
<p><a href="yahsp05.html#ans91">解答</a>
</p>

<h4>●問題92</h4>
<p> 多倍長整数 xs. ys を減算する関数 bignumSub xs ys を定義してください。
</p>
<pre class="item">
bignumSub :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumSub [0,0,1] [65535,65535]
[1]
*Main&gt; bignumSub [0,0,1] [0,0,1]
[0]
*Main&gt; bignumSub [0,0,1] [0,1]
[0,65535]
*Main&gt; bignumSub [0,0,1] [1,0,1]
[65535,65535,65535*** Exception: bignum: underflow
</pre>
<p><a href="yahsp05.html#ans92">解答</a>
</p>

<h4>●問題93</h4>
<p> 多倍長整数 xs と基数未満の整数 n を乗算する関数 bignumMulInt xs n を定義してください。
</p>
<pre class="item">
bignumMulInt :: Bignum -&gt; Word32 -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumMulInt [1,2,3,4,5] 0
[0]
*Main&gt; bignumMulInt [1,2,3,4,5] 1
[1,2,3,4,5]
*Main&gt; bignumMulInt [1,2,3,4,5] 2
[2,4,6,8,10]
*Main&gt; bignumMulInt [65535, 65535] 65535
[1,65535,65534]
</pre>
<p><a href="yahsp05.html#ans93">解答</a>
</p>

<h4>●問題94</h4>
<p> 多倍長整数 xs. ys を乗算する関数 bignumMul xs ys を定義してください。
</p>
<pre class="item">
bignumMul :: Bignum -&gt; Bignum -&gt; Bignum
</pre>
<pre>
*Main&gt; bignumMul [1,1,1] [1,1,1]
[1,2,3,2,1]
*Main&gt; bignumMul [65535,65535,65535] [1,1,1]
[65535,65534,65534,0,1,1]
*Main&gt; bignumMul [65535,65535,65535] [65535,65535,65535]
[1,0,0,65534,65535,65535]
</pre>
<p><a href="yahsp05.html#ans94">解答</a>
</p>

<h4>●問題95</h4>
<p> 多倍長整数 xs と基数未満の整数 n を除算する関数 bignumDivInt xs n を定義してください。返り値は商と剰余をタプルで返すものとします。
</p>
<pre class="item">
bignumDivInt :: Bignum -&gt; Word32 -&gt; (Bignum, Bignum)
</pre>
<pre>
*Main&gt; bignumDivInt [2,4,6,8,10] 1
([2,4,6,8,10],[0])
*Main&gt; bignumDivInt [2,4,6,8,10] 2
([1,2,3,4,5],[0])
*Main&gt; bignumDivInt [2,4,6,8,10] 3
([21846,1,2,21848,3],[0])
*Main&gt; bignumDivInt [2,4,6,8,10] 4
([0,32769,1,32770,2],[2])
*Main&gt; bignumDivInt [2,4,6,8,10] 65535
([28,24,18,10],[30])
*Main&gt; bignumDivInt [2,4,6,8,10] 0
*** Exception: bignum: divide by zero
</pre>
<p><a href="yahsp05.html#ans95">解答</a>
</p>

<h4>●問題96</h4>
<p> 多倍長整数 xs. ys を除算する関数 bignumDiv xs ys を定義してください。返り値は商と剰余をタプルに格納して返すものとします。
</p>
<pre class="item">
bignumDiv :: Bignum -&gt; Bignum -&gt; (Bignum, Bignum)
</pre>
<pre>
*Main&gt; bignumDiv [0,0,0,1] [0,0,0,1]
([1],[0])
*Main&gt; bignumDiv [0,0,0,1] [0,0,1]
([0,1],[0])
*Main&gt; bignumDiv [1,0,0,1] [0,0,1]
([0,1],[1])
*Main&gt; bignumDiv [0,0,0,1] [65535,65535]
([0,1],[0,1])
</pre>
<p><a href="yahsp05.html#ans96">解答</a>
</p>

<h4>●問題97</h4>
<p> 多倍長整数 xs を文字列に変換する関数 bignumToString xs r を定義してください。r は基数を表す整数値 (r &lt;= 16) です。
</p>
<pre class="item">
bignumToString :: Bignum -&gt; Int -> String
</pre>
<pre>
*Main&gt; bignumToString [0,0,0,1] 10
"281474976710656"
*Main&gt; bignumToString [0,0,0,1] 16
"1000000000000"
*Main&gt; bignumToString [65535,65535,65535] 10
"281474976710655"
*Main&gt; bignumToString [65535,65535,65535] 16
"FFFFFFFFFFFF"
</pre>
<p><a href="yahsp05.html#ans97">解答</a>
</p>

<h4>●問題98</h4>
<p> 文字列 str を多倍長整数に変換する関数 stringToBignum str r を定義してください。r は基数を表す整数値 (r &lt;= 16) です。
</p>
<pre class="item">
stringToBignum :: String -&gt; Int -&gt; Bignum
</pre>
<pre>
*Main&gt; stringToBignum "1234567890" 10
[722,18838]
*Main&gt; stringToBignum "FFFFFFFFFFFFFFFF" 16
[65535,65535,65535,65535]
*Main&gt; stringToBignum "1234567890ABCDEF" 16
[52719,37035,22136,4660]
*Main&gt; stringToBignum "12345678901234567890" 10
[2770,60191,43404,43860]
</pre>
<p><a href="yahsp05.html#ans98">解答</a>
</p>

<h4>●問題99</h4>
<p> 多倍長整数の平方根の整数部分を求める関数 bignumSqrt xs を定義してください。
</p>
<pre class="item">
bignumSqrt :: bignum -&gt; bignum
</pre>
<pre>
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 2 * 10^20
14142135623
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 2 * 10^40
141421356237309504880
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 2 * 10^80
14142135623730950488016887242096980785696
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 3 * 10^20
17320508075
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 3 * 10^40
173205080756887729352
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 3 * 10^80
17320508075688772935274463415058723669428
</pre>

<p><a href="yahsp05.html#ans99">解答</a>
</p>
<HR>
<h4 id="ans81">●解答81</h4>
<pre class="list">
リスト : 整数を多倍長整数に変換する

base :: Word32
base = 65536

baseL :: Integer
baseL = 65536

toBignum :: Integer -&gt; Bignum
toBignum x
  | x &lt; 0     = error "toBignum : domain error"
  | x &lt; baseL = [fromIntegral x]
  | otherwise = fromIntegral (x `mod` baseL) : toBignum (x `div` baseL)
</pre>
<p> toBignum は簡単です。x が baseL よりも小さければ x を Wrod32 に変換してからリストに格納して返します。あとは、整数 n を基数 baseL で割り算していき、剰余を toBignum の返り値 (リスト) に追加していくだけです。
</p>

<h4 id="ans82">●解答82</h4>
<pre class="list">
リスト : 多倍長整数を整数に変換する

bignumToInteger :: Bignum -&gt; Integer
bignumToInteger xs =
  foldr (\x a -&gt; a * baseL + fromIntegral x) 0 xs
</pre>

<p> bignumToInteger も簡単です。引数 xs を foldr で末尾から畳み込むだけです。
</p>

<h4 id="ans83">●解答83</h4>
<pre class="list">
リスト : 多倍長整数の論理積

bignumAND :: Bignum -&gt; Bignum -&gt; Bignum
bignumAND xs ys = if null zs then [0] else zs
  where zs = dropWhileEnd (== 0) $ zipWith (.&.) xs ys
</pre>
<p> bignumAND は xs と ys の要素の論理積を zipWith で求め、末尾から連続する 0 を dropWhileEnd で取り除きます。その結果、zs が空リストになったならば [0] を返します。そうでなければ zs をそのまま返します。
</p>

<h4 id="ans84">●解答84</h4>
<pre class="list">
リスト : 多倍長整数の論理和

bignumLogical :: (Word32 -&gt; Word32 -&gt; Word32) -&gt; Bignum -&gt; Bignum -&gt; Bignum
bignumLogical _ []     []     = []
bignumLogical f xs     []     = xs
bignumLogical f []     ys     = ys
bignumLogical f (x:xs) (y:ys) = f x y : bignumLogical f xs ys

bignumOR :: Bignum -&gt; Bignum -&gt; Bignum
bignumOR = bignumLogical (.|.)
</pre>
<p> bignumOR と bignumXOR の処理は関数 bignumLogical で行います。bignumLogical は xs と ys の要素を順番に取り出して関数 f を適用し、その結果を bignumLogical の返り値 (リスト) に追加します。ys が空リストになった場合は xs を返し、xs が空リストになった場合は ys を返します。両方とも空リストの場合は空リストを返します。
</p>

<h4 id="ans85">●解答85</h4>
<pre class="list">
リスト : 多倍長整数の排他的論理和

bignumXOR :: Bignum -&gt; Bignum -&gt; Bignum
bignumXOR xs ys = if null zs then [0] else zs
  where zs = dropWhileEnd (==0) $ bignumLogical xor xs ys
</pre>
<p> bignumXOR は bignumLogical を呼び出して、リストの要素を排他的論理和を求め、dropWhileEnd で末尾から連続する 0 を取り除きます。その結果、zs が空リストになったら [0] を返します。そうでなければ zs をそのまま返します。
</p>

<h4 id="ans86">●解答86</h4>
<pre class="list">
リスト : 多倍長整数の左シフト

baseBit :: Int
baseBit = 16

mask :: Word32
mask = 0xffff

bignumShiftLeft16 :: Bignum -&gt; Int -&gt; Bignum
bignumShiftLeft16 xs b = iter xs 0
  where iter []     c = if c == 0 then [] else [c]
        iter (x:xs) c = z : iter xs (shiftR y baseBit')
          where y = shiftL x b
                z = (y .|. c) .&. mask

bignumShiftLeft :: Bignum -&gt; Int -&gt; Bignum
bignumShiftLeft xs n
  | n == 0 || xs == [0] = xs
  | n &lt; baseBit = bignumShiftLeft16 xs n
  | otherwise   = replicate a 0 ++ bignumShiftLeft16 xs b
      where a = n `div` baseBit
            b = n `mod` baseBit
</pre>
<p> bignumShiftLeft は引数 n が 0 または xs が [0] の場合は xs をそのまま返します。baseBit 未満の場合は関数 bignumShiftLeft16 を呼び出します。そうでなければ、n を baseBit で除算し、商を a に、剰余を b にセットします。そして、xs を b ビットシフトした結果に a 個の 0 を先頭に追加します。
</p>
<p> 実際のビットシフトは bignumShiftLeft16 で行います。局所関数 iter でリストの要素を順番に取り出します。引数 c には左ビットシフトしたときに溢れたビットをセットします。x を b ビット左シフトした値を y にセットし、y と c の論理和を求め、それと mask の論理積の結果を z にセットします。この z を iter の返り値 (リスト) に追加します。溢れたビットは y を右へ 16 ビットシフトすれば求めることができます。
</p>

<h4 id="ans87">●解答87</h4>
<pre class="list">
リスト : 多倍長整数の右シフト

bignumShiftRight16 :: Bignum -&gt; Int -&gt; Bignum
bignumShiftRight16 xs b = if null zs then [0] else zs
  where zs = dropWhileEnd (==0) $ snd $ iter xs
        mask = shiftL 1 b - 1
        iter [x]    = (x .&. mask, [shiftR x b])
        iter (x:xs) = let (c, ys) = iter xs
                          a = (shiftR x b) .|. (shiftL c (baseBit - b))
                      in (x .&. mask, a:ys)

bignumShiftRight :: Bignum -&gt; Int -&gt; Bignum
bignumShiftRight xs n
  | n == 0 || xs == [0] = xs
  | n &lt; baseBit = bignumShiftRight16 xs n
  | otherwise   = let ys = drop (n `div` baseBit) xs
                      b  = n `mod` baseBit
                  in if null ys
                     then [0]
                     else bignumShiftRight16 ys b
</pre>
<p> bignumShiftRight は引数 n が 0 または xs が [0] の場合は xs をそのまま返します。baseBit 未満の場合は関数 bignumShiftRight16 を呼び出します。そうでなければ、n を base_bit で除算し、xs の先頭から商の数だけ要素を取り除き、それを ys にセットします。剰余は b にセットします。もし ys が空リストならば [0] を返します。そうでなければ、bignumShiftRigth16 を呼び出して、ys を b ビット右へシフトします。
</p>
<p> 実際のビットシフトは関数 bignumShiftRight16 で行います。局所関数 iter で xs の要素を順番に取り出します。最初に iter を再帰呼び出しして、溢れたビット c とシフトした結果 ys を求めます。それから、x を右に b ビットシフトし、それと c を左へ baseBit - b ビットシフトした値の論理和を求めます。この値 a を ys に追加し、溢れるビットを x と mask の論理積で求めます。mask の値は 1 を b ビット左シフトした値から 1 を引き算するだけです。これで下位 b ビットを 1 にすることができます。
</p>

<h4 id="ans88">●解答88</h4>
<pre class="list">
リスト : 多倍長整数の比較

bignumCompare :: Bignum -&gt; Bignum -&gt; Ordering
bignumCompare [] [] = EQ
bignumCompare [] _  = LT
bignumCompare _  [] = GT
bignumCompare (x:xs) (y:ys) =
  case bignumCompare xs ys of
    EQ -&gt; compare x y
    r  -&gt; r

bignumEQ, bignumNE, bignumGT, bignumLT, bignumGE, bignumLE :: Bignum -&gt; Bignum -&gt; Bool
bignumEQ xs ys = bignumCompare xs ys == EQ
bignumNE xs ys = bignumCompare xs ys /= EQ
bignumGT xs ys = bignumCompare xs ys == GT
bignumLT xs ys = bignumCompare xs ys == LT
bignumGE xs ys = bignumCompare xs ys &gt;= EQ
bignumLE xs ys = bignumCompare xs ys &lt;= EQ
</pre>
<p> 関数 bignumCompare は xs と ys が等しい場合は EQ を、xs のほうが大きい場合は GT を、xs のほうが小さい場合は LT を返します。
</p>
<p> bignumCompare は 2 つのリストを順番にたどっていき、xs が先に空リストになったら LT を、ys が先に空リストになったら GT を返します。両方とも空リストになった場合は EQ を返します。bignumCompare を再帰呼び出しして、その結果が EQ の場合は関数 compare で x と y を比較します。そうでなければ、返り値 r をそのまま返します。あとは、各関数から bignumCompare を呼び出して結果を比較するだけです。
</p>

<h4 id="ans89">●解答89</h4>
<pre class="list">
リスト : 多倍長整数と整数の加算

integerAdd :: Word32 -&gt; Word32 -&gt; Word32 -&gt; (Word32, Word32)
integerAdd x y c =
  let n = x + y + c
  in if n &lt; base then (n, 0) else (n - base, 1)

bignumAddInt :: Bignum -&gt; Word32 -&gt; Bignum
bignumAddInt [] n = if n == 0 then [] else [n]
bignumAddInt (x:xs) n = y : bignumAddInt xs c
  where (y, c) = integerAdd x 0 n
</pre>
<p> bignumAddInt は最下位の桁と引数 c を加算し、桁上がりがあればそれを上位の桁に加算します。あとは、桁上げの処理を繰り返すだけです。整数同士の加算は関数 integerAdd で行います。引数 x, y, c を加算し、その値 n が base 未満であれば n と 0 をタプルで返します。そうでなければ、n - base と 1 をタプルで返します。
</p>

<h4 id="ans90">●解答90</h4>
<pre class="list">
リスト : 多倍長整数の加算

bignumAdd :: Bignum -&gt; Bignum -&gt; Bignum
bignumAdd xs ys = iter xs ys 0
  where iter [] ys c = bignumAddInt ys c
        iter xs [] c = bignumAddInt xs c
        iter (x:xs) (y:ys) c =
          let (n, c') = integerAdd x y c
          in n : iter xs ys c'
</pre>
<p> bignumAdd の処理は局所関数 iter で行います。第 3 引数 c は桁上がりを表します。xs または ys が空リストの場合は bignumAddInt を呼び出して、もう一方の値と c を加算します。そうでなければ、xs と ys の要素と c を integerAdd で加算します。あとは、iter に c' を渡してを再帰呼び出しし、その返り値に n を追加するだけです。
</p>

<h4 id="ans91">●解答91</h4>
<pre class="list">
リスト : 多倍長整数と整数の減算

integerSub :: Word32 -&gt; Word32 -&gt; Word32 -&gt; (Word32, Word32)
integerSub x y c =
  let n = base + x - y - c
  in if n &lt; base then (n, 1) else (n - base, 0)

bignumSubInt :: Bignum -&gt; Word32 -&gt; Bignum
bignumSubInt xs n = if null zs then [0] else zs
  where zs = dropWhileEnd (== 0) $ iter xs n
        iter [] n =
          if n &gt; 0 then error "bignum: underflow" else []
        iter (x:xs) n =
          let (y, c) = integerSub x 0 n
          in y : iter xs c
</pre>
<p> bignumSubInt は最下位の桁と引数 n を減算し、桁借りがあればそれを上位の桁から減算します。あとは、桁借りの処理を繰り返すだけです。実際の処理は局所関数 iter で行います。引数が空リストで、桁借りの値 n が正であれば、計算結果は負になるのでエラーを送出します。そうでなければ、空リストを返します。あとは、integerSub で x - n を計算し、桁借り c を iter に渡して再帰呼び出しし、その返り値に y を追加するだけです。最後に、末尾から連続する 0 を dropWhileEnd で取り除き、その結果 zs が空リストであれば [0] を、そうでなければ zs を返します。
</p>
<p> integerSub は base + x から y と c を減算して変数 n にセットします。もし、n が base よりも小さい場合、n と桁借りを表す 1 をタプルで返します。そうでなければ、n - base と 0 をタプルで返します。
</p>

<h4 id="ans92">●解答92</h4>
<pre class="list">
リスト : 多倍長整数の減算

bignumSub :: Bignum -&gt; Bignum -&gt; Bignum
bignumSub xs ys = if null zs then [0] else zs
  where zs = dropWhileEnd (==0) $ iter xs ys 0
        iter [] ys c = if null ys &amp;&amp; c == 0
                       then []
                       else error "bignum: underflow"
        iter xs [] c = bignumSubInt xs c
        iter (x:xs) (y:ys) c =
          let (n, c') = integerSub x y c
          in n : iter xs ys c'
</pre>
<p> bignumSub の処理は局所関数 iter で行います。iter は xs と ys の要素と桁借りを表す引数 c を integerSub で減算し、その結果を iter の返り値 (リスト) に格納していきます。xs が空リストの場合、ys が空リストで c が 0 であれば空リストを返します。そうでなければ、結果は負になるのでエラーを送出します。ys が空リストで xs が空リストでない場合、bignumSubInt で xs から c を減算します。最後に、dropWhileEnd で末尾から連続する 0 を取り除き、その結果 zs が空リストであれば [0] を、そうでなければ zs を返します。
</p>


<h4 id="ans93">●解答93</h4>
<pre class="list">
リスト : 多倍長整数と整数の乗算

integerMul :: Word32 -&gt; Word32 -&gt; Word32 -&gt; (Word32, Word32)
integerMul x y c =
  let n = x * y + c
  in if n &lt; base
     then (n, 0)
     else (n `mod` base, n `div` base)

bignumMulInt :: Bignum -&gt; Word32 -&gt; Bignum
bignumMulInt xs n
  | n == 0    = [0]
  | n == 1    = xs
  | otherwise = iter xs 0
      where iter [] c =
              if c == 0 then [] else [c]
            iter (x:xs) c = let (y, c') = integerMul x n c
                            in y : iter xs c'
</pre>
<p> bignumMulInt は引数 n が 0 ならば [0] を、1 ならば xs をそのまま返します。それ以外の場合、最下位の桁から順番に x と掛け算して、iter の返り値 (リスト) に追加します。このとき、桁上がり c' を iter に渡して、上位の桁に足し算します。整数の乗算は関数 integerMul で行います。引数 x, y が乗算する整数、c が桁上がりで加算する値です。x * y + c を n にセットし、値が base 未満であれば n と 0 をタプルで返します。そうでなければ、n と base の剰余と商をタプルで返します。
</p>

<h4 id="ans94">●解答94</h4>
<pre class="list">
リスト : 多倍長整数の乗算

bignumMul :: Bignum -&gt; Bignum -&gt; Bignum
bignumMul [x] ys = bignumMulInt ys x
bignumMul xs [y] = bignumMulInt xs y
bignumMul xs ys  = iter xs ys [0]
  where iter _  []     a = a
        iter xs (y:ys) a =
          iter (0:xs) ys (bignumAdd (bignumMulInt xs y) a)
</pre>
<p> 多倍長整数同士の乗算は筆算と同じ方法で行います。簡単な例を示しましょう。
</p>
<pre class="fig">
xs : (4 3 2 1)
ys : (7 6 5)

        1   2   3   4
*           5   6   7
----------------------
        7  14  21  28
    6  12  18  24   0
5  10  15  20   0   0
----------------------
5  16  34  52  45  28

図 : 多倍長整数の乗算
</pre>
<p> 上図のように、xs を 16 bit 左シフトしながら ys の要素を掛け算し、その値を加算していけばいいわけです。
</p>
<p> bignumMul は引数 xs, ys が base 未満の整数であれば、bignumMulInt を呼び出して計算します。そうでなければ、xs と y の乗算を bignumMulInt で求め、累積変数 a にその値を bignumAdd で加算します。ys の次の要素を乗算するとき、xs の先頭に 0 を挿入して 16 bit 左シフトします。
</p>

<p> なお、今回の方法は桁数が多くなると遅くなります。これよりも高速な方法として「Karatsuba 法」や「高速フーリエ変換」を使った方法があります。これらのアルゴリズムについては、<a href="http://www1.s2.starcat.ne.jp/fussy/">Fussy さん</a> の <a href="http://fussy.web.fc2.com/algo/algo10-3.htm">乗算処理の高速化</a>, <a href="http://fussy.web.fc2.com/algo/algo10-4.htm">高速フーリエ変換</a>、<a href="http://homepage2.nifty.com/m_kamada/">M.Kamada さん</a> の <a href="http://homepage2.nifty.com/m_kamada/math/fftmul.htm">離散フーリエ変換を用いた多倍長乗算の話</a> が参考になると思います。
</p>
<h4 id="ans95">●解答95</h4>
<pre class="list">
リスト : 多倍長整数と整数の除算

integerDiv :: Word32 -&gt; Word32 -&gt; Word32 -&gt; (Word32, Word32)
integerDiv x y c =
  let n = c * base + x
  in (n `div` y, n `mod` y)

bignumDivInt :: Bignum -&gt; Word32 -&gt; (Bignum, Bignum)
bignumDivInt xs 0 = error "bignum: divide by zero"
bignumDivInt xs 1 = (xs, [0])
bignumDivInt xs n = iter (reverse xs) 0 []
  where iter [] c [] = ([0], [c])
        iter [] c a  = (a, [c])
        iter (x:xs) c a =
          let (p, q) = integerDiv x n c
          in iter xs q (if p == 0 &amp;&amp; null a then a else p:a)
</pre>
<p> bignumDivInt は引数 x が 0 の場合はエラーを送出し、1 の場合は xs と [0] をタプルで返します。それ以外の場合は、xs の上位の桁から順番に整数 x で除算していきます。このため、xs を reverse で反転しています。局所関数 iter の変数 c には上位の桁の余りをセットします。あとは、関数 integerDiv で xs の要素と n の除算を行います。このとき、c * base を加えてから x で割ることに注意してください。あとは商と剰余をタプルで返します。
</p>
<p> bignumDivInt は上位の桁から処理を行うため、リストの末尾に 0 が付加されないように工夫する必要があります。商 p が 0 で、かつ累積変数 a が空リストの場合、p を a に追加しません。それ以外の場合は p を a に追加します。最後に、a が空リストであれば zero と [c] を、そうでなければ a と [c] をタプルで返します。
</p>

<h4 id="ans96">●解答96</h4>
<p> 多倍長整数の除算は筆算と同じ方法で行いますが、かなり複雑な処理になります。ここではアルゴリズムの概略を説明するだけにとどめます。詳細は <a href="yahsp05.html#cite">参考文献</a> をお読みください。
</p>
<pre class="list">
リスト : 多倍長整数の除算 (擬似コード)

xs = (x1 x2 ... xn), ys = (y1 y2 ... ym) とし、xs / ys の商と剰余を求める

*base* / 2 &lt;= ym * d &lt; *base* を満たす d を求め、(xs * d) / (ys * d) を計算する

xs1 = xs * d とする
xs1 と同じ桁数になるよう (ys * d) の下位に 0 を追加たものを ys1 とする
このとき、追加した 0 の個数を s とする

qs = ()
while( s &gt;= 0 ){
  xs1 / ys1 の仮の商 q' を求める。
    (1) xs1 が ys1 よりも少ない桁数の場合、q' は 0 である
    (2) xs1 と ys1 の桁数 (n) が同じ場合、q' = xn / yn とする
    (3) xs1 が n 桁, ys1 が n - 1 桁の場合、q' = min( (xn * base + xn-1) / yn-1, base - 1 ) とする

  if( q' &gt; 0 ){
    ys2 = ys1 * q'
    while( xs1 &lt; ys2 ){
      q' = q' - 1
      ys2 = ys2 - ys1
    }
    xs1 = xs1 - ys2
  }

  q' を qs に追加する
  ys1 の最下位から 0 を取り除く
  s = s - 1
}

商は qs, 剰余は xs1 / d となる。
</pre>
<p> ポイントは仮の商 q' を求める処理です。ys1 の最上位の桁 ym が条件 (A) base / 2 &lt;= ym &lt; base を満たしている場合、(2) であれば q' は 0 か 1 になります。(3) であれば xs1 の上位 2 桁と ys1 の上位 1 桁 (ym) から仮の商を求めます。このとき、真の商を q とすると、条件 (A) を満たしているならば次の式が成り立ちます。
</p>
<pre class="item">
q &lt;= q' &lt;= q + 2
</pre>
<p> したがって、q の値は q', q' - 1, q' - 2 のどれかになります。ys2 = ys1 * q' を計算し、xs1 &lt; ys2 であれば q' から 1 を、ys2 から ys1 を引き算します。これを xs1 &gt;= ys2 になるまで繰り返しますが、最悪でも 2 回の繰り返しで済むわけです。
</p>
<p> 商 q が q' - 1 と q' - 2 になる例を示します。
</p>
<pre class="fig">
xs1 = [65535, 65535, 32767]
ys1 = [65535, 32768]

q' = (32767 * base + 65535) / 32768 = 65535
ys2 = [65535, 32768] * 65535 = [1, 32766, 32768] &gt; xs1

q' = q' - 1 = 65534
ys2 = ys2 - ys1 = [2, 65533, 32767] &lt; xs1

q' = 65534, xs1 = xs1 - ys2 = [65533, 2]

-----------------------------------------------------
xs1 = [65535, 0, 32767]
ys1 = [65535, 32768]

q' = (32767 * base + 0) / 32768 = 65534
ys2 = [65535, 32768] * 65534 = [2, 65533, 32767] &gt; xs1

q' = q' - 1
ys2 = ys2 - ys1 = [3, 32764, 32767] &gt; xs1
q' = q' - 1
ys2 = ys2 - ys1 = [4, 65531, 32766] &lt; xs1

q' = 65532, xs1 = xs1 - ys2 = [65531, 5]
</pre>

<p> なお、(3) を満たしているとき、より高い精度で仮の商 q' を求める方法があります。有名なクヌース先生のアルゴリズムＤはこの方法を使っています。除算のアルゴリズムについては、<a href="yahsp05.html#cite">参考文献 [2]</a> がわかりやすくまとまっていると思います。また、乗算の処理が高速な場合、ニュートン法で ys の逆数 1 / ys を求め、xs * (1 / ys) を計算することで除算を高速に実行することができます。
</p>

<p> 擬似コードをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 多倍長整数の除算

halfBase = 0x8000

-- シフトするビット数を求める
getShiftBit :: Word32 -&gt; Int
getShiftBit n = iter n 0
  where iter n c
          | n &gt;= halfBase = c
          | otherwise = iter (n * 2) (c + 1)

-- 仮の商を求める
getQuot :: Bignum -&gt; Bignum -&gt; Word32
getQuot [] _ = 0
getQuot [x] [y] = x `div` y
getQuot (x1:x2:xs) [y] = (x2 * base + x1) `div` y
getQuot (_:xs) (_:ys) = getQuot xs ys


bignumDiv :: Bignum -&gt; Bignum -&gt; (Bignum, Bignum)
bignumDiv xs [y] = bignumDivInt xs y
bignumDiv xs ys
  | bignumLT xs ys = ([0], xs)
  | otherwise = iter s xs' ys' []
      where d = getShiftBit $ last ys
            xs' = bignumShiftLeft xs d
            s = length xs' - length ys
            ys' = bignumShiftLeft ys (baseBit * (fromIntegral s) + (fromIntegral d))
            iter s xs1 ys1 q =
              if s &lt; 0
              then (q, bignumShiftRight xs1 d)
              else iter (s - 1)
                        xs1'
                        (tail ys1)
                        (if quot == 0 &amp;&amp; null q then q else quot:q)
              where (quot, xs1') = iter2 xs1 ys1
                    iter2 xs1 ys1 =
                      let quot = min (getQuot xs1 ys1) (base - 1)
                          ys2 = bignumMulInt ys1 quot
                      in if quot == 0
                         then (quot, xs1) 
                         else iter3 xs1 ys1 ys2 quot
                    iter3 xs1 ys1 ys2 quot =
                      if bignumLT xs1 ys2
                      then iter3 xs1 ys1 (bignumSub ys2 ys1) (quot - 1)
                      else (quot, bignumSub xs1 ys2)
</pre>
<p> 関数 getShiftBit は ys の最上位の値が base / 2 以上になるよう、左シフトするビット数を求めます。関数 getQuot は仮の商を求めます。xs が空リストならば、xs の桁は ys よりも少ないので 0 を返します。ys が末尾の要素で、かつ xs も末尾の要素であれば、同じ桁数なので x / y を返します。そうでなければ、xs の上位 2 桁を求め、それを y で割り算します。関数 bignumDiv は説明をそのままプログラムしただけなので、とくに難しいところはないと思います。
</p>
<div class="note">
-- <a name="cite">参考文献</a> --------<br>
[1] <a href="http://www1.s2.starcat.ne.jp/fussy/">Fussy's HOMEPAGE</a>, <a href="http://fussy.web.fc2.com/algo/algo10-2.htm">多倍長整数の演算</a><br>
[2] 野呂春文, <a href="http://research.n-fukushi.ac.jp/ps/research/usr/db/pdfs/00070-00010.pdf">大きな整数の除算アルゴリズム (PDF)</a>
</div>
<h4 id="ans97">●解答97</h4>
<pre class="list">
リスト : 多倍長整数を文字列に変換する

charTable :: String
charTable = "0123456789ABCDEF"

bignumToString :: Bignum -&gt; Word32 -&gt; String
bignumToString xs r = iter xs []
  where iter [0]    a = a
        iter xs a = iter ys ((charTable !! (fromIntegral m)) : a)
          where (ys, [m]) = bignumDivInt xs r
</pre>
<p> bignumToString は簡単です。bignumDivInt で xs を基数 r で割り算し、charTable から m 番目の要素を求め、それを累積変数 a のリストに追加します。この処理を xs が [0] になるまで繰り返し、最後に a を返します。
</p>
<h4 id="ans98">●解答98</h4>
<pre class="list">
リスト : 文字列を多倍長整数に変換する

stringToBignum :: String -&gt; Word32 -&gt; Bignum
stringToBignum s r = iter s [0]
  where iter [] a = a
        iter (x:xs) a =
          case findIndex (== toUpper x) charTable of
            Nothing -&gt; error "stringToBignum: illegal char"
            Just n  -&gt; iter xs (bignumAddInt (bignumMulInt a r) (fromIntegral n))
</pre>
<p> stringToBignum も簡単です。局所関数 iter で 1 文字ずつ順番に取り出し、関数 findIndex で文字を数値 n に変換します。このとき、英小文字をモジュール Data.Char の関数 toUpper で英大文字に変換しています。文字が見つからない場合はエラーを送出します。あとは、bignumMulInt で累積変数 a と基数 r を掛け算し、それに bignumAddInt で n を加算していくだけです。最後に a を返します。
</p>

<h4 id="ans99">●解答99</h4>
<p> 数 a の平方根 √a の値を求める場合、方程式 x2 - a = 0 を Newton (ニュートン) 法で解くことが多いと思います。方程式を f(x), その導関数を f'(x) とすると、ニュートン法は次の漸化式の値が収束するまで繰り返す方法です。
</p>
<pre class="item">
x<sub>n+1</sub> = x<sub>n</sub> - f(x<sub>n</sub>) / f'(x<sub>n</sub>)
</pre>
<p> 平方根を求める場合、導関数は f'(x) = 2x になるので、漸化式は次のようになります。
</p>
<pre class="item">
x<sub>n+1</sub> = (x<sub>n</sub> + a / x<sub>n</sub>) / 2
</pre>
<p> <a href="yahsp05.html#cite99">参考文献 1</a> によると、√a より大きめの初期値から出発し、置き換え x &lt;- (x + a / x) / 2 を減少が止まるまで繰り返すことで √a の正確な値を求めることができるそうです。
</p>

<p> これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 平方根の整数部を求める

bignumSqrt :: Bignum -&gt; Bignum
bignumSqrt [0] = [0]
bignumSqrt xs = iter xs
  where iter p = let (q, _) = bignumDiv xs p
                     q' = bignumShiftRight16 (bignumAdd p q) 1
                 in if bignumGE q' p then p else iter q'
</pre>
<p> 漸化式を計算して変数 q' にセットし、q' がひとつ前の値 p 以上になったら p を返すだけです。
</p>
<p> ところで、Newton 法は初期値の設定によって性能が大きく変わります。引数 xs をそのまま初期値として使う場合、xs が大きくなると実行速度はかなり遅くなります。そこで、xs を半分に分けて、上位の桁を初期値として使うことにします。ただし、そのままでは √xs よりも小さくなる場合があるので、16 ビット左シフトすることにします。
</p>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 平方根の整数部を求める (改良版)

bignumSqrt' :: Bignum -&gt; Bignum
bignumSqrt' [0] = [0]
bignumSqrt' xs = iter (init xs)
  where init xs = let k = length xs `div` 2
                  in if k == 0 then xs else 0 : drop k xs
        iter p = let (q, _) = bignumDiv xs p
                     q' = bignumShiftRight16 (bignumAdd p q) 1
                 in if bignumGE q' p then p else iter q'
</pre>
<p> init で初期値を求めます。xs を半分の桁を k とし、k が 0 ならば xs をそのまま返します。そうでなければ、drop で xs から k 個の要素を削除し、その先頭に 0 を追加します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 2 * 10^100
141421356237309504880168872420969807856967187537694
(0.28 secs, 26877204 bytes)
*Main&gt; bignumToInteger $ bignumSqrt' $ toBignum $ 2 * 10^100
141421356237309504880168872420969807856967187537694
(0.09 secs, 7789172 bytes)
*Main&gt; bignumToInteger $ bignumSqrt $ toBignum $ 2 * 10^200
14142135623730950488016887242096980785696718753769480731766797379907324784621070
388503875343276415727
(1.59 secs, 164479284 bytes)
*Main&gt; bignumToInteger $ bignumSqrt' $ toBignum $ 2 * 10^200
14142135623730950488016887242096980785696718753769480731766797379907324784621070
388503875343276415727
(0.19 secs, 16584340 bytes)

実行環境 : Windows 7, Core i7-2670QM 2.20GHz, GHCi, version 7.4.1
</pre>
<p> bignumSqrt' のほうが高速ですね。改良の効果は十分に出ていると思います。
</p>
<div class="note">
<a name="cite99">-- 参考文献 --------</a><br>
1. 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="yahsp04.html">PrevPage</a> | <a href="haskell.html#yahsp">Haskell</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>