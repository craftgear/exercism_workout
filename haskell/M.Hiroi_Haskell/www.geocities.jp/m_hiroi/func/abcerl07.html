<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Erlang プログラミング入門</title>
  <meta name="description" content="Erlang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881787</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Erlang プログラミング入門</h2>
<div class="small">
[ <a href="abcerl06a.html">PrevPage</a> | <a href="erlang.html">Erlang</a> | <a href="abcerl08.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>バイナリ</h3>
<p> 今回は「バイナリ (binary)」というデータ型について説明します。Erlang のバイナリは、バイナリデータ (binary data) を扱うためのデータ構造です。基本的には 1 byte (要素の値は 0 から 255 まで) の 1 次元配列ですが、ビット単位でも操作できるようになっています。
</p>

<h4>●バイナリの生成</h4>
<p> バイナリは次の式で生成することができます。
</p>
<pre class="item">
&lt;&lt; 値:サイズ/タイプ, ... &gt;&gt;
</pre>
<p> 値はデフォルトで整数、サイズはビット幅を指定します。整数以外の値を使用する場合はタイプを指定します。サイズの指定を省略した場合は 8 bit (1 byte) になります。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; &lt;&lt;1, 2, 3, 4&gt;&gt;.
&lt;&lt;1,2,3,4&gt;&gt;

&gt; &lt;&lt;16#0102:16, 5, 6&gt;&gt;.
&lt;&lt;1,2,5,6&gt;&gt;

&gt; &lt;&lt;1:4, 2:4, 3, 4&gt;&gt;.
&lt;&lt;18,3,4&gt;&gt;
</pre>
<p> 最初の例は要素が 1, 2, 3, 4 のバイナリになります。次の例は、最初の要素が 16 bit の値 16#0102 なので、上位 8 bit と下位 8 bit に分けて格納され、バイナリの値は &lt;&lt;1,2,5,6&gt;&gt; になります。最後の例は、2 つの要素が 4 bit なので、1 つのバイトデータ 18 にまとめられて、大きさが 3 のバイナリデータになります。
</p>
<p> バイナリの要素は文字列または文字でも指定することができます。簡単な例を示します。
</p>
<pre>
&gt; &lt;&lt;"abc"&gt;&gt;.
&lt;&lt;"abc"&gt;&gt;

&gt; &lt;&lt;$a, $b, $c&gt;&gt;.
&lt;&lt;"abc"&gt;&gt;
</pre>
<p> バイナリの大きさは組み込み関数 (BIF) の size/1 で求めることができます。
</p>
<pre>
&gt; size(&lt;&lt;1, 2, 3, 4&gt;&gt;).
4
&gt; size(&lt;&lt;1, 2, 3, 4, 5, 6, 7, 8&gt;&gt;).
8
</pre>
<h4>●タイプの指定方法</h4>
<p> タイプで指定できる属性の種類を下記に示します。複数の属性を指定するときはハイフン (-) で区切ります。
</p>
<ul>
  <li>データ型
  <ul>
    <li>integer, 整数 (デフォルト)
    <li>float, 浮動小数点数
    <li>binary, bytes, バイナリ
    <li>bitstring, bits, ビットストリング
    <li>utf8, utf16, utf32, ユニコード
  </ul>
  <li>符号
  <ul>
    <li>signed, 符号付き
    <li>unsigned, 無符号 (デフォルト)
  </ul>
  <li>エンディアン
  <ul>
    <li>big (デフォルト)
    <li>little
    <li>native (CPU のエンディアン)
  </ul>
  <li>ユニット:整数値
  <ul>
    <li>サイズの単位 (1 - 256) を指定
    <li>integer のデフォルトは 1 bit
  </ul>
</ul>
<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; &lt;&lt;1.2345/float&gt;&gt;.
&lt;&lt;63,243,192,131,18,110,151,141&gt;&gt;

&gt; &lt;&lt;123, 5.6789/float, &lt;&lt;1, 2, 3, 4&gt;&gt;/binary&gt;&gt;.
&lt;&lt;123,64,22,183,49,143,197,4,129,1,2,3,4&gt;&gt;

&gt; &lt;&lt;16#01020304:32&gt;&gt;.
&lt;&lt;1,2,3,4&gt;&gt;

&gt; &lt;&lt;16#01020304:4/unit:8&gt;&gt;.
&lt;&lt;1,2,3,4&gt;&gt;

&gt; &lt;&lt;16#01020304:4/native-unit:8&gt;&gt;.
&lt;&lt;4,3,2,1&gt;&gt;

&gt; &lt;&lt;16#01020304:4/little-unit:8&gt;&gt;.
&lt;&lt;4,3,2,1&gt;&gt;

&gt; &lt;&lt;16#01020304:4/big-unit:8&gt;&gt;.
&lt;&lt;1,2,3,4&gt;&gt;
</pre>
<p> UTF-8 が扱える端末であれば日本語を表示することもできますが、バイナリで日本語を使用するときはタイプに utf8 を指定する必要があります。werl +pc uncode での実行例を示します。
</p>
<pre>
&gt; "あいうえお".
"あいうえお"

&gt; io:format('~p~n', ["あいうえお"]).
[12354,12356,12358,12360,12362]
ok

&gt; &lt;&lt;"あいうえお"&gt;&gt;.
&lt;&lt;"BDFHJ"&gt;&gt;

&gt; &lt;&lt;"あいうえお"/utf8&gt;&gt;.
&lt;&lt;"あいうえお"/utf8&gt;&gt;
</pre>
<p> format で日本語 (utf8) を表示するときは ~s, ~p の代わりに ~ts, ~tp を使います。
</p>
<pre>
&gt; io:format('~ts~n', ["あいうえお"]).
あいうえお
ok
&gt; io:format('~tp~n', ["あいうえお"]).
"あいうえお"

&gt; A = &lt;&lt;"あいうえお"/utf8&gt;&gt;.
&lt;&lt;"あいうえお"/utf8&gt;&gt;
&gt; io:format('~p~n', [A]).       
&lt;&lt;227,129,130,227,129,132,227,129,134,227,129,136,227,129,138&gt;&gt;
ok
&gt; io:format('~tp~n', [A]).
&lt;&lt;"あいうえお"/utf8&gt;&gt;
ok
</pre>
<h4>●ビットストリング</h4>
<p> バイナリは 1 byte (8 bit) が標準の単位で、ビットの総数は 8 の倍数になりますが、それ以外のデータ (ビットの総数が 8 の倍数にはならないデータ) でも取り扱うことができます。Erlang ではこれを「ビットストリング (bitstring)」といいます。基本的な操作はバイナリと同じですが、パターンマッチングで動作が異なる場合があります。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; &lt;&lt;1:2&gt;&gt;.
&lt;&lt;1:2&gt;&gt;

&gt; &lt;&lt;1,2,3,4:4&gt;&gt;.
&lt;&lt;1,2,3,4:4&gt;&gt;

&gt; &lt;&lt;1:4,2,3,4&gt;&gt;.
&lt;&lt;16,32,48,4:4&gt;&gt;
</pre>
<p> 最初の例は 2 bit のビットストリングになります。次の例は、最後のデータが 4 bit なので、28 bit のビットストリングになります。最後の例は、最初のデータが 4 bit なので、2 番目以降のデータが 4 bit ずつ左へシフトされて &lt;&lt;16,32,48,4:4&gt;&gt; となります。
</p>
<p> なお、関数 size/1 にビットストリングを適用すると、バイト単位での大きさを返します。ビット単位で大きさを求める場合は組み込み関数 bit_size/1 を使ってください。
</p>
<pre>
&gt; size(&lt;&lt;1:4&gt;&gt;).
0
&gt; size(&lt;&lt;1,2,3,4:4&gt;&gt;).
3
&gt; bit_size(&lt;&lt;1:4&gt;&gt;).
4
&gt; bit_size(&lt;&lt;1,2,3,4:4&gt;&gt;).
28
12> bit_size(&lt;&lt;1,2,3,4&gt;&gt;).
32
</pre>

<h4>●バイナリのパターンマッチング</h4>
<p> パターンマッチングはバイナリでも行うことができます。次の例を見てください。
</p>
<pre>
&gt; &lt;&lt;A, B, C, D&gt;&gt; = &lt;&lt;1, 2, 3, 4&gt;&gt;.
&lt;&lt;1,2,3,4&gt;&gt;
&gt; A.
1
&gt; B.
2
&gt; C.
3
&gt; D.
4

&gt; &lt;&lt;X:4,Y:4&gt;&gt; = &lt;&lt;129&gt;&gt;.
&lt;&lt;129&gt;&gt;
&gt; X.
8
&gt; Y.
1

&gt; A1 = &lt;&lt;255, 1.2345/float, &lt;&lt;1, 2, 3, 4&gt;&gt;/binary&gt;&gt;.
&lt;&lt;255,63,243,192,131,18,110,151,141,1,2,3,4&gt;&gt;

&gt; &lt;&lt;X1, Y1/float, Z1/binary&gt;&gt; = A1.
&lt;&lt;255,63,243,192,131,18,110,151,141,1,2,3,4&gt;&gt;
&gt; X1.
255
&gt; Y1.
1.2345
&gt; Z1.
&lt;&lt;1,2,3,4&gt;&gt;
</pre>
<p> バイナリで整数以外のデータとパターンマッチングするときは、/ の後ろにタイプを指定してください。これでバイナリの要素が float や binary でもパターンマッチングで取り出すことができます。また、ビット幅を指定して値を取り出すこともできます。
</p>
<p> リストのパターンマッチングのように、先頭の要素と残りのデータとに分けてマッチングさせることも可能です。次の例を見てください。
</p>
<pre>
&gt; &lt;&lt;H, R/binary&gt;&gt; = &lt;&lt;1, 2, 3, 4, 5&gt;&gt;.
&lt;&lt;1,2,3,4,5&gt;&gt;
&gt; H.
1
&gt; R.
&lt;&lt;2,3,4,5&gt;&gt;
</pre>
<p> 先頭のデータをバイト単位ではなくビット単位で取り出すことも可能です。この場合、残りのデータはビットストリングになるので、タイプには bitstring を指定します。また、ビットストリングからバイトデータを取り出す場合も、残りのデータがビットストリングになるので bitstring を指定します。簡単な実行例を示します。
</p>
<pre>
&gt; &lt;&lt;Hb:4, Rb/bitstring&gt;&gt; = &lt;&lt;16, 2, 3, 4, 5&gt;&gt;.
&lt;&lt;16,2,3,4,5&gt;&gt;

&gt; Hb.
1
&gt; Rb.
&lt;&lt;0,32,48,64,5:4&gt;&gt;

&gt; &lt;&lt;Hb1, Rb1/bitstring&gt;&gt; = &lt;&lt;1, 2, 3, 4, 5:4&gt;&gt;.
&lt;&lt;1,2,3,4,5:4&gt;&gt;

&gt; Hb1.
1
&gt; Rb1.
&lt;&lt;2,3,4,5:4&gt;&gt;
</pre>
<p> この場合、Rb と Rb1 に binary を指定するとマッチングでエラーになります。
</p>

<h4>●ビット演算子</h4>
<p> ここで Erlang に用意されているビット演算子について説明しておきましょう。
</p>
<table border=1>
<caption>表 : ビット演算子</caption>
<thead>
  <tr><th>演算子</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>band</td><td>ビットごとの論理積を返す</td></tr>
  <tr><td>bor </td><td>ビットごとの論理和を返す</td></tr>
  <tr><td>bxor</td><td>ビットごとの排他的論理和を返す</td></tr>
  <tr><td>bnot</td><td>ビットごとの論理的な否定を返す</td></tr>
  <tr><td>bsl</td><td>m bsl n は m を n ビットだけ左シフトする</td></tr>
  <tr><td>bsr</td><td>m bsr n は m を n ビットだけ右シフトする</td></tr>
</tbody>
</table>
<p> band はビットごとの論理積を返します。
</p>
<pre>
&gt; 5 band 3.
1
</pre>
<pre class="fig">
     0101
 and 0011
---------
     0001
</pre>
<p> bor はビットごとの論理和を返します。
</p>
<pre>
&gt; 5 bor 3.
7
</pre>
<pre class="fig">
    0101
 or 0011
--------
    0111
</pre>
<p> bxor はビットごとの排他的論理和を返します。
</p>
<pre>
&gt; 5 bxor 3.
6
</pre>
<pre class="fig">
     0101
 xor 0011
---------
     0110
</pre>
<p> bnot はビットごとの論理的な否定を返します。
</p>
<pre>
&gt; bnot 0.
-1
&gt; bnot 1.
-2
</pre>
<p> m bsl n は m を n ビット左シフトします。m bsr n は m を n ビット右シフトします。
</p>
<pre>
&gt; 1 bsl 8.
256
&gt; 256 bsr 4.
16
</pre>

<h4>●バイナリの内包表記</h4>
<p> Erlang はリストだけではなくバイナリにも「内包表記」を使うことができます。基本的な構文を次に示します。
</p>
<pre class="item">
&lt;&lt; &lt;&lt;式１&gt;&gt; || &lt;&lt;パターン&gt;&gt; &lt;= 式２, 条件式 &gt;&gt;
</pre>
<p> &lt;&lt; &gt;&gt; の最初にバイナリの要素を生成する式１ (コンストラクタ) を記述します。次に || で区切ったあと、"&lt;&lt;パターン&gt;&gt; &lt;= 式２" を記述します。式２の値はバイナリでなければなりません。式１とパターンは &lt;&lt; &gt;&gt; で囲ってください。式２はバイナリをそのまま指定してもかまいません。&lt;= はバイナリの先頭から順番に要素を取り出し、パターンとマッチングを行います。また、カンマで区切ったあと、条件式を指定することができます。この条件式はガードとは違って、真偽値を返す関数であれば何でもかまいません。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
&gt; &lt;&lt; &lt;&lt;(X * 2)&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;1, 2, 3, 4&gt;&gt; &gt;&gt;.
&lt;&lt;2,4,6,8&gt;&gt;

&gt; &lt;&lt; &lt;&lt;X&gt;&gt; || &lt;&lt;X:4&gt;&gt; &lt;= &lt;&lt;1, 2, 3, 4&gt;&gt; &gt;&gt;.
&lt;&lt;0,1,0,2,0,3,0,4&gt;&gt;

&gt; &lt;&lt; &lt;&lt;Y:4, X:4&gt;&gt; || &lt;&lt;X:4, Y:4&gt;&gt; &lt;= &lt;&lt;1, 2, 3, 4&gt;&gt; &gt;&gt;.
&lt;&lt;16,32,48,64&gt;&gt;
</pre>
<p> 最初の例はパターンが &lt;&lt;X&gt;&gt; なので、バイナリから 8 bit ずつデータを取り出して変数 X にセットします。次に X * 2 を計算して、その値がバイナリの要素になります。2 番目の例は、パターンが &lt;&lt;X:4&gt;&gt; なので、バイナリから 4 bit ずつデータを取り出します。その値がそのままバイナリの要素になるので、生成されるバイナリの大きさは 8 byte になります。最後の例は、上位 4 bit と下位 4 bit を反転させたバイナリを生成します。
</p>

<p> パターンで指定したビット幅が式で指定したビット幅よりも大きい場合、上位のビットが捨てられて下位のビットが有効になる事に注意してください。次の例を見てください。
</p>
<pre>
&gt; &lt;&lt; &lt;&lt;X&gt;&gt; || &lt;&lt;X:16&gt;&gt; &lt;= &lt;&lt;1, 2, 3, 4, 5, 6, 7, 8&gt;&gt; &gt;&gt;.
&lt;&lt;2,4,6,8&gt;&gt;
</pre>
<p> パターンは &lt;&lt;X:16&gt;&gt; なので、バイナリから 16 bit ずつデータを取り出します。式は &lt;&lt;X&gt;&gt; なので、生成する要素は 8 bit になります。この場合、上位 8 bit は捨てられて、値は下位 8 bit になります。したがって、生成されるバイナリは &lt;&lt;2,4,6,8&gt;&gt; になるわけです。
</p>

<h4>●バイナリとリストの変換</h4>
<p> バイナリの内包表記で、"&lt;&lt;パターン&gt;&gt; &lt;= 式" のかわりにリスト内包表記の "パターン &lt;- 式" を使うことができます。逆に、リスト内包表記で "&lt;&lt;パターン&gt;&gt; &lt;= 式" を使うこともできます。これにより、バイナリからリストへの変換、およびその逆変換を行うことができます。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; &lt;&lt; &lt;&lt;X&gt;&gt; || X &lt;- [1, 2, 3, 4, 5] &gt;&gt;.
&lt;&lt;1,2,3,4,5&gt;&gt;

&gt; [X || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;1, 2, 3, 4, 5&gt;&gt;].
[1,2,3,4,5]

&gt; &lt;&lt; &lt;&lt;X&gt;&gt; || X &lt;- [1, 2, 1000, 4, 5] &gt;&gt;.
&lt;&lt;1,2,232,4,5&gt;&gt;

&gt; &lt;&lt; &lt;&lt;X:16&gt;&gt; || X &lt;- [1, 2, 1000, 4, 5] &gt;&gt;.
&lt;&lt;0,1,0,2,3,232,0,4,0,5&gt;&gt;

&gt; &lt;&lt; &lt;&lt;X&gt;&gt; || X &lt;- [1, 2, a, 4, 5] &gt;&gt;.
** exception error: bad argument
</pre>
<p> リストからバイナリに変換する場合、リストの要素の値に注意してください。値がビット幅に収まらない場合、余分な上位ビットは捨てられて下位ビットがバイナリの要素になります。また、数値以外のデータを与えるとエラーになります。
</p>
<p> なお、Erlang の組み込み関数 (BIF) にはリストをバイナリに変換する関数 list_to_binary と、バイナリをリストに変換する関数 binary_to_list が用意されています。簡単な実行例を示します。
</p>
<pre>
&gt; list_to_binary([1, 2, 3, 4, 5]).
&lt;&lt;1,2,3,4,5&gt;&gt;
&gt; binary_to_list(&lt;&lt;1, 2, 3, 4, 5&gt;&gt;).
[1,2,3,4,5]
</pre>
<p> このほかに、モジュール binary にはバイナリを操作するための便利な関数が用意されています。また、モジュール erlang にもデータをバイナリに変換する関数やその逆変換を行う関数があります。詳細は Erlang のリファレンスマニュアル <a href="http://erlang.org/doc/man/binary.html">Erlang -- binary</a>, <a href="http://erlang.org/doc/man/erlang.html">Erlang -- erlang</a> をお読みください。
</p>
<hr>
<div align="right">
初出 2011 年 11 月 20 日<br>
改訂 2019 年 1 月 6 日
</div>
</section>
<hr>
<section class="contents">
<h3 id="chap02">ファイル入出力</h3>
<p> 今回は Erlang のファイル入出力について説明します。Erlang は「ポート (port)」というデータ型を介して外部と通信処理を行います。ファイルの入出力処理もポートを介して行われますが、モジュール io, file などに用意されている関数を使うと、ポートを意識しないで入出力処理を行うことができます。
</p>

<h4>●標準入出力</h4>
<p> 通常のファイルは、ファイルに対応するポートを生成しないとアクセスすることはできません。ただし、標準入出力は Erlang を起動した時から簡単に利用することができます。一般に、キーボードからの入力を「標準入力」、画面への出力を「標準出力」といいます。
</p>

<p> データの入出力処理は標準入出力を使うと簡単です。モジュール io には標準入出力用の関数が用意されています。たとえば、io:write や io:format はデータを標準出力へ出力する関数でした。関数 io:read/1 は Erlang で取り扱うことができる「項」を入力することができます。
</p>
<pre class="item">
io:read(Prompt) =&gt; {ok, Data} | eof | {error, Reason}
</pre>
<p> 引数 Prompt は画面に表示するプロンプトで、文字列かアトムで指定します。省略することはできません。read はファイルの終了を検出すると eof を返します。エラーが発生した場合は {error, Reason} を返します。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
&gt; io:read("&gt;&gt; ").
&gt;&gt; 1234.
{ok,1234}
&gt; io:read("&gt;&gt; ").
&gt;&gt; 1.2345.
{ok,1.2345}
&gt; io:read("&gt;&gt; ").
&gt;&gt; foo.
{ok,foo}
&gt; io:read("&gt;&gt; ").
&gt;&gt; [1,2,3,4].
{ok,[1,2,3,4]}
&gt; io:read("&gt;&gt; ").
&gt;&gt; {a, b, c, d}.
{ok,{a,b,c,d}}
&gt; io:read("&gt;&gt; ").
&gt;&gt; "hello, world".
{ok,"hello, world"}
</pre>
<p> データの終わりにはピリオドを入力してください。read は Erlang の構文規則にしたがって標準入力からデータを読み込み、それを項に変換して返します。
</p>

<h4>●get_line</h4>
<p> 標準入力から 1 行ずつ読み込む場合、関数 io:get_line/1 を使うと便利です。
</p>
<pre class="item">
io:get_line(Prompt) =&gt; Data | eof | {error, Reason}
</pre>
<p> 引数 Prompt は画面に表示するプロンプトで、文字列かアトムで指定します。省略することはできません。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; io:get_line("&gt;&gt; ").
&gt;&gt; hello, world
"hello, world\n"
</pre>
<p> hello, world と入力してリターンキーを押すと、get_line は入力データを文字列 (リスト) にして返します。このとき、改行文字もいっしょに文字列に格納されます。また、get_line はファイルの終了を検出すると eof を返します。エラーが発生した場合は {error, Reason} を返します。
</p>
<p> それでは簡単な例題として、入力をそのままエコーバックする関数 echo/0 を作ってみましょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : エコーバック

-module(iotest).
-export([echo/0]).

echo() -&gt; 
    case io:get_line("> ") of
        "\n" -&gt; ok;
        Line -&gt; io:fwrite(Line), echo()
    end.
</pre>

<p> 標準入力から get_line で 1 行読み込み、それを io:fwrite で標準出力へ出力します。fwrite は io:format と同じ働きをする関数です。第 1 引数に文字列を与えると、それをそのまま出力します。それから echo を再帰呼び出します。これで echo は無限ループになります。入力された文字列が "\n" の場合は処理を終了します。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
&gt; iotest:echo().
&gt; hello, world
hello, world
&gt; foo bar baz
foo bar baz
&gt; 1234567890
1234567890
&gt;
ok
</pre>
<p> 終了する場合はリターンキーだけを押してください。最後の ok は echo/0 の返り値です。
</p>

<h4>●ファイルのオープンとクローズ</h4>
<p> ファイルにアクセスする場合、次の 3 つの操作が基本になります。
</p>
<ol>
  <li>アクセスするファイルをオープンする
  <li>入出力関数を使ってファイルを読み書きする。
  <li>ファイルをクローズする。
</ol>
<p> 「ファイルをオープンする」とは、アクセスするファイルを指定して、それと 1 対 1に対応するポートを生成することです。入出力関数はオープンしたポートを経由してファイルにアクセスします。Erlang の場合、ファイルのオープンは関数 file:open/2 で行います。
</p>
<pre class="item">
file:open(Filename, Mode) =&gt; {ok, IoDevice} | {error, Reason}
</pre>
<p> open/2 は引数にファイル名 Filename とアクセスモード Mode を指定して、Filename で指定されたファイルに対応する IoDevice を生成して返します。Erlang ではファイルの入出力処理をプロセスで行っていて、open はそのファイルの入出力を行うプロセスの識別子 (Pid) を返します。このほかに「ファイルディスクプリタ」という IoDevice もありますが、本稿では触れません。
</p>
<p> アクセスモード Mode はリストで、要素はアクセスモードを表すアトムになります。要素がひとつしかない場合、リストではなくアトムをそのまま指定してもかまいません。下表に主なアクセスモードを示します。
</p>

<table border=1>
<caption>表 : アクセスモード</caption>
<thead>
  <tr><th>モード</th><th>動作</th></tr>
</thead>
<tbody>
  <tr><td>read </td><td> 読み込み (read) モード</td></tr>
  <tr><td>write </td><td> 書き出し (write) モード</td></tr>
  <tr><td>append </td><td> 追加 (append) モード</td></tr>
  <tr><td>binary </td><td> バイナリの指定</td></tr>
</tbody>
</table>

<p> 読み込みモードの場合、ファイルが存在しないとエラーになります。書き出しモードの場合、ファイルが存在すれば、そのファイルを大きさ 0 に切り詰めてからオープンします。追加モードの場合、ファイルの最後尾にデータを追加します。binary は取り扱うデータをバイナリデータに設定します。
</p>
<p> なお、Windows では「テキストモード」と「バイナリモード」の区別がありますが、Erlang の基本はバイナリモードです。Erlang の場合、行単位で入出力を行う関数において改行の変換が行われます。
</p>

<p> オープンしたファイルは必ずクローズしてください。この操作を行う関数が file:close/1 です。
</p>
<pre class="item">
file:close(IoDevice) =&gt; ok | {error, Reason}
</pre>

<h4>●ファイルの読み込み</h4>
<p> ファイルの読み込みはモジュール file に定義されている関数のほかに、モジュール io の関数でも第 1 引数に IoDevice を指定すると利用することができます。主な入力関数を以下に示します。
</p>
<pre class="item">
io:read(IoDevice, Prompt) =&gt; Result
io:get_line(IoDevice, Prompt) =&gt; Data | eof | {error, Reason}
file:read_line(IoDevice) =&gt; {ok, Data} | eof | {error, Reason}
file:read(IoDevice, Number) =&gt; {ok, Data} | eof | {error, Reason}
file:read_file(Filename) =&gt; {ok, Binary} | {error, Reason}
</pre>
<p> read_line/1 は IoDevice から1 行読み込みます。Windows の場合、改行コードの変換が行われます。file:read/2 は Number で指定した個数だけデータを読み込みます。返り値の Data は、open の Mode で binary を指定するとバイナリに、そうでなければリストになります。read_file/1 は Filename で指定したファイルを全部読み込み、データをバイナリに格納して返します。
</p>
<p> 簡単な例を示します。ファイル test.dat からデータを読み込みます。
</p>
<pre class="fig">
foo
bar
baz
1234
5678

図 : test.dat の内容
</pre>
<pre>
&gt; file:read_file("test.dat").
{ok,&lt;&lt;"foo\r\nbar\r\nbaz\r\n1234\r\n5678\r\n"&gt;&gt;}

&gt; {ok, F} = file:open("test.dat", read).
{ok,&lt;...&gt;}
&gt; file:read_line(F).
{ok,"foo\n"}
&gt; file:read_line(F).
{ok,"bar\n"}
&gt; file:read_line(F).
{ok,"baz\n"}
&gt; file:read_line(F).
{ok,"1234\n"}
&gt; file:read_line(F).
{ok,"5678\n"}
&gt; file:read_line(F).
eof
&gt; file:close(F).
ok
</pre>
<p> read_file/1 を使って test.dat を読み込むと、データを格納したバイナリが返されます。M.Hiroi の実行環境は Windows なので、改行が \r\n で表されていることがわかります。次に、read_line/1 で 1 行ずつ読み込みます。open のモードで binary を指定していないので、データはリストに格納されて返されます。このとき、改行の変換が行われていることに注意してください。
</p>
<p> 次は open のモードで binary を指定してみましょう。
</p>
<pre>
&gt; {ok, F1} = file:open("test.dat", [read, binary]).
{ok,&lt;...&gt;}
&gt; file:read_line(F1).
{ok,&lt;&lt;"foo\n"&gt;&gt;}
&gt; file:read_line(F1).
{ok,&lt;&lt;"bar\n"&gt;&gt;}
&gt; file:read_line(F1).
{ok,&lt;&lt;"baz\n"&gt;&gt;}
&gt; file:read_line(F1).
{ok,&lt;&lt;"1234\n"&gt;&gt;}
&gt; file:read_line(F1).
{ok,&lt;&lt;"5678\n"&gt;&gt;}
&gt; file:read_line(F1).
eof
&gt; file:close(F1).
ok
</pre>
<p> この場合、読み込んだデータはバイナリに格納されて返されます。行単位の入力なので、改行の変換も行われていることに注意してください。
</p>
<p> 次は file:read/2 を使って 6 バイトずつデータを読み込んでみましょう。
</p>
<pre>
&gt; {ok, F2} = file:open("test.dat", read).
{ok,&lt;...&gt;}
&gt; file:read(F2, 6).
{ok,"foo\r\nb"}
&gt; file:read(F2, 6).
{ok,"ar\r\nba"}
&gt; file:read(F2, 6).
{ok,"z\r\n123"}
&gt; file:read(F2, 6).
{ok,"4\r\n567"}
&gt; file:read(F2, 6).
{ok,"8\r\n"}
&gt; file:read(F2, 6).
eof
&gt; file:close(F2).
ok</pre>
<p> open のモードで binary を指定していないので、読み込んだデータはリストに格納されて返されます。file:read/2 では改行の変換が行われないことに注意してください。また、ファイルの最後では、データが足りなくて指定したサイズに満たない場合もあります。
</p>

<p> それでは簡単な例題として、ファイルの内容を画面へ出力する関数 cat/1 を作ってみましょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : ファイルの表示

cat_sub(In) -&gt;
    case file:read_line(In) of
        eof -&gt; ok;
        {ok, Line} -&gt; io:fwrite(Line), cat_sub(In)
    end.

cat(Filename) -&gt;
    case file:open(Filename, read) of
        {error, Reason} -&gt; io:format('file open error ~w~n', [Reason]);
        {ok, In} -&gt; cat_sub(In), file:close(In)
    end.
</pre>
<p> cat/1 の引数 Filename はファイル名を表す文字列です。ファイル Filename をオープンして IoDevice を変数 In にセットします。ファイルの表示は関数 cat_sub/1 で行います。read_line/1 で 1 行読み込み、それを fwrite/1 で標準出力へ出力します。それから cat_sub/1 を再帰呼び出しします。ファイルの終了を検出したら処理を終了します。あとは cat/1 に戻って、close でファイルを閉じるだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
&gt; iotest:cat("test.dat").
foo
bar
baz
1234
5678
ok
</pre>

<h4>●ファイルの書き込み</h4>
<p> データをファイルに書き込むには、ファイルを write モードでオープンします。このとき、注意事項が一つあります。既に同じ名前のファイルが存在している場合は、そのファイルの長さを 0 に切り詰めてからデータを書き込みます。既存のファイルは内容が破壊されることに注意してください。
</p>
<p> モジュール io と file に定義されている主な出力関数を以下に示します。
</p>
<pre class="item">
io:nl(IoDevice) =&gt; ok
io:write(IoDevice, Term) =&gt; ok
io:format(IoDevice, Format, Args) =&gt; ok
file:write(IoDevice, Data) =&gt; ok | {error, Reason}
file:write_file(Filename, Data) =&gt; ok | {error, Reason}
</pre>
<p> Data はリストまたはバイナリで、要素の値はバイナリデータ (0 - 255) になります。なお、リストの要素はバイナリデータを格納したリストまたはバイナリでもかまいません。
</p>
<p> 簡単な例を示します。
</p>
<pre>
&gt; {ok, Out1} = file:open("test.out", write).
{ok,&lt;...&gt;}
&gt; file:write(Out1, "foo").
ok
&gt; file:write(Out1, "bar").
ok
&gt; file:write(Out1, "baz").
ok
&gt; file:write(Out1, ["1234", "5678"]).
ok
&gt; file:close(Out1).
ok
&gt; {ok, Data} = file:read_file("test.out").
{ok,&lt;&lt;"foobarbaz12345678"&gt;&gt;}
&gt; file:write_file("test1.out", Data).
ok
&gt; file:read_file("test1.out").
{ok,&lt;&lt;"foobarbaz12345678"&gt;&gt;}
</pre>
<p> ファイル test.out を write モードでオープンします。write でデータを書き込みますが、このときデータにリストを渡すと、格納された文字列をファイルに書き込みます。test.out をクローズしたあと、read_file/1 で test.out を読み込むと、データが書き込まれていることがわかります。それから、そのデータを write_file/1 でファイル test1.out に書き込みます。read_file/1 で test1.out を読み込むと、正常に書き込まれていることがわかります。
</p>
<p> このほかにも、Erlang にはファイルを操作する便利な関数が多数用意されています。詳しい説明は Erlang のリファレンスマニュアル <a href="http://erlang.org/doc/man/io.html">Erlang -- io</a>, <a href="http://erlang.org/doc/man/file.html">Erlang -- file</a> をお読みください。
</p>
<hr>
<div align="right">
初出 2011 年 11 月 20 日<br>
改訂 2019 年 1 月 6 日
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2011-2019 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcerl06a.html">PrevPage</a> | <a href="erlang.html">Erlang</a> | <a href="abcerl08.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>