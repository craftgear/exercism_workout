<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Haskell プログラミング入門</title>
  <meta name="description" content="Haskell,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881791</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Functional Programming</h1>
<h2>お気楽 Haskell プログラミング入門</h2>
<div class="small">
[ <a href="haskell34.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell36.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Haskell で作る micro Scheme (3)</h3>
<p> micro Scheme の続きです。今回は変数の値を書き換えるシンタックス形式 set! と数値の算術演算と比較演算の処理を作りましょう。
</p>

<h4>●環境の修正</h4>
<p> まず最初に、変数の値を更新できるように環境の定義を修正します。次のリストを見てください。
</p>
<pre class="list">
リスト : 環境の修正

-- ローカル環境の定義
type LEnv = [(String, IORef SExpr)]

-- グローバルな環境
type GEnv = H.HashTable String SExpr

-- 両方の環境を保持する
type Env = (GEnv, LEnv)

-- 評価器の定義
type Scm a = ErrorT String IO a
</pre>
<p> 局所変数を保持する環境 LEnv の場合、変数の値は IORef に格納するように修正します。変数の値を求める、または書き換える場合、IORef の操作関数は値を IO に包んで返すので、Either モナドと IO モナドを同時に使う必要があります。このため、S 式を評価するときに使う型 Scm は Either モナドではなくモナド変換子 ErrorT を使って、Either モナドと IO モナドを合成することにします。
</p>
<p> 大域変数の値を格納する環境 GEnv も Data.Map から Data.HashTable に変更します。HashTable は「ハッシュ表」のことで、IORef と同様に操作関数は値を IO に包んで返します。使い方はあとで詳しく説明します。そして、大域変数の環境と局所変数の環境をタプルにまとめたものを型 Env として定義します。
</p>

<p> 次に、環境 LEnv を操作する関数を作ります。
</p>
<pre class="list">
リスト : 環境 LEnv の操作関数

-- 新しい変数束縛の追加
pushLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO LEnv
pushLEnv s v env = do
  a &lt;- newIORef v
  return ((s, a):env)

-- 変数の値を求める
lookupLEnv :: String -&gt; LEnv -&gt; IO (Maybe SExpr)
lookupLEnv s env = 
  case lookup s env of
    Nothing -&gt; return Nothing
    Just v  -&gt; do a &lt;- readIORef v
                  return (Just a)

-- 変数の値を更新する
updateLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO LEnv
updateLEnv s v env =
  case lookup s env of
    Nothing -&gt; pushLEnv s v env
    Just a  -&gt; do writeIORef a v
                  return env
</pre>
<p> 関数 pushLEnv は変数名 s、値 v、環境 env を受け取り、新しい変数束縛を追加した環境を返します。newIORef v で v を格納した変数 a を生成し、タプル (s, a) を env に追加して返します。返り値の型は IO LEnv になります。
</p>
<p> 関数 lookupLEnv は環境 env の中から変数 s の値を探します。返り値の型は IO (Maybe SExpr) になります。lookup で env から s を探します。見つからない場合は Nothing を IO モナドに包んで返します。見つけた場合は readIORef で値 a を求め、Just a を IO モナドに包んで返します。
</p>
<p> 関数 updateLEnv は変数の値を書き換えます。lookup で変数 s を探します。見つからない場合は pushLEnv で新しい変数束縛を追加します。ただし、今回のプログラムではこの処理を使うことはありません。変数を見つけた場合は、writeIORef で変数の値を v に書き換えます。
</p>

<h4>●Data.HashTable の使い方</h4>
<p> 次は HashTable の使い方を説明します。HashTable のデータ型は次のようになります。
</p>
<pre class="item">
data HashTable key val
</pre>
<p> key がキーを表すデータ、val が値を表すデータです。ハッシュ表 (hash table) はデータを格納する配列と、データを整数値に変換する「ハッシュ関数 (hash function) 」を用意します。この値を「ハッシュ値 (hash value) 」と呼びます。ハッシュ値は配列の添字に対応し、この位置にデータを格納します。つまり、ハッシュ表はハッシュ関数によってデータを格納する位置を決める探索方法となります。
</p>
<p> ハッシュ表のアルゴリズムに興味のある方は、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo04.html">ハッシュ法</a> をお読みください。
</p>
<p> ハッシュ表の主な操作関数を示します。
</p>
<ul>
  <li>new :: (key -&gt; key -&gt; Bool) -&gt; (key -&gt; Int32) -&gt; IO (HashTable key val)
  <li>insert :: HashTable key val -&gt; key -&gt; val -&gt; IO ()
  <li>delete :: HashTable key val -&gt; key -&gt; IO ()
  <li>lookup :: HashTable key val -&gt; key -&gt; IO (Maybe val)
  <li>update :: HashTable key val -&gt; key -&gt; val -&gt; IO Bool
  <li>fromList :: Eq key =&gt; (key -&gt; Int32) -&gt; [(key, val)] -&gt; IO (HashTable key val)
  <li>toList :: HashTable key val -&gt; IO [(key, val)]
  <li>hashInt :: Int -&gt; Int32
  <li>hashString :: String -&gt; Int32
</ul>
<p> new は新しいハッシュ表を生成します。第 1 引数はキーの等値を判定する述語です。キーが型クラス Eq のインスタンスであれば演算子 (==) を指定するだけです。第 2 引数がハッシュ関数です。文字列 (String) と整数 (Int) の場合、あらかじめ用意されているハッシュ関数 hashString と hashInt を指定すればいいでしょう。
</p>
<p> insert はキーと値をハッシュ表に登録します。同じキーを登録した場合、以前の値が残されることに注意してください。以前の値が不要な場合は update を使います。返り値は IO Bool で、新しいキーと値を登録した場合は IO False を、すでに存在するキーの値を更新した場合は IO True を返します。
</p>
<p> delete はハッシュ表からキーとその値を削除します。lookup はハッシュ表からキーの値を探します。fromList は連想リストからハッシュ表を生成します。等値を判定する述語には演算子 (==) が用いられます。toList はハッシュ表を連想リストに変換します。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
Prelude Data.HashTable&gt; ht &lt;- new (==) hashString :: IO (HashTable String Int
Prelude Data.HashTable&gt; toList ht
[]
Prelude Data.HashTable&gt; insert ht "foo" 10
Prelude Data.HashTable&gt; insert ht "bar" 20
Prelude Data.HashTable&gt; insert ht "baz" 30
Prelude Data.HashTable&gt; toList ht
[("baz",30),("bar",20),("foo",10)]
Prelude Data.HashTable&gt; Data.HashTable.lookup ht "foo"
Just 10
Prelude Data.HashTable&gt; Data.HashTable.lookup ht "oops"
Nothing
</pre>
<p> new でハッシュ表を生成し、"foo", "bar", "baz" を登録します。toList でハッシュ表を連想リストに変換すると、3 つのキーと値が登録されていることがわかります。lookup で "foo" を探すと Just 10 が返されます。"oops" は見つからないので Nothing が返されます。
</p>
<pre>
Prelude Data.HashTable&gt; insert ht "baz" 40
Prelude Data.HashTable&gt; toList ht
[("baz",40),("baz",30),("bar",20),("foo",10)]
Prelude Data.HashTable&gt; Data.HashTable.lookup ht "baz"
Just 40
Prelude Data.HashTable&gt; delete ht "baz"
Prelude Data.HashTable&gt; toList ht
[("bar",20),("foo",10)]
</pre>
<p> 次に、insert で "baz" と 40 を登録します。toList で変換すると、以前の値が残されていることがわかります。lookup で検索すると、最新の値 Just 40 が返されます。delete で "baz" を削除すると、以前の値もいっしょに削除されます。
</p>
<pre>
Prelude Data.HashTable&gt; update ht "foo" 100
True
Prelude Data.HashTable&gt; toList ht
[("bar",20),("foo",100)]
Prelude Data.HashTable&gt; update ht "baz" 200
False
Prelude Data.HashTable&gt; toList ht
[("baz",200),("bar",20),("foo",100)]
</pre>
<p> 次に、update で "foo" の値を 100 に変更します。True が返されたので、"foo" の値は更新されました。toList で変換すると、"foo" の値が 100 に書き換えられていることがわかります。update で "baz" 200 を登録すると、新しいキーなので False が返されます。
</p>

<h4>●S 式の評価</h4>
<p> 次は S 式を評価する関数を修正します。前回のプログラムでは評価結果と大域変数の環境を返していましたが、ハッシュ表は値を破壊的に更新するので、大域変数の環境を返す必要はありません。関数の型は次のように評価結果だけを返すことになります。
</p>
<pre class="item">
eval :: Env -&gt; SExpr -&gt; Scm SExpr
evalArguments :: Env -&gt; SExpr -&gt; Scm SExpr
makeBindings :: LEnv -&gt; SExpr -&gt; SExpr -&gt; Scm LEnv
apply :: Env -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
</pre>
<p> 最初に関数 eval を修正します。
</p>
<pre class="list">
リスト : S 式の評価

eval :: Env -&gt; SExpr -&gt; Scm SExpr
eval env NIL        = return NIL
eval env v@(INT _)  = return v
eval env v@(REAL _) = return v
eval env v@(STR _)  = return v
eval env (SYM name) = do
  a &lt;- liftIO $ lookupLEnv name $ snd env
  case a of
    Nothing -&gt; do b &lt;- liftIO $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just v  -&gt; return v
    Just v -&gt; return v
eval env (CELL func args) = do
  v &lt;- eval env func
  case v of
    SYNT f -&gt; f env args
    _      -&gt; do vs &lt;- evalArguments env args
                 apply env v vs
</pre>
<p> 変数の値を求める処理を修正します。局所変数の値を求めるとき、lookupLEnv を liftIO で持ち上げていることに注意してください。同様に、大域変数の値を求めるときは、H.lookup を liftIO で持ち上げます。
</p>

<p> 次は関数 makeBindings を修正します。
</p>
<pre class="list">
リスト : 変数束縛

makeBindings :: LEnv -&gt; SExpr -&gt; SExpr -&gt; Scm LEnv
makeBindings lenv NIL        _    = return lenv
makeBindings lenv (SYM name) rest = liftIO $ pushLEnv name rest lenv
makeBindings lenv (CELL (SYM name) parms) (CELL v args) = do
  lenv' &lt;- makeBindings lenv parms args
  liftIO (pushLEnv name v lenv')
makeBindings lenv _ NIL = throwError $ strMsg errNEA
makeBindings lenv _ _   = throwError $ strMsg "invalid arguments form"
</pre>
<p> 新しい変数束縛を追加するときは pushLEnv を呼び出しますが、このとき liftIO で持ち上げることに注意してください。
</p>

<h4>●set! の実装</h4>
<p> Scheme の場合、シンボルに値を代入する操作は define だけではありません。Scheme には set! というシンタックス形式があり、シンボルの値を書き換えることができます。簡単な例を示しましょう。
</p>
<pre>
gosh&gt; (set! a 10)
***ERROR : symbol not defined: #<identifier user#a>
Stack Trace:
・・・省略・・・

gosh&gt; (define a 10)
a
gosh&gt; a
10
gosh&gt; (set! a 20)
20
gosh&gt; a
20
</pre>
<p> set! は未定義のシンボルに値をセットすることはできません。define は新しい変数を束縛して値を代入することができますが、set! は値を書き換えることしかできないのです。最初に define で a に 10 をセットします。その後、set! で a の値を 20 に書き換えることができます。set! の返り値は Scheme の仕様書 (R5RS) では未定義ですが、Gauche ではセットした値を返します。micro Scheme も Gauche と同様にセットした値を返すことにします。
</p>

<p> なお、Scheme の場合、値を書き換える関数には ! マークを付けて注意を促す習慣があります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : シンタックス形式 set!

evalSet :: Env -&gt; SExpr -&gt; Scm SExpr
evalSet env (CELL (SYM name) (CELL expr _)) = do
  v &lt;- eval env expr
  a &lt;- liftIO $ lookupLEnv name (snd env)
  case a of
    Nothing -&gt; do b &lt;- liftIO $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just _ -&gt; do liftIO $ H.update (fst env) name v
                                 return v
    Just _  -&gt; do liftIO $ updateLEnv name v (snd env)
                  return v
evalSet _ _ = throwError (strMsg "invalid set! form")
</pre>
<p> 関数 evalSet は第 2 引数の S 式 expr を eval で評価して値 v を求めます。それから、lookupLEnv で変数名 name の局所変数があるか調べます。見つけた場合は updateLEnv で name の値を v に変更します。lookupLEnv と updateLEnv は liftIO で持ち上げることに注意してください。
</p>
<p> 局所変数ではない場合、H.lookup で大域変数の中から変数 name を探します。name を見つけた場合、H.update で name の値を v に更新します。見つからない場合はエラーを返します。ハッシュ表の操作関数も liftIO で持ち上げることに注意してください。
</p>

<h4>●算術演算</h4>
<p> 次は算術演算の処理を作りましょう。今回の micro Scheme は数の型が整数と実数しかないので、電卓プログラムと同様に整数同士の演算は整数とし、整数と実数の演算は整数を実数に変換してから行うことにします。
</p>
<p> Lisp / Scheme の場合、算術演算を行う関数 +, -, *, / は複数の引数を受け取ることができます。簡単な例を示しましょう。
</p>
<pre class="item">
(+)           =&gt; 0
(+ 1)         =&gt; 1
(+ 1 2 3)     =&gt; 6
(+ 1 2 3 4.5) =&gt; 10.5

(*)           =&gt; 1
(* 1)         =&gt; 1
(* 1 2 3)     =&gt; 6
(* 1 2 3 4.5) =&gt; 27.0

(- 1)         =&gt; -1
(- 10 5 4)    =&gt; 1
(- 10 4.5)    =&gt; 5.5
(-)           =&gt; エラー  ; 引数が足りない
</pre>
<p> / は割り算を行います。Scheme の場合、整数同士の割り算で割り切れない場合は分数になりますが、micro Scheme は分数をサポートしていないので、Haskell の演算子 div と同じく結果を整数で返すことにします。簡単な例を示します。
</p>
<pre class="item">
(/ 2.0)   =&gt; 0.5    ; 引数の逆数を求める
(/ 8 4 2) =&gt; 1
(/)       =&gt; エラー ; 引数が足りない
(/ 1 0)   =&gt; エラー ; 0 で除算
</pre>
<p> 加算のプログラムは次のようになります。
</p>
<pre class="list">
リスト : 算術演算 (加算)

-- 畳み込み
foldCell :: (SExpr -&gt; SExpr -&gt; Scm SExpr) -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
foldCell _ a NIL = return a
foldCell f a (CELL x rest) = do v &lt;- f a x
                                foldCell f v rest
foldCell _ _ _ = throwError $ strMsg $ errCELL

-- 加算
add :: SExpr -&gt; SExpr -&gt; Scm SExpr
add (INT x)  (INT y)  = return (INT (x + y))
add (INT x)  (REAL y) = return (REAL (fromIntegral x + y))
add (REAL x) (INT y)  = return (REAL (x + fromIntegral y))
add (REAL x) (REAL y) = return (REAL (x + y))
add _        _        = throwError $ strMsg $ "+ : " ++ errNUM

adds :: SExpr -&gt; Scm SExpr
adds xs = foldCell add (INT 0) xs
</pre>
<p> 関数 foldCell はコンスセルに対して畳み込みを行う関数です。モナディック関数 foldM と同様の動作になります。foldCell を用意すると、四則演算の処理は簡単です。たとえば加算の場合、2 つの引数を加算する関数 add を作ります。あとは、foldCell に add を渡してコンスセルの要素を加算するだけです。初期値に INT 0 を渡しているので、引数が無い場合は 0 を返すことになります。
</p>
<p> 他の演算処理は簡単なので説明は割愛します。詳細は <a href="haskell35.html#list1">プログラムリスト</a> をお読みください。
</p>
<h4>●比較演算</h4>
<p> 次は数値の比較演算処理を作りましょう。Lisp / Scheme の場合、数値の比較演算は複数の引数を受け取ることができます。
</p>
<pre class="item">
 1. = N1 N2 N3 ...  ==&gt; （N1 ＝ N2 ＝ N3 ＝ .... ）
    引数がすべて等しければ true を、それ以外であれば false を返す。
 2. &lt; N1 N2 N3 ... ==&gt; （N1 ＜ N2 ＜ N3 ＜ .... ）
    引数を左から見て、単調に増加していれば true を、それ以外であれば false を返す。
 3. &gt; N1 N2 N3 ... ==&gt; （N1 ＞ N2 ＞ N3 ＞ .... ）
    引数を左から見て、単調に減少していれば true を、それ以外であれば false を返す。
 4. &lt;= N1 N2 N3 ... ==&gt; （N1 ≦ N2 ≦ N3 ≦ .... ）
    引数を左から見て、単調に減少していなければ true を、それ以外であれば false を返す。
 5. &gt;= N1 N2 N3 ... ==&gt; （N1 ≧ N2 ≧ N3 ≧ .... ）
    引数を左から見て、単調に増加していなければ true を、それ以外であれば false を返す。
</pre>
<p> これらの述語は、右側に書いた数式の関係を満たせば true を返し、そうでなければ false を返します。整数と実数の比較は整数を実数に変換してから行うもとのします。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 数値の比較演算子

compareNum :: SExpr -&gt; SExpr -&gt; Scm Ordering
compareNum (INT x)  (INT y)  = return $ compare x y
compareNum (INT x)  (REAL y) = return $ compare (fromIntegral x) y
compareNum (REAL x) (INT y)  = return $ compare x (fromIntegral y)
compareNum (REAL x) (REAL y) = return $ compare x y
compareNum _ _ = throwError $ strMsg errNUM

compareNums :: (Ordering -&gt; Bool) -&gt; SExpr -&gt; Scm SExpr
compareNums _ NIL          = throwError $ strMsg errNEA
compareNums _ (CELL _ NIL) = throwError $ strMsg errNEA
compareNums p (CELL x (CELL y NIL)) = do
  r &lt;- compareNum x y
  if p r then return true else return false
compareNums p (CELL x ys@(CELL y _)) = do
  r &lt;- compareNum x y
  if p r then compareNums p ys else return false
compareNums _ _ = throwError $ strMsg "invalid function form"

eqNum, ltNum, gtNum, ltEq, gtEq :: SExpr -&gt; Scm SExpr
eqNum = compareNums (== EQ)
ltNum = compareNums (== LT)
gtNum = compareNums (== GT)
ltEq  = compareNums (&lt;= EQ)
gtEq  = compareNums (&gt;= EQ)
</pre>
<p> 関数 compareNum は 2 つの引数を比較して Ordering (LT, EQ, GT) を返します。関数 compareNums はコンスセルに格納されている要素を順番に比較して、すべての要素が述語 p を満たしていれば true を、満たしていなければ false を返します。関数 eqNum, ltNum, gtNum, ltEq, gtEq は、それぞれ関数 =, &lt;, &gt;, &lt;=, &gt;= に対応します。
</p>
<p> 主な修正はこれだけです。あとの処理は簡単なので説明は割愛します。詳細は <a href="haskell35.html#list1">プログラムリスト</a> をお読みください。
</p>
<h4>●簡単な実行例</h4>
<p> それでは実行してみましょう。プログラムは GHC で最適化オプションを付けてコンパイルしてください。M.Hiroi は -O2 を付けてコンパイルしました。
</p>
<p> 最初は算術演算です。
</p>
<pre>
Scm&gt; (+)
0
Scm&gt; (+ 1)
1
Scm&gt; (+ 1 2)
3
Scm&gt; (+ 1 2 3 4 5)
15
Scm&gt; (+ 1 2 3.0 4 5)
15.0
Scm&gt; (*)
1
Scm&gt; (* 1)
1
Scm&gt; (* 1 2)
2
Scm&gt; (* 1 2 3 4 5)
120
Scm&gt; (* 1 2 3.0 4 5)
120.0
Scm&gt; (-)
- : Not enough arguments
Scm&gt; (- 1)
-1
Scm&gt; (- 1 2)
-1
Scm&gt; (- 1 2 3)
-4
Scm&gt; (- 1 2.0 3)
-4.0
Scm&gt; (/)
/ : Not enough arguments
Scm&gt; (/ 2.0)
0.5
Scm&gt; (/ 8 4)
2
Scm&gt; (/ 8 4 2)
1
Scm&gt; (/ 8 4 2.0)
1.0
</pre>
<p> 正常に動作していますね。次は比較演算子です。
</p>
<pre>
Scm&gt; (= 1 1)
true
Scm&gt; (= 1 2)
false
Scm&gt; (= 1 1 1 1 1)
true
Scm&gt; (= 1 1 1.0 1 1)
true
Scm&gt; (= 1 1)
true
Scm&gt; (= 1 2)
false
Scm&gt; (= 1 1 1 1 1)
true
Scm&gt; (= 1 1 1.0 1 1)
true
Scm&gt; (&lt; 1 2 3 4 5)
true
Scm&gt; (&gt; 1 2 3 4 5)
false
Scm&gt; (&lt;= 1 2 3 4 5)
true
Scm&gt; (&lt;= 1 2 3 3 4 4 5)
true
Scm&gt; (&gt;= 1 2 3 3 4 4 5)
false
</pre>
<p> これも正常に動作していますね。次は再帰定義で階乗とフィボナッチ関数の値を求めてみましょう。
</p>
<pre>
Scm&gt; (define fact (lambda (x) (if (= x 0) 1 (* x (fact (- x 1))))))
fact
Scm&gt; (fact 9)
362880
Scm&gt; (fact 10)
3628800
Scm&gt; (fact 20)
2432902008176640000
Scm&gt; (fact 50)
30414093201713378043612608166064768844377641568960512000000000000
</pre>
<pre>
Scm&gt; (define fibo (lambda (n) (if (&lt; n 2) 1 (+ (fibo (- n 1)) (fibo (- n 2))))))
fibo
Scm&gt; (fibo 1)
1
Scm&gt; (fibo 2)
2
Scm&gt; (fibo 3)
3
Scm&gt; (fibo 4)
5
Scm&gt; (fibo 5)
8
Scm&gt; (fibo 10)
89
Scm&gt; (fibo 20)
10946
Scm&gt; (fibo 30)
1346269
</pre>
<p> 正常に動作していますね。
</p>
<p> 次は set! で変数の値を書き換えます。
</p>
<pre>
Scm&gt; a
unbound variable: a
Scm&gt; (set! a 10)
unbound variable: a
Scm&gt; (define a 10)
a
Scm&gt; (set! a 100)
100
Scm&gt; a
100
Scm&gt; x
unbound variable: x
Scm&gt; ((lambda (x) (set! x (+ x 10)) x) 100)
110
Scm&gt; x
unbound variable: x
</pre>
<p> 大域変数と局所変数ともに set! で書き換えることができます。また、クロージャが保存している値も set! で書き換えることができます。
</p>
<pre>
Scm&gt; (define foo (lambda (x) (lambda () (set! x (+ x 1)))))
foo
Scm&gt; (define foo10 (foo 10))
foo10
Scm&gt; (foo10)
11
Scm&gt; (foo10)
12
Scm&gt; (foo10)
13
Scm&gt; (foo10)
14
Scm&gt; (foo10)
15
</pre>
<p> クロージャを使うと、フィボナッチ関数の値を返すジェネレータも簡単に作成することができます。
</p>
<pre>
Scm&gt; (define fibogen (lambda (a b c) (lambda () (set! a (+ b c)) (set! c b) (set! b a))))
fibogen
Scm&gt; (define g (fibogen 0 0 1))
g
Scm&gt; (g)
1
Scm&gt; (g)
1
Scm&gt; (g)
2
Scm&gt; (g)
3
Scm&gt; (g)
5
Scm&gt; (g)
8
Scm&gt; (g)
13
Scm&gt; (g)
21
Scm&gt; (g)
34
Scm&gt; (g)
55
Scm&gt; (g)
89
</pre>
<h4>●末尾再帰最適化</h4>
<p> 最後に「末尾再帰最適化」について考えてみましょう。Haskell が末尾再帰最適化を行う場合、ある条件で eval が末尾再帰していれば、micro Scheme も末尾再帰最適化が行われます。なお、ここでいう末尾再帰最適化は処理速度のことではなく、次に示すような関数呼び出しにおいて、スタックを消費せずに実行できることです。
</p>
<pre>
Scm&gt; (define foo (lambda () (foo)))
foo
Scm&gt; (foo)
=&gt; 無限ループになる
</pre>
<p> 末尾再帰最適化が行われる場合、foo を評価すると無限ループになります。実際、micro Scheme で foo を評価すると無限ループになります。
</p>

<p> 末尾再帰の末尾とは最後に行われる処理のことで、一般に末尾で関数を呼び出すことを「末尾呼び出し」といいます。関数を呼び出す場合、返ってきた後に行う処理のために、必要な情報を保存しておかなければいけません。ところが、末尾呼び出しはそのあと実行する処理がないので、情報を保存しておく必要がありません。このため、末尾再帰は繰り返しに変換することができるのです。
</p>

<p> micro Scheme で S 式を評価するとき、末尾呼び出しが行われる場所は evalIf と evalBody の 2 か所しかありません。次のリストを見てください。
</p>
<pre class="list">
リスト : 末尾呼び出しの処理

evalIf :: Env -&gt; SExpr -&gt; Scm SExpr
evalIf env (CELL pred (CELL thenForm rest)) = do
  v &lt;- eval env pred
  if v /= false
  then eval env thenForm
  else case rest of
         CELL elseForm _ -&gt; eval env elseForm
         _               -&gt; return false
evalIf _ _ = throwError $ strMsg $ "if : " ++ errNEA


evalBody :: Env -&gt; SExpr -&gt; Scm SExpr
evalBody env (CELL expr NIL) = eval env expr
evalBody env (CELL expr rest) = do
  eval env expr
  evalBody env rest
evalBody _ _ = throwError $ strMsg "invalid body form"
</pre>
<p> evalIf は条件部を評価したあと、then 節か else 節を評価しますが、そのあと評価する S 式はありません。どちらの節を評価するにしても末尾で eval を呼び出しているので、eval は evalIf を経由していますが末尾再帰になっています。
</p>

<p> evalBody の場合も同様です。最後の S 式を評価するときの eval は末尾呼び出しになっているので、apply と evalBody を経由して eval は末尾再帰になります。このように eval を末尾再帰でプログラムすると、Haskell が末尾再帰最適化を行ってくれれば、micro Scheme で S 式を評価するときに末尾再帰最適化が行われます。
</p>

<h4>●正格性フラグ</h4>
<p> ここで、Haskell は遅延評価を行う処理系であることを思い出してください。たとえば、加算を行う add の処理で、INT (x + y) の x + y は遅延評価されます。このため、次のようなプログラムはスタックオーバーフローが発生して末尾再帰にはなりません。
</p>

<pre class="list">
リスト : n から m までの合計値を求める

(define sum
  (lambda (n m a)
    (if (&gt; n m)
        a
      (sum (+ n 1) m (+ a n)))))
</pre>
<p> 関数 sum は末尾再帰になっています。ところが、加算の処理で遅延評価が行われると、累積変数 a の値を返すまで (+ a n) の処理が蓄積されるため、スタックオーバーフローになるのです。
</p>
<p> この場合、正格性フラグ ! を使うと簡単に正格評価を行うことできます。
</p>
<pre class="list">
リスト : S 式のデータ型

data SExpr = INT  !Integer
           | REAL !Double
           | SYM  String
           | STR  String
           | CELL SExpr SExpr
           | NIL
           | PRIM (SExpr -&gt; Scm SExpr)
           | SYNT (Env -&gt; SExpr -&gt; Scm SExpr)
           | CLOS SExpr LEnv
</pre>
<p> 正格性フラグ ! は data 宣言の中で使用することができます。SExpr の中で INT !Integer と REAL !Double の二箇所に正格性フラグを使っています。これで、算術演算で INT と REAL に値を格納するとき、たとえば INT (x + y) の式 x + y は正格評価されます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
Scm&gt; (define sum (lambda (n m a) (if (&gt; n m) a (sum (+ n 1) m (+ a n)))))
sum
Scm&gt; (sum 1 10000 0)
50005000
Scm&gt; (sum 1 100000 0)
5000050000
Scm&gt; (sum 1 1000000 0)
500000500000
Scm&gt; (sum 1 10000000 0)
50000005000000
</pre>
<p> 正格評価フラグを設定しないと、次のようにスタックオーバーフローが発生します。
</p>
<pre>
Scm&gt; (sum 1 10000 0)
50005000
Scm&gt; (sum 1 100000 0)
5000050000
Scm&gt; (sum 1 1000000 0)
Stack space overflow: current size 8388608 bytes.
Use `+RTS -Ksize -RTS' to increase it.
</pre>
<p> Scheme のプログラムが末尾再帰でなければ、正格性フラグをつけてもスタックオーバーフローします。
</p>
<pre>
Scm&gt; (define sum (lambda (n m) (if (&gt; n m) 0 (+ n (sum (+ n 1) m)))))
sum
Scm&gt; (sum 1 10000)
50005000
Scm&gt; (sum 1 100000)
5000050000
Scm&gt; (sum 1 1000000)
Stack space overflow: current size 8388608 bytes.
Use `+RTS -Ksize -RTS' to increase it.
</pre>
<p> 関数 sum は末尾再帰ではないので、大きな値を計算すると当然ですがスタックオーバーフローします。
</p>
<p> 今回はここまでです。次回は micro Scheme に「伝統的なマクロ」を追加しましょう。
</p>
<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li>黒川利明, 『LISP 入門』, 培風館, 1982
  <li>Patrick Henry Winston, Berthold Klaus Paul Horn, 『LISP 原書第 3 版 (1)』, 培風館, 1992<br>
18. Lisp で書く Lisp
  <li>R. Kent Dybvig (著), 村上雅章 (訳), 『プログラミング言語 SCHEME』, 株式会社ピアソン・エデュケーション, 2000<br>
9.2 Scheme のメタ循環インタプリタ
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995<br>
第 11 章 定義インタプリタ
  <li>小西弘一, 清水剛, 『ＣプログラムブックⅢ』, アスキー, 1986
  <li>Harold Abelson, Gerald Jay Sussman, Julie Sussman, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">"Structure and Interpretation of Computer Programs"</a>, <br><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1">4.1  The Metacircular Evaluator</a>
  <li><a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/index-j.html">稲葉雅幸</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/index-j.html">ソフトウェア特論</a>, <a href="http://www.jsk.t.u-tokyo.ac.jp/~inaba/soft4/soft4-scheme-interp/index.html">Scheme インタプリタ</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
--
-- mscheme.hs : microScheme
--
--              Copyright (C) 2013 Makoto Hiroi
--
import Data.Char
import Data.IORef
import qualified Data.HashTable as H
import Control.Monad.Error
import System.IO

-- S 式の定義
data SExpr = INT  !Integer
           | REAL !Double
           | SYM  String
           | STR  String
           | CELL SExpr SExpr
           | NIL
           | PRIM (SExpr -&gt; Scm SExpr)
           | SYNT (Env -&gt; SExpr -&gt; Scm SExpr)
           | CLOS SExpr LEnv

-- 等値の定義
instance Eq SExpr where
  INT x  == INT y  = x == y
  REAL x == REAL y = x == y
  SYM x  == SYM y  = x == y
  STR x  == STR y  = x == y
  NIL    == NIL    = True
  _      == _      = False

-- パーサエラーの定義
data ParseErr = ParseErr String String deriving Show

instance Error ParseErr where
  noMsg    = ParseErr "" ""
  strMsg s = ParseErr "" s

-- パーサの定義
type Parser a = Either ParseErr a

-- 評価器の定義
type Scm a = ErrorT String IO a

-- ローカル環境の定義
type LEnv = [(String, IORef SExpr)]

pushLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO LEnv
pushLEnv s v env = do
  a &lt;- v `seq` newIORef v
  return ((s, a):env)

lookupLEnv :: String -&gt; LEnv -&gt; IO (Maybe SExpr)
lookupLEnv s env = 
  case lookup s env of
    Nothing -&gt; return Nothing
    Just v  -&gt; do a &lt;- readIORef v
                  return (Just a)

updateLEnv :: String -&gt; SExpr -&gt; LEnv -&gt; IO (LEnv)
updateLEnv s v env =
  case lookup s env of
    Nothing -&gt; pushLEnv s v env
    Just a  -&gt; do writeIORef a v
                  return env

-- グローバルな環境
type GEnv = H.HashTable String SExpr

-- 両方の環境を保持する
type Env = (GEnv, LEnv)

-- 真偽値
true  = SYM "true"
false = SYM "false"

-- Primitive の定義
errNUM  = "Illegal argument, Number required"
errINT  = "Illegal argument, Integer required"
errNEA  = "Not enough arguments"
errCELL = "Illegal argument, List required"
errZERO = "Divide by zero"

-- リスト操作
car :: SExpr -&gt; Scm SExpr
car NIL = throwError $ strMsg $ "car : " ++ errNEA
car (CELL (CELL a _) _) = return a
car _                   = throwError $ strMsg $ "car : " ++ errCELL

cdr :: SExpr -&gt; Scm SExpr
cdr NIL = throwError $ strMsg $ "cdr : " ++ errNEA
cdr (CELL (CELL _ d) _) = return d
cdr _                   = throwError $ strMsg $ "cdr : " ++ errCELL

cons :: SExpr -&gt; Scm SExpr
cons (CELL a (CELL b _)) = return (CELL a b)
cons _                   = throwError $ strMsg $ "cons : " ++ errNEA

pair :: SExpr -&gt; Scm SExpr
pair NIL                 = throwError $ strMsg $ "pair? : " ++ errNEA
pair (CELL (CELL _ _) _) = return true
pair _                   = return false

-- 畳み込み
foldCell :: (SExpr -&gt; SExpr -&gt; Scm SExpr) -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
foldCell _ a NIL = return a
foldCell f a (CELL x rest) = do v &lt;- f a x
                                foldCell f v rest
foldCell _ _ _ = throwError $ strMsg $ errCELL

-- 四則演算
add :: SExpr -&gt; SExpr -&gt; Scm SExpr
add (INT x)  (INT y)  = return (INT (x + y))
add (INT x)  (REAL y) = return (REAL (fromIntegral x + y))
add (REAL x) (INT y)  = return (REAL (x + fromIntegral y))
add (REAL x) (REAL y) = return (REAL (x + y))
add _        _        = throwError $ strMsg $ "+ : " ++ errNUM

adds :: SExpr -&gt; Scm SExpr
adds xs = foldCell add (INT 0) xs

sub :: SExpr -&gt; SExpr -&gt; Scm SExpr
sub (INT x)  (INT y)  = return (INT (x - y))
sub (INT x)  (REAL y) = return (REAL (fromIntegral x - y))
sub (REAL x) (INT y)  = return (REAL (x - fromIntegral y))
sub (REAL x) (REAL y) = return (REAL (x - y))
sub _        _        = throwError $ strMsg $ "- : " ++ errNUM

subs :: SExpr -&gt; Scm SExpr
subs NIL = throwError $ strMsg $ "- : " ++ errNEA
subs (CELL (INT a) NIL)  = return (INT (-a))
subs (CELL (REAL a) NIL) = return (REAL (-a))
subs (CELL a rest) = foldCell sub a rest

mul :: SExpr -&gt; SExpr -&gt; Scm SExpr
mul (INT x)  (INT y)  = return (INT (x * y))
mul (INT x)  (REAL y) = return (REAL (fromIntegral x * y))
mul (REAL x) (INT y)  = return (REAL (x * fromIntegral y))
mul (REAL x) (REAL y) = return (REAL (x * y))
mul _        _        = throwError $ strMsg $ "- : " ++ errNUM

muls :: SExpr -&gt; Scm SExpr
muls xs = foldCell mul (INT 1) xs

div' :: SExpr -&gt; SExpr -&gt; Scm SExpr
div' _        (INT 0)  = throwError $ strMsg errZERO
div' _        (REAL 0) = throwError $ strMsg errZERO
div' (INT x)  (INT y)  = return (INT (x `div` y))
div' (INT x)  (REAL y) = return (REAL (fromIntegral x / y))
div' (REAL x) (INT y)  = return (REAL (x / fromIntegral y))
div' (REAL x) (REAL y) = return (REAL (x / y))
div' _        _        = throwError $ strMsg $ "- : " ++ errNUM

divs :: SExpr -&gt; Scm SExpr
divs NIL = throwError $ strMsg $ "/ : " ++ errNEA
divs (CELL a NIL)  = div' (INT 1) a
divs (CELL a rest) = foldCell div' a rest

mod' :: SExpr -&gt; Scm SExpr
mod' NIL          = throwError $ strMsg $ "mod : " ++ errNEA
mod' (CELL _ NIL) = throwError $ strMsg $ "mod : " ++ errNEA
mod' (CELL _ (CELL (INT 0) _))  = throwError $ strMsg errZERO
mod' (CELL _ (CELL (REAL 0) _)) = throwError $ strMsg errZERO
mod' (CELL (INT x) (CELL (INT y) _)) = return (INT (mod x y))
mod' _ = throwError $ strMsg $ "mod : " ++ errINT

-- 等値の判定
eq' :: SExpr -&gt; Scm SExpr
eq' (CELL x (CELL y _)) =
  if x == y then return true else return false
eq' _ = throwError $ strMsg $ "eq : " ++ errNEA

equal' :: SExpr -&gt; Scm SExpr
equal' (CELL x (CELL y _)) =
  if iter x y then return true else return false
  where iter (CELL a b) (CELL c d) = iter a c &amp;&amp; iter b d
        iter x y = x == y
equal' _ = throwError $ strMsg $ "equal : " ++ errNEA

-- 数値の比較演算子
compareNum :: SExpr -&gt; SExpr -&gt; Scm Ordering
compareNum (INT x)  (INT y)  = return $ compare x y
compareNum (INT x)  (REAL y) = return $ compare (fromIntegral x) y
compareNum (REAL x) (INT y)  = return $ compare x (fromIntegral y)
compareNum (REAL x) (REAL y) = return $ compare x y
compareNum _ _ = throwError $ strMsg errNUM

compareNums :: (Ordering -&gt; Bool) -&gt; SExpr -&gt; Scm SExpr
compareNums _ NIL          = throwError $ strMsg errNEA
compareNums _ (CELL _ NIL) = throwError $ strMsg errNEA
compareNums p (CELL x (CELL y NIL)) = do
  r &lt;- compareNum x y
  if p r then return true else return false
compareNums p (CELL x ys@(CELL y _)) = do
  r &lt;- compareNum x y
  if p r then compareNums p ys else return false
compareNums _ _ = throwError $ strMsg "invalid function form"

eqNum, ltNum, gtNum, ltEq, gtEq :: SExpr -&gt; Scm SExpr
eqNum = compareNums (== EQ)
ltNum = compareNums (== LT)
gtNum = compareNums (== GT)
ltEq  = compareNums (&lt;= EQ)
gtEq  = compareNums (&gt;= EQ)

--
-- S 式の表示
--
showCell :: SExpr -&gt; String
showCell (CELL a d) =
  show a ++ case d of
              NIL      -&gt; ""
              PRIM _   -&gt; "&lt;primitive&gt;"
              CLOS _ _ -&gt; "&lt;closure&gt;"
              SYNT _   -&gt; "&lt;syntax&gt;"
              INT x    -&gt; " . " ++ show x
              REAL x   -&gt; " . " ++ show x
              SYM x    -&gt; " . " ++ x
              STR x    -&gt; " . " ++ show x
              _        -&gt; " " ++ showCell d
showCell xs = show xs

instance Show SExpr where
  show (INT x)    = show x
  show (REAL x)   = show x
  show (SYM x)    = x
  show (STR x)    = show x
  show NIL        = "()"
  show (SYNT _)   = "&lt;syntax&gt;"
  show (PRIM _)   = "&lt;primitive&gt;"
  show (CLOS _ _) = "&lt;closure&gt;"
  show xs         = "(" ++ showCell xs ++ ")"

--
-- S 式の読み込み
--

isAlpha' :: Char -&gt; Bool
isAlpha' x = elem x "!$%&amp;*+-/:&lt;=&gt;?@^_~"

isIdent0 :: Char -&gt; Bool
isIdent0 x = isAlpha x || isAlpha' x

isIdent1 :: Char -&gt; Bool
isIdent1 x = isAlphaNum x || isAlpha' x

isREAL :: Char -&gt; Bool
isREAL x = elem x ".eE"

quote = SYM "quote"

isNUM :: String -&gt; Bool
isNUM (x:_) = isDigit x
isNUM _     = False

getNumber :: String -&gt; Parser (SExpr, String)
getNumber xs =
  let (s, ys) = span isDigit xs
  in if not (null ys) &amp;&amp; isREAL (head ys)
     then case reads xs of
            [] -&gt; throwError noMsg  -- ありえないエラー
            [(y', ys')] -&gt; return (REAL y', ys')
     else return (INT (read s), ys)

readSExpr :: String -&gt; Parser (SExpr, String)
readSExpr [] = throwError $ strMsg "EOF"
readSExpr (x:xs) 
  | isSpace x  = readSExpr xs
  | isDigit x  = getNumber (x:xs)
  | isIdent0 x = if x == '+' &amp;&amp; isNUM xs
                 then getNumber xs
                 else if x == '-' &amp;&amp; isNUM xs
                 then do (y, ys) &lt;- getNumber xs
                         case y of
                           INT x  -&gt; return (INT  (- x), ys)
                           REAL x -&gt; return (REAL (- x), ys)
                 else let (name, ys) = span isIdent1 (x:xs)
                      in return (SYM name, ys)
  | otherwise  =
      case x of
        '('  -&gt; readCell 0 xs
        ';'  -&gt; readSExpr $ dropWhile (/= '\n') xs
        '"'  -&gt; case reads (x:xs) of
                  [] -&gt; throwError noMsg
                  [(y, ys)] -&gt; return (STR y, ys)
        '\'' -&gt; readSExpr xs &gt;&gt;= \(e, ys) -&gt; return (CELL quote (CELL e NIL), ys)
        _    -&gt; throwError $ ParseErr xs ("unexpected token: " ++ show x)

readCell :: Int -&gt; String -&gt; Parser (SExpr, String)
readCell _ [] = throwError $ strMsg "EOF"
readCell n (x:xs)
  | isSpace x = readCell n xs
  | otherwise =
      case x of
        ')' -&gt; return (NIL, xs)
        '.' -&gt; if n == 0
               then throwError $ ParseErr xs "invalid dotted list"
               else do (e, ys) &lt;- readSExpr xs
                       case dropWhile isSpace ys of
                         ')':zs -&gt; return (e, zs)
                         _      -&gt; throwError $ ParseErr xs "invalid dotted list"
        '(' -&gt; do (a, ys) &lt;- readCell 0 xs
                  (d, zs) &lt;- readCell 1 ys
                  return (CELL a d, zs)
        _   -&gt; do (a, ys) &lt;- readSExpr (x:xs)
                  (d, zs) &lt;- readCell 1 ys
                  return (CELL a d, zs)

--
-- S 式の評価
--
eval :: Env -&gt; SExpr -&gt; Scm SExpr
eval env NIL        = return NIL
eval env v@(INT _)  = return v
eval env v@(REAL _) = return v
eval env v@(STR _)  = return v
eval env (SYM name) = do
  a &lt;- liftIO $ lookupLEnv name $ snd env
  case a of
    Nothing -&gt; do b &lt;- liftIO $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just v  -&gt; return v
    Just v -&gt; return v
eval env (CELL func args) = do
  v &lt;- eval env func
  case v of
    SYNT f -&gt; f env args
    _      -&gt; do vs &lt;- evalArguments env args
                 apply env v vs

-- 引数の評価
evalArguments :: Env -&gt; SExpr -&gt; Scm SExpr
evalArguments env NIL = return NIL
evalArguments env (CELL expr rest) = do
  v  &lt;- eval env expr
  vs &lt;- evalArguments env rest
  return (CELL v vs)
evalArguments _ _ = throwError $ strMsg "invalid function form"

-- 変数束縛
makeBindings :: LEnv -&gt; SExpr -&gt; SExpr -&gt; Scm LEnv
makeBindings lenv NIL        _    = return lenv
makeBindings lenv (SYM name) rest = liftIO $ pushLEnv name rest lenv
makeBindings lenv (CELL (SYM name) parms) (CELL v args) = do
  lenv' &lt;- makeBindings lenv parms args
  liftIO (pushLEnv name v lenv')
makeBindings lenv _ NIL = throwError $ strMsg errNEA
makeBindings lenv _ _   = throwError $ strMsg "invalid arguments form"

-- 関数適用
apply :: Env -&gt; SExpr -&gt; SExpr -&gt; Scm SExpr
apply env func actuals =
  case func of
    PRIM f -&gt; f actuals
    CLOS (CELL parms body) lenv0 -&gt; do
      lenv1 &lt;- makeBindings lenv0 parms actuals
      evalBody (fst env, lenv1) body
    _ -&gt; throwError $ strMsg $ "Not Function: " ++ show func

-- 本体の評価
evalBody :: Env -&gt; SExpr -&gt; Scm SExpr
evalBody env (CELL expr NIL) = eval env expr
evalBody env (CELL expr rest) = do
  eval env expr
  evalBody env rest
evalBody _ _ = throwError $ strMsg "invalid body form"

--
-- シンタックス形式
--

-- quote
evalQuote :: Env -&gt; SExpr -&gt; Scm SExpr
evalQuote env (CELL expr _) = return expr
evalQuote _ _ = throwError $ strMsg "invalid quote form"

-- define
evalDef :: Env -&gt; SExpr -&gt; Scm SExpr
evalDef env (CELL sym@(SYM name) (CELL expr NIL)) = do
  v &lt;- eval env expr
  liftIO $ H.update (fst env) name v
  return sym
evalDef _ _ = throwError $ strMsg "invalid define form"

-- if
evalIf :: Env -&gt; SExpr -&gt; Scm SExpr
evalIf env (CELL pred (CELL thenForm rest)) = do
  v &lt;- eval env pred
  if v /= false
  then eval env thenForm
  else case rest of
         CELL elseForm _ -&gt; eval env elseForm
         _               -&gt; return false
evalIf _ _ = throwError $ strMsg $ "if : " ++ errNEA

-- lambda
evalLambda :: Env -&gt; SExpr -&gt; Scm SExpr
evalLambda env expr = return (CLOS expr (snd env))

-- set!
evalSet :: Env -&gt; SExpr -&gt; Scm SExpr
evalSet env (CELL (SYM name) (CELL expr _)) = do
  v &lt;- eval env expr
  a &lt;- liftIO $ lookupLEnv name (snd env)
  case a of
    Nothing -&gt; do b &lt;- liftIO $ H.lookup (fst env) name
                  case b of
                    Nothing -&gt; throwError $ strMsg $ "unbound variable: " ++ name
                    Just _ -&gt; do liftIO $ H.update (fst env) name v
                                 return v
    Just _  -&gt; do liftIO $ updateLEnv name v (snd env)
                  return v
evalSet _ _ = throwError (strMsg "invalid set! form")

--
-- 大域変数の初期化
--
initGEnv :: [(String, SExpr)]
initGEnv = [("true",   true),
            ("false",  false),
            ("quote",  SYNT evalQuote),
            ("define", SYNT evalDef),
            ("lambda", SYNT evalLambda),
            ("if",     SYNT evalIf),
            ("set!",   SYNT evalSet),
            ("eq?",    PRIM eq'),
            ("equal?", PRIM equal'),
            ("pair?",  PRIM pair),
            ("+",      PRIM adds),
            ("-",      PRIM subs),
            ("*",      PRIM muls),
            ("/",      PRIM divs),
            ("mod",    PRIM mod'),
            ("=",      PRIM eqNum),
            ("&lt;",      PRIM ltNum),
            ("&gt;",      PRIM gtNum),
            ("&lt;=",     PRIM ltEq),
            ("&gt;=",     PRIM gtEq),
            ("car",    PRIM car),
            ("cdr",    PRIM cdr),
            ("cons",   PRIM cons)]

-- read-eval-print-loop
repl :: Env -&gt; String -&gt; IO ()
repl env xs = do
  putStr "Scm&gt; "
  hFlush stdout
  case readSExpr xs of
    Left  (ParseErr xs' mes) -&gt; do putStrLn mes
                                   repl env $ dropWhile (/= '\n') xs'
    Right (expr, xs') -&gt; do result &lt;- runErrorT $ eval env expr 
                            case result of
                              Left mes -&gt; putStrLn mes
                              Right v  -&gt; print v
                            repl env xs'

main :: IO ()
main = do
  xs &lt;- hGetContents stdin
  ht &lt;- H.fromList H.hashString initGEnv
  repl (ht, []) xs
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2013 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="haskell34.html">PrevPage</a> | <a href="haskell.html">Haskell</a> | <a href="haskell36.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>