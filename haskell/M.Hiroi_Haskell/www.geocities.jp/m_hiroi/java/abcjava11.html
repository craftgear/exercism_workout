<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>続・お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881776</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Java Programming</h1>
<h2>続・お気楽 Java プログラミング入門</h2>
<div class="small">
[ <a href="abcjava10.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava12.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>ジェネリクス (前編)</h3>
<p>「ジェネリクス (generics)」は JDK 5 から導入された機能です。Java のジェネリクスは、Ｃ++のテンプレート、C# のジェネリック、Scala の多相型などと同様に、データ型をパラメータ化することにより、ひとつのクラス定義や関数定義で複数のデータ型に対応することができます。今回はジェネリクスの基本的な使い方を簡単に説明します。
</p>
<h4>●ジェネリクスの基本</h4>
<p> ジェネリクスの基本的な考え方は簡単です。クラスや関数 (メソッド) を定義するとき、フィールド変数や関数の引数 (返り値) にデータ型を指定しますが、これをパラメータ化できるようにしたものがジェネリクスです。クラスや関数を定義するとき、関数の仮引数のようにデータ型を受け取るパラメータを指定します。これを「型パラメータ」とか「型変数」と呼びます。
</p>
<p> 実際に使用するときはデータ型を型パラメータに渡します。関数を呼び出すときに渡す実引数と同じと考えてください。Ｃ++のテンプレートでは、そのデータ型に合わせたクラスや関数が生成されますが、Java のジェネリクスでは生成されるクラスや関数の実体はひとつで、コンパイル時にデータ型のチェックが行われます。どちらの方法でも、一つのプログラムでいろいろなデータ型に対応することができます。
</p>
<p> ジェネリクスの構文を示します。
<ol>
  <li>class クラス名&lt;T, U, ...&gt; { ... }
  <li>&lt;T, U, ...&gt; 返り値の型 関数名(...) { ... }
</ol>
<p> 型パラメータは &lt; ... &gt; の中で指定します。型パラメータは複数指定することができます。名前は英大文字一文字で表すことが一般的です。Java の場合、型パラメータに渡せるデータ型は参照型データだけです。C++ や C# のように int や double など基本的なデータ型を渡すことはできません。ラッパークラス Integer や Double を使ってください。
</p>

<h4>●ジェネリクスでのクラス定義</h4>
<p> それでは実際にジェネリクスでクラスを定義してみましょう。まず最初に、ジェネリクスを使わないでクラスを定義します。
</p>
<pre class="list">
リスト : クラス Foo の定義

class Foo {
  int x;
  Foo() { x = 0; }
  Foo(int n) { x = n; }
  int getX() { return x; }
  void setX(int n) { x = n; }
}

class sample110 {
  public static void main(String[] args) {
    Foo a = new Foo();
    System.out.println(a.getX());
    a.setX(10);
    System.out.println(a.getX());
  }
}
</pre>
<pre>
C&gt;java sample110
0
10
</pre>
<p> クラス Foo は int 型の整数を格納します。ジェネリクスを使うと、整数型だけではなく他のデータ型を格納するクラスを簡単に作ることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : ジェネリクスクラス

class Foo&lt;T&gt;
  T x;
  Foo() { x = null; }
  Foo(T n) { x = n; }
  T getX() { return x; }
  void setX(T n) { x = n; }
}

class sample111 {
  public static void main(String[] args) {
    Foo&lt;Integer&gt; a = new Foo&lt;&gt;(0);
    System.out.println(a.getX());
    a.setX(10);
    System.out.println(a.getX());
    Foo&lt;String&gt; b = new Foo&lt;&gt;("hello, world");
    System.out.println(b.getX());
    b.setX("good by!");
    System.out.println(b.getX());
    int[] ary = {1, 2, 3, 4, 5};
    Foo&lt;int[]&gt; c = new Foo&lt;&gt;(ary);
    System.out.println(c.getX()[0]);
    c.getX()[4] = 50;
    for (int x: c.getX()) System.out.println(x);
  }
}
</pre>
<p> ここでは型パラメータ名を T としました。型パラメータ T は Foo の中で参照することができます。具体的には、int のかわりに T を使ってプログラムを記述するだけです。メンバ変数の宣言は int x から T x に書き換えます。メソッドの定義も int getX() を T getX() に、void setX(int n) を void setX(T n) に書き換えます。
</p>
<p> コンストラクタも同様に書き換えます。Ｃ++のテンプレートでは、クラス T のコンストラクタは T() で呼び出すことができますが、Java のジェネリクスではできません。Java の場合、パラメータは参照型だけなので、Foo() ではとりあえず x を null で初期化することにします。不要であれば削除してください。
</p>
<p> ジェネリクスで定義したクラスから、実際のクラスとインスタンスを生成する場合は次のように宣言します。
</p>
<ol>
  <li>クラス名&lt;型, ...&gt; 変数名 = new クラス名&lt;型, ...&gt;(引数, ...)
  <li>クラス名&lt;型, ...&gt; 変数名 = new クラス名&lt;&gt;(引数, ...)
</ol>
<p> クラス名の後ろの &lt; &gt; の中に型 (データ型) を指定します。データ型は "クラス名&lt;型, ...&gt;" になります。本稿ではジェネリクスで定義された型を「ジェネリクス型」と記述することにします。ジェネリクス型はクラス名が同じでも異なる型を与えれば、別のデータ型として扱われます。Java の場合、1 のように右辺と左辺で同じデータ型を記述しないといけませんが、2 のように右辺の型指定を省略することもできます。この &lt;&gt; をダイヤモンド演算子といいます。
</p>
<p> main() で Foo&lt;Integer&gt; a = new Foo&lt;&gt;(0); とすれば、整数 (Integer) を格納する Foo のインスタンスを生成して変数 a にセットします。Foo&lt;String&gt; b = new Foo&lt;&gt;("..."); とすれば、変数 b に文字列を格納する Foo のインスタンスが代入され、Foo&lt;int[]&gt; c = new Foo&lt;&gt;(ary); とすれば、変数 c にint 型の配列 ary を格納する Foo のインスタンスが代入されます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;java sample111
0
10
hello, world
good by!
1
1
2
3
4
50
</pre>
<p> このようにジェネリクスを使うと、一つのクラス定義で複数のデータ型に対応するプログラムを作ることができます。
</p>

<h4>●ジェネリクスによる関数定義</h4>
<p> 次はジェネリクスで関数 (メソッド) を作ってみましょう。簡単な例として、恒等関数 (identity function) を取り上げます。次のリストを見てください。
</p>
<pre class="list">
リスト : 恒等関数

class sample112 {
  static &lt;T&gt; T identity(T x) {
    return x;
  }

  public static void main(String[] args) {
    Integer a = 123;
    System.out.println(identity(a));
    Double b = 1.2345;
    System.out.println(identity(b));
    String c = "hello, world";
    System.out.println(identity(c));
  }
}
</pre>
<pre>
C&gt;java sample112
123
1.2345
hello, world
</pre>
<p> 関数 identity() は引数をそのまま返す関数です。T が型パラメータで、これで任意の型のデータに対応することができます。ジェネリクスを使わない場合、データ型の種類だけ identitiy() を多重定義しなければいけませんが、ジェネリクスを使えば関数をひとつ定義するだけですみます。つまり、Integer, Double, String など Java の参照型データであれば何でも対応することができるわけです。このような関数を「多相型関数 (polymorphic function)」といいます。
</p>
<p> 多相型関数のように、いろいろな型を取ることができる性質のことを「多相性 (polymmprphism)」といいます。多相性は Java のジェネリクスだけではなく、ML 系の言語 (OCaml, SML/NJ, Haskell など) の特徴のひとつです。これらの言語には「型推論」という機能があり、プログラマがデータ型を宣言する必要はほとんどありません。
</p>

<h4>●Pair の作成</h4>
<p> それでは簡単な例題として、2 つの異なるデータ型を格納するクラス Pair をジェネリクスで作成してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : Pair クラス

class Pair&lt;T, U&gt; {
  private T fst;
  private U snd;
  // コンストラクタ
  Pair(T x, U y) {
    fst = x;
    snd = y;
  }
  // メソッド
  T getFst() { return fst; }
  U getSnd() { return snd; }
  void setFst(T x) { fst = x; }
  void setSnd(U y) { snd = y; }

  // 文字列に変換
  public String toString() {
    return "(" + fst.toString() + ", " + snd.toString() + ")";
  }
}

public class sample113 {
  public static void main(String[] args) {
    Pair&lt;String, Integer&gt; a = new Pair&lt;&gt;("foo", 10);
    System.out.println(a);
    System.out.println(a.getFst());
    System.out.println(a.getSnd());
    a.setFst("FOO");
    a.setSnd(20);
    System.out.println(a);
    
    Pair&lt;String, Double&gt;  b = new Pair&lt;&gt;("bar", 1.2345);
    System.out.println(b);
    Pair&lt;String, String&gt;  c = new Pair&lt;&gt;("baz", "oops!");
    System.out.println(c);

    // Pair&lt;String, Integer&gt;[] d = new Pair&lt;String, Integer&gt;[4];
    // ジェネリクス型の配列は作成できない
  }
}
</pre>
<pre>
C&gt;java sample113
(foo, 10)
foo
10
(FOO, 20)
(bar, 1.2345)
(baz, oops!)
</pre>
<p> Pair には 2 つの異なるデータ型を格納するので、型パラメータは T, U の 2 つが必要になります。フィールド変数 fst が T 型のデータを格納し、snd が U 型のデータを格納します。あとは、フィールド変数のアクセスメソッドと文字列に変換するメソッド toString() を定義します。
</p>
<p> main() の中で、Pair&lt;String,Integer&gt; とすると、String と Integer を格納するインスタンスが生成されます。T と U には同じデータ型を指定してもかまいません。なお Java の場合、ジェネリクス型の配列は作成することができません。ジェネリクス型のオブジェクトを格納する場合は ArrayList&lt;E&gt; を使います。
</p>
<h4>●可変長配列 (ArrayList)</h4>
<p> Java の ArrayList は可変長の一次元配列を実装したコレクションクラスです。ArrayList&lt;E&gt; はそのジェネリクス版です。Java の場合、配列を宣言したあとで、その大きさを変更することはできません。ArrayList の場合、保持している配列の容量が足りなくなると自動的に拡張してくれます。一般に、大きさを自由に変えることができる配列を「可変長配列」といいます。Perl, Python, Ruby などスクリプト言語の多くは可変長配列をサポートしています。
</p>
<p> ArrayList は java.util 内に定義されているので、使用するときは import java.util.* としてください。変数の宣言は次のように行います。
</p>
<ol>
  <li>ArrayList&lt;データ型&gt; 変数名 = new ArrayList<>();
  <li>List&lt;データ型&gt; 変数名 = new ArrayList<>();
</ol>
<p> ArrayList&lt;E&gt; はインターフェース List&lt;E&gt; を継承しています。変数の型を List&lt;E&gt; で宣言しておくと、ArrayList&lt;E&gt; 以外のコレクションクラスに切り替えることも簡単にできます。
</p>
<p> 上記の場合、空 (要素数が 0) の ArrayList が生成されます。引数に正整数 n を指定すると、容量が n で空の ArrayList が生成されます。また、イテレータを実装しているコレクションクラスを指定すると、その要素を格納した ArrayList が生成されます。
</p>
<p> List&lt;E&gt; の基本的なメソッドを下表に示します。
</p>
<table border=1>
<caption>表 : List&lt;E&gt; の基本的なメソッド</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>boolean add(E e)</td><td>末尾に e を追加する</td></tr>
  <tr><td>void add(int i, E e)</td><td>i 番目に e を挿入する</td></tr>
  <tr><td>E get(int i)</td><td>i 番目の要素を求める</td></tr>
  <tr><td>E remove(int i)</td><td>i 番目の要素を削除する</td></tr>
  <tr><td>void set(int i, E e)</td><td>i 番目の要素を e を書き換える</td></tr>
  <tr><td>int size()</td><td>格納している要素数を返す</td></tr>
  <tr><td>boolean isEmpty()</td><td>コレクションが空であれば true を返す</td></tr>
  <tr><td>void clear()</td><td>コレクションを空にする</td></tr>
</tbldy>
</table>
<p> Ｃ++のテンプレート vector は配列と同様に角カッコで要素にアクセスすることができますが、Java の List&lt;E&gt; はできません。ご注意くださいませ。この他にも List&lt;E&gt; には便利なメソッドが用意されています。詳細は Java のマニュアル <a href="http://docs.oracle.com/javase/jp/7/api/java/util/List.html">インタフェース List&lt;E&gt;</a> をお読みください。
</p>
<p> 簡単な使用例を示しましょう。
</p>
<pre class="list">
リスト : ArrayList の簡単な使用例

import java.util.*;

public class sample114 {
  public static void main(String[] args) {
    List&lt;Integer&gt; a = new ArrayList&lt;&gt;();
    for (int i = 1; i &lt;= 8; i++) a.add(i);
    System.out.println(a);
    List&lt;Integer&gt; b = new ArrayList&lt;&gt;(a);
    for (int i = 0; i &lt; a.size(); i++) {
      b.set(i, a.get(i) * 10);
    }
    System.out.println(b);
  }
}
</pre>
<p> ジェネリクスではない ArrayList では、要素のデータ型を Object で宣言しています。したがって、どんなデータ型でも代入することができますが、要素を参照するときはダウンキャストが必要になります。プログラマが間違って想定外のデータを代入すると、ダウンキャストに失敗することもあるでしょう。
</p>
<p> ジェネリクス版の場合、データ型が指定されているので、コンパイル時にデータ型のチェックが行われます。異なるデータ型をセットすることはできませんし、参照するときのダウンキャストも不要になります。つまり、データ型に対して安全なプログラムを作ることができるわけです。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;java sample114
[1, 2, 3, 4, 5, 6, 7, 8]
[10, 20, 30, 40, 50, 60, 70, 80]
</pre>
<h4>●Pair を格納する</h4>
<p> それでは、Pair&lt;T, U&gt; を ArrayList&lt;E&gt; に格納してみましょう。Java のジェネリクスはジェネリクスを入れ子にすることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : Pair を List に格納する

import java.util.*;

class Pair&lt;T, U&gt; {
  private T fst;
  private U snd;
  // コンストラクタ
  Pair(T x, U y) {
    fst = x;
    snd = y;
  }
  // メソッド
  T getFst() { return fst; }
  U getSnd() { return snd; }
  void setFst(T x) { fst = x; }
  void setSnd(U y) { snd = y; }

  // 文字列に変換
  public String toString() {
    return "(" + fst.toString() + ", " + snd.toString() + ")";
  }
}

public class sample115 {
  public static void main(String[] args) {
    List&lt;Pair&lt;String, Integer&gt;&gt; a = new ArrayList&lt;&gt;();
    a.add(new Pair&lt;String, Integer&gt;("foo", 10));
    a.add(new Pair&lt;String, Integer&gt;("bar", 20));
    a.add(new Pair&lt;String, Integer&gt;("baz", 30));
    a.add(new Pair&lt;String, Integer&gt;("oops", 40));
    System.out.println(a);
  }
}
</pre>
<pre>
C&gt;java sample115
[(foo, 10), (bar, 20), (baz, 30), (oops, 40)]
</pre>
<p> 「インスタンス初期化子 (Instance Initializer)」を使うと、List の初期化は次のように記述することができます。
</p>
<pre class="list">
リスト ; インスタンス初期化子

    List&lt;Pair&lt;String, Integer&gt;&gt; a = new ArrayList&lt;Pair&lt;String, Integer&gt;&gt;() {
      {
        add(new Pair&lt;String, Integer&gt;("foo", 10));
        add(new Pair&lt;String, Integer&gt;("bar", 20));
        add(new Pair&lt;String, Integer&gt;("baz", 30));
        add(new Pair&lt;String, Integer&gt;("oops", 40));
      }
    };
</pre>
<p> インスタンス初期化子は {{ ... }} の中のメソッドを順番に実行します。なお、インスタンス初期化子を使う場合、ダイヤモンド演算子を使うことはできません。ご注意くださいませ。
</p>
<h4>●連結リスト (ジェネリクス版)</h4>
<p> もうひとつ簡単な例題として、拙作のページ <a href="abcjava08.html">第 8 回 連結リスト</a> で作成した片方向連結リスト SinglyLinkedList をジェネリクスで書き直してみましょう。クラス定義は次のようになります。
</p>
<pre class="list">
リスト : クラス定義

class SinglyLinkedList&lt;E&gt; implements Iterable&lt;E&gt; {
  // セル
  private class Cell {
    // フィールド変数
    private E value;
    private Cell link;
    // コンストラクタ
    Cell(E item, Cell xs) {
      value = item;
      link = xs;
    }

    // アクセスメソッド
    E getValue() { return value; }
    Cell getLink() { return link; }
    void setValue(E item) { value = item; }
    void setLink(Cell xs) { link = xs; }
  }
  
  // フィールド変数
  private Cell head;
  private int  size;
  // コンストラクタ
  SinglyLinkedList() {
    head = new Cell(null, null);   // ヘッダーセル
    size = 0;
  }
  
  // メソッドの定義
  ・・・ 省略 ・・・
}
</pre>
<p> 要素のデータ型を型パラメータ E で表します。イテレータを実装するため、Iterable のジェネリクス版 Iterable&lt;E&gt; を継承します。内部クラス Cell は SinglyLinkedList の型パラメータ E のスコープ内にあるので、そのままで E を参照することができます。フィールド変数 value の型を E に、コンストラクタとアクセスメソッドで要素の型を E に変更するだけです。
</p>
<p> なお、static なフィールド変数、メソッド、内部クラスでは、クラスの型パラメータを参照することはできません。コンパイルエラーになります。ご注意くださいませ。
</p>
<p> あとはメソッドで要素の型を E に変更します。メソッドの仕様を下表に示します。
</p>
<table border=1>
<caption>表 : SinglyLinkedList&lt;E&gt; の操作メソッド</caption>
<thead>
  <tr><th>メソッド</th><th> 機能</th></tr>
</thead>
<tbody>
  <tr><td>E get(int n) </td><td>n 番目の要素を求める</td></tr>
  <tr><td>void insert(int n, E x) </td><td>n 番目の位置にデータ x を追加する</td></tr>
  <tr><td>E remove(int n) </td><td>n 番目の要素を削除する</td></tr>
  <tr><td>E set(int n, E x) </td><td>n 番目の要素をデータ x に置き換える<br>返り値は置き換えられた古い要素を返す</td></tr>
  <tr><td>void clear() </td><td>連結リストを空にする</td></tr>
  <tr><td>int size() </td><td>要素の個数を返す</td></tr>
  <tr><td>boolean isEmpty() </td><td>空リストであれば true を返す</td></tr>
  <tr><td>List&lt;E&gt; toList()</td><td>ArrayList&lt;E&gt; に変換する</td></tr>
  <tr><td>String toSting() </td><td>文字列に変換する</td></tr>
  <tr><td>Iterator&lt;E&gt; iterator()</td><td>イテレータを返す</td></tr>
</tbody>
</table>
<p> イテレータを返すプログラムは次のようになります。
</p>
<pre class="list">
リスト : イテレータ

  public Iterator&lt;E&gt; iterator() {
    // 無名クラス
    return new Iterator&lt;E&gt;() {
      Cell xs = head.getLink();
      public boolean hasNext() { return xs != null; }
      public E next() {
        E item = xs.getValue();
        xs = xs.getLink();
        return item;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }
</pre>
<p> iterator() は Iterator&lt;E&gt; を返します。Iterator&lt;E&gt; は Iterator のジェネリクス版です。あとは要素の型を E に変更するだけです。あとのプログラムは簡単なので説明は省略いたします。詳細は <a href="abcjava11.html#list1">プログラムリスト</a> をお読みください。
</p>

<h4>●簡単な実行例</h4>
<p> それでは簡単なテストを行ってみましょう。プログラムリストと実行結果を示します。
</p>
<pre class="list">
リスト : 簡単なテスト

public class slist2 {
  static &lt;E&gt; void printCollection(Iterator&lt;E&gt; iter){
    while(iter.hasNext()){
      System.out.print(iter.next() + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) {
    SinglyLinkedList&lt;Integer&gt; xs = new SinglyLinkedList&lt;&gt;();
    System.out.println(xs);
    System.out.println(xs.size());
    System.out.println(xs.isEmpty());
    for (int i = 0; i &lt; 10; i++) {
      System.out.println("insert: " + i + ", "+ i);
      xs.insert(i, i);
      System.out.println(xs);
      System.out.println(xs.size());
      System.out.println(xs.isEmpty());
    }
    for (Integer n: xs.toList()) System.out.print(n + " ");
    System.out.println();
    for (int i = 0; i &lt; 10; i++) {
      xs.set(i, xs.get(i) + 10);
      System.out.print(xs.get(i) + " ");
    }
    System.out.println();
    for(int i = 0; i &lt; 5; i++) {
      System.out.println("remove: " + i);
      System.out.println(xs.remove(i));
      System.out.println(xs);
      System.out.println(xs.size());
      System.out.println(xs.isEmpty());
    }
    System.out.println("clear:");
    xs.clear();
    System.out.println(xs);
    System.out.println(xs.size());
    System.out.println(xs.isEmpty());

    SinglyLinkedList&lt;Integer&gt; ys = new SinglyLinkedList&lt;&gt;();
    for(int i = 0; i &lt; 10; i++){
      ys.insert(0, i);
    }
    printCollection(ys.iterator());
    for (Integer n: ys) System.out.print(n + " ");
    System.out.println();
  }
</pre>
<pre>
C&gt;java slist2
()
0
true
insert: 0, 0
(0)
1
false
insert: 1, 1
(0 1)
2
false
insert: 2, 2
(0 1 2)
3
false
insert: 3, 3
(0 1 2 3)
4
false
insert: 4, 4
(0 1 2 3 4)
5
false
insert: 5, 5
(0 1 2 3 4 5)
6
false
insert: 6, 6
(0 1 2 3 4 5 6)
7
false
insert: 7, 7
(0 1 2 3 4 5 6 7)
8
false
insert: 8, 8
(0 1 2 3 4 5 6 7 8)
9
false
insert: 9, 9
(0 1 2 3 4 5 6 7 8 9)
10
false
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
remove: 0
10
(11 12 13 14 15 16 17 18 19)
9
false
remove: 1
12
(11 13 14 15 16 17 18 19)
8
false
remove: 2
14
(11 13 15 16 17 18 19)
7
false
remove: 3
16
(11 13 15 17 18 19)
6
false
remove: 4
18
(11 13 15 17 19)
5
false
clear:
()
0
true
9 8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0
</pre>
<p> 正常に動作していますね。要素のデータ型が型パラメータで指定されているので、get() で要素を取り出すときキャストしなくてもよいので、より安全なプログラムを作ることができます。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// slist2.java : 片方向連結リスト (ジェネリクス版)
//
//               Copyright (C) 2016 Makoto Hiroi
//
import java.util.*;

// 例外クラス
class ListIndexOutOfBoundsException extends IndexOutOfBoundsException {
  public ListIndexOutOfBoundsException() { }
  public ListIndexOutOfBoundsException(String msg) { super(msg); }
}


// 連結リスト
class SinglyLinkedList&lt;E&gt; implements Iterable&lt;E&gt; {
  // セル
  private class Cell {
    // フィールド変数
    private E value;
    private Cell link;
    // コンストラクタ
    Cell(E item, Cell xs) {
      value = item;
      link = xs;
    }

    // アクセスメソッド
    E getValue() { return value; }
    Cell getLink() { return link; }
    void setValue(E item) { value = item; }
    void setLink(Cell xs) { link = xs; }
  }
  
  // フィールド変数
  private Cell head;
  private int  size;
  // コンストラクタ
  SinglyLinkedList() {
    head = new Cell(null, null);   // ヘッダーセル
    size = 0;
  }
  
  // n 番目のセルを求める
  private Cell nth(int n) {
    int i = -1;
    Cell xs = head;
    while (xs != null) {
      if (n == i) return xs;
      i++;
      xs = xs.getLink();
    }
    throw new ListIndexOutOfBoundsException("SinglyLinkedList");
  }

  // 参照
  public E get(int n) {
    return nth(n).getValue();
  }

  // 挿入
  public void insert(int n, E item) {
    Cell xs = nth(n - 1);
    Cell ys = new Cell(item, xs.getLink());
    xs.setLink(ys);
    size++;
  }

  // 削除
  public E remove(int n) {
    Cell xs = nth(n - 1);
    Cell ys = xs.getLink();
    if (ys == null) {
      throw new ListIndexOutOfBoundsException("SinglyLinkedList");
    }
    xs.setLink(ys.getLink());
    size--;
    return ys.getValue();
  }

  // 書き換え
  public E set(int n, E item) {
    Cell xs = nth(n);
    E old = xs.getValue();
    xs.setValue(item);
    return old;
  }

  // 空にする
  public void clear() {
    head.setLink(null);
    size = 0;
  }

  // 個数を求める
  public int size() { return size; }

  // 空リストか
  public boolean isEmpty() { return size == 0; }

  // List 型に変換する
  public List&lt;E&gt; toList(){
    List&lt;E&gt; a = new ArrayList&lt;&gt;();
    Cell xs = head.getLink();
    for (int i = 0; i &lt; size; i++) {
      a.add(xs.getValue());
      xs = xs.getLink();
    }
    return a;
  }
  
  // 文字列に変換
  public String toString(){
    String buff = "(";
    Cell xs = head.getLink();
    while (xs != null) {
      buff += xs.getValue().toString();
      xs = xs.getLink();
      if (xs != null) buff += " ";
    }
    buff += ")";
    return buff;
  }

  // イテレータ
  public Iterator&lt;E&gt; iterator() {
    // 無名クラス
    return new Iterator&lt;E&gt;() {
      Cell xs = head.getLink();
      public boolean hasNext() { return xs != null; }
      public E next() {
        E item = xs.getValue();
        xs = xs.getLink();
        return item;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }
}

// 簡単なテスト
public class slist2 {
  static &lt;E&gt; void printCollection(Iterator&lt;E&gt; iter){
    while(iter.hasNext()){
      System.out.print(iter.next() + " ");
    }
    System.out.println();
  }

  public static void main(String[] args) {
    SinglyLinkedList&lt;Integer&gt; xs = new SinglyLinkedList&lt;&gt;();
    System.out.println(xs);
    System.out.println(xs.size());
    System.out.println(xs.isEmpty());
    for (int i = 0; i &lt; 10; i++) {
      System.out.println("insert: " + i + ", "+ i);
      xs.insert(i, i);
      System.out.println(xs);
      System.out.println(xs.size());
      System.out.println(xs.isEmpty());
    }
    for (Integer n: xs.toList()) System.out.print(n + " ");
    System.out.println();
    for (int i = 0; i &lt; 10; i++) {
      xs.set(i, xs.get(i) + 10);
      System.out.print(xs.get(i) + " ");
    }
    System.out.println();
    for(int i = 0; i &lt; 5; i++) {
      System.out.println("remove: " + i);
      System.out.println(xs.remove(i));
      System.out.println(xs);
      System.out.println(xs.size());
      System.out.println(xs.isEmpty());
    }
    System.out.println("clear:");
    xs.clear();
    System.out.println(xs);
    System.out.println(xs.size());
    System.out.println(xs.isEmpty());

    SinglyLinkedList&lt;Integer&gt; ys = new SinglyLinkedList&lt;&gt;();
    for(int i = 0; i &lt; 10; i++){
      ys.insert(0, i);
    }
    printCollection(ys.iterator());
    for (Integer n: ys) System.out.print(n + " ");
    System.out.println();
  }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava10.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava12.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>