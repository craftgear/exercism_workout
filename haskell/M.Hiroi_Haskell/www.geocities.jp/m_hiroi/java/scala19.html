<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881778</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala18.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala20.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>マップ (Map) とセット (Set)</h3>
<p> 前回は「列 (Seq) 」について説明しました。今回は Scala の基本的なコレクションである「マップ (Map) 」と「セット (Set) 」について説明します。
</p>

<h4>●マップとは？</h4>
<p> マップは「連想配列」のことで、Perl や Ruby では「ハッシュ (Hash) 」と呼ばれています。配列が整数値を使って要素を指定するのに対し、マップはキー (key) というデータを使って要素を指定します。一般に、連想配列のキーには文字列が用いられますが、Scala では「ハッシュ値」の計算と等値の判定ができれば、マップのキーとして使用することができます。
</p>

<p> 等値の判定はメソッド equals で、ハッシュ値の計算はメソッド hashCode で行います。文字列や数値など基本的な型には equals と hashCode が定義されています。また、case class はどちらのメソッドも自動的に作成されるので、case class のインスタンスはマップのキーとして使用することができます。なお、サブクラスをキーにする場合は、メソッド CanEqual が必要になりますが、case class はこのメソッドも自動的に作成されます。
</p>

<p> Perl や Ruby で連想配列をハッシュと呼ぶのは、連想配列を実現するアルゴリズムに「ハッシュ法 (hashing) 」が用いられているからです。Scala の場合、不変 (immutable) なマップはハッシュトライ (HashTrie) といって木構造を使ったハッシュ法が用いられています。可変 (mutable) なマップはハッシュテーブル (ハッシュ表) といって配列を使ったハッシュ法になります。
</p>

<p> ハッシュ法はデータを高速に探索できるアルゴリズムです。線形探索では時間がとてもかかる処理でも、マップを遣うと高速にデータを探索することができます。ハッシュ法 (ハッシュ表) のアルゴリズムに興味のある方は、拙作のページ拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo04.html">ハッシュ法</a> をお読みくださいませ。
</p>

<h4>●不変 (immutable) なマップ</h4>
<p> 最初に不変なマップから説明しましょう。マップの型は Map[K,V] で、型パラメータ K がキーを、V が値を表します。マップを生成する構文を示します。
</p>
<pre class="item">
Map[K, V]()
Map[K, V](Key1 -&gt; Value1, Key2 -&gt; Value2, ...)
</pre>
<p> Map[K, V] の後ろのカッコでキーと値を指定します。() だけだと空のマップを生成します。-&gt; はタプルを生成する構文です。Scala の場合、Map は -&gt; を使ってキーと値を指定します。キーと値を指定する場合、型 [K, V] を指定しなくても Scala が型推論で型を決めてくれます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = Map("foo" -&gt; 10, "bar" -&gt; 20)
a: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20)

scala&gt; a("foo")
res0: Int = 10

scala&gt; a("bar")
res1: Int = 20

scala&gt; a("baz")
java.util.NoSuchElementException: key not found: baz
・・・省略・・・

scala&gt; a contains "foo"
res2: Boolean = true

scala&gt; a contains "Baz"
res3: Boolean = false

scala&gt; a.get("foo")
res4: Option[Int] = Some(10)

scala&gt; a.get("baz")
res5: Option[Int] = None

scala&gt; a.getOrElse("foo", 0)
res6: Int = 10

scala&gt; a.getOrElse("baz", 0)
res7: Int = 0

scala&gt; a.size
res8: Int = 2

scala&gt; a.isEmpty
res9: Boolean = false
</pre>

<p> マップのアクセスは列と同様にカッコ ( ) を使います。マップを生成して変数 a にセットします。a("foo") でキー "foo" のデータを参照することができます。immutable なマップなので、値を書き換えることはできません。キーが見つからない場合はエラーが送出されます。
</p>
<p> キーの有無はメソッド contains でチェックすることができます。メソッド get は Option 型を返すので、キーがあれば値を Some に包んで返します。見つからない場合は None を返します。getOrElse(k, d) はキー k が見つからない場合はデフォルト値 d を返します。マップの大きさはメソッド size で取得することができます。メソッド isEmpty はマップが空であれば true を、そうでなければ false を返します。
</p>

<h4>●データの追加</h4>
<p> データの追加は演算子 + を使います。次の例を見てください。
</p>
<pre>
scala&gt; val b = a + ("baz" -&gt; 30)
b: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30)

scala&gt; b.get("foo")
res10: Option[Int] = Some(10)

scala&gt; b.get("baz")
res11: Option[Int] = Some(30)

scala&gt; val c = b.updated("oops", 40)
c: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30, oops -&gt; 40)

scala&gt; c.get("oops")
res12: Option[Int] = Some(40)
</pre>
<p> a + ("baz" -&gt; 30) は、マップ a に "baz" -&gt; 30 を追加した新しいマップを生成します。演算子 + のほかに、メソッド updated を使って新しいキーと値を追加することもできます。
</p>
<p> 演算子 ++ を使うと、他のマップやタプル (key, value) を格納した列のデータをマップに追加することができます。
</p>
<pre>
scala&gt; val a = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30)
a: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30)

scala&gt; a ++ Map(4 -&gt; 40, 5 -&gt; 50, 6 -&gt; 60)
res0: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 50, 1 -&gt; 10, 6 -&gt; 60, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40)

scala&gt; a ++ List((4, 40), (5, 50), (6, 60))
res1: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 50, 1 -&gt; 10, 6 -&gt; 60, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40)

scala&gt; a ++ Array((4, 40), (5, 50), (6, 60))
res2: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 50, 1 -&gt; 10, 6 -&gt; 60, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40)

scala&gt; a ++ Map(1 -&gt; 100)
res3: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 100, 2 -&gt; 20, 3 -&gt; 30)
</pre>
<p> 左辺と右辺で同じキーがある場合、左辺の値は右辺の値に置き換えられます。
</p>

<h4>●データの削除</h4>
<p> データの削除は演算子 - を使います。次の例を見てください。
</p>
<pre>
scala&gt; val a = Map("foo" -&gt; 10, "bar" -&gt; 20, "baz" -&gt; 30)
a: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30)

scala&gt; a - "foo"
res0: scala.collection.immutable.Map[String,Int] = Map(bar -&gt; 20, baz -&gt; 30)

scala&gt; a - ("foo", "bar")
res1: scala.collection.immutable.Map[String,Int] = Map(baz -&gt; 30)

scala&gt; a - "oops"
res2: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30)
</pre>
<p> 演算子 - はマップからキーとその値を削除した新しいマップを返します。キーをタプルに格納すれば、複数のキーをまとめて削除することができます。
</p>

<p> 演算子 -- を使うと、キーを格納した列のデータをマップから削除することができます。
</p>
<pre>
scala&gt; val a = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40, 5 -&gt; 50)
a: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 50, 1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40)

scala&gt; a -- List(1,3,5)
res1: scala.collection.immutable.Map[Int,Int] = Map(2 -&gt; 20, 4 -&gt; 40)

scala&gt; a -- Array(1,3,5)
res2: scala.collection.immutable.Map[Int,Int] = Map(2 -&gt; 20, 4 -&gt; 40)
</pre>

<h4>●キーと値の取得</h4>
<p> マップは for 式、メソッド foreach、イテレータを使って、キーと値を順番に取り出すことができます。
</p>
<pre>
scala&gt; val a = Map("foo" -&gt; 10, "bar" -&gt; 20, "baz" -&gt; 30)
a: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30)

scala&gt; for (x &lt;- a) println(x)
(foo,10)
(bar,20)
(baz,30)

scala&gt; a foreach println
(foo,10)
(bar,20)
(baz,30)

scala&gt; val it = a.iterator
it: Iterator[(String, Int)] = non-empty iterator

scala&gt; while (it.hasNext) println(it.next)
(foo,10)
(bar,20)
(baz,30)
</pre>
<p> キーと値はタプルに格納されて渡されます。for 式の場合はパターンマッチングが使えるので、キーと値を別々の変数に取り出すのは簡単です。
</p>
<pre>
scala&gt; for ((k, v) &lt;- a) { println(k); println(v) }
foo
10
bar
20
baz
30
</pre>
<h4>●マップと列の変換</h4>
<p> マップ Map[K, V] は列 Seq[(K, V)] に変換することができます。逆に、列 Seq[(K, V)] はマップ Map[K, V] に変換することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = Map("foo" -&gt; 10, "bar" -&gt; 20, "baz" -&gt; 30)
a: scala.collection.immutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20, baz -&gt; 30)

scala&gt; a.toList
res0: List[(String, Int)] = List((foo,10), (bar,20), (baz,30))

scala&gt; a.toVector
res1: Vector[(String, Int)] = Vector((foo,10), (bar,20), (baz,30))

scala&gt; a.toArray
res2: Array[(String, Int)] = Array((foo,10), (bar,20), (baz,30))

scala&gt; List((1, 10), (2, 20), (3, 30)).toMap
res3: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30)

scala&gt; Vector((1, 10), (2, 20), (3, 30)).toMap
res4: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30)

scala&gt; Array((1, 10), (2, 20), (3, 30)).toMap
res5: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30)
</pre>
<p> toList, toVector, toArray などでマップを列に変換することができます。また、列はメソッド toMap でマップに変換することができます。
</p>

<h4>●可変 (mutable) なマップ</h4>
<p> 可変 (mutable) なマップは scala.collection.mutable.Map を使います。Map は immutable なマップが使っているので、import で別名を付けるといいでしょう。簡単な例を示します。
</p>
<pre>
scala&gt; import scala.collection.mutable.{Map =&gt; MMap}
import scala.collection.mutable.{Map=&gt;MMap}

scala&gt; val a = MMap("foo" -&gt; 10, "bar" -&gt; 20)
a: scala.collection.mutable.Map[String,Int] = Map(foo -&gt; 10, bar -&gt; 20)

scala&gt; a("foo")
res0: Int = 10

scala&gt; a contains "foo"
res1: Boolean = true

scala&gt; a get "baz"
res2: Option[Int] = None
</pre>
<p> 基本的には immutable なマップと同じメソッドが使えますが、演算子 +, ++, -, -- は mutable なマップでも新しいマップを生成することに注意してください。
</p>

<h4>●マップの更新</h4>
<p> mutable なマップは値を書き換えることができます。
</p>
<pre class="item">
m(key) = value
m.update(key, value)
</pre>
<p> マップを m とすると、列と同様に m(key) = value, または m.update(key, value) で key の値を value に更新します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; a("foo") = 100

scala&gt; a
res4: scala.collection.mutable.Map[String,Int] = Map(foo -&gt; 100, bar -&gt; 20)

scala&gt; a.update("bar", 200)

scala&gt; a
res6: scala.collection.mutable.Map[String,Int] = Map(foo -&gt; 100, bar -&gt; 200)
</pre>
<p> マップにキーが含まれていない場合は、そのマップに新しいキーと値を追加します。<pre>
</p>
scala&gt; a("baz") = 300

scala&gt; a
res8: scala.collection.mutable.Map[String,Int] = Map(baz -&gt; 300, foo -&gt; 100, bar -&gt; 200)

scala&gt; a.update("oops", 400)

scala&gt; a
res10: scala.collection.mutable.Map[String,Int] = Map(baz -&gt; 300, oops -&gt; 400, foo -&gt; 100, bar -&gt; 200)

scala&gt; a.getOrElseUpdate("foo", 500)
res11: Int = 100

scala&gt; a.getOrElseUpdate("foo1", 500)
res12: Int = 500

scala&gt; a
res13: scala.collection.mutable.Map[String,Int] = Map(baz -&gt; 300, oops -&gt; 400, foo1 -&gt; 500, foo -&gt; 100, bar -&gt; 200)
</pre>
<p> メソッド getOrElseUpdate は、キーが見つかればその値を返します。キーが見つからない場合は、キーと値をマップに追加して値を返します。キー "foo" はマップ a にあるので、その値 100 を返します。キー "foo1" はマップ a にないので "foo1" -&gt; 500 を追加して、値 500 を返します。
</p>

<p> 更新処理は演算子 += でも行うことができます。
</p>
<pre>
scala&gt; a += ("bar" -&gt; 2)
res14: a.type = Map(baz -&gt; 300, oops -&gt; 400, foo1 -&gt; 500, foo -&gt; 100, bar -&gt; 2)

scala&gt; a += ("bar1" -&gt; 20)
res15: a.type = Map(bar1 -&gt; 20, baz -&gt; 300, oops -&gt; 400, foo1 -&gt; 500, foo -&gt; 100, bar -&gt; 2)
</pre>
<p> 演算子 + を使うと新しいマップが生成されることに注意してください。
</p>
<p> キーの削除は演算子 -= または remove で行います。
</p>
<pre>
scala&gt; a -= "foo1"
res16: a.type = Map(bar1 -&gt; 20, baz -&gt; 300, oops -&gt; 400, foo -&gt; 100, bar -&gt; 2)

scala&gt; a remove "bar1"
res17: Option[Int] = Some(20)

scala&gt; a remove "foo1"
res18: Option[Int] = None

scala&gt; a
res19: scala.collection.mutable.Map[String,Int] = Map(baz -&gt; 300, oops -&gt; 400, foo -&gt; 100, bar -&gt; 2)

scala&gt; a.clear

scala&gt; a
res21: scala.collection.mutable.Map[String,Int] = Map()
</pre>
<p> 演算子 -= の返り値はマップになりますが、remove は削除したキーの値を Option 型で返します。メソッド clear はマップの全データを削除します。マップは空になります。
</p>
<p> また、他のコレクションに格納されているデータでマップを更新する場合は演算子 ++=, --= を使います。
</p>
<pre>
scala&gt; import scala.collection.mutable.{Map=&gt;MMap}
import scala.collection.mutable.{Map=&gt;MMap}

scala&gt; val a = MMap(1 -&gt; 10, 2 -&gt; 20, 3 -&gt; 30, 4 -&gt; 40, 5 -&gt; 50)
a: scala.collection.mutable.Map[Int,Int] = Map(2 -&gt; 20, 5 -&gt; 50, 4 -&gt; 40, 1 -&gt; 10, 3 -&gt; 30)

scala&gt; a ++= List((6, 60), (7, 70), (8, 80))
res0: a.type = Map(8 -&gt; 80, 2 -&gt; 20, 5 -&gt; 50, 4 -&gt; 40, 7 -&gt; 70, 1 -&gt; 10, 3 -&gt; 30, 6 -&gt; 60)

scala&gt; a --= List(6, 7, 8)
res1: a.type = Map(2 -&gt; 20, 5 -&gt; 50, 4 -&gt; 40, 1 -&gt; 10, 3 -&gt; 30)
</pre>
<h4>●セットとは？</h4>
<p> 「セット (Set) 」はリストやマップのように要素を格納するコレクションですが、リストと違って要素に順番はなく、重複した要素を含まないところが特徴です。セットはデータの集合を表すのに便利なデータ型です。集合は要素の順番に意味はありません。たとえば集合 {1, 3, 5, 7} は {7, 5, 3, 1} や {5, 3, 1, 7} と表すこともできます。このように、要素は適当に並べてもかまわないのですが、ある規則で要素を整列させておく場合もあります。
</p>

<p> Scala のセットはマップと同様に、不変 (immutable) なセットはハッシュトライ (HashTrie) という木構造を使ったハッシュ法が用いられています。可変 (mutable) なセットは配列を使ったハッシュ法になります。当然ですが、セットを使う場合はメソッド equals と hashCode が必要になります。
</p>

<h4>●不変 (immutable) なセット</h4>
<p> 最初に不変なセットから説明しましょう。セットの型は Set[A] で、型パラメータ A が要素の型を表します。セットは次の構文で生成します。
</p>
<pre class="item">
Set[A]()
Set[A](item1, item2, ...)
</pre>
<p> マップと同様にカッコの中に要素を指定します。() だけの場合は空のセットが生成されます。要素を指定する場合は型 [A] を省略することができます。Scala が型推論で型を決めてくれます。
</p>
<p> 簡単な例を示します。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4, 5)
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&gt; a contains 3
res1: Boolean = true

scala&gt; a(3)
res2: Boolean = true

scala&gt; a contains 0
res3: Boolean = false

scala&gt; a(0)
res4: Boolean = false

scala&gt; a.size
res5: Int = 5

scala&gt; a.isEmpty
res6: Boolean = false
</pre>

<p> 要素の有無はメソッド contains でチェックすることができます。カッコ ( ) によるアクセスも contains と同じ意味になります。つまり、a(3) は a contains 3 と同じで、セット a に要素 3 があれば true を返し、無ければ false を返します。セットの大きさはメソッド size で求めることができます。メソッド isEmpty はセットが空であれば true を、そうでなければ false を返します。
</p>

<h4>●データの追加</h4>
<p> データの追加は演算子 + を使います。
</p>
<pre>
scala&gt; a + 10
res7: scala.collection.immutable.Set[Int] = Set(5, 10, 1, 2, 3, 4)

scala&gt; a + (10, 20, 30)
res8: scala.collection.immutable.Set[Int] = Set(5, 10, 20, 1, 2, 3, 30, 4)
</pre>
<p> 演算子 + は要素を追加した新しいセットを返します。複数の要素をタプルに格納して、まとめて追加することもできます。
</p>
<p> 演算子 ++ を使うと、セットや他の列に格納されたデータを追加することができます。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4, 5)
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&gt; a ++ Set(6, 7, 8, 9)
res0: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 9, 2, 7, 3, 8, 4)

scala&gt; a ++ List(6, 7, 8, 9)
res1: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 9, 2, 7, 3, 8, 4)

scala&gt; a ++ Array(6, 7, 8, 9)
res2: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 9, 2, 7, 3, 8, 4)
</pre>
<h4>●データの削除</h4>
<p> データの削除は演算子 - を使います。
</p>
<pre>
scala&gt; a - 5
res8: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&gt; a - (1, 2, 3)
res9: scala.collection.immutable.Set[Int] = Set(5, 4)

scala&gt; a - 10
res10: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)
</pre>
<p> 演算子 - は要素を削除した新しい集合を返します。削除する要素が無い場合は、セットをそのまま返します。
</p>
<p> 演算子 -- を使うと、セットや他の列に格納されたデータを削除することができます。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4, 5)
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&gt; a -- Set(1, 3, 5)
res0: scala.collection.immutable.Set[Int] = Set(2, 4)

scala&gt; a -- List(1, 3, 5)
res1: scala.collection.immutable.Set[Int] = Set(2, 4)

scala&gt; a -- Array(1, 3, 5)
res2: scala.collection.immutable.Set[Int] = Set(2, 4)
</pre>
<h4>●集合演算</h4>
<p> セットは集合を扱うメソッドや演算子が用意されています。主なメソッドを下表に示します。
</p>

<table border=1>
<caption>表 : セットの集合演算</caption>
<thead>
  <tr><th>メソッド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>s1 subsetOf s2 </td><td>s1 が s2 の部分集合であれば真を返す</td></tr>
  <tr><td>s1 intersect s2</td><td>s1 と s2 の積を求める (s1 &amp; s2)</td></tr>
  <tr><td>s1 union s2    </td><td>s1 と s2 の和を求める (s1 | s2)</td></tr>
  <tr><td>s1 diff s2     </td><td>s1 と s2 の差を求める (s1  &amp;~ s2)</td></tr>
</tbody>
</table>

<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4)
a: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&gt; val b = Set(3, 4, 5, 6)
b: scala.collection.immutable.Set[Int] = Set(3, 4, 5, 6)

scala&gt; a union b
res0: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 3, 4)

scala&gt; a | b
res1: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 3, 4)

scala&gt; a intersect b
res2: scala.collection.immutable.Set[Int] = Set(3, 4)

scala&gt; a & b
res3: scala.collection.immutable.Set[Int] = Set(3, 4)

scala&gt; a diff b
res4: scala.collection.immutable.Set[Int] = Set(1, 2)

scala&gt; a &amp;~ b
res5: scala.collection.immutable.Set[Int] = Set(1, 2)

scala&gt; Set(1, 2) subsetOf a
res6: Boolean = true

scala&gt; Set(1, 2) subsetOf b
res7: Boolean = false

scala&gt; Set(4,3,2,1) == a
res8: Boolean = true

scala&gt; Set(1, 2, 3) + 4 == a
res9: Boolean = true

scala&gt; a == b
res10: Boolean = false
</pre>
<p> なお、セットの等値は演算子 ==, != で判定することができます。
</p>

<h4>●要素の取得</h4>
<p> セットは for 式、メソッド foreach、イテレータを使って、要素を順番に取り出すことができます。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4, 5)
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&gt; for (x &lt;- a) println(x)
5
1
2
3
4

scala&gt; a foreach println
5
1
2
3
4

scala&gt; val it = a.iterator
it: Iterator[Int] = non-empty iterator

scala&gt; while (it.hasNext) println(it.next)
5
1
2
3
4
</pre>

<h4>●セットと列の変換</h4>
<p> セット Set[A] は列 Seq[A] に変換することができます。逆に、列 Seq[A] はセット Set[A] に変換することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = Set(1, 2, 3, 4, 5)
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&gt; a.toList
res0: List[Int] = List(5, 1, 2, 3, 4)

scala&gt; a.toVector
res1: Vector[Int] = Vector(5, 1, 2, 3, 4)

scala&gt; a.toArray
res2: Array[Int] = Array(5, 1, 2, 3, 4)

scala&gt; List(1, 2, 3, 1, 1, 2, 3, 4).toSet
res3: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&gt; Vector(1, 2, 3, 1, 1, 2, 3, 4).toSet
res4: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&gt; Array(1, 2, 3, 1, 1, 2, 3, 4).toSet
res5: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)
</pre>
<p> toList, toVector, toArray などでセットを列に変換することができます。また、列はメソッド toSet でセットに変換することができます。このとき、重複要素が削除されることに注意してください。
</p>

<h4>●可変 (mutable) なセット</h4>
<p> 可変 (mutable) なセットは scala.collection.mutable.Set を使います。Set は immutable なセットが使っているので、import で別名を付けるといいでしょう。簡単な例を示します。
</p>
<pre>
scala&gt; import scala.collection.mutable.{Set=&gt;MSet}
import scala.collection.mutable.{Set=&gt;MSet}

scala&gt; val a = MSet(1, 2, 3, 4, 5)
a: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&gt; a(3)
res0: Boolean = true

scala&gt; a contains 3
res1: Boolean = true

scala&gt; a(0)
res2: Boolean = false

scala&gt; a contains 10
res3: Boolean = false
</pre>

<h4>●セットの更新</h4>
<p> mutable なセットは要素の追加や削除を破壊的に行うことができます。自分自身を書き換えるので、元の値は残りません。
</p>
<p> 要素の追加は演算子 += もしくはメソッド add を使います。簡単な例を示しましょう。
</p>
<pre>
scala&gt; a += 10
res4: a.type = Set(1, 5, 2, 3, 10, 4)

scala&gt; a += (20, 30, 40)
res5: a.type = Set(30, 1, 5, 2, 20, 3, 10, 4, 40)

scala&gt; a add 100
res6: Boolean = true

scala&gt; a
res7: scala.collection.mutable.Set[Int] = Set(30, 1, 100, 5, 2, 20, 3, 10, 4, 40)

scala&gt; a add 100
res8: Boolean = false

scala&gt; a
res9: scala.collection.mutable.Set[Int] = Set(30, 1, 100, 5, 2, 20, 3, 10, 4, 40)
</pre>
<p> 演算子 += はセットを返しますが、メソッド add は要素を追加した場合は true を、同じ要素があって追加できなかった場合は false を返します。
</p>

<p> 要素の削除は演算子 -= もしくは remove を使います。
</p>
<pre>
scala&gt; a -= 100
res10: a.type = Set(30, 1, 5, 2, 20, 3, 10, 4, 40)

scala&gt; a remove 40
res11: Boolean = true

scala&gt; a remove 50
res12: Boolean = false

scala&gt; a
res13: scala.collection.mutable.Set[Int] = Set(30, 1, 5, 2, 20, 3, 10, 4)

scala&gt; a -= (10, 20, 30)
res14: a.type = Set(1, 5, 2, 3, 4)

scala&gt; a.clear

scala&gt; a
res16: scala.collection.mutable.Set[Int] = Set()
</pre>
<p> 演算子 -= はセットを返しますが、メソッド remove は要素を削除できた場合は true を、要素が無くて削除できなかった場合は false を返します。メソッド clear は全要素を削除します。つまり、セットを空にします。
</p>

<p> なお、mutable なセットの更新は演算子 ++= や --= を使っても行うことができます。
</p>
<pre>
scala&gt; val a = MSet(1, 2, 3, 4, 5)
a: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&gt; a ++= Set(6, 7, 8, 9)
res0: a.type = Set(9, 1, 5, 2, 6, 3, 7, 4, 8)

scala&gt; a ++= List(10, 11, 12, 13, 14, 15)
res1: a.type = Set(15, 9, 1, 2, 3, 10, 4, 11, 12, 13, 5, 6, 7, 14, 8)

scala&gt; a --= List(6, 7, 8, 9, 10)
res2: a.type = Set(15, 1, 2, 3, 4, 11, 12, 13, 5, 14)

scala&gt; a --= Set(1, 2, 3, 4, 5)
res3: a.type = Set(15, 11, 12, 13, 14)
</pre>

<h4>●TreeMap と TreeSet</h4>
<p> ハッシュ法はデータを高速に探索できる優れたアルゴリズムですが、データの順序はバラバラになるので、たとえばデータの中から最小値や最大値を探すような処理には不向きです。このような場合、順序木を使ってマップやセットを実装すると、最小値や最大値を簡単に求めることができるようになります。Scala には scala.collection.imutable に TreeMap と TreeSet が用意されています。
</p>
<p> Scala の場合、TreeMap と TreeSet の実装には「赤黒木 (Red-Black Tree) 」という二分木 (平衡木) が使われています。データ数を N とすると、平衡木はデータの挿入、探索、削除を O(log<SUB>2</SUB> N) で行うことができます。平衡木のアルゴリズムに興味のある方は、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> をお読みください。AVL 木、2-3 木、赤黒木、AA 木について詳しく説明しています。
</p>

<p> TreeMap の型は TreeMap[K, V] で、TreeSet の型は TreeSet[A] です。TreeMap と TreeSet は次の構文で生成します。
</p>
<pre class="item">
TreeMap[K, V]()(implicit ordering: Ordering[K])
TreeMap[K, V](k1 -> v1, k2 -> v2, ...)(implicit ordering: Ordering[K])
</pre>
<pre class="item">
TreeSet[A]()(implicit ordering: Ordering[A])
TreeSet[A](item1, item2, ...)(implicit ordering: Ordering[A])
</pre>
<p> データの比較には Ordering を使います。これは暗黙の引数として定義されているので省略することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; import scala.collection.immutable.{TreeMap, TreeSet}
import scala.collection.immutable.{TreeMap, TreeSet}

scala&gt; val a = TreeMap("foo" -> 10, "bar" -> 20, "baz" -> 30)
a: scala.collection.immutable.TreeMap[String,Int] = Map(bar -> 20, baz -> 30, foo -> 10)

scala&gt; a("foo")
res0: Int = 10

scala&gt; a.get("oops")
res1: Option[Int] = None

scala&gt; val b = TreeSet(5, 4, 3, 2, 1)
b: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 2, 3, 4, 5)

scala&gt; b(1)
res2: Boolean = true

scala&gt; b(10)
res4: Boolean = false
</pre>
<p> データの挿入は Map や Set と同じメソッドで行うことができますが、このほかにもメソッド insert が用意されています。
</p>
<pre>
scala&gt; a.insert("oops", 40)
res5: scala.collection.immutable.TreeMap[String,Int] = Map(bar -> 20, baz -> 30, foo -> 10, oops -> 40)

scala&gt; b.insert(6)
res6: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 2, 3, 4, 5, 6)
</pre>
<p> 最小値と最大値は fisrtKey, lastKey, min, max で求めることができます。
</p>
<pre>
scala&gt; a.firstKey
res7: String = bar

scala&gt; a.lastKey
res8: String = foo

scala&gt; a.max
res9: (String, Int) = (foo,10)

scala&gt; a.min
res10: (String, Int) = (bar,20)

scala&gt; b.firstKey
res11: Int = 1

scala&gt; b.lastKey
res12: Int = 5

scala&gt; b.max
res13: Int = 5

scala&gt; b.min
res14: Int = 1
</pre>
<p> TreeMap の場合、max と min は該当するキーとその値をタプルに格納して返します。
</p>
<p> for 式、メソッド foreach、イテレータで要素を取り出すと、それは昇順にソートした結果と同じになります。
</p>
<pre>
scala&gt; for (x &lt;- a) println(x)
(bar,20)
(baz,30)
(foo,10)

scala&gt; a.foreach(println)
(bar,20)
(baz,30)
(foo,10)

scala&gt; val it1 = a.iterator
it1: Iterator[(String, Int)] = non-empty iterator

scala&gt; while (it1.hasNext) println(it1.next)
(bar,20)
(baz,30)
(foo,10)

scala&gt; for (x &lt;- b) println(x)
1
2
3
4
5

scala&gt; b.foreach(println)
1
2
3
4
5

scala&gt; val it2 = b.iterator
it2: Iterator[Int] = non-empty iterator

scala&gt; while (it2.hasNext) println(it2.next)
1
2
3
4
5
</pre>
<p> このほかにも、便利なメソッドが多数用意されています。詳細は Scala のドキュメントをお読みください。
</p>

<h4>●たらいまわし関数</h4>
<p> 最後に「たらいまわし関数」を使ってハッシュ法の効果を確かめてみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : たらいまわし関数

  def tarai(x:Int, y:Int, z:Int): Int =
    if (x &lt;= y) y
    else tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))

  def tak(x:Int, y:Int, z:Int): Int =
    if (x &lt;= y) z
    else tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))
</pre>
<p> 関数 tarai や tak は「たらいまわし関数」といって、再帰的に定義されています。これらの関数は、引数の与え方によっては実行に時間がかかるため、Lisp などのベンチマークに利用されることがあります。関数 tarai は通称「竹内関数」と呼ばれていて、日本の代表的な Lisper である竹内郁雄先生によって考案されたそうです。そして、関数 tak は関数 tarai のバリエーションで、John Macarthy 先生によって作成されたそうです。
</p>

<p> それでは、さっそく実行してみましょう。
</p>
<pre class="item">
tarai(16, 8, 0) : 88.0 [s]
tak(24, 12, 0)  : 11.0 [s]

実行環境 : Windows 7, Core i7-2670QM 2.20GHz, Scala ver 2.11.1
</pre>
<p> このように、たらいまわし関数は引数の値が小さくても実行に時間がかかります。
</p>

<h4>●メモ化による高速化</h4>
<p> たらいまわし関数が遅いのは、同じ値を何度も計算しているためです。この場合、表 (table) を使って処理を高速化することができます。同じ値を何度も計算することがないように、計算した値は表に格納しておいて、2 回目以降は表から計算結果を求めるようにします。このような手法を「表計算法」とか「メモ化 (memoization または memoisation) 」といいます。
</p>
<p> 関数 tarai の場合は「遅延評価」を行う処理系、たとえば関数型言語の Haskell では高速に実行することができます。プログラムを見てください。x &lt;= y のとき、tarai は y を返しますが、このとき引数 z の値は必要ありませんね。引数 z の値は x &gt; y のときに計算するようにすれば、無駄な計算を省略することができます。Scala にも遅延評価があるので、tarai の高速化は遅延評価を取り上げるところで行ってみましょう。なお、tak は x &lt;= y のときに z を返しているため、遅延評価で高速化することはできません。ご注意ください。
</p>

<p> それでは、関数 tak をメモ化してみましょう。Scala の場合、メモ化は mutable なマップを使うと簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : たらいまわし関数のメモ化

  // ハッシュ表
  val takTbl = MMap[(Int,Int,Int),Int]()

  def takMemo(x: Int, y: Int, z: Int): Int =
    takTbl.get((x, y, z)) match {
      case Some(n) =&gt; n
      case None =&gt; {
        val n = if (x &lt;= y) z
                else takMemo(takMemo(x - 1, y, z),
                             takMemo(y - 1, z, x),
                             takMemo(z - 1, x, y))
        takTbl((x, y, z)) = n
        n
      }
    }

  // 連想リスト
  val takLst = ListMap[(Int,Int,Int),Int]()

  def takMemoL(x: Int, y: Int, z: Int): Int =
    takLst.get((x, y, z)) match {
      case Some(n) =&gt; n
      case None =&gt; {
        val n = if (x &lt;= y) z
                else takMemoL(takMemoL(x - 1, y, z),
                              takMemoL(y - 1, z, x),
                              takMemoL(z - 1, x, y))
        takLst((x, y, z)) = n
        n
      }
    }
</pre>
<p> 関数 takMemo の値を格納するマップ (ハッシュ表) を変数 takTbl に用意します。関数 tak では、引数 x, y, z を要素とするタプルを作り、それをキーとして takTbl を検索します。takTbl にキーがあれば、その値を返します。そうでなければ、値を計算して takTbl にセットして、その値を返します。
</p>
<p> 実行速度を比較するため、連想リストを使ったマップ ListMap でメモ化した関数 takMemoL を作ります。LispMap は scala.collection.mutable に用意されています。ListMap はキーを線形探索するので、実行時間は Map (ハッシュ表) よりも遅くなるはずです。
</p>
<h4>●実行結果</h4>
<p> それでは実際に実行してみましょう。
</p>
<pre class="item">
tak(24, 12, 0) : 11     [s]
連想リスト     :  0.207 [s]
ハッシュ表     :  0.013 [s]
</pre>
<p> メモ化の効果はとても大きくて、連想リスト (ListMap) でも実行時間は 1 秒かかりません。ハッシュ表 (Map) を使うと、もっと高速になりました。
</p>
<p> ご参考までに、引数の値をもっと増やして実行してみました。
</p>
<pre class="item">
tak (80, 40, 0)
連想リスト : 33.727 [s]
ハッシュ表 :  0.027 [s]
</pre>
<p> Map (ハッシュ表) の場合、引数の値を増やしても高速に実行することができます。ハッシュ法の効果も大変大きいですね。また、同じ計算を再度実行すると、メモ化の働きにより値をすぐに求めることができます。
</p>

<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="http://docs.scala-lang.org/ja/overviews/collections/introduction.html">
COLLECTIONS - Scala Documentation</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// Tarai.scala : たらいまわし関数
//
//               Copyright (C) 2014 Makoto Hiroi
//
import scala.collection.mutable.{Map =&gt; MMap, ListMap}

object Tarai {
  // たらいまわし関数
  def tarai(x:Int, y:Int, z:Int): Int =
    if (x &lt;= y) y
    else tarai(tarai(x - 1, y, z), tarai(y - 1, z, x), tarai(z - 1, x, y))

  def tak(x:Int, y:Int, z:Int): Int =
      if (x &lt;= y) z
      else tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))

  // ハッシュ表
  val takTbl = MMap[(Int,Int,Int),Int]()

  def takMemo(x: Int, y: Int, z: Int): Int =
    takTbl.get((x, y, z)) match {
      case Some(n) =&gt; n
      case None =&gt; {
        val n = if (x &lt;= y) z
                else takMemo(takMemo(x - 1, y, z),
                             takMemo(y - 1, z, x),
                             takMemo(z - 1, x, y))
        takTbl((x, y, z)) = n
        n
      }
    }

  // 連想リスト
  val takLst = ListMap[(Int,Int,Int),Int]()

  def takMemoL(x: Int, y: Int, z: Int): Int =
    takLst.get((x, y, z)) match {
      case Some(n) =&gt; n
      case None =&gt; {
        val n = if (x &lt;= y) z
                else takMemoL(takMemoL(x - 1, y, z),
                              takMemoL(y - 1, z, x),
                              takMemoL(z - 1, x, y))
        takLst((x, y, z)) = n
        n
      }
    }

  def main(args: Array[String]) {
    val s0 = System.currentTimeMillis
    println(takMemoL(80, 40, 0))
    println((System.currentTimeMillis - s0) + "msec")
    val s1 = System.currentTimeMillis
    println(takMemo(80, 40, 0))
    println((System.currentTimeMillis - s1) + "msec")
  }
}
</pre>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala18.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala20.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>