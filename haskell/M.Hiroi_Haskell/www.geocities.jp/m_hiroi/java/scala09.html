<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881777</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala08.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala10.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>継承</h3>
<p> 前回はオブジェクト指向の基本について簡単に説明しました。今回はオブジェクト指向機能の目玉ともいえる「継承」について取り上げます。まず最初に、一般的なオブジェクト指向で使われている継承について簡単に説明します。
</p>

<h4>●単一継承</h4>
<p> 継承には「単一継承」と「多重継承」の 2 種類があります。単一継承は、ただ一つのクラスからしか機能を継承することができません。したがって、クラスの階層は下図のような木構造 <sup><a href="scala09.html#note1">[*1]</a></sup> で表すことができます。
</p>

<pre class="fig">
            Ａ
          ／｜＼
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ
    ／  ＼
  ／      ＼
Ｅ          Ｆ

図 : 単一継承におけるクラスの階層
</pre>

<p> 継承は何段階に渡って行われてもかまいません。たとえばクラス E の場合、スーパークラスが B で、B のスーパークラスが A に設定されています。サブクラスは複数あってもかまいません。たとえば、A のサブクラスは B, C, D の 3 つがあり、B のサブクラスは E, F の 2 つがあります。上図では、クラス A のスーパークラスはありませんが、ほかのクラスはただ一つのスーパークラスを持っています。オブジェクト指向言語では Smalltalk, Java, Ruby, Scala が単一継承です。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 木 (tree) は階層的な関係を表すためのデータ構造です。身近な例ではディレクトリ (フォルダ) の階層構造が木にあたります。
</div>
<h4>●多重継承</h4>
<p> これに対し、多重継承は複数のクラスを継承することができます。このため、クラスの階層は木構造ではなく、下図のようなグラフ <sup><a href="scala09.html#note2">[*2]</a></sup> で表すことができます。
</p>

<pre class="fig">
              Ａ
            ／  ＼
          ／      ＼
        Ｂ          Ｃ
      ／  ＼      ／  ＼
    ／      ＼  ／      ＼
  Ｄ          Ｅ          Ｆ

図 : 多重継承におけるクラスの階層
</pre>

<p> クラス E に注目してください。スーパークラスには B と C の 2 つがあります。多重継承では、単一継承と同じくサブクラスを複数持つことができ、なおかつ、スーパークラスも複数持つことができるのです。Ｃ++や CLOS (Common Lisp Object System) は多重継承をサポートしています。スクリプト言語では Perl や Python が多重継承です。
</p>

<p> Java や Scala の場合、基本的には単一継承ですが Java であれば「インターフェース (interface) 」を使ってメソッドの「仕様」だけを、Scala であれば「トレイト (trait) 」を使って「仕様」や「実装」を多重継承できるようになっています。トレイトについては次回以降で詳しく説明します。
</p>

<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> グラフは木をより一般化したデータ構造です。数学のグラフ理論では、いくつかの点とそれを結ぶ線でできた図形を「グラフ」といいます。
</div>

<h4>●継承の仕組み</h4>
<p> 一般的なオブジェクト指向言語の場合、継承によって引き継がれる性質は定義されたインスタンス変数やメソッドになります。次の図を見てください。
</p>

<pre class="fig">
     class
 ┌─ Foo  ─┐          ┌─ instance ─┐
 ├─────┤          ├───────┤
 │  変数 a  │────→│    変数 a    │
 ├─────┤          ├───────┤
 │  変数 b  │          │    変数 b    │
 └─────┘          └───────┘
method : get_a, get_b
      │
     継承
      ↓
 ┌─ Bar  ─┐          ┌─ instance ─┐
 ├─────┤────→├───────┤
 │  変数 c  │          │    変数 a    │
 └─────┘          ├───────┤
method : get_c()         │    変数 b    │
                         ├───────┤
                         │    変数 c    │
                         └───────┘

        図 : 一般的な継承
</pre>

<p> クラス Foo にはインスタンス変数 a, b とリーダーメソッド get_a, get_b が定義されています。次に、クラス Bar を定義します。Bar は Foo を継承し、Bar 固有のインスタンス変数 c とリーダーメソッド get_c を定義します。Foo と Bar のインスタンスを生成すると、上図に示したように、Bar のインスタンスにはクラス Foo で定義された変数 a, b も含まれます。このように、Foo のインスタンス変数が Bar に継承されます。
</p>

<p> Foo のインスタンスを生成すると、もちろん変数 a, b は含まれていますが、Bar のインスタンスとメモリを共有することはありません。クラスはオブジェクトの設計図です。設計に共通な部分があったとしても、それから生み出されるインスタンスは別々の実体で、インスタンス変数を共有することはないのです。
</p>

<p> クラス Bar にはメソッド get_c しか定義されていませんが、クラス Foo を継承することにより、メソッド get_a と get_b を呼び出すことができます。Bar のインスタンスに対して get_a を呼び出すと、クラス Bar には get_a が定義されていないのでスーパークラス Foo を調べ、そこで定義されている get_a が呼び出されます。もちろん、取り出される値は Bar のインスタンスにある変数 a の値です。このように、Foo のメソッドが Bar に継承されます。
</p>

<h4>●単一継承の使い方</h4>
<p> それでは、具体的に Scala の継承を説明しましょう。スーパークラスは class 文で指定します。クラス名の後ろに extends を付けて、その後ろにスーバークラス名を指定します。Scala は単一継承が基本なので、指定できるスーパークラスは一つだけです。継承に必要な設定はこれだけです。
</p>

<p> 簡単な例として、上図のクラスを実際にプログラムしてみましょう。次の例を見てください。
</p>

<pre>
scala&gt; class Foo(var a: Int, var b: Int) {
     | println("call Foo")
     | def get_a(): Int = a
     | def get_b(): Int = b
     | def put_a(n: Int): Unit = a = n
     | def put_b(n: Int): Unit = b = n
     | }
defined class Foo

scala&gt; class Bar(a: Int, b: Int, var c: Int) extends Foo(a, b) {
     | println("call Bar")
     | def get_c(): Int = c
     | def put_c(n: Int): Unit = c = n
     | }
defined class Bar

scala&gt; val a = new Foo(1, 2)
call Foo
a: Foo = Foo@1a34d52

scala&gt; val b = new Bar(10, 20, 30)
call Foo
call Bar
b: Bar = Bar@16278d

scala&gt; a.get_a
res0: Int = 1

scala&gt; a.get_b
res1: Int = 2

scala&gt; b.get_a
res2: Int = 10

scala&gt; b.get_b
res3: Int = 20

scala&gt; b.get_c
res4: Int = 30

scala&gt; a.get_c
&lt;console&gt;:10: error: value get_c is not a member of Foo
              a.get_c
                ^
</pre>
<p> クラス Foo のコンストラクタ引数 a, b には var があるので、これらの引数はフィールド変数として扱われます。メソッド get_a と get_b の定義は簡単です。与えられたインスタンスから値を取り出すだけです。次にクラス Bar を定義します。extends の後ろにスーパークラス Foo を指定します。これで Foo のフィールド変数とメソッドを継承することができます。
</p>

<p> Bar のコンストラクタ引数では引数 c に var があるので、引数 c がフィールド変数として扱われます。a, b はただの引数になります。フィールド変数 a, b の初期化は Foo のコンストラクタで行っていますね。このメソッドを呼び出すことができれば、わざわざ Bar のコンストラクタで a, b の初期化を行う必要はありません。この場合、extends Foo の後ろにコンストラクタ引数を指定してください。これで Foo のコンストラクタが呼び出されます。
</p>
<p> Bar のインスタンスを生成すると、Foo のコンストラクタが呼び出されるので、call Foo が表示されてから call Bar が表示されます。スーパークラスのメソッドは Bar のインスタンスからでも呼び出すことができます。b.get_a は 10 になりますし、自クラスのメソッド b.get_c は 30 になります。なお、Foo のインスタンス a からサブクラスのメソッド get_c は呼び出すことができません。エラーになります。
</p>

<h4>●オーバーライド</h4>
<p> 継承はクラスに新しい機能を追加するだけではなく、メソッドをオーバーライドすることで機能を変更することができます。なお、オーバーライドと多重定義 (オーバーロード) はまったく異なる機能です。混同しないように注意してください。
</p>
<p> それでは、簡単な例を示しましょう。フィールド変数の合計値を求めるメソッド sum を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : メソッドのオーバーライド

class Foo(var a: Int, var b: Int) {
  def get_a(): Int = a
  def get_b(): Int = b
  def put_a(n: Int): Unit = a = n
  def put_b(n: Int): Unit = b = n
  def sum(): Int = a + b
}

class Bar(a: Int, b: Int, var c: Int) extends Foo(a, b) {
  def get_c(): Int = c
  def put_c(n: Int): Unit = c = n
  override def sum(): Int = super.sum() + c
}

object sample0901 {
  def main(args: Array[String]) {
    val a = new Foo(1, 2)
    val b = new Bar(10, 20, 30)
    println(a.sum)
    println(b.sum)
  }
}
</pre>

<p> クラス Foo でメソッド sum を定義します。そして、クラス Bar でメソッド sum をオーバーライドします。オーバーライドはスーパークラスにあるメソッドと同じ名前のメソッドを定義するだけです。Scala の場合、def の前にキーワード override を指定する必要があります。
</p>

<p> Scala は Java と同様に super を使ってスーパークラスのメソッドを呼び出すことができます。
</p>
<pre class="item">
super.method(args, ...)
</pre>
<p> Bar のメソッド sum では、super.sum でスーパークラスのメソッド sum を呼び出して、その結果にフィールド変数 c の値を足し算します。実行結果は次のようになります。
</p>
<pre>
C&gt;scala sample0901
3
60
</pre>
<p> 正常に動作していますね。
</p>

<h4>●型の継承</h4>
<p> Scala の場合、Java と同様にクラス名は型を表す識別子として利用することができます。継承はフィールド変数やメソッドに作用するだけではなく、型にも作用します。サブクラスに属するインスタンスは型も継承されるため、スーパークラスの型として取り扱うことができるのです。インスタンスが属するクラスを判定するメソッド isInstanceOf を使って調べてみましょう。
</p>
<pre class="item">
obj.isInstanceOf[型] =&gt; Boolean
</pre>
<p> 次の例を見てください。
</p>
<pre>
scala&gt; class Foo
defined class Foo

scala&gt; class Bar extends Foo
defined class Bar

scala&gt; class Baz extends Bar
defined class Baz

scala&gt; val a = new Foo
a: Foo = Foo@154b8c5

scala&gt; val b = new Bar
b: Bar = Bar@81f160

scala&gt; val c = new Baz
c: Baz = Baz@1920ade

scala&gt; a.isInstanceOf[Foo]
res0: Boolean = true

scala&gt; b.isInstanceOf[Foo]
res1: Boolean = true

scala&gt; c.isInstanceOf[Foo]
res2: Boolean = true

scala&gt; a.isInstanceOf[Bar]
res3: Boolean = false

scala&gt; b.isInstanceOf[Bar]
res4: Boolean = true

scala&gt; c.isInstanceOf[Bar]
res5: Boolean = true

scala&gt; a.isInstanceOf[Baz]
res6: Boolean = false

scala&gt; b.isInstanceOf[Baz]
res7: Boolean = false

scala&gt; c.isInstanceOf[Baz]
res8: Boolean = true
</pre>
<p> クラス Bar はクラス Foo を継承しています。Foo のインスタンス a は isInstanceOf でチェックすると、Foo では true になり、Bar では false になります。ところが、Bar のインスタンス b は、Bar で true になるのは当然ですが、Foo のサブクラスなので型が継承され、Fooでも true になります。そして、Bar を継承したクラス Baz のインスタンスを作って、それを isInstanceOf でチェックすると、Foo, Bar, Baz のどれでも true になります。
</p>

<p> このように、クラスを単一継承してサブクラスを作ると、サブクラスはスーパークラスの部分集合として考えることができます。次の図を見てください。サブクラス Baz は Bar や Foo に含まれているので、そのインスタンスから Bar や Foo のメソッドを呼び出することができるわけです。
</p>

<pre class="fig">
  ┌──────────┐
  │        Foo         │
  │  ┌──────┐  │
  │  │    Bar     │  │
  │  │  ┌──┐  │  │
  │  │  │Baz │  │  │
  │  │  │    │  │  │
  │  │  └──┘  │  │
  │  │            │  │
  │  └──────┘  │
  │                    │
  └──────────┘

図 : クラスとサブクラスの関係
</pre>

<h4>●継承とオーバーライドの制限</h4>
<p> クラスを定義するとき、class の前に final を付けると、そのクラスを継承したサブクラスを作ることはできません。つまり、継承を禁止することができます。また、メソッドを定義するとき def の前に final を付けると、サブクラスでオーバーライドすることができなくなります。これらの機能は Java と同じです。
</p>

<h4>●抽象クラス</h4>
<p> クラスでメソッドを定義するとき、メソッドの型だけを宣言することができます。これを「抽象メソッド (abstract method) 」といいます。そして、抽象メソッドを持つクラスを「抽象クラス (abstract class) 」といい、new でインスタンスを生成することはできません。なお、Scala はメソッドだけではなくフィールド変数も抽象フィールド変数として定義することができます。
</p>
<p> 抽象クラスは次のように定義します。
</p>
<pre class="item">
abstract class クラス名 {
  ...
  val 名前: 型
  var 名前: 型
  def 名前(引数: 型, ...): 型
  ...
}
</pre>
<p> 抽象フィールド変数と抽象メソッドは名前と型を指定するだけで、= 以降の式や値は書きません。抽象フィールド変数、抽象メソッドを持つクラスは class の前に必ず abstract を宣言してください。なお、Java と違って、メソッドの定義で abstract をつける必要はありません。また、抽象メソッドがないクラスでも abstract を宣言することができます。もちろん、そのクラスは抽象クラスになります。
</p>
<p> 抽象クラスは継承されることを前提としたクラスで、抽象フィールド変数や抽象メソッドはサブクラスにおいて具体的に定義されます。抽象クラスでは、サブクラス共通のメソッドを定義します。このとき、抽象メソッドを呼び出してもかまいません。サブクラスのインスタンスが生成されるとき、そのサブクラスでは抽象メソッドが具体化されているはずなので、実際にはサブクラスのメソッドが呼び出されることになります。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; abstract class Foo {
     | def foo(): Unit
     | }
defined class Foo

scala&gt; class Foo1 extends Foo {
     | def foo(): Unit = println("Foo!!")
     | }
defined class Foo1

scala&gt; val a = new Foo1
a: Foo1 = Foo1@82c5f1

scala&gt; a.foo()
Foo!!
</pre>
<p> クラス Foo のメソッド foo は抽象メソッドなので、Foo は抽象クラスになります。abstract を付けないとエラーになります。クラス Foo1 は Foo を継承していて、抽象メソッド foo をオーバーライドしています。抽象メソッドをオーバーライドする場合は、キーワード override を省略してもかまいません。もちろん、override を付けても大丈夫です。これで、Foo の抽象メソッドをすべてオーバーライドしたので、クラス Foo1 は具象クラスとなり、new でインスタンスを生成することができ、メソッド foo を呼び出すことができます。
</p>


<h4>●図形のクラス</h4>
<p> それでは簡単な例題として、図形の面積を求めるプログラムを作ってみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 図形のクラス

abstract class Figure {
  def kindOf(): String
  def area(): Double
  def print(): Unit = println(kindOf() + ": area = " + area())
}

class Triangle(val altiude: Double, val base: Double) extends Figure {
  def kindOf(): String = "Triangle"
  def area(): Double = altiude * base / 2
}

class Rectangle(val width: Double, val height: Double) extends Figure {
  def kindOf(): String = "Rectangle"
  def area(): Double = width * height
}

class Circle(val radius: Double) extends Figure {
  def kindOf(): String = "Circle"
  def area(): Double = radius * radius * Math.PI
}

object sample0902 {
  def main(args: Array[String]) {
    val a = new Triangle(2, 2)
    val b = new Rectangle(2, 2)
    val c = new Circle(2)
    a.print
    b.print
    c.print
  }
}
</pre>

<p> クラス Figure は抽象クラスです。メソッド kindOf と area が抽象メソッドで、kindOf は図形の種類を文字列で返し、area は図形の面積を計算して返します。kindOf と area はサブクラスで定義します。
</p>
<p> print は図形の種別と面積を表示するメソッドです。ここで、抽象メソッド kindOf と area を呼び出しています。実際には、print を呼び出したインスタンスが属するクラスのメソッドが呼び出されます。つまり、ポリモーフィズムにより適切なメソッドが呼び出されるわけです。
</p>

<p> クラス Triangle, Rectangle, Circle は Figure を継承します。どのクラスも抽象メソッド kindOf と area を具体化しています。なお、スーパークラスの抽象メソッドをすべて具体化しないと、そのサブクラスも抽象クラスになるため、コンパイルでエラーになります。ご注意ください。
</p>

<p> それでは実行例を示します。
</p>
<pre>
C&gt;scala sample0902
Triangle: area = 2.0
Rectangle: area = 4.0
Circle: area = 12.566370614359172
</pre>
<p> 正常に動作していますね。
</p>
<h4>●キャストとポリモーフィズム</h4>
<p> Java や Scala では、サブクラスのインスタンスをスーパークラスのデータ型に変換することができます。型変換のことを「キャスト」といいます。特に、サブクラスをスーパークラスに変換することを「アップキャスト」といい、スーパークラスのインスタンスをサブクラスの型に変換することを「ダウンキャスト」といいます。
</p>

<p> Java や Scala の場合、サブクラスのインスタンスをスーパークラスの変数 (メソッドの引数) や配列などに代入するとき、自動的にアップキャストが行われます。コンパイルエラーは発生しません。これに対し、スーパークラスのインスタンスをサブクラスの変数などに代入するとき、プログラマが明示的にキャストしないとコンパイルエラーになります。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; class Foo {
     | def display(): Unit = println("Foo")
     | }
defined class Foo

scala&gt; class Bar1 extends Foo {
     | override def display(): Unit = println("Bar1")
     | }
defined class Bar1

scala&gt; class Bar2 extends Foo {
     | override def display(): Unit = println("Bar2")
     | }
defined class Bar2

scala&gt; class Baz {
     | def display(): Unit = println("Baz")
     | }
defined class Baz

scala&gt; val a = new Foo
a: Foo = Foo@2059ae

scala&gt; val b = new Bar1
b: Bar1 = Bar1@1e7a160

scala&gt; val c = new Bar2
c: Bar2 = Bar2@9f4771

scala&gt; val d = new Baz
d: Baz = Baz@1329995

scala&gt; val a1: Foo = b      // アップキャスト
a1: Foo = Bar1@1e7a160

scala&gt; val a2: Foo = c      // アップキャスト
a2: Foo = Bar2@9f4771

scala&gt; a.display
Foo

scala&gt; a1.display          // ポリモーフィズム
Bar1

scala&gt; a2.display          // ポリモーフィズム
Bar2
</pre>
<p> 各クラスのインスタンスを生成して変数 a, b, c, d にセットします。Bar1, Bar2 は Foo のサブクラスなので、Foo の変数 a1 に b を、a2 に c を代入することができます。これがアップキャストです。そして、a からメソッド display を呼び出すと Foo と表示されますが、a1, a2 から display を呼び出すと、ポリモーフィズムが働いて Bar1, Bar2 の display が呼び出され、Bar1 と Bar2 が表示されます。
</p>

<pre>
scala&gt; a1.isInstanceOf[Bar1]
res3: Boolean = true

scala&gt; val b1: Bar1 = a1.asInstanceOf[Bar1]  
b1: Bar1 = Bar1@1e7a160

scala&gt; b1.display
Bar1
</pre>
<p> 逆に、Bar1 の変数 b1 に a1 を代入するには明示的にキャストする必要があります。これがダウンキャストです。Scala の場合、isInstanceOf[Bar1] でチェックして、true であればダウンキャストすることができます。型変換はメソッド asInstanceOf[型] で行います。これで変数 b1 に a1 を代入することができます。そして、b1 からメソッド display を呼び出すと Bar1 と表示されます。
</p>
<pre>
scala&gt; d.isInstanceOf[Foo]
&lt;console&gt;:11: warning: fruitless type test: a value of type Baz cannot also be a Foo
              d.isInstanceOf[Foo]
                            ^
res4: Boolean = false

scala&gt; val a3: Foo = d.asInstanceOf[Foo]
java.lang.ClassCastException: Baz cannot be cast to Foo
  ... 32 elided
</pre>

<p> それから、Foo と継承関係のない Baz のインスタンスは、キャストしても Foo や Bar の変数に代入することはできません。ご注意くださいませ。
</p>

<p> 次に、図形のオブジェクトをリストにまとめて格納することを考えてみましょう。Triangle, Rectangle, Circle は型が違うので、同じリストに格納することはできません。この場合、スーパークラス Figure に型変換すると同じリストに格納することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : キャスト (2)

object sample0903 {
  def sumOfArea(xs: List[Figure]): Double = {
    var sum = 0.0
    for (x &lt;- xs) sum += x.area
    sum
  }
  
  def main(args: Array[String]) {
    val a = new Triangle(2, 2)
    val b = new Rectangle(2, 2)
    val c = new Circle(2)
    a.print
    b.print
    c.print
    println(sumOfArea(List(a, b, c)))
  }
}
</pre>
<pre>
C&gt;scala sample0903
Triangle: area = 2.0
Rectangle: area = 4.0
Circle: area = 12.566370614359172
18.566370614359172
</pre>
<p> 関数 sumOfFigure は図形の面積の合計値を求めます。型変換した場合、サブクラスの情報は失われるため、サブクラス独自のメソッドを呼び出すことはできません。型変換したスーパークラスのメソッドしか利用できませんが、ポリモーフィズムによりサブクラスのメソッドが呼び出されるため、図形の面積を正しく計算することができます。
</p>
</div>
<hr>
<div class="contents">
<h3 id="chap02">トレイト</h3>
<p> 前回は継承について簡単に説明しました。今回は「トレイト (trait) 」について取り上げます。
</p>

<h4>●トレイトとは？</h4>
<p> Scala の「トレイト」は、Java の「インターフェース」と比較するならば、実装を持つことが可能なインターフェース、ということができます。Java のインターフェースはメソッドの仕様 (抽象メソッド) だけを定義した抽象クラスの一種ですが、「多重継承」できるところが他のクラスと異なるところです。
</p>
<p> Scala のトレイトは、基本的には Java のインターフェースと同じですが、大きな違いは実装を持たせることができるところです。メソッドだけではなくフィールド変数も持たせることができます。Scala のトレイトは多重継承が簡単にできるように機能を制限した「クラス」と考えることができます。
</p>

<p> クラスを多重継承するとき複雑な問題を引き起こす場合がありますが、その問題点について把握しておくと、トレイトの理解が深まると思います。そこで、まず最初に多重継承の問題点について説明します。
</p>

<h4>●多重継承とその問題点</h4>
<p> 一般的なオブジェクト指向の場合、継承によって引き継がれる性質は定義されたデータ (インスタンス変数など) やメソッドになります。これを「実装の継承」と呼びます。また、インスタンス変数を継承することを特別に「属性の継承」と呼ぶ場合があります。
</p>

<p> 多重継承を行う場合、異なる性質や機能を持つクラスを継承することがあります。たとえば、クラス Foo にはメソッド method_a があり、クラス Bar にはメソッド method_b があるとしましょう。この 2 つのメソッドはまったく異なる働きをするとします。ここで、メソッド method_a はインスタンス変数 x を使っていて、method_b も x を使っていると、多重継承で問題が発生します。
</p>

<p> 一般的な多重継承で、クラス Foo と Bar を継承してクラス Baz を作成した場合、クラス Baz のインスタンスに変数 x は一つしか存在しません。メソッド method_a と method_b は一つしかない x を使うことになります。この場合、どちらかのメソッドは正常に動作しないでしょう。これでは多重継承する意味がありませんね。
</p>

<p> また、多重継承ではインスタンス変数だけではなく、メソッド名が衝突する場合もあります。このように、多重継承では名前の衝突が発生する危険性があるのです。それから、多重継承にはもう一つ問題点があります。それはクラスの階層構造が複雑になることです。
</p>

<p> 単一継承の場合、クラスの階層は木構造になりますが、多重継承ではグラフになります。木構造の場合、クラスの優先順位は簡単に決めることができますが、グラフになると優先順位を決めるためのアルゴリズムは複雑になり、それを理解するのは難しくなります。多重継承は強力な機能ですが、使うときには十分な注意が必要になるのです。 
</p>

<p> ちなみにＣ++の場合、多重継承したクラスに同名のメソッドがある場合、どちらを呼び出すのか明確に指定しないとコンパイルでエラーとなります。またＣ++はメンバ変数も継承されるため、変数名の衝突も発生します。この場合も、どちらの変数を使用するのか明確に指定しないとコンパイルエラーとなります。
</p>

<p> このほかにも、多重継承ではいろいろな問題が発生するため、それを解決するためにＣ++ではいろいろな機能が用意されています。ところが、それらの機能がＣ++をいっそう複雑な言語にしていると M.Hiroi には思えてなりません。Ｃ++はコンパイラ型の言語で、なによりも効率を重視するため、複雑な言語仕様になるのは避けられないのかもしれません。
</p>

<h4>●Mix-in</h4>
<p> これらの問題を回避するため、属性を継承するスーパークラスは一つだけに限定して、あとのスーパークラスは実装だけを継承するという方法があります。これを Mix-in といいます。
</p>

<p> 具体的には、インスタンス変数を定義せずにメソッドだけを記述したクラスを用意します。属性の継承は単一継承になりますが、実装のみを記述したクラスはいくつ継承してかまいません。一つのクラスに複数の実装を混ぜることから Mix-in と呼ばれています。
</p>

<p> なお、Mix-in は特別な機能ではなく、多重継承を使いこなすための方法論にすぎません。多重継承を扱うことができるプログラミング言語であれば Mix-in を行うことが可能です。この Mix-in という方法を言語仕様に取り込んでいるのが Ruby です。Mix-in を下図に示します。
</p>

<pre class="fig">
                Ａ
              ／
            Ｂ
 Mixin A  ／  ＼    Mixin B
    ＼  ／      ＼  ／
      Ｃ          Ｄ

      図 : Mix-in
</pre>
<p> クラス C はクラス B を継承していて、そこにクラス Mixin A が Mix-in されています。クラス D もクラス B を継承していますが、Mix-in されているクラスは Mixin B となります。
</p>

<p> 多重継承の問題点は Mix-in ですべて解決できるわけではありませんが、クラスの階層構造がすっきりとしてわかりやすくなることは間違いありません。Mix-in は多重継承を使いこなす優れた方法だと思います。
</p>

<p> Scala のクラスは単一継承ですが、トレイトは多重継承ができるので、Scala でも Mix-in を使うことができます。また、トレイトは型として使用することもできます。つまり、クラスをトレイトの型に変換することで、ポリモーフィズムを有効に活用することができるわけです。
</p>

<h4>●トレイトの使い方</h4>
<p> それでは、具体的にトレイトの使い方を説明しましょう。トレイトの定義は trait 文で行います。trait の構文を示します。
</p>

<pre class="item">
trait 名前 extends クラス or トレイト [with トレイト] {
  ...
}
</pre>
<p> trait の後ろに名前を指定します。トレイトは extends で他のクラスを継承することができます。継承するクラスがない場合は extends にトレイトを指定することができます。トレイトは with を使って指定します。多重継承する場合は、"with トレイト" を複数記述します。
</p>

<p> そして、ブロックの中でフィールド変数やメソッドなどを宣言します。実装を定義することも可能です。ただし、コンストラクタ引数を持つことはできません。補助コンストラクタも定義することはできません。また、トレイト単独でインスタンスを生成することはできません。ご注意くださいませ。
</p>

<p> クラスでトレイトを継承する場合も extends や with を使います。指定方法は trait と同じです。with を使って複数のトレイトを継承することができます。
</p>

<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : トレイトの使い方

class Foo(val a: Int = 1, val b: Int = 2) {
  def foo(): Unit = println("Foo")
  def method(): Unit = println("Foo method")
}

trait Bar1 {
  def bar1(): Unit = println("Bar1")
  def method(): Unit = println("Bar1 method")
}

trait Bar2 {
  def bar2(): Unit = println("Bar2")
  def method(): Unit = println("Bar2 method")
}

class Baz extends Foo with Bar1 with Bar2 {
  override def method(): Unit = super.method
}

object sample0904 {
  def main(args: Array[String]) {
    val a = new Baz
    println(a.a)
    println(a.b)
    a.foo
    a.bar1
    a.bar2
    a.method
  }
}
</pre>
<p> クラス Foo にはフィールド変数 a, b とメソッド method、トレイト Bar1, bar2 にはメソッド method が定義されています。Foo と Bar1, Bar2 を継承するクラス Baz を定義する場合、同名のメソッド method があるので、method を Baz でオーバーライドしてください。オーバーライドしないと、どのメソッドを呼び出したらよいかコンパイラが決定できずにエラーとなります。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;scala sample0904
1
2
Foo
Bar1
Bar2
Bar2 method
</pre>
<p> 継承したメソッド foo, bar1, bar2 を呼び出すことができるのは当然ですが、3 つのクラスにある method は、どのクラスのメソッドが呼び出されるのでしょうか。表示された Bar2 method から、トレイト Bar2 のメソッドが呼び出されたことがわかります。
</p>

<p> 多重継承でメソッドを探索する場合、簡単に言うと with の右側から順番に行われ、最後に extends で指定したクラスを探します。そして、最初に見つかったメソッドを実行します。したがって、with でトレイトの順番を逆にすると、今度は Bar1 の method が実行されます。
</p>

<p> なお、トレイト Bar1 と Bar2 にスーパークラスが設定されている場合、メソッドの探索はもっと複雑になります。Scala の場合、メソッドの優先順位は「線形化」という方法で決定します。「線形化」については本稿の範囲を超えるので説明は割愛します。興味のある方は調べてみてください。
</p>

<p> 特定のスーパークラスのメソッドを呼び出したい場合は、super の後ろに [クラス名] を指定します。たとえば、Baz で Foo の method を呼び出したい場合は次のように指定します。
</p>
<pre class="item">
override def method(): Unit = super[Foo].method
</pre>
<p> これで Foo の method を呼び出すことができます。
</p>

<h4>●図形のクラス</h4>
<p> それでは簡単な例として、前回作成した図形のプログラムをトレイトを使って書き直してみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 図形のクラス (トレイト版)

trait Figure {
  def kindOf(): String
  def area(): Double
  def print(): Unit = println(kindOf() + ": area = " + area())
}

class Triangle(val altiude: Double, val base: Double) extends Figure {
  def kindOf(): String = "Triangle"
  def area(): Double = altiude * base / 2
}

class Rectangle(val width: Double, val height: Double) extends Figure {
  def kindOf(): String = "Rectangle"
  def area(): Double = width * height
}

class Circle(val radius: Double) extends Figure {
  def kindOf(): String = "Circle"
  def area(): Double = radius * radius * Math.PI
}

object sample0905 {
  def sumOfArea(xs: List[Figure]): Double = {
    var sum = 0.0
    for (x &lt;- xs) sum += x.area
    sum
  }
  
  def main(args: Array[String]) {
    val a = new Triangle(2, 2)
    val b = new Rectangle(2, 2)
    val c = new Circle(2)
    a.print
    b.print
    c.print
    println(sumOfArea(List(a, b, c)))
  }
}
</pre>
<pre>
C&gt;scala sample0905
Triangle: area = 2.0
Rectangle: area = 4.0
Circle: area = 12.566370614359172
18.566370614359172
</pre>
<p> 最初に図形を操作するトレイト Figure を定義します。この中でメソッド kindOf, area, を宣言し、print の実装を定義します。次に図形を表すクラス Triangle, Rectangle, Circle を定義します。ここで extends で Figure を継承します。そして、各クラスで Figure のメソッドを実装します。
</p>
<p> クラスは継承したトレイトの型にアップキャストすることができます。どのクラスも Figure を継承しているので型 List[Figure] のリストに格納することができます。
</p>
<p> 面積の合計を求める関数 sumOfArea は引数に Figure 型のリストを受け取ります。そして、Figure に定義されているメソッドを使ってインスタンスを操作することができます。sumOfArea はメソッド area を呼び出していますが、ポリモーフィズムの働きにより各クラスのメソッド area が呼び出されるので図形の面積を正しく求めることができます。
</p>

<h4>●Ord トレイト</h4>
<p> もうひとつ簡単な例題として、値の大小関係を比較するための演算子を定義するトレイト Ord を作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : Ord トレイト

trait Ord {
  def &lt;(that: Any): Boolean
  def &lt;=(that: Any): Boolean = this &lt; that || this == that
  def &gt;(that: Any): Boolean = !(this &lt; that) &amp;&amp; this != that
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}
</pre>
<p> Scala の演算子はメソッドとして定義されています。たとえば、1 + 2 は (1).+(2) と呼び出すこともできます。1. は浮動小数点数として扱われるので、1 はカッコで囲んでください。== と != はメソッド equals をオーバーライドすれば使用することができます。演算子 &lt; を抽象メソッドとすると、演算子 &lt;=, &gt;, &gt;= は &lt;, ==, != で定義することができます。
</p>

<p> それでは図形の抽象クラス Figure に Ord を実装してみましょう。値の大小関係は面積で比較します。次のリストを見てください。
</p>
<pre class="list">
リスト : Ord の使用例

trait Ord {
  def &lt;(that: Any): Boolean
  def &lt;=(that: Any): Boolean = this &lt; that || this == that
  def &gt;(that: Any): Boolean = !(this &lt; that) &amp;&amp; this != that
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}

abstract class Figure extends Ord {
  def kindOf(): String
  def area(): Double
  def print(): Unit = println(kindOf() + ": area = " + area())
  override def equals(other: Any): Boolean = other match {
    case that: Figure =&gt; area == that.area
    case _ =&gt; false
  }
  def &lt;(other: Any): Boolean = other match {
    case that: Figure =&gt; area &lt; that.area
    case _ =&gt; false
  }
}

class Triangle(val altiude: Double, val base: Double) extends Figure {
  def kindOf(): String = "Triangle"
  def area(): Double = altiude * base / 2
}

class Rectangle(val width: Double, val height: Double) extends Figure {
  def kindOf(): String = "Rectangle"
  def area(): Double = width * height
}

class Circle(val radius: Double) extends Figure {
  def kindOf(): String = "Circle"
  def area(): Double = radius * radius * Math.PI
}

object sample0906 {
  def insertSort(xs: List[Figure]): List[Figure] = {
    def insertElement(x: Figure, xs: List[Figure]): List[Figure] =
      xs match {
        case Nil =&gt; List(x)
        case y::ys =&gt; if (x &lt; y) x::y::ys else y::insertElement(x, ys)
      }
    xs match {
      case Nil =&gt; Nil
      case y::ys =&gt; insertElement(y, insertSort(ys))
    }
  }
  def main(args: Array[String]) {
    val a = new Triangle(5, 5)
    val b = new Rectangle(2, 2)
    val c = new Circle(2)
    for (x &lt;- insertSort(List(a, b, c))) x.print
  }
}
</pre>
<pre>
C&gt;scala sample0906
Rectangle: area = 4.0
Triangle: area = 12.5
Circle: area = 12.566370614359172
</pre>
<p> 抽象クラス Figure でトレイト Ord を継承します。このクラスでメソッド equals をオーバーライドして、メソッド &lt; を実装します。どちらのメソッドも match 式で引数 other の型が Figure であることを確認し、メソッド area を呼び出して大小関係をチェックします。
</p>
<p> 関数 insertSort は拙作のページ <a href="scala04.html#chap02">パターンマッチング</a> で作成した単純挿入ソートの型を Int から Figure に変えたものです。これで図形を格納したリスト (List[Figure]) をソートすることができます。
</p>

<h4>●クラスからトレイトへのキャスト</h4>
<p> Java の場合、どんなクラスでも明示的にキャストすればインターフェースへ型変換することができますが、Scala はそうではありません。isInstanceOf[トレイト] の返り値が true であれば、asInstancOf[トレイト] でキャストすることができますが、返り値が false の場合はキャストすることはできません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; trait foo {
     | def bar(): Unit
     | }
defined trait foo

scala&gt; class Baz1 extends foo {
     | def bar(): Unit = println("oops!")
     | }
defined class Baz1

scala&gt; class Baz2
defined class Baz2

scala&gt; val a = new Baz1
a: Baz1 = Baz1@114a7d4

scala&gt; val b = new Baz2
b: Baz2 = Baz2@47b187

scala&gt; val c: foo = a
c: foo = Baz1@114a7d4

scala&gt; b.isInstanceOf[foo]
res0: Boolean = false

scala&gt; val d: foo = b.asInstanceOf[foo]
java.lang.ClassCastException: Baz2 cannot be cast to foo
  ... 32 elided
</pre>
<p> トレイト foo を定義します。クラス Baz1 は foo を継承し、メソッド bar を定義します。クラス Baz2 は foo を継承せず、メソッド bar も定義していません。次に、Baz1 と Baz2 のインスタンスを生成します。Baz1 は foo を継承しているので、キャストしなくても foo に型変換することができます。Baz2 は foo を継承していないので、b.isInstanceOf[foo] の返り値は false になり、b.asInstanceOf[foo] でキャストしても失敗します。
</p>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala08.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala10.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>