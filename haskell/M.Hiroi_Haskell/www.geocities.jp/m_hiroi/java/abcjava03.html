<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881775</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Java プログラミング入門</h1>
<h2>第 3 回 メソッドの関数的な使い方</h2>
<div class="small">
[ <a href="abcjava02.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 前回と前々回で Java の基本的なデータ型と制御構造について一通り説明しました。今回はメソッドについて取り上げます。Java はオブジェクト指向プログラミング言語なので、クラスを定義しないとプログラムを作ることができません。このクラスの中で定義された関数がメソッドになります。とりあえずオブジェクト指向のことはおいといて、メソッドの関数的な使い方について説明します。
</p>

<h4>●関数の基礎知識</h4>
<p> プログラミングは模型を組み立てる作業と似ています。簡単な処理は Java の機能やライブラリを使って実現することができます。ところが、模型が大きくなると、一度に全体を組み立てるのは難しくなります。このような場合、全体をいくつかに分割して、まずその部分ごとに作ります。最後に、それを結合して全体を完成させます。
</p>

<p> これはプログラミングにも当てはまります。実現しようとする処理が複雑になると、一度に全部作ることは難しくなります。そこで、全体を小さな処理に分割して、一つ一つの処理を作成し、それらを組み合わせて全体のプログラムを完成させます <sup><a href="abcjava03.html#note1">[*1]</a></sup>。
</p>

<p> 分割した処理を作成する場合、それを一つの部品として扱えると便利です。つまり、小さな部品を作り、それを使って大きな部品を作り、最後にそれを組み合わせて全体を完成させます。このとき、もっとも基本となる部品が関数です。Java はオブジェクト指向プログラミング言語なので、厳密な意味での関数はありませんが、メソッドを関数のように使うことは簡単にできます。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> このような方法を分割統治法といいます。
</div>

<h4>●関数の定義方法</h4>
<p> Java の関数 (メソッド) 定義はとても簡単です。本ドキュメントでは、関数的な使い方をするメソッドのことを関数と呼ぶことにします。例題として、数を 2 乗する関数を作ってみましょう。リスト 1 を見てください。
</p>

<pre class="list">
リスト 1 : 数を 2 乗する関数

public class sample30 {
  static int square(int x) {
    return x * x;
  }

  public static void main(String[] args) {
    System.out.println(square(10));
  }
}
</pre>

<p> 関数定義の構文を図 1 に示します。
</p>

<pre class="fig">
static データ型 名前(仮引数名, ...){
  処理A;
  処理B;
  ...
}

図 1 : Java の関数定義
</pre>
<p> 関数の定義は図 2 のように数式と比較するとわかりやすいでしょう。
</p>
<pre class="fig">
      ｆ   （ｘ） ＝  ｘ * ｘ

型   名前   引数      処理内容

int  square  (x)     { return x * x; }

    図 2 : 関数定義と数式の比較
</pre>
<p> square が関数名、( ) の中の x が入力データを受け取る引数、ブロック { } の中の return x * x が実行される処理です。関数定義で使用する引数のことを「仮引数」、実際に与えられる引数を「実引数」といいます。square の定義で使用した x が仮引数で、square(10) の 10 が実引数になります。
</p>
<p> そして、関数が出力する値を「返り値」といいます。返り値のデータ型は関数名の前で指定します。Java の場合、関数の値は return 文を使って返します。return x * x; とすることで、x * x の計算結果を返します。Java の場合、メソッドはクラスメソッドとインスタンスメソッドの 2 種類があり、static を付けるとクラスメソッドになります。とりあえず、関数的な使い方をする場合は static を付けると覚えておいてください。
</p>
<p> それでは実際に実行してみましょう。
</p>
<pre>
C&gt;java sample30
100
</pre>
<p> なお、値を返さない関数も定義することができます。この場合、返り値の型には void を指定してください。
</p>
<h4>●局所変数と大域変数</h4>
<p> それでは、ここで変数 x に値が代入されている場合を考えてみましょう。次の例を見てください。
</p>

<pre class="list">
リスト 2 : 局所変数と大域変数

public class sample31 {
  static int x = 10;
  
  static int square(int x) {
    return x * x;
  }

  public static void main(String[] args) {
    System.out.println(x);
    System.out.println(square(5));
    System.out.println(x);
  }
}
</pre>
<pre>
C&gt;java sample31
10
25
10
</pre>
<p> クラスの先頭で変数 x を定義しています。Java の場合、クラスで定義された変数を「フィールド変数」といいます。通常、フィールド変数はインスタンスを生成するときインスタンスの中に割り当てられます。他のオブジェクト指向言語では「インスタンス変数」と呼びます。
</p>

<p> ところが、フィールド変数に static を付けると、インスタンスではなくクラスに割り当てられます。これを「クラス変数」と呼びます。インスタンス変数はインスタンスを生成しないとアクセスすることはできませんが、クラス変数はインスタンスを生成しなくても、同じクラスのメソッドからアクセスすることができます。
</p>

<p> 最初の println() ではクラス変数の x を参照するので 10 が表示されます。それでは、square(5) の実行結果はどうなると思いますか。x には 10 がセットされているので 10 の 2 乗を計算して返り値は 100 になるのでしょうか。これは 5 の 2 乗を計算して結果は 25 になります。そして、square() を実行したあとでもクラス変数 x の値は変わりません。
</p>

<p> square() の仮引数 x は、その関数が実行されている間だけ有効です。このような変数を「ローカル変数 (local variable)」もしくは「局所変数」といいます。これに対し、プログラムのどこからでもアクセスできる変数を「グローバル変数 (golbal variable)」もしくは「大域変数」といいます。
</p>

<p> Java は変数の値を求めるとき、それが局所変数であればその値を参照します。局所変数でなければ、フィールド変数の値を参照します。Java には厳密な意味での大域変数は存在しませんが、フィールド変数のアクセス権を設定することで、クラス変数を大域変数のように使用することは可能です。ただし、この方法はお勧めしません。
</p>

<p> プログラムを作る場合、関数を部品のように使います。ある関数を呼び出す場合、いままで使っていた変数の値が勝手に書き換えられると、呼び出す方が困ってしまいます。部品であるならば、ほかの処理に影響を及ぼさないように、自分自身の中で処理を完結させることが望ましいのです。これを実現するための必須機能が局所変数なのです。
</p>

<h4>●局所変数の定義と有効範囲</h4>
<p> Java の場合、関数の仮引数は局所変数になりますが、それ以外にも関数の中で局所変数が必要になる場合があります。Java は関数内で宣言された変数を局所変数として扱います。今まで main() の中で変数を宣言しましたが、これらの変数はすべて局所変数になります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト 3 : 局所変数の有効範囲

public class sample32 {
  public static void main(String[] args) {
    int x = 1;
    {
      int y = 2;
      {
        int z = 3;
        System.out.println(x);
        System.out.println(y);
        System.out.println(z);
      }
      System.out.println(x);
      System.out.println(y);
      // System.out.println(z);  z は範囲外 (コンパイルエラー)
    }
    System.out.println(x);
    // System.out.println(y);    y は範囲外 (コンパイルエラー)
    // System.out.println(z);    z は範囲外 (コンパイルエラー)
  }
}
</pre>
<pre>
C&gt;java sample32
1
2
3
1
2
1
</pre>
<p> 局所変数が値を保持する期間のことを、変数の「有効範囲 (scope : スコープ) 」といいます。局所変数の有効範囲は変数が定義されているブロックの中だけです。for 文の場合も同じで、初期化処理で宣言された局所変数は、そのあとのブロックが有効範囲になります。
</p>

<p> リスト 3 の変数 x は main() の一番外側のブロックで定義されているので、main() の処理が終了するまで有効です。変数 y は 2 番目のブロックで、変数 z は 3 番目のブロックで定義されているので、各々のブロックの終わりまでが変数の有効範囲になります。ブロックの実行が終了すると、そのブロックで定義された局所変数は廃棄されます。
</p>

<p> したがって、3 番目のブロックの中では変数 x, y, z が有効です。ブロックの処理が終了すると変数 z が廃棄されるので、2 番目のブロックの中では変数 x, y が有効です。そして、そのブロックの処理が終了すると、変数 y が廃棄されるので有効な変数は x と引数の args だけになります。
</p>

<p> もう一つ簡単な例を示しましょう。
</p>

<pre class="list">
リスト 4 : 要素の合計値を求める

public class sample33 {
  // 配列の要素の合計値を求める
  static int sum(int[] ary) {
    int total = 0;
    for (int n: ary) total += n;
    return total;
  }

  public static void main(String[] args){
    int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    System.out.println(sum(a));
  }
}
</pre>

<p> 関数 sum() の引数 ary には要素が int の配列を渡します。変数 total は関数内で宣言しているので、局所変数として使用することができます。また、for 文で使う変数 n も局所変数になります。この場合、変数 n の有効範囲は for 文の中だけです。for 文による繰り返しが終了すると、変数 n は廃棄されることに注意してください。
</p>

<p> sum() の処理内容は簡単です。最初に変数 total を 0 に初期化します。次に for 文で配列の要素を順番に取り出して変数 n に代入し、n の値を total に加算していきます。最後に total の値を返します。実際に実行すると次のようになります。
</p>
<pre>
C&gt;java sample33
55
</pre>
<h4>●可変長引数</h4>
<p> 仮引数の個数よりも多くの値を受け取りたい場合は、データ型の後ろに ... を付けた仮引数を用意します。これを「可変長引数」といい、JDK 5 から導入された機能です。仮引数に入りきらない値は、配列に格納されて可変長引数に渡されます。これで可変個の引数を受け取る関数を定義することができます。簡単な例を示しましょう。
</p>

<pre class="list">
リスト 5 : 可変長引数

public class sample34 {
  static void foo(int a, int... args) {
    System.out.print(a + ",[");
    for (int n: args) {
      System.out.print(n + ",");
    }
    System.out.println("]");
  }

  static void foo0(int... args) {
    System.out.print("[");
    for (int n: args) {
      System.out.print(n + ",");
    }
    System.out.println("]");
  }

  public static void main(String[] args){
    foo(1);
    foo(1, 2);
    foo(1, 2, 3);
    foo(1, 2, 3, 4);
    foo0();
    foo0(1);
    foo0(1, 2);
    foo0(1, 2, 3);
  }
} 
</pre>
<pre>
C&gt;java sample34
1,[]
1,[2,]
1,[2,3,]
1,[2,3,4,]
[]
[1,]
[1,2,]
[1,2,3,]
</pre>

<p> 可変長引数は通常の仮引数よりも後ろに定義します。関数 foo() は通常の引数が一つしかありません。foo(1) と呼び出すと、引数 a に 1 がセットされます。実引数はもうないので、仮引数 args には空の配列が渡されます。次に foo(1, 2) と呼び出すと、実引数 2 が配列に格納されて仮引数 args に渡されます。同様に、foo(1, 2, 3) は 2 と 3 が配列に格納されて仮引数 args に渡されます。
</p>

<p> 関数 foo0() は、0 個以上の引数を受け取る関数、つまり、引数があってもなくてもどちらでも動作します。この場合、仮引数は args だけになります。実引数がない場合、引数 args には空の配列 [ ] が渡されます。もし、複数の引数があれば、それらを配列にまとめて仮引数 args に渡します。
</p>

<h4>●関数の多重定義</h4>
<p> Java は同じクラス内で同名の関数 (メソッド) を複数定義することができます。これを「多重定義 (overload)」といいます。ただし、引数のデータ型、個数、並び方などが異なる必要があります。これらがまったく同じメソッドを多重定義することはできません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト 6 : 多重定義

public class sample35 {
  static int max(int a, int b) {
    return a &lt; b ? b : a;
  }
  
  static double max(double a, double b) {
    return a &lt; b ? b : a;
  }

  public static void main(String[] args) {
    System.out.println(max(1, 2));
    System.out.println(max(1.1, 2.2));
  }
}
</pre>
<pre>
C&gt;java sample35
2
2.2
</pre>
<p> 関数 max は引数 a と b で大きいほうを返します。同じ名前の関数が 2 つ定義されていますが、仮引数のデータ型が異なっています。実引数に int を渡すと int max(int a, int b) が呼び出されます。double を渡すと double max(double a, double b) が呼び出されます。このように、同じ名前の関数を定義することができます。
</p>
<p> ところで、メソッド print() と println() は整数、浮動小数点数、文字列などいろいろなデータを出力できますが、これは多重定義されているからできることなのです。なお、max() は Java の Math クラスで多重定義されていて、Math.max() で呼び出すことができます。
</p>
<h4>●データの探索</h4>
<p> それでは簡単な例題として、データの探索処理を作ってみましょう。データの探索とは、データの集まりの中から特定のデータを見つける処理のことです。データの探索はプログラムの中で最も基本的な操作の一つです。たとえば配列からデータを探す場合、いちばん簡単な方法は先頭から順番にデータを比較していくことです。これを「線形探索 (linear searching)」といます。リスト 7 を見てください。
</p>

<pre class="list">
リスト 7 : データの探索

public class sample36 {
  // n があるか
  static boolean find(int n, int[] ary) {
    for (int x: ary) {
      if (x == n) return true;
    }
    return false;
  }

  // n の位置を求める
  static int position(int n, int[] ary) {
    for (int i = 0; i &lt; ary.length; i++) {
      if (ary[i] == n) return i;
    }
    return -1;
  }

  // n の個数を求める
  static int count(int n, int[] ary){
    int c = 0;
    for (int x: ary) {
      if (x == n) c++;
    }
    return c;
  }

  public static void main(String[] args) {
    int[] a = {1, 2, 3, 1, 2, 3, 4, 5};
    System.out.println(find(4, a));
    System.out.println(find(6, a));
    System.out.println(position(5, a));
    System.out.println(position(7, a));
    System.out.println(count(3, a));
    System.out.println(count(8, a));
  }
}
</pre>

<pre>
C&gt;java sample36
true
false
7
-1
2
0
</pre>
<p> 関数 find() は配列 ary の中から引数 n と等しいデータを探します。for 文で配列の要素を一つずつ順番に取り出して n と比較します。等しい場合は true を返します。for ループが終了する場合は n と等しい要素が見つからなかったので false を返します。関数 position() は、データを見つけた場合はその位置 i を返し、見つからない場合は -1 を返します。
</p>

<p> find() と position() は最初に見つけた要素とその位置を返しますが、同じ要素が配列に複数あるかもしれません。関数 count() は等しい要素の個数を数えて返します。局所変数 c を 0 に初期化し、n と等しい要素 x を見つけたら c の値を +1 します。最後に c の値を返します。
</p>

<p> このように、線形探索は簡単にプログラムできますが、大きな欠点があります。データ数が多くなると処理に時間がかかるのです。近年、パソコンの性能は著しく向上しているので、線形探索でどうにかなる場合もありますが、データ数が多くて時間かかかるのであれば、次の例題で取り上げる「二分探索」や他の高速な探索アルゴリズム <sup><a href="abcjava03.html#note2">[*2]</a></sup> を使ってみるとよいでしょう。
</p>

<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> 基本的なところでは「ハッシュ法」や「二分探索木」などがあります。
</div>

<h4>●二分探索</h4>
<p> 次は「二分探索 (バイナリサーチ：binary searching)」を例題として取り上げます。線形探索の実行時間は要素数 N に比例するので、N が大きくなると時間がかかるようになります。これに対し、二分探索は log<sub>2</sub> N に比例する時間でデータを探すことができます。
</p>

<p> ただし、探索するデータはあらかじめ昇順に並べておく必要があります。この操作を「ソート (sort)」といいます。二分探索は最初にデータをソートしておかないといけないので、線形探索に比べて準備に時間がかかります。
</p>

<p> 二分探索の動作を図 3 に示します。
</p>

<pre class="fig">
[11 22 33 44 55 66 77 88 99]        key は 66
             ↑                     66 &gt; 55 後半を探す

11 22 33 44 55 [66 77 88 99]        88 &gt; 66 前半を探す
                      ↑

11 22 33 44 55 [66 77] 88 99        77 &gt; 66 前半を探す
                   ↑

11 22 33 44 55 [66] 77 88 99        66 = 66 発見
                ↑

            図 3 : 二分探索
</pre>

<p> 二分探索は探索する区間を半分に分割しながら調べていきます。キーが 66 の場合を考えてみましょう。まず区間の中央値 55 とキーを比較します。データが昇順にソートされている場合、66 は中央値 55 より大きいので区間の前半を調べる必要はありません。したがって、後半部分だけを探索すればいいのです。
</p>

<p> あとは、これと同じことを後半部分に対して行います。最後には区間の要素が一つしかなくなり、それとキーが一致すれば探索は成功、そうでなければ探索は失敗です。ようするに、探索するデータ数が 1 / 2 ずつ減少していくわけです。図 3 の場合、線形探索ではデータの比較が 6 回必要になりますが、二分探索であれば 4 回で済みます。また、データ数が 1,000,000 個になったとしても、二分探索を使えば高々 20 回程度の比較で探索を完了することができます。
</p>

<p> それでは、配列からデータを二分探索するプログラムを作ってみましょう。Java にはクラス Arrays に二分探索を行うメソッド binarySearch() とソートを行うメソッド sort() が用意されていますが、私達でも繰り返しを使って簡単にプログラムすることができます。リスト 8 を見てください。
</p>

<pre class="list">
リスト 8 : 二分探索

public class sample37 {
  static boolean binarySearch(int n, int[] ary){
    int low = 0;
    int high = ary.length - 1;
    while (low &lt;= high) {
      int mid = (low + high) / 2;
      if (n == ary[mid])
        return true;
      else if (n &gt; ary[mid])
        low = mid + 1;
      else
        high = mid - 1;
    }
    return false;
  }

  public static void main(String[] args) {
    int[] a = {10, 20, 30, 40, 50, 60, 70, 80};
    System.out.println(binarySearch(20, a));
    System.out.println(binarySearch(60, a));
    System.out.println(binarySearch(45, a));
  }
}
</pre>
<pre>
C&gt;java sample37
true
true
false
</pre>
<p> 最初に、探索する区間を示す変数 low と high を初期化します。配列の長さは ary.length で取得し、最後の要素の位置を high にセットします。次の while ループで、探索区間を半分ずつに狭めていきます。まず、区間の中央値を求めて変数 mid にセットします。if 文で mid の位置にある要素と n を比較し、等しい場合は探索成功です。return で true を返します。
</p>

<p> n が大きい場合は区間の後半を調べます。変数 low に mid + 1 をセットします。逆に、n が小さい場合は前半を調べるため、変数 high に mid - 1 をセットします。これを区間が二分割できるあいだ繰り返します。low が high より大きくなったら分割できないので繰り返しを終了し false を返します。
</p>

<p> 二分探索はデータを高速に探索することができますが、あらかじめデータをソートしておく必要があります。このため、途中でデータを追加するには、データを挿入する位置を求め、それ以降のデータを後ろへ移動する処理が必要になります。つまり、データの登録には時間がかかるのです。
</p>

<p> したがって、二分探索はプログラムの実行中にデータを登録し、同時に探索も行うという使い方には向いていません。途中でデータを追加して探索も行う場合は、他の高速な探索アルゴリズムを検討してみてください。
</p>

<h4>●素数を求める (2)</h4>
<p> それでは関数を使って、前回作成した素数を求めるプログラムを書き直して見ましょう。リスト 9 を見てください。
</p>

<pre class="list">
リスト 9 : 素数を求める

public class Prime1 {
  // 素数のチェック
  static boolean isPrime(int n, int primeSize, int[] primeTable) {
    for(int i = 1; i &lt; primeSize; i++){
      int p = primeTable[i];
      if (p * p &gt; n) break;
      if (n % p == 0) return false;
    }
    return true;
  }
  
  public static void main(String[] args) {
    int primeTable[] = new int [100];
    int primeSize = 1;
    primeTable[0] = 2;
    for (int n = 3; n &lt; primeTable.length; n += 2) {
      if (isPrime(n, primeSize, primeTable)) {
        primeTable[primeSize++] = n;
      }
    }
    for (int i = 0; i &lt; primeSize; i++) {
      System.out.print(primeTable[i] + " ");
    }
  }
}
</pre>
<pre>
C&gt;java Prime1
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</pre>
<p> 数値 n が素数か判定する処理を関数 isPrime() で行うように変更します。isPrime() は数値 n と素数の個数 primeSize と配列 primeTable を受け取り、n が素数で割り切れれば false を返し、そうでなければ true を返します。
</p>

<p> Lisp / Scheme などの関数型言語の世界では、真偽値を返す関数を「述語 (predicate)」といいます。Java の場合、真偽値を返す関数は名前の先頭 (接頭辞) に is, has, can などを付けて表すことが多いようです。
</p>

<p> isPrime() を使うと、素数を求める処理は簡単にプログラムすることができます。isPrime() が true を返したら n を配列 primeTable に追加するだけです。素数の判定処理を関数 isPrime() で行うことにより、関数 main() はとてもわかりやすいプログラムになりました。
</p>

<h4>●値呼びと参照呼び</h4>
<p> 一般に、関数呼び出しには二つの方法があります。一つが「値呼び (call by value)」、もう一つが「参照呼び (call by reference)」です。近代的なプログラミング言語では「値呼び」が主流です。
</p>

<p> 値呼びの概念はとても簡単です。
</p>
<ol>
  <li>受け取るデータを格納する変数 (仮引数) を用意する。
  <li>データを引数に代入する。
  <li>関数の実行終了後、引数を廃棄する。
</ol>
<p> 値呼びのポイントは 2. です。データを引数に代入するとき、データのコピーが行われるのです。たとえば、変数 a の値が 10 の場合、関数 foo(a) を呼び出すと、実引数 a の値 10 が foo の仮引数にコピーされます。変数に格納されている値そのものを関数に渡すので、「値渡し」とか「値呼び」と呼ばれます。また、値呼びは任意の式の値を実引数として渡すことができます。たとえば foo(a + b) の場合、引数に渡された式 a + b を計算し、その結果が foo の仮引数に渡されます。
</p>

<p> 値呼びは単純でわかりやすいのですが、呼び出し先 (caller) から呼び出し元 (callee) の局所変数にアクセスできると便利な場合もあります。仮引数に対する更新が直ちに実引数にも及ぶような呼び出し方が「参照呼び」です。
</p>

<p> Java は「値呼び」です。文字型を含む数や boolean などの「基本データ型」は、仮引数にデータをセットするときデータのコピーが行われます。ただし、配列や文字列などのオブジェクトは「参照データ型」といって、仮引数にデータをセットするとき、オブジェクトのコピーは行われません。Java の変数 (引数) は参照データ型を格納しているのではなく、そのオブジェクトへの参照を格納しているのです。参照はＣ言語のポインタや Perl のリファレンスのことで、実態はオブジェクトに割り当てられたメモリのアドレスです。図 4 を見てください。
</p>
<pre class="fig">
         ┌─┐      ┌──┐
  変数 a │・┼──→│"ab"│ データ (object)
         └─┘      └──┘

  (1) a = "ab" の場合

         ┌─┐      ┌──┐
  変数 a │・┼──→│"ab"│ データ (object)
         └─┘      └──┘
                       ↑
         ┌─┐        │
  変数 b │・┼────┘
         └─┘

  (2) b = a の場合

  図 4 : 参照データ型の代入操作
</pre>

<p> 変数 a に文字列 "ab" を代入する場合、Java は "ab" を a に書き込むのではありません。文字列 (オブジェクト) "ab" を生成して、図 4 (1) のようにオブジェクトへの参照を a に書き込みます。a の値を変数 b に代入する場合も、図 4 (2) のように a に格納されているオブジェクトへの参照を b に書き込むだけで、文字列はコピーされません。
</p>

<p> したがって、参照データ型の場合、代入はデータに名札を付ける操作と考えることができます。図 4 (2) のように、一つのデータに複数の名札を付けることもできるわけです。これは引数の場合も同じです。参照データ型の場合、実引数に格納されている値はオブジェクトへの参照であり、それが仮引数にコピーされます。つまり、アドレスを値渡ししているわけです。
</p>

<p> オブジェクトの同一性は演算子 == で調べることができます。次の例を見てください。
</p>

<pre class="list">
リスト 10 : オブジェクトの同一性

public class sample38 {
  public static void main(String[] args) {
    String a = new String("ab");
    String b = a;
    String c = new String("ab");
    System.out.println(a == b);
    System.out.println(a == c);
    System.out.println(a.equals(c));
  }
}
</pre>
<pre>
C&gt;java sample38
true
false
true
</pre>
<p> new String("ab") は String 型のインスタンスを生成します。インスタンスはオブジェクトのことです。オブジェクト指向についていはあとで詳しく説明します。
</p>
<p> 変数 a と c には String のオブジェクトを代入し、変数 b に a の値を代入します。変数 a と b は同じオブジェクトを参照しているので、a == b は true になります。a と c は異なるオブジェクトなので、値が同じ文字列 "ab" でも a == c は false になります。値を比較したい場合はメソッド equals() を使います。インスタンスメソッドは次の形式で呼び出します。
</p>
<pre class="item">
object.method(args, ...)
</pre>
<p> インスタンス object の後ろにドット ( . ) を付けて、その後ろに呼び出すメソッドを指定します。a.equals(c) は a と c の値を比較するので true になります。文字列が等しいか調べる場合は演算子 == ではなくメソッド equals() を使ってください。
</p>

<p> ただし、配列のような更新可能なオブジェクトの場合、関数の引数に配列を渡してそれを破壊的に修正すると、呼び出し元の変数の値も書き換えられたかのようにみえます。次の例を見てください。
</p>

<pre class="list">
リスト 11 : 渡された配列を破壊的に修正

public class sample39 {
  static void foo(int[] ary) {
    ary[0] *= 10;
  }

  static void printArray(int[] ary) {
    for (int n: ary) {
      System.out.print(n + " ");
    }
    System.out.println();
  }
  
  public static void main(String[] args) {
    int[] a = {1, 2, 3, 4};
    printArray(a);
    foo(a);
    printArray(a);
  }
}
</pre>
<pre>
C&gt;java sample39
1 2 3 4
10 2 3 4
</pre>
<p> 変数 a に配列 {1, 2, 3, 4} をセットします。関数 printArray() は配列 ary の内容を表示します。関数 foo() は配列 ary の先頭要素を 10 倍します。このとき、配列 ary の内容を破壊的に修正していることに注意してください。foo(a) を呼び出したあと printArray(a) を実行すると、先頭要素が 10 に書き換えられていることがわかります。
</p>

<p> この場合、変数 a の値が書き換えられたのではなく、a が参照しているオブジェクトの内容を直接書き換えているだけなのです。元の値をそのままにしておきたい場合は、元の配列をコピーして新しい配列を生成してください。
</p>
</section>
<div align="right">
初版 2009 年 4 月 11 日<br>
改訂 2016 年 11 月 12 日
</div>
<hr>
<div class="ce">
<b>Copyright (C) 2009-2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava02.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava04.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>