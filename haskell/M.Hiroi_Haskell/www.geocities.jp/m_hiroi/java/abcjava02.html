<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881775</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>お気楽 Java プログラミング入門</h1>
<h2>第 2 回 Java の基礎知識 (2)</h2>
<div class="small">
[ <a href="abcjava01.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> 前回は Java の基本として、数と文字列、if 文と while 文について説明しました。今回は配列と for 文、switch 文について説明します。
</p>
<h4>●配列</h4>
<p> Java の配列 (array) はデータを一列に並べたもので、Ｃ/Ｃ++の 1 次元配列と同等のデータ構造です。配列に格納されたデータを要素といいます。配列はホテルやマンションの部屋にたとえるとわかりやすいと思います。ホテル全体を配列とすると、各部屋がデータを格納する変数と考えることができます。ホテルでは、ルームナンバーによって部屋を指定しますね。配列の場合も、整数値によってデータを格納する変数を指定することができます。この整数値を「添字 (subscripts)」といいます。
</p>

<pre class="fig">
添字    ０  １  ２  ３  ４  ５  ６  ７  ８  ９
      ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
配列  │  │  │  │  │  │  │  │  │  │  │
      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

                図 1 : 配列の構造
</pre>

<p> たとえば、10 個のデータを格納する配列を考えてみます。これは、平屋建てのホテルで、部屋が 10 室あると考えてください。この場合は上図に示すように、データを格納する変数が並んでいて、それぞれ 0 から 9 までの添字で指定することができます。Java の場合、Ｃ/Ｃ++と同じく、添字は 0 から順番に数えます。
</p>

<p> Java の場合、配列は次のように宣言します。
</p>
<pre class="item">
データ型[] 変数名 = new データ型 [大きさ];
データ型 変数名 [] = new データ型 [大きさ];
データ型[] 変数名 = {値1, ..., 値N};
データ型 変数名 [] = {値1, ..., 値N};
</pre>
<p> データ型は配列に格納する要素のデータ型を指定します。その後ろの [ ] は配列の宣言であることを表します。それから変数名を指定します。変数名の後ろに [ ] を付けてもかまいません。配列の実体は new データ型 [大きさ] で指定します。
</p>

<p> 一般に、スクリプト言語の多くは配列の大きさを自由に変えることができる「可変長配列」をサポートしています。ところが、Java の配列はＣ/Ｃ++と同様にあとから大きさを変更することはできません。そのかわり、Java には可変長配列を実装したクラス ArrayList がパッケージ java.util に用意されています。
</p>

<p> 要素の初期値はデータ型によって決まります。数値の場合は 0 に、boolean の場合は false に初期化されます。初期値を設定したい場合は {値1, ..., 値N} で要素の値を設定します。この場合、{ } の中の要素数が配列の大きさになります。このとき、データ型と値のデータ型が一致しないとコンパイルエラーになります。
</p>

<p> 簡単な例を示しましょう。
</p>

<pre class="list">
リスト 1 : 配列の使用例

public class sample20 {
  public static void main(String[] args) {
    int[] a = new int [4];
    int[] b = {1, 2, 3, 4, 5, 6, 7, 8};
    System.out.println(a.length);
    System.out.println(b.length);
    System.out.println(a[0]);
    System.out.println(b[0]);
    a[0] = 10;
    b[0] = 20;
    System.out.println(a[0]);
    System.out.println(b[0]);
  }
}
</pre>
<pre>
C&gt;java sample20
4
8
0
1
10
20
</pre>

<p> 配列の要素は角カッコ [ ] を使ってアクセスします。これはＣ/Ｃ++と同じです。配列の要素を取り出して変数に代入することも、配列の要素を書き換えることもできます。配列は自分自身の大きさを知っていて、変数名 + ドット ( . ) + length で値を取り出すことができます。
</p>

<p> 配列は入れ子にすることができます。つまり、配列の要素に配列を入れてもかまいません。これで多次元配列を表すことができます。簡単な例を示しましょう。
</p>

<pre class="list">
リスト 2 : 2 次元配列

public class sample21 {
  public static void main(String[] args) {
    int[][] a = new int [3][3];
    int[][] b = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
    };
    System.out.println(a.length);
    System.out.println(b.length);
    System.out.println(a[0][0]);
    System.out.println(b[2][2]);
    a[0][0] = 10;
    b[2][2] = 20;
    System.out.println(a[0][0]);
    System.out.println(b[2][2]);
  }
}
</pre>
<pre>
C&gt;java sample21
3
3
0
9
10
20
</pre>

<p> 多次元配列は [ ] を複数つけることで宣言します。2 次元配列の場合、int a[ ][ ] のように [ ] を 2 つ付けて、大きさを new int [3][3] のように指定します。これで配列 a の大きさは 3 で、その要素は大きさ 3 の配列になります。また、初期値を指定する場合は、{ } の中で {1, 2, 3} のように初期値付きで要素を指定します。これで 2 次元配列を初期化することができます。
</p>
<p> 要素のアクセスは簡単で、最初の [ ] で配列に格納されている配列を取り出し、次の [ ] で取り出した配列の要素を指定します。たとえば、b[2][2] は b[2] に格納されている配列 {7, 8, 9} を取り出し、次の [2] でその配列の 2 番目の要素を指定します。したがって、b[2][2] の値は 9 になります。b[2][2] = 20; とすると 9 が書き換えられて 20 になります。
</p>

<h4>●for 文による繰り返し</h4>
<p> 配列を操作するときに、とても役に立つ繰り返し文を紹介しましょう。まず、Ｃ/Ｃ++でもお馴染みの for 文です。Java の for 文はＣ/Ｃ++とほぼ同じです。
</p>
<pre class="item">
for (初期化; 条件部; 更新処理) { 処理A; ...; 処理Z; }
</pre>
<pre class="fig">
                ↓
          ┌─────┐
          │  初期化  │
          └─────┘
                ├←─────┐
    false ┌─────┐      │
  ┌───│  条件部  │      │
  │      └─────┘      │
  │            ↓true        │
  │      ┌─────┐      │
  │      │  処理Ａ  │      │
  │      └─────┘      │
  │            ・            │
  │            ・            │
  │      ┌─────┐      │
  │      │  処理Ｚ  │      │
  │      └─────┘      │
  │            ↓            │
  │      ┌─────┐      │
  │      │ 更新処理 │      │
  │      └─────┘      │
  │            └──────┘
  └──────┐
                ↓

        図 2 : for 文の処理
</pre>

<p> for 文の特徴は、いちばん最初に行われる初期化と、繰り返すたびに行われる更新処理があることです。上図を見ればおわかりのように、初期化はただ一度しか行われず、更新処理はブロックの処理を実行してから行われます。なお、繰り返す処理が一つしかない場合は { } を省略することができます。
</p>
<p> 簡単な使用例を示しましょう。
</p>

<pre class="list">
リスト 3 : for 文の使用例

public class sample22 {
  public static void main(String[] args) {
    for (int i = 0; i &lt; 10; i++) {
      System.out.println("Hello, World!");
    }
  }
}
</pre>
<pre>
C&gt;java sample22
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
</pre>
<p> まず、int i = 0; で変数 i を 0 に初期化します。この処理は for 文が始まるときに一度だけ実行されます。次に条件部 i &lt; 10 がチェックされます。i は 0 ですから条件を満たしますね。そこで、ブロックの処理が行われ、println() により Hello, World! が表示されます。
</p>
<p> 次に、更新処理 i++ が行われます。変数 i の値を +1 したら、条件部のチェックを行います。あとは、while と同様に条件部が成立しているあいだは、ブロックの処理と更新処理を繰り返します。結局、i の値は 10 になるので、条件部が不成立となり繰り返しを終了します。したがって、このプログラムを実行すると Hello, World! が 10 回表示されます。
</p>

<h4>●拡張 for 文</h4>
<p> Java は JDK 5 から拡張 for 文を使用することができます。拡張 for 文は配列から順番に要素を取り出して変数に代入し、ブロックに書かれている処理を繰り返し実行します。拡張 for 文は Perl の foreach や Python, Ruby の for 文と同じです。拡張 for 文の構文と動作を下図に示します。
</p>
<pre class="item">
for (データ型 変数名: コレクション) { 処理A; ...; 処理Z; }
</pre>
<pre class="fig">
                ↓
                ├←────┐
       No ┌─────┐    │
  ┌───│要素がある│    │
  │      └─────┘    │
  │            ↓Yes       │
  │    ┌───────┐  │
  │    │変数←次の要素│  │
  │    └───────┘  │
  │            ↓          │
  │      ┌─────┐    │
  │      │   処理   │    │
  │      └─────┘    │
  │            └─────┘
  └──────┐
                ↓

    図 3 : 拡張 for 文の処理
</pre>
<p> 一般に、複数の要素を格納するデータ型を「コレクション (collection) 」とか「コンテナ (container) 」と呼びます。Java のライブラリには ArayList など便利なコレクションが用意されていて、それらにも拡張 for 文を適用することができます。なお、変数のデータ型とコレクションに格納されているデータ型が一致しないとコンパイルでエラーとなります。
</p>

<p> たとえば、拡張 for 文と通常の for 文で、配列の要素の合計を求めると次のようになります。
</p>

<pre class="list">
リスト 4 : 配列の合計値を求める

public class sample23 {
  public static void main(String[] args) {
    int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int sum0 = 0, sum1 = 0;
    // 拡張 for 文
    for (int n: a) sum0 += n;
    System.out.println(sum0);
    // 通常の for 文
    for (int i = 0; i &lt; a.length; i++) sum1 += a[i];
    System.out.println(sum1);
  }
}
</pre>
<pre>
C&gt;java sample23
55
55
</pre>
<p> 拡張 for 文の場合、配列 a の要素を先頭から順番に取り出して変数 n にセットします。通常の for 文の場合は、変数 i を 0 に初期化して、更新処理で i を +1 していくことで、配列の先頭から順番にアクセスします。条件部で i の値が a.length 以上になったならば、配列の範囲を超えるので繰り返しを終了します。このような単純な処理の場合は拡張 for 文の方が簡単ですね。
</p>

<h4>●繰り返しの制御</h4>
<p> while 文や for 文は break 文によって繰り返しを脱出することができます。contiune 文は繰り返しの先頭に戻ります。break 文と continue 文の動作を図 4 に示します。
</p>
<pre class="fig">
//
// break と continue
//
while (testA) {←──────┐
    処理A;                   │
    if (testB) continue; ──┘
    処理B;
    if (testC) break;───┐
    処理C;                 │
}                          │
 ←────────────┘
処理D;

図 4 : break 文と continue 文の動作
</pre>
<p> testB が真で continue 文が実行されると、それ以降の処理を実行せずに条件部のチェックが行われます。つまり、処理 B, testC, 処理 C は実行されません。for 文で continue 文が実行されると、それ以降の処理は実行されずに更新処理が実行されます。拡張 for 文の場合は次の要素を取り出す処理が行われます。
</p>

<p> testC が真で break 文が実行されると、それ以降の処理を実行せずに while 文や for 文の繰り返しを脱出します。図 4 では、break 文で while 文の繰り返しを脱出すると、while 文の次の処理 D が実行されます。
</p>

<p> ここまではＣ/Ｃ++と同じですが、Java の break 文は後ろにラベルを付けることができます。そして、同じラベルの処理へ脱出することができます。これは多重ループから脱出するときに使うと便利です。
</p>

<h4>●コマンドライン引数の取得</h4>
<p> Java の場合、メソッド main で指定した String 型の配列にコマンドラインで与えられた引数が格納されています。次のリストを見てください。
</p>
<pre class="list">
リスト 5 : コマンドライン引数の取得

public class sample24 {
  public static void main(String[] args) {
    for (String a: args) {
      System.out.println(a);
    }
  }
}
</pre>

<p> 変数 args の内容を表示するだけです。3 つの引数を与えて起動すると、次のように表示されます。
</p>
<pre>
C&gt;java sample24 foo bar baz
foo
bar
baz
</pre>

<h4>●素数を求める</h4>
<p> 簡単な例題として、100 以下の素数を求めるプログラムを作ってみましょう。いちばん簡単な方法は、奇数 3, 5, 7, 9, ... をそれまでに見つけた素数で割ってみることです。見つけた素数は配列に格納しておけばいいでしょう。プログラムをリスト 6 に示します。
</p>

<pre class="list">
リスト 6 : 素数を求める

public class Prime {
  public static void main(String[] args) {
    int primeTable[] = new int [100];
    int primeSize = 1;
    primeTable[0] = 2;
    for (int n = 3; n &lt; primeTable.length; n += 2) {
      boolean flag = true;
      for (int i = 1; i &lt; primeSize; i++) {
        int p = primeTable[i];
        if (p * p &gt; n) {
          break;
        } else if (n % p == 0) {
          flag = false;
          break;
        }
      }
      if (flag) primeTable[primeSize++] = n;
    }
    for (int i = 0; i &lt; primeSize; i++) {
      System.out.print(primeTable[i] + " ");
    }
  }
}
</pre>
<pre>
C&gt;java Prime
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</pre>
<p> 変数 primeTable は素数を格納する配列で 0 番目の要素を 2 に初期化します。変数 primeSize は格納されている素数の個数を表します。変数 n を 3 に初期化して、for ループで n の値を 2 ずつ増やしていきます。これで奇数列を生成することができます。
</p>

<p> このプログラムは変数 flag の使い方がポイントです。for ループの先頭で flag を true に初期化します。次の for ループで、primeTable に格納されている素数を取り出して変数 p にセットします。n は奇数なので、2 で割り算する必要はありません。primeTable の 1 番目の要素から順番に primeSize - 1 番目までの要素を調べます。
</p>

<p> n が素数か判別する場合、実際には primeTable の素数をすべて調べる必要はなく、√n より小さい素数を調べるだけで十分です。p &gt; √n のかわりに p * p &gt; n をチェックし、真であれば break で for ループを脱出します。x % y が 0 ならば、flag を false にセットしてから break します。
</p>

<p> そして、for ループが終了した後、flag が true であれば n を primeTtable に追加して、primeSize の値を +1 します。これで、primeTable の先頭から順番に素数を格納していくことができます。最後に for ループで求めた素数を表示します。
</p>

<p> ところで、リスト 6 のプログラムはちょっとわかりにくいのが欠点です。この場合、関数 (メソッド) を使うとわかりやすいプログラムを作ることができます。
</p>

<h4>●エラトステネスの篩</h4>
<p> もう一つ、素数を求める簡単な方法を紹介しましょう。最初に、2 から N までの整数列を生成します。先頭の 2 は素数なので、この整数列から 2 で割り切れる整数を取り除き除きます。2 で割り切れる整数が取り除かれたので、残った要素の先頭が素数になります。先頭要素は 3 になるので、今度は 3 で割り切れる整数を取り除けばいいのです。このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩 (ふるい) 」といいます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト 7 : エラトステネスの篩

public class Sieve {
  public static void main(String[] args) {
    // false は素数, true は素数ではない
    boolean primes[] = new boolean [100];
    for (int n = 2; n &lt; primes.length; n++) {
      if (primes[n]) continue;  // n は素数ではない
      // n の倍数を削除
      for (int m = 2 * n; m &lt; primes.length; m += n) {
        primes[m] = true;
      }
      // 表示
      System.out.print(n + " ");
    }
  }
}
</pre>
<pre>
C&gt;java Sieve
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</pre>
<p> boolean 型の配列 primes で整数列を表します。false で素数を表し、素数でない場合は true をセットします。boolean 型の配列は false で初期化されるので、最初はすべての数が素数ということになります。次に、for ループで primes から素数 n を探します。n = 2 の場合、primes[n] は false なので n は素数になります。primes[n] が true の場合は continue で for ループの更新処理へ移ります。
</p>
<p> n が素数の場合は、次の for ループで primes から n の倍数を取り除きます。変数 m を 2 * n に初期化し、for ループの更新処理で m に n を加算していけば、m の値は n の倍数になります。あとは primes[m] に true をセットして、素数 n を表示するだけです。
</p>
<p> なお、このプログラムは改善の余地があります。奇数だけを調べるように工夫すると、配列の大きさを半分にすることができ、実行時間も速くなるでしょう。興味のある方はプログラムを改造してみてください。
</p>
<h4>●素因数分解</h4>
<p> エラトステネスの篩と同じ考え方で素因数分解を行うことができます。素因数分解とは、素数でない整数 (合成数) を素数の積の形に書き表すことです。たとえば、12 は 2 * 2 * 3 と素因数分解することができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト 8 : 素因数分解

public class Factorization {
  public static void main(String[] args) {
    int m = 1234567890;
    // 2 で割れるだけ割り算する
    while (m % 2 == 0) {
      System.out.print(2);
      System.out.print(" ");
      m /= 2;
    }
    // 奇数で割り算していく
    for (int i = 3; i * i <= m; i += 2) {
      while (m % i == 0) {
        System.out.print(i + " ");
        m /= i;
      }
    }
    if (m &gt; 1) System.out.println(m);
  }
}
</pre>
<p> 最初に 2 で割り算します。それから、奇数で割り算していきます。割り算するときは、その数で割り切れるあいだは割り算を続けることに注意してください。たとえば、27 を素因数分解すると 3 * 3 * 3 になりますが、3 を一回だけしか割り算しないと、結果は 3 * 9 のように素数ではない数が含まれてしまいます。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;java Factorization
2 3 3 5 3607 3803
</pre>
<p> どの数も素数で、2 * 3 * 3 * 5 * 3607 * 3803 を計算すると 1234567890 になります。なお、これはとても単純なアルゴリズムなので、大きな整数の素因数分解には適していません。巨大な合成数の素因数分解はとても難しい問題です。興味のある方は素因数分解について調べてみてください。
</p>
<h4>●switch 文</h4>
<p> ひとつの値を比較して条件分岐を行う場合は if 文よりも switch 文を使ったほうが簡単です。Java の switch 文はＣ/Ｃ++とほぼ同じです。switch 文の構文を示します。
</p>

<pre class="fig">
  switch (式) {
  case A:
    処理A1;
    処理A2;
    処理A3;
    break;
  case B:
    処理B1;
    処理B2;
    処理B3;
    break;
  case C:
    処理C1;
    処理C2;
    処理C3;
    break;
  default:
    処理Z1;
    処理Z2;
    処理Z3;
  }

  図 5 : case の構文
</pre>

<p> switch 文は最初に ( ) の中の式を評価します。式の評価結果は文字型を含む整数値 <sup><a href="abcjava02.html#note1">[*1]</a></sup> でなければいけません。そのあとに複数の case 節が続きます。case の後ろには定数値 (整数値) を指定します。そして、式の評価結果と case で指定した定数を比較します。
</p>

<p> 式の評価結果と等しい値を見つけた場合、その case 節以降の処理を順番に実行して、break 文で実行を中断します。break 文を忘れると、次の case 節の処理も実行してしまいます。ご注意くださいませ。そうでなければ、次の case 節に移ります。たとえば、定数 A と等しくない場合、次の節に移り定数 B をチェックします。
</p>

<p> もしも、等しい定数が見つからない場合は default 節が実行されます。なお、default 節は省略することができます。switch 文の動作を図 6 に示します。
</p>

<pre class="fig">
     評価結果
        ↓
  ┌─────┐Yes ┌────┐          ┌────┐
  │  定数 A  │─→│処理Ａ１│→・・・→│処理Ａ３│─ break →┐
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐Yes ┌────┐          ┌────┐           │
  │  定数 B  │─→│処理Ｂ１│→・・・→│処理Ｂ３│─ break →┤
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐Yes ┌────┐          ┌────┐           │
  │  定数 C  │─→│処理Ｃ１│→・・・→│処理Ｃ３│─ break →┤
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐    ┌────┐          ┌────┐           │
  │ default  │─→│処理Ｚ１│→・・・→│処理Ｚ３│ ────→┤
  └─────┘    └────┘          └────┘           │
                                                                 │
                                                                 ↓

        図 6 : switch 文の流れ図
</pre>
<p> 簡単な例を示します。switch 文を使って FizzBuzz 問題を解いてみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト 9 : FizzBuzz 問題 (2)

public class FizzBuzz1 {
  public static void main(String[] args) {
    for (int i = 1; i &lt;= 100; i++) {
      switch (i % 15) {
      case 0:
        System.out.print("FizzBuzz");
        break;
      case 3: case 6: case 9: case 12:
        System.out.print("Fizz");
        break;
      case 5: case 10:
        System.out.print("Buzz");
        break;
      default:
        System.out.print(i);
      }
      if (i % 20 == 0) {
        System.out.println();
      } else {
        System.out.print(" ");
      }
    }
  }
}
</pre>

<pre>
C&gt;java Fizzbuzz1
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz
Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz
41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz
61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz
Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz
</pre>

<p> switch 文で i % 15 を求めます。0 であれば 15 で割り切れるので、FizzBuzz を表示します。3, 6, 9, 12 であれば、3 の倍数なので Fizz と表示します。リスト 9 のように複数の case を続けて設定してもかまいません。5, 10 であれば 5 の倍数なので Buzz と表示します。それ以外の数値は default で i を表示します。
</p>
<div class="note">
-- Note --------<br>
<a name="note1">[*1] switch 文は JDK 5 から整数値だけではなく enum 型 (列挙型) も指定できるようになりました。
</div>
</section>
<div align="right">
初版 2009 年 4 月 4 日<br>
改訂 2016 年 11 月 12 日
</div>
<hr>
<div class="ce">
<b>Copyright (C) 2009-2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava01.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava03.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>