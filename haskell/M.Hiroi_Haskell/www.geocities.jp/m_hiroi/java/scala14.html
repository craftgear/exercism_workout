<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881778</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala13.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala15.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>多相クラス (2)</h3>
<p> 多相クラスの続きです。前回はクラスに型パラメータを指定することで「多相クラス」を実現しました。今回は「抽象型」を使って多相的なクラスを作る方法を紹介します。それから、型境界と変位という型パラメータを制限する方法について説明します。
</p>

<h4>●抽象型とは？</h4>
<p> Scala の抽象クラスやトレイトでは、抽象メソッドや抽象フィールド変数を宣言することができますが、同じように「型」も type 文で抽象的に宣言することができます。
</p>
<ol>
  <li>type 名前 = 型
  <li>type 名前
</ol>
<p> type は型に別名を付ける働きをします。1 の方法は既存の型に新しい名前を付けます。2 のように = 以降を省略すると、その名前は抽象型になります。抽象クラスやトレイトでは、type で抽象型を宣言し、その型を使ってフィールド変数やメソッドを定義します。そして、抽象型を宣言しているクラスやトレイトを継承 (または Mix-in) して具象クラスを作るとき、そのクラスで type で宣言した型名に具体的な型を指定します。
</p>

<h4>●スタックの仕様</h4>
<p> 簡単な例題として、抽象型を使ってリストと配列でスタックを作ってみましょう。最初に、スタックの仕様を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト ; スタックの仕様

trait Stack {
  type Item
  def push(x: Item): Unit
  def pop(): Item
  def isEmpty(): Boolean
  def isFull(): Boolean
  def length(): Int
}
</pre>
<p> Stack はトレイトで定義しましたが、抽象クラスで定義してもかまいません。要素の型を type で Item と定義します。メソッド push は Item 型のデータ x を受け取って、それをスタックに格納します。pop はスタックから Item 型の要素を取り出します。あとのメソッドも簡単ですね。
</p>

<h4>●リストを使ったスタックの実装</h4>
<p> 次はリストを使って Stack の仕様を実装します。
</p>
<pre class="list">
リスト :  リストを使った Stack の実装

trait ListStack extends Stack {
  private var top: List[Item] = Nil

  def push(x: Item): Unit = top = x :: top

  def pop(): Item = {
    if (top == Nil) throw new Exception("ListStack.pop: Stack is Empty")
    val x = top.head
    top = top.tail
    x
  }

  def isEmpty(): Boolean = top == Nil
  def isFull(): Boolean = false
  def length(): Int = top.length
}
</pre>
<p> 名前は ListStack としました。この段階では Item の型を決定できないので、Stack で定義されている型 Item を使ってメソッドを実装します。スタック本体のリストはフィールド変数 top に格納します。値を書き換える必要があるので var で宣言します。Nil はリストの要素がどんな型であっても空リストを表すので、Item の型が決まっていなくても変数 top に代入することができます。
</p>

<p> メソッド push はコンス演算子で引数 x を top の先頭に追加して、top を新しい値に書き換えます。pop は最初にデータの有無をチェックして、データがなければエラーを送出します。そうでなければ、先頭の要素を取り出して変数 x にセットし、top の値を top.tail に書き換えます。最後に x を返します。あとのメソッドは簡単ですね。
</p>

<p> 最後に、Int を格納するスタックを作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : Int を格納するスタック

class IntListStack extends ListStack {
  type Item = Int
}
</pre>
<p> 名前は IntListStack としました。extends で ListStack を継承し、type で Item に Int を設定するだけです。これで new IntListStack とすると、Int を格納するスタックを生成することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; val a = new IntListStack
a: IntListStack = IntListStack@17cc3cb

scala&gt; for (i &lt;- 1 to 10) a.push(i)

scala&gt; a.length
res2: Int = 10

scala&gt; while (!a.isEmpty) println(a.pop)
10
9
8
7
6
5
4
3
2
1

scala&gt; a.isEmpty
res4: Boolean = true
</pre>
<p> また、次のように型パラメータを使ったスタックを作ることもできます。
</p>
<pre class="list">
リスト : 多相型のスタック

class PolyListStack[A] extends ListStack {
  type Item = A
}
</pre>
<p> type で Item に型パラメータ A をセットすると、PolyListStack は型パラメータを使った多相クラスになります。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; val b = new PolyListStack[String]
b: PolyListStack[String] = PolyListStack@123faef

scala&gt; b.push("foo")

scala&gt; b.push("bar")

scala&gt; b.push("baz")

scala&gt; while (!b.isEmpty) println(b.pop)
baz
bar
foo
</pre>
<h4>●配列を使ったスタックの実装</h4>
<p> 次は配列を使ってスタックを実装しましょう。配列でスタックを実現する場合、データを格納するための配列本体と、スタックのトップを表す変数が必要になります。本稿では、この変数を「スタックポインタ (stack pointer) 」と呼ぶことにしましょう。次の図を見てください。
</p>
<pre class="fig">
 buffer 0  1  2  3  4  5    top
 (1) [                    ]  0    空の状態 
 (2) [  A                 ]  1    PUSH A
 (3) [  A  B              ]  2    PUSH B
 (4) [  A  B  C           ]  3    PUSH C
 (5) [  A  B              ]  2    POP =&gt; C 
 (6) [  A                 ]  1    POP =&gt; B 
 (7) [                    ]  0    POP =&gt; A 

    図 : ベクタによるスタックの実現
</pre>
<p> まず、配列 buffer とスタックポインタ top を用意します。top の値は 0 に初期化しておきます。データをプッシュするときは buffer(top) にデータを格納してから、top の値をインクリメントします。逆にポップするときは、top の値をデクリメントしてから、buffer(top) にあるデータを取り出します。スタックを操作するたびに、top の値は上図のように変化します。
</p>

<p> データをプッシュしていくと、top の値は配列の大きさと等しくなります。配列はリストと違って大きさに限りがあるので、これ以上データを追加することはできません。つまり、スタックは満杯となります。したがって、データをプッシュするとき、スタックに空きがあるかチェックする必要があります。また、top が 0 のときはスタックが空の状態なので、ポップすることはできません。このチェックも必要になります。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 配列を使ったスタックの実装

trait ArrayStack extends Stack {
  protected val buff: Array[Item]
  private var cnt: Int = 0

  def push(x: Item) {
    if (isFull) throw new Exception("ArrayStack.push: Stack is Full")
    buff(cnt) = x
    cnt += 1
  }

  def pop(): Item = {
    if (isEmpty) throw new Exception("ArrayStack.pop: Stack is Empty")
    cnt -= 1
    buff(cnt)
  }

  def isEmpty(): Boolean = cnt == 0
  def isFull(): Boolean = buff.size == cnt
  def length(): Int = cnt
}
</pre>
<p> 変数 buff はスタック本体を表す配列を格納します。型が決まらないと配列は生成できないので、ここでは抽象フィールド変数として定義します。cnt はスタックに格納されている要素の個数を表します。これをスタックポインタとして使います。
</p>
<p> メソッド push は、最初にスタックに空きがあるかチェックします。満杯であればエラーを送出します。そうでなければ、buff(cnt) に x をセットして cnt を +1 します。pop は最初にスタックが空かチェックします。データがなければエラーを送出します。そうでなければ cnt を -1 してから buff(cnt) を返します。あとのメソッドは簡単ですね。
</p>

<p> 最後に、Int を格納するスタックを作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : Int を格納するスタック

class IntArrayStack(size: Int) extends ArrayStack {
  type Item = Int
  protected val buff = new Array[Item](size)
}
</pre>
<p> 名前は IntArrayStack としました。コンストラクタ引数 size でスタックの大きさを指定します。extends で ArrayStack を継承し、type で Item に Int を設定します。そして、new Array[Item](size) で配列本体を生成します。これで new IntArrayStack(10) とすると、Int を格納する大きさ 10 のスタックを生成することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; val b = new IntArrayStack(10)
b: IntArrayStack = IntArrayStack@1cec6a6

scala&gt; for (i &lt;- 1 to 10) b.push(i)

scala&gt; b.isFull
res2: Boolean = true

scala&gt; while (!b.isEmpty) println(b.pop)
10
9
8
7
6
5
4
3
2
1

scala&gt; b.isEmpty
res4: Boolean = true
</pre>
<p> なお、ArrayStack は ListStack と違って、型パラメータを使った多相的なクラスを作ることはできません。
</p>
<pre class="list">
リスト : 型パラメータを使った多相クラス (コンパイルエラー)

class PolyArrayStack[A](size: Int) extends ArrayStack {
  type Item = A
  protected val buff = new Array[Item](size)
}
</pre>
<p> 型 Item が決まらないので、配列を生成できずにコンパイルエラーとなります。型パラメータを使いたい場合は、要素の型を Any (または他のスーパークラス) に設定して配列を生成し、型変換を使ってデータの出し入れを行うことになります。実際、Scala のライブラリ scala.collection.mutable にあるクラス ArrayStack は型パラメータを使った多相クラスとして定義されています。
</p>

<h4>●リングバッファ</h4>
<p> 前回は mutable なリストを使ってキュー (queue) を実現しました。キューは配列を使っても簡単に実現できます。先頭位置を示す front と末尾を示す rear を用意し、front と rear の間にあるデータをキューに格納されているデータとするのがポイントです。次の図を見てください。
</p>
<pre class="fig">
           0  1  2  3  4  5  6  7  8  9
rear = 0  ↓
QUEUE    [                              ]  : QUEUE は空
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : データの追加
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 10を取り出す
front= 1     ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 20,30を取り出す
front= 3           ↑

                    図 : キューの動作
</pre>
<p> まずキューは空の状態で、rear, front ともに 0 です。データの追加は、rear が示す位置にデータを書き込み、rear の値を +1 します。データ 10, 20, 30 を追加すると、図のようにデータが追加され rear は 3 になります。このとき front は 0 のままなので、先頭のデータは 10 ということになります。
</p>

<p> 次に、データを取り出す場合、front の示すデータを取り出してから front の値を +1 します。この場合、front が 0 なので 10 を取り出して front の値は 1 となり、次のデータ 20 が先頭になります。データを順番に 20, 30 と取り出していくと、3 つしかデータを書き込んでいないので当然キューは空になります。このとき front は 3 になり rear と同じ値になります。このように、front と rear の値が 0 の場合だけが空の状態ではなく、front と rear の値が等しくなると、キューは空になることに注意してください。
</p>

<p> rear, fornt ともに値は増加していく方向なので、いつかは配列の範囲をオーバーします。このため、配列を先頭と末尾がつがっているリング状と考え、rear, front が配列の範囲を超えたら 0 に戻すことにします。これを「循環配列」とか「リングバッファ」と呼びます。一般に、配列を使ってキューを実装する場合は、リングバッファとするのが普通です。
</p>

<h4>●キューの仕様</h4>
<p> 最初に、キューの仕様を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : キューの仕様

trait Queue {
  type Item
  def enqueue(x: Item): Unit
  def dequeue(): Item
  def peek(): Item
  def isEmpty(): Boolean
  def isFull(): Boolean
  def length(): Int
  def clear(): Unit
}
</pre>
<p> トレイト Queue で抽象型 Item を定義します。あとのメソッドは前回作成したメソッドとほぼ同じです。
</p>

<h4>●配列を使ったキューの実装</h4>
<p> 配列を使ったキューの実装は次のようになります。
</p>
<pre class="list">
リスト : 配列によるキューの実装

trait ArrayQueue extends Queue {
  protected val buff: Array[Item]
  protected var front = 0
  protected var rear = 0
  protected var cnt = 0

  def enqueue(x: Item) = {
    if (isFull) throw new Exception("ArrayQueue.enqueue Queue is Full")
    buff(rear) = x
    rear += 1
    cnt += 1
    if (buff.size == rear) rear = 0
  }

  def dequeue(): Item = {
    if (isEmpty) throw new Exception("ArrayQueue.dequeue Queue is Empty")
    val x = buff(front)
    front += 1
    cnt -= 1
    if (buff.size == front) front = 0
    x
  }

  def peek(): Item = {
    if (isEmpty) throw new Exception("ArrayQueue.peek Queue is Empty")
    buff(front)
  }

  def isEmpty(): Boolean = cnt == 0
  def isFull(): Boolean = cnt == buff.size
  def length(): Int = cnt
  def clear() = {
    front = 0
    rear = 0
    cnt = 0
  }
}
</pre>
<p> 変数 buff はスタック本体を表す配列を格納します。cnt はキューに格納されている要素の個数を表します。この変数を用意することで、キューの状態を簡単にチェックすることができます。
</p>

<p> メソッド enqueue は、最初にキューに空きがあるかチェックします。満杯であればエラーを送出します。そうでなければ、buff(rear) に x をセットして rear と cnt を +1 します。そして、rear の値が配列の範囲を超えたならば 0 に戻します。
</p>

<p> メソッド dequeue は、キューにデータがあるかチェックしてから、front の位置にあるデータを取り出して変数 x にセットします。あとは、cnt と front の値を +1 して、front の値が配列の範囲を超えたら 0 に戻します。
</p>

<p> あとのメソッドは簡単なので説明は省略します。リストをお読みくださいませ。
</p>

<h4>●簡単な実行例</h4>
<p> 最後に Int を格納するキュー IntArrayQueue を作ります。
</p>
<pre class="list">
リスト : Int を格納するキュー

class IntArrayQueue(size: Int) extends ArrayQueue {
  type Item = Int
  protected val buff = new Array[Item](size)
}
</pre>

<p> 抽象型 Item を Int に設定し、buff に大きさ size の配列 Array[Int] をセットします。これでプログラムは完成です。
</p>
<p> それでは、簡単な使用例を示しましょう。
</p>
<pre>
scala&gt; val a = new IntArrayQueue(10)
a: IntArrayQueue = IntArrayQueue@1b01550

scala&gt; for (i &lt;- 1 to 10) a.enqueue(i)

scala&gt; a.isFull
res1: Boolean = true

scala&gt; a.length
res2: Int = 10

scala&gt; while (!a.isEmpty) println(a.dequeue)
1
2
3
4
5
6
7
8
9
10

scala&gt; a.isEmpty
res4: Boolean = true
</pre>
<p> 正常に動作していますね。
</p>

<h4>●immutable なスタックの実装</h4>
<p> 今まで作成したスタックは mutable なものですが、関数型言語では immutable なスタックが用いられます。imutable なスタックはリストを使って簡単に実現することができます。データを追加するときはリストの先頭に追加し、データを取り出すときはリストの先頭から行うように操作を限定すると、それはスタックの動作と同じになります。
</p>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : immutable なスタック

case class imStack[A](top: List[A] = Nil) {

  def push(x: A): imStack[A] = imStack[A](x :: top)

  def pop(): (A, imStack[A]) = top match {
    case Nil =&gt; throw new Exception("imStack.pop: Stack is Empty")
    case x::xs =&gt; (x, imStack[A](xs))
  }

  def isEmpty: Boolean = top == Nil
  def isFull: Boolean = false
  def length: Int = top.length
}
</pre>
<p> case クラスで imStack を定義します。フィールド変数 top はリストを格納しますが、immutable であることに注意してください。したがって、push や pop でスタックを操作する場合、新しい imStack を生成して返すことになります。push はデータをリストの先頭に追加した imStack を返します。pop はリストの先頭要素を取り除き、その要素と新しい imStack をタプルに格納して返します。スタックが空の場合はエラーを送出します。
</p>

<p> 簡単な使用例を示します。
</p>
<pre>
scala&gt; val a = new imStack[Int]
a: imStack[Int] = imStack(List())

scala&gt; a.isEmpty
res2: Boolean = true

scala&gt; val b = a.push(1)
b: imStack[Int] = imStack(List(1))

scala&gt; val c = b.push(2)
c: imStack[Int] = imStack(List(2, 1))

scala&gt; val d = c.push(3)
d: imStack[Int] = imStack(List(3, 2, 1))

scala&gt; val (x, e) = d.pop
x: Int = 3
e: imStack[Int] = imStack(List(2, 1))

scala&gt; val (y, f) = e.pop
y: Int = 2
f: imStack[Int] = imStack(List(1))

scala&gt; val (z, g) = f.pop
z: Int = 1
g: imStack[Int] = imStack(List())
</pre>
<p> 正常に動作していますね。関数型言語の場合、変数の値を書き換えることができないので、push や pop の返り値を別の変数に格納する必要があります。面倒なように思えますが、immutable なデータ構造は再帰定義や高階関数といっしょに使うと便利です。たとえば、リストの要素をスタックに格納する場合は次のようになります。
</p>
<pre>
scala&gt; List(1,2,3,4,5,6,7,8).foldLeft(new imStack[Int])(_.push(_))
res3: imStack[Int] = imStack(List(8, 7, 6, 5, 4, 3, 2, 1))
</pre>
<p> プレイスホルダーを使って、(a, x) =&gt; a.push(x) を _.push(_) で表していることに注意してください。
</p>

<h4>●immutable なキュー</h4>
<p> 今度はリストを使って immutable なキューを作ってみましょう。リストを使ってキューを実装する場合、キューの先頭とリストの先頭を対応させます。すると、キューからデータを取り出すには、リストの先頭からデータを取り出すだけですみます。これはとても簡単ですね。
</p>

<p> ただし、キューにデータを入れるには、リストの最後尾にデータを追加することになるため、ちょっとした工夫が必要になります。たとえば、データの追加に演算子 ::: を使うと、データを追加するたびにリスト（キュー）がコピーされてしまいます。このため、キューに格納されているデータが多くなると時間がかかるようになります。
</p>

<p> これを回避する方法はいろいろ考えられるのですが、今回は関数型言語 (SML/NJ など) でよく使われている方法を紹介します。次の図を見てください。
</p>

<pre class="fig">
            先頭                        
 変数      ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 front ─→│０│・┼─→│１│・┼─→│２│／│  
           └─┴─┘    └─┴─┘    └─┴─┘
           最後尾                  
           ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 rear  ─→│５│・┼─→│４│・┼─→│３│／│  
           └─┴─┘    └─┴─┘    └─┴─┘

        図 : キューの構造
</pre>

<p> 上図は 2 つのリストでキューを表しています。データを取り出すときは front のリストを、データを追加するときは rear のリストを使います。front と rear で一つのキューを構成し、rear のリストはデータを逆順で格納することになります。ようするに、front が先頭で rear が最後尾になるわけです。上図のキューを一つのリストで表すと (0, 1, 2, 3, 4, 5) になります。
</p>
<p> したがって、front が空リストでも rear にデータがあれば、キューは空ではありません。rear のリストを逆順にして front にセットし、rear を空リストにします。これで front からデータを取り出すことができます。キューが空の状態は front と rear が両方とも空リストの場合です。
</p>

<h4>●immutable なキューの実装</h4>
<p> それではプログラムを作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : immutable なキューの実装

case class imQueue[A](front: List[A] = Nil, rear: List[A] = Nil) {

  def enqueue(x: A): imQueue[A] = imQueue[A](front, x::rear)

  def dequeue(): (A, imQueue[A]) = {
    if (isEmpty) throw new Exception("imQueue.dequeue: Queue is Empty")
    front match {
      case Nil =&gt; imQueue[A](rear.reverse, Nil).dequeue
      case x::xs =&gt; (x, imQueue[A](xs, rear))
    }
  }

  def peek(): A = {
    if (isEmpty) throw new Exception("imQueue.peek: Queue is Empty")
    front match {
      case Nil =&gt; rear.reverse.head
      case x::_ =&gt; x
    }
  }

  def isEmpty: Boolean = front == Nil && rear == Nil
  def length: Int = front.length + rear.length
}
</pre>
<p> case クラスで imQueue を定義します。フィールド変数は front と rear の 2 つです。どちらも immutable であることに注意してください。
</p>

<p> equeue はキューにデータ x を追加します。これは x を rear の先頭に追加するだけです。dequeue はキューからデータを取り除きます。キューが空の場合はエラーを送出します。front が空リストの場合は、キュー imQueue(rear.reverse, Nil) を作って dequeue を再帰呼び出しします。front にデータがある場合はパターン x::xs とマッチングさせ、x と imQueue(xs, rear) をタプルに格納して返します。peek はキューの先頭要素を返します。処理は dequeue とほとんど同じで、違いはキューの先頭要素を返すだけです。あとのメソッドは簡単ですね。
</p>

<p> それでは簡単な実行例を示します。
</p>
<pre>
scala&gt; val a = List(1,2,3,4,5,6,7,8).foldLeft(new imQueue[Int])(_.enqueue(_))
a: imQueue[Int] = imQueue(List(),List(8, 7, 6, 5, 4, 3, 2, 1))

scala&gt; val (x, b) = a.dequeue
x: Int = 1
b: imQueue[Int] = imQueue(List(2, 3, 4, 5, 6, 7, 8),List())

scala&gt; val (y, c) = b.dequeue
y: Int = 2
c: imQueue[Int] = imQueue(List(3, 4, 5, 6, 7, 8),List())

scala&gt; val (z, d) = c.dequeue
z: Int = 3
d: imQueue[Int] = imQueue(List(4, 5, 6, 7, 8),List())

scala&gt; d.peek
res6: Int = 4
</pre>
<p> 正常に動作していますね。
</p>

<h4>●型パラメータの制限</h4>
<p> Scala の型パラメータは任意の型を表しますが、プログラムによっては型に制限をかけたい場合があります。Scala は型パラメータの指定で「上限境界」と「下限境界」という制限を設定することができます。
</p>
<pre class="item">
1. 上限境界 A &lt;: Foo, 型 A は型 Foo か、そのサブクラス
2. 下限境界 A &gt;: Baz, 型 A は型 Baz か、そのスーパークラス
</pre>
<p> これを「型境界」といいます。型境界は type の抽象型でも設定することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; class Foo
defined class Foo

scala&gt; class Bar extends Foo
defined class Bar

scala&gt; class Baz extends Bar
defined class Baz

scala&gt; class Oops[A &lt;: Bar]
defined class Oops

scala&gt; new Oops[Foo]
&lt;console&gt;:10: error: type arguments [Foo] do not conform to class Oops's 
type parameter bounds [A &lt;: Bar]
       val res0 =
           ^
&lt;console&gt;:11: error: type arguments [Foo] do not conform to class Oops's 
type parameter bounds [A &lt;: Bar]
              new Oops[Foo]
                  ^

scala&gt; new Oops[Bar]
res1: Oops[Bar] = Oops@1d2ade3

scala&gt; new Oops[Baz]
res2: Oops[Baz] = Oops@1cf2fc1
</pre>
<p> 継承関係が Foo - Bar - Baz というクラスを作ります。クラス Oops は多相クラスで、型パラメータに A &lt;: Bar を指定しているので、指定できる型は Bar または Bar のサブクラスである Baz になります。new Oops[Foo] とするとエラーになりますが、Oops[Bar] と Oops[Baz] はインスタンスを生成できます。
</p>
<pre>
scala&gt; class Oops1[A &gt;: Bar]
defined class Oops1

scala&gt; new Oops1[Foo]
res3: Oops1[Foo] = Oops1@b61c56

scala&gt; new Oops1[Bar]
res4: Oops1[Bar] = Oops1@1713d56

scala&gt; new Oops1[Baz]
&lt;console&gt;:11: error: type arguments [Baz] do not conform to class Oops1's 
type parameter bounds [A &gt;: Bar]
       val res5 =
           ^
&lt;console&gt;:12: error: type arguments [Baz] do not conform to class Oops1's 
type parameter bounds [A &gt;: Bar]
              new Oops1[Baz]
                  ^
</pre>
<p> クラス Oops1 の型パラメータは A &gt;: Bar なので、今度は Bar または Bar のスーパークラス Foo でインスタンスを生成できます。Bar のサブクラス Baz を指定して new Oops1[Baz] とするとエラーになります。
</p>
<p> また、上限境界と下限境界を同時に設定することもできます。
</p>
<pre class="item">
[A &gt;: Baz &lt;: Bar]
</pre>
<p> これで Baz 以上 Bar 以下のクラス、つまり、Bar と Baz に型パラメータ A を限定することができます。
</p>

<h4>●Ordered トレイト</h4>
<p> それでは簡単な例題として、リストを挿入ソートする関数 insertSort を多相型関数に改良してみましょう。次のように、単純に型パラメータを指定するだけではコンパイルでエラーになります。
</p>
<pre class="list">
リスト : 単純挿入ソート (コンパイルエラー)

  def insertSort[A](xs: List[A]): List[A] = {
    def insertElement(x: A, xs: List[A]): List[A] =
      xs match {
        case Nil =&gt; List(x)
        case y::ys =&gt; if (x &lt; y) x::y::ys else y::insertElement(x, ys)
      }
    xs match {
      case Nil =&gt; Nil
      case y::ys =&gt; insertElement(y, insertSort(ys))
    }
  }
</pre>
<p> 型パラメータ A だけでは、リストの要素の型に演算子 &lt; が定義されているか判定できないので、コンパイルエラーになります。この場合、トレイト Ordered[A] を継承して、型パラメータに上限境界を指定します。Ordered は次のように比較演算子を定義しています。
</p>
<pre class="list">
リスト : Ordered (Ordered.scala より抜粋)

trait Ordered[A] extends Any with java.lang.Comparable[A] {
  /*
   * Returns `x` where:
   *   - `x &lt; 0` when `this &lt; that`
   *   - `x == 0` when `this == that`
   *   - `x &gt; 0` when  `this &gt; that`
   */
  def compare(that: A): Int

  def &lt;  (that: A): Boolean = (this compare that) &lt;  0

  def &gt;  (that: A): Boolean = (this compare that) &gt;  0

  def &lt;= (that: A): Boolean = (this compare that) &lt;= 0

  def &gt;= (that: A): Boolean = (this compare that) &gt;= 0

  def compareTo(that: A): Int = compare(that)
}
</pre>
<p> Scala の場合、比較演算子もメソッドです。Orderd を継承して抽象メソッド compare をオーバーライドすれば比較演算子を使用することができます。
</p>
<p> 簡単な例として、点を表す Point クラスで Orderd を継承してみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : Point クラス

case class Point(val x: Double, val y: Double) extends Ordered[Point] {
  def distance(that: Point): Double = {
    val dx = x - that.x
    val dy = y - that.y
    Math.sqrt(dx * dx + dy * dy)
  }
  
  def compare(that: Point): Int = {
    val a = Math.sqrt(x * x + y * y)
    val b = Math.sqrt(that.x * that.x + that.y * that.y)
    if (a == b) 0 else if (a &lt; b) -1 else 1
  }
}
</pre>
<p> Ordered を継承するとき、型パラメータには Point を指定します。大小関係は、とりあえず原点 Point(0, 0) からの距離を基準にしましょう。あとは、compare で原点からの距離を求めて変数 a, b にセットし、a == b ならば 0 を、a &lt; b ならば -1 を、a &gt; b ならば 1 を返します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; val a = Point(1, 1)
a: Point = Point(1.0,1.0)

scala&gt; val b = Point(2, 2)
b: Point = Point(2.0,2.0)

scala&gt; a &lt; b
res0: Boolean = true

scala&gt; b &gt; a
res1: Boolean = true

scala&gt; a &gt;= a
res2: Boolean = true
</pre>
<p> あとは insertSort の型パラメータで、A &lt: Ordered[A] を指定すると、Point を格納したリストをソートすることができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : Point のソート

object sample1301 {
  def insertSort[A &lt;: Ordered[A]](xs: List[A]): List[A] = {
    def insertElement(x: A, xs: List[A]): List[A] =
      xs match {
        case Nil =&gt; List(x)
        case y::ys =&gt; if (x &lt; y) x::y::ys else y::insertElement(x, ys)
      }
    xs match {
      case Nil =&gt; Nil
      case y::ys =&gt; insertElement(y, insertSort(ys))
    }
  }
  def main(args: Array[String]) {
    println(insertSort(List(Point(5,5), Point(4,4), Point(3,3), Point(2,2), Point(1,1))))
  }
}
</pre>
<pre>
C&gt;scala sample1301
List(Point(1.0,1.0), Point(2.0,2.0), Point(3.0,3.0), Point(4.0,4.0), Point(5.0,5.0))
</pre>
<p> ただし、このままでは整数 (Int) を格納したリスト (List[Int]) をソートすることはできません。Int だけではなく、Double など基本的な数は Ordered を継承 (または Mix-in) していないからです。この場合、「可視境界」を使うと Int や Double でもソートすることができます。具体的には A &lt;% Ordered[A] と指定します。興味のある方は試してみてください。可視境界については回を改めて説明する予定です。
</p>

<h4>●変位の指定</h4>
<p> Scala の型パラメータは境界の指定だけではなく、「変位」を指定することができます。たとえば、Foo - Bar - Baz という継承関係を持つクラスと多相クラス Oops[A] があるとします。型 Oops[Foo] と Oops[Bar] に直接の関係はありませんが、型パラメータに指定するクラスの継承関係を使って、多相クラスでも親子関係 (スーパークラスとサブクラスの関係) を考えることができます。Scala では、この機能を「変位」といいます。
</p>

<p> 変位の指定には「非変 (nonvariant) 」、「共変 (covariant) 」、「反変 (contravariant) 」の 3 通りあります。今までのように型パラメータ A だけ指定すると「非変」になります。これは多相クラスに親子関係を持たせない方法です。次の例を見てください。
</p>
<pre>
scala&gt; class Foo
defined class Foo

scala&gt; class Bar extends Foo
defined class Bar

scala&gt; class Baz extends Bar
defined class Baz

scala&gt; class Oops[A]
defined class Oops

scala&gt; var a: Oops[Foo] = new Oops[Foo]
a: Oops[Foo] = Oops@1483de4

scala&gt; a = new Oops[Bar]
&lt;console&gt;:11: error: type mismatch;
 found   : Oops[Bar]
 required: Oops[Foo]
Note: Bar &lt;: Foo, but class Oops is invariant in type A.
You may wish to define A as +A instead. (SLS 4.5)
       a = new Oops[Bar]
           ^

scala&gt; a = new Oops[Baz]
&lt;console&gt;:12: error: type mismatch;
 found   : Oops[Baz]
 required: Oops[Foo]
Note: Baz &lt;: Foo, but class Oops is invariant in type A.
You may wish to define A as +A instead. (SLS 4.5)
       a = new Oops[Baz]
           ^
</pre>
<p> 多相クラスに親子関係があるならば、親クラスの変数に子クラスのインスタンスを代入することができます。非変の場合、多相クラスに親子関係はないので、上記のように Oops[Foo] と宣言した変数 a に代入できるのは Oops[Foo] だけで、Oops[Bar] や Oops[Baz] のインスタンスは代入できません。
</p>
<p> 共変は型パラメータで指定するクラスと同じ親子関係を設定する方法です。したがって、型パラメータ A で指定したクラスのサブクラスも同じ変数に代入することができます。共変の指定は型パラメータの前に + を付けます。次の例を見てください。
</p>
<pre>
scala&gt; class Oops1[+A]
defined class Oops1

scala&gt; var a: Oops1[Foo] = new Oops1[Foo]
a: Oops1[Foo] = Oops1@960bfa

scala&gt; a = new Oops1[Bar]
a: Oops1[Foo] = Oops1@14e5088

scala&gt; a = new Oops1[Baz]
a: Oops1[Foo] = Oops1@148b3d2

scala&gt; var b: Oops1[Bar] = new Oops1[Foo]
&lt;console&gt;:10: error: type mismatch;
 found   : Oops1[Foo]
 required: Oops1[Bar]
       var b: Oops1[Bar] = new Oops1[Foo]
                           ^
</pre>
<p> クラス Oops1 は型パラメータで +A と指定しているので共変になります。変数 a を Oops1[Foo] と宣言すると、Foo[Bar] や Foo[Baz] のインスタンスでも代入することができます。変数 b は Oops1[Bar] と宣言しているので、Oosp1[Foo] のインスタンスは代入できません。
</p>
<p> 共変とは逆に、反変は指定したクラスと逆の親子関係を設定する方法です。Foo のサブクラスが Bar とすると、反変は Oops[Bar] が Oops[Foo] のスーパークラスになります。反変は型パラメータの前に - を付けます。次の例を見てください。
</p>
<pre>
scala&gt; class Oops2[-A]
defined class Oops2

scala&gt; var a: Oops2[Bar] = new Oops2[Bar]
a: Oops2[Bar] = Oops2@1af3a0f

scala&gt; a = new Oops2[Foo]
a: Oops2[Bar] = Oops2@1304f9d

scala&gt; a = new Oops2[Baz]
&lt;console&gt;:12: error: type mismatch;
 found   : Oops2[Baz]
 required: Oops2[Bar]
       a = new Oops2[Baz]
           ^
</pre>
<p> クラス Oops2 の型パラメータは -A なので反変になります。変数 a は Oops2[Bar] と宣言されているので、Oops2[Bar] だけではなく Oops2[Foo] のインスタンスも格納することができます。ただし、Oops2[Baz] のインスタンスは格納することができません。
</p>

<h4>●mutable な多相型データ構造は非変</h4>
<p> Scala の場合、mutable な多相型データ構造は非変に設定します。次の例を見てください。
</p>
<pre>
scala&gt; class Foo[A](var x: A)
defined class Foo

scala&gt; val a = new Foo[Int](10)
a: Foo[Int] = Foo@154b8c5

scala&gt; a.x
res0: Int = 10

scala&gt; a.x = 20
a.x: Int = 20
</pre>
<p> もしも、型パラメータ A を共変に設定すると、次のプログラムが動作することになります。
</p>
<pre class="list">
val a = new Foo[Int](10)
val b: Foo[Any] = a
a.x = "oops" =&gt; エラー
</pre>
<p> 型 Any はすべてのオブジェクトのスーパークラスです。変数 b の型を Foo[Any] と宣言すれば、Int は Any のサブクラスなので、変数 a のインスタンスを変数 b に代入することができます。変数 b の型は Foo[Any] なので、ここに文字列を代入してもいいはずですが、b の実体は Foo[Int] で Int しか格納することができません。この場合、実行時にエラーを送出することになるでしょう。
</p>
<p> 実際、Scala の配列は非変に設定されていますが、Java の配列は共変です。Java の場合、配列を使って上記のようなプログラムを書くことが可能です。次のリストを見てください。
</p>
<pre class="list">
リスト : Java の配列は共変 (test.java)

public class test {
  public static void main(String[] args){
    Integer [] a = new Integer [] {1, 2, 3, 4};
    Object [] b = a;
    b[0] = 10;
    for (Object x: b) System.out.println(x);    
  }
}
</pre>
<pre>
C&gt;javac test.java

C&gt;java test
10
2
3
4
</pre>
<p> Integer の配列 a を作成します。変数 b を Object の配列に宣言すると、変数 b に a の配列を代入することができます。配列の値を Integer 以外の値に書き換えなければ、このプログラムでも正常に動作します。
</p>
<p> ところが、配列 b は Object で宣言しているので、そこに文字列を代入することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : Java の配列は共変 (実行時エラー)

public class test {
  public static void main(String[] args){
    Integer [] a = new Integer [] {1, 2, 3, 4};
    Object [] b = a;
    b[0] = "hello, world";
    for (Object x: b) System.out.println(x);
  }
}
</pre>
<p> b[0] に文字列をセットします。実際、コンパイルしてもエラーはならないのですが、実行するとエラーが送出されます。
</p>
<pre>
C&gt;javac test.java

C&gt;java test
Exception in thread "main" java.lang.ArrayStoreException: java.lang.String
        at test.main(test.java:5)
</pre>
<p> Scala では、配列を非変に設定しているので、このような危険なプログラムを書くことはできません。
</p>

<p> それでは、型パラメータ A に反変を設定することはできるのでしょうか。実際に試してみると、次のようなエラーが出ます。
</p>
<pre>
scala&gt; class Foo[-A](var x: A)
&lt;console&gt;:7: error: contravariant type A occurs in covariant position in type =&gt; A of method x
       class Foo[-A](var x: A)
                         ^
</pre>
<p> <a href="scala14.html#cite">参考 URL </a> によると、Scala のメソッドは、仮引数の変位を反変に、返り値の変位を共変に設定しているようです。メソッド x はフィールド変数 x の値を返すので返り値の型は A で変位は反変になります。共変の位置に反変の型パラメータ A が出現している場合、Scala はコンパイルエラーとするようです。逆に、反変の位置に共変の型パラメータが出現してもコンパイルエラーになります。
</p>
<p> もしも、型パラメータ A に反変を許したらどうなるのでしょう。次の例を見てください。
</p>
<pre>
scala&gt; class Foo {
     | def foo() = println("Foo")
     | }
defined class Foo

scala&gt; class Bar extends Foo {
     | def bar() = println("Bar")
     | }
defined class Bar
</pre>
<pre class="list">
class Baz[-A](var x: A)

val a: Baz[Foo] = new Baz(new Foo)
val b: Baz[Bar] = a
a.x.bar() =&gt; エラー
</pre>
<p> Bar は Foo のサブクラスなので、Baz[Foo] は Baz[Bar] のサブクラスになります。したがって、Baz[Foo] のインスタンス a は、スーパークラス Baz[Bar] の変数 b にセットすることができます。変数 b は Baz[Bar] なので、a.x の型は Bar でメソッド bar を呼び出すことができるはずです。ですが、b の実体は Baz[Foo] であり、Foo にメソッド bar はありません。この場合も実行時にエラーが送出されることになるでしょう。
</p>

<p> 型パラメータの変位を共変に設定すると、次のように動作します。ただし、フィールド変数 x を immutable にします。
</p>
<pre>
scala&gt; class Baz[+A](val x: A)
defined class Baz

scala&gt; val a = new Baz[Bar](new Bar)
a: Baz[Bar] = Baz@1483de4

scala&gt; val b: Baz[Foo] = a
b: Baz[Foo] = Baz@1483de4

scala&gt; b.x.foo()
Foo
</pre>
<p> 変位は共変なので、Baz[Foo] は Baz[Bar] のスーパークラスになり、Baz[Bar] のインスタンス a を、Bar[Foo] で宣言した変数 b に代入することができます。そして、b.x.foo() でメソッド foo を呼び出すことができます。これは Bar が Foo のメソッド foo を継承しているので、問題なく動作します。
</p>

<p> Scala の場合、immutable な多相クラスは変位を共変に設定するようです。今回はここまでです。次回は多相クラスを使って実際に immutable なデータ構造を作ってみましょう。
</p>

<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="http://tech.cm55.com/wiki/scala">scala - tech.cm55.com</a>, <a href="http://tech.cm55.com/wiki/scala/typeSystem">Scala の型システム</a>
  <li><a href="http://www29.atwiki.jp/tmiya/">プログラミング言語 Scala Wiki</a>, <a href="http://www29.atwiki.jp/tmiya/pages/46.html">Scala By Example 和訳 : 第 8 章 ジェネリックな型とメソッド</a>
</ol>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala13.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala15.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>