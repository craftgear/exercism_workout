<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881778</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala11.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala13.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>例外処理</h3>
<p> 今回は「例外処理」について説明します。一般に、例外 (exception) はエラー処理で使われる機能です。「例外＝エラー処理」と考えてもらってもかまいません。最近は例外処理を備えているプログラミング言語が多くなりました。もちろん Scala にも例外処理があります。なお、エラーが発生したことを「例外が発生した」とか「例外が送出された」という場合もあります。本稿でもエラーのことを例外と記述することにします。
</p>

<h4>●例外の捕捉</h4>
<p> 通常、例外が発生すると Scala はプログラムの実行を中断しますが、致命的な例外でなければプログラムの実行を継続する、または特別な処理を行わせたい場合もあるでしょう。このような場合に、例外処理が役に立ちます。Scala では発生した例外を捕まえるのに try 式を使います。try 式の構文を下図に示します。
</p>

<pre class="fig">
try {
  処理A
} catch {
  case 変数1: ExceptionClass1 =&gt; 式1
  case 変数2: ExceptionClass2 =&gt; 式2
  ...
}

        図 : 例外処理
</pre>

<p> Scala の場合、try も式になります。try は、そのあとに定義されている処理 A を実行します。処理 A が正常に終了した場合は try も終了し、返り値は処理 A の結果になります。もしも、処理 A で例外が発生した場合、処理 A の実行は中断され、その例外が catch の case 節で指定した例外と一致すれば、その case 節を実行します。try の返り値は case 節で実行した式の値になります。
</p>

<p> case 節には例外を型 ExceptionClass で指定します。捕捉した例外は case 節の変数にセットされます。try の catch には複数の case 節を指定することができます。Scala の例外は Java と同じクラスが使用されいて、Throwable というクラスとして定義されています。例外は階層構造になっていて、すべての例外は直接または間接的に Throwable を継承します。Throwable は Error と Exception に分けられ、Exception は RuntimeException とそれ以外の例外に分けられます。
</p>

<p> Error を継承した例外は、復旧するのが困難なエラーが発生したことを表します。RuntimeException を継承した例外は、Java の仮想マシン (JVM) で発生したエラーを表します。たとえば、0 で割ったときに送出される例外 ArithmeticException や、配列の添字が範囲外であることを表す例外 ArrayIndexOutOfBoundsException などがあります。
</p>

<p> Java の場合、Error と RuntimeException は「非チェック例外」といって、try 文で例外処理を記述しなくてもプログラムをコンパイルすることができます。RuntimeException 以外の Exception は「チェック例外」といって、try 文で例外処理を記述しないとコンパイルでエラーになります。ところが、Scala の例外はすべて「非チェック例外」になります。try 文による例外処理を記述しなくてもコンパイルエラーにはなりません。ご注意くださいませ。
</p>

<h4>●try 式の使い方</h4>
<p> try 式の使い方は簡単です。次の例を見てください。
</p>

<pre>
scala&gt; try { 10 / 5 } catch { case e: ArithmeticException =&gt; println(e); 0 }
res0: Int = 2

scala&gt; try { 10 / 0 } catch { case e: ArithmeticException =&gt; println(e); 0 }
java.lang.ArithmeticException: / by zero
res1: Int = 0
</pre>

<p> try 式の中で割り算を実行します。Scala の場合、0 で除算すると例外 ArithmeticException を送出して実行を中断します。ここで、try 文の catch 節に ArithmeticException を指定すると、例外を捕捉して処理を続行することができます。
</p>
<p> 10 / 2 は 5 を返しますが、10 / 0 は 0 で除算しているので例外 ArithmeticException が送出されます。この例外クラスは catch 節に指定されているので、その節が実行されて例外クラスのインスタンス e の内容を表示して 0 を返します。
</p>

<h4>●例外の送出</h4>
<p> 例外は throw で送出することができます。
</p>

<pre class="item">
throw new ExceptionClass(args, ...)
</pre>

<p> throw には例外クラスのインスタンスを引数として渡します。throw が実行されると、プログラムの実行を直ちに中断して、例外を受け止める catch に該当する case 節があると、そこへ制御が移ります。該当する case 節がない場合、プログラムの実行は中断されます。
</p>

<p> 簡単な例を示しましょう。
</p>

<pre>
scala&gt; try { throw new RuntimeException("Oops!") } catch { case e: RuntimeException =&gt; println(e) }
java.lang.RuntimeException: Oops!
</pre>
<p> 例外に渡した引数は、例外クラスのインスタンスに格納されます。例外クラスのインスタンスは catch の case 節で受け取ることができます。上記の例では、送出された例外のインスタンスは変数 e にセットされます。例外に渡したメッセージはインスタンスに格納されます。
</p>

<h4>●例外の定義</h4>
<p> 例外は他の例外を継承することで、ユーザが独自に定義することができます。Scala の場合、Exception か RuntimeException を継承するといいでしょう。次の例を見てください。
</p>

<pre>
scala&gt; class BarException(mes: String) extends RuntimeException(mes)
defined class BarException

scala&gt; throw new BarException("oops!")
BarException: oops!
  ... 32 elided
</pre>
<p> このように、BarException は RuntimeException を継承しているので、フィールド変数やメソッドを定義しなくてもスーパークラスのコンストラクタを呼び出すだけで動作します。
</p>

<h4>●大域脱出</h4>
<p> Scala の例外は、try の中で呼び出した関数の中で例外が送出されても、それを捕捉することができます。この機能を使って、評価中の関数からほかの関数へ制御を移す「大域脱出 (global exit) 」を実現することができます。
</p>

<p> 簡単な例を示しましょう。
</p>

<pre>
scala&gt; class GlobalExitException extends RuntimeException
defined class GlobalExitException

scala&gt; def bar1() = println("call bar1")
bar1: ()Unit

scala&gt; def bar2() = throw new GlobalExitException
bar2: ()Nothing

scala&gt; def bar3() = println("call bar3")
bar3: ()Unit

scala&gt; def foo() = { bar1; bar2; bar3 }
foo: ()Unit

scala&gt; try { foo } catch { case e:GlobalExitException =&gt; println("Golbal Exit") }
call bar1
Golbal Exit
</pre>
<p> 実行の様子を下図に示します。
</p>

<pre class="fig">
 ┌───────┐
 │try { ... }   │←─┐
 │catch { ... } │    │
 └───────┘    │
        ↓             │
 ┌──────┐      │
 │   foo()    │──┐│
 └──────┘    ││
       ↓↑          ↓│
 ┌──────┐  ┌ bar2() ───────────┐ 
 │  bar1()    │  │throw new GlobalExitException │
 └──────┘  └───────────────┘

            図 : 大域脱出
</pre>

<p> 通常の関数呼び出しは、呼び出し元の関数に制御が戻ります。ところが bar2 で throw が実行されると、呼び出し元の関数 foo を飛び越えて、制御が try の catch に移るのです。このように、例外処理を使って関数を飛び越えて制御を移すことができます。
</p>

<p> 大域脱出はとても強力な機能ですが、多用すると処理の流れがわからなくなる、いわゆる「スパゲッティプログラム」になってしまいます。使用には十分ご注意下さい。
</p>

<h4>●finally 節</h4>
<p> ところで、プログラムの途中で例外が送出されると、残りのプログラムは実行されません。このため、必要な処理が行われない場合があります。このような場合、try に finally 節を定義します。finally 節は try の処理で例外が発生したかどうかにかかわらず、try の処理が終了するときに必ず実行されます。例外が発生した場合は、finally 節を実行したあとで同じ例外を再送出します。なお、catch 節と finally 節を同時に try 文に書く場合は、catch 節を先に定義してください。そのあとで finally 節を定義します。
</p>

<p> 簡単な例を示しましょう。大域脱出で作成した foo を呼び出す関数 baz を作ります。
</p>
<pre>
scala&gt; def baz() = try { foo } finally { println("clean up") }
baz: ()Unit

scala&gt; try { baz } catch { case e:GlobalExitException =&gt; println("Golbal Exit") }
call bar1
clean up
Golbal Exit
</pre>

<p> 関数 bar2() で送出された例外 GlobalExitException は baz() の finally 節で捕捉されて println("clean up") が実行されます。その後、例外 GlobalExitException が再送出され、try の catch 節に捕捉されて Global Exit と表示されます。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">有理数</h3>
<p> 今回は簡単な例題として、有理数 (分数) を表すクラスを作ってみましょう。
</p>

<h4>●有理数の定義</h4>
<p> 有理数 (Rational) は分子と分母を整数の組で表すと簡単に定義できます。次のリストを見てください。
</p>
<pre class="list">
リスト : 有理数の定義

package rational

class Rat private (val n: BigInt, val d: BigInt) {
  override def toString: String =
    if (d == 1) n.toString else n + "/" + d
}
</pre>
<p> フィールド変数 n が分子を表し、d が分母を表します。どちらも val で宣言します。簡単な定義ですが、多倍長整数を使っているので、大きな数値を扱っても桁あふれの心配はありません。
</p>

<h4>●有理数の生成</h4>
<p> 次は有理数を生成するメソッド apply を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 有理数の生成

object Rat {
  def apply(a: BigInt, b: BigInt): Rat = {
    if (b == 0) throw new ArithmeticException
    val g = a gcd b
    val n = a * b.signum / g
    val d = b * b.signum / g
    new Rat(n, d)
  }
}
</pre>
<p> 引数 a が分子で、b が分母を表します。b が 0 の場合はエラーを送出します。そうでなければ、Rat (a, b) を生成します。このとき、BigInt のメソッド gcd で最大公約数を求めて、約分することに注意してください。それから、有理数の符号は分子に付けることにします。signum は符号 (-1, 0, 1) を求めるメソッドです。分母 b が負の場合は a と b に -1 を掛け算して、分母を正の値にします。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
scala&gt; import rational._
import rational._

scala&gt; Rat(10, 100)
res0: rational.Rat = 1/10

scala&gt; Rat(10, -12)
res1: rational.Rat = -5/6

scala&gt; Rat(-1234, -2)
res2: rational.Rat = 617

scala&gt; Rat(-1234, -4)
res3: rational.Rat = 617/2
</pre>

<h4>●算術演算子の定義</h4>
<p> Scala の演算子はメソッドで「多重定義」もできるので、算術演算子の定義は簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 算術演算子の定義

class Rat private (val n: BigInt, val d: BigInt) {
  override def toString: String = n + "/" + d

  def +(that: Rat): Rat = Rat(n * that.d + that.n * d, d * that.d)

  def -(that: Rat): Rat = Rat(n * that.d - that.n * d, d * that.d)

  def *(that: Rat): Rat = Rat(n * that.n, d * that.d)

  def /(that: Rat): Rat = Rat(n * that.d, d * that.n)
}
</pre>
<p> 単純な分数の計算なので、難しいところはないでしょう。この場合、演算子の優先順位は +, -, *, / と同じです。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
scala&gt; import rational._
import rational._

scala&gt; val a = Rat(1, 2)
a: rational.Rat = 1/2

scala&gt; val b = Rat(1, 3)
b: rational.Rat = 1/3

scala&gt; a + b
res0: rational.Rat = 5/6

scala&gt; a - b
res1: rational.Rat = 1/6

scala&gt; b - a
res2: rational.Rat = -1/6

scala&gt; a * b
res3: rational.Rat = 1/6

scala&gt; a / b
res4: rational.Rat = 3/2

scala&gt; b / a
res5: rational.Rat = 2/3
</pre>

<h4>●暗黙の型変換</h4>
<p> これで有理数と有理数の計算はできますが、有理数と整数の計算はできません。そこで、有理数と多倍長整数の計算を行う演算子を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : 算術演算子の多重定義

class Rat private (val n: BigInt, val d: BigInt) {
  override def toString: String = n + "/" + d

  def +(that: Rat): Rat = Rat(n * that.d + that.n * d, d * that.d)
  def +(x: BigInt): Rat = Rat(n + x * d, d)

  def -(that: Rat): Rat = Rat(n * that.d - that.n * d, d * that.d)
  def -(x: BigInt): Rat = Rat(n - x * d, d)

  def *(that: Rat): Rat = Rat(n * that.n, d * that.d)
  def *(x: BigInt): Rat = Rat(n * x, d)

  def /(that: Rat): Rat = Rat(n * that.d, d * that.n)
  def /(x: BigInt): Rat = Rat(n, d * x)
}
</pre>
<p> Int や Long に対応するメソッドが定義されていませんが、これでも有理数と整数 (Byte, Short, Int, Long, BigInt) の計算を行うことができます。これは、Scala が Int や Long を自動的に BigInt に型変換してくれるからです。次の例を見てください。
</p>
<pre>
scala&gt; val a: BigInt = 10: Int
a: BigInt = 10

scala&gt; val b: BigInt = 10: Long
b: BigInt = 10

scala&gt; val c: BigInt = 10: Short
c: BigInt = 10

scala&gt; val d: BigInt = 10: Byte
d: BigInt = 10

scala&gt; val e: BigInt = 10: Double
&lt;console&gt;:7: error: type mismatch;
 found   : Double
 required: BigInt
       val e: BigInt = 10: Double
                         ^
</pre>
<p> 整数は BigInt に型変換されますが、Double は型変換されずにエラーになります。Scala は型が一致しない場合、事前に用意されている変換関数を呼び出して、型変換を自動的に行います。この機能を「暗黙の型変換 (implicit conversion) 」とか「暗黙変換」といいます。整数は BigInt に変換する関数が用意されていますが、Double は用意されていないのでエラーになるわけです。
</p>

<p> 今のままでは、式が "有理数 演算子 整数" の場合は計算できますが、"整数 演算子 有理数" だとコンパイルエラーになります。そこで、整数を有理数に変換する関数を定義することにしましょう。
</p>

<h4>●変換関数の定義</h4>
<p> 変換関数の定義は def の前に implicit を付けます。
</p>
<pre class="item">
implicit def 名前(引数: 元の型): 変換後の型 = 式
</pre>
<p> 名前は "元の型" + "To" + "変換後の型" とするのが一般的なようです。
</p>
<p> 変換関数はシングルトンオブジェクトに定義しておいて、使用するときにそれを import します。次のリストを見てください。
</p>
<pre class="list">
リスト : 変換関数の定義

object RatConversion {
  implicit def byteToRat(x: Byte): Rat = Rat(x, 1)
  implicit def shortToRat(x: Short): Rat = Rat(x, 1)
  implicit def intToRat(x: Int): Rat = Rat(x, 1)
  implicit def longToRat(x: Long): Rat = Rat(x, 1)
  implicit def bigIntToRat(x: BigInt): Rat = Rat(x, 1)
}
</pre>
<p> 変換関数は簡単ですね。有理数 Rat(x, 1) を生成して返すだけです。あとは、有理数を使用するファイルで RatConversion をインポートします。具体的には、次のように宣言します。
</p>
<pre class="item">
import RatConversion._ 
</pre>
<p> たとえば、Int を Rat に変換する場合、intToRat が必要になりますが、このとき intToRat が RatConversion の中に入ったままだと、暗黙の型変換で intToRat を見つけることができません。つまり、変換関数は RatConversion.intToRat ではなく intToRat で参照できるようにしておかないと、暗黙の型変換は機能しないのです。
</p>
<p> 実は、もうひとつ簡単な方法があります。それはコンパニオンオブジェクトに変換関数を定義することです。次のリストを見てください。
</p>

<pre class="list">
リスト : 変換関数の定義

object Rat {
  //
  // ・・・省略・・・
  //
  implicit def byteToRat(x: Byte): Rat = Rat(x, 1)
  implicit def shortToRat(x: Short): Rat = Rat(x, 1)
  implicit def intToRat(x: Int): Rat = Rat(x, 1)
  implicit def longToRat(x: Long): Rat = Rat(x, 1)
  implicit def bigIntToRat(x: BigInt): Rat = Rat(x, 1)
}
</pre>
<p> クラス Rat にはコンパニオンオブジェクトがあるので、そこに変換関数を定義するだけです。今回はこの方法を使うことにします。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
C&gt;scalac Rat.scala
warning: there were 5 feature warning(s); re-run with -feature for details
one warning found
</pre>
<pre>
scala&gt; import rational._
import rational._

scala&gt; val a = Rat(1, 2)
a: rational.Rat = 1/2

scala&gt; val b = 10
b: Int = 10

scala&gt; val c: BigInt = 20
c: BigInt = 20

scala&gt; b + a
res0: rational.Rat = 21/2

scala&gt; c + a
res1: rational.Rat = 41/2

scala&gt; b * a
res2: rational.Rat = 5

scala&gt; c * a
res3: rational.Rat = 10
</pre>
<p> Scala ver 2.11 の場合、暗黙の型変換を使うと warning がでるようです。これは次に示す import 文をファイルに書くと抑制することができます。
</p>
<pre class="item">
import scala.language.implicitConversions
</pre>
<p> warning を表示するということは、暗黙の型変換は使用に注意が必要な機能なのでしょう。暗黙の型変換は、ちょっと危険で難しい話のようなので、今回はここまでにしておきます。もっと勉強してから再度取り上げることにします。
</p>

<h4>●比較演算子の定義</h4>
<p> 次は比較演算子を定義します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 比較演算子の定義

class Rat private (val n: BigInt, val d: BigInt) {
  //
  // ・・・省略・・・
  //
  override def equals(other: Any): Boolean =
    other match {
      case that: Rat =&gt; that.n == n &amp;&amp; that.d == d
      case _ =&gt; false
    }

  private def compare(that: Rat): Int = (this - that).n.signum
  def &lt; (that: Rat): Boolean = compare(that) &lt;  0
  def &lt;=(that: Rat): Boolean = compare(that) &lt;= 0
  def &gt; (that: Rat): Boolean = compare(that) &gt;  0
  def &gt;=(that: Rat): Boolean = compare(that) &gt;= 0
}
</pre>
<p> 等値の判定はメソッド equals をオーバーライドするだけです。大小関係の比較はメソッド compare を呼び出します。これは左辺の値から右辺の値を引き算して、その符号を返します。あとは、各メソッドで compare の返り値と 0 を比較するだけです。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
scala&gt; import rational._
import rational._

scala&gt; val a = Rat(1, 2)
a: rational.Rat = 1/2

scala&gt; val b = Rat(1, 3)
b: rational.Rat = 1/3

scala&gt; a == Rat(1, 2)
res0: Boolean = true

scala&gt; a == b
res1: Boolean = false

scala&gt; a != b
res2: Boolean = true

scala&gt; a &lt; b
res3: Boolean = false

scala&gt; b &lt; a
res4: Boolean = true

scala&gt; a + a &gt;= Rat(1, 1)
res5: Boolean = true

scala&gt; a + a &lt;= Rat(1, 1)
res6: Boolean = true

scala&gt; a + a &gt;= Rat(2, 1)
res7: Boolean = false

scala&gt; a + a &lt;= Rat(1, 4)
res8: Boolean = false
</pre>
<h4>●その他のメソッド</h4>
<p> 最後にちょっと便利なメソッドを定義しておきます。
</p>

<pre class="list">
リスト : その他のメソッド

class Rat private (val n: BigInt, val d: BigInt) {
  //
  // ・・・省略・・・
  //
  def abs(): Rat = if (n &gt;= 0) this else Rat(-n, d)
  def inv(): Rat = Rat(d, n)
  def signum(): Int = n.signum
  def isInteger(): Boolean = d == 1
  def toInteger(): BigInt = n / d
}
</pre>
<p> メソッド abs は有理数の絶対値を求めます。inv は有理数の逆数を求めます。これは分子と分母を逆にするだけです。signum は符号を求めます。isInteger は有理数が整数ならば真を返します。これは分母 d が 1 かチェックするだけです。toInteger は有理数を整数に変換します。単純に割り算するだけです。
</p>

<h4>●小町分数</h4>
<p> それではクラス Rat を使ってパズルをといてみましょう。なお、ここで紹介するパズルは、拙作のページ <a href="../clisp/clisp07.html#yori03">お気楽 CLOS プログラミング入門：ちょっと寄り道</a> で取り上げたものです。内容は重複しますが、ご了承くださいませ。
</p>

<p> それでは問題です。
</p>
<div class="contents">
<b>[問題] 小町分数</b>
<p> 下図の A から I の場所に 1 から 9 までの数字をひとつずつ配置します。3 つの分数を足すと 1 / N になる配置を求めてください。
</p>
<pre class="fig">
  Ａ      Ｄ      Ｇ      １
 ---- ＋ ---- ＋ ---- ＝ ----
 ＢＣ    ＥＦ    ＨＩ     Ｎ

例： 3/27 + 6/54 + 9/81 = 1/3
     3/54 + 6/72 + 9/81 = 1/4

      図 : 小町分数
</pre>
<p> このパズルの元ネタは N = 1 の場合で、<a href="scala12.html#cite_1">参考文献 [1]</a> に掲載されています。ちなみに、3 つの分数の和が整数になる場合、その値は 1 しかありません。
</p>
</div>
<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 小町分数の解法

import rational._

object komachiRat {
  def komachi() {
    val iter = Range(1, 10).toList.permutations
    while (iter.hasNext) {
      // a/bc + d/ef + g/hi = N
      val xs = iter.next
      val x = Rat(xs(0), xs(1) * 10 + xs(2))
      val y = Rat(xs(3), xs(4) * 10 + xs(5))
      val z = Rat(xs(6), xs(7) * 10 + xs(8))
      val r = x + y + z
      if (xs(0) &lt; xs(3) &amp;&amp; xs(3) &lt; xs(6) &amp;&amp; r.inv.isInteger) {
        print(xs(0) + "/" + xs(1) + xs(2) + " + ")
        print(xs(3) + "/" + xs(4) + xs(5) + " + ")
        print(xs(6) + "/" + xs(7) + xs(8) + " = ")
        println(r)
      }
    }
  }

  def main(args: Array[String]) {
    komachi
  }
}
</pre>

<p> 1 から 9 までの数字の順列を生成して、条件を満たしているかチェックするだけです。今回は Scala の permutations をそのまま呼び出して、9! 通りの順列を生成しています。次に、3 つの分数を計算して変数 x, y, z にセットし、x + y + z の結果を変数 r にセットします。
</p>
<p> 次の if 式で条件を満たしているかチェックします。重複解を取り除くため、分子の数字を A &lt; D &lt; G に限定しています。順列の生成でこの処理を入れると枝刈りの効果で実行速度はもう少し速くなります。結果 r の逆数が整数であれば、条件を満たしているので print で式を表示します。
</p>

<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;scalac komachiRat.scala

C&gt;scala komachiRat
1/24 + 3/56 + 7/98 = 1/6
1/26 + 5/39 + 7/84 = 1/4
1/32 + 5/96 + 7/84 = 1/6
1/38 + 2/95 + 4/76 = 1/10
1/48 + 5/32 + 7/96 = 1/4
1/56 + 3/72 + 9/84 = 1/6
1/96 + 5/32 + 7/84 = 1/4
1/96 + 5/48 + 7/32 = 1/3
2/18 + 5/63 + 7/49 = 1/3
2/19 + 4/57 + 6/38 = 1/3
3/27 + 6/54 + 9/81 = 1/3
3/48 + 5/16 + 9/72 = 1/2
3/54 + 6/72 + 9/81 = 1/4
5/34 + 7/68 + 9/12 = 1
</pre>
<p> 結果は全部で 14 通りになりました。
</p>

<div class="note">
-- 参考文献 ------<br>
<a name="cite_1">[1]</a> 芦ヶ原伸之,『超々難問数理パズル 解けるものなら解いてごらん』, 講談社, 2002
</div>
<h4>●Four Four's</h4>
<p> Rat を使ってもう一つパズルを解いてみましょう。Four Four's は数字を使ったパズルです。いろいろなルールがあるのですが、今回は簡易ルールで行きましょう。なお、このドキュメントは拙作のページ <a href="../puzzle/index.html"> Puzzle DE Programming</a> <a href="../puzzle/four.html">Four Four's</a> のプログラムを Scala で書き直したものです。内容は重複しますが、あしからずご了承くださいませ。
</p>
<p> それでは問題です。
</p>
<pre class="item">
<b>[問題] Four Four's</b>
数字 4 を 4 つと +, - *, /, () を使って、答えが 1 から 10 になる式を作りなさい。
数字は 4 だけではなく、44 や 444 のように合体させてもよい。
また、- を符号として使うことは禁止する。
</pre>
<p> 数字の 4 を 4 つ使うので Four Four's という名前なのだと思います。ところで、このルールでは 11 になる式を作ることができません。ほかのルール、たとえば小数点を付け加えると、次のように作ることができます。
</p>
<pre class="item">
4 / .4 + 4 / 4 = 11
</pre>
<p> 今回は簡易ルールということで、小数点を使わないで 1 から 10 までの式を作ってください。まずは、ご自分の頭を使って解いてみましょう。気分転換や息抜きのときにでも考えてみてください。
</p>

<h4>●数式のパターン</h4>
<p> それではプログラムを作りましょう。基本的には、数式を生成して答えをチェックするだけです。Four Four's の場合、4 つの数値に 3 つの演算子しかありませんから、数式のパターンは簡単に求めることができます。数式を二分木で表すと、次に示す 5 つのパターンになります。
</p>

<pre class="fig">
          Ｘ                Ｘ                          Ｘ
        ／  ＼            ／  ＼                      ／  ＼
      ／      ＼        ４      Ｙ                  Ｙ      ４  
    Ｙ          Ｚ            ／  ＼              ／  ＼
  ／  ＼      ／  ＼        ４      Ｚ          Ｚ      ４
４     ４   ４      ４            ／  ＼      ／  ＼
                                ４      ４  ４      ４
        （１）             （２）                    （３）

    Ｘ                   Ｘ
  ／  ＼               ／  ＼
４      Ｙ           Ｙ      ４
      ／  ＼       ／  ＼
    Ｚ      ４   ４      Ｚ
  ／  ＼               ／  ＼
４      ４           ４      ４
  （４）               （５）

              図 : 数式のパターン (二分木)
</pre>
<p> X, Y, Z が演算子を表します。これを式で表すと、次のようになります。
</p>
<pre class="item">
(1) (4 Y 4) X (4 Z 4)
(2) 4 X (4 Y (4 Z 4))
(3) ((4 Z 4) Y 4) X 4
(4) 4 X ((4 Z 4) Y 4)
(5) (4 Y (4 Z 4)) X 4
</pre>
<p> あとは、X, Y, Z に演算子 +, -, *, / を入れて数式を計算すればいいわけです。
</p>
<p> Four Four's は数字を合体できるので、数字が 3 つで演算子が 2 つ、数字が 2 つで演算子がひとつ、というパターンもあります。演算子がひとつの場合は簡単ですね。演算子が 2 つの場合は、次の式になります。
</p>
<pre class="item">
(A) (a Y b) X c
(B) a X (b Y c)
</pre>
<p> a, b, c が数字で X, Y が演算子を表しています。数字は 4 か 44 になります。この場合、a, b, c の組み合わせを生成する必要があります。組み合わせを (a, b, c) で表すと、(4, 4, 44), (4, 44, 4), (44, 4, 4) の 3 通りとなります。これと演算子の組み合わせにより数式を生成して、答えを求めてチェックします。
</p>
<p> 最後に演算子がひとつの場合をチェックします。これは (4 op 444), (44 op 44), (444 op 4) の 3 通りをチェックするだけです。
</p>

<h4>●クラスの定義</h4>
<p> それではプログラムを作りましょう。最初に数式を表す二分木を定義します。
</p>
<pre class="list">
リスト : 数式の定義

// 数式 (抽象クラス)
abstract class Expr {
  def eval(): Rat
  def printExpr(): Unit
}

// 節
case class Node(op: String, left: Expr, right: Expr) extends Expr {
  def eval(): Rat = op match {
    case "+" =&gt; left.eval + right.eval
    case "-" =&gt; left.eval - right.eval
    case "*" =&gt; left.eval * right.eval
    case "/" =&gt; left.eval / right.eval
  }

  def printExpr() {
    print("(")
    left.printExpr
    print(" " + op + " ")
    right.printExpr
    print(")")
  }
}

// 葉
case class Leaf(n: Rat) extends Expr {
  def eval(): Rat = n
  def printExpr(): Unit = print(n)
}
</pre>
<p> Expr は数式を表す二分木です。数式の場合、数値は葉 (Leaf) に格納され、演算子は節 (Node) に格納されます。値を正確に計算するため、数値には Rat を使います。メソッド eval は式を計算し、printExpr は式を表示します。
</p>

<p> 節 Node は演算子 op と、左右の式を格納します。eval は簡単で、right.eval, left.eval で左右の式を計算し、それを op に対応する演算子で計算するだけです。printExpr は "(右辺 演算子 左辺)" を表示します。右辺と左辺は printExpr を再帰呼び出しするだけです。
</p>

<p> 葉 Leaf は数値を格納します。メソッド eval は簡単で、格納している数値 n を返すだけです。printExpr は n を表示するだけです。
</p>

<h4>●数式の生成</h4>
<p> 次は数式を生成する処理を作ります。
</p>
<pre class="list">
リスト : 数式の生成

  def makeExpr4(op1: String, op2: String, op3: String): List[Expr] = {
    val four = Leaf(4)
    List(Node(op1, Node(op2, four, four), Node(op3, four, four)),
         Node(op1, four, Node(op2, four, Node(op3, four, four))),
         Node(op1, Node(op2, Node(op3, four, four), four), four),
         Node(op1, four, Node(op2, Node(op3, four, four), four)),
         Node(op1, Node(op2, four, Node(op3, four, four)), four))
  }

  def calc(e: Expr) {
    val r: Rat = try { e.eval } catch { case e:ArithmeticException =&gt; 0 }
    if (r.isInteger &amp;&amp; 0 &lt; r &amp;&amp; r &lt;= 10) {
      e.printExpr
      println(" = " + r)
    }
  }

  def fourfours() {
    val ops = List("+", "-", "*", "/")
    for (op1 &lt;- ops; op2 &lt;- ops; op3 &lt;- ops) {
      for (e &lt;- makeExpr4(op1, op2, op3)) calc(e)
    }
    for (op1 &lt;- ops; op2 &lt;- ops) {
      for (e &lt;- makeExpr3(op1, op2)) calc(e)
    }
    for (op1 &lt;- ops) {
      for (e &lt;- makeExpr2(op1)) calc(e)
    }
  }
</pre>

<p> 演算子の組み合わせは関数 fourfours の for ループで生成しています。それを関数 makeExpr4, makeExpr3, makeExpr2 に渡します。たとえば、makeExpr4 は 5 通りの数式をリストに格納して返すので、それを for ループ で一つずつ取り出して関数 calc に渡して計算します。
</p>

<p> 式の計算で 0 除算の例外が送出されるので、それを try の catch で捕捉します。そして、計算結果が整数で、その値が 1 から 10 の範囲であれば、PrintExpr で式を表示します。
</p>
<p> あとは特に難しいところはないでしょう。詳細は <a href="scala12.html#list2">プログラムリスト２</a> を参照してください。
</p>

<h4>●実行結果</h4>
<p> さっそく実行してみたところ、全部で 100 通りの式が出力されました。このプログラムは重複解のチェックを行っていないので、多数の式が出力されることに注意してください。実行結果の一部を示します。
</p>
<pre class="item">
((4 - 4) + (4 / 4)) = 1
((4 / 4) + (4 / 4)) = 2
(((4 + 4) + 4) / 4) = 3
(4 + (4 * (4 - 4))) = 4
(((4 * 4) + 4) / 4) = 5
(((4 + 4) / 4) + 4) = 6
(4 + (4 - (4 / 4))) = 7
((4 + 4) + (4 - 4)) = 8
((4 + 4) + (4 / 4)) = 9
((44 - 4) / 4) = 10
</pre>

<p> この中で、10 になる式は (44 - 4) / 4 しかありません。数字 4 を 4 つと +, -, *, / () だけでは、10 になる式を作ることはできないことがわかります。
</p>
<p> また、このプログラムはカッコをはずす処理を行っていないので、数式はちょっとわかりづらいですね。興味のある方は演算子の優先順位を考慮してカッコをはずすプログラムにも挑戦してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
//
// Rat.scala : Rational number
//
//             Copyright (C) 2014 Makoto Hiroi
//
package rational

import scala.language.implicitConversions

class Rat private (val n: BigInt, val d: BigInt) {
  def +(that: Rat): Rat = Rat(n * that.d + that.n * d, d * that.d)
  def +(x: BigInt): Rat = Rat(n + x * d, d)

  def -(that: Rat): Rat = Rat(n * that.d - that.n * d, d * that.d)
  def -(x: BigInt): Rat = Rat(n - x * d, d)

  def *(that: Rat): Rat = Rat(n * that.n, d * that.d)
  def *(x: BigInt): Rat = Rat(n * x, d)

  def /(that: Rat): Rat = Rat(n * that.d, d * that.n)
  def /(x: BigInt): Rat = Rat(n, d * x)

  override def toString: String =
    if (d == 1) n.toString else n + "/" + d

  override def equals(other: Any): Boolean =
    other match {
      case that: Rat =&gt; that.n == n &amp;&amp; that.d == d
      case _ =&gt; false
    }

  private def compare(that: Rat): Int = (this - that).n.signum
  def &lt; (that: Rat): Boolean = compare(that) &lt;  0
  def &lt;=(that: Rat): Boolean = compare(that) &lt;= 0
  def &gt; (that: Rat): Boolean = compare(that) &gt;  0
  def &gt;=(that: Rat): Boolean = compare(that) &gt;= 0

  def abs(): Rat = if (n &gt;= 0) this else Rat(-n, d)
  def inv(): Rat = Rat(d, n)
  def signum(): Int = n.signum
  def isInteger(): Boolean = d == 1
  def toInteger(): BigInt = n / d
}

object Rat {
  def apply(a: BigInt, b: BigInt): Rat = {
    if (b == 0) throw new ArithmeticException
    val g = a gcd b
    val n = a * b.signum / g
    val d = b * b.signum / g
    new Rat(n, d)
  }

  implicit def byteToRat(x: Byte): Rat = Rat(x, 1)
  implicit def shortToRat(x: Short): Rat = Rat(x, 1)
  implicit def intToRat(x: Int): Rat = Rat(x, 1)
  implicit def longToRat(x: Long): Rat = Rat(x, 1)
  implicit def bigIntToRat(x: BigInt): Rat = Rat(x, 1)
}
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
//
// FourFours.scala : Four Four's
//
//                   Copyright (C) 2014 Makoto Hiroi
//
import rational._

// 式 (抽象クラス)
abstract class Expr {
  def eval(): Rat          // 式の評価
  def printExpr(): Unit    // 式の表示
}

// 節
case class Node(op: String, left: Expr, right: Expr) extends Expr {
  def eval(): Rat = op match {
    case "+" =&gt; left.eval + right.eval
    case "-" =&gt; left.eval - right.eval
    case "*" =&gt; left.eval * right.eval
    case "/" =&gt; left.eval / right.eval
  }

  def printExpr() {
    print("(")
    left.printExpr
    print(" " + op + " ")
    right.printExpr
    print(")")
  }
}

// 葉
case class Leaf(n: Rat) extends Expr {
  def eval(): Rat = n
  def printExpr(): Unit = print(n)
}

object FourFours {
  // 数式の生成
  def makeExpr4(op1: String, op2: String, op3: String): List[Expr] = {
    val four = Leaf(4)
    List(Node(op1, Node(op2, four, four), Node(op3, four, four)),
         Node(op1, four, Node(op2, four, Node(op3, four, four))),
         Node(op1, Node(op2, Node(op3, four, four), four), four),
         Node(op1, four, Node(op2, Node(op3, four, four), four)),
         Node(op1, Node(op2, four, Node(op3, four, four)), four))
  }

  def makeExpr3(op1: String, op2: String): List[Expr] = {
    val a = Leaf(4)
    val b = Leaf(44)
    List(Node(op1, Node(op2, a, a), b),
         Node(op1, a, Node(op2, a, b)),
         Node(op1, Node(op2, a, b), a),
         Node(op1, a, Node(op2, b, a)),
         Node(op1, Node(op2, b, a), a),
         Node(op1, b, Node(op2, a, a)))
  }

  def makeExpr2(op1: String): List[Expr] = {
    val a = Leaf(4)
    val b = Leaf(44)
    val c = Leaf(444)
    List(Node(op1, a, c), Node(op1, c, a), Node(op1, b, b))
  }

  // 式を計算する
  def calc(e: Expr) {
    val r: Rat = try { e.eval } catch { case e: ArithmeticException =&gt; 0 }
    if (r.isInteger &amp;&amp; 0 &lt; r &amp;&amp; r &lt;= 10) {
      e.printExpr
      println(" = " + r)
    }
  }

  def fourfours() {
    val ops = List("+", "-", "*", "/")
    for (op1 &lt;- ops; op2 &lt;- ops; op3 &lt;- ops) {
      for (e &lt;- makeExpr4(op1, op2, op3)) calc(e)
    }
    for (op1 &lt;- ops; op2 &lt;- ops) {
      for (e &lt;- makeExpr3(op1, op2)) calc(e)
    }
    for (op1 &lt;- ops) {
      for (e &lt;- makeExpr2(op1)) calc(e)
    }
  }

  def main(args: Array[String]) {
    fourfours
  }
}
</pre>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala11.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala13.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>