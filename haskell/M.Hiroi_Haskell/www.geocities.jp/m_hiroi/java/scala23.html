<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881778</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala22.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala24.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>継続渡しスタイル</h3>
<p> 今回は「継続渡しスタイル (Continuation Passing Style : CPS) 」という手法について説明します。Scheme には「継続」という他の言語 <sup><a href="scala23.html#note1">[*1]</a></sup> にはない強力な機能がありますが、使いこなすのはちょっと難しいといわれています。継続渡しスタイルはクロージャを使った汎用的な方法で、クロージャがあるプログラミング言語であれば、継続渡しスタイルでプログラムを作成することができます。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 実は Ruby にも「継続」があります。また、標準的な機能ではありませんが、SML/NJ や OCaml でも拡張機能を使って「継続」を取り扱うことができます。
</div>
<h4>●継続とは？</h4>
<p> 最初に継続について簡単に説明します。継続は「次に行われる計算」のことです。たとえば、次のプログラムを例に考えてみましょう。
</p>

<pre>
scala&gt; def foo(): Unit = println("foo")
foo: ()Unit

scala&gt; def bar(): Unit = println("bar")
bar: ()Unit

scala&gt; def baz(): Unit = println("baz")
baz: ()Unit

scala&gt; def test(): Unit = {foo(); bar(); baz()}
test: ()Unit

scala&gt; test
foo
bar
baz
</pre>

<p> 関数 test は関数 foo, bar, baz を順番に呼び出します。foo の次に実行される処理は bar, baz の関数呼び出しです。この処理が foo を呼び出したあとの「継続」になります。同様に、bar のあとに実行されるのは baz の呼び出しで、この処理がこの時点での「継続」になります。また、baz を呼び出したあと、test の中では次に実行する処理はありませんが、test は関数呼び出しされているので、関数呼び出しから元に戻る処理が baz を呼び出したあとの「継続」になります。
</p>

<p> このように、あるプログラムを実行しているとき、そのプログラムを終了するまでには「次に実行する処理 (計算) 」が必ず存在します。一般に、この処理 (計算) のことを「継続」といいます。Scheme の場合、次の計算を続行するための情報を取り出して、それを保存することができます。Scheme では、この保存した情報を「継続」といって、通常のデータ型と同様に取り扱うことができます。つまり、継続を変数に代入したり関数の引数に渡すことができるのです。継続を使うとプログラムの実行を途中で中断し、あとからそこに戻ってプログラムの実行を再開することができます。
</p>

<h4>●継続渡しスタイルとは？</h4>
<p> 一般のプログラミング言語では、Scheme のように継続を取り出して保存することはできません。そこで、継続 (次に行う処理) を関数 (クロージャ) で表して、それを引数に渡して実行することにします。これを「継続渡しスタイル (CPS) 」といいます。たとえば、次の例を見てください。
</p>

<pre>
scala&gt; def testCps(cont: () =&gt; Unit): Unit = { foo(); bar(); cont() }
testCps: (cont: () =&gt; Unit)Unit

scala&gt; testCps(baz)
foo
bar
baz

scala&gt; testCps(bar)
foo
bar
bar
</pre>

<p> 関数 testCps は foo, bar を呼び出したあと、引数 cont に渡された処理 (継続) を実行します。関数 baz を渡せば foo, bar, baz と表示されますし、他の処理を渡せばそれを実行することができます。
</p>

<p> もう一つ簡単な例を示しましょう。継続に値を渡して処理を行うこともできます。
</p>
<pre>
scala&gt; def addCps(a: Int, b: Int, cont: Int =&gt; Int): Int = cont(a + b)
addCps: (a: Int, b: Int, cont: Int =&gt; Int)Int

scala&gt; addCps(1, 2, x =&gt; x)
res0: Int = 3

scala&gt; addCps(1, 2, x =&gt; {println(x); x})
3
res1: Int = 3
</pre>

<p> 関数 addCps は引数 a と b を加算して、その結果を継続 cont に渡します。cont に x =&gt; x を渡せば、計算結果を返すことができます。また、cont で println(x) を呼び出せば、計算結果を表示することができます。
</p>
<p> ところで、addCps は次のように多相関数として定義するともっと便利になります。
</p>
<pre>
scala&gt; def addCps1[A](a: Int, b: Int, cont: Int =&gt; A): A = cont(a + b)
addCps1: [A](a: Int, b: Int, cont: Int =&gt; A)A

scala&gt; addCps1(10, 20, x =&gt; x)
res2: Int = 30

scala&gt; addCps1(10, 20, println)
30
</pre>
<p> 継続 cont の返り値を型パラメータ A にします。そうすると、addCps1 には println を直接渡すことができます。
</p>

<h4>●再帰呼び出しと継続渡しスタイル</h4>
<p> CPS を使うと再帰呼び出しを末尾再帰に変換することができます。たとえば、階乗の計算を CPS でプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 階乗の計算 (CPS)

  def factCps[A](n: Int, cont: BigInt =&gt; A): A =
    if (n == 0) cont(1)
    else factCps(n - 1, x =&gt; cont(n * x))
</pre>

<p> 引数 cont が継続を表します。n == 0 のときは、cont に階乗の値 1 を渡します。それ以外の場合は、階乗の計算を継続の処理にまかせて factCps を再帰呼び出します。ここで、factCps の呼び出しは末尾再帰になることに注意してください。
</p>
<p> 継続の処理 x =&gt; cont(n * x) では、継続の引数 x と factCps の引数 n を掛け算して、その結果を cont に渡します。たとえば、factCps(4, x =&gt; x) の呼び出しを図に示すと、次のようになります。
</p>
<pre class="fig">
   fact(4, x =&gt; x)
=&gt;      4 (x1 =&gt; (x =&gt; x) (4 * x1))
=&gt;      3 (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2))
=&gt;      2 (x3 =&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) (2 * x3))
=&gt;      1 (x4 =&gt; (x3 =&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) (2 * x3)) (1 * x4))
=&gt;      0 (x4 =&gt; (x3 =&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) (2 * x3)) (1 * x4)) 1

継続の評価

   (x4 =&gt; (x3 =&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) (2 * x3)) (1 * x4)) 1
=&gt; (x3 =&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) (2 * x3)) 1
=&gt; (x2 =&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) (3 * x2)) 2
=&gt; (x1 =&gt; (x =&gt; x) (4 * x1)) 6
=&gt; (x =&gt; x) 24
=&gt; 24

                    図 1 : fact_cps の実行
</pre>
<p> このように、継続の中で階乗の式が組み立てられていきます。そして、n == 0 のとき継続 cont に引数 1 を渡して評価すると、今までに組み立てられた式が評価されて階乗の値を求めることができます。つまり、n の階乗を求めるとき、継続 x =&gt; cont(n * x) の引数 x には n - 1 の階乗の値が渡されていくわけです。そして、最後に継続 x =&gt; x に n の階乗の値が渡されるので、階乗の値を返すことができます。
</p>

<p> それでは実際に実行してみましょう。
</p>
<pre>
scala&gt; for (i &lt;- 1 to 20) factCps(i, println)
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
2432902008176640000
</pre>

<h4>●二重再帰と継続渡しスタイル</h4>
<p> 次はフィボナッチ数列を求める関数を CPS で作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : フィボナッチ関数

  // 二重再帰
  def fibo(n: Int): BigInt =
    if (n == 0 || n == 1) 1
    else fibo(n - 1) + fibo(n - 2)

  // CPS
  def fiboCps[A](n: Int, cont: BigInt =&gt; A): A =
    if (n == 0 || n == 1) cont(1)
    else fiboCps(n - 1, x =&gt; fiboCps(n - 2, y =&gt; cont(x + y)))
</pre>
<p> 関数 fiboCps は、引数 n が 0 または 1 のとき cont 1 を評価します。それ以外の場合は fiboCps を再帰呼び出しします。fiboCps(n - 1) が求まると、その値は継続の引数 x に渡されます。継続の中で、今度は fiboCps(n - 2) の値を求めます。すると、その値は fiboCps (n - 2) の継続の引数 y に渡されます。したがって、fiboCps(n) の値は x + y で求めることができます。この値を fiboCps(n) の継続 cont に渡せばいいわけです。
</p>

<p> fiboCps の実行を図に示すと、次のようになります。
</p>
<pre class="fig">
f(5) ┬ f(4) ┬ f(3) ┬ f(2) ┬ f(1)
     │      │      │      │
    cont    cont    cont    cont
     │      │      │      └ f(0)
     │      │      └ f(1)
     │      └ f(2) ┬ f(1)
     │              │
     │             cont
     │              └ f(0)
     │
     └ f(3) ┬ f(2) ┬ f(1)
             │      │
            cont    cont
             │      └ f(0)
             └ f(1)

    図 : fibo_cps の実行
</pre>
<p> cont は継続を表します。fiboCps は末尾再帰になっているので、n - 1 の値を求めるために左から右へ処理が進みます。このとき、n - 2 の値を求める継続 cont が生成されていくことに注意してください。そして、f(1) の実行が終了すると継続が評価され、n - 2 の値が求められます。すると、2 番目の継続が評価されて n - 1 の値 x と n - 2 の値 y を加算して、その値を継続 cont に渡します。こうして、次々と継続が評価されてフィボナッチ関数の値を求めることができます。
</p>

<p> それでは実際に実行してみましょう。
</p>
<pre>
scala&gt; for (i &lt;- 1 to 15) fiboCps(i, println)
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
</pre>
<p> 正常に動作していますね。ところが、fiboCps(16, println) を実行するとエラーになってしまいました。Scala には末尾再帰最適化が行われているかチェックするアノテーション @tailrec が用意されています。@tailrec を使う場合、scala.annotation.tailrec をインポートしてください。
</p>
<pre class="list">
リスト : 末尾再帰最適化のチェック

  @tailrec
  def fiboCps[A](n: Int, cont: BigInt =&gt; A): A =
    if (n == 0 || n == 1) cont(1)
    else fiboCps(n - 1, x =&gt; fiboCps(n - 2, y =&gt; cont(x + y)))
</pre>
<p> 末尾再帰最適化が行われない場合、コンパイルエラーになります。
</p>
<pre>
scala> :load sample23.scala
Loading sample23.scala...
import scala.annotation.tailrec
&lt;console&gt;:21: error: could not optimize @tailrec annotated method fiboCps: it
contains a recursive call not in tail position
           else fiboCps(n - 1, x =&gt; fiboCps(n - 2, y =&gt; cont(x + y)))
                                           ^
</pre>
<p> 他の関数型言語 (Scheme, SML/NJ, OCaml など) では末尾再帰最適化されるのですが、Scala では最適化されないようです。Scala と CPS の相性はあまりよくないのかもしれません。
</p>

<p> なお、fiboCps は末尾再帰最適化されたとしても、関数の呼び出し回数は二重再帰の場合と同じです。したがって、実行速度は二重再帰の場合とほとんどかわりません。また、二重再帰の場合は関数呼び出しによりスタックが消費されますが、CPS の場合はクロージャが生成されるのでメモリ (ヒープ領域) が消費されます。このように、再帰呼び出しを CPS に変換したからといって、効率の良いプログラムになるとは限りません。ご注意くださいませ。
</p>

<h4>●CPS の便利な使い方</h4>
<p> 階乗やフィボナッチ関数の場合、CPS に変換するメリットはほとんどありませんが、場合によっては CPS に変換した方が簡単にプログラムできることもあります。たとえば、リストを平坦化する関数 flatten で、リストの要素に空リストが含まれていたら空リストを返すようにプログラムを修正することを考えてみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : リストの平坦化 (間違い)

  def flatten[A](xs: List[List[A]]): List[A] =
    xs match {
      case Nil =&gt; Nil
      case x::_ if (x == Nil) =&gt; Nil
      case x::xs =&gt; x ::: flatten(xs)
    }
</pre>
<p> 関数 flatten は空リストを見つけたら空リストを返していますが、これでは正常に動作しません。実際に試してみると次のようになります。
</p>
<pre>
scala&gt; flatten(List(List(1,2), List(3,4), List(5,6)))
res0: List[Int] = List(1, 2, 3, 4, 5, 6)

scala&gt; flatten(List(List(1,2), List(3,4), Nil, List(5,6)))
res1: List[Int] = List(1, 2, 3, 4)
</pre>
<p> 2 番目の例が空リストを含む場合です。この場合、空リストを返したいのですが、その前の要素を連結したリストを返しています。空リストを見つける前にリストの連結処理を行っているので、空リストを見つけたらその処理を廃棄しないといけないのです。
</p>

<p> このような場合、CPS を使うと簡単です。次のリストを見てください。
</p>

<pre class="list">
リスト : リストの平坦化 (CPS)

  def flattenCps[A](xs: List[List[A]], cont: List[A] =&gt; List[A]): List[A] =
    xs match {
      case Nil =&gt; cont(Nil)
      case x::_ if (x == Nil) =&gt; Nil
      case x::xs1 =&gt; flattenCps(xs1, (y: List[A]) =&gt; cont(x ::: y))
    }
</pre>

<p> flatten を CPS に変換するのは簡単です。リストの先頭の要素 x と平坦化したリストの連結を継続で行うだけです。平坦化したリストは継続の引数 y に渡されるので、x @ y でリストを連結して、それを継続 cont に渡せばいいわけです。
</p>
<p> 引数のリストが空リストになったら継続 cont に空リストを渡して評価します。これで、リストの連結処理が行われます。もしも、途中で空リストを見つけた場合は、空リストをそのまま返します。この場合、継続 cont は評価されないので、リストの連結処理は行われず、空リストをそのまま返すことができます。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; flattenCps(List(List(1,2), List(3,4), List(5,6)), (x: List[Int]) =&gt; x)
res0: List[Int] = List(1, 2, 3, 4, 5, 6)

scala&gt; flattenCps(List(List(1,2), List(3,4), Nil, List(5,6)), (x: List[Int]) =&gt; x)
res1: List[Int] = List()
</pre>
<p> 正常に動作していますね。
</p>

<h4>●二分木の巡回を CPS で実装</h4>
<p> 次は二分木を巡回するプログラムを CPS で作ってみましょう。二分木の詳しい説明は拙作のページ <a href="scala15.html">多相クラス (3)</a>「不変 (immutable) で多相的な二分木」をお読みください。
</p>

<pre class="list">
リスト : 二分木の巡回

  // 抽象クラス
  abstract class Tree[+A] {
    def left: Tree[A]
    def right: Tree[A]
    def item: A
    def isEmpty: Boolean

    // 巡回
    def foreach(f: A =&gt; Unit): Unit = {
      if (!isEmpty) {
        left.foreach(f)
        f(item)
        right.foreach(f)
      }
    }
  }

  // 節
  case class Node[A](item: A, left: Tree[A], right: Tree[A]) extends Tree[A] {
    def isEmpty: Boolean = false
  }

  // 終端 (空の木)
  case object Nils extends Tree[Nothing] {
    def item  = throw new Exception("Nils: item is not member")
    def left  = throw new Exception("Nils: left is not member")
    def right = throw new Exception("Nils: right is not member")
    def isEmpty: Boolean = true
  }
</pre>
<p> メソッド foreach は二重再帰になっています。そこで、f(item) の評価と右部分木の巡回は継続で行うことにします。プログラムは次のようになります。
</p>

<pre class="list">
リスト : 二分木の巡回 (CPS)

    def foreachCps(f: A =&gt; Unit)(cont: () =&gt; Unit) {
      if (isEmpty) cont()
      else left.foreachCps(f)(() =&gt; {f(item); right.foreachCps(f)(() =&gt; cont())})
    }
</pre>
<p> foreachCpsは副作用が目的なので、継続に値を渡す必要はありません。そこで、cont には Unit を渡すことにします。左部分木をたどったら継続 cont を呼び出します。その中で f(item) を評価し、そのあと右部分木をたどります。このときの継続は cont() を評価するだけです。これで生成された継続を呼び出して、木を巡回することができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
scala&gt; val a: Tree[Int] = Node(4, Node(2, Node(1, Nils, Nils), Node(3, Nils, Nils)), 
Node(6, Node(5, Nils, Nils), Node(7, Nils, Nils)))
a: sample23.Tree[Int] = Node(4,Node(2,Node(1,Nils,Nils),Node(3,Nils,Nils)),
Node(6,Node(5,Nils,Nils),Node(7,Nils,Nils)))

scala&gt; a.foreachCps(println)(() =&gt; Unit)
1
2
3
4
5
6
7
</pre>
<p> このように、foreachCps で二分木を通りがけ順で巡回することができます。
</p>
<h4>●二分木と遅延ストリーム</h4>
<p> 二分木の巡回を CPS に変換すると、遅延ストリームに対応するのも簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 二分木の巡回 (遅延ストリーム版)

    def streamOfTree[B &gt;: A](cont: () =&gt; Stream[B]): Stream[B] = 
      if (isEmpty) cont()
      else left.streamOfTree(() =&gt; item #:: right.streamOfTree(() =&gt; cont()))
</pre>

<p> streamOfTree は二分木を巡回してその要素を順番に出力する遅延ストリームを生成します。foreachCps は継続の中で関数 f を呼び出しましたが、streamOfTree は継続の中で遅延ストリーム Stream を返します。そして、演算子 #:: の右辺で右部分木をたどり、その継続の中で cont() を呼び出します。
</p>
<p> ここで継続 cont の型は () =&gt; Stream[B] になることに注意してください。streamOfTree を呼び出すときに渡す継続が一番最後に呼び出されるので、遅延ストリームの終端 Strem.empty を返すように定義してください。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
scala&gt; val a: Tree[Int] = Node(4, Node(2, Node(1, Nils, Nils), Node(3, Nils, Nils)), 
Node(6, Node(5, Nils, Nils), Node(7, Nils, Nils)))
a: sample23.Tree[Int] = Node(4,Node(2,Node(1,Nils,Nils),Node(3,Nils,Nils)),
Node(6,Node(5,Nils,Nils),Node(7,Nils,Nils)))

scala&gt; val s = a.streamOfTree(() =&gt; Stream.empty)
s: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala&gt; s.head
res1: Int = 1

scala&gt; s.tail.head
res2: Int = 2

scala&gt; s.tail.tail.head
res3: Int = 3

scala&gt; s.take(7).toList
res4: List[Int] = List(1, 2, 3, 4, 5, 6, 7)
</pre>

<p> streamOfTree を使うと、2 つの二分木が等しいか判定する述語 isEqual を簡単に作ることができます。二分木の要素がすべて等しい場合、isEqual は true を返し、そうでなければ false を返すことにします。つまり、二分木を集合として扱うわけです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 同値の判定

    def isEqual[B &gt;: A](xs: Tree[B]): Boolean = {
      def iter(s1: Stream[B], s2: Stream[B]): Boolean =
        if (s1.isEmpty &amp;&amp; s2.isEmpty) true
        else if(s1.isEmpty || s2.isEmpty || s1.head != s2.head) false
        else iter(s1.tail, s2.tail)
      //
      iter(this.streamOfTree(() =&gt; Stream.empty),
           xs.streamOfTree(() =&gt; Stream.empty))
    }
</pre>
<p> 実際の処理は局所関数 iter で行います。iter には二分木の遅延ストリームを渡します。あとは、遅延ストリームから要素を一つずつ取り出して、それが等しいかチェックするだけです。
</p>
<p> それでは実行例を示します。
</p>
<pre>
scala&gt; val a: Tree[Int] = Node(4, Node(2, Node(1, Nils, Nils), Node(3, Nils, Nils)), 
Node(6, Node(5, Nils, Nils), Node(7,Nils,Nils)))
a: sample23.Tree[Int] = Node(4,Node(2,Node(1,Nils,Nils),Node(3,Nils,Nils)),
Node(6,Node(5,Nils,Nils),Node(7,Nils,Nils)))

scala&gt; val b = Node(1,Nils,Node(2,Nils, Node(3,Nils, Node(4, Nils, Node(5,Nils,
Node(6, Nils, Node(7, Nils, Nils)))))))
b: sample23.Node[Int] = Node(1,Nils,Node(2,Nils,Node(3,Nils,Node(4,Nils,Node(5,Nils,
Node(6,Nils,Node(7,Nils,Nils)))))))

scala&gt; a.isEqual(b)
res0: Boolean = true

scala&gt; val c = Node(1,Nils,Node(2,Nils, Node(3,Nils, Node(4, Nils, Node(5,Nils,
Node(6, Nils, Node(8, Nils, Nils)))))))
c: sample23.Node[Int] = Node(1,Nils,Node(2,Nils,Node(3,Nils,Node(4,Nils,Node(5,Nils,
Node(6,Nils,Node(8,Nils,Nils)))))))

scala&gt; a.isEqual(c)
res1: Boolean = false
</pre>
<p> 変数 a, b に二分木をセットします。a と b では二分木の形状は異なりますが要素はすべて同じです。したがって、isEqual(a, b) は true を返します。変数 c にセットされた二分木は要素が一つだけ異なっているので、isEqual(a, c) は false を返します。
</p>

<p> 部分集合を判定する関数 isSubSet も簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 部分集合の判定

    def isSubSet[B &gt;: A &lt;% Ordered[B]](xs: Tree[B]): Boolean = {
      def iter(s1: Stream[B], s2: Stream[B]): Boolean =
        if (s1.isEmpty) true
        else if (s2.isEmpty) false
        else if (s1.head == s2.head) iter(s1.tail, s2.tail)
        else if (s1.head &gt; s2.head) iter(s1, s2.tail)
        else false
      //
      iter(this.streamOfTree(() =&gt; Stream.empty),
           xs.streamOfTree(() =&gt; Stream.empty))
    }
</pre>
<p> 実際の処理は局所関数 iter で行います。遅延ストリーム s1 が s2 の途中で終了した場合、s1 の要素はすべて s2 にあるので s1 は s2 の部分集合です。isSubSet は true を返します。s2 が途中で終了した場合、s1 は s2 に含まれていない要素があるので、部分集合ではありません。false を返します。
</p>
<p> そうでなければ、遅延ストリームから要素を一つずつ取り出します。s1.head == s2.head ならば次の要素を調べます。 s1.head &gt; s2.head の場合、x と等しい要素が s2 に存在するかもしれないので、x と s2 の次の要素を比較します。それ以外の場合、s1.head と等しい要素は s2 に存在しないことがわかるので false を返します。
</p>

<p> それでは実行例を示します。
</p>
<pre>
scala&gt; val b: Tree[Int] = Node(3,Node(2,Node(1, Nils, Nils), Nils), Nils)
b: sample23.Tree[Int] = Node(3,Node(2,Node(1,Nils,Nils),Nils),Nils)

scala&gt; b.isSubSet(a)
res0: Boolean = true

scala&gt; val c: Tree[Int] = Node(3,Node(2,Node(0, Nils, Nils), Nils), Nils)
c: sample23.Tree[Int] = Node(3,Node(2,Node(0,Nils,Nils),Nils),Nils)

scala&gt; c.isSubSet(a)
res1: Boolean = false
</pre>
<p> 正常に動作していますね。
</p>

<h4>●TailCalls</h4>
<p> Scala は fiboCps だけではなく、相互再帰の場合も末尾再帰は最適化されません。このような場合、オブジェクト scala.util.control.TailCalls に用意されている関数を使うと、スタックオーバーフローせずにプログラムを実行することができます。TailCalls に用意されている関数を示します。
</p>
<pre class="item">
def done[A](result: A): TailRec[A]
def tailcall[A](rest: =&gt; TailRec[A]): TailRec[A]
</pre>
<p> done は値を返すときに呼び出します。値は TailRec のフィールド変数 result に格納されて返されます。再帰呼び出しするときは tailcall を使います。TailCalls は遅延評価を使って末尾再帰のプログラムをスタックを消費せずに実行します。本当に最適化される (繰り返しに変換される) わけではないので、実行速度は遅くなるかもしれません。ご注意くださいませ。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 相互再帰

  def isEven(n: Int): TailRec[Boolean] =
    if (n == 0) done(true)
    else tailcall(isOdd(n - 1))

  def isOdd(n: Int): TailRec[Boolean] = 
    if (n == 0) done(false)
    else tailcall(isEven(n - 1))
</pre>
<p> isEven と isOdd は相互再帰で偶数と奇数を判定します。Scala の場合、TailCalls を使わないとスタックオーバーフローします。isEven と isOdd の返り値の型は TailRec[Boolean] になります。n == 0 のとき、真偽値を返しますが done で TailRec に格納して返します。そして、再帰呼び出しするときは tailcall を経由して行います。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; isEven(1000).result
res0: Boolean = true

scala&gt; isOdd(10000).result
res1: Boolean = false

scala&gt; isEven(100000).result
res2: Boolean = true

scala&gt; isOdd(999999999).result
res3: Boolean = true
</pre>
<p> このように、大きな値でもスタックオーバーフローせずに実行することができます。
</p>
<p> 次は階乗 (CPS 版) を TailCalls で書き直してみましょう。
</p>
<pre class="list">
リスト : 階乗

  def factCps1(n: Int, cont: TailRec[BigInt] =&gt; TailRec[BigInt]): TailRec[BigInt] =
    if (n == 0) cont(done(1))
    else tailcall(factCps1(n - 1, x =&gt; cont(done(x.result * n))))
</pre>
<p> 継続 cont の型は TailRec[BigInt] =&gt; TailRec[BigInt] になります。そして、cont を呼び出すとき、その引数を done で TailRec に変換して渡します。cont の引数 x は TailRec なので、計算するときは x.result で値を取り出してください。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; factCps1(100, x =&gt; x).result
res4: BigInt = 93326215443944152681699238856266700490715968264381621468592963895
21759999322991560894146397615651828625369792082722375825118521091686400000000000
0000000000000
</pre>
<p> 同様に、フィボナッチ関数 fiboCps を書き直すこと次のようになります。
</p>
<pre class="list">
リスト : フィボナッチ関数

  def fiboCps1(n: Int, cont: TailRec[BigInt] =&gt; TailRec[BigInt]): TailRec[BigInt] =
    if (n == 0 || n == 1) cont(done(1))
    else tailcall(fiboCps1(n - 1, x =&gt; tailcall(fiboCps1(n - 2, y =&gt; cont(done(x.result + y.result))))))
</pre>
<p> 匿名関数の引数 x, y は TailRec なので、x.result と y.result で値を取り出して計算するだけです。
</p>
<p> 実行結果を示します。
</p>
<pre>
scala&gt; fiboCps1(16, x =&gt; x).result
res5: BigInt = 1597

scala&gt; fiboCps1(20, x =&gt; x).result
res6: BigInt = 10946

scala&gt; fiboCps1(30, x =&gt; x).result
res7: BigInt = 1346269
</pre>
<p> スタックオーバーフローせずに値を求めることができました。
</p>
<hr>
<h4>●プログラムリスト</h4>
<pre class="list">
//
// sample23.html : 継続渡しスタイル (CPS) サンプルプログラム
//
//                 Copyright (C) 2014 Makoto Hiroi
//
import scala.collection.immutable.Stream
import scala.util.control.TailCalls._

object sample23 {

  // 階乗
  def factCps[A](n: Int, cont: BigInt =&gt; A): A =
    if (n == 0) cont(1)
    else factCps(n - 1, x =&gt; cont(n * x))

  // フィボナッチ関数
  def fibo(n: Int): BigInt =
    if (n == 0 || n == 1) 1
    else fibo(n - 1) + fibo(n - 2)

  def fiboCps[A](n: Int, cont: BigInt =&gt; A): A =
    if (n == 0 || n == 1) cont(1)
    else fiboCps(n - 1, x =&gt; fiboCps(n - 2, y =&gt; cont(x + y)))

  // リストの平坦化
  def flatten[A](xs: List[List[A]]): List[A] =
    xs match {
      case Nil =&gt; Nil
      case x::_ if (x == Nil) =&gt; Nil
      case x::xs1 =&gt; x ::: flatten(xs1)
    }

  def flattenCps[A](xs: List[List[A]], cont: List[A] =&gt; List[A]): List[A] =
    xs match {
      case Nil =&gt; cont(Nil)
      case x::_ if (x == Nil) =&gt; Nil
      case x::xs1 =&gt; flattenCps(xs1, (y: List[A]) =&gt; cont(x ::: y))
    }

  // 二分木
  abstract class Tree[+A] {
    def left: Tree[A]
    def right: Tree[A]
    def item: A
    def isEmpty: Boolean

    // 巡回
    def foreach(f: A =&gt; Unit): Unit = {
      if (!isEmpty) {
        left.foreach(f)
        f(item)
        right.foreach(f)
      }
    }

    // CPS 版
    def foreachCps(f: A =&gt; Unit)(cont: () =&gt; Unit) {
      if (isEmpty) cont()
      else left.foreachCps(f)(() =&gt; {f(item); right.foreachCps(f)(() =&gt; cont())})
    }

    // 遅延ストリーム版
    def streamOfTree[B &gt;: A](cont: () =&gt; Stream[B]): Stream[B] = 
      if (isEmpty) cont()
      else left.streamOfTree(() =&gt; item #:: right.streamOfTree(() =&gt; cont()))

    // 同値の判定
    def isEqual[B &gt;: A](xs: Tree[B]): Boolean = {
      def iter(s1: Stream[B], s2: Stream[B]): Boolean =
        if (s1.isEmpty &amp;&amp; s2.isEmpty) true
        else if(s1.isEmpty || s2.isEmpty || s1.head != s2.head) false
        else iter(s1.tail, s2.tail)
      //
      iter(this.streamOfTree(() =&gt; Stream.empty),
           xs.streamOfTree(() =&gt; Stream.empty))
    }

    // 部分集合の判定
    def isSubSet[B &gt;: A &lt;% Ordered[B]](xs: Tree[B]): Boolean = {
      def iter(s1: Stream[B], s2: Stream[B]): Boolean =
        if (s1.isEmpty) true
        else if (s2.isEmpty) false
        else if (s1.head == s2.head) iter(s1.tail, s2.tail)
        else if (s1.head &gt; s2.head) iter(s1, s2.tail)
        else false
      //
      iter(this.streamOfTree(() =&gt; Stream.empty),
           xs.streamOfTree(() =&gt; Stream.empty))
    }

  }

  case class Node[A](item: A, left: Tree[A], right: Tree[A]) extends Tree[A] {
    def isEmpty: Boolean = false
  }

  case object Nils extends Tree[Nothing] {
    def item  = throw new Exception("Nils: item is not member")
    def left  = throw new Exception("Nils: left is not member")
    def right = throw new Exception("Nils: right is not member")
    def isEmpty: Boolean = true
  }

  // TailCalls の使用例
  def isEven(n: Int): TailRec[Boolean] =
    if (n == 0) done(true)
    else tailcall(isOdd(n - 1))

  def isOdd(n: Int): TailRec[Boolean] = 
    if (n == 0) done(false)
    else tailcall(isEven(n - 1))

  def factCps1(n: Int, cont: TailRec[BigInt] =&gt; TailRec[BigInt]): TailRec[BigInt] =
    if (n == 0) cont(done(1))
    else tailcall(factCps1(n - 1, x =&gt; cont(done(x.result * n))))

  def fiboCps1(n: Int, cont: TailRec[BigInt] =&gt; TailRec[BigInt]): TailRec[BigInt] =
    if (n == 0 || n == 1) cont(done(1))
    else tailcall(fiboCps1(n - 1, x =&gt; tailcall(fiboCps1(n - 2, y =&gt; cont(done(x.result + y.result))))))
}
</pre>
</section>
<hr>
<section class="contents">
<h4 id="chap02">Appendix: 末尾再帰と繰り返し</h4>
<p> ここで「末尾再帰」についてもう少し深く考えてみましょう。末尾再帰の「末尾」とは、関数の最後で行われる処理のことです。とくに末尾で関数を呼び出すことを「末尾呼び出し (tail call) 」といいます。関数を呼び出す場合、返ってきたあとに行う処理のため、必要な情報を保存しておかなければいけません。ところが、末尾呼び出しはそのあとに実行する処理がありません。呼び出したあと元に戻ってくる必要さえないのです。
</p>

<p> このため、末尾呼び出しはわざわざ関数を呼び出す必要はなく、アセンブリ言語のような低水準のレベルではジャンプ命令に変換することができます。これを「末尾呼び出し最適化 (tail call optimization) 」とか「末尾最適化」といいます。とくに末尾再帰は末尾で自分自身を呼び出しているので、関数の中で繰り返しに変換することができます。
</p>

<p> また、相互再帰やもっと複雑な再帰呼び出しの場合でも、末尾最適化を適用することで、繰り返しに変換できる場合もあります。このように、再帰プログラムを繰り返しに変換してから実行することを「末尾再帰最適化 (tail recursion optimization) 」といいます。厳密にいうと末尾最適化なのですが、一般的には末尾再帰最適化と呼ばれることが多いようです。
</p>

<p> 末尾再帰最適化を行うプログラミング言語、たとえば Scheme の場合、次に示すような関数呼び出しは、スタックを消費せずに実行することができます。処理系は Gauche を使いました。
</p>
<pre>
gosh&gt; (define (foo) (foo))
foo
gosh&gt; (foo)
=&gt; 無限ループになる
</pre>
<p> これは Scala でも同様に実行することができますが、M.Hiroi の環境では CTRL-C でブレークすることができなかったので注意してください。
</p>

<p> もうひとつ簡単な例を示しましょう。Ｃ言語で階乗を計算する関数 fact を作ります。
</p>
<pre class="list">
リスト : 末尾再帰を繰り返しに変換する (Ｃ言語)

/* 末尾再帰 */
int fact(int n, int a)
{
  if(n == 0){
    return a;
  } else {
    return fact(n - 1, a * n);
  }
}

/* 繰り返し */
int facti(int n, int a)
{
loop:
  if(n == 0) return a;
  a *= n;
  n--;
  goto loop;
}
</pre>

<p> fact は末尾再帰になっています。これを繰り返しに変換すると facti のようになります。引数 n と a の値を保存する必要がないので、n と a の値を書き換えてから goto 文で先頭の処理へジャンプするだけです。最近はＣ言語でも末尾再帰最適化を行う処理系 (GCC など) があるようです。
</p>

<h4>●末尾再帰をスタックオーバーフローせずに実行する</h4>
<p> Scala の場合、末尾再帰最適化ができなければ繰り返しでプログラムすることになりますが、CPS は末尾再帰でプログラムしたほうが簡単です。この場合、TailCalls を使うことになりますが、その基本的な考え方は簡単なので、少々不恰好でもよければ私たちでもプログラムすることができます。
</p>

<p> 末尾再帰の場合、再帰呼び出しのあとに行う処理は存在せず、関数の返り値をそのまま返すだけです。この返り値のかわりに、関数呼び出しの部分を遅延評価して、それをオブジェクトに格納して返すこともできます。ここで実行中の処理を中断することができます。そして、オブジェクトに格納された処理を評価すると、中断された処理を再開することができます。ようするに、遅延ストリームと同じような処理になります。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 末尾再帰の計算

// 抽象クラス
abstract class TailCall[A] {
  def result: A
  def call: TailCall[A]
  def isDone: Boolean
}

// 計算終了
class Done[A](val result: A) extends TailCall[A] {
  def call = throw new Exception("Done: call not member")
  def isDone: Boolean = true
}

// 計算中
class Call[A](f: =&gt; TailCall[A]) extends TailCall[A] {
  lazy val func = f
  def result = throw new Exception("Call: result not member")
  def call: TailCall[A] = func
  def isDone: Boolean = false
}
</pre>
<p> クラス TailCall は末尾再帰の計算を表します。TailCalls の TailRec に相当するクラスです。クラス Done は計算終了を表すクラスで、計算結果をフィールド変数 result に格納します。Call は計算中の処理を格納するクラスです。遅延評価で実行する処理を受け取り、フィールド変数 func にセットします。メソッド call は遅延評価した処理 func を実行します。
</p>

<p> 次に、TailCall を使って末尾再帰を実行する関数を作ります。
</p>
<pre class="list">
リスト : 末尾再帰を実行する

  // 値を返す
  def done[A](x: A): TailCall[A] = new Done(x)

  // Call オブジェクトを返す
  def tailcall[A](f: =&gt; TailCall[A]): TailCall[A] = new Call(f)

  // 実行
  def exec[A](f: TailCall[A]): A = {
    var fn = f
    while (!fn.isDone) fn = fn.call
    fn.result
  }
</pre>

<p> 関数 done は値を返すために使います。関数 tailcall は末尾再帰するときに使います。done は Done のオブジェクトを、tailcall は Call のオブジェクトを生成して返すだけです。関数 exec は末尾再帰で書かれたプログラムを実行します。引数 f を mutable な変数 fn にセットします。あとは、計算が終わるまで fn.call を呼び出して fn の値を更新するだけです。fn.call の返り値は Done か Call のオブジェクトです。Done が帰ってくれば計算終了、Call が返ってくれば tailcall を使った再帰呼び出しであることがわかります。その場合は、計算を続行すればいいわけです。
</p>

<p> 簡単な実行例を示します。
</p>
<pre class="list">
リスト : TailCall の簡単な例題

  // 相互再帰
  def isEven(n: Int): TailCall[Boolean] =
    if (n == 0) done(true)
    else tailcall(isOdd(n - 1))

  def isOdd(n: Int): TailCall[Boolean] = 
    if (n == 0) done(false)
    else tailcall(isEven(n - 1))

  // 階乗
  def factCps1(n: Int, cont: TailCall[BigInt] =&gt; TailCall[BigInt]): TailCall[BigInt] =
    if (n == 0) cont(done(1))
    else tailcall(factCps1(n - 1, x =&gt; cont(done(x.result * n))))

  // フィボナッチ関数
  def fiboCps1(n: Int, cont: TailCall[BigInt] =&gt; TailCall[BigInt]): TailCall[BigInt] =
    if (n == 0 || n == 1) cont(done(1))
    else tailcall(fiboCps1(n - 1, x =&gt; tailcall(fiboCps1(n - 2, y =&gt; cont(done(x.result + y.result))))))
</pre>
<pre>
scala&gt; exec(isEven(1000))
res0: Boolean = true

scala&gt; exec(isOdd(10000))
res1: Boolean = false

scala&gt; exec(factCps1(100, x => x))
res2: BigInt = 93326215443944152681699238856266700490715968264381621468592963895
21759999322991560894146397615651828625369792082722375825118521091686400000000000
0000000000000

scala&gt; exec(fiboCps1(16, x => x))
res3: BigInt = 1597

scala&gt; exec(fiboCps1(20, x => x))
res4: BigInt = 10946

scala&gt; exec(fiboCps1(30, x => x))
res5: BigInt = 1346269
</pre>
<p> tailcall と done の使い方は TailCalls と同じです。関数を実行するときは exec を使うので、TailCalls よりも使い勝手は少々悪いと思いますが、スタックオーバーフローせずにプログラムを実行することができます。
</p>
<hr>
<h4>●プログラムリスト２</h4>
<pre class="list">
//
// sample2301.scala : 末尾再帰を繰り返しのように実行する
//
//                    Copyright (C) 2014 Makoto Hiroi
//

// 抽象クラス
abstract class TailCall[A] {
  def result: A
  def call: TailCall[A]
  def isDone: Boolean
}

// 計算終了
class Done[A](val result: A) extends TailCall[A] {
  def call = throw new Exception("Done: call not member")
  def isDone: Boolean = true
}

// 計算中
class Call[A](f: =&gt; TailCall[A]) extends TailCall[A] {
  lazy val func = f
  def result = throw new Exception("Call: result not member")
  def call: TailCall[A] = func
  def isDone: Boolean = false
}

object sample2301 {
  // 値を返す
  def done[A](x: A): TailCall[A] = new Done(x)

  // Call オブジェクトを返す
  def tailcall[A](f: =&gt; TailCall[A]): TailCall[A] = new Call(f)

  // 実行
  def exec[A](f: TailCall[A]): A = {
    var fn = f
    while (!fn.isDone) fn = fn.call
    fn.result
  }

  def isEven(n: Int): TailCall[Boolean] =
    if (n == 0) done(true)
    else tailcall(isOdd(n - 1))

  def isOdd(n: Int): TailCall[Boolean] = 
    if (n == 0) done(false)
    else tailcall(isEven(n - 1))

  def factCps1(n: Int, cont: TailCall[BigInt] =&gt; TailCall[BigInt]): TailCall[BigInt] =
    if (n == 0) cont(done(1))
    else tailcall(factCps1(n - 1, x =&gt; cont(done(x.result * n))))

  def fiboCps1(n: Int, cont: TailCall[BigInt] =&gt; TailCall[BigInt]): TailCall[BigInt] =
    if (n == 0 || n == 1) cont(done(1))
    else tailcall(fiboCps1(n - 1, x =&gt; tailcall(fiboCps1(n - 2, y =&gt; cont(done(x.result + y.result))))))

}
</pre>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala22.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala24.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>