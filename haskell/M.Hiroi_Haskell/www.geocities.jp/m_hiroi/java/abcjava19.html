<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>続・お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881776</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Java Programming</h1>
<h2>続・お気楽 Java プログラミング入門</h2>
<div class="small">
[ <a href="abcjava18.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava20.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>immutable な遅延ストリーム (後編)</h3>
<h4>●zipWith()</h4>
<p> 遅延ストリームを操作する場合、2 つの遅延ストリームを受け取るマップ関数があると便利です。関数型言語 Haskell では、この処理を zipWith() と呼んでいます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : マップ関数 zipWith()

  public static &lt;T, U, V&gt; LazyStream&lt;V&gt; zipWith(BiFunction&lt;? super T, ? super U, ? extends V&gt; func, LazyStream&lt;T&gt; xs, LazyStream&lt;U&gt; ys) {
    if (xs.isEmpty() || ys.isEmpty())
      return nil();
    else
      return cons(func.apply(xs.first(), ys.first()), () -&gt; zipWith(func, xs.rest(), ys.rest()));
  }
</pre>
<p> 今回は zipWith() をスタティックメソッドとして定義しました。遅延ストリーム xs と ys からそれぞれの要素を取り出してメソッド func に渡します。そして、その返り値を遅延ストリームに格納して返します。どちらかの遅延ストリームが空になった場合は空の遅延ストリームを返します。これで有限と無限どちらの遅延ストリームにも対応することができます。
</p>

<p> 簡単な実行例を示しましょう。
</p>
<pre class="list">
リスト : zipWith() の例

import immutable.*;
import static immutable.LazyStream.*;

public class sample190 {
  public static void main(String[] args) {
    LazyStream&lt;Integer&gt; xs = iota(1, 10);
    LazyStream&lt;Integer&gt; ys = iota(11, 20);
    LazyStream&lt;Integer&gt; zs = iterate(1, x -&gt; x + 1);
    System.out.println(zipWith((x, y) -&gt; x * y, xs, ys).take(10));
    System.out.println(zipWith((x, y) -&gt; x * y, xs, zs).take(10));
    System.out.println(zipWith((x, y) -&gt; x * y, zs, ys).take(10));
    System.out.println(zipWith((x, y) -&gt; x * y, zs, zs).take(20));
  }
}
</pre>
<pre>
C&gt;java sample190
[11, 24, 39, 56, 75, 96, 119, 144, 171, 200]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
[11, 24, 39, 56, 75, 96, 119, 144, 171, 200]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]
</pre>
<p> zipWith() を使うと、遅延ストリームに対していろいろな処理を定義することができます。次の例を見てください。
</p>
<pre class="list">
リスト : zipWith() の例 (2)

import immutable.*;
import static immutable.LazyStream.*;

public class sample191 {
  static LazyStream&lt;Integer&gt; addStream(LazyStream&lt;Integer&gt; xs, LazyStream&lt;Integer&gt; ys) {
    return zipWith((x, y) -&gt; x + y, xs, ys);
  }
  
  static LazyStream&lt;Integer&gt; ones = repeat(1);
  static LazyStream&lt;Integer&gt; ints;
  static LazyStream&lt;Integer&gt; fibo;
  static {
    ints = cons(1, () -&gt; addStream(ones, ints));
    fibo = cons(0, () -&gt; cons(1, () -&gt; addStream(fibo.rest(), fibo)));
  }
  
  public static void main(String[] args) {
    System.out.println(ints.take(20));
    System.out.println(fibo.take(20));
  }
}
</pre>
<pre>
C&gt;java sample191
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]
</pre>
<p> addStream() は xs と ys の要素を加算した遅延ストリームを返します。この addStream() を使うと、整数を生成する遅延ストリーム ints やフィボナッチ数列を生成する遅延ストリーム fibo を定義することができます。
</p>
<p> 遅延ストリーム ints は、現在の ints に 1 を足し算することで整数を生成しています。fibo は現在のフィボナッチ数列を表していて、fibo.rest() で次の要素を求め、それらを足し算することで、その次の要素を求めています。この場合、ストリームの初期値として 2 つの要素が必要になることに注意してください。
</p>
<p> なお、スタティック変数 ints と fibo は代入演算子 (=) で初期値を指定すると、右辺式に自分自身 (ints や fibo) が含まれるためコンパイルエラーになります。このため、ints と fobo の初期化には「スタティックイニシャライザ (静的初期化子)」を使っています。
</p>
<pre class="item">
static { 初期化処理; ... }
</pre>
<p> クラスの中で static を付けたブロックを定義すると、そのクラスを最初に利用したときに、その中の処理が一度だけ実行されます。
</p>

<h4>●遅延ストリームの併合</h4>
<p> 次は、要素を昇順に出力する 2 つの遅延ストリームを併合 (マージ: merge) するメソッドを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 遅延ストリームのマージ

  public static &lt;E extends Comparable&lt;E&gt;&gt; LazyStream&lt;E&gt; merge(LazyStream&lt;E&gt; xs, LazyStream&lt;E&gt; ys) {
    if (xs == NIL) {
      return ys;
    } else if (ys == NIL) {
      return xs;
    } else {
      E x = xs.first();
      E y = ys.first();
      int r = x.compareTo(y);
      if (r &lt;= 0)
        return cons(x, () -&gt; merge(xs.rest(), ys));
      else
        return cons(y, () -&gt; merge(xs, ys.rest()));
    }
  }
</pre>
<p> スタティックメソッド merge() は 2 つの遅延ストリームを併合して新しい遅延ストリームを返します。基本的には連結リストのメソッド mergeList() と同じです。xs が空であれば ys を返し、ys が空ならば xs を返します。そうでなければ、遅延ストリームの先頭要素を取り出して変数 x, y にセットします。x &lt;= y ならば x を、そうでなければ y を遅延ストリームに格納します。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre class="list">
リスト : merge() の例

import immutable.*;
import static immutable.LazyStream.*;

public class sample192 {
  public static void main(String[] args) {
    LazyStream&lt;Integer&gt; xs = iterate(1, x -&gt; x + 2);
    LazyStream&lt;Integer&gt; ys = iterate(0, x -&gt; x + 2);
    System.out.println(merge(xs, ys).take(20));
    System.out.println(merge(xs, xs).take(20));
  }
}
</pre>
<pre>
C&gt;java sample192
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 13, 13, 15, 15, 17, 17, 19, 19]
</pre>
<h4>●集合演算</h4>
<p> ここで、遅延ストリームには重複要素が存在せず、要素は昇順に出力されることを前提にすると、遅延ストリームでも集合演算を行うことができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 集合演算

  // 和集合
  public static &lt;E extends Comparable&lt;E&gt;&gt; LazyStream&lt;E&gt; union(LazyStream&lt;E&gt; xs, LazyStream&lt;E&gt; ys) {
    if (xs == NIL) {
      return ys;
    } else if (ys == NIL) {
      return xs;
    } else {
      E x = xs.first();
      E y = ys.first();
      int r = x.compareTo(y);
      if (r &lt; 0)
        return cons(x, () -&gt; union(xs.rest(), ys));
      else if (r &gt; 0)
        return cons(y, () -&gt; union(xs, ys.rest()));
      else
        return cons(x, () -&gt; union(xs.rest(), ys.rest()));
    }
  }

  // 積集合
  public static &lt;E extends Comparable&lt;E&gt;&gt; LazyStream&lt;E&gt; intersection(LazyStream&lt;E&gt; xs, LazyStream&lt;E&gt; ys) {
    if (xs == NIL) {
      return nil();
    } else if (ys == NIL) {
      return nil();
    } else {
      while (true) {
        E x = xs.first();
        E y = ys.first();
        int r = x.compareTo(y);
        if (r == 0) {
          LazyStream&lt;E&gt; xs1 = xs;
          LazyStream&lt;E&gt; ys1 = ys;
          return cons(x, () -&gt; intersection(xs1.rest(), ys1.rest()));
        } else if (r &lt; 0) {
          xs = xs.dropWhile(x1 -&gt; x1.compareTo(y) &lt; 0);
        } else {
          ys = ys.dropWhile(y1 -&gt; x.compareTo(y1) &gt; 0);
        }
      }
    }
  }
</pre>
<p> スタティックメソッド union() は xs と ys から要素を取り出して、小さいほうを遅延ストリームに追加します。等しい場合は x だけを追加します。このとき、xs と ys の両方から先頭要素を取り除くことに注意してください。
</p>
<p> スタティックメソッド intersection() はちょっと複雑です。xs, ys から先頭要素を取り出して、変数 x, y にセットします。x と y が等しい場合は、その要素を遅延ストリームに追加します。x が y よりも小さい場合、dropWhile() で xs から y よりも小さい要素を取り除きます。逆に、x が y よりも大きい場合は ys から x よりも小さい要素を取り除きます。あとは while ループで同じ処理を繰り返すだけです。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre class="list">
リスト : union() と intersection() の例

import immutable.*;
import static immutable.LazyStream.*;

public class sample193 {
  public static void main(String[] args) {
    LazyStream&lt;Long&gt; xs = iterate(1L, x -&gt; x + 1);
    LazyStream&lt;Long&gt; triangular = xs.map(x -&gt; x * (x + 1) / 2);
    LazyStream&lt;Long&gt; square = xs.map(x -&gt; x * x);
    System.out.println(triangular.take(20));
    System.out.println(square.take(20));
    System.out.println(union(triangular, square).take(20));
    System.out.println(intersection(triangular, square).take(7));
  }
}
</pre>
<pre>
C&gt;java sample193
[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]
[1, 3, 4, 6, 9, 10, 15, 16, 21, 25, 28, 36, 45, 49, 55, 64, 66, 78, 81, 91]
[1, 36, 1225, 41616, 1413721, 48024900, 1631432881]
</pre>
<p> 遅延ストリーム triangular は「三角数」、square は「四角数」を表します。これらの遅延ストリームを union() でまとめると、三角数または四角数の数列になります。intersection() でまとめると、三角数かつ四角数の数列 (平方三角数) になります。なお、平方三角数は拙作のページ <a href="../puzzle/index.html">Puzzle DE Progamming</a> <a href="../puzzle/polynum.html">多角数</a> でも取り上げています。興味のある方はお読みくださいませ。
</p>

<h4>●ハミングの問題</h4>
<p> 次は「ハミングの問題」を解いてみましょう。
</p>
<div class="question">
<b>[ハミングの問題]</b><br>
<p> 7 以上の素数で割り切れない正の整数を小さい順に N 個求めよ
</p>
<a name="cite0130">参考文献</a> : 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991 (361 ページより引用)
</div>
<p> 7 以上の素数で割り切れない正の整数は、素因子が 2, 3, 5 しかない自然数のことで、これを「ハミング数 (Hamming Numbers)」といいます。ハミング数は素因数分解したとき、2<sup>i</sup> * 3<sup>j</sup> * 5<sup>k</sup> (i, j, k &gt;= 0) の形式になります。たとえば、100 以下のハミング数は次のようになります。
</p>
<pre class="item">
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 
54, 60, 64, 72, 75, 80, 81, 90, 96, 100
</pre>
<p> 遅延ストリームを使うと「ハミングの問題」は簡単に解くことができます。小さい順にハミング数を出力する遅延ストリームを hs としましょう。hs は 1 から始まるので次のように定義できます。
</p>
<pre class="item">
hs = cons(1, () -&gt; ...);
</pre>
<p> 最初の要素は 1 なので、それに 2, 3, 5 を掛け算した値 (2, 3, 5) もハミング数になります。これらの値は hs.map(x -&gt; x * 2), hs.map(x -&gt; x * 3), hs.map(x -&gt; x * 5) で生成することができます。あとは、これらの遅延ストリームをひとつにまとめて、小さい順に出力する遅延ストリームを作ればいいわけです。hs の定義は次のようになります。
</p>
<pre class="item">
hs = cons(1, () -&gt; union(union(hs.map(x -&gt; x * 2), hs.map(x -&gt; x * 3)), hs.map(x -&gt; x * 5)));
</pre>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : ハミングの問題

import immutable.*;

public class hamming {
  static LazyStream&lt;Long&gt; union(LazyStream&lt;Long&gt; xs, LazyStream&lt;Long&gt; ys) {
    return LazyStream.union(xs, ys);
  }
  
  static LazyStream&lt;Long&gt; hs;
  static {
    hs = LazyStream.cons(1L, () -&gt; union(union(hs.map(x -&gt; x * 2), hs.map(x -&gt; x * 3)), hs.map(x -&gt; x * 5)));
  }

  public static void main(String[] args) {
    System.out.println(hs.take(100));
  }
}
</pre>
<p> LazyStrem.union() を直接呼び出すとコンパイルエラーになったので、スタティックメソッド union() を定義しました。実行結果を示します。
</p>
<pre>
C&gt;java hamming
[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45,
 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144,
150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320,
324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625,
640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 
1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536]
</pre>

<h4>●順列の生成</h4>
<p> 異なる n 個の順列の総数は、n の階乗 (n!) だけあります。たとえば、3 つの整数 1, 2, 3 の順列は次に示すように 6 通りあります。
</p>
<pre class="item">
(1 2 3), (1 3 2), (2 1 3), (2 3 1), (3 1 2), (3 2 1)
</pre>
<p> 順列を生成するプログラムは再帰定義で簡単に作ることができます。(1 2 3) の順列を生成する場合、最初に 1 で始まる順列を生成します。これは 1 を取り除いた数字 (2 3) の順列を生成することで実現できます。次は 2 で始まる順列を生成します。同様に、2 を取り除いた数字 (1 3) の順列を生成すればいいわけです。(2 3) や (1 3) の順列を生成する場合も同じように考えることができます。
</p>

<h4>●要素の選択</h4>
<p> それではプログラムを作りましょう。最初に、連結リスト ImList&lt;E&gt; から要素を一つ選んで、選んだ要素と残りの要素を返すメソッド select() を作ります。次のリストを見てください。
</p>

<pre class="list">
リスト : 要素の選択

import immutable.*;
import static immutable.LazyStream.*;

public class sample194 {
  static &lt;E&gt; LazyStream&lt;Pair&lt;E, ImList&lt;E&gt;&gt;&gt; select(ImList&lt;E&gt; xs) {
    if (xs.rest().isEmpty())
      return cons(Pair.pair(xs.first(), ImList.nil()), () -&gt; nil());
    else
      return cons(Pair.pair(xs.first(), xs.rest()),
                  () -&gt; select(xs.rest()).map(p -&gt; Pair.pair(p.getFst(), ImList.cons(xs.first(), p.getSnd()))));
  }

  public static void main(String[] args) {
    LazyStream&lt;Pair&lt;Integer, ImList&lt;Integer&gt;&gt;&gt; xs = select(ImList.iota(1, 4));
    xs.forEach(System.out::println);
  }
}
</pre>
<p> select() は選んだ要素と残りの要素を Pair に格納し、それを遅延ストリームに格納して返します。最初に、リスト xs の要素が一つしかない場合は (xs.first(), ImList.nil()) を遅延ストリームに格納します。そうでなければ、(xs.first(), xs.rest()) を遅延ストリームに格納し、第 2 引数のラムダ式の中で残りの要素を選びます。
</p>
<p> ラムダ式の中では select(xs.rest()) を実行して、残りの要素を一つ選びます。返り値は遅延ストリームなので、map() で要素 (Pair) を順番に取り出して、Pair の第 2 要素のリストに xs.first() を追加します。Pair は immutable なので値を書き換えることはできません。新しい Pair を生成していることに注意してください。これで、リスト xs から要素を順番に選ぶことができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;java sample194
(1, (2 3 4))
(2, (1 3 4))
(3, (1 2 4))
(4, (1 2 3))
</pre>
<h4>●プログラムの作成</h4>
<p> select() を使うと順列を生成するメソッド permutations() は簡単にプログラムすることができます。次のリストを見てください。
</p>

<pre class="list">
リスト : 順列の生成

import immutable.*;
import static immutable.LazyStream.*;

public class sample194 {
  //
  // select() は省略
  //

  static &lt;E&gt; LazyStream&lt;ImList&lt;E&gt;&gt; permutations(ImList&lt;E&gt; xs) {
    if (xs.isEmpty())
      return cons(ImList.nil(), () -&gt; nil());
    else
      return select(xs).flatMap(p -&gt; permutations(p.getSnd()).map(ys -&gt; ImList.cons(p.getFst(), ys)));
  }
  
  public static void main(String[] args) {
    LazyStream&lt;ImList&lt;Integer&gt;&gt; ys = permutations(ImList.iota(1, 4));
    ys.forEach(System.out::println);
  }
}
</pre>

<p> メソッド permutations() は引数のリスト xs から順列を生成し、それを遅延ストリームに格納して返します。引数が空リストの場合、空リストを遅延ストリームに格納します。このリストに対して要素を追加していきます。
</p>
<p> xs が空リストでなければ select() で要素を一つ選びます。flatMap() のラムダ式の引数 p は Pair です。p.getSnd() で残りのリストを取り出し、permutations() でその順列を生成します。そして、その返り値を map() で取り出して、先頭に選択した要素 p.getFst() を追加すれば順列を生成することができます。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
C&gt;java sample194
(1 2 3 4)
(1 2 4 3)
(1 3 2 4)
(1 3 4 2)
(1 4 2 3)
(1 4 3 2)
(2 1 3 4)
(2 1 4 3)
(2 3 1 4)
(2 3 4 1)
(2 4 1 3)
(2 4 3 1)
(3 1 2 4)
(3 1 4 2)
(3 2 1 4)
(3 2 4 1)
(3 4 1 2)
(3 4 2 1)
(4 1 2 3)
(4 1 3 2)
(4 2 1 3)
(4 2 3 1)
(4 3 1 2)
(4 3 2 1)
</pre>

<h4>●select() を使わない方法</h4>
<p> 順列は select() を使わなくてもプログラムを作ることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 順列の生成 (2)

import immutable.*;
import static immutable.LazyStream.*;

public class sample195 {
  static &lt;E&gt; LazyStream&lt;ImList&lt;E&gt;&gt; permutations(ImList&lt;E&gt; xs) {
    if (xs.isEmpty())
      return cons(ImList.nil(), () -&gt; nil());
    else
      return of(xs).flatMap(x -&gt; permutations(xs.filter(y -&gt; !x.equals(y))).map(z -&gt; ImList.cons(x, z)));
  }

  public static void main(String[] args) {
    LazyStream&lt;ImList&lt;Integer&gt;&gt; perm = permutations(ImList.iota(1, 4));
    perm.forEach(System.out::println);
  }
}
</pre>
<p> 要素の選択は of(xs).flatMap() で行います。この場合、連結リスト xs の要素を先頭から順番に選択することになります。ラムダ式の中で permutations() を呼び出すとき、リスト xs から選んだ要素 x を filter() で削除します。これで x を取り除いたリストの順列を生成することができます。あとは　map() でリスト z の先頭に x を追加していくだけです。
</p>

<h4>●組み合わせの生成</h4>
<p> 次は「組み合わせ (combination)」を生成するプログラムを作ってみましょう。たとえば、リスト (1 2 3 4 5) の中から 3 個を選ぶ組み合わせは次のようになります。
</p>
<pre class="item">
(1 2 3), (1 2 4), (1 2 5), (1 3 4), (1 3 5), (1 4 5)
(2 3 4), (2 3 5), (2 4 5), (3 4 5)
</pre>
<p> 最初に 1 を選択した場合、次は (2 3 4 5) の中から 2 個を選べばいいですね。2 番目に 2 を選択したら、次は (3 4 5) の中から 1 個を選べばいいわけです。これで、(1 2 3), (1 2 4), (1 2 5) が生成されます。(2 3 4 5) の中から 2 個選ぶとき、2 を選ばない場合があります。この場合は (3 4 5) の中から 2 個を選べばいいわけです。ここで 3 を選ぶと (1 3 4), (1 3 5) が生成できます。同様に、3 を除いた (4 5) の中から 2 個をえらぶと (1 4 5) を生成することができます。
</p>
<p> これで 1 を含む組み合わせを生成したので、次は 1 を含まない組み合わせ、つまり (2 3 4 5) から 3 個を選ぶ組み合わせを生成すればいいわけです。けっきょく、この処理の考え方は次に示す組み合わせの公式と同じです。
</p>
<pre class="item">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r-1</sub> + <sub>n-1</sub>C<sub>r</sub>
</pre>
<p> これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : 組み合わせの生成

import immutable.*;
import static immutable.LazyStream.*;

public class sample196 {
  static &lt;E&gt; LazyStream&lt;ImList&lt;E&gt;&gt; combinations(int n, ImList&lt;E&gt; xs) {
    if (n == 0)
      return cons(ImList.nil(), () -&gt; nil());
    else if (xs.length() == n)
      return cons(xs, () -&gt; nil());
    else
      return combinations(n - 1, xs.rest()).map(ys -&gt; ImList.cons(xs.first(), ys))
             .lazyAppend(Delay.delay(() -&gt; combinations(n, xs.rest())));
  }

  public static void main(String[] args) {
    LazyStream&lt;ImList&lt;Integer&gt;&gt; xs = combinations(3, ImList.iota(1, 5));
    xs.forEach(System.out::println);
  }
}
</pre>
<p> combinations() の第 1 引数が選択する要素の個数、第 2 引数が要素を格納したリストです。n が 0 の場合、選択する要素がないので空リストを格納した遅延ストリームを返します。n と xs.length() が等しい場合は、その要素を全て選択するので xs を格納した遅延ストリームを返します。
</p>

<p> そうでなければ、先頭要素 xs.first() を選びます。残りのリスト xs.rest() から n - 1 個を選ぶ組み合わせを combinations() で求め、その先頭に xs.first() を追加します。あとは、xs.rest() から n 個を選ぶ組み合わせを combinations() で求め、lazyAppend() で連結するだけです。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
C&gt;java sample196
(1 2 3)
(1 2 4)
(1 2 5)
(1 3 4)
(1 3 5)
(1 4 5)
(2 3 4)
(2 3 5)
(2 4 5)
(3 4 5)
</pre>
<p> 正常に動作していますね。
</p>
<h4>●組 (Pair) を生成する遅延ストリーム</h4>
<p> 次は、2 つのストリームからその要素の組み合わせを生成するストリームを作りましょう。要素が n 個のストリームの場合、組み合わせは n * n 個あります。次の図を見てください。
</p>
<pre class="fig">
(a0, b0) (a0, b1) (a0, b2) ... (a0, bn)
(a1, b0) (a1, b1) (a1, b2) ... (a1, bn)
(a2, b0) (a2, b1) (a2, b2) ... (a2, bn)

                           ...

(an, b0) (an, b1) (an, b2) ... (an, bn)

        図 : n * n 個の組
</pre>
<p> これは「直積集合」を求めることと同じです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組の生成 (1)

import immutable.*;
import static immutable.LazyStream.*;

public class sample197 {
  static &lt;T, U&gt; LazyStream&lt;Pair&lt;T, U&gt;&gt; pairStream(LazyStream&lt;T&gt; xs, LazyStream&lt;U&gt; ys) {
    return xs.flatMap(x -&gt; ys.map(y -&gt; Pair.pair(x, y)));
  }

  public static void main(String[] args) {
    LazyStream&lt;Pair&lt;Integer, Integer&gt;&gt; ps1 = pairStream(iota(1, 4), iota(5, 8));
    System.out.println(ps1.take(16));
    LazyStream&lt;Pair&lt;Integer, Integer&gt;&gt; ps2 = pairStream(iterate(1, x -&gt; x + 1), iterate(5, x -&gt; x + 1));
    System.out.println(ps2.take(16));
  }
}
</pre>
<p> メソッド pairStream() はとても簡単ですが、実は問題点があるのです。実際に実行してみましょう。
</p>

<pre>
C&gt;java sample197
[(1, 5), (1, 6), (1, 7), (1, 8), (2, 5), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6),
 (3, 7), (3, 8), (4, 5), (4, 6), (4, 7), (4, 8)]
[(1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), 
 (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)]
</pre>
<p> 有限の遅延ストリームであれば問題ありませんが、無限ストリームの要素で組を作る場合、Pair の第 1 要素は 1 しか出力されません。そこで、下図に示すように、対角線上に組を生成していくことにします。
</p>
<pre class="fig">
   | a0  a1  a2  a3  a4  a5
---+-----------------------------
b0 | 0   1   3   6   10  15  ...
   |
b1 | 2   4   7   11  16  ...
   |
b2 | 5   8   12  17  ...
   |
b3 | 9   13  18  ...
   |
b4 | 14  19  ...
   |
b5 | 20 ...
   |
   | ...
   |

図 : 無限ストリームによる組の生成
</pre>
<p> 図を見ればおわかりのように、対角線の要素数を n とすると、組は (an-1, b0), (an-2, b1), ..., (a1, bn-2), (a0, bn-1) となっています。これは、xs から n 個の要素を取り出したリストと、ys から n 個の要素を取り出して反転したリストを zip でまとめた形になっています。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 組の生成 (2)

import java.util.*;
import immutable.*;
import static immutable.LazyStream.*;

public class sample198 {
  static &lt;T, U&gt; ImList&lt;Pair&lt;T, U&gt;&gt; makePair(List&lt;T&gt; xs, List&lt;U&gt; ys) {
    ImList&lt;Pair&lt;T, U&gt;&gt; zs = ImList.nil();
    for (int i = 0; i &lt; ys.size(); i++) {
      int j = ys.size() - 1 - i;
      zs = ImList.cons(Pair.pair(xs.get(j), ys.get(i)), zs);
    }
    return zs;
  }
  
  static &lt;T, U&gt; LazyStream&lt;Pair&lt;T, U&gt;&gt; makePairStream(int n, LazyStream&lt;T&gt; xs, LazyStream&lt;U&gt; ys) {
    ImList&lt;Pair&lt;T, U&gt;&gt; zs = makePair(xs.take(n), ys.take(n));
    return of(zs).lazyAppend(Delay.delay(() -&gt; makePairStream(n + 1, xs, ys)));
  }
  
  static &lt;T, U&gt; LazyStream&lt;Pair&lt;T, U&gt;&gt; pairStream(LazyStream&lt;T&gt; xs, LazyStream&lt;U&gt; ys) {
    return makePairStream(1, xs, ys);
  }

  public static void main(String[] args) {
    LazyStream&lt;Integer&gt; xs = iterate(1, x -&gt; x + 1);
    LazyStream&lt;Pair&lt;Integer, Integer&gt;&gt; ps = pairStream(xs, xs);
    System.out.println(ps.take(50));
  }
}
</pre>
<p> 実際の処理はメソッド makePairStream() で行っています。引数 n が対角線上の要素数を表します。take() で xs と ys から要素を取り出し、それをメソッド makePair() に渡して組を作成します。このリストを of() で遅延ストリームに変換します。これで無限リストに対応することができます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;java sample198
[(1, 1), (1, 2), (2, 1), (1, 3), (2, 2), (3, 1), (1, 4), (2, 3), (3, 2), (4, 1),
 (1, 5), (2, 4), (3, 3), (4, 2), (5, 1), (1, 6), (2, 5), (3, 4), (4, 3), (5, 2),
 (6, 1), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (1, 8), (2, 7),
 (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (1, 9), (2, 8), (3, 7), (4, 6),
 (5, 5), (6, 4), (7, 3), (8, 2), (9, 1), (1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]
</pre>
<p> 正常に動作していますね。
</p>
<h4>●エラトステネスの篩</h4>
<p> 最後に、遅延ストリームを使って素数を求めるプログラムを作ってみましょう。考え方は簡単です。最初に、2 から始まる整数列を生成する遅延ストリームを用意します。2 は素数なので、素数ストリームの要素になります。次に、この整数列から 2 で割り切れる整数を取り除き除きます。これは filter() を使うと簡単です。
</p>
<p> 2 で割り切れる整数が取り除かれたので、次の要素は 3 になります。今度は 3 で割り切れる整数を取り除けばいいのです。これも filter() を使えば簡単です。このとき、入力用の遅延ストリームは 2 で割り切れる整数が取り除かれています。したがって、この遅延ストリームに対して 3 で割り切れる整数を取り除くように filter() を設定すればいいわけです。
</p>
<p> このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩」といいます。ようするに、2 から始まる整数ストリームに対して、見つけた素数 2, 3, 5, 7, 11, ... を順番に filter() で設定して素数でない整数をふるい落としていくわけです。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 素数の生成

import immutable.*;
import static immutable.LazyStream.*;

public class sievelazy {
  static LazyStream&lt;Integer&gt; sieve(LazyStream&lt;Integer&gt; s) {
    int p = s.first();
    return cons(p, () -&gt; sieve(s.rest().filter(x -&gt; x % p != 0)));
  }
  
  public static void main(String[] args) {
    LazyStream&lt;Integer&gt; ps = sieve(iterate(2, x -&gt; x + 1));
    System.out.println(ps.take(25));
    System.out.println(ps.take(50));
    System.out.println(ps.take(100));
  }
}
</pre>
<p> sieve() には 2 から始まる整数列を生成する遅延ストリームを渡します。ラムダ式で sieve() を呼び出すとき、filter() により整数列から 2 で割り切れる整数を取り除いた遅延ストリームが渡されます。次の要素 3 を取り出すとき、この遅延ストリームに対して 3 で割り切れる整数を取り除くことになるので、2 と 3 で割り切れる整数が取り除かれることになります。次の要素は 5 になりますが、その遅延ストリームからさらに 5 で割り切れる整数が filter() で取り除かれることになります。
</p>
<p> このように filter() が設定されていくことで、素数でない整数をふるい落としていくことができるわけです。それでは実行してみましょう。
</p>
<pre>
C&gt;java sievelazy
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
 79, 83, 89, 97]
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163
, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229]
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,
 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,
 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]
</pre>
<p> 正常に動作していますね。
</p>
<h4>●sieve() の高速化</h4>
<p> メソッド sieve() は簡単にプログラムできますが、生成する素数の個数が多くなると、その実行速度はかなり遅くなります。実をいうと、sieve() なみに簡単で sieve() よりも高速な方法があります。
</p>
<p> 整数 n が素数か確かめる簡単な方法は、√n 以下の素数で割り切れるか試してみることです。割り切れる素数 m があれば、n は素数ではありません。そうでなければ、n は素数であることがわかります。
</p>
<p> これをそのままプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 素数の生成 (2)

import immutable.*;
import static immutable.LazyStream.*;

public class sievelazy {
  static LazyStream&lt;Integer&gt; sieve(LazyStream&lt;Integer&gt; s) {
    int p = s.first();
    return cons(p, () -&gt; sieve(s.rest().filter(x -&gt; x % p != 0)));
  }
  
  // 高速化
  static LazyStream&lt;Integer&gt; primes =
    cons(2, () -&gt; cons(3, () -&gt; cons(5, () -&gt; primesFrom(7))));

  static int nextPrime(int n) {
    while (true) {
      LazyStream&lt;Integer&gt; ps = primes;
      while (true) {
        int p = ps.first();
        if (p * p &gt; n) return n;
        if (n % p == 0) break;
        ps = ps.rest();
      }
      n += 2;
    }
  }

  static LazyStream&lt;Integer&gt; primesFrom(int n) {
    int p = nextPrime(n);
    return cons(p, () -&gt; primesFrom(p + 2));
  }

  public static void main(String[] args) {
    LazyStream&lt;Integer&gt; ps = sieve(iterate(2, x -&gt; x + 1));
/*
    System.out.println(ps.take(25));
    System.out.println(ps.take(50));
    System.out.println(ps.take(100));
*/
    long start = System.currentTimeMillis();
    System.out.println(ps.get(3000));
    long end = System.currentTimeMillis();
    System.out.println((end - start)  + "ms");
    start = System.currentTimeMillis();
    System.out.println(primes.get(3000));
    end = System.currentTimeMillis();
    System.out.println((end - start)  + "ms");
  }
}
</pre>
<p> 変数 primes に素数列を生成する遅延ストリームをセットします。実際に素数を生成する処理はメソッド primesFrom() で行います。primesFrom() は簡単で、メソッド nextPrime() を呼び出して n 以上で最小の素数を求め、それを遅延ストリームに追加します。偶数は素数ではないので、引数 n には奇数を与えていることに注意してください。
</p>
<p> nextPrime() も簡単です。√n 以下の素数は生成済みなので、while ループで primes から素数を順番に first() で取り出して変数 p にセットします。p が√n よりも大きければ n を返します。ここでは√n のかわりに条件を p * p &lt;= n としています。n が素数 p で割り切れれば、break で内側の while ループを脱出して次の数 (n + 2) を調べます。
</p>
<p> それでは実行してみましょう。get() で 3001 番目の素数を求めてみました。
</p>
<pre>
C&gt;java sievelazy
27457
2862ms
27457
8ms

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> sieve() よりも primes のほうが高速になりました。興味のある方はいろいろ試してみてください。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava18.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava20.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>