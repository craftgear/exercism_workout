<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>続・お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881776</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Java Programming</h1>
<h2>続・お気楽 Java プログラミング入門</h2>
<div class="small">
[ <a href="abcjava15.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava17.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>パッケージ</h3>
<p> プログラムを作っていると、以前作った関数と同じ処理が必要になる場合があります。いちばんてっとり早い方法はソースファイルからその関数をコピーすることですが、賢明な方法とはいえません。このような場合、自分で作成した関数をライブラリとしてまとめておくと便利です。ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、同じ名前の関数や変数が存在すると、そのライブラリは正常に動作しないでしょう。この問題は「パッケージ (package)」を使うと解決することができます。
</p>
<h4>●パッケージの基本的な使い方</h4>
<p> Java のパッケージはディレクトリで管理します。ディレクトリを作成して、そこにソースファイルを格納すれば、それをパッケージとして使用することができます。このとき、ディレクトリ名がパッケージ名になります。ディレクトリ名とソースファイル名は異なっていてもかまいません。ディレクトリの中に複数のソースファイルがある場合、それらをまとめたものが一つのパッケージになります。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : foo\Foo.java

package foo;

public class Foo {
  public static int a = 10;
  public static void test() {
    System.out.println("package foo");
  }
}
</pre>
<pre class="list">
リスト : bar\Bar.java

package bar;

public class Bar {
  public static int a = 20;
  public static void test() {
    System.out.println("package bar");
  }
}
</pre>
<p> カレントディレクトリにディレクトリ foo を作成し、その中にファイル Foo.java を格納します。同様に、ディレクトリ bar を作成して、ファイル Bar.java を格納します。ファイルの先頭には package 文でパッケージ名を記述します。外部に公開 (export) するクラスは public で宣言します。このとき、ファイル名は public 宣言したクラスの名前と同じにしてください。つまり、ファイル内で定義できる public なクラスは一つだけになります。
</p>
<p> パッケージを利用するときは import 文を使うと便利です。環境変数 CLASSPATH を設定していない場合、もしくは CLASSPARH にカレントディレクトリを追加している場合、パッケージ foo と bar は次のように指定します。
</p>
<pre class="list">
import foo.*;
import bar.*;
</pre>
<p> Java はクラスを探すとき、CLASSPATH が設定されている場合は、そのディレクトリから探します。CLASSPATH が設定されていなければ、カレントディレクトリを探します。見つからない場合は Java の標準ライブラリから探します。CLASSPATH を設定すると、カレントディレクトリを探索しないので、CLASSPATH にカレントディレクトリを追加するか、コマンド javac のオプション -classpath でカレントディレクトリ ( . ) を指定してください。
</p>
<p> それでは実行してみましょう。
</p>
<pre class="list">
リスト : パッケージの使用例

import foo.*;
import bar.*;

public class sample160 {
  public static void main(String[] args) {
    Foo.test();
    System.out.println(Foo.a);
    Bar.test();
    System.out.println(Bar.a);
  }
}
</pre>
<pre>
C&gt;javac foo/Foo.java

C&gt;javac bar/Bar.java

C&gt;javac sample160.java

C&gt;java sample160
package foo
10
package bar
20
</pre>
<p> 最初に import で foo と bar をインポートします。これでパッケージに含まれるクラスにアクセスすることができます。Foo.test() を実行すれば、package foo と表示され、Bar.a の値を表示すると 20 になります。このように、パッケージを使うことで名前の衝突を回避することができます。
</p>
<p> foo と bar を一つのディレクトリに格納することもできます。次の図を見てください。
</p>
<pre class="fig">
./
    baz/
        foo/
            Foo.java
        bar/
            Bar.java
</pre>
<p> ディレクトリ baz の中にディレクトリ foo と bar があり、その中にソースファイル Foo.java と Bar.java があります。この場合、Foo.java と Bar.java の package 文は次のように宣言します。
</p>
<pre class="item">
package baz.foo;
package baz.bar;
</pre>
<p> sample160.java の import 文は次のように指定します。
</p>
<pre class="item">
import baz.foo.*;
import baz.bar.*;
</pre>
<p> package 文と import 文のパス区切り記号にはドット ( . ) を使います。これで今までと同様にクラス Foo, Bar を使用することができます。
</p>

<h4>●Java Archive</h4>
<p> Java はコマンド jar を使って、パッケージ内にある複数の class ファイルを一つのファイルにまとめて取り扱うことができます。このファイルを Java Archive とか JAR ファイルといいます。
</p>
<p> jar で JAR ファイルを作成するときは次のオプションを指定します。
</p>
<pre class="item">
jar cf ファイル名.jar パッケージ
</pre>
<p> jar のオプションは UNIX 系 OS のコマンド tar と同じです。オプションに v を付けるとメッセージが表示されます。たとえば、パッケージ baz を JAR ファイルにまとめると次のようになります。
</p>
<pre>
C&gt;jar cvf baz.jar baz
マニフェストが追加されました
baz/を追加中です(入=0)(出=0)(0%格納されました)
baz/bar/を追加中です(入=0)(出=0)(0%格納されました)
baz/bar/Bar.classを追加中です(入=479)(出=324)(32%収縮されました)
baz/bar/Bar.javaを追加中です(入=144)(出=107)(25%収縮されました)
baz/foo/を追加中です(入=0)(出=0)(0%格納されました)
baz/foo/Foo.classを追加中です(入=479)(出=323)(32%収縮されました)
baz/foo/Foo.javaを追加中です(入=145)(出=108)(25%収縮されました)
</pre>
<p> これで JAR ファイル baz,jar が生成されます。JAR ファイルの内容は次のコマンドで閲覧することができます。
</p>
<pre class="item">
jar tf ファイル名
</pre>
<pre>
C&gt;jar tf baz.jar
META-INF/
META-INF/MANIFEST.MF
baz/
baz/bar/
baz/bar/Bar.class
baz/bar/Bar.java
baz/foo/
baz/foo/Foo.class
baz/foo/Foo.java
</pre>
<h4>●JAR ファイルの使い方</h4>
<p> JAR ファイルを利用する場合は環境変数 CLASSPAT かコマンドのオプション -classpath (-cp) でJAR ファイル名を指定します。
</p>
<pre>
C&gt;javac -cp baz.jar sample160.java

C&gt;java -cp ".;baz.jar" sample160
package baz.foo
10
package baz.bar
20
</pre>
<p> コマンド java で sample160 を実行する場合、CLASSPATH を設定するとカレントディレクトリの探索を行わないので、sample160 を見つけることができなくなります。この場合、CLASSPATH にカレントディレクトリ ( . ) を追加してください。Windows の場合、パスの区切り記号にはセミコロン ( ; ) を使います。これで複数のパスや JAR ファイルを指定することができます。探索の順序は左から右になります。
</p>
<p> マニフェストファイルで main() が定義されているクラスを指定すると、実行可能な JAR ファイルを作成することができます。名前は何でもかまいません。次に示すように Main-Class: の後ろに main() が定義されているクラスを指定するだけです。
</p>
<pre class="list">
リスト : Manifest.txt

Main-Class: sample160
</pre>
<p> jar コマンドではオプション m と引数に Manifest.txt を指定します。
</p>
<pre>
C&gt;jar cvfm sample.jar Manifest.txt sample160.class baz
マニフェストが追加されました
sample160.classを追加中です(入=496)(出=348)(29%収縮されました)
baz/を追加中です(入=0)(出=0)(0%格納されました)
baz/bar/を追加中です(入=0)(出=0)(0%格納されました)
baz/bar/Bar.classを追加中です(入=479)(出=324)(32%収縮されました)
baz/bar/Bar.javaを追加中です(入=144)(出=107)(25%収縮されました)
baz/foo/を追加中です(入=0)(出=0)(0%格納されました)
baz/foo/Foo.classを追加中です(入=479)(出=323)(32%収縮されました)
baz/foo/Foo.javaを追加中です(入=145)(出=108)(25%収縮されました)

C&gt;jar tf sample.jar
META-INF/
META-INF/MANIFEST.MF
sample160.class
baz/
baz/bar/
baz/bar/Bar.class
baz/bar/Bar.java
baz/foo/
baz/foo/Foo.class
baz/foo/Foo.java
</pre>
<p> これで、Manifest.txt の内容が JAR ファイル内の MANIFEST.MF にコピーされます。なお、baz.jar には main() を定義しているクラスがないので、引数に sample160.class も指定する必要があります。
</p>
<p> JAR ファイルを実行するにはオプション -jar を使います。それでは実行してみましょう。
</p>
<pre>
C&gt;java -jar sample.jar
package baz.foo
10
package baz.bar
20
</pre>
<h4>●import static</h4>
<p> import 文で static を指定すると、クラス名を指定せずにスタティックメソッドやスタティックなフィールド変数にアクセスできるようになります。
</p>
<pre class="item">
import static パッケージ名.クラス名.staticな変数名またはメソッド名;
import static パッケージ名.クラス名.*;
</pre>
<p> たとえば、クラス java.lang.Math には便利な数学関数が定義されていますが、static import すれば Math を省略してアクセスすることができます。
</p>
<pre class="list">
リスト : import static の使用例

import static java.lang.Math.*;

public class sample161 {
  public static void main(String[] args) {
    System.out.println(sqrt(2.0));
    System.out.println(PI);
  }
}
</pre>
<pre>
C&gt;java sample161
1.4142135623730951
3.141592653589793
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">immutable な連結リスト</h3>
<h4>●不変データ構造</h4>
<p> パッケージの簡単な例題として immutable な連結リストを作ってみました。Java の場合、フィールド変数を final で宣言すると、コンストラクタで初期化する以外に値を変更することができなくなります。さらに、class を final 宣言して継承を禁止すると、新しいサブクラスを作って mutable なフィールド変数を追加することができなくなります。これで immutable なデータ構造 (不変データ構造) を作ることができるように思われますが、実はそう簡単ではありません。
</p>
<h4>●実装上の問題点</h4>
<p> 格納する要素が immutable なデータ (String や基本データ型) であれば問題ないのですが、mutable なデータ (オブジェクト) を格納すると、そのデータ構造は immutable ではなくなります。たとえば、データ構造 xs にオブジェクトの参照を返すメソッド get() があるとしましょう。オブジェクトのセッターを setX(...) とすると、xs.get().setX(...) でオブジェクトの値を更新することが可能です。つまり、データ構造 xs の値を書き換えることができるわけです。
</p>
<p> この問題を解決するため、データ構造を生成するときに格納するオブジェクトをコピーする、参照を返すときにもコピーを作るといった方法があるのですが、今回は簡単な例題ということで、mutable なオブジェクトを格納するときは連結リストの不変性を放棄することにします。つまり、不変データ構造として使いたい場合は、プログラマの責任で immutable なデータを入れてください、ということにします。

<p> あくまでも学習が目的のライブラリなので、実用性はほとんどありませんが、興味のある方はいろいろ試してみてください。
</p>
<h4 id="update">●修正 (2016/12/25)</h4>
<ul>
  <li>再帰呼び出しをループに修正
    <ul>
      <li>フィールド変数 next の final を削除
      <li>リストを破壊的に反転する private なメソッド nreverse を追加
    </ul>
  <li>メソッド tabulate, member, memberIf, takeWhile, dropWhile を追加
</ul>
<h4>●連結リストの仕様</h4>
<ul>
  <li>パッケージ名 : immutable
  <li>クラス名 : ImList&lt;E&gt;
  <li>リストの生成 (スタティックメソッド)
    <ul>
      <li>&lt;E&gt; ImList&lt;E&gt; cons(E x, ImList&lt;E&gt; xs)<br>
リスト xs の先頭に要素 x を追加する (Lisp の cons と同じ)
      <li>&lt;E&gt; ImList&lt;E&gt; of(E... args)<br>
要素 args を格納したリストを返す
      <li>&lt;E&gt; ImList&lt;E&gt; fill(int n, E x)<br>
要素 x を n 個格納したリストを返す
      <li>ImList&lt;Integer&gt; iota(int n, int m)<br>
n 以上 m 以下の整数列を返す
      <li>&lt;E&gt; ImList&lt;E&gt; tabulate(int n, Function&lt;Integer, ? extends E&gt; func)<br>
0 から n - 1 までの整数列を生成して要素にメソッド func を適用し、その結果をリストに格納して返す
      <li>&lt;T, U, V&gt; ImList&lt;V&gt; zipWith(BiFunction&lt;? super T, ? super U, ? extends V&gt; func, ImList&lt;T&gt; xs, ImList&lt;U&gt; ys)<br>
リスト xs と ys の要素をメソッド func に適用し、その結果をリストに格納して返す
      <li>&lt;E&gt; ImList&lt;E&gt; nil()<br>
空リストを返す
    </ul>
  <li>リストの操作
    <ul>
      <li>boolean isEmpty()<br>
空リストならば真を返す (Lisp の null と同じ)
      <li>E first()<br>
先頭要素を返す (Lisp の car と同じ)
      <li>ImList&lt;E&gt; rest()<br>
先頭要素を取り除いたリストを返す (Lisp の cdr と同じ)
      <li>E last()<br>
末尾の要素を返す
      <li>E get(int n)<br>
n 番目の要素を返す (先頭要素は 0 番目)
      <li>ImList&lt;E&gt; add(int n, E x)<br>
n 番目に要素 x を挿入した新しいリストを返す
      <li>ImList&lt;E&gt; remove(int n)<br>
n 番目の要素を削除した新しいリストを返す
      <li>int length()<br>
リストの長さを求める
      <li>ImList&lt;E&gt; append(ImList&lt;E&gt; ys)<br>
自分自身 (this) とリスト ys を連結した新しいリストを返す
      <li>ImList&lt;E&gt; reverse()<br>
リストを反転する
      <li>ImList&lt;E&gt; take(int n)<br>
先頭から n 個の要素を取り出してリストに格納して返す
      <li>ImList&lt;E&gt; drop(int n)<br>
先頭から n 個の要素を取り除く
    </ul>
  <li>探索
    <ul>
      <li>boolean contains(E x)<br>
引数 x がリストに含まれている場合は真を、そうでなければ偽を返す
      <li>int indexOf(E x)<br>
引数 x を探索して、その位置を返す。見つからない場合は -1 を返す
      <li>Optional&lt;E&gt; findIf(Predicate&lt;? super E&gt; pred)<br>
述語 pred が真を返す要素を探索する
      <li>ImList&lt;E&gt; member(E x)<br>
引数 x を探索して、x 以降のリストを返す。見つからない場合は空リストを返す
      <li>ImList&lt;E&gt; memberIf(Predicate&lt;? super E&gt; pred)<br>
述語 pred が真を返す要素を探索して、見つけた要素以降のリストを返す。見つからない場合は空リストを返す
      <li>ImList&lt;E&gt; takeWhile(Predicate&lt;? super E&gt; pred)<br>
述語 pred が真を返す間、先頭から要素を取り出す
      <li>ImList&lt;E&gt; dropWhile(Predicate&lt;? super E&gt; pred)<br>
述語 pred が真を返す間、先頭から要素を取り除く
    </ul>
  <li>高階関数
    <ul>
      <li>&lt;U&gt; ImList&lt;U&gt; map(Function&lt;? super E, ? extends U&gt; func)<br>
リストの要素にメソッド func を適用し、その結果をリストに格納して返す (マッピング)
      <li>&lt;U&gt; ImList&lt;U&gt; flatMap(Function&lt;? super E, ImList&lt;U&gt;&gt; func)<br>
リストの要素に func を適用し、その結果 (リスト) を連結して返す
      <li>ImList&lt;E&gt; filter(Predicate&lt;? super E&gt; pred)<br>
述語 pred が真を返す要素をリストに格納して返す
      <li>&lt;U&gt; U foldLeft(BiFunction&lt;U, ? super E, U&gt; func, U a)<br>
リストの先頭から畳み込みを行う
      <li>&lt;U&gt; U foldRight(BiFunction&lt;? super E, U, U&gt; func, U a)<br>
リストの末尾から畳み込みを行う
      <li>void forEach(Consumer&lt;? super E&gt; func)<br>
リストの要素にメソッド func を適用する
      <li>boolean allMatch(Predicate&lt;? super E&gt; pred)<br>
リストの要素に述語 pred を適用し、すべて真を返せば真を返す。
      <li>boolean anyMatch(Predicate&lt;? super E&gt; pred)<br>
リストの要素に述語 pred を適用し、ひとつでも真を返せば真を返す。
    </ul>
  <li>集合演算
    <ul>
      <li>ImList&lt;E&gt; distinct()<br>
重複要素を取り除いた新しいリストを返す
      <li>ImList&lt;E&gt; union(ImList&lt;E&gt; ys)<br>
和集合を求める
      <li>ImList&lt;E&gt; intersection(ImList&lt;E&gt; ys)<br>
積集合を求める
      <li>ImList&lt;E&gt; difference(ImList&lt;E&gt; ys)<br>
差集合を求める
      <li>boolean isSubset(ImList&lt;E&gt; ys)<br>
自分自身 (this) が引数 ys の部分集合ならば真を返す
    </ul>
  <li>その他
    <ul>
      <li>Iterator&lt;E&gt; iterator()<br>
イテレータを生成して返す
      <li>String toString()<br>
リストを文字列に変換する
    </ul>
</ul>
<h4>●プログラムリスト</h4>
<pre class="list">
//
// ImList.java : immutable な連結リスト
//
//               Copyright (C) 2016 Makoto Hiroi
//
package immutable;

import java.util.*;
import java.util.function.*;

public final class ImList&lt;E&gt; implements Iterable&lt;E&gt; {
  private final E item;
  private ImList&lt;E&gt; next;

  private ImList(E x, ImList&lt;E&gt; y) {
    item = x;
    next = y;
  }

  // 終端
  private static final ImList&lt;?&gt; NIL = new ImList&lt;&gt;(null, null);

  public static &lt;E&gt; ImList&lt;E&gt; nil() {
    @SuppressWarnings("unchecked")
    ImList&lt;E&gt; t = (ImList&lt;E&gt;)NIL;
    return t;
  }

  public boolean isEmpty() { return this == NIL; }

  // リストの生成
  public static &lt;E&gt; ImList&lt;E&gt; cons(E x, ImList&lt;E&gt; y) {
    return new ImList&lt;E&gt;(x , y);
  }
  
  @SafeVarargs
  public static &lt;E&gt; ImList&lt;E&gt; of(E... args) {
    ImList&lt;E&gt; xs = nil();
    for (int i = args.length - 1; i &gt;= 0; i--) {
      xs = cons(args[i], xs);
    }
    return xs;
  }

  public static &lt;E&gt; ImList&lt;E&gt; fill(int n, E x) {
    ImList&lt;E&gt; xs = nil();
    while (n-- &gt; 0) xs = cons(x, xs);
    return xs;
  }

  public static &lt;E&gt; ImList&lt;E&gt; tabulate(int n, Function&lt;Integer, ? extends E&gt; func) {
    ImList&lt;E&gt; xs = nil();
    while (--n &gt;= 0) {
      xs = cons(func.apply(n), xs);
    }
    return xs;
  }
  
  public static ImList&lt;Integer&gt; iota(int n, int m) {
    ImList&lt;Integer&gt; xs = nil();
    while (m &gt;= n) xs = cons(m--, xs);
    return xs;
  }

  public static &lt;T, U, V&gt; ImList&lt;V&gt; zipWith(BiFunction&lt;? super T, ? super U, ? extends V&gt; func, ImList&lt;T&gt; xs, ImList&lt;U&gt; ys) {
    ImList&lt;V&gt; zs = nil();
    while (xs != NIL &amp;&amp; ys != NIL) {
      zs = cons(func.apply(xs.first(), ys.first()), zs);
      xs = xs.rest();
      ys = ys.rest();
    }
    return zs.nreverse();
  }
  
  //
  // 基本操作
  //

  // 先頭要素
  public E first() {
    if (this == NIL)
      throw new IndexOutOfBoundsException("ImList.first()");
    return item;
  }

  // 先頭要素を取り除いたリスト
  public ImList&lt;E&gt; rest() {
    if (this == NIL)
      throw new IndexOutOfBoundsException("ImList.rest()");
    return next;
  }

  // 最後の要素
  public E last() {
    ImList&lt;E&gt; xs = this;
    if (xs == NIL)
      throw new IndexOutOfBoundsException("ImList.last()");
    while (xs.rest() != NIL) xs = xs.rest();
    return xs.first();
  }

  // n 番目の要素
  public E get(int n) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (n-- == 0) return xs.first();
      xs = xs.rest();
    }
    throw new IndexOutOfBoundsException("ImList.get()");
  }

  // n 番目に要素を追加
  public ImList&lt;E&gt;add(int n, E x) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    if (n == 0) return cons(x, xs);
    while (n-- &gt; 0) {
      ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    ImList&lt;E&gt; zs = ys.nreverse();
    ys.next = cons(x, xs);
    return zs;
  }

  // n 番目の要素を削除
  public ImList&lt;E&gt; remove(int n) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    if (n == 0) return xs.rest();
    while (n-- &gt; 0) {
      ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    ImList&lt;E&gt; zs = ys.nreverse();
    ys.next = xs.rest();
    return zs;
  }

  // 長さを求める
  public int length() {
    ImList&lt;E&gt; xs = this;
    int c = 0;
    while (xs != NIL) {
      c++;
      xs = xs.rest();
    }
    return c;
  }

  // 連結
  public ImList&lt;E&gt; append(ImList&lt;E&gt; ys) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; zs = nil();
    if (xs == NIL) return ys;
    while (xs != NIL) {
      zs = cons(xs.first(), zs);
      xs = xs.rest();
    }
    xs = zs.nreverse();
    zs.next = ys;
    return xs;
  }

  // 反転
  public ImList&lt;E&gt; reverse() {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    while (xs != NIL) {
      ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    return ys;
  }

  // 破壊的な反転
  private ImList&lt;E&gt; nreverse() {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    while (xs != NIL) {
      ImList&lt;E&gt; zs = xs.rest();
      xs.next = ys;
      ys = xs;
      xs = zs;
    }
    return ys;
  }
  
  // 先頭から n 個の要素を取り出す
  public ImList&lt;E&gt; take(int n) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    while (n -- &gt; 0 &amp;&amp; xs != NIL) {
      ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    return ys.nreverse();
  }

  // 先頭から n 個の要素を取り除く
  public ImList&lt;E&gt; drop(int n) {
    ImList&lt;E&gt; xs = this;
    while (n-- &gt; 0 &amp;&amp; xs != NIL) xs = xs.rest();
    return xs;
  }

  // 探索
  public int indexOf(E x) {
    int i = 0;
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (x.equals(xs.first())) return i;
      i++;
      xs = xs.rest();
    }
    return -1;
  }

  public boolean contains(E x) {
    return indexOf(x) &gt;= 0;
  }

  public Optional&lt;E&gt; findIf(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (pred.test(xs.first())) return Optional.of(xs.first());
      xs = xs.rest();
    }
    return Optional.empty();
  }

  public ImList&lt;E&gt; member(E x) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (x.equals(xs.first())) break;
      xs = xs.rest();
    }
    return xs;
  }
  
  public ImList&lt;E&gt; memberIf(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (pred.test(xs.first())) break;
      xs = xs.rest();
    }
    return xs;
  }

  public ImList&lt;E&gt; takeWhile(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    while (xs != NIL) {
      if (pred.test(xs.first()))
        ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    return ys.nreverse();
  }

  public ImList&lt;E&gt; dropWhile(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (!pred.test(xs.first())) break;
      xs = xs.rest();
    }
    return xs;
  }
  
  //
  // 高階関数
  //

  // マッピング
  public &lt;U&gt; ImList&lt;U&gt; map(Function&lt;? super E, ? extends U&gt; func) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;U&gt; ys = ImList.nil();
    while (xs != NIL) {
      ys = cons(func.apply(xs.first()), ys);
      xs = xs.rest();
    }
    return ys.nreverse();
  }

  public &lt;U&gt; ImList&lt;U&gt; flatMap(Function&lt;? super E, ImList&lt;U&gt;&gt; func) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;ImList&lt;U&gt;&gt; ys = ImList.nil();
    while (xs != NIL) {
      ys = cons(func.apply(xs.first()), ys);
      xs = xs.rest();
    }
    ImList&lt;U&gt; zs = nil();
    while (ys != NIL) {
      zs = ys.first().append(zs);
      ys = ys.rest();
    }
    return zs;
  }

  // フィルター
  public ImList&lt;E&gt; filter(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = ImList.nil();
    while (xs != NIL) {
      if (pred.test(xs.first())) ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    return ys.nreverse();
  }

  // 畳み込み
  public &lt;U&gt; U foldLeft(BiFunction&lt;U, ? super E, U&gt; func, U a) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      a = func.apply(a, xs.first());
      xs = xs.rest();
    }
    return a;
  }

  public &lt;U&gt; U foldRight(BiFunction&lt;? super E, U, U&gt; func, U a) {
    ImList&lt;E&gt; xs = this.reverse();
    while (xs != NIL) {
      a = func.apply(xs.first(), a);
      xs = xs.rest();
    }
    return a;
  }
  
  // 巡回
  public void forEach(Consumer&lt;? super E&gt; func) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      func.accept(xs.first());
      xs = xs.rest();
    }
  }

  // 述語
  public boolean allMatch(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (!pred.test(xs.first())) return false;
      xs = xs.rest();
    }
    return true;
  }

  public boolean anyMatch(Predicate&lt;? super E&gt; pred) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (pred.test(xs.first())) return true;
      xs = xs.rest();
    }
    return false;
  }

  //
  // 集合演算
  //
  
  // 重複要素を取り除く
  public ImList&lt;E&gt; distinct() {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; ys = nil();
    while (xs != NIL) {
      if (!ys.contains(xs.first()))
        ys = cons(xs.first(), ys);
      xs = xs.rest();
    }
    return ys.nreverse();
  }

  // 和集合
  public ImList&lt;E&gt; union(ImList&lt;E&gt; ys) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; zs = ys;
    while (xs != NIL) {
      if (!ys.contains(xs.first()))
        zs = cons(xs.first(), zs);
      xs = xs.rest();
    }
    return zs;
  }

  // 積集合
  public ImList&lt;E&gt; intersection(ImList&lt;E&gt; ys) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; zs = ImList.nil();
    while(xs != NIL) {
      if (ys.contains(xs.first()))
        zs = cons(xs.first(), zs);
      xs = xs.rest();
    }
    return zs;
  }

  // 差集合
  public ImList&lt;E&gt; difference(ImList&lt;E&gt; ys) {
    ImList&lt;E&gt; xs = this;
    ImList&lt;E&gt; zs = ImList.nil();
    while(xs != NIL) {
      if (!ys.contains(xs.first()))
        zs = cons(xs.first(), zs);
      xs = xs.rest();
    }
    return zs;
  }

  // 部分集合
  public boolean isSubset(ImList&lt;E&gt; ys) {
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      if (!ys.contains(xs.first())) return false;
      xs = xs.rest();
    }
    return true;
  }
  
  // イテレータ
  public Iterator&lt;E&gt; iterator() {
    // 無名クラス
    return new Iterator&lt;E&gt;() {
      ImList&lt;E&gt; xs = ImList.this;
      public boolean hasNext() { return xs != NIL; }
      public E next() {
        E item = xs.first();
        xs = xs.rest();
        return item;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }

  // 文字列に変換
  public String toString() {
    String s = "(";
    ImList&lt;E&gt; xs = this;
    while (xs != NIL) {
      s += xs.first().toString();
      if (xs.rest() != NIL) s += " ";
      xs = xs.rest();
    }
    s += ")";
    return s;
  }
}
</pre>
<h4>●簡単なテスト</h4>
<pre class="list">
リスト : 簡単なテスト

import immutable.*;
import static immutable.ImList.*;

public class testimlist {
  public static void main(String[] args) {
    ImList&lt;Integer&gt; xs = nil();
    System.out.println(xs);
    System.out.println(xs.isEmpty());
    for (int i = 0; i &lt; 10; i++) xs = cons(i, xs);
    System.out.println(xs);
    System.out.println(xs.isEmpty());
    System.out.println(xs.first());
    System.out.println(xs.rest());
    System.out.println(xs.rest().first());
    System.out.println(xs.rest().rest().first());
    System.out.println(xs.rest().rest().rest().first());
    xs = fill(5, 0);
    System.out.println(xs);
    xs = of(1, 3, 5, 7, 9);
    System.out.println(xs);
    xs = tabulate(5, x -&gt; x * x);
    System.out.println(xs);
    xs = zipWith((x, y) -&gt; x * y, of(1, 3, 5, 7, 9), of(2, 4, 6, 8, 10));
    System.out.println(xs);
    xs = iota(1, 10);
    System.out.println(xs);
    for (int i = 0; i &lt; xs.length(); i++)
      System.out.println(xs.get(i));
    System.out.println(xs.last());
    System.out.println(xs.add(0, 100));
    System.out.println(xs.add(5, 100));
    System.out.println(xs.add(10, 100));
    System.out.println(xs.remove(0));
    System.out.println(xs.remove(4));
    System.out.println(xs.remove(9));
    System.out.println(xs.append(xs));
    System.out.println(xs.reverse());
    for (int i = 0; i &lt;= 10; i++) {
      System.out.println(xs.take(i));
      System.out.println(xs.drop(i));
    }
    for (int i = 0; i &lt;= 11; i++) {
      final int j = i;
      System.out.println(xs.indexOf(i));
      System.out.println(xs.contains(i));
      System.out.println(xs.findIf(x -&gt; x == j));
      System.out.println(xs.member(i));
      System.out.println(xs.memberIf(x -&gt; x == j));
    }
    System.out.println(xs.takeWhile(x -&gt; x &lt; 5));
    System.out.println(xs.dropWhile(x -&gt; x &lt; 5));
    System.out.println(xs.map(x -&gt; x * x));
    System.out.println(xs.flatMap(x -&gt; ImList.of(x, x)));
    System.out.println(xs.filter(x -&gt; x % 2 == 0));
    System.out.println(xs.foldLeft((a, x) -&gt; a + x, 0));
    System.out.println(xs.foldLeft((a, x) -&gt; cons(x, a), nil()));
    System.out.println(xs.foldRight((x, a) -&gt; a + x, 0));
    System.out.println(xs.foldRight((x, a) -&gt; cons(x, a), nil()));
    xs.forEach(System.out::println);
    System.out.println(xs.allMatch(x -&gt; x &lt;= 10));
    System.out.println(xs.allMatch(x -&gt; x &lt; 10));
    System.out.println(xs.anyMatch(x -&gt; x == 10));
    System.out.println(xs.anyMatch(x -&gt; x == 0));
    for (int x: xs) System.out.print(x);
    System.out.println("");
    ImList&lt;Integer&gt; a = of(1, 2, 3, 4, 2, 3, 4, 3, 4, 4);
    ImList&lt;Integer&gt; b = a.distinct();
    System.out.println(b);
    ImList&lt;Integer&gt; c = of(3, 4, 5, 6);
    System.out.println(b.union(c));
    System.out.println(b.intersection(c));
    System.out.println(b.difference(c));
    System.out.println(b.isSubset(c));
    System.out.println(b.isSubset(b));
  }
}
</pre>
<pre>
C&lt;java testimlist
()
true
(9 8 7 6 5 4 3 2 1 0)
false
9
(8 7 6 5 4 3 2 1 0)
8
7
6
(0 0 0 0 0)
(1 3 5 7 9)
(0 1 4 9 16)
(2 12 30 56 90)
(1 2 3 4 5 6 7 8 9 10)
1
2
3
4
5
6
7
8
9
10
10
(100 1 2 3 4 5 6 7 8 9 10)
(1 2 3 4 5 100 6 7 8 9 10)
(1 2 3 4 5 6 7 8 9 10 100)
(2 3 4 5 6 7 8 9 10)
(1 2 3 4 6 7 8 9 10)
(1 2 3 4 5 6 7 8 9)
(1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10)
(10 9 8 7 6 5 4 3 2 1)
()
(1 2 3 4 5 6 7 8 9 10)
(1)
(2 3 4 5 6 7 8 9 10)
(1 2)
(3 4 5 6 7 8 9 10)
(1 2 3)
(4 5 6 7 8 9 10)
(1 2 3 4)
(5 6 7 8 9 10)
(1 2 3 4 5)
(6 7 8 9 10)
(1 2 3 4 5 6)
(7 8 9 10)
(1 2 3 4 5 6 7)
(8 9 10)
(1 2 3 4 5 6 7 8)
(9 10)
(1 2 3 4 5 6 7 8 9)
(10)
(1 2 3 4 5 6 7 8 9 10)
()
-1
false
Optional.empty
()
()
0
true
Optional[1]
(1 2 3 4 5 6 7 8 9 10)
(1 2 3 4 5 6 7 8 9 10)
1
true
Optional[2]
(2 3 4 5 6 7 8 9 10)
(2 3 4 5 6 7 8 9 10)
2
true
Optional[3]
(3 4 5 6 7 8 9 10)
(3 4 5 6 7 8 9 10)
3
true
Optional[4]
(4 5 6 7 8 9 10)
(4 5 6 7 8 9 10)
4
true
Optional[5]
(5 6 7 8 9 10)
(5 6 7 8 9 10)
5
true
Optional[6]
(6 7 8 9 10)
(6 7 8 9 10)
6
true
Optional[7]
(7 8 9 10)
(7 8 9 10)
7
true
Optional[8]
(8 9 10)
(8 9 10)
8
true
Optional[9]
(9 10)
(9 10)
9
true
Optional[10]
(10)
(10)
-1
false
Optional.empty
()
()
(1 2 3 4)
(5 6 7 8 9 10)
(1 4 9 16 25 36 49 64 81 100)
(1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10)
(2 4 6 8 10)
55
(10 9 8 7 6 5 4 3 2 1)
55
(1 2 3 4 5 6 7 8 9 10)
1
2
3
4
5
6
7
8
9
10
true
false
true
false
12345678910
(1 2 3 4)
(2 1 3 4 5 6)
(4 3)
(2 1)
false
true
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava15.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava17.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>