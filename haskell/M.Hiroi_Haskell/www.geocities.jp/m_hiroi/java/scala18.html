<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881778</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala17.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala19.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>パッケージ</h3>
<p> プログラムを作っていると、以前作った関数と同じ処理が必要になる場合があります。いちばんてっとり早い方法はソースファイルからその関数をコピーすることですが、賢明な方法とはいえません。このような場合、自分で作成した関数をライブラリとしてまとめておくと便利です。ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、同じ名前の関数や変数が存在すると、そのライブラリは正常に動作しないでしょう。この問題は「パッケージ (package) 」を使うと解決することができます。
</p>

<h4>●パッケージの宣言</h4>
<p> Scala は Java と同様に、パッケージの中に複数のクラス (class) やオブジェクト (object) を定義することができます。パッケージは package 文で宣言します。package 文がない場合は無名のパッケージとして扱われます。package 文の構文を示します。
</p>
<pre class="item">
package 名前 {
  ...
}
</pre>
<p> Java と違い、Scala は一つのファイルに複数のパッケージを記述することができます。<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : パッケージの使用例 (1)

package foo {
  class Foo {
    val x = 1
  }
}
</pre>
<p> ファイル foo.scala に package foo を宣言し、その中でクラス Foo を定義します。このプログラムは package の { } を省略して、次のように記述することができます。
</p>
<pre class="list">
リスト : パッケージの使用例 (2)

package foo

class Foo {
  val x = 1
}
</pre>
<p> scalac で foo.scala をコンパイルすると、サブディレクトリ foo が作成され、その中にコンパイルされた Foo.class が格納されます。クラス Foo を使用するときは、パッケージ名を前に付けて foo.Foo とします。Java と同様に、区切り記号にはドット ( . ) を使います。これを完全修飾名といいます。import 文を使うと、Foo だけで使用することができます。これはあとで説明します。
</p>

<h4>●パッケージの入れ子</h4>
<p> パッケージは入れ子にすることができます。
</p>
<pre class="list">
リスト : パッケージの入れ子 (1)

package foo {
  class Foo {
    val x = 1
  }

  package bar {
    class Bar {
      val y = 2
    }
  }
}
</pre>
<p> このプログラムも package の { } を省略して、次のように記述してもかまいません。
</p>
<pre class="list">
リスト : パッケージの入れ子 (2)

package foo 

class Foo {
  val x = 1
}

package bar

class Bar {
  val y = 2
}
</pre>
<p> このプログラムをコンパイルすると、サブディレクトリ foo の中にサブディレクトリ bar が作成され、その中に Bar.class が格納されます。クラス Foo のアクセスは foo.Foo で、クラス Bar のアクセスは foo.bar.Bar となります。
</p>

<h4>●一つのファイルに複数のパッケージを定義する</h4>
<p> Scala は一つのファイルに複数のパッケージを記述することができます。また、次のようにパッケージ名をドットで区切ることもできます。
</p>
<pre class="list">
リスト : 複数のパッケージ

package foo {
  class Foo {
    val x = 1
  }

  package bar {
    class Bar {
      val y = 2
    }
  }
}

package baz {
  class Baz {
    val z = 3
  }
}

package baz.oops {
  class Oops {
    val mes = "oops"
  }
}
</pre>
<p> Baz.class はサブディレクトリ baz の中に、Oops.class は baz の中のサブディレクトリ oops の中に格納されます。
</p>

<h4>●import 文</h4>
<p> パッケージ内のクラスは import 文を使うと簡単に使用できるようになります。次の例を見てください。
</p>
<pre>
scala&gt; new foo.Foo
res0: foo.Foo = foo.Foo@1488b16

scala&gt; import foo.Foo
import foo.Foo

scala&gt; new Foo
res1: foo.Foo = foo.Foo@a2bc93

scala&gt; import foo.bar._
import foo.bar._

scala&gt; new Bar
res2: foo.bar.Bar = foo.bar.Bar@34211

scala&gt; new foo.bar.Bar
res3: foo.bar.Bar = foo.bar.Bar@1e7a160
</pre>
<p> クラス Foo は foo.Foo で使用することができます。import foo.Foo とすると、REPL の名前空間に Foo がインポートされて、完全修飾名ではなく Foo だけで使用することができます。アンダーバー ( _ ) を使うと、パッケージに定義されているクラスをすべてインポートすることができます。これは Java の * と同じ機能です。import foo.bar._ でパッケージ foo.bar で定義されているクラスやオブジェクトをすべてインポートすることができます。
</p>

<h4>●import 文の便利な機能</h4>
<p> パッケージの中で特定のクラスだけをインポートすることもできます。
</p>
<pre class="item">
import パッケージ名.{クラス1, クラス2, ... }
</pre>
<p> { } の中でインポートするクラスを指定します。簡単な例を示しましょう。
</p>
<pre class="list">
リスト : パッケージ foo1

package foo1

class Foo {
  val x = 1
}

class Bar {
  val y = 2
}

class Baz {
  val z = 3
}
</pre>
<pre>
scala&gt; import foo1.{Foo, Bar}
import foo1.{Foo, Bar}

scala&gt; new Foo
res0: foo1.Foo = foo1.Foo@11d1f8b

scala&gt; new Bar
res1: foo1.Bar = foo1.Bar@44f2a5

scala&gt; new Baz
&lt;console&gt;:9: error: not found: type Baz
              new Baz
                  ^

scala&gt; new foo1.Baz
res3: foo1.Baz = foo1.Baz@167d97b
</pre>

<p> インポートするとき、クラスに別名を付けることもできます。
</p>
<pre class="item">
import パッケージ名.{クラス名1 =&gt; 別名, ...}
</pre>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; import foo1.{Foo =&gt; Oops}
import foo1.{Foo=&gt;Oops}

scala&gt; new Oops
res0: foo1.Foo = foo1.Foo@1bf6d0e

scala&gt; new foo1.Foo
res1: foo1.Foo = foo1.Foo@1627d13

scala&gt; new Foo
&lt;console&gt;:9: error: not found: type Foo
              new Foo
                  ^
</pre>
<p> また、次のようにアンダーバーと組み合わせて、残りのクラスをすべてインポートすることもできます。
</p>
<pre>
scala&gt; import foo1.{Foo =&gt; Oops, _}
import foo1.{Foo=&gt;Oops, _}

scala&gt; new Oops
res0: foo1.Foo = foo1.Foo@5d38da

scala&gt; new Bar
res1: foo1.Bar = foo1.Bar@f782af

scala&gt; new Baz
res2: foo1.Baz = foo1.Baz@1c03d88
</pre>

<h4>●オブジェクトのインポート</h4>
<p> シングルトンオブジェクトをインポートすることもできます。簡単な例を示しましょう。
</p>
<pre>
scala&gt; object Foo {
     | var x = 1
     | def getX: Int = x
     | def putX(a: Int): Unit = x = a
     | }
defined object Foo

scala&gt; Foo.x
res0: Int = 1

scala&gt; Foo.getX
res1: Int = 1

scala&gt; Foo.putX(10)

scala&gt; import Foo._
import Foo._

scala&gt; x
res3: Int = 10

scala&gt; getX
res4: Int = 10

scala&gt; putX(100)

scala&gt; x
res6: Int = 100
</pre>
<p> アンダーバーを使って、シングルトンオブジェクトに定義されている変数や関数をすべてインポートすることができます。また、インポートする関数や変数を指定することもできます。
</p>
<pre>
scala&gt; object Bar {
     | val x = 10
     | val y = 20
     | def getX: Int = x
     | def getY: Int = y
     | }
defined object Bar

scala&gt; import Bar.{getX =&gt; getBX, getY}
import Bar.{getX=&gt;getBX, getY}

scala&gt; getBX
res7: Int = 10

scala&gt; getY
res8: Int = 20
</pre>
<p> Bar のメソッド getX は名前を getBX に変えてインポートし、メソッド getY はそのままインポートしています。
</p>
<p> ちなみに、print や prntln はシングルトンオブジェクト Predef に定義されています。Scala は Predef を含め 3 つのパッケージ (やオブジェクト) を暗黙のうちにインポートしています。
</p>
<pre class="item">
import java.lang._  // Java の基本クラス
import scala._      // scala の基本クラス
import Predef._     // Predef オブジェクト
</pre>

<h4>●パッケージオブジェクト</h4>
<p> パッケージオブジェクトは、パッケージをシングルトンオブジェクトのように扱うための機能です。
</p>
<pre class="item">
package object 名前 {
  ...
}
</pre>
<p> package object の後ろに名前を指定し、{ ... } の中にフィールド変数やメソッド、クラスを定義します。同じパッケージ内でクラスを定義する場合、パッケージオブジェクトの変数やメソッドは、パッケージ名をつけなくてもアクセスすることができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : パッケージオブジェクト

package pack

package object foo {
  val x = 1
  def getX: Int = x

  class Foo {
    val y = 2
    def foo: Int = x + y
  }
}
</pre>
<p> pack.foo はパッケージオブジェクトです。クラス Foo は pack.foo に定義されているので、フィールド変数 x は修飾名を付けなくてもアクセスすることができます。上記プログラムは、次のように 2 つのファイルに分割することもできます。
</p>

<pre class="list">
リスト : パッケージオブジェクト (2)

//
// pack.scala
//
package pack

package object foo {
  val x = 1
  def getX: Int = x
}

//
// packFoo.scala
//
package pack.foo {
  class Foo {
    val y = 2
    def foo: Int = x + y
  }
}
</pre>
<p> クラス Foo はパッケージオブジェクト foo.bar の中で定義されているので、異なるファイルに分割されていても、完全修飾名なしでフィールド変数 x を参照することができます。
</p>
<p> パッケージオブジェクトはパッケージと同様に import 文でインポートすることができます。
</p>
<pre>
C&gt;scalac pack.scala

C&gt;scalac packFoo.scala

C&gt;scala
Welcome to Scala version 2.11.1 (Java HotSpot(TM) Clie
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import pack.foo._
import pack.foo._

scala&gt; x
res0: Int = 1

scala&gt; getX
res1: Int = 1

scala&gt; val a = new Foo
a: pack.foo.Foo = pack.foo.package$Foo@15606db

scala&gt; a.foo
res2: Int = 3
</pre>
<h4>●スコープ限定子</h4>
<p> Scala のアクセス制御は、private, protected, 指定無し (public) の 3 通りの方法がありますが、このほかにも「スコープ限定子」という機能があります。これは private, protected のあとに角カッコで公開するクラス (オブジェクト) やパッケージを指定する機能です。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : スコープ限定子

package foo {
  class Foo {
    private[foo] var x = 1
  }

  class Bar {
    var y = 2
    def getX(a: Foo): Int = a.x
  }
}

object sample1801 {
  def main(args: Array[String]) {
    val a = new foo.Foo
    val b = new foo.Bar
    println(b.getX(a))
  }
}
</pre>
<pre>
C&gt;scalac sample1801.scala

C&gt;scala sample1801
1
</pre>
<p> private で指定されたクラス Foo のフィールド変数 x は、他のクラスからアクセスすることはできませんが、private[foo] と指定すると、パッケージ foo に定義されているクラスであればアクセスすることができます。したがって、Bar のメソッド getX は Foo のフィールド変数 x を参照することができます。
</p>

<p> private[this] というように this を指定をすると、同じインスタンスしかアクセスすることができなくなります。つまり、クラスが同じでも異なるインスタンスであれば、アクセスすることができなくなります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : スコープ限定子 (2)

class Foo {
  private[this] var x = 1
  def getX: Int = x
  def putX(a: Int): Unit = x = a

  def foo(): Int = (new Foo).x
}

object sample1802 {
  def main(args: Array[String]) {
    val a = new Foo
    println(a.getX)
    println(a.foo)
  }
}
</pre>
<pre>
C&gt;scalac sample1802.scala
sample1802.scala:6: error: value x is not a member of Foo
  def foo(): Int = (new Foo).x
                             ^
one error found
</pre>
<p> Foo のメソッド foo は、Foo のインスタンスを生成して、そのフィールド変数 x にアクセスしています。ところが、変数 x にはスコープ限定子 this が指定されているので、メソッド foo は異なるインスタンス (new Foo) の変数 x を参照することはできません。コンパイルでエラーになります。
</p>
<p> protected にもスコープ限定子を指定することができます。protected[scope] は、自クラスとそのサブクラス、scope で指定したものにアクセス権限が与えられます。protected[this] は、自クラスについては private[this] と同じですが、サブクラスからアクセスすることは可能です。
</p>

<h4>●シールドクラス</h4>
<p> パッケージと直接関係はありませんが、もう一つアクセス制御の機能を紹介しましょう。class の前に sealed を付けると、そのクラスは「シールドクラス」に設定されます。シールドクラスと同一ファイルにあるクラスは、シールドクラスを継承することができますが、別ファイルのクラスはシールドクラスを継承することができません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 図形のクラス (figure.scala)

package figure

sealed abstract class Figure {
  def kindOf: String
}

case class Triangle() extends Figure {
  def kindOf(): String = "Triangle"
}

case class Rectangle() extends Figure {
  def kindOf(): String = "Rectangle"
}

case class Circle() extends Figure {
  def kindOf(): String = "Circle"
}
</pre>
<p> 抽象クラス Figure はシールドクラスなので、ファイル figure.scala 内では Figure を継承した case クラスを作ることができます。次のように、パターンマッチングを使って図形の種類ごとに個数を数えるプログラムを作ることができます。
</p>
<pre class="list">
リスト : 図形をカウントする (sample1804.scala)

import figure._

object sample1803 {
  def countFigure(xs: List[Figure]): List[Int] = {
    var a = 0
    var b = 0
    var c = 0
    for (x &lt;- xs) {
      x match {
        case Triangle() =&gt; a += 1
        case Rectangle() =&gt; b += 1
        // case Circle() =&gt; c += 1  warning!!
      }
    }
    List(a, b, c)
  }

  def main(args: Array[String]) {
    println(countFigure(List(new Circle(), new Rectangle(), new Triangle(),
                            new Rectangle(), new Triangle(), new Rectangle())))
  }
}
</pre>
<p> ここで、パターンマッチングに漏れがあることに注意してください。シールドクラスの場合、パターンマッチングに漏れがあると警告が表示されます。
</p>
<pre>
C&gt;scalac figure.scala

C&gt;scalac sample1803.scala
sample1803.scala:9: warning: match may not be exhaustive.
It would fail on the following input: Circle()
      x match {
      ^
one warning found

C&gt;scala sample1803
scala.MatchError: Circle() (of class Circle)
</pre>
<p> 警告を無視して実行すると、実行時に MatchError が送出されます。コメントを有効にして、パターンマッチングに漏れをなくすと正常に実行することができます。
</p>
<pre>
C&gt;scalac sample1803.scala

C&gt;scala sample1803
List(2, 3, 1)
</pre>
<p> また、次のように別ファイルで Figure を継承した case class を作るとコンパイルエラーになります。
</p>
<pre class="list">
リスト : 図形をカウントする (sample1804.scala)

import figure._

case class Pentagon() extends Figure {
  def kindOf: String = "Pentagon"
}

object sample1804 {
  def countFigure(xs: List[Figure]): List[Int] = {
    var a = 0
    var b = 0
    var c = 0
    var d = 0
    for (x &lt;- xs) {
      x match {
        case Triangle() =&gt; a += 1
        case Rectangle() =&gt; b += 1
        case Circle() =&gt; c += 1
        case Pentagon() =&gt; d += 1
      }
    }
    List(a, b, c, d)
  }

  def main(args: Array[String]) {
    println(countFigure(List(new Circle(), new Rectangle(), new Triangle(),
                            new Rectangle(), new Triangle(), new Rectangle())))
  }
}
</pre>
<pre>
C&gt;scalac sample1804.scala
sample1804.scala:3: error: illegal inheritance from sealed class Figure
case class Pentagon() extends Figure {
                              ^
one error found
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">列 (Seq)</h3>
<p> 今回は「列 (Seq) 」について説明します。Seq は「シーケンス (sequence) 」の略で、要素を順番に並べたコレクションのことを「列」といいます。Scala の場合、列は Seq トレイトとして定義されていて、Seq を継承 (Mix-in) しているデータ型であれば、列として統一的に扱うことができます。
</p>

<h4>●リストと列の違い</h4>
<p> 列の代表的なデータがリスト (List) ですが、リストのコンス演算子 (::) と連結演算子 (:::) は Seq トレイトにはありません。列の先頭に要素を追加するには演算子 +: を使い、列の末尾に要素を追加するには演算子 :+ を使います。列を連結する場合は演算子 ++ を使います。もちろん、これらの演算子はリストにも適用することができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = List(1, 2, 3, 4, 5)
a: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; 0 +: a
res0: List[Int] = List(0, 1, 2, 3, 4, 5)

scala&gt; a :+ 6
res1: List[Int] = List(1, 2, 3, 4, 5, 6)

scala&gt; a ++ List(6, 7, 8, 9)
res2: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>

<h4>●不変 (immutable) な列</h4>
<p> 不変な列は、リスト以外ではおもに String, Range, Vector などがあります。String と Range は今までもよく使ってきましたが、Vector (ベクタ、ベクトル) は初めでなので簡単に説明しましょう。
</p>
<p> リストの要素を参照する場合、セルを順番にたどっていく必要があるので、後ろの要素ほど時間がかかるようになります。Vector はこれを改良したデータ構造で、要素の参照はほぼ一定時間で行うことができるようになっています。他のプログラミング言語、たとえば Scheme では一次元配列のことをベクタと呼びますが、Scala のベクタは配列ではありません。したがって、要素の参照は配列よりも時間がかかります。ご注意ください。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val b = Vector(1, 2, 3, 4, 5)
b: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5)

scala&gt; b(0)
res3: Int = 1

scala&gt; b(4)
res4: Int = 5

scala&gt; 0 +: b
res5: scala.collection.immutable.Vector[Int] = Vector(0, 1, 2, 3, 4, 5)

scala&gt; b :+ 6
res6: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6)

scala&gt; b ++ Vector(6, 7, 8, 9)
res7: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; b ++ List(6, 7, 8, 9)
res8: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; a ++ b
res9: List[Int] = List(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
</pre>
<p> もちろん、String にも Seq トレイトのメソッドを適用することができます。
</p>
<pre>
scala&gt; val c = "abcdefg"
c: String = abcdefg

scala&gt; c(0)
res10: Char = a

scala&gt; c(6)
res11: Char = g

scala&gt; 'A' +: c
res12: String = Aabcdefg

scala&gt; c :+ 'Z'
res13: String = abcdefgZ
</pre>

<h4>●列の生成</h4>
<p> 列の生成はコンパニオンオブジェクトの apply メソッドだけではなく、次に示すメソッドもコンパニオンオブジェクトに用意されています。
</p>
<pre class="item">
empty                         : 空の列を生成する。
concat(col1, col2, ...)       : 他のコレクションから列を生成する。
fill(大きさ)(値)              : 列を指定した値で満たす。
tabulate(大きさ)(関数)        : 添字に関数を適用して、返り値を列に格納して返す。
iterate(初期値, 大きさ)(関数) : 前の要素に関数を適用して、その返り値を列に格納して返す。
range(開始, 終了, [増分])     : 指定した範囲の数列を生成する。
</pre>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; List.empty[Int]
res0: List[Int] = List()

scala&gt; Vector.empty[Int]
res1: scala.collection.immutable.Vector[Int] = Vector()

scala&gt; List.concat(Vector(1, 2, 3, 4), List(5, 6, 7, 8))
res2: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; Vector.concat(Vector(1, 2, 3, 4), List(5, 6, 7, 8))
res3: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; List.fill(5)(0)
res4: List[Int] = List(0, 0, 0, 0, 0)

scala&gt; Vector.fill(5)(0)
res5: scala.collection.immutable.Vector[Int] = Vector(0, 0, 0, 0, 0)

scala&gt; List.tabulate(5)(x =&gt; x * x)
res6: List[Int] = List(0, 1, 4, 9, 16)

scala&gt; Vector.tabulate(5)(x =&gt; x * x)
res7: scala.collection.immutable.Vector[Int] = Vector(0, 1, 4, 9, 16)

scala&gt; List.iterate(1, 5)(x =&gt; x * 2)
res8: List[Int] = List(1, 2, 4, 8, 16)

scala&gt; Vector.iterate(1, 5)(x =&gt; x * 2)
res9: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4, 8, 16)

scala&gt; List.range(1, 8)
res10: List[Int] = List(1, 2, 3, 4, 5, 6, 7)

scala&gt; Vector.range(1, 8)
res11: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7)
</pre>
<p> なお、これらのメソッドは配列 (Array) にも用意されています。
</p>
<pre>
scala&gt; Array.empty[Int]
res0: Array[Int] = Array()

scala&gt; Array.concat(Array(1, 2, 3), Array(4, 5, 6))
res1: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala&gt; Array.fill(10)(0)
res2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala&gt; Array.tabulate(5)(x =&gt; x * x)
res3: Array[Int] = Array(0, 1, 4, 9, 16)

scala&gt; Array.iterate(1, 5)(x =&gt; x * 2)
res4: Array[Int] = Array(1, 2, 4, 8, 16)

scala&gt; Array.range(1, 10)
res5: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>

<h4>●可変 (mutable) な列</h4>
<p> 可変な列はおもに ArrayBuffer, ListBuffer, StringBuilder があります。ArrayBuffer は要素を格納するバッファに配列を使っていて、いわゆる「可変長配列」として使用することができます。ArrayBuffer はバッファの末尾に対する操作が得意です。ListBuffer はバッファに連結リストを使っていて、バッファの先頭に対する操作が得意です。StringBuilder は文字列を組み立てるために使います。
</p>
<p> 可変な列 seq は seq(n) = x で要素を更新できますが、このほかにも要素の追加や削除を行うメソッドが用意されています。
</p>
<pre class="item">
seq += x              : x を末尾に追加する
seq ++= xs            : xs の要素をすべて末尾に追加する
x +=: seq             : x を先頭に追加する
xs +=: seq            : xs の要素をすべて先頭に追加する
seq insert (i, x)     : x を i 番目に挿入する
seq insertAll (i, xs) : xs の要素をすべて i 番目に挿入する
seq -= x              : 要素 x を削除する
seq remove i          : i 番目の要素を削除する
seq remove (i, n)     : i 番目から n 個の要素を削除する
seq trimStart n       : 先頭から n  個の要素を削除する
seq trimEnd n         : 末尾から n  個の要素を削除する
</pre>

<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; import scala.collection.mutable.{ArrayBuffer, ListBuffer}
import scala.collection.mutable.{ArrayBuffer, ListBuffer}

scala&gt; val a = new ArrayBuffer[Int]
a: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

scala&gt; for (i &lt;- 1 to 5) a += i

scala&gt; a
res1: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5)

scala&gt; a(0)
res2: Int = 1

scala&gt; a(4)
res3: Int = 5

scala&gt; a(0) = 100

scala&gt; a
res5: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(100, 2, 3, 4, 5)

scala&gt; a remove 4
res6: Int = 5

scala&gt; a
res7: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(100, 2, 3, 4)

scala&gt; a.length
res8: Int = 4

scala&gt; for (i &lt;- 1 to 5) i +=: b

scala&gt; b
res9: scala.collection.mutable.ListBuffer[Int] = ListBuffer(5, 4, 3, 2, 1)

scala&gt; b(0)
res10: Int = 5

scala&gt; b(4)
res11: Int = 1

scala&gt; b(4) = 100

scala&gt; b
res12: scala.collection.mutable.ListBuffer[Int] = ListBuffer(5, 4, 3, 2, 100)

scala&gt; a ++= b
res13: a.type = ArrayBuffer(100, 2, 3, 4, 5, 4, 3, 2, 100)

scala&gt; a ++=: b
res14: b.type = ListBuffer(100, 2, 3, 4, 5, 4, 3, 2, 100, 5, 4, 3, 2, 100)

scala&gt; a -= 100
res15: a.type = ArrayBuffer(2, 3, 4, 5, 4, 3, 2, 100)

scala&gt; a.toArray
res16: Array[Int] = Array(2, 3, 4, 5, 4, 3, 2, 100)

scala&gt; b -= 100
res17: b.type = ListBuffer(2, 3, 4, 5, 4, 3, 2, 100, 5, 4, 3, 2, 100)

scala&gt; b -= 100
res18: b.type = ListBuffer(2, 3, 4, 5, 4, 3, 2, 5, 4, 3, 2, 100)

scala&gt; b.toList
res19: List[Int] = List(2, 3, 4, 5, 4, 3, 2, 5, 4, 3, 2, 100)
</pre>
<p> StringBuilder は文字列を組み立てるときに使うと便利です。簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = new StringBuilder
a: StringBuilder =

scala&gt; a += 'a'
res0: a.type = a

scala&gt; a ++= "bcdefg"
res1: a.type = abcdefg

scala&gt; a.toString
res2: String = abcdefg
</pre>
<p> StringBuilder は標準でインポートされているので、簡単に使用することができます。
</p>

<h4>●WrappedArray</h4>
<p> 配列は Seq トレイトを継承していませんが、Seq 型の変数や関数の引数に配列を渡すことができます。次の例を見てください。
</p>
<pre>
scala&gt; val a = Array(1, 2, 3, 4, 5)
a: Array[Int] = Array(1, 2, 3, 4, 5)

scala&gt; val b:Seq[Int] = a
b: Seq[Int] = WrappedArray(1, 2, 3, 4, 5)

scala&gt; b.toArray
res0: Array[Int] = Array(1, 2, 3, 4, 5)
</pre>
<p> 暗黙の型変換により配列は WrappedArray に変換されます。WrappedArray は Seq トレイトを継承しています。また、toArray メソッドで配列に戻すことも簡単にできます。
</p>
<p> Scala の配列は演算子 ==, != で等値の判定はできませんが、WrappedArray は演算子==, != で等値を判定することができます。
</p>
<pre>
scala&gt; val c = Array(1, 2, 3, 4, 5)
c: Array[Int] = Array(1, 2, 3, 4, 5)

scala&gt; a == c
res1: Boolean = false

scala&gt; val d: Seq[Int] = c
d: Seq[Int] = WrappedArray(1, 2, 3, 4, 5)

scala&gt; b == d
res2: Boolean = true
</pre>
<p> WrappedArray にメソッドを適用すると、適切なデータ構造に変換される場合があります。
</p>
<pre>
scala&gt; b.reverse
res3: Seq[Int] = WrappedArray(5, 4, 3, 2, 1)

scala&gt; b :+ 6
res4: Seq[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6)
</pre>
<p> reverse も演算子 :+ も、返り値の型は Seq[Int] ですが、:+ の場合は実体が WrappedArray から ArrayBuffer に変わっています。
</p>

<p> 実をいうと、配列は列と同じ演算がサポートされています。次の例を見てください
</p>
<pre>
scala&gt; val a = Array(1,2,3,4)
a: Array[Int] = Array(1, 2, 3, 4)

scala&gt; a :+ 5
res6: Array[Int] = Array(1, 2, 3, 4, 5)

scala&gt; 0 +: a
res7: Array[Int] = Array(0, 1, 2, 3, 4)

scala&gt; a ++ Array(5,6,7,8)
res8: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8)
</pre>
<p> <a href="scala18.html#cite">参考 URL</a> の <a href="http://docs.scala-lang.org/ja/overviews/collections/arrays.html">配列</a> によると、内部では暗黙の型変換により WrappedArray とは異なる型に変換されて処理が行われているそうです。初心者にとって、暗黙の型変換はやっぱり難しいですね。WrappedArray の説明は、ここまでにしておきましょう。
</p>

<h4>●列のパターンマッチング</h4>
<p> リストと同様に列でもパターンマッチングを行うことができます。簡単な例を示しましょう。
</p>
<pre>
scala&gt; val (x +: xs) = Vector(1, 2, 3, 4, 5)
x: Int = 1
xs: scala.collection.immutable.Vector[Int] = Vector(2, 3, 4, 5)

scala&gt; val (x +: xs) = List(1, 2, 3, 4, 5)
x: Int = 1
xs: List[Int] = List(2, 3, 4, 5)

scala&gt; val (ys :+ y) = Vector(1, 2, 3, 4, 5)
ys: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4)
y: Int = 5

scala&gt; val (ys :+ y) = List(1, 2, 3, 4, 5)
ys: List[Int] = List(1, 2, 3, 4)
y: Int = 5

scala&gt; val (a +: b +: c +: d) = Vector(1, 2, 3, 4, 5)
a: Int = 1
b: Int = 2
c: Int = 3
d: scala.collection.immutable.Vector[Int] = Vector(4, 5)

scala&gt; val (a +: b +: c +: d) = List(1, 2, 3, 4, 5)
a: Int = 1
b: Int = 2
c: Int = 3
d: List[Int] = List(4, 5)
</pre>
<p> 演算子 +: はコンス演算子 (::) と同じように使うことができます。演算子 :+ を使うと、最後尾の要素を簡単に取り出すことができます。
</p>
<p> 次のように、Seq(...) とマッチングさせることもできます。
</p>
<pre>
scala&gt; val Seq(a, b, c) = Vector(1, 2, 3)
a: Int = 1
b: Int = 2
c: Int = 3

scala&gt; val Seq(a, b, c) = List(1, 2, 3)
a: Int = 1
b: Int = 2
c: Int = 3

scala&gt; val Seq(a, b, c, _*) = Vector(1, 2, 3, 4, 5)
a: Int = 1
b: Int = 2
c: Int = 3

scala&gt; val Seq(a, b, c, _*) = List(1, 2, 3, 4, 5)
a: Int = 1
b: Int = 2
c: Int = 3
</pre>
<p> _* は 0 個以上の任意の要素とマッチングします。
</p>
<p> 記号 @ を使うと変数とパターンを同時に設定することができます。これを「as パターン」といいます。
</p>
<pre class="item">
変数名 @ パターン
</pre>
<p> たとえば、xs @ (y :: ys) と List(1, 2, 3) をマッチングさせると、次のようになります。
</p>
<pre class="item">
xs =&gt; List(1, 2, 3)
y  =&gt; 1
ys =&gt; List(2, 3)
</pre>
<p> もうひとつ簡単な例を示しましょう。
</p>
<pre>
scala&gt; val Seq(a, b, c, d @ _*) = List(1, 2, 3, 4, 5)
a: Int = 1
b: Int = 2
c: Int = 3
d: Seq[Int] = List(4, 5)
</pre>
<p> パターン _* とマッチングした値は変数 d にセットされます。
</p>

<h4>●列の操作メソッド</h4>
<p> 列からデータを探索する場合、今まで用いてきたメソッド contains, indexOf, find, count はそのまま列に使用することができます。
</p>
<pre>
scala&gt; import scala.collection.mutable.{ArrayBuffer}
import scala.collection.mutable.ArrayBuffer

scala&gt; val a = Vector(1,2,3,4,5,6,7,8)
a: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; val b = ArrayBuffer(10, 20, 30, 40, 50)
b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 20, 30, 40, 50)

scala&gt; a contains 5
res0: Boolean = true

scala&gt; a contains 50
res1: Boolean = false

scala&gt; b contains 5
res2: Boolean = false

scala&gt; b contains 50
res3: Boolean = true

scala&gt; a indexOf 5
res4: Int = 4

scala&gt; a indexOf 50
res5: Int = -1

scala&gt; b indexOf 50
res6: Int = 4

scala&gt; b indexOf 5
res7: Int = -1
scala&gt; a find (_ % 2 == 0)
res8: Option[Int] = Some(2)

scala&gt; b find (_ % 2 == 0)
res9: Option[Int] = Some(10)

scala&gt; a count (_ % 2 == 0)
res10: Int = 4

scala&gt; b count (_ % 2 == 0)
res11: Int = 5
</pre>
<p> メソッド reverse で列を反転することもできます。
</p>
<pre>
scala&gt; a.reverse
res12: scala.collection.immutable.Vector[Int] = Vector(8, 7, 6, 5, 4, 3, 2, 1)

scala&gt; a
res13: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; b.reverse
res14: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(50, 40, 30, 20, 10)

scala&gt; b
res15: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 20, 30, 40, 50)
</pre>
<p> 元の列を反転した新しい列が生成されます。
</p>
<p> 高階関数 map, filter, foldLeft, FoldRight, foreach も使用することができます。
</p>
<pre>
scala&gt; a.map(x =&gt; x * x)
res16: scala.collection.immutable.Vector[Int] = Vector(1, 4, 9, 16, 25, 36, 49, 64)

scala&gt; b.map(x =&gt; x * x)
res17: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(100, 400, 900, 1600, 2500)

scala&gt; a.filter(_ % 2 == 0)
res18: scala.collection.immutable.Vector[Int] = Vector(2, 4, 6, 8)

scala&gt; b.filter(_ % 20 == 0)
res19: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(20, 40)

scala&gt; a.foldLeft(0)(_ + _)
res20: Int = 36

scala&gt; b.foldLeft(0)(_ + _)
res21: Int = 150

scala&gt; a foreach println
1
2
3
4
5
6
7
8

scala&gt; b foreach println
10
20
30
40
50
</pre>
<p> リストのように、head で先頭要素を、tail で先頭要素を取り除いた列を、last で末尾の要素を取得することができます。
</p>
<pre>
scala&gt; a.head
res22: Int = 1

scala&gt; b.head
res23: Int = 10

scala&gt; a.tail
res24: scala.collection.immutable.Vector[Int] = Vector(2, 3, 4, 5, 6, 7, 8)

scala&gt; b.tail
res25: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(20, 30, 40, 50)

scala&gt; a.last
res26: Int = 8

scala&gt; b.last
res27: Int = 50
</pre>
<p> リストの場合、head と tail は高速に動作しますが、他のデータ型がリストと同じように高速に動作するわけではありません。ご注意くださいませ。
</p>

<h4>●列のソート</h4>
<p> 列をソートするにはメソッド sortBy, sortWith, sorted を使います。
</p>
<pre class="item">
def sortBy[B](f: (A) =&gt; B)(implicit ord: math.Ordering[B]): Seq[A]
def sortWith(lt: (A, A) =&gt; Boolean): Seq[A]
def sorted[B &gt;: A](implicit ord: math.Ordering[B]): Seq[A]
</pre>
<p> キーワード implicit が付いている引数は「暗黙の引数」といって、引数を省略することができます。これはあとで説明します。sorted はソートした列を返します。sortWith は引数 lt に比較関数を渡して、それを使って列をソートします。sortBy は列の要素に引数 f の関数を適用し、その結果に対してソートを行います。これらのそーとはすべて新しい列を返すことに注意してください。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; List(5, 6, 4, 7, 3, 8, 2, 9, 1).sorted
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; Vector(5, 6, 4, 7, 3, 8, 2, 9, 1).sorted
res1: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; import scala.collection.mutable.{ArrayBuffer}
import scala.collection.mutable.ArrayBuffer

scala&gt; val a = ArrayBuffer(5, 6, 4, 7, 3, 8, 2, 9, 1)
a: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(5, 6, 4, 7, 3, 8, 2, 9, 1)

scala&gt; a.sorted
res2: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; a
res3: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(5, 6, 4, 7, 3, 8, 2, 9, 1)

scala&gt; val b = Array(5, 6, 4, 7, 3, 8, 2, 9, 1)
b: Array[Int] = Array(5, 6, 4, 7, 3, 8, 2, 9, 1)

scala&gt; b.sorted
res4: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; b
res5: Array[Int] = Array(5, 6, 4, 7, 3, 8, 2, 9, 1)
</pre>
<p> mutable な列や配列でも、sorted でソートすると新しい列や配列が生成されます。
</p>
<p> 要素の一部の値を基準にソートしたい場合は sortBy を使うと簡単です。たとえば、列の要素がタプルの場合、要素を基準にして次のようにソートすることができます。
</p>
<pre>
scala&gt; List(("foo", 30), ("oops", 10), ("baz", 20), ("bar", 40)).sortBy(_._1)
res6: List[(String, Int)] = List((bar,40), (baz,20), (foo,30), (oops,10))

scala&gt; List(("foo", 30), ("oops", 10), ("baz", 20), ("bar", 40)).sortBy(_._2)
res7: List[(String, Int)] = List((oops,10), (baz,20), (foo,30), (bar,40))
</pre>
<p> sortWith に渡す比較関数 lt(x, y) は、x が y よりも小さい場合に真を返すと、列を昇順にソートします。
</p>
<pre>
scala&gt; List(5,6,4,7,3,8,2,9,1).sortWith(_ &lt; _)
res8: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; List(5,6,4,7,3,8,2,9,1).sortWith(_ &gt; _)
res9: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1)

scala&gt; List(("foo", 30), ("oops", 10), ("baz", 20), ("bar", 40)).sortWith(_._1 &lt; _._1)
res10: List[(String, Int)] = List((bar,40), (baz,20), (foo,30), (oops,10))

scala&gt; List(("foo", 30), ("oops", 10), ("baz", 20), ("bar", 40)).sortWith(_._1 &gt; _._1)
res11: List[(String, Int)] = List((oops,10), (foo,30), (baz,20), (bar,40))
</pre>

<p> このほかにも便利なメソッドが多数用意されています。詳細は Scala のリファレンスをお読みください。
</p>

<h4>●Ordering</h4>
<p> Ordering はトレイトで、仮想メソッド compare を定義すると、Ordering のメソッドを使用することができます。
</p>
<pre class="item">
abstract def compare(x: T, y: T): Int  // 大小関係を符号 (負, 0, 正) で返す
</pre>
<pre class="item">
def equiv(x: T, y: T): Boolean   // x == y
def gt(x: T, y: T)   : Boolean   // x &gt; y
def gteq(x: T, y: T) : Boolean   // x &gt;= y
def lt(x: T, y: T)   : Boolean   // x &lt; y
def lteq(x: T, y: T) : Boolean   // x &lt;= y
</pre>
<p> sorted や sortBy に Ordering を渡す場合は、無名のクラスを使うと簡単です。次の例を見てください。
</p>
<pre>
scala&gt; List(5, 6, 4, 7, 3, 8, 2, 9, 1).sorted(new Ordering[Int] {
     | def compare(x: Int, y:Int): Int = (x - y).signum
     | })
res12: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; List(5, 6, 4, 7, 3, 8, 2, 9, 1).sorted(new Ordering[Int] {
     | def compare(x: Int, y:Int): Int = (y - x).signum
     | })
res13: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1)

scala&gt; List(5, 6, 4, 7, 3, 8, 2, 9, 1).sorted(new Ordering[Int] {
     | def compare(x: Int, y:Int): Int = y - x
     | })
res14: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1)
</pre>
<p> compare は signum で -1, 0, 1 に変換しなくても、負, 0, 正 を返すだけで動作するようです。
</p>

<h4>●暗黙の引数</h4>
<p> 暗黙の引数（implicit parameter）は、引数の型に合わせた値をあらかじめ定義しておいて、メソッドの引数が省略された場合は、その値を用いる機能です。暗黙の引数は引数名の前にキーワード implicit を付けます。あらかじめ定義しておく値にも val の前に implicit を付けます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; implicit val m = 10
m: Int = 10

scala&gt; implicit val n = 1.234
n: Double = 1.234

scala&gt; def foo(x: Int)(implicit y: Int): Int = x + y
foo: (x: Int)(implicit y: Int)Int

scala&gt; def bar(x: Double)(implicit y: Double): Double = x + y
bar: (x: Double)(implicit y: Double)Double

scala&gt; foo(1)
res0: Int = 11

scala&gt; foo(1)(2)
res1: Int = 3

scala&gt; bar(1.0)
res2: Double = 2.234

scala&gt; bar(1.0)(2.0)
res3: Double = 3.0
</pre>
<p> 暗黙の値として変数 m, n を定義します。メソッド foo, bar の第 2 引数が暗黙の引数です。implicit は引数名の前にしか付けられないので、引数をカッコで分けて通常の引数を定義してから暗黙の引数を定義するのが一般的なようです。
</p>
<p> foo の暗黙の引数の型は Int なので、引数を省略すると変数 m の値が使われます。bar の暗黙の引数の型は Double なので、引数を省略すると変数 n の値が使われます。もちろん、引数を省略せずに渡して呼び出すこともできます。
</p>
<p> もうひとつ、簡単な例を示しましょう。点を表すクラス　Point を作り、それをリストに格納して sorted でソートしてみましょう。Point の比較は原点からの距離で行います。次のように、Ordered[Point] を暗黙の値として定義すると、sorted を簡単に呼び出すことができます。
</p>
<pre>
scala&gt; case class Point(val x: Double, val y: Double)
defined class Point

scala> List(Point(1.0, 1.0), Point(2.0, 2.0), Point(0.0, 0.0)).sorted
&lt;console&gt;:10: error: No implicit Ordering defined for Point.
              List(Point(1.0, 1.0), Point(0.0, 0.0), Point(2.0, 2.0)).sorted

scala&gt; implicit val pointOrd = new Ordering[Point] {
     | def compare(p: Point, q: Point): Int = {
     | val d1 = Math.sqrt(p.x * p.x + p.y * p.y)
     | val d2 = Math.sqrt(q.x * q.x + q.y * q.y)
     | (d1 - d2).signum
     | }
     | }
pointOrd: Ordering[Point] = $anon$1@e20e6b

scala&gt; List(Point(1.0, 1.0), Point(2.0, 2.0), Point(0, 0)).sorted
res4: List[Point] = List(Point(0.0,0.0), Point(1.0,1.0), Point(2.0,2.0))
</pre>
<p> 暗黙の引数は便利な機能ですが、暗黙の型変換と同じように、ちょっと難しいところもあるようです。今回はここまでにして、もっと勉強してから再度取り上げることにしましょう。
</p>

<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="http://docs.scala-lang.org/ja/overviews/collections/introduction.html">
COLLECTIONS - Scala Documentation</a>
</ol>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala17.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala19.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>