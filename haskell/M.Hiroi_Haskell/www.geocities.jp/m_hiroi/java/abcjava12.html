<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>続・お気楽 Java プログラミング入門</title>
  <meta name="description" content="Java,Java入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881776</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Java Programming</h1>
<h2>続・お気楽 Java プログラミング入門</h2>
<div class="small">
[ <a href="abcjava11.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava13.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>ジェネリクス (後編)</h3>
<p> ジェネリクスの続きです。今回は型パラメータについてもう少し詳しく説明します。
</p>
<h4>●型パラメータの制約</h4>
<p> Java の型パラメータは任意のデータ型を表しますが、プログラムによってはデータ型に制約をかけたい場合があります。Java は型パラメータの指定で制約を設定することができます。
</p>
<ul>
  <li>&lt;T extends Foo&gt; 型 T は型 Foo か、そのサブクラス
</ul>
<p> これを「型境界」といいます。Foo はクラスでもインターフェースでもかまいません。これにより、型 T は Foo を継承したサブクラスに制限されます。複数の制約をかけたい場合は型 (インターフェース) を &amp; でつないでください。
</p>
<p> 他のプログラミング言語、たとえば Scala ではこれを「上限境界」といいます。Scala の場合、上限境界のほかに下限境界もありますが、Java には上限境界しかありません。ご注意くださいませ。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 型パラメータの制約

class Foo { }
class Bar extends Foo { }
class Baz extends Bar { }
class Oops&lt;T extends Bar&gt; { }

public class sample120 {
  public static void main(String[] args) {
    // Oops&lt;Foo&gt; a = new Oops&lt;&gt;(); エラー 型引数Fooは型変数Tの境界内にありません
    Oops&lt;Bar&gt; a = new Oops&lt;&gt;();
    System.out.println(a);
    Oops&lt;Baz&gt; b = new Oops&lt;&gt;();
    System.out.println(b);
  }
}
</pre>
<pre>
C&gt;java sample120
Oops@1db9742
Oops@106d69c
</pre>
<p> 継承関係が Foo - Bar - Baz というクラスを作ります。クラス Oops はジェネリクスクラスで、型パラメータに T extends Bar を指定しているので、指定できる型は Bar または Bar のサブクラスである Baz になります。new Oops&lt;Foo&gt; とするとエラーになりますが、new Oops&lt;Bar&gt; と new Oops&lt;Baz&gt; はインスタンスを生成することができます。
</p>
<h4>●共変と反変</h4>
<p> ジェネリクス型には直接的な継承関係はありませんが、型パラメータに渡すクラスの継承関係を使って、ジェネリクス型でも継承関係 (スーパークラスとサブクラスの関係) を考えることができます。たとえば、ジェネリクス型 Foo&lt;T&gt; を考えてみましょう。
</p>
<pre class="list">
リスト : クラス Foo の定義

class Foo&lt;T&gt; {
  private T value;
  Foo(T x) { value = x; }
  T getValue() { return value; }
  void setValue(T x) { value = x; }
}
</pre>
<p> 型パラメータと同じ継承関係を持たせることを「共変 (covariant)」といいます。共変が許されると、次のようなプログラムが可能になります。
</p>
<pre class="list">
リスト : 共変

Foo&lt;Object&gt; a = new Foo&lt;String&gt;("hello");
</pre>

<p> String は Object のサブクラスなのでアップキャストが可能です。ジェネリクス型でもアップキャストができると便利な場合があります。
</p>
<p> 型パラメータと逆の継承関係を持たせることを「反変 (contravariant)」といいます。反変が許されると、次のようなプログラムが可能になります。
</p>
<pre class="list">
リスト : 反変

Foo&lt;String&gt; a = new Foo&lt;Object&gt;(new Object());
</pre>
<p> 反変は直感に反するところがあって、ちょっと難しいかもしれません。メソッドの引数の型や返り値の型で反変を指定すると、メソッドの使い勝手がよくなる場合があります。
</p>
<p> 共変ではなく反変ではないことを「非変 (nonvariant)」とか「不変」と呼びます。これはジェネリクス型に継承関係を持たせない方法です。
</p>
<h4>●Java の配列は共変</h4>
<p> Java の場合、ジェネリクス型は非変ですが配列は共変です。共変の場合、次のようなプログラムを書くことが可能です。
</p>
<pre class="list">
リスト : Java の配列は共変

public class sample121 {
  public static void main(String[] args) {
    Integer [] a = new Integer [] {1, 2, 3, 4};
    Object [] b = a;
    b[0] = 10;
    for (Object x: b) System.out.println(x);    
  }
}
</pre>
<pre>
C&gt;javac sample121.java

C&gt;java sample121
10
2
3
4
</pre>
<p> Integer の配列 a を作成します。変数 b を Object の配列に宣言すると、変数 b に a の配列を代入することができます。配列の値を Integer 以外の値に書き換えなければ、このプログラムでも正常に動作します。
</p>
<p> ところが、配列 b は Object で宣言しているので、そこに文字列を代入することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : Java の配列は共変 (実行時エラー)

public class sample122 {
  public static void main(String[] args){
    Integer [] a = new Integer [] {1, 2, 3, 4};
    Object [] b = a;
    b[0] = "hello, world";
    for (Object x: b) System.out.println(x);
  }
}
</pre>
<p> b[0] に文字列をセットします。実際、コンパイルしてもエラーはならないのですが、実行するとエラーが送出されます。
<pre>
C&gt;javac sample122.java

C&gt;java sample122
Exception in thread "main" java.lang.ArrayStoreException: java.lang.String
        at sample122.main(sample122.java:5)
</pre>
<p> Java のジェネリクス型は非変に設定されているので、このような危険なプログラムを書くことはできません。
</p>
<pre class="list">
リスト : ジェネリクス型は非変

class Foo { }
class Bar extends Foo { }
class Baz extends Bar { }
class Oops&lt;T&gt; { }

public class sample123 {
  public static void main(String[] args) {
    Oops&lt;Foo&gt; a = new Oops&lt;&gt;();
    a = new Oops&lt;Bar&gt;();
    System.out.println(a);
  }
}
</pre>
<pre>
C&gt;javac sample123.java
sample123.java:9: エラー: 不適合な型: Oops&lt;Bar&gt;をOops&lt;Foo&gt;に変換できません:
    a = new Oops&lt;Bar&gt;();
        ^
エラー1個
</pre>
<p> もちろん、配列に書き込みを行わなければ、共変でも問題は発生しません。一般に、immutable なデータ構造は共変に、mutable なデータ構造は非変に設定したほうがよいとされています。
</p>

<h4>●ワイルドカード</h4>
<p> Java の場合、? という型指定を使うと、共変と反変を指定することができます。? を「ワイルドカード」といいます。? は任意の型を表します。たとえば、Foo&lt;?&gt; で宣言された変数には、Foo&lt;Integer&gt; でも Foo&lt;Double&gt; でも Foo のインスタンスであれば何でもセットすることができます。簡単な例を示しましょう。
</p>

<pre class="list">
リスト : ワイルドカード

class Foo&lt;T&gt; {
  private T x;
  Foo(T a) { x = a; }
  T getX() { return x; }
  void setX(T a) { x = a; }
}

public class sample124 {
  public static void main(String[] args) {
    Foo&lt;?&gt; a = new Foo&lt;Integer&gt;(123);
    int n = (Integer)a.getX();     // 型が不定なのでキャストが必要
    System.out.println(n);
    a = new Foo&lt;Double&gt;(1.2345);
    double m = (Double)a.getX();
    System.out.println(m);
    a = new Foo&lt;String&gt;("hello!");
    System.out.println(a.getX());
    // a.setX("oops!");  コンパイルエラー
    // 型が不定なので特定の型を書き込むことはできない
    // System.out.println(a.getX());
  }
}
</pre>
<pre>
C&gt;java sample124
123
1.2345
hello!
</pre>
<p> 変数 a の型をワイルドカードを使って  Foo&lt;?&gt; と宣言すると、Foo のインスタンスであれば何でも a に代入することができます。ただし、データ型の情報が失われるため、メソッド getX() で取り出した値の型は Object として扱われることになり、ダウンキャストが必要になります。同様に、型が特定できないため、setX() で特定のデータを書き込むことはできません。コンパイルエラーになります。
</p>
<h4>●共変と反変の指定</h4>
<p> Java の場合、ワイルドカードにも制約をかけることができます。
</p>
<ol>
  <li>&lt;? extends Foo&gt; Foo またはそのサブクラス
  <li>&lt;? super Foo&gt; Foo またはそのスーパークラス
</ol>
<p> 1 を「上限境界ワイルドカード」といい、共変に相当します。2 を「下限境界ワイルドカード」といい、反変に相当します。簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 共変と反変の指定

class Foo { }
class Bar extends Foo { }
class Baz extends Bar { }

class Oops&lt;T&gt; {
  private T value;
  Oops(T x) { value = x; }
  T getValue() { return value; }
  void setValue(T x) { value = x; }
}

public class sample125 {
  public static void main(String[] args) {
    // Oops&lt;? extends Bar&gt; a = new Oops&lt;Foo&gt;(new Foo()); コンパイルエラー
    Oops&lt;? extends Bar&gt; b = new Oops&lt;Baz&gt;(new Baz());
    Bar obj1 = b.getValue();   // OK キャスト不要 (アップキャスト)
    System.out.println(obj1);
    // b.setValue(new Bar());     コンパイルエラー
    
    Oops&lt;? super Bar&gt; c = new Oops&lt;Foo&gt;(new Foo());
    // Oops&lt;? super Bar&gt; d = new Oops&lt;Baz&gt;(new Baz()); コンパイルエラー

    c.setValue(new Bar());         // 書き込みは OK
    // c.setValue(new Foo());         Bar 以外はコンパイルエラー
    Bar obj2 = (Bar)c.getValue();  // キャストが必要になる
    System.out.println(obj2);
  }
}
</pre>
<pre>
C&gt;java sample125
Baz@1db9742
Bar@106d69c
</pre>
<p> 変数 a, b は Oops&lt;? extends Bar&gt; と宣言しているので共変です。Oops&lt;Baz&gt; のインスタンスは代入できますが、Oops&lt;Foo&gt; のインスタンスは代入できません。b.getValue() の返り値は Bar 型の変数にキャストせずに代入することができます。共変の場合、値を書き換えることはできません。b.setValue(new Bar()) を呼び出すとコンパイルエラーになります。
</p>

<p> 変数 c, d は Oops&lt;? super Bar&gt; と宣言しているので反変です。Oops&lt;Foo&gt; のインスタンスは代入できますが、Oops&lt;Baz&gt; のインスタンスは代入できません。反変の場合、制約で宣言したデータ型は代入することができます。したがって、c.setValue() は正常に動作します。ただし、Bar 以外のデータ型を渡すとコンパイルエラーになります。c.getValue() の返り値はデータ型が Bar と特定できないので、Object として扱われます。このため、ダウンキャストが必要になり、データ型に対して安全なプログラムにはなりません。
</p>
<h4>●連結リストの改良</h4>
<p> さて、これだけでは共変と反変がなんの役に立つのかよくわかりませんね。そこで、簡単な使用例を示しましょう。前回作成した連結リスト SinglyLinkedList&lt;E&gt; にメソッド pushAll(() と popAll() を追加します。ここで、メソッドの仕様を次のように定義すると使い勝手が悪くなります。
</p>
<ul>
  <li>void pushAll(Collection&lt;E&gt; c);
  <li>void popAll(Collection&lt;E&gt; c);
</ul>
<p> pushAll() はコレクション c のすべての要素を連結リストの先頭に追加します。popAll() は連結リストの先頭から要素を取り出して、それをコレクション c に追加します。ここで、上記のように引数の型を Collection&lt;E&gt; とすると、要素が同じデータ型のコレクションしか引数に渡すことができません。このような場合、共変と反変が役に立ちます。
</p>
<p> pushAll() の場合、コレクションの要素が連結リストの要素のサブクラスであれば、連結リストに代入することができるはずです。これは引数の型を共変に設定すれば実現できます。popAll() の場合、コレクションの要素が連結リストの要素のスーパークラスであれば、連結リストの要素をコレクションに代入することができるはずです。これは引数の型を反変に設定すれば実現できます。したがって、メソッドの仕様は次のようになります。
</p>
<ul>
  <li>void pushAll(Collection&lt;? extends E&gt; c);
  <li>void popAll(Collection&lt;? super E&gt; c);
</ul>
<p> これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : pushAll() と popAll()

  // コレクションの要素をリストに追加
  void pushAll(Collection&lt;? extends E&gt; c) {
    for (E x: c) {
      head.setLink(new Cell(x, head.getLink()));
    }
  }

  // リストの要素を取り出してコレクションに追加
  void popAll(Collection&lt;? super E&gt; c) {
    for (E x: this) {
      c.add(x);
    }
    clear();
  }
</pre>
<p> pushAll() の引数は Collection&lt;? extends E&gt; と宣言されているので、要素は E または E のサブクラスであることが保証されています。for 文で要素を変数 x に取り出すとき、キャストせずにそのまま行うことができます。同様に、popAll() の引数は Collection&lt;? super E&gt; と宣言されているので、要素は E または E のスーパークラスであることが保証されています。メソッド add() で要素を追加するとき、アップキャストになるので安全に行うことができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre class="list">
リスト : 簡単なテスト

class Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

public class slist3 {
  public static void main(String[] args) {
    List&lt;Baz&gt; xs = new ArrayList&lt;Baz&gt;() {
      {
        add(new Baz());
        add(new Baz());
        add(new Baz());
      }
    };
    System.out.println(xs);
    SinglyLinkedList&lt;Bar&gt; ys = new SinglyLinkedList&lt;&gt;();
    ys.pushAll(xs);
    System.out.println(ys);
    List&lt;Foo&gt; zs = new ArrayList&lt;&gt;();
    ys.popAll(zs);
    System.out.println(ys);
    System.out.println(zs);
  }
}
</pre>
<pre>
C&gt;java slist3
[Baz@1db9742, Baz@106d69c, Baz@52e922]
(Baz@52e922 Baz@106d69c Baz@1db9742)
()
[Baz@52e922, Baz@106d69c, Baz@1db9742]
</pre>
<p> 変数 xs には Baz のインスタンスを格納した ArrayList をセットし、変数 ys には Bar を格納する連結リストをセットします。Baz は Bar のサブクラスなので、ys.pushAll(xs) はコンパイル可能で正常に動作します。次に、Foo のインスタンスを格納する ArrayList を変数 zs にセットします。Foo は Bar のスーパークラスなので、ys.popAll(zs) はコンパイル可能で正常に動作します。
</p>
<p> このように、共変と反変を設定すると、メソッドの使い勝手を改善することができます。
</p>

<h4>●Comparable&lt;E&gt;</h4>
<p> List&lt;E&gt; を継承しているコレクションクラスでは、Collections クラスのメソッド binarySearch() で二分探索、sort() でソートすることができます。このとき、型 E は Comparable&lt;E&gt; を継承する必要があります。Comparable&lt;E&gt; は Comparable のジェネリクス版です。宣言されているメソッドは compareTo() だけです。
</p>
<pre class="item">
int compareTo(E o);
</pre>
<p> Comparable と違って引数の型が E になります。compareTo() は自分自身のオブジェクト (this) と引数 o を比較し、o が大きい場合は負の整数、等しい場合は 0、小さい場合は正の整数を返します。
</p>
<p> Collections.sort() は次のように定義されています。
</p>
<pre class="item">
static &lt;E extends Comparable&lt;? super E&gt;&gt; void sort(List&lt;E&gt; list)
</pre>
<p> ここで型 E の制約に注意してください。制約は Comparable&lt;E&gt; で十分なように思えます。実際、compareTo() を実装したクラスであれば、問題なくコンパイルすることができます。ところが、継承を考えるとうまくいかない場合があるのです。次のリストを見てください。
</p>
<pre class="list">
リスト : Comparable&lt;E&gt; の使用例

class Foo implements Comparable&lt;Foo&gt; {
  private int x;
  Foo(int n) { x = n; }
  int getX() { return x; }
  void setX(int n) { x = n; }

  public int compareTo(Foo o) {
    int r = x - o.x;
    if(r &lt; 0) return -1;
    else if (r == 0) return 0;
    return 1;
  }

  public String toString() {
    return "Foo(" + x + ")";
  }
}

class Bar extends Foo {
  Bar(int n) { super(n); }

  @Override
  public String toString() {
    return "Bar(" + getX() + ")";
  }
}
</pre>
<p> クラス Foo で Comparable&lt;E&gt; を継承する場合は型 E に Foo を指定します。それから、メソッド compareTo() を実装します。クラス Baz は Foo を継承しているので、Comparable&lt;Foo&gt; も継承します。ここで、Bar のインスタンスをソートすることを考えてみましょう。
</p>
<p> sort() の型 E の制約を Comparable&lt;E&gt; として Bar をソートする場合、インターフェース Comparable&lt;Bar&gt; が必要になります。ところが、Bar に実装されているのは Comparable&lt;Foo&gt; しかありません。この場合はコンパイルエラーになります。
</p>
<p> 制約を Comparable&lt;? super E&gt; とした場合、Bar のスーパークラス Foo も許されので Comparable&lt;Foo&gt; が制約になります。この場合、コンパイルは通って正常に実行することができます。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre class="list">
リスト : 簡単な実行例

public class sample126 {
  public static void main(String[] args) {
    List&lt;Foo&gt; xs = new ArrayList&lt;Foo&gt;() {
      {
        add(new Foo(3));
        add(new Foo(1));
        add(new Foo(2));
      }
    };
    System.out.println(xs);
    Collections.sort(xs);
    System.out.println(xs);
    List&lt;Bar&gt; ys = new ArrayList&lt;Bar&gt;() {
      {
        add(new Bar(2));
        add(new Bar(3));
        add(new Bar(1));
      }
    };
    System.out.println(ys);
    Collections.sort(ys);
    System.out.println(ys);
  }
}
</pre>
<pre>
C&gt;java sample126
[Foo(3), Foo(1), Foo(2)]
[Foo(1), Foo(2), Foo(3)]
[Bar(2), Bar(3), Bar(1)]
[Bar(1), Bar(2), Bar(3)]
</pre>
<p> このように、Foo のサブクラス Bar のインスタンスでもソートすることができます。
</p>
<h4>●連想リスト</h4>
<p> 最後に簡単な例題として、「連想リスト (association list : a-list)」を作ってみましょう。連想リストは Lisp / Scheme でよく用いられるデータ構造で、Java では Pair を要素とするコレクションで簡単に実装することができます。次の図を見てください。
</p>
<pre class="fig">
                     ┌────┬────┬────┬──→ データ 
                     │        │        │        │
 連想リスト => [("a", 1), ("b", 2), ("c", 3), ("d", 4)]
                 │        │        │        │
                 └────┴────┴────┴──→ キー

                        図 : 連想リストの構造
</pre>
<p> 上図の場合、文字列 "a", "b", "c", "d" がキーで、整数 1, 2, 3, 4 がデータとなります。一般に、キーとその値を格納するコレクションを「マップ (map)」と呼びます。Java のライブラリには、インターフェース Map&lt;K, V&gt; が用意されています。K がキーで、V が値を表す型パラメータです。具体的には、クラス HashMap&lt;K, V&gt; や TreeMap&lt;K, V&gt; を使います。HashMap はアルゴリズムにハッシュ法、TreeMap は二分木 (平衡木) が用いられています。
</p>
<p> 連想リストは線形探索になるので、要素数が多くなると実行時間は遅くなります。HashMap や TreeMap のほうが高速に処理できるので、Java で連想リストを使う機会はほとんどないと思いますが、Java のお勉強ということで、あえて連想リストのプログラムを作ってみましょう。
</p>
<p> プログラムは簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : 連想リスト

class AssocList&lt;K, V&gt; {
  private SinglyLinkedList&lt;Pair&lt;K, V&gt;&gt; contents;
  public AssocList() {
    contents = new SinglyLinkedList&lt;Pair&lt;K, V&gt;&gt;();
  }

  // key の探索
  private Pair&lt;K, V&gt; assoc(K key) {
    for (Pair&lt;K, V&gt; p: contents) {
      if (key.equals(p.getFst()) &amp;&amp; p.getSnd() != null) return p;
    }
    return null;
  }

  // key があるか
  public boolean hasKey(K key) {
    return assoc(key) != null;
  }
  
  // 追加
  public void add(K key, V value) {
    Pair&lt;K, V&gt; p = assoc(key);
    if (p == null)
      contents.insert(0, new Pair&lt;K,V&gt;(key, value));
    else
      p.setSnd(value);
  }

  // 取得
  public V get(K key) {
    Pair&lt;K, V&gt; p = assoc(key);
    return p != null ? p.getSnd() : null;
  }

  // 削除 (null に書き換えるだけ)
  public V remove(K key) {
    Pair&lt;K, V&gt; p = assoc(key);
    if (p != null) {
      V v = p.getSnd();
      p.setSnd(null);
      return v;
    }
    return null;
  }

  // 空にする
  public void clear() { contents.clear(); }
}
</pre>
<p> クラス AccocList のフィールド変数 contents にコレクションクラスをセットします。今回は SinglyLinedList を使いましたが、他のコレクションクラスを使っても簡単に実装することができます。キーを探索するため、作業用のメソッド assoc() を定義します。名前は Lisp / Scheme から拝借しました。String 以外の参照型データの場合、演算子 == による等値の判定はオブジェクトのアドレスが用いられます。オブジェクトに格納されている値を比較したい場合はメソッド equals() を使ってください。
</p>
<p> assoc() を定義すると、あとのメソッドは簡単です。ただし、注意点が一つあって、今回は remove() でデータを削除するとき、連結リストから削除するのではなく、値を null に書き換えることで対応しています。このため、キーの有無を判定するメソッド hasKey() では、assoc() でキーを見つけたあと、値が null でないことを確認しています。あとは簡単なので、詳細はプログラムリストをお読みください。
</p>

<p> それでは実際に実行してみましょう。
</p>
<pre class="list">
リスト : 連想リストのテスト

  static void testAlist() {
    AssocList&lt;String, Integer&gt; alist = new AssocList&lt;&gt;();
    alist.add("foo", 10);
    alist.add("bar", 20);
    alist.add("baz", 30);
    alist.add("oops", 40);
    System.out.println(alist.get("foo"));
    System.out.println(alist.get("bar"));
    System.out.println(alist.get("baz"));
    System.out.println(alist.get("oops"));
    alist.add("bar", 200);
    System.out.println(alist.get("bar"));
    System.out.println(alist.hasKey("FOO"));
    System.out.println(alist.hasKey("baz"));
    System.out.println(alist.remove("baz"));
    System.out.println(alist.hasKey("baz"));    
    System.out.println(alist.get("baz"));
  }
</pre>
<pre>
10
20
30
40
200
false
true
30
false
null
</pre>
<p> 正常に動作していますね。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// slist3.java : 片方向連結リスト (ジェネリクス版)
//
//               Copyright (C) 2016 Makoto Hiroi
//
import java.util.*;

// 例外クラス
class ListIndexOutOfBoundsException extends IndexOutOfBoundsException {
  public ListIndexOutOfBoundsException() { }
  public ListIndexOutOfBoundsException(String msg) { super(msg); }
}

// 連結リスト
class SinglyLinkedList&lt;E&gt; implements Iterable&lt;E&gt; {
  // セル
  private class Cell {
    // フィールド変数
    private E value;
    private Cell link;
    // コンストラクタ
    Cell(E item, Cell xs) {
      value = item;
      link = xs;
    }

    // アクセスメソッド
    E getValue() { return value; }
    Cell getLink() { return link; }
    void setValue(E item) { value = item; }
    void setLink(Cell xs) { link = xs; }
  }
  
  // フィールド変数
  private Cell head;
  private int  size;
  // コンストラクタ
  SinglyLinkedList() {
    head = new Cell(null, null);   // ヘッダーセル
    size = 0;
  }
  
  // n 番目のセルを求める
  private Cell nth(int n) {
    int i = -1;
    Cell xs = head;
    while (xs != null) {
      if (n == i) return xs;
      i++;
      xs = xs.getLink();
    }
    throw new ListIndexOutOfBoundsException("SinglyLinkedList");
  }

  // 参照
  public E get(int n) {
    return nth(n).getValue();
  }

  // 挿入
  public void insert(int n, E item) {
    Cell xs = nth(n - 1);
    Cell ys = new Cell(item, xs.getLink());
    xs.setLink(ys);
    size++;
  }

  // 削除
  public E remove(int n) {
    Cell xs = nth(n - 1);
    Cell ys = xs.getLink();
    if (ys == null) {
      throw new ListIndexOutOfBoundsException("SinglyLinkedList");
    }
    xs.setLink(ys.getLink());
    size--;
    return ys.getValue();
  }

  // 書き換え
  public E set(int n, E item) {
    Cell xs = nth(n);
    E old = xs.getValue();
    xs.setValue(item);
    return old;
  }

  // 空にする
  public void clear() {
    head.setLink(null);
    size = 0;
  }

  // 個数を求める
  public int size() { return size; }

  // 空リストか
  public boolean isEmpty() { return size == 0; }

  // List 型に変換する
  public List&lt;E&gt; toList(){
    List&lt;E&gt; a = new ArrayList&lt;&gt;();
    Cell xs = head.getLink();
    for (int i = 0; i &lt; size; i++) {
      a.add(xs.getValue());
      xs = xs.getLink();
    }
    return a;
  }
  
  // 文字列に変換
  public String toString(){
    String buff = "(";
    Cell xs = head.getLink();
    while (xs != null) {
      buff += xs.getValue().toString();
      xs = xs.getLink();
      if (xs != null) buff += " ";
    }
    buff += ")";
    return buff;
  }

  // イテレータ
  public Iterator&lt;E&gt; iterator() {
    // 無名クラス
    return new Iterator&lt;E&gt;() {
      Cell xs = head.getLink();
      public boolean hasNext() { return xs != null; }
      public E next() {
        E item = xs.getValue();
        xs = xs.getLink();
        return item;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }

  // コレクションの要素をリストに追加
  void pushAll(Collection&lt;? extends E&gt; c) {
    for (E x: c) {
      head.setLink(new Cell(x, head.getLink()));
    }
  }

  // リストの要素を取り出してコレクションに追加
  void popAll(Collection&lt;? super E&gt; c) {
    for (E x: this) {
      c.add(x);
    }
    clear();
  }
}

class Pair&lt;T, U&gt; {
  private T fst;
  private U snd;
  // コンストラクタ
  Pair(T x, U y) {
    fst = x;
    snd = y;
  }
  // メソッド
  T getFst() { return fst; }
  U getSnd() { return snd; }
  void setFst(T x) { fst = x; }
  void setSnd(U y) { snd = y; }

  // 文字列に変換
  public String toString() {
    return "(" + fst.toString() + ", " + snd.toString() + ")";
  }
}

// 連想リスト
class AssocList&lt;K, V&gt; {
  private SinglyLinkedList&lt;Pair&lt;K, V&gt;&gt; contents;
  public AssocList() {
    contents = new SinglyLinkedList&lt;Pair&lt;K, V&gt;&gt;();
  }

  // key の探索
  private Pair&lt;K, V&gt; assoc(K key) {
    for (Pair&lt;K, V&gt; p: contents) {
      if (key.equals(p.getFst()) &amp;&amp; p.getSnd() != null) return p;
    }
    return null;
  }

  // key があるか
  public boolean hasKey(K key) {
    return assoc(key) != null;
  }
  
  // 追加
  public void add(K key, V value) {
    Pair&lt;K, V&gt; p = assoc(key);
    if (p == null)
      contents.insert(0, new Pair&lt;K,V&gt;(key, value));
    else
      p.setSnd(value);
  }

  // 取得
  public V get(K key) {
    Pair&lt;K, V&gt; p = assoc(key);
    return p != null ? p.getSnd() : null;
  }

  // 削除 (null に書き換えるだけ)
  public V remove(K key) {
    Pair&lt;K, V&gt; p = assoc(key);
    if (p != null) {
      V v = p.getSnd();
      p.setSnd(null);
      return v;
    }
    return null;
  }

  // 空にする
  public void clear() { contents.clear(); }
}

class Foo { }
class Bar extends Foo { }
class Baz extends Bar { }

// 簡単なテスト
public class slist3 {
  // 連想リストのテスト
  static void testAlist() {
    AssocList&lt;String, Integer&gt; alist = new AssocList&lt;&gt;();
    alist.add("foo", 10);
    alist.add("bar", 20);
    alist.add("baz", 30);
    alist.add("oops", 40);
    System.out.println(alist.get("foo"));
    System.out.println(alist.get("bar"));
    System.out.println(alist.get("baz"));
    System.out.println(alist.get("oops"));
    alist.add("bar", 200);
    System.out.println(alist.get("bar"));
    System.out.println(alist.hasKey("FOO"));
    System.out.println(alist.hasKey("baz"));
    System.out.println(alist.remove("baz"));
    System.out.println(alist.hasKey("baz"));    
    System.out.println(alist.get("baz"));
  }
  
  public static void main(String[] args) {
    List&lt;Baz&gt; xs = new ArrayList&lt;Baz&gt;() {
      {
        add(new Baz());
        add(new Baz());
        add(new Baz());
      }
    };
    System.out.println(xs);
    SinglyLinkedList&lt;Bar&gt; ys = new SinglyLinkedList&lt;Bar&gt;();
    ys.pushAll(xs);
    System.out.println(ys);
    List&lt;Foo&gt; zs = new ArrayList&lt;&gt;();
    ys.popAll(zs);
    System.out.println(ys);
    System.out.println(zs);

    testAlist();
  }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcjava11.html">PrevPage</a> | <a href="index.html">Java</a> | <a href="abcjava13.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>