<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Scala プログラミング入門</title>
  <meta name="description" content="Scala,Scala入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881777</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Scala Programming</h1>
<h2>お気楽 Scala プログラミング入門</h2>
<div class="small">
[ <a href="scala04.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>高階関数 (2)</h3>
<p> 関数型言語の場合、リスト操作関数の多くは高階関数として定義されています。Scala の場合も、リスト操作用メソッドの多くは高階関数として定義されています。今回はよく使われる高階関数として、マッピング、フィルター、畳み込み (縮約) について説明します。
</p>

<h4>●マッピング</h4>
<p> まず最初に、リストの要素を関数 f に与えて、その結果をリストに格納して返す関数を作ってみましょう。このような操作を「マッピング（写像）」といいます。なお、関数に引数を与えて呼び出すことを、関数型言語では「適用」といいます。本稿でも関数呼び出しの意味で適用を使うことにします。
</p>
<p> 次のリストを見てください。
</p>

<pre class="list">
リスト : マッピング

def mapcar[A, B](f: A =&gt; B, xs: List[A]): List[B] = 
  xs match {
    case Nil =&gt; Nil
    case y::ys =&gt; f(y) :: mapcar(f, ys)
  }
</pre>

<p> 関数名は mapcar としました。名前は Common Lisp から拝借しました。なお、Scala には同じ機能を持つメソッド map があります。
</p>
<p> 第 1 引数 f が関数型 A =&gt; B で第 2 引数 xs がリスト List[A] になります。関数 f はリストの要素を受け取るので、関数 f の引数の型とリストの要素の型は一致します。これを型パラメータ A で表しています。同様に、関数 f の返り値の型と mapcar の返り値のリストの要素の型は一致します。これを型パラメータ B で表しています。このように、mapcar は多相型関数として定義されます。
</p>

<p> プログラムは簡単です。パターンマッチングで引数のリストを先頭の要素 y と残りのリスト ys に分解します。そして、y に関数 f を適用した結果と mapcar(f, ys) の結果をコンス演算子 :: で結合します。引数のリストが空リストの場合が再帰呼び出しの停止条件になります。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; mapcar((x: Int) =&gt; x * x, List(1, 2, 3, 4, 5))
res0: List[Int] = List(1, 4, 9, 16, 25)

scala&gt; mapcar((x: Int) =&gt; Math.sqrt(x), List(1, 2, 3, 4, 5))
res1: List[Double] = List(1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979)
</pre>
<p> Scala の場合、マッピングはメソッド map を使います。
</p>
<pre>
scala&gt; List(1,2,3,4,5).map(x =&gt; x * x)
res2: List[Int] = List(1, 4, 9, 16, 25)

scala&gt; List(1,2,3,4,5).map(x =&gt; Math.sqrt(x))
res3: List[Double] = List(1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979)
</pre>
<h4>●プレースホルダー</h4>
<p> ここで便利な機能を紹介しましょう。無名関数の引数が式の中で一度しか使われない場合、引数をアンダーバー ( _ ) で代用することができます。これを「プレースホルダー」と呼びます。
</p>
<p> たとえば、無名関数 (x: Int, y: Int) =&gt; x + y は、式の中で引数 x と y が 1 回ずつしか現れていないので、プレースホルダーを使って表すことができます。次の例を見てください。
</p>
<pre>
scala&gt; val f1:(Int, Int) =&gt; Int = _ + _
f1: (Int, Int) =&gt; Int = &lt;function2&gt;

scala&gt; f1(10, 20)
res0: Int = 30

scala&gt; val f2 = (_: Int) + (_: Int)
f2: (Int, Int) =&gt; Int = &lt;function2&gt;

scala&gt; f2(100, 200)
res1: Int = 300
</pre>
<p> 変数 f1 に関数型を指定すると、式はプレースホルダーを使って _ + _ と表すことができます。引数が複数ある場合、左側から見て最初の _ が第 1 引数に、2 番目の _ が第 2 引数に対応します。また、f2 のように _ で型を指定することもできます。
</p>
<p> マッピング (map) の例題で、無名関数 x =&gt; x * x は引数 x が 2 回現れているのでプレースホルダーは使えませんが、x =&gt; Math.sqrt(x) はプレースホルダーを使って Math.sqrt(_) と表すことができきます。
</p>

<h4>●フィルター</h4>
<p> フィルター (filter) は、引数の関数が真を返す要素だけをリストに格納して返す働きをする関数です。関数型言語では、真または偽を返す関数のことを「述語 (predicate) 」といいます。ここでは簡単な例題として、フィルターとは逆の働きをする関数、つまり述語が真を返す要素を削除する関数 removeIf を作ってみましょう。名前は Common Lisp から拝借しました。
</p>

<pre class="list">
リスト : 要素の削除

def removeIf[A](f: A =&gt; Boolean, xs: List[A]): List[A] =
  xs match {
    case Nil =&gt; Nil
    case y::ys if (f(y)) =&gt; removeIf(f, ys)
    case y::ys =&gt; y :: removeIf(f, ys)
  }
</pre>

<p> mapcar と同様に removeIf も簡単です。引数 f の型は A =&gt; Boolean で、引数 xs の型は List[A] になります。f の引数の型とリストの要素の型は同じになります。f(y) が真ならば y を返り値のリストに加えません。偽ならば y を返り値のリストに加えるだけです。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; removeIf((_: Int) % 2 == 0, List(1, 2, 3, 4, 5))
res0: List[Int] = List(1, 3, 5)

scala&gt; removeIf((_: String) == "bar", List("foo", "bar", "baz"))
res1: List[String] = List(foo, baz)
</pre>
<p> 最初の例では偶数の要素が削除されます。次の例は文字列 "bar" が削除されます。
</p>

<p> もちろん、フィルターも簡単に定義することができます。removeIf とは逆に、述語が真を返すとき要素をリストに追加し、偽を返すときはリストに加えません。
</p>

<pre class="list">
リスト : フィルター

def filter[A](f: A =&gt; Boolean, xs: List[A]): List[A] =
  xs match {
    case Nil =&gt; Nil
    case y::ys if (f(y)) =&gt; y :: filter(f, ys)
    case _::ys =&gt; filter(f, ys)
  }
</pre>

<p> 簡単な実行例を示しましょう。
</p>

<pre>
scala&gt; filter((_: Int) % 2 == 0, List(1, 2, 3, 4, 5))
res2: List[Int] = List(2, 4)
</pre>
<p> Scala のライブラリには、メソッド filter, filterNot が用意されています。
</p>
<pre>
scala&gt; List(1, 2, 3, 4, 5).filter(_ % 2 == 0)
res3: List[Int] = List(2, 4)

scala&gt; List(1, 2, 3, 4, 5).filterNot(_ % 2 == 0)
res4: List[Int] = List(1, 3, 5)
</pre>
<h4>●畳み込み</h4>
<p> 2 つの引数を取る関数 f とリストを引数に受け取る関数 reduce を考えます。reduce はリストの各要素に対して関数 f を下図のように適用します。
</p>

<pre class="fig">
(1) (a1, a2, a3, a4, a5)
    =&gt; f( f( f( f( a1, a2 ), a3 ), a4 ), a5 )

(2) (a1, a2, a3, a4, a5)
    =&gt; f( a1, f( a2, f( a3, f( a4, a5 ) ) ) )

        図 : 関数 reduce の動作
</pre>

<p> 関数 f を適用する順番で 2 通りの方法があります。図 (1) はリストの先頭から f を適用し、図 (2) はリストの後ろから f を適用します。たとえば、関数 f が単純な加算関数とすると、reduce の結果はどちらの場合もリストの要素の和になります。
</p>

<pre class="item">
f(x, y) = x + y の場合
reduce =&gt; a1 + a2 + a3 + a4 + a5
</pre>

<p> このように、reduce はリストのすべての要素を関数 f を用いて結合します。このような操作を「縮約」とか「畳み込み」といいます。また、reduce の引数に初期値 g を指定することがあります。この場合、reduce は下図に示す動作になります。
</p>

<pre class="fig">
(1) (a1, a2, a3, a4, a5)
    =&gt; f( f( f( f( f( g, a1 ), a2 ), a3 ), a4 ), a5 )

(2) (a1, a2, a3, a4, a5)
    =&gt; f( a1, f( a2, f( a3, f( a4, f( a5, g ) ) ) ) )

        図 : reduce() の動作 (2)
</pre>

<p> ここでは簡単な例題として、上図 (1) の動作を行う関数 foldl と、上図 (2) の動作を行う関数 foldr を作ってみましょう。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : 畳み込み

def foldl[A, B](f: (A, B) =&gt; A, a: A, xs: List[B]): A =
  xs match {
    case Nil =&gt; a
    case y::ys =&gt; foldl(f, f(a, y), ys)
  }

def foldr[A, B](f: (B, A) =&gt; A, a: A, xs: List[B]): A =
  xs match {
    case Nil =&gt; a
    case y::ys =&gt; f(y, foldr(f, a, ys))
  }
</pre>

<p> 第 1 引数 f が適用する関数、第 2 引数 a が初期値、第 3 引数がリストです。foldl と foldr の返り値は初期値 a の型 A と同じになります。つまり、リストの要素と同じ型である必要はありません。そして、渡される関数の型にも注目してください。foldl の場合、関数の第 1 引数と初期値の型が同じです。第 1 引数に今までの処理結果が渡されて、第 2 引数にリストの要素が渡されることがわかります。これに対し、foldr は逆になっていることに注意してください。
</p>

<p> 最初のマッチング節は再帰呼び出しの停止条件ですが、foldl (foldr) に空リストが与えられた場合にも対応します。この場合は初期値 a を返します。次のマッチング節でリストの要素を取り出して関数 f を呼び出します。
</p>

<p> たとえば、リストが [1, 2, 3] で a が 0 とします。最初は f(0, 1) が実行され、その返り値が foldl の第 2 引数に渡されます。次は f(a, 2) が実行されますが、これは f(f(0, 1), 2) と同じことです。そして、その結果が foldl の第 2 引数になります。最後に f(a, 3) が実行されますが、これは f(f(f(0, 1), 2), 3) となり、上図 (1) と同じ動作になります。
</p>

<p> foldl の場合、リストの要素が関数 f の第 2 引数になり、第 1 引数にはこれまでの処理結果が渡されます。これに対し、foldr の場合は逆になり、関数 f の第 1 引数にリストの要素が渡されて、これまでの処理結果は第 2 引数に渡されます。これで上図 (2) の動作を実現することができます。
</p>


<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; foldl((_: Int) + (_: Int), 0, List(1, 2, 3, 4, 5))
res0: Int = 15

scala&gt; foldr((_: Int) + (_: Int), 0, List(1, 2, 3, 4, 5))
res1: Int = 15
</pre>
<p> Scala のライブラリには、メソッド foldLeft, foldRight が用意されています。
</p>
<pre>
scala&gt; List(1, 2, 3, 4, 5).foldLeft(0)(_ + _)
res2: Int = 15

scala&gt; List(1, 2, 3, 4, 5).foldRight(0)(_ + _)
res3: Int = 15
</pre>
<h4>●畳み込みの使用例</h4>
<p> ところで、foldl, foldr と 2 引数の関数を組み合わせると、いろいろな関数を実現することができます。最初に length の例を示します。
</p>

<pre>
scala&gt; foldl((a: Int, x: Int) =&gt; a + 1, 0, List(1, 2, 3, 4, 5))
res4: Int = 5

scala&gt; foldr((x: Int, a:Int) =&gt; a + 1, 0, List(1, 2, 3, 4, 5))
res5: Int = 5

scala&gt; def length[A](xs: List[A]): Int = foldl((a: Int, x: A) =&gt; a + 1, 0, xs)
length: [A](xs: List[A])Int

scala&gt; length(List(1, 2, 3, 4, 5, 6))
res6: Int = 6
</pre>
<p> foldl で length を実現する場合、初期値を 0 にして第 1 引数の値を +1 することで実現できます。foldr の場合は第 2 引数の値を +1 します。
</p>
<p> 次に map の例を示します。
</p>
<pre>
scala&gt; foldr((x: Int, a: List[Int]) =&gt; (x * x)::a, Nil, List(1,2,3,4,5))
res7: List[Int] = List(1, 4, 9, 16, 25)

scala&gt; def mapcar[A,B](f: A =&gt; B, xs: List[A]): List[B] =
     | foldr((x: A, a: List[B]) =&gt; f(x) :: a, Nil, xs)
mapcar: [A, B](f: A =&gt; B, xs: List[A])List[B]

scala&gt; mapcar((x: Int) =&gt; x * x, List(1, 2, 3, 4, 5))
res8: List[Int] = List(1, 4, 9, 16, 25)
</pre>
<p> map の場合は foldr を使うと簡単です。初期値を Nil にして第 1 引数の計算結果を第 2 引数のリストに追加するだけです。
</p>
<p> 次に filter の例を示します。
</p>
<pre>
scala&gt; foldr((x: Int, a: List[Int]) =&gt; if (x % 2 == 0) x::a else a, Nil, List(1, 2, 3, 4, 5))
res9: List[Int] = List(2, 4)

scala&gt; def filter[A](f: A =&gt; Boolean, xs: List[A]): List[A] =
     | foldr((x: A, a: List[A]) =&gt; if (f(x)) x::a else a, Nil, xs)
filter: [A](f: A =&gt; Boolean, xs: List[A])List[A]

scala&gt; filter((x: Int) =&gt; x % 2 == 0, List(1, 2, 3, 4, 5))
res10: List[Int] = List(2, 4)
</pre>
<p> filter の場合も初期値を Nil にして、第 1 引数が条件を満たしていれば第 2 引数のリストに追加します。
</p>
<p> 最後に述語が真となる要素の個数を求めてみましょう。これは Common Lisp の関数 count-if と同じです。
</p>
<pre>
scala&gt; foldl((a: Int, x: Int) =&gt; if (x % 2 == 0) a + 1 else a, 0, List(1, 2, 3, 4, 5))
res11: Int = 2

scala&gt; def countIf[A](f: A =&gt; Boolean, xs: List[A]): Int =
     | foldl((a:Int, x:A) =&gt; if (f(x)) a + 1 else a, 0, xs)
countIf: [A](f: A =&gt; Boolean, xs: List[A])Int

scala&gt; countIf((x: Int) =&gt; x % 2 == 0, List(1, 2, 3, 4, 5))
res12: Int = 2
</pre>
<p> このように、畳み込みを使っていろいろな処理を実現することができます。
</p>

<h4>●foreach</h4>
<p> 副作用を目的とした高階関数を作ることもできます。foreach はリストの要素に関数を適用しますが、その返り値をリストに格納することはしません。次のリストを見てください。
</p>
<pre class="list">
リスト : foreach

def foreach[A](f: A =&gt; Unit, xs: List[A]): Unit =
  xs match {
    case Nil =&gt; ()
    case x::ys =&gt; { f(x); foreach(f, ys) }
  }

// 別解
def foreach[A](f: A => Unit, xs: List[A]) {
  for (x &lt;- xs) f(x)
}
</pre>
<p> 最初は再帰定義でプログラムしています。関数 f の型は A =&gt; Unit になります。xs が空リストの場合は Unit の値 () を返します。そうでなければ、リストを x::ys で分解して、ブロックの中で f(x) を呼び出したあと、foreach を再帰呼び出しします。別解は for ループでプログラムしたものです。for 式で取り出した要素 x を関数 f に渡して呼び出すだけです。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; foreach(println, List(1,2,3,4,5))
1
2
3
4
5
</pre>
<p> このように、foreach に println を渡すとリストの要素を表示することができます。
</p>

<p> なお、Scala のライブラリには同じ機能を持つメソッド foreach が用意されてます。
</p>
<pre>
scala&gt; List(1,2,3,4,5).foreach(println)
1
2
3
4
5
</pre>
<h4>●for 内包表記</h4>
<p> Scala でリストを操作する場合、高階関数だけではなく「for 内包表記 (for comprehensions) 」を使うことができます。基本的な構文を次に示します。
</p>
<pre class="item">
for (パターン &lt;- コレクション [if (条件式)]) yield 式
</pre>
<p> "パターン &lt;- コレクション" の部分を「ジェネレータ」とか「生成器」といいます。for 式は変数の定義でパターンマッチングを使うことができます。ジェネレータのあとには "if (条件式)" を付けることができます。これを「フィルター」といいます。これは match 式のガード節と同じ意味で、条件式を満たす変数が for の本体 "yield 式" に送られます。yield は式を実行し、その結果を新しく生成したコレクションに格納します。ジェネレータに与えるコレクションの型がリストであれば、生成されるコレクションの型もリストになります。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val a = List(1, 2, 3, 4, 5, 6, 7, 8)
a: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; for (x &lt;- a) yield x * x
res0: List[Int] = List(1, 4, 9, 16, 25, 36, 49, 64)

scala&gt; for (x &lt;- a if x % 2 == 0) yield x * x
res1: List[Int] = List(4, 16, 36, 64)

scala&gt; for (x &lt;- a if x % 2 != 0) yield x * x
res2: List[Int] = List(1, 9, 25, 49)
</pre>
<p> 最初の例は要素を 2 乗したリストを生成します。次の例は、偶数の要素を取り出して 2 乗します。最後の例は奇数の要素を取り出して 2 乗します。これらの動作は高階関数 mapcar や filter と同じです。
</p>

<p> for 内包表記は複数の生成器を指定することもできます。次の例を見てください。
</p>
<pre>
scala&gt; for (x &lt;- List(1,2,3); y &lt;- List(4,5,6)) yield (x, y)
res3: List[(Int, Int)] = List((1,4), (1,5), (1,6), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6))
</pre>
<p> 最初に、x に 1 がセットされ、次にリスト List(4, 5, 6) の要素が y にセットされるので、タプル (1,4), (1,5), (1,6) が生成されます。次に、x の値が 2 にセットされてから、再度 y に List(4, 5, 6) の要素が順番にセットされるので、タプル (2,4), (2,5), (2,6) が生成されます。最後に、x が 3 にセットされてタプル (3,4), (3,5), (3,6) が生成されます。
</p>

<p> また、それぞれの生成器のあとに条件式を設定することもできます。簡単な例を示します。
</p>
<pre>
scala&gt; for (x &lt;- a if x % 2 == 0; y &lt;- a if y % 2 != 0) yield (x, y)
res4: List[(Int, Int)] = List((2,1), (2,3), (2,5), (2,7), (4,1), (4,3), (4,5),
 (4,7), (6,1), (6,3), (6,5), (6,7), (8,1), (8,3), (8,5), (8,7))
</pre>
<p> タプルの第 1 要素 x は偶数、第 2 要素 y は奇数になります。
</p>

<h4>●クイックソート</h4>
<p> それでは簡単な例題として、高速なソートアルゴリズムとして有名な「クイックソート (quick sort) 」を作ってみましょう。クイックソートはある値を基準にして、要素をそれより大きいものと小さいものの 2 つに分割していくことでソートを行います。基準になる値のことを「枢軸」といいます。枢軸は要素の中から適当な値を選んでいいのですが、リストの場合は任意の要素を簡単に選ぶことができません。この場合、いちばん簡単に求めることができる先頭の要素を枢軸とします。
</p>

<p> リストを 2 つに分けたら、それらを同様にソートします。これは、再帰を使えば簡単に実現できます。その結果を枢軸を挟んで結合します。これを図に表すと次のようになります。
</p>
<pre class="fig">
    [5, 3, 7, 6, 9, 8, 1, 2, 4]

          5 を枢軸に分割

   [3, 1, 2, 4]  5  [7, 6, 9, 8]

   3を枢軸に分割    7を枢軸に分割

 [1, 2]  3  [4] | 5 | [6]  7  [9, 8]

  ・・・分割を繰り返していく・・・    

        図 : クイックソート
</pre>
<p> このようにリストを分割していくと、最後は空リストになります。ここが再帰の停止条件になります。あとは分割したリストを結合していけばいいわけです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : クイックソート

object sample0501 {
  def quickSort(xs: List[Int]): List[Int] =
    xs match {
      case Nil =&gt; Nil
      case p::ys =&gt; {
        val a = for (y &lt;- ys if y &lt; p) yield y
        val b = for (y &lt;- ys if y &gt;= p) yield y
        quickSort(a) ::: List(p) ::: quickSort(b)
      }
    }
}
</pre>
<p> 引数のリスト xs が空リストであれば空リストを返します。そうでなければ、リストの先頭要素 p を枢軸として、内包表記で p より小さい要素と p 以上の要素に分けます。あとは quickSort を再帰呼び出しして、その結果を List(x) をはさんで演算子 ::: で連結するだけです。ただし、リスト ys を二分割するとき、ys を 2 回走査することに注意してください。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
scala&gt; :load sample0501.scala
Loading sample0501.scala...
defined object sample0501

scala&gt; import sample0501._
import sample0501._

scala&gt; quickSort(List(5,4,6,3,7,2,8,1,9,0))
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>
<p> 正常に動作していますね。
</p>

<h4>●クイックソートの弱点</h4>
<p> クイックソートの実行時間は、データ数を N とすると平均して N * log2 N に比例します。ところが、枢軸の選び方によっては、最悪で N の 2 乗に比例するところまで劣化します。つまり、挿入ソートと同じくらい遅くなってしまうのです。たとえば、リストの先頭要素を枢軸として選ぶ場合、リストの要素が昇順または降順に並んでいると最悪の結果になります。
</p>

<p> このため、クイックソートをプログラムする場合、枢軸の選び方を工夫するのが一般的です。たとえば、データの中からいくつかの要素を選び、その中で中間の値を持つ要素を枢軸に選びます。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、中間の値を選ぶのに時間がかかってしまいます。実際には、3 つから 5 つの要素を選んで、その中で中間の値を枢軸とする場合が多いようです。
</p>

<p> ただし、この改良方法はリストには不向きであることに注意してください。リストはデータ数が多くなるほど、後ろのデータを取り出すのに時間がかかるようになります。先頭から 3 つのデータを取り出して枢軸を選んだとしても、降順または昇順に並んだデータには効果が無いのは明らかです。このため、リストのソートはクイックソートよりも「マージソート (merge sort) 」の方が適しているといわれています。
</p>

<h4>●リストの平坦化</h4>
<p> もうひとつ簡単な例題として、リストを平坦化する関数 flatten を作ってみましょう。簡単な動作例を示します。
</p>
<pre class="item">
flatten(List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9)))
=&gt; List(1, 2, 3, 4, 5, 6, 7, 8, 9)
flatten(List(List(1, 2, 3), Nil, List(4, 5, 6), Nil, List(7, 8, 9)))
=&gt; List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : リストの平坦化

object sample0502 {
  def flatten[A](xs: List[List[A]]): List[A] =
    xs match {
      case Nil =&gt; Nil
      case ys::zs =&gt; ys ::: flatten(zs)
    }

  // 内包表記
  def flatten1[A](xs: List[List[A]]): List[A] =
    for (ys &lt;- xs; y &lt;- ys) yield y

}
</pre>
<p> flatten はリストの先頭要素 ys を取り出して、ys と次の要素を演算子 ::: で結合すればいいわけです。for 内包表記を使うともっと簡単になります。リスト xs から要素 ys を取り出し、ys からさらに要素 y を取り出します。あとは、y をリストに格納して返すだけです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; :load sample0502.scala
Loading sample0502.scala...
defined object sample0502

scala&gt; import sample0502._
import sample0502._

scala&gt; flatten(List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9)))
res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; flatten1(List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9)))
res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; flatten(List(List(1, 2, 3), Nil, List(4 ,5, 6), Nil, List(7, 8, 9)))
res2: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; flatten1(List(List(1, 2, 3), Nil, List(4, 5, 6), Nil, List(7, 8, 9)))
res3: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>
<p> 正常に動作していますね。なお、Scala のライブラリにもメソッド flatten が用意されています。
</p>
<pre>
scala&gt; List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9)).flatten
res4: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; List(List(1, 2, 3), Nil, List(4, 5, 6), Nil, List(7, 8, 9)).flatten
res5: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">レキシカルスコープとクロージャ</h3>
<p> 変数の有効範囲を表す用語に「スコープ (scope) 」があります。この用語を使うと、厳密ではありませんが、変数の有効範囲は「レキシカルスコープ (lexical scope) 」と「ダイナミックスコープ (dynamic scope) 」の 2 つに分けることができます。伝統的な Lisp、たとえば Emacs Lisp はダイナミックスコープですが、現在の Scheme や Common Lisp はレキシカルスコープです。Scala もレキシカルスコープを採用しています。
</p>

<h4>●レキシカルスコープ</h4>
<p> それでは、レキシカルスコープについて詳しく見てみましょう。フィールド変数 x を表示する関数 foo を定義します。
</p>
<pre class="list">
リスト ; レキシカルスコープ

object sample0503 {
  var x = 10

  def foo() = println(x)

  def foo1() = {
    val x = 100
    println("local value: " + x)
    foo()
  }

  def main(args: Array[String]) {
    println("call foo")
    foo()
    println("call foo1")
    foo1()
  }
}
</pre>
<pre>
C&gt;sample0503
call foo
10
call foo1
local value: 100
10
</pre>
<p> 関数 foo には局所変数 x を定義していないので、foo を実行した場合はフィールド変数の値を参照します。その結果 10 が表示されます。それでは、foo1 という関数から foo を呼び出す場合を考えてみましょう。foo1 には let で局所変数 x を定義します。この場合、foo はどちらの値を表示するのでしょうか。実際に試してみると、10 と表示されました。
</p>

<p> このように、foo1 で定義した局所変数 x は、foo から参照することはできません。次の図を見てください。
</p>
<pre class="fig">
┌────── object sample0503─────┐ 
│                                        │
│        フィールド変数  x ←────┐  │
│                                    │  │
│  ┌→┌─ 関数 foo ──────┐  │  │
│  │  │                ┌───┼─┘  │
│  │  │        println(x)      │      │
│  │  │                        │      │
│  │  └────────────┘      │
│  │  ┌─ 関数 foo1  ─────┐      │
│  │  │                        │      │
│  │  │  ┌─val : x ───┐  │      │
│  │  │  │                │  │      │
│  └─┼─┼─ foo()        │  │      │
│      │  └────────┘  │      │
│      └────────────┘      │
│                                        │
└────────────────────┘

        図 : レキシカルスコープ
</pre>
<p> 上図では変数の有効範囲を枠で表しています。foo1 の val で定義した局所変数 x は、それを定義したブロックの枠の中でのみ有効です。もしも、この枠で変数が見つからない場合は、ひとつ外側の枠を調べます。順番に外側の枠を調べていくと、最後には関数定義の枠に行き着きます。ここで変数（引数）が見つからない場合はフィールド変数を調べます。
</p>
<p> 関数 foo は関数定義の枠しかありません。そこに変数 x が定義されていないので、フィールド変数を調べることになるのです。このように、関数 foo から foo1 の枠とブロックの枠を超えて変数 x にアクセスすることはできないのです。これを「レキシカルスコープ」といいます。レキシカルには文脈上いう意味があり、変数が定義されている構造の範囲内 (枠内) でないと、その変数にアクセスすることはできません。
</p>
<p> ところが伝統的な Lisp の場合、foo1 で定義した変数 x は呼び出された関数 foo からアクセスすることができます。これを「ダイナミックスコープ」といいます。foo1 で定義された変数 x は、foo1 の実行が終了するまで存在します。そして、foo1 から呼ばれた関数ならば、どこからでも参照することができるのです。もしも、foo1 をダイナミックスコープの処理系、たとえば Emacs Lisp で実行するならば、foo で表示される x の値は 100 になります。
</p>

<h4>●レキシカルスコープと局所関数</h4>
<p> それでは、関数の中で定義された局所関数や無名関数の場合はどうなるのでしょうか。次の例を見てください。
</p>

<pre>
scala&gt; def timesElement(n: Int, xs: List[Int]): List[Int] =
     | xs.map((x: Int)=&gt; x * n)
timesElement: (n: Int, xs: List[Int])List[Int]

scala&gt; timesElement(10, List(1,2,3,4,5))
res0: List[Int] = List(10, 20, 30, 40, 50)
</pre>

<p> 無名関数の引数は x だけなので、変数 n はフィールド変数を参照するように思われるかもしれません。ところが、変数 n は関数 timesElement の引数 n を参照するのです。これを図に示すと、次のようになります。
</p>

<pre class="fig">
┌──────  Scala REPL  ──────┐
│                                      │
│    ┌─ timesElement : n, xs ─┐    │
│    │                  ↑      │    │
│    │                  └─┐  │    │
│    │  ┌── fun : x  ─┐│  │    │
│    │  │          ↑    ││  │    │
│    │  │    ┌──┘    ││  │    │
│    │  │     x * n      ││  │    │
│    │  │        └───┼┘  │    │
│    │  └────────┘    │    │
│    └─────────────┘    │
│                                      │
└───────────────────┘

        図 : 無名関数 (fun) 内の変数
</pre>

<p> ポイントは、無名関数が timesElement 内で定義されているところです。変数 n は関数の引数として定義されていて、その有効範囲は関数の終わりまでです。無名関数はその範囲内に定義されているため、変数 n にアクセスすることができるのです。つまり、関数内で定義された無名関数は、そのとき有効な局所変数にアクセスすることができるのです。
</p>

<p> これは def で定義された局所的な関数も同じです。timesElement は次のように書き換えることができます。
</p>

<pre>
scala&gt; def timesElement1(n: Int, xs: List[Int]): List[Int] = {
     | def timesN(x: Int): Int = x * n
     | xs.map(timesN)
     | }
timesElement1: (n: Int, xs: List[Int])List[Int]

scala&gt; timesElement1(10, List(1, 2, 3, 4, 5))
res1: List[Int] = List(10, 20, 30, 40, 50)
</pre>
<p> 局所関数 timesN は timesElement 内で定義されているので、timesN から timesElement の引数 n を参照することができます。
</p>

<h4>●クロージャ</h4>
<p> Lisp などの関数型言語では、関数を生成する関数を簡単に作ることができます。このとき使われる機能が「クロージャ (closure) 」です。クロージャは評価する関数と参照可能な局所変数をまとめたものです。クロージャは関数のように実行することができますが、クロージャを生成するときに参照可能な局所変数を保持するところが異なります。参照可能な局所変数の集合を「環境」と呼ぶことがあります。
</p>

<p> Scala の関数はカリー化できるので、関数を返す関数はとても簡単に作成することができます。また、Scala は関数型言語でもあるので、当然ですがクロージャも使うことができます。Scala でクロージャを生成するには「無名関数」を使うか、局所的な関数を定義して、その関数を返します。たとえば、「引数を n 倍する関数」を生成する関数は、無名関数を使うと次のようになります。
</p>
<pre>
scala&gt; def foo(n: Int): (Int =&gt; Int) = (x: Int) =&gt; x * n
foo: (n: Int)Int =&gt; Int

scala&gt; val foo10 = foo(10)
foo10: Int =&gt; Int = &lt;function1&gt;

scala&gt; foo10(1)
res0: Int = 10

scala&gt; foo10(2)
res1: Int = 20

scala&gt; val foo5 = foo(5)
foo5: Int =&gt; Int = &lt;function1&gt;

scala&gt; foo5(10)
res2: Int = 50

scala&gt; foo5(20)
res3: Int = 100
</pre>
<p> 関数 foo は引数を n 倍する関数を生成します。関数 foo の型は、引数 Int を受け取り Int =&gt; Int という関数を返すことを表しています。変数 foo10 に foo(10) の返り値をセットします。すると、foo10 は引数を 10 倍する関数として使うことができます。同様に、変数 foo5 に foo(5) の返り値をセットすると、foo5 は引数を 5 倍する関数になります。
</p>

<p> 無名関数を生成するとき、評価する関数のほかに、そのとき参照可能な局所変数、つまり「環境」もいっしょに保存されます。この場合、参照可能な局所変数は foo の引数 n です。そして、クロージャを実行するときは、保存されている局所変数を参照することができるのです。
</p>
<p> foo(10) を実行して無名関数を生成するとき、定義されている局所変数は n で、その値は 10 ですね。この値がクロージャに保存されているので、foo10 の関数は引数を 10 倍した結果を返します。foo(5) を評価すると n の値は 5 で、それがクロージャに保存されているので、foo5 の関数は引数を 5 倍した結果を返すのです。
</p>

<p> また、def で局所的な関数を定義して、その関数を返すとクロージャを生成することができます。def を使った例を示します。
</p>
<pre>
scala&gt; def foo(n:Int):(Int =&gt; Int) = {
     | def bar(x:Int):Int = x * n
     | bar
     | }
foo: (n: Int)Int =&gt; Int

scala&gt; val foo20 = foo(20)
foo20: Int =&gt; Int = &lt;function1&gt;

scala&gt; foo20(11)
res7: Int = 220

scala&gt; foo20(22)
res8: Int = 440
</pre>
<p> def で局所関数 bar を定義して、bar を返します。すると、foo は「引数を n 倍する関数」を生成する関数になります。
</p>
<p> もっとも、Scala では関数を部分適用するだけで同様の関数を作ることができます。
</p>
<pre>
scala&gt; def foo(n: Int)(x: Int): Int = n * x
foo: (n: Int)(x: Int)Int

scala&gt; val foo100 = foo(100)_
foo100: Int =&gt; Int = &lt;function1&gt;

scala&gt; foo100(111)
res9: Int = 11100

scala&gt; foo100(222)
res10: Int = 22200
</pre>
<p> このように、Scala は関数の部分適用により目的の関数を簡単に生成することができます。
</p>

<h4>●環境の仕組み</h4>
<p> クロージャを理解する場合、環境を「連想リスト (association list : a-list) 」で考えるとわかりやすいと思います。
</p>

<p> 一般に、関数を呼び出す場合、関数を評価するための環境は空リストです。最初に、引数がこの環境に追加されます。val や var で定義される局所変数もこの環境に追加されます。もしも、環境に該当する変数が存在しない場合は大域変数を参照します。
</p>

<p> たとえば、foo(5) と呼び出すと環境は次のようになります。
</p>
<pre class="item">
foo(5) ==&gt; 環境 : [(n, 5)]
</pre>

<p> 連想リストのキー n が変数名で、その値が 5 です。クロージャを生成するとき、この連想リストを保持すると考えてください。そして、クロージャを評価するときは、保存していた環境を使います。したがって、foo5(11) を評価すると、環境 [(n, 5)] に引数 x の値が追加され、[(x, 11), (n, 5)] になります。この環境で式 n * x を評価するので、5 * 11 = 55 を返すわけです。
</p>

<p> 関数の評価が終了すると、環境に追加された変数は削除されます。foo5(11) の評価で追加された変数は x なので、(x, 11) が削除され [(n, 5)] になります。このように、クロージャに保存された環境は変化しません。
</p>

<h4>●ジェネレータ</h4>
<p> 最後に、クロージャの応用例として「ジェネレータ (generator) 」というプログラムを紹介しましょう。ジェネレータは、呼び出されるたびに新しい値を生成していきます。Scala の場合、ジェネレータと同じことは「イテレータ (Iterator) 」を使って行うことができますが、クロージャでも簡単にプログラムすることができます。
</p>

<p> 簡単な例題として、奇数列 ( 1, 3, 5, ..... ) を発生するジェネレータを作ってみます。関数名は genOddNumber としましょう。genOddNumber は呼び出されるたびに新しい奇数を返します。いちばん簡単な実装方法は、返した値を大域変数に記憶しておくことです。genOddNumber のプログラムは次のようになります。
</p>
<pre class="list">
リスト : 奇数を発生するジェネレータ

object sample0504 {

  var prevNumber = -1

  def genOddNumber(): Int = {
    prevNumber += 2
    prevNumber
  }
}
</pre>
<pre>
scala&gt; :load sample0504.scala
Loading sample0504.scala...
defined object sample0504

scala&gt; import sample0504._
import sample0504._

scala&gt; for (i <- 1 to 10) println(genOddNumber)
1
3
5
7
9
11
13
15
17
19
</pre>
<p> フィールド変数 prevNumber は、genOddNumber が返した値を記憶します。新しい値は、この prevNumber に 2 を足せばいいのです。
</p>

<p> このように、大域変数を使うと簡単にジェネレータを作ることができますが問題点もあります。それは、複数のジェネレータが必要になる場合です。単純に考えると、必要な数だけ大域変数と関数を用意すればいいのですが、数が増えると大域変数や関数を定義するだけでも大変な作業になります。
</p>

<p> ところがクロージャを使うと、もっとスマートにジェネレータを用意できます。まず、ジェネレータを作る関数を定義します。
</p>
<pre class="list">
リスト : ジェネレータを作る関数

  // sample0504 に追加
  def makeGen(): (() =&gt; Int) = {
    var prevNumber = -1
    () =&gt; {
      prevNumber += 2
      prevNumber
    }
  }
</pre>
<p> 関数 makeGen はクロージャを返します。そして、このクロージャがジェネレータの役割を果たすのです。それでは、実際に実行してみましょう。
</p>
<pre>
scala&gt; val g1 = makeGen()
g1: () =&gt; Int = &lt;function0&gt;

scala&gt; g1()
res0: Int = 1

scala&gt; g1()
res1: Int = 3

scala&gt; g1()
res2: Int = 5

scala&gt; val g2 = makeGen()
g2: () =&gt; Int = &lt;function0&gt;

scala&gt; g2()
res3: Int = 1

scala&gt; g2()
res4: Int = 3

scala&gt; g2()
res5: Int = 5
</pre>
<p> makeGen で作成したクロージャを変数 g1 にセットして実行します。実行するたびに 1, 3, 5 と奇数列を生成していますね。次に新しいクロージャを変数 g2 にセットします。このクロージャを実行すると、新しい奇数列を生成します。確かにジェネレータとして動作しています。
</p>

<p> このプログラムのポイントは局所変数 prevNumber です。クロージャで保存される環境は変数 prevNumber です。この値は makeGen が実行されたときに -1 で初期化されています。クロージャにはこの値が保存されます。
</p>

<p> 次に、g1 にセットしたクロージャを実行します。匿名関数は、クロージャに保存された局所変数にアクセスするので、prevNumber += 2 の値は 1 になり、クロージャに保持されている prevNumber の値は 1 に更新されます。
</p>

<p> 環境はクロージャによって異なります。g1 のクロージャが評価されると、そのクロージャの環境が更新されるのであって、ほかのクロージャに影響を与えることはありません。したがって、ジェネレータが発生する奇数列が、ほかのジェネレータに影響を与えることはないのです。あとは必要な数だけジェネレータを makeGen で作り、そのクロージャを変数に格納しておけばいいわけです。
</p>

<p> 次は、奇数列を最初に戻す、つまり、ジェネレータをリセットすることを考えてみましょう。この場合、クロージャ内の変数を書き換えるしか方法はありません。そこで、makeGen の返り値を 2 つに増やすことにします。最初の返り値は奇数列を発生するジェネレータで、2 番目の返り値はジェネレータをリセットする関数とします。プログラムは次のようになります。
</p>
<pre class="list">
リスト : ジェネレータのリセット

  // sample0504 に追加
  def makeGen1(): (() =&gt; Int, () =&gt; Unit) = {
    var prevNumber = -1
    (() =&gt; {
       prevNumber += 2
       prevNumber
     },
     () =&gt; prevNumber = -1)
  }
</pre>

<p> 返り値の型はタプルで、奇数列を返す関数 () =&gt; Int とジェネレータをリセットする関数 () =&gt; Unit を格納します。どちらの関数も無名関数を使って簡単に定義することができます。あとは、それをタプルに格納して返すだけです。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
scala&gt; val (gen, reset) = makeGen1()
gen: () =&gt; Int = &lt;function0&gt;
reset: () =&gt; Unit = &lt;function0&gt;

scala&gt; gen()
res0: Int = 1

scala&gt; gen()
res1: Int = 3

scala&gt; gen()
res2: Int = 5

scala&gt; gen()
res3: Int = 7

scala&gt; reset()

scala&gt; gen()
res4: Int = 1

scala&gt; gen()
res5: Int = 3
</pre>
<p> 正常に動作していますね。
</p>

<p> クロージャは少し難しいかもしれませんが、 便利で面白い機能です。少々歯応えがありますが、 これもプログラミングの面白いところだと思います。興味のある方はいろいろと試してみてください。 
</p>
<h4>●イテレータ</h4>
<p> ご参考までに、Scala のイテレータを簡単に説明しておきます。Scala の場合、データ (オブジェクト) にメソッド iterator があれば、そのデータをイテレータに変換することができます。イテレータの型は "Iterator[型]" で表され、メソッド has.Next でデータの有無を判定し、メソッド next でイテレータからデータを順番に取り出すことができます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
scala&gt; val iter = Range(1, 10, 2).iterator
iter: Iterator[Int] = non-empty iterator

scala&gt; iter.hasNext
res0: Boolean = true

scala&gt; iter.next
res1: Int = 1

scala&gt; iter.next
res2: Int = 3

scala&gt; iter.next
res3: Int = 5

scala&gt; iter.next
res4: Int = 7

scala&gt; iter.next
res5: Int = 9

scala&gt; iter.hasNext
res6: Boolean = false

scala&gt; iter
res7: Iterator[Int] = empty iterator
</pre>
<p> 数列を表す Range を iterator でイテレータに変換し、変数 iter にセットします。すると、iter.next が数列の要素を一つずつ順番に取り出すことができます。リストや配列もイテレータに変換することができますし、自分でイテレータを作ることもできます。詳細はオブジェクト指向のところで説明する予定です。
</p>
</section>
<hr>
<div class="ce">
<b> Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="scala04.html">PrevPage</a> | <a href="scala.html">Scala</a> | <a href="scala06.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>