<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門</title>
  <meta name="description" content="xyzzy,xyzzy Lisp,Common Lisp,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881766</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>xyzzy Lisp Programming</h1>
<h2>Common Lisp 入門</h2>
<div class="small">
[ <a href="abclisp16.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp18.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap32">複数の値を返す方法（多値）</h3>
<p> 一般に、関数の返り値はひとつしかありません。複数の値を返す場合、Lisp ではリストに格納して返すのがふつうです。この場合、返す側は必要なデータをリストに格納し、受け取る側はリストからデータを取り出す処理が必要になります。ところが、Common Lisp の <b>多値 (Multiple Values)</b> という機能を使うと、複数の値を簡単にやり取りすることができます。
</p>

<h4>●複数の値を受け取る</h4>
<p> 複数の値を受け取るには、マクロ multiple-value-bind を使うと簡単です。
</p>
<pre class="item">
multiple-value-bind (&amp;rest vars) values-form &amp;rest form
</pre>
<p> multiple-value-bind は、多値を返す関数 values-form を評価し、その結果を vars で定義した変数にセットします。変数はレキシカル変数として設定されるので、multiple-value-bind を実行している間だけ有効です。簡単な例を示しましょう。Common Lisp には、整数でない値を整数に変換する関数 floor, ceiling, truncate, round が定義されています。これらの関数は 2 つの値（多値）を返します。
</p>
<pre>
(truncate 10 3)
=&gt; 3

(multiple-value-bind
    (q r)
    (truncate 10 3)
    (format nil "商 ~D, 余り ~D" q r))
=&gt; "商 3, 余り 1"
</pre>
<p> 関数 truncate は割り算を行って商と余りを返します。ふつうに truncate を呼び出すと商を返すだけですが、multiple-value-bind を使うと、商のほかに余りも受け取ることができます。q と r は truncate が返す値を受け取る変数です。次に、truncate を評価して結果を変数にセットします。あとは、残りの form を順番に評価していきます。multiple-value-bind は最後に評価した form の値を返します。
</p>
<p> もしも、返される値よりも変数の個数が多い場合、残りの変数には nil がセットされます。逆に、返される値が変数よりも多い場合、余分な値は捨てられます。次の例を見てください。
</p>
<pre>
(multiple-value-bind (q)
    (truncate 10 3)
    (list q))
=&gt; (3)

(multiple-value-bind (q r s)
    (truncate 10 3)
    (list q r s))
=&gt; (3 1 nil)
</pre>
<p> 最初の例では、変数 q しか定義されていないので、q には商がセットされますが余りは捨てられます。次の例では、変数 s が定義されていますが、truncate は 2 つの値しか返さないので、s には nil がセットされます。
</p>

<h4>●複数の値を返す</h4>
<p> 次は、複数の値を返す方法を説明します。これはとても簡単で、関数 values を使うだけです。
</p>
<pre class="item">
values &amp;rest args
</pre>
<p> 引数 args を値として順番に帰します。簡単な例を示しましょう。
</p>
<pre>
(defun foo (x y z) (values x y))

(multiple-value-bind (a b c)
    (foo 1 2 3)
    (list a b c))
=&gt; (1 2 nil)
</pre>
<p> foo は 3 つ受け取る引数から最初の 2 つを返します。これは (values x y) とすればいいですね。実際に試してみると、multiple-value-bind で 2 つの値を受け取ることができます。
</p>

<h4>●その他</h4>
<p> このように、多値の操作は multiple-value-bind と values を使って簡単に行うことができます。このほかにも、便利な関数やマクロがあるので紹介しましょう。
</p>
<pre class="item">
values-list list
multiple-value-list form
</pre>
<pre>
(multiple-value-list (truncate 10 3))
=&gt; (3 1)
</pre>
<p> 関数 values-list は list の要素を多値として返します。逆に、マクロ multiple-value-list は form を評価して、多値をリストに格納して返します。
</p>
<pre class="item">
multiple-value-call function &amp;rest form
</pre>
<p> 特殊形式 multiple-value-call は、form を評価した結果をすべて集めて、それらを引数として function に渡して評価します。次の例を見てください。
</p>
<pre>
(multiple-value-call #'+ (truncate 10 3) (truncate 14 3))
=&gt; (+ 3 1 4 2)
=&gt; 10
</pre>
<p> 最初の truncate は 3 と 1 を返し、次は 4 と 2 を返します。したがって、関数 + には 3, 1, 4, 2 が引数として与えられ、その結果が 10 となるのです。function に #'list を与えれば、multiple-value-list と同様の働きをします。
</p>
<pre class="item">
multiple-value-prog1 form &amp;rest forms
</pre>
<p> prog1 の多値バージョンです。複数の form を順番に評価しますが、最初に評価した form の結果（多値）を返します。
</p>
<pre class="item">
multiple-value-setq var-list form
</pre>
<p> multiple-value-bind の setq バージョンです。ようするに、var-list で指定した変数に値を代入するだけで、これらの変数はレキシカル変数として設定されるわけではありません。let などで定義したレキシカル変数や、スペシャル変数へ値を代入するときに使うと便利でしょう。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap33">二分探索木</h3>
<p> 今回は構造体の具体的な使用例として、<b>二分探索木</b>という探索アルゴリズムを Lisp で実装してみましょう。
</p>
<p> あるデータの中から特定のデータを探す場合、データ数が少なければ力任せに探索しても何とかなりますが、データ数が多くなると探索に時間がかかるようになります。このような場合、あらかじめデータを整理整頓しておくことで、特定のデータを高速に見つけることができるようになります。この代表的なアルゴリズムが<b>ハッシュ法</b>と<b>二分探索木</b>です。
</p>
<p> Common Lisp にはハッシュ表が用意されているので、二分探索木を使う機会は少ないでしょう。ですが、二分探索木にはハッシュにはない特徴があります。格納されたデータをある順番で出力すると、それはソートした結果と同じになるのです。また、データの中から最大値や最小値を簡単に見つけることができます。データを見つけることだけならばハッシュの方が高速なのですが、データの大小関係が絡む処理には、二分探索木の方が適しているのです。
</p>

<h4>●構造体の定義</h4>
<p> 木構造の場合、リストのセルに相当するデータ構造を<b>節(node)</b>と呼び、複数の節を連結することで木構造を表します。木構造の詳しい説明は拙作のページ <a href="abclisp09.html#yori13">ちょっと寄り道「木構造と二分木」</a> をお読みください。たとえば、二分木の節は次のように表すことができます。
</p>

<pre class="list">
List 1 : 節の定義

; 節
(defstruct Node
    value       ; データ
    left        ; 左の子
    right)      ; 右の子
</pre>
<p> スロット value にデータを格納し、left は左側の子、right は右側の子を格納します。スロット left からデータを取り出せば、左側の節へ移動することができ、right からデータを取り出せば、右側の節へ移動することができます。子がない場合、left と right には nil をセットすることにします。
</p>
<p> 次に、二分木のルートを格納する構造体を定義します。
</p>

<pre class="list">
List 2 : ルートの定義

; ルート
(defstruct Tree
    root         ; ルート
    compare)     ; 比較関数
</pre>

<p> 構造体 Tree は、二分木の根 root と比較関数を格納します。実際の二分木は Node を使って実現します。二分木を操作する場合、データの比較関数が必要になります。たとえば、数値を格納するのであれば、数値の比較関数を使って操作関数を作ればいいのですが、それでは数値専用の二分木になってしまいますね。
</p>
<p> オブジェクト指向の場合、比較関数をメソッドとして定義すれば、データ型によって比較関数を自動的に選択することができます。このため、二分探索木のプログラムを変更しなくても、あらゆるデータ（オブジェクト）に対応することができます。しかしながら、構造体ではそのようなことはできません。
</p>
<p> そこで、make-Tree でルートを生成するときに、使用する比較関数をキーワード :compare でセットしてもらうことにします。データを比較するときは、スロット compare に格納されている比較関数を使うように、プログラムを作るわけです。比較関数は次に示す仕様を満たすものとします。
</p>
<pre class="item">
引数 obj1 obj2
OUTPUT : obj1 &lt; obj2  --&gt; -1
         obj1 = obj2  --&gt;  0
         obj1 &gt; obj2  --&gt;  1
</pre>
<p> 比較関数は 2 つの引数 obj1 と obj2 を比較し、-1, 0, 1 のいずれかの値を返します。これは Perl の演算子 &lt;=&gt; と同じ仕様です。たとえば、数値を格納する場合は、次のような定義になるでしょう。
</p>

<pre class="list">
List 3 : 数値の比較関数

(defun num-comp (n1 n2)
  (cond ((= n1 n2) 0)
        ((&gt; n1 n2) 1)
        (t        -1)))
</pre>

<h4>●探索</h4>
<p> それでは、二分木の中からデータを探索する search-tree を作ります。これは簡単です。プログラムは次のようになります。
</p>

<pre class="list">
List 4 : データの探索

(defun search-tree (root value)
  (check-tree-p root)
  (let ((node (Tree-root root))
        (func (Tree-compare root)))
    (while node
      (case (funcall func value (Node-value node))
        ( 0 (return t))
        ( 1 (setq node (Node-right node)))
        (-1 (setq node (Node-left  node)))))))
</pre>

<p> 再帰を使ってもいいのですが、繰り返しでも簡単にプログラムできます。最初に、データ型のチェックを行っています。次に、ルートと比較関数を取り出し、二分木をたどってデータを探索します。このプログラムでは、
</p>
cond ではなくマクロ case を使っています。
<pre class="fig">
(case キーとなるＳ式
      ( キーリスト１ Ｓ式A1 Ｓ式A2 ... )
      ( キーリスト２ Ｓ式B1 Ｓ式B2 ... )
        ・・・・・
      ( キーリストＭ Ｓ式M1 Ｓ式M2 ... )
      ( t Ｓ式T1 Ｓ式T2 ... ))
</pre>
<p> case は最初にキーとなる S 式を受け取り、そのあと cond と同様に複数の節が続きます。cond には節の先頭に条件部がありましたが、case の場合はキーリストというものがあります。まず、キーとなる S 式を評価します。次に、この評価結果とキーリストに格納された要素を比較します。このとき、キーリスト本体や要素は評価されないことに注意してください。もし、等しい要素を見つけた場合は、その節の S 式を順番に実行します。キーリストの要素がひとつしかない場合は、要素だけ書いてもかまいません。
</p>

<p> データ型のチェックは簡単です。
</p>

<pre class="list">
List 5 : データ型のチェック

(defun check-tree-p (data)
  (unless (Tree-p data)
    (error "引数には Tree を指定してください"))
  (unless (Tree-compare data)
    (error "比較関数を指定してください")))
</pre>

<p> データを Tree-p でチェックし、比較関数が指定されていなければエラーとします。
</p>

<h4>●挿入</h4>
<p> 次はデータを挿入する insert-tree です。
</p>

<pre class="list">
List 6 : データの挿入

(defun insert-tree (root value)
  (check-tree-p root)
  (setf (Tree-root root)
        (insert-tree-sub (Tree-root root) value (Tree-compare root))))
</pre>

<p> 実際にデータを挿入する関数は insert-tree-sub が担当します。
</p>

<pre class="list">
List 7 : 挿入関数の本体

(defun insert-tree-sub (node value func)
  (if (null node)
    (setq node (make-Node :value value))
    (case (funcall func value (Node-value node))
      ( 1 (setf (Node-right node)
                (insert-tree-sub (Node-right node) value func)))
      (-1 (setf (Node-left node)
                (insert-tree-sub (Node-left node) value func)))))

  ; 返り値は node だよ
  node)
</pre>
<p> insert-tree-sub は再帰関数で、データを挿入した新しい部分木を返します。これでデータが挿入されます。よくわからないという方は、拙作のプログラミング入門講座を参照してください。
</p>

<h4>●出力</h4>
<p> 最後に、データを表示する関数 print-tree を作ります。
</p>

<pre class="list">
List 8 : データの出力

(defun print-tree (root)
  (check-tree-p root)
  (print-tree-sub (Tree-root root)))
</pre>
<p> 実際の仕事は print-tree-sub で行います。
</p>
<p> ところで、木のすべての節を規則的な順序で回ることを<b>巡回 (traverse)</b> といいます。この中で重要なのが次の方法です。
</p>
<ol>
  <li><b>行きがけ順</b><br>
     まず節のデータを出力し、そのあと、左の子、右の子の順番で出力。
  <li><b>帰りがけ順</b><br>
     左の子、右の子を出力してから、節のデータを出力。
  <li><b>通りがけ順</b><br>
     左の子を出力してから、節のデータを出力し、最後に右の子を出力。
</ol>
<p> 二分木の場合、通りがけ順でデータを出力すると、ソートした出力結果を得ることができます。print-tree-sub は次のようになります。
</p>

<pre class="list">
List 9 : 通りがけで出力

(defun print-tree-sub (node)
  (when node
    (print-tree-sub (Node-left node))
    (print (Node-value node))
    (print-tree-sub (Node-right node))))
</pre>
<p> print-tree-sub も再帰を使えば簡単ですね。
</p>

<h4>●実行結果</h4>
<p> それでは、実行してみましょう。
</p>
<pre>
(setq *r* (make-Tree :compare #'num-comp))
=&gt; #S(Tree root nil compare #&lt;lexical-closure: ・・省略・・&gt;)

(dotimes (x 10) (insert-tree *r* (random 1000)))

(print-tree *r*)

11 
192 
337 
449 
535 
623 
626 
630 
743 
757 
nil
</pre>
<p> 正常に動作していますね。このように、二分探索木を通りがけで出力すると、その結果はソートされるのです。
</p>
<p> ところで、このプログラムはマクロを多用しているので、バイトコンパイルしてから実行した方が良いでしょう。また、実際に使うのであれば、<b>パッケージ (package)</b> としてまとめておいたほうがよいでしょう。M.Hiroi は Common Lisp のパッケージを使ったことがほとんどありません。勉強しないといけませんね。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap34">パッケージの基本的な使い方</h3>
<h4>●パッケージとは？</h4>
<p> プログラムを作っていると、ほかのプログラムで作った関数が利用できるのではないか、といった場面に出あうことがあります。このような場合、自分で作成した関数をライブラリとしてまとめておくと、簡単に再利用することができて便利です。
</p>
<p> ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、同じ名前の関数や変数が存在すると、そのライブラリは正常に動作しないでしょう。このような名前の衝突を避けるために、Common Lisp では<b>パッケージ (package)</b> を使います。次の例を見てください。
</p>
<pre class="list">
; ファイル bar.l

(defpackage "bar")
(in-package "bar")

(defvar aaa 10)
(defvar bbb 20)
(defun test () (print "package bar"))
</pre>
<p> このファイルをロードしてから、*scratch* で次のプログラムを実行します。
</p>
<pre>
(setq aaa 100)    ; パッケージ user の変数 aaa
100
bar::aaa          ; パッケージ bar の変数 aaa
10
</pre>
<p> defpackage はパッケージを定義するマクロです。あとで詳しく説明しますが、ここでは bar という名前のパッケージを定義しています。マクロ in-package は、シンボルが所属するパッケージを指定します。Lisp 処理系は、グローバル変数 *package* の値を<b>カレントパッケージ</b>として扱い、このパッケージの中からシンボルを探したり、シンボルを新規に登録します。in-package は *package* の値を切り替えます。これ以降、ファイル bar.l で定義される関数や変数名はパッケージ bar に属します。
</p>
<p> 通常、カレントパッケージは <b>user</b> という、Lisp 処理系があらかじめ用意しているパッケージになっています。*scratch* で定義する変数や関数は user に登録されます。したがって、最初 aaa に 100 を代入しましたが、この変数はパッケージ user 内に定義されます。
</p>
<p> ほかのパッケージの変数や関数は、<b>パッケージ名::名前</b>のようにアクセスすることができます。これを<b>パッケージ修飾子</b>といいます。パッケージ bar の変数 aaa は、bar::aaa でアクセスすることができ、その値は 10 になります。このように、同じ変数名 aaa でも、パッケージによって区別されるのです。変数 aaa が衝突することはありません。
</p>
<p> 関数の呼び出しも同じです。bar に定義されている関数 test は、次のように呼び出すことができます。
</p>
<pre>
(bar::test)
"package bar"
</pre>
<p> 大昔の Lisp 処理系では、システム内のシンボルを <b>oblist</b> というリストで管理していました。今では、ハッシュ表を使って管理するのが一般的です。拙作の Lisp インタプリタ VTOL の場合、oblist はシステム内のシンボルをリストに格納して返す関数として定義しています。昔の Lisp 処理系は、oblist はひとつしかありませんでした。VTOL の場合も、シンボルを管理するハッシュ表はひとつしかありません。
</p>
<p> パッケージとは、「複数のハッシュ表を使ってシンボルを管理するシステム」と考えてください。パッケージ user に定義されているシンボルは、user に対応するハッシュ表に登録され、bar で使用されているシンボルは、bar に対応するハッシュ表に登録されるのです。そして、使用するハッシュ表を決めるのが、カレントパッケージなのです。
</p>

<h4>●import と export</h4>
<p> ところで、異なるパッケージの変数や関数を使うときに、いちいちパッケージ修飾子をつけるのは面倒ですね。このため Common Lisp には、ほかのパッケージで定義された名前を取り込む機能<b>インポート (import)</b> が用意されています。ただし、このためにはパッケージ側でも名前を外へ出すための準備が必要です。これを <b>エキスポート (export)</b> といいます。エキスポートされたシンボルを<b>外部シンボル (external symbol)</b> といい、そうでないシンボルを<b>内部シンボル (internal symbol)</b> といいます。パッケージには、この 2 種類のシンボルがあるのです。
</p>
<p> シンボルをエキスポートするには関数 export を使います。
</p>
<pre class="item">
export symbols &amp;optional package
</pre>
<p> 引数 symbols はシンボルのリストか、ただひとつのシンボルでなければいけません。これらのシンボルは、パッケージ package の外部シンボルとしてアクセスすることができます。package が省略されると、カレントパッケージが対象となります。簡単な例を示しましょう。
</p>
<pre class="list">
; ファイル bar.l

(defpackage "bar")
(in-package "bar")
(export '(aaa bbb test))

(defvar aaa 10)
(defvar bbb 20)
(defun test () (print "package bar"))
</pre>
<p> これで、シンボル aaa, bbb, test がエキスポートされます。
</p>
<p> シンボルをインポートするには関数 import を使います。
</p>
<pre class="item">
import symbols &amp;optional package
</pre>
<p> 引数 symbols は export と同じです。これらのシンボルは package 内でパッケージ修飾子なしでアクセスできるようになります。これらのシンボルが、すでに package 内に存在する場合はエラーとなります。パッケージ bar のシンボル aaa, test をインポートするには、次のように指定します。
</p>
<pre class="list">
(import '(bar:aaa bar:test))
</pre>
<p> エキスポートされているシンボルのパッケージ修飾子は<b>パッケージ名:名前</b>となります。これで、aaa と test をパッケージ修飾子なしで利用することができます。エキスポートされているシンボルをすべてインポートしたい場合は、関数 use-package を使うと便利です。
</p>
<pre class="item">
use-package packages-to-use &amp;optional package
</pre>
<p> 引数 packages-to-use はパッケージかパッケージの名前のリストです。ひとつしかない場合は、それをそのまま与えてもかまいません。パッケージ bar の外部シンボルをすべてインポートするには、次のように指定します。
</p>
<pre class="list">
(use-package "bar")
</pre>
<p> これで、エキスポートされている aaa, bbb, test を利用することができます。
</p>
<p> ところ、export や use-package は defpackage でも行うことができます。Common Lisp の場合、パッケージの定義する関数 make-package がありますが、マクロ defpackage を使った方が簡単です。
</p>
<pre class="item">
defpackage package-name &amp;rest options
</pre>
<p> package-name には、パッケージ名を表す文字列かシンボルを与えます。よく使われる options を次に示します。
</p>
<ul>
  <li>(:use package-name ...)<br>
      使用するパッケージを指定します。これは関数 use-package と同じ働きをします。
  <li>(:export symbol-name ...)<br>
      エキスポートするシンボルを指定します。これは関数 export と同じ働きをします。
  <li>(:import-from package-name symbol-name ...)<br>
      パッケージ package-name で定義されているシンボルをインポートします。
      これは関数 import と同じ働きをします。
</ul>
<p> xyzzy Lisp 0.2.1.160 の場合、:export と :import-from は動作しないようです。その場合は、export と import を使ってください。
</p>

<h4>●provide と require</h4>
<p> パッケージのロードは、プログラムファイルのロードと同じです。load や load-library を使うことができますが、このほかに、モジュールをロードする require という関数が用意されています。
</p>
<p> <b>モジュール (modules)</b> を簡単に説明すると、ある機能を実現するためのプログラムの集まりや構造のことです。たとえば二分探索木の場合、データ構造の定義と基本的な操作関数が複数ありますが、それらをひとつにまとめてモジュールとして考えることができます。プログラムの構造を表す名前はいろいろあって、プログラミング言語によって呼び方はまちまちです。オブジェクト指向であれば<b>クラス</b>と呼ばれるでしょう。
</p>
<pre class="item">
provide  modules-name
require  modules-name &amp;optional path-name
</pre>
<p> provide はモジュール名を定義する関数です。modules-name は、モジュール名を表す文字列かシンボルです。provide はファイルの先頭に書いておきます。require はモジュールをロードする関数です。モジュール名とファイル名は同じにしておくのが一般的です。
</p>
<p> ロードされたモジュールはグローバル変数 *modules* に登録されます。require でモジュールをロードするときに *modules* をチェックして、モジュールがロード済みであればロードしません。あとは load-library と同じです。
</p>

<h4>●簡単な例題</h4>
<p> それでは、前に作成した二分探索木をパッケージにしてみましょう。ファイルの先頭に次のプログラムを追加します。
</p>

<pre class="list">
List 10 : パッケージの定義

(provide "tree")
(defpackage "tree")
(in-package "tree")
(export '(search-tree insert-tree print-tree make-tree))
</pre>
<p> make-tree は二分木のルートを作成する関数です。構造体の定義はパッケージ tree で行われるので、生成されるマクロは tree 内でのみ使用することができます。まあ、make-Tree をエキスポートすることもできますが、関数を定義したほうがわかりやすいでしょう。
</p>

<pre class="list">
List 11 : ルートの設定

(defun make-tree (func) (make-Tree :compare func))
</pre>
<p> とても簡単ですね。比較関数 func を受け取り、マクロ make-Tree を使えばＯＫです。また、スロット :compare が make-tree に隠されるので、データ抽象の点でも良いですね。
</p>
<p> パッケージ tree は、次のように利用することができます。
</p>
<pre class="list">
(require "tree")
(use-package "tree")
</pre>
<p> これで tree.l をバイトコンパイルして site-lisp に置いておけば、二分探索木を簡単に利用することができます。
</p>

<h4>●マクロをパッケージにまとめる場合</h4>
<p> 自分で作ったマクロも、パッケージにまとめておくと簡単に再利用することができます。この場合、バイトコンパイルするときに注意が必要です。簡単な例題として、prog3 というマクロを作りましょう。
</p>
<p> prog1 が最初に評価した S 式の値、prog2 が 2 番目に評価した S 式の値を返すように、prog3 は 3 番目に評価した S 式の値を返します。このマクロをパッケージ mymacro に格納することにします。パッケージの定義は次のようになります。
</p>

<pre class="list">
List 12 : パッケージ mymacro

(defpackage "mymacro")
(in-package "mymacro")
(export '(prog3))

; マクロの定義
(defmacro prog3 (first second third &amp;rest body)
  `(progn
     ,first
     ,second
     (prog1
         ,third
       ,@body)))
</pre>

<p> prog3 は xyzzy Lisp の prog2 (evalmacs.l) を改造しただけです。パッケージ mymacro をインタプリタで使う場合は、(require "mymacro") でマクロをロードすればいいのですね。たとえば、test_macro.l で mymacro を使うには、次のようにします。
</p>
<pre class="list">
(require "mymacro")
(use-package "mymacro")

(defun foo (a b)
  (prog3 (+ a b) (- a b) (* a b) (/ a b)))
</pre>
<p> これでマクロ prog3 を使うことができます。ところが、test_macro.l をバイトコンパイルする場合、これでは動作しないのです。もちろん、バイトコンパイルは正常に終了しますが、test_macro.lc をロードして foo を実行すると、「関数 foo が定義されていない」というエラーが発生します。
</p>
<p> マクロはバイトコンパイルするときにマクロ展開されます。(require "mymacro") とありますが、mymacro をロードするコードにコンパイルされるだけで、実際にロードされるわけではありません。つまり、コンパイラは prog3 がマクロであることを認識していないのです。このため、コンパイラは関数呼び出しのコードを出力するのですが、prog3 という関数は存在しないため、foo を実行するとエラーになるのです。
</p>
<p> したがって、コンパイルするときにも mymacro を実際にロードしなければいけません。このために用意されている関数（特殊形式）が eval-when です。
</p>
<pre class="item">
eval-when ({situation}*) Ｓ式
</pre>
<p> eval-when は<b>situation (状況)</b> で指定した状況においてのみ、本体の S 式を評価します。situation には次の 3 種類があります。
</p>
<ul>
  <li>:execute<br>
      インタプリタにロードするときに評価する
  <li>:compile-toplevel<br>
      バイトコンパイルするときに評価する
  <li>:load-toplevel<br>
      バイトコンパイル済みのファイルをロードするときに評価する
</ul>
<p> eval-when の使い方はけっこう難しいです。xyzzy のリファレンスには、次のように書いてありました。
</p>
<blockquote>
<cite>
よくわからなかったら、3 つ全部つけておけば大丈夫という説もある^^;
</cite>
</blockquote>
<p> この教えに従うと、test_macro.l は次のようになります。
</p>
<pre class="list">
(eval-when (:compile-toplevel :load-toplevel :execute)
  (require "mymacro")
  (use-package "mymacro"))

(defun foo (a b)
  (prog3 (+ a b) (- a b) (* a b) (/ a b)))
</pre>
<p> これで prog3 をマクロとしてバイトコンパイルできます。そして、test_macro.lc をロードすれば、関数 foo を実行することができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abclisp16.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp18.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>