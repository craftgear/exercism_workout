<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>xyzzy Lisp Progoramming</title>
  <meta name="description" content="xyzzy,xyzzy Lisp,Common Lisp,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881767</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>xyzzy Lisp Programming</h1>
<div class="small">
[ <a href="xyzzy02.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | NextPage ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap14">プロセス(1)</h3>
<p> Windows や UNIX 系の OS は、複数のプログラムを同時に実行することができます。プログラムの実行は OS によって管理されます。この処理単位を<b>プロセス (process)</b> といいます。通常、ひとつのプログラムがひとつのプロセスに対応します。
</p>
<p> そして、あるプロセスから別のプログラムを起動して、新しいプロセスを作ることができます。新しいプロセスを<b>チャイルドプロセス (child process)</b> とか<b>子プロセス</b>と呼び、元のプロセスを<b>親プロセス (parent process)</b> と呼んで区別する場合があります。もちろん、xyzzy Lisp からもプログラムを起動することができます。
</p>

<h4>●プログラムの起動</h4>
<p> xyzzy には、プログラムを起動する基本的な関数に call-process があります。
</p>
<pre class="item">
call-process command-line
</pre>
<p> 引数 command-line には、実行するプログラム名とその引数を文字列で与えます。このほかに、次に示すようなキーワードを指定することができます。
</p>
<table border=1>
<caption>表 1 : call-process の主なキーワード</caption>
<thead>
  <tr><th>キーワード</th><th>機能</th></tr>
</thead>
</tbody>
  <tr><td>:input</td><td>入力ファイル名を指定</td></tr>
  <tr><td>:output</td><td>出力ファイル名を指定</td></tr>
  <tr><td>:directory</td><td>プログラム実行時のカレントディレクトリを指定</td></tr>
  <tr><td>:show</td><td>:minimize 最小化, :no-active アクティブにしない</td></tr>
  <tr><td>:wait</td><td>t : 外部プログラムが終了するまで待つ </td></tr>
</tbody>
</table>
<p> たとえば、*scratch* で次のプログラムを実行すると、Windows のアプリケーション「メモ帳 (notepad) 」が起動されます。
</p>
<pre class="item">
(call-process "notepad")
(call-process "notepad" :show :minimize)
</pre>
<p> :show に :minimize を指定すると、notepad は起動されますがウィンドウは最小化の状態になります。また、:wait に t を指定すると、起動したプログラムが終了するまで待ちます。このとき call-process の返り値は、実行したプログラムが返す<b>終了コード</b>となります。次の例を見てください。
</p>
<pre>
(call-process "perl -e exit(0);" :show :minimize :wait t)
0
(call-process "perl -e exit(10);" :show :minimize :wait t)
10
</pre>
<p> Perl の場合、関数 exit で終了コードを指定することができます。最初の例では、exit(0) が実行され Perl の終了コードは 0 となり、call-process の返り値が 0 になります。次の例では、Perl の終了コードが 10 となり、call-process の返り値は 10 になります。
</p>
<p> プログラムの標準出力を受け取りたい場合は、キーワード :output に出力先のファイル名を指定します。
</p>
<pre>
(call-process "perl -v" :output "test.tmp" :show :minimize :wait t)
</pre>
<p> perl -v の標準出力は、ファイル test.tmp へ出力されます。同じように、:input にファイル名を指定すると、実行するプログラムの標準入力は、指定されたファイルになります。
</p>

<h4>●標準出力をバッファへ</h4>
<p> プログラムの標準出力をバッファへ表示させたい場合は、関数 execute-shell-command を使うと簡単です。
</p>
<pre class="item">
execute-shell-command command-line &amp;optional infile output environ directory
</pre>
<p> 引数 infile, directory は call-process と同じです。environ ですが、たぶん環境変数だとは思うのですが、詳しい使い方はわかりません。output には、出力先のバッファかバッファ名を指定します。指定した名前のバッファが存在しない場合は、新しいバッファが作成されます。プログラムはシェルを経由して起動されるので、シェルの内部コマンドでも実行できます。たとえば、*scratch* 上で次のプログラムを実行します。
</p>
<pre>
(execute-shell-command "dir" t (selected-buffer))
</pre>
<p> dir の結果は *scratch* へ出力されます。このとき、バッファの内容はクリアされることに注意してください。
</p>
<p> execute-shell-command の返り値は、起動したシェルが返す終了コードとなります。実行したプログラムの終了コードではありません。ご注意くださいませ。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap15">プロセス(2)</h3>
<p> プロセスの例題として、Z-MUSIC のコンパイルを取り上げます。Z-MUSIC は X68000 で開発された音源ドライバで、MML (Music Macro Language) で MUSIC データを記述することが特徴です。Ｃ/Ｃ++ と同じように、エディタでソースファイル(ZMS ファイル）を記述してコンパイルします。コンパイルしたファイルを ZMD ファイルといい、これを音源ドライバに渡すことで音楽が演奏されます。
</p>
<p> Windows の場合、Z-MUSIC 互換のコンパイラ ZMC3.EXE と、ZMD ファイルをスタンダード MIDI ファイルへ変換するコンバータ Z2M3.EXE が、やぎ。氏によって開発されています。これらのアプリケーションを使えば、Windows でも Z-MUSIC 互換 MML を使って MIDI データを作成することができます。
</p>
<p> 今回は、ZMS ファイルのコンパイルと MIDI データへの変換を xyzzy で行うプログラムを作ります。本来ならば Zmusic モードに組み込むコマンドですが、まずはお勉強ということで単独のコマンドとして実装してみましょう。
</p>

<h4>●コマンドの概要</h4>
<p> コマンドを実行して結果をバッファに表示するのであれば、関数 execute-shell-command を使うと簡単です。ところが、今回のように複数のコマンドを実行する場合、最初のコマンドでエラーが発生した場合は、そこで作業を中断してエラーメッセージを表示するべきでしょう。ふつう、コマンドがエラー終了した場合、0 以外の終了コードを返します。execute-shell-command はシェルの終了コードを返すため、返り値でコマンドのエラーを検出することはできません。
</p>
<p> そこで、コマンドの実行は call-process を使い、バッファへの表示処理を自前で作ることにします。まあ、execute-shell-command を参考にできるので、それほど難しいプログラムではありません。
</p>

<h4>●テンポラリファイル</h4>
<p> コマンドの標準出力を受け取るファイルは、自分で名前を考えるよりも関数 make-temp-file-name を使って、重複しないファイル名を作成した方が簡単です。
</p>
<pre class="item">
make-temp-file-name &amp;optional prefix suffix directory directory-p
</pre>
<p> この関数はテンポラリファイルを作成し、ファイル名をフルパスで返します。prifix に文字列を指定すると、ファイル名の先頭に指定した文字列が使われます。また、suffix に文字列を指定すると、今度はファイル名の最後尾に指定した文字列が使われます。簡単な実行例を示します。
</p>
<pre>
(make-temp-file-name)
"C:/TEMP/~xyzlkje.tmp"

(make-temp-file-name "_hiro")
"C:/TEMP/_hirolkjd.tmp"

(make-temp-file-name nil "oop")
"C:/TEMP/~xyzlkjf.oop"
</pre>
<p> make-temp-file-name を実行するとファイル名を返すだけではなく、実際にファイルが作成されることに注意してください。
</p>

<h4>●ファイル名の操作</h4>
<p> ZMC3.EXE と Z2M3.EXE を実行するときは、ZMS ファイルがあるディレクトリをカレントディレクトリとした方がいいでしょう。編集中の ZMS ファイルは関数 get-buffer-file-name で求めることができます。このとき、ファイル名をフルパスで返すので、ZMS ファイルがあるディレクトリを求めることができます。xyzzy Lisp には、ファイル名を操作する関数が用意されています。
</p>
<table border=1>
<caption>表 2 : ファイル名を操作する主な関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>directory-namestring pathname</td><td>pathname のディレクトリ部分を返す</td></tr>
  <tr><td>file-namestring pathname</td><td>pathname のファイル名部分を返す</td></tr>
  <tr><td>merge-pathnames pathname &amp;optional defaults</td><td>パスとファイル名を連結する</td><tr>
  <tr><td>pathname-host pathname</td><td>ホスト名を返す</td></tr>
  <tr><td>pathname-device pathname</td><td>デバイス名を返す</td></tr>
  <tr><td>pathname-directory pathname</td><td>ディレクトリをリストに格納して返す</td></tr>
  <tr><td>pathname-name pathname</td><td>ファイルの名前を返す</td></tr>
  <tr><td>pathname-type pathname</td><td>ファイルの拡張子を返す</td></tr>
</tbody>
</table>

<p> 簡単な実行例を示しましょう。
</p>
<pre>
(setq *test* "c:/usr/work/test.txt")
=&gt; "c:/usr/work/test.txt"
(directory-namestring *test*)
=&gt; "c:/usr/work/"
(file-namestring *test*)
=&gt; "test.txt"
(pathname-device *test*)
=&gt; "c"
(pathname-directory *test*)
=&gt; ("usr" "work")
(pathname-name *test*)
=&gt; "test"
(pathname-type *test*)
=&gt; "txt"
</pre>

<h4>●プログラムの作成</h4>
<p> まずはコマンド本体から作りましょう。プログラムは次のようになります。
</p>

<pre class="list">
List 1 : コンパイル

(defun zmc ()
  (interactive)
  (let* ((zms-file (get-buffer-file-name))
         (zmd-file (substitute-string zms-file ".ZMS" ".ZMD" :case-fold t))
         (dir      (directory-namestring zms-file))
         (tmp-file (make-temp-file-name))
         (output   (find-buffer *zmusic-buffer-name*))
         result)
    (setq result (exec-zmusic-command "ZMC3" zms-file dir tmp-file))
    (when (= 0 result)
      ; 正常終了
      (setq result (exec-zmusic-command "Z2M3" zmd-file dir tmp-file)))
    (unless output
      (setq output (make-zmusic-buffer)))     ; バッファを作る
    (file-to-buffer tmp-file output)          ; 表示する
    (delete-file tmp-file)))
</pre>

<p> 最初に、get-buffer-file-name で ZMS ファイルを求めます。次に、関数 substitute-string で .ZMS を .ZMD に書き換えて、コンパイル後に生成される ZMD ファイル名を作ります。キーワード :case-fold に t が指定されると、英大文字小文字を区別せずに置換します。
</p>
<p> ディレクトリ部分は、directory-namestring で取り出して dir にセットし、出力先のファイルは make-temp-file-name で作成します。バッファはグローバル変数 *zmusic-buffer-name* に格納されている名前で作成しますが、その前に関数 find-buffer で以前に作成したバッファを探します。見つからない場合は nil を返すので、そのときは新しくバッファを作成します。
</p>
<p> プログラムは exec-zmusic-command で実行します。この関数は、コマンドラインを生成して call-process を呼び出すだけです。ZMC3.EXE の終了コードが 0 であれば、コンパイルは正常に終了しました。次に、Z2M3.EXE を呼び出します。エラーがあれば 0 以外の終了コードを返すので、ファイル output の内容をバッファへ転送します。output が nil の場合は、make-zmusic-buffer で新しくバッファを作成します。
</p>
<p> このプログラムでは、Z2M3.EXE の出力結果を無条件にバッファへ転送していますが、正常に終了した場合はバッファを表示しない、ということもできます。最後に delete-file でテンポラリファイル tmp-file を削除します。
</p>
<p> 次はプログラムを実行する exec-zmusic-command です。
</p>

<pre class="list">
List 2 : コマンドの実行

(defun exec-zmusic-command (command file dir tmp-file)
  (call-process (concat command " " file)
                :output tmp-file
                :exec-directory dir
                :show :minimize
                :wait t))
</pre>
<p> 実行する command と引数 file を関数 concat で連結します。この関数は文字列専用です。Common Lisp には、1 次元配列、文字列、リストを<b>列 (sequence)</b> として操作できる<b>列関数</b>が用意されています。列を連結する関数 concatenate を使うと、次のようになります。
</p>
<pre class="list">
(concatenate 'string command " " file)
</pre>
<p> このほかにも、Common Lisp には便利な列関数が用意されています。詳細は Common Lisp 入門 <a href="abclisp06.html">列関数</a> をお読みください。
</p>
<p> 次はバッファを作成する make-zmusic-buffer を作ります。
</p>

<pre class="list">
List 3 : バッファの作成

(defun make-zmusic-buffer ()
  (let ((output (create-new-buffer *zmusic-buffer-name*)))
    (save-excursion
      (set-buffer output)
      (setq need-not-save t))   ; バッファローカルな変数をセット
    output))
</pre>

<p> バッファは create-new-buffer で作成します。このバッファはセーブする必要が無いので、バッファローカルな変数 need-not-save に t をセットします。ですが、このままでは ZMS ファイルを格納しているバッファのローカル変数を書き換えてしまいます。そこで、save-ecursion を使って現在の状態を保存し、set-buffer でカレントバッファを output に切り替えます。それから、need-not-save に t をセットしてください。
</p>
<p> 最後にファイルをバッファへ転送する file-to-buffer を作ります。
</p>

<pre class="list">
List 4 : ファイルをバッファへ

(defun file-to-buffer (file buffer)
  (erase-buffer buffer)
  (pop-to-buffer buffer t)
  (insert-file-contents file)
  (set-buffer-modified-p nil))
</pre>

<p> まずバッファの内容を erase-buffer で消去します。次に pop-to-buffer で画面を分割して buffer を表示します。このとき、カレントバッファは buffer に切り替わります。ファイルからバッファへの転送は関数 insert-file-contents を使うと簡単です。この関数は指定されたファイルの内容を、カレントバッファのポイントの後ろに挿入します。最後に set-buffer-modified-p でバッファを未変更の状態に設定します。
</p>

<h4>●とりあえず完成です</h4>
<p> これでプログラムは一応完成しました。きちんと動作することは確認しましたが、実際に Zmusic モードに組み込むときには、ユーザーの使い勝手を考慮する必要があります。まず、実行するプログラムを固定していますが、ユーザーが設定できるようにするべきです。このとき、オプションも設定できるようにするといいでしょう。プログラム名やオプションのデフォルト値はグローバル変数に格納しておいて、ユーザーが設定する場合は .xyzzy で書き換えてもらう、という方法が簡単でよいかもしれません。また、MIDI ファイルを演奏するコマンドも作った方がいいですね。
</p>
<p> このほかにも、いろいろな問題点があるでしょう。お気づきの点があればご指摘ください。
</p>
<h4>●追記(2000/10/04)</h4>
<p> Zmusic モードに同等のコマンドを組み込みました。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap16">しりとりゲーム</h3>
<p> 今回はハッシュ表を使って<b>しりとりゲーム</b>を作ってみましょう。プログラムを簡単にするため、入力する単語は「ひらがな」のみとします。たとえば、
</p>
<pre class="item">
りんご  ごりら  らじお  ・・・・
</pre>
<p> というように、ひらがなで単語を入力します。長音記号「ー」も使用不可としますので、たとえばルビーは「るびぃ」と入力してください。今回は *scratch* 上で実行するプログラムを作ります。
</p>
<h4>●単語の管理</h4>
<p> まず最初に、ゲームで使用する単語の管理から考えましょう。コンピュータが単語を考えるのは難しいので、使用する単語はあらかじめファイル word.dat に格納しておきます。ゲームを始めるときに、このファイルから単語を読み込み、ハッシュ表 *shiri-word* にセットすることにします。ハッシュ表の使い方は Common Lisp 入門 <a href="abclisp16.html">ハッシュ表</a> をお読みください。
</p>
<p> しりとりゲームは同じ単語を二度使うことができないので、未使用の単語はハッシュ表の値を t とし、使用済みの単語はハッシュ表の値にシンボル used をセットすることにしましょう。
</p>
<p> コンピュータが単語を返すときは、私達が入力した単語の最後の文字を取り出し、その文字で始まる単語を *shiri-word* の中から探します。この処理はハッシュ表に登録されているキーを調べなければいけません。ハッシュ表のキーを毎回調べるのは大変なので、先頭文字ごとに単語を区分けしておくことにしましょう。この処理にハッシュ表 *first-code* を使います。
</p>
<p> ハッシュ表 *first-code* は文字をキーとして使います。たとえば、「あ」で始まる単語が、あさがお、あじさい、あり、だとしましょう。すると、*first-code* の #\あ の値は、これらの単語を格納したリストがセットされます。
</p>
<pre>
(gethash #\あ *first-code*)
=&gt; ("あさがお" "あじさい" "あり")
</pre>
<p> *first-code* で単語見つからなければ、コンピュータの<b>負け</b>となります。
</p>
<p> それでは、ファイルからデータを読み込むプログラムを作ります。
</p>

<pre class="list">
List 5 : データファイルリード

(defun read-word-data ()
  ; ハッシュ表セット
  (setq *shiri-word* (make-hash-table :test #'equal)
        *first-code* (make-hash-table))
  ; ファイルリード
  (with-open-file (in "./site-lisp/word.dat" :direction :input)
    (let (word)
      (while (setq word (read-line in nil))
        (unless (check-word-p word)
          (setf (gethash word *shiri-word*) t))))))
</pre>

<p> ハッシュ表を格納する変数 *shiri-word* と *first-code* はスペシャル変数として定義します。ハッシュ表 *first-code* のキーは文字なので、:test はデフォルトの eql のままでかまいません。
</p>
<p> ファイルの読み込みですが、プログラムとデータファイル word.dat はディレクトリ site-lisp に格納しておきます。あとは read-line で 1 行ずつ読み込み、check-word-p で単語が「ひらがな」であることを確認してからハッシュ表にセットします。check-word-p は string-match を使えば簡単です。
</p>

<pre class="list">
List 6 : 単語のチェック

(defun check-word-p (word)
  (string-match "[^ぁ-ん]" word))
</pre>
<p> 文字コードは shift-jis を前提としています。ほかの文字コードでは動作しないかもしれません。M.Hiroi はほかのコードでの動作確認はしていないので、ご注意くださいませ。
</p>
<p> *first-code* は単語を検索するときにデータをセットします。単語の検索は次のようになります。
</p>

<pre class="list">
List 7 : 単語の検索

(defun search-word (word)
  (let* ((code (get-last-code word))
         (word-list (gethash code *first-code* t)) word)
    (if (eq word-list t)
      (setq word-list (get-word-data code)))
    (while word-list
      (setq word (pop word-list))
      (unless (eq (gethash word *shiri-word*) 'used)
        (return word)))))
</pre>
<p> get-last-code は最後尾の文字を取り出す関数です。これはあとで説明します。そして、*first-code* から code で始まる単語を取り出します。まだデータがセットされていなければ t を返すこととし、その場合は get-word-data で *shiri-word* から code で始まる単語をすべて求めます。あとは、リストの中から未使用の単語を探します。このとき、使用済みの単語はリストから削除します。
</p>
<p> *shiri-word* から単語を取得する処理は maphash を使えば簡単です。
</p>

<pre class="list">
List 8 : 先頭文字 code で始まる単語を取得

(defun get-word-data (code)
  (let (word-list)
    (maphash #'(lambda (key value)
                 (if (char= code (elt key 0))
                     (push key word-list)))
             *shiri-word*)
    word-list))
</pre>
<p> 列関数 elt で先頭文字を取り出し、code と等しければ word-list にセットします。文字の比較関数には char=, char/=, char&lt;, char&gt;, char&lt;=, char&gt;= があります。xyzzy Lisp は日本語も 1 文字として扱えるので、とても便利です。ラムダ式で word-list にデータをセットできるのは、クロージャが働いているからです。ご注意ください。
</p>

<h4>●単語の入力</h4>
<p> 次は、私たちが単語を入力する処理を考えましょう。単語の入力にはミニバッファを使います。あとは、入力された単語が「しりとり」の規則に違反していないかチェックします。単語の入力は関数 input-word で行います。
</p>

<pre class="list">
List 9 : 単語の入力

(defun input-word ()
  (loop
    (let ((word (read-string "単語を入力してね &gt; ")))
      (if (check-word-p word)
          (princ "単語は「ひらがな」でお願いね！\n")
          (return word)))))
</pre>

<p> これは簡単ですね。check-word-p で入力されたデータをチェックをするだけです。次に、規則のチェックを行う関数 rule-check を作ります。
</p>

<pre class="list">
List 10 : 規則のチェック

(defun rule-check (my-word your-word)
  (cond ((char= #\ん (get-last-code your-word))
         (princ "「ん」で終わったのであなたの負けよ！"))
        ((and (stringp my-word)
              (char/= (get-last-code my-word)
                      (elt your-word 0)))
         (princ "最初の文字が違うのであなたの負けよ！"))
        ((eq (gethash your-word *shiri-word*) 'used)
         (princ "その単語は前に使ったのであなたの負けよ！"))
        (t nil)))
</pre>

<p> 引数 my-word がコンピュータ側の単語で、your-word が私たちが入力した単語です。最後の文字が「ん」で終わるチェックは簡単ですね。次に、入力した単語がきちんと「しりとり」になっているかチェックします。このゲームでは、私たちから単語を入力するので、最初は my-word に単語がセットされていません。その場合、my-word に nil が渡されるので、型述語 stringp で文字列がセットされていることを確認します。最後に、使用済みの単語であるかチェックします。これはハッシュ表 *shiri-word* を調べるだけです。
</p>
<p> では、単語の最後の文字を取り出す処理を作りましょう。
</p>
<pre class="list">
List 11 : 最後の文字を取り出す

(defun get-last-code (word)
  (change-code (elt word (1- (length word)))))
</pre>

<p> 最後の文字を取り出すことは簡単です。しかし、単語が「ぁぃぅぇぉっゃゅょゎ」などで終わっているときが問題です。これらの文字から始まる単語はないので、この場合は「あいうえおつやゆよわ」に変換することにします。この処理を関数 change-code で行います。
</p>

<pre class="list">
List 12 : 連想リストを使って文字を変換

(defun change-code (code)
  (let ((a-list '((#\ぁ . #\あ) (#\ぃ . #\い) (#\ぅ . #\う)
                  (#\ぇ . #\え) (#\ぉ . #\お) (#\っ . #\つ)
                  (#\ゃ . #\や) (#\ゅ . #\ゆ) (#\ょ . #\よ)
                  (#\ゎ . #\わ)))
         data)
    (if (setq data (assoc code a-list))
        (cdr data)
        code)))
</pre>

<p> いろいろな方法が考えられますが、Lisp らしく「連想リスト (association list) 」を使ってみました。連想リストの説明は Common Lisp 入門 <a href="abclisp08.html">リストの操作（その２）</a> をお読みください。
</p>
<h4>●ゲーム本体の作成</h4>
<p> では、最後にゲーム本体を作りましょう。
</p>

<pre class="list">
List 13 : しりとりゲーム本体

(defun exec-shiri ()
  (let (your-word my-word)
    (loop
      (setq your-word (input-word))
      (princ your-word)
      (terpri)
      (if (rule-check my-word your-word)
        (return))
      (update-word your-word)
      (princ "うみゅみゅ・・・")
      (unless (setq my-word (search-word your-word))
        (princ "私の負けです")
        (return))
      (format t "「~A」！~%" my-word)
      (goto-char (point-max))
      (update-word my-word))))
</pre>

<p> 私たちが入力した単語は、ファイル word.dat に登録されていない単語もあるでしょう。関数 update-word で単語を使用済みにするとき、それらの単語はハッシュ表 *shiri-word* に登録されます。ゲームが終了したら、ハッシュ表に登録された単語を word.dat に出力することで、私たちが入力した単語を覚えることがでます。つまり、だんだんと強くなるわけですね。むちゃくちゃな単語でも入力することはできますが、次のゲームではその単語を逆に使われることになります。ご自重くださいませ。
</p>
<p> update-word はとても簡単です。
</p>

<pre class="list">
List 14 : 単語を使用済みとする

(defun update-word (word)
  (setf (gethash word *shiri-word*) 'used))
</pre>
<p> シンボル used をセットするだけです。これで新しい単語も登録されます。exec-shiri を呼び出すメインルーチンは、次のようになります。
</p>

<pre class="list">
List 15 : メインルーチン

(defun shiri ()
  (if *shiri-word*
    (change-word-data)
    (read-word-data))
  (exec-shiri)
  (save-word-data))
</pre>

<p> グローバル変数 *shiri-word* が nil でなければ二回目以降のゲームと判断し、change-word-data を呼び出して使用済みの単語を未使用に戻します。そうでなければ、read-word-data を呼び出してハッシュ表のセットとデータの読み込みを行います。change-word-data は次のようになります。
</p>

<pre class="list">
List 16 : 使用済みの単語を未使用に戻す

(defun change-word-data ()
  (clrhash *first-code*)
  (maphash #'(lambda (key value)
               (if (eq value 'used)
                   (setf (gethash key *shiri-word*) t)))
           *shiri-word*))
</pre>

<p> まず、ハッシュ表 *first-code* をクリアします。次に、maphash を使って *shiri-word* に登録されているキーで、値が used のものを t に変更します。データのセーブも簡単です。
</p>

<pre class="list">
List 17 : データのセーブ

(defun save-word-data ()
  (with-open-file (out "./site-lisp/word.dat" :direction :output)
    (maphash #'(lambda (key value) (format out "~A~%" key))
             *shiri-word*)))
</pre>
<p> これも maphash を使って、キーをファイル word.dat に書き込むだけです。これでプログラムは完成です。
</p>

<h4>●ダウンロード</h4>
<p> まあ、とりえのない「しりとりゲーム」ですが、適当な単語を入れた word.dat を用意したので、暇つぶしに遊んでみたり、改造したりしてみてください。圧縮ファイル内の shiri.l と word.dat を site-lisp に展開してください。あとは M-x load-file shiri.l でファイルをロードし、*scratch* で (shiri) を実行するとゲームが始まります。word.dat の単語は少ないので、最初は簡単に勝てるでしょう。
</p>
<dl>
  <dt>ファイル名
  <dd>shiri.l : プログラムファイル
  <dd>word.dat : 単語ファイル
</dl>
<a href="shiri.lzh"><b>ダウンロード</b></a>(1,988 byte)

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="xyzzy02.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | NextPage ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>