<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門</title>
  <meta name="description" content="xyzzy,xyzzy Lisp,Common Lisp,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881765</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>xyzzy Lisp Programming</h1>
<h2>Common Lisp 入門</h2>
<div class="small">
[ <a href="abclisp01.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap02">リストの操作</h3>
<h4>●リストの分解</h4>
<p> 最初はリストの分解から始めましょう。関数 <b>car</b> はリストの第 1 要素を取り出し、関数 <b>cdr</b> はリストの第 1 要素を取り除いたリストを返します。なお Common Lisp の場合、car と cdr ではなく <b>first</b> と <b>rest</b> を使うことが推奨されています。ですが、M.Hiroi は古い人間のため car と cdr を好んで使っています。皆さんは first と rest を使ってくださいね。
</p>

<pre class="fig">
   ┌─────→ car は先頭のセルの CAR 部を返す
   │
   │  ┌───→ cdr は先頭のセルの CDR 部を返す
   │  │
 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→│・│／│ 
 └┼┴─┘    └┼┴─┘    └┼┴─┘    └┼┴─┘
   ↓            ↓            ↓            ↓
   ａ            ｂ            ｃ            ｄ

        (car '(a b c d)) =&gt; a
        (cdr '(a b c d)) =&gt; (b c d)

                図 1 : car と cdr の操作
</pre>

<p> car と cdr は関数ですので、リストには引用符を付けることを忘れないでください。また、リスト以外のデータを与えるとエラーとなります。
</p>
<p> car と cdr はリストを分解します。上図に示すように、car は先頭のセルの CAR 部に格納されたデータを返します。cdr は CDR 部に格納されたデータ (後ろに接続されているセル) を返します。つまり、先頭要素を除いたリストを返すことになります。
</p>
<p> 要素が 1 つしかないリストに cdr を適用すれば、空リスト nil を返します。また、car も cdr も引数に nil が与えられると nil を返します。
</p>
<pre>
(cdr '(a)) =&gt; nil
(car nil)  =&gt; nil
(cdr nil)  =&gt; nil
</pre>

<p> 今度は要素がリストの場合を考えてみましょう。次の例を見てください。
</p>
<pre>
(car '((a b) (c d) (e f))) =&gt; (a b)
(cdr '((a b) (c d) (e f))) =&gt; ((c d) (e f))
</pre>

<p> リストの第 1 要素は (a b) であり、a ではないことに注意してください。a を取り出したい場合は次のようになります。
</p>
<pre>
(car (car '((a b) (c d) (e f)))) =&gt; a
</pre>

<p> それでは、第 2 要素を取り出す場合はどうするのでしょう。car と cdr を組み合わせれば簡単に取り出すことができます。
</p>
<pre class="fig">
(car (cdr '(a b c d e f)))
     ~~~~~~~~~~~~~~~~~~~~ が評価されると a が取り除かれる。
   ||
(car '(b c d e f))  取り除いた後のリストの第 1 要素を取り出す。
=&gt; b
</pre>

<p> このように、car と cdr を組み合わせることで、リストのどの要素にもアクセスすることができるのです。また、car と cdr を組み合わせた関数 cxxr, cxxxr, cxxxxr も用意されています。x には a か d が入ります。次の例を見てください。
</p>
<pre class="item">
(cadr '(a b c d)) ≡ (car (cdr '(a b c d))) =&gt; b
(caddr '(a b c d)) ≡ (car (cdr (cdr '(a b c d)))) =&gt; c
(cadddr '(a b c d)) ≡ (car (cdr (cdr (cdr '(a b c d))))) =&gt; d
</pre>
<p> 昔の Lisp では、リストの第 2 要素や第 3 要素を取り出すために cadr や caddr がよく使われました。これらの関数は Common Lisp にも用意されていますが、第 2 要素は <b>second</b> で、第 3 要素は <b>third</b> で取り出した方がよいでしょう。このほかに、第 4 要素を取り出す fourth から第 10 要素を取り出す tenth まで用意されています。
</p>

<h4>●リストの合成</h4>
<p> 次は、リストの合成です。関数 <b>cons</b> はリストの先頭にデータを付け加えます。
</p>
<pre class="fig">
                           新しいセル
                           ┌─┬─┐
         cons の返り値 ←─│・│・┼─→ nil(引数)
                           └┼┴─┘
                             ↓
                             ａ(引数)

                         (cons 'a nil) =&gt; (a)

                   新しいセル  ┌─── 引数 (b c) ─────┐
                   ┌─┬─┐  │  ┌─┬─┐    ┌─┬─┐  │
 cons の返り値 ←─│・│・┼─┼→│・│・┼─→│・│／│  │ 
                   └┼┴─┘  │  └┼┴─┘    └┼┴─┘  │
                     ↓        │    ↓            ↓        │
                     ａ(引数)  │    ｂ            ｃ        │
                               └──────────────┘

                       (cons 'a '(b c)) =&gt; (a b c)

                        図 2 : cons の動作
</pre>

<p> car と cdr で分解したリストは cons で合成することができます。
</p>

<pre class="fig">
                   ┌───┐
             ┌─→│ｃａｒ│→ a  ────┐
             │    └───┘              ↓
             │                        ┌────┐
 (a b c d) ─┤                        │ｃｏｎｓ│→ (a b c d) 
             │                        └────┘
             │    ┌───┐              ↑
             └─→│ｃｄｒ│→ (b c d)  ─┘
                   └───┘

                図 3 : リストの分解と合成
</pre>

<p> この関係は、リストを操作する関数を作る場合の基本です。とても重要な関係なので、覚えておいてください。
</p>
<p> 関数 <b>list</b> は、その引数を要素とする新しいリストを返します。
</p>
<pre class="fig">
                   新しいセル    新しいセル    新しいセル
                   ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 list の返り値 ←─│・│・┼─→│・│・┼─→│・│／│
                   └┼┴─┘    └┼┴─┘    └┼┴─┘
                     ↓            ↓            ↓
                     ａ            ｂ            ｃ

                 (list 'a 'b 'c) =&gt; (a b c)

                   新しいセル    新しいセル    新しいセル
                   ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 list の返り値 ←─│・│・┼─→│・│・┼─→│・│／│
                   └┼┴─┘    └┼┴─┘    └┼┴─┘
                     ↓            ↓            ↓
                    (a b)         (c d)         (e f)

    (list '(a b) '(c d) '(e f)) =&gt; ((a b) (c d) (e f))    

                    図 4 : list の動作
</pre>

<p> 上図のように、list は引数を新しいリストの要素として格納します。引数がリストの場合は、それが要素となります。リスト同士をつなぐのではないことに注意してください。
</p>
<p> これに対し、関数 <b>append</b> はリスト同士を接続します。したがって、引数はリストでなければいけません。アトムを与えるとエラーになります。
</p>

<pre class="fig">
          引数 (a b)                    引数 (c d)
        ┌─┬─┐    ┌─┬─┐      ┌─┬─┐    ┌─┬─┐
        │・│・┼─→│・│／│  ┌→│・│・┼─→│・│／│  
        └┼┴─┘    └┼┴─┘  │  └┼┴─┘    └┼┴─┘
          ↓            ↓        │    ↓            ↓
          ａ            ｂ        │    ｃ            ｄ
          │            │        │
          ↓            ↓        │
        ┌┼┬─┐    ┌┼┬─┐  │
  ┌──│・│・┼─→│・│・┼─┘
  │    └─┴─┘    └─┴─┘
  │    新しいセル    新しいセル
  ↓
  append の返り値

                (append '(a b) '(c d)) =&gt; (a b c d)

                図 5 : append の動作
</pre>

<p> append はリストを接続する場合、新しいセルを作成して引数の要素を格納します。ただし、いちばん最後の引数は新しいセルを作成しません。要素自体には何もしないことに注意してください。
</p>
<pre>
(append '((a b) (c d)) '(e f))
=&gt; ((a b) (c d) e f)

(append '((a b) (c d)) '((e f)))
=&gt; ((a b) (c d) (e f))         ; (a b c d e f) ではないことに注意
</pre>

<p> このように、要素がリストの場合でも、そのリストの要素を取り出すことはせずに、引数の要素を並べるだけです。
</p>

<h4>●リストの操作は非破壊的</h4>
<p> 今まで紹介した関数はシンボルの値を変更しません。次の例を見てください。
</p>
<pre>
(setq var '(a b c d e))
=&gt; (a b c d e)
(cdr var)
=&gt; (b c d e)
var
=&gt; (a b c d e)
</pre>
<p> シンボル var の値は破壊されません。var の値を変更したいときは setq や setf を使います。
</p>
<pre>
(setq var (cdr var))
=&gt; (b c d e)
var
=&gt; (b c d e)
</pre>
<p> 以上のように、シンボル var の値は更新されます。
</p>

<h4>●ドットリスト</h4>
<p> ここで、もう一度 cdr に戻ります。cdr は先頭の要素を取り除いたリストを返しましたが、それはセルの CDR 部を返す働きと同じです。最初に、最終セルの CDR にはリストの終わりを示すデータが格納されることを説明しました。したがって、要素がひとつしかないリストに cdr を適用すると、リストの終端を表すデータが取り出されます。もうおわかりだと思いますが、この特別なデータが nil なのです。
</p>

<pre class="fig">
 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→ nil
 └┼┴─┘    └┼┴─┘    └┼┴─┘    リストの終端 
   ↓            ↓            ↓
   ａ            ｂ            ｃ

         リスト (a b c) の構造

        図 6 : リストの終端（その１）
</pre>

<p> 今までのリストは、すべて終端に nil がセットされています。ところが、Lisp の立場になって考えてみると、リストの終端は CDR  部に格納されるデータがセル以外であれば、そこがリストの終端であることがわかります。つまり、nil でなくてもかまわないのです。リストの終端が nil 以外のデータである場合、そのリストを次のように表します。
</p>
<pre class="fig">
 ┌─┬─┐            ┌─┬─┐
 │・│・┼─→ nil    │・│・┼─→ b
 └┼┴─┘            └┼┴─┘
   ↓                    ↓
   ａ                    ａ

 (a) ≡ (a . nil)      (a . b)

 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→nil 
 └┼┴─┘    └┼┴─┘    └┼┴─┘
   ↓            ↓            ↓
   ａ            ｂ            ｃ

     (a b c) ≡ (a . (b . (c . nil)))

    図 7 : リストの終端（その２）
</pre>

<p> 左右の括弧の中間にドット ( . ) を置き、左側に CAR 部のデータを、右側に CDR 部のデータを書きます。つまり、リスト (a) は (a . nil) と表すことができます。このようなデータを<b>ドット対 (dotted pair)</b> と呼びます。たとえば、CAR 部がシンボル a で CDR 部がシンボル b であれば (a . b) となります。普通のリストも次のようにドット対を使って表現できます。
</p>
<pre class="item">
(a)           ≡ (a . nil)
(a b c)       ≡ (a . (b . (c . nil)))
<del>((a b) (c d)) ≡ ((a . (b . nil)) . (c . (d . nil)))</del> <sup><a name="update">[訂正]</a> '02-4-15</sup>
((a b) (c d)) ≡ <del>((a . (b . nil)) (c . (d . nil)))</del> <sup><a name="update1">[訂正]</a> '02-6-27</sup>
              ≡ ((a . (b . nil)) . ((c . (d . nil)) . nil))
((a b) c d)   ≡ ((a . (b . nil)) . (c . (d . nil)))
</pre>
<div class="note">
-- [訂正] '02-4-15, '02-6-27  -----<br>
例題に誤りがありました。訂正するとともにお詫び申し上げます。<br>
<a href="../xyzzy_lisp.html#cite">参考文献 [2]</a> によると、カッコ ( ) の中間にドットを置いてリストを表すことを<b>ドット表現</b>といい、ドットを使わずにリストを表すことを<b>リスト表現</b>というそうです。そして、リスト表現とドット表現を混在させた表記法を<b>改良リスト表現</b>といい、多くの Lisp 処理系がこの表記法を用いています。((a . (b . nil)) (c . (d . nil))) は ((a b) (c d)) と同じリスト構造を表していますが、改良リスト表現になっているためドット表現 ((a . (b . nil)) . ((c . (d . nil)) . nil)) に訂正しました。
</div>

<p> それでは、リスト (a b c) の終端を d に変えてみましょう。ドット対を使った表記法では、(a . (b . (c . d))) となりますが、これは (a b c . d) と表すことができます。
</p>
<pre class="fig">
 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→d 
 └┼┴─┘    └┼┴─┘    └┼┴─┘
   ↓            ↓            ↓
   ａ            ｂ            ｃ

     (a b c . d) ≡ (a . (b . (c . d)))

    図 8 : リストの終端（その３）
</pre>

<p> このように、nil 以外のアトムで終端されたリストを<b>ドットリスト (dotted list)</b> と呼びます。
</p>
<p> ドットの後ろは cdr にセットするデータを指定するのですから、複数のデータを書いたり省略してはいけません。次の場合はエラーになります。
</p>
<pre class="item">
( . a)       ; car がない
(a . )       ; cdr がない
(a . b c)    ; cdr にデータが複数ある
(a . . b)    ; ドットが複数ある
(a . b . c )
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap03">数と算術演算</h3>
<p> Common Lisp では、いくつかの種類の数が定義されています。大きく分けると整数 (integer)、分数 (ratio)、浮動小数点数 (floating-point number)、複素数 (complex number) という 4 種類の数があります。xyzzy Lisp でもこれらの数を使うことができます。
</p>

<h4>●整数</h4>
<p> Common Lisp の場合、整数の大きさには制限がありません。これは xyzzy Lisp も同じで、5000! や 10000! でも求めることができます。ただし、処理系の内部では整数を fixnum と bignum (多倍長整数) に分けています。その処理系で効率良く整数を表せる範囲が fixnum で、それ以外の整数が bignum となります。fixnum の範囲は処理系に依存しますが、その値は変数 most-negative-fixnum と most-positive-fixnum に格納されています。
</p>
<pre>
most-negative-fixnum =&gt; -2147483648
most-positive-fixnum =&gt;  2147483647
</pre>
<p> このように、xyzzy の fixnum は 32 bit で表されています。
</p>
<p> 整数は通常 10 進表記ですが、それ以外の基数でも書くことができます。
</p>
<pre class="item">
#nn<b>r</b>ddddd または #nn<b>R</b>ddddd
</pre>
<p> nn が基数 ( 2 - 32 ) を表します。よく使われる基数には省略形が用意されています。
</p>

<ul>
  <li> 2 進表記<br>
      #b の後ろに 0 と 1 の数値を記述
  <li> 8 進表記<br>
      #o の後ろに 0 から 7 までの数値を記述
  <li>16 進表記<br>
      #x の後ろに 0 から f までの数値を記述
</ul>
<p> 簡単な例を示しましょう。
</p>
<pre>
#4r1230123 =&gt; 6939
#b10101010 =&gt; 170
#o1234567  =&gt; 342391
#o-127     =&gt; -87
#xabcdef   =&gt; 11259375
</pre>

<h4>●分数</h4>
<p> Common Lisp は分数を扱うことができます。分数は 2 つの整数を / で区切って表します。簡単な例を示します。
</p>
<pre class="item">
1/2, 2/3, 4/3, 11/13, -51/100, 30517578125/32768
</pre>
<p> また、4/6 や 3/12 のような入力もできますが、この場合は約分されることになります。とくに、4/2 のような割り切れる分数は、ただちに整数に変換されます。次の例を見てください。
</p>
<pre>
4/6  =&gt; 2/3
3/12 =&gt; 1/4
10/5 =&gt; 2    ; 整数に変換される
</pre>
<h4>●浮動小数点数</h4>
<p> Common Lisp は浮動小数点数を扱うことができます。浮動小数点数は一種類だけではなく、処理系によって複数の種類を持つことができますが、その精度と大きさは処理系に依存します。Common Lisp で推奨されている浮動小数点数の種類を表 1 に示します。
</p>
<table border=1>
<caption>表 1 : 浮動小数点数の種類</caption>
<thead>
  <tr><th>形式</th><th>最小精度</th><th>最小の指数の大きさ</th><th>指数マーカ</th></tr>
</thead>
<tbody>
  <tr><td>小精度 (short-float)</td><td>13 ビット</td><td>5 ビット</td><td>s, S</td></tr>
  <tr><td>単精度 (single-float)</td><td>24 ビット</td><td>8 ビット</td><td>f, F</td></tr>
  <tr><td>倍精度 (double-float)</td><td>50 ビット</td><td>8 ビット</td><td>d, D</td></tr>
  <tr><td>長精度 (long-float)</td><td>50 ビット</td><td>8 ビット</td><td>l, L</td></tr>
</tbody>
</table>

<p> 浮動小数点の表記法は次のようになります。
</p>
<pre class="item">
[+|-] 数字 小数点 数字 指数マーカ [+|-] 数字
例： 0.1234                   ; single-float
     0.1234d0                 ; double-float
     1.2345e10                ; single-float
     -9.876542999999999d-100  ; double-float
</pre>
<p> Common Lisp の仕様では、これら 4 つの形式をすべてサポートしなければならないわけではなく、処理系によっては 4 つより少なくてもかまいません。xyzzy Lisp には 2 つの内部形式があり、short-float と single-float が同じ形式、double-float と long-float が同じ形式になります。ようするに、Ｃ/Ｃ++ の float (単精度浮動小数点型) に相当するのが short-float, single-float で、double (倍精度浮動小数点型) に相当するのが double-float, long-float になります。
</p>
<p> なお、指数マーカには e, E を使うことができます。この場合、浮動小数点数は変数 *read-default-float-format* に格納されている形式に変換されます。また、指数マーカを省略した場合も同様です。デフォルトは single-float です。
</p>

<h4>●複素数</h4>
<p> Common Lisp は複素数を扱うことができます。複素数は #C の後ろに実部と虚部のリストを付けて表します。簡単な例を示しましょう。
</p>
<pre class="item">
#C(5 -3)
#C(1.2 2.4)
#C(1/2 2/3)
#C(0.5 2/3) =&gt; #C(0.5 0.6666667)
</pre>
<p> 実部と虚部の指定には、整数、浮動小数点数、分数を使うことができます。もし、実部と虚部が異なる種類（型）の数ならば、同じ種類の数になるよう変換されます。
</p>

<h4>●算術演算</h4>
<p> ここでは簡単な算術演算を説明します。
</p>
<p> <b>+</b> は足し算を、<b>*</b> は掛け算を、<b>-</b> は引き算を行います。これらの関数は引数をいくつでも取ることができます。数以外のデータを引数に与えるとエラーになります。引数の型が異なる場合は強制的に型変換が行われます。簡単な例を示しましょう。
</p>
<pre>
(+)           =&gt; 0
(+ 1)         =&gt; 1
(+ 1 2 3)     =&gt; 6
(+ 1 2 3 1/2) =&gt; 13/2
(+ 1 2 3 4.5) =&gt; 10.5

(*)           =&gt; 1
(* 1)         =&gt; 1
(* 1 2 3)     =&gt; 6
(* 1 2 3 1/4) =&gt; 3/2
(* 1 2 3 4.5) =&gt; 27.0

(- 1)         =&gt; -1
(- 10 5 4)    =&gt; 1
(- 10 5/2)    =&gt; 15/2
(- 10 4.5)    =&gt; 5.5
(-)           =&gt; エラー  ; 引数が足りない
</pre>

<p> <b>/</b> は割り算を行います。整数同士の割り算で割り切れない場合は分数になります。引数が 0 の場合はエラーになります。
</p>
<pre>
(/ 2)     =&gt; 1/2    ; 引数の逆数を求める
(/ 8 4 2) =&gt; 1      ; 約分されて整数になる
(/)       =&gt; エラー ; 引数が足りない
</pre>

<p> 整数や分数を浮動小数点数に変換するには関数 <b>float</b> を使います。
</p>
<pre>
(float 1/3) =&gt; 0.3333333
(float 3)   =&gt; 3.0
</pre>
<p> 逆に、分数や浮動小数点数を整数に変換するには、次に示す関数を使います。
</p>

<ul>
  <li><b>floor num1 [num2]</b><br>
i ≦ num1 ＜ i + 1 を満たす整数 i を求める。
  <li><b>ceiling num1 [num2]</b><br>
i - 1 ＜ num1 ≦ i を満たす整数 i を求める。
  <li><b>truncate num1 [num2]</b><br>
小数点以下を切り捨てる。
  <li><b>round num1 [num2]</b><br>
近い方の整数に丸める。ちょうど 0.5 の場合には偶数方向に丸める。
</ul>
<p> 引数 num2 が与えられた場合は (/ num1 num2) を評価し、その結果を整数に変換します。
</p>

<p> <b>1+</b> は引数に 1 を加え、<b>1-</b> は引数から 1 を引きます。
</p>
<pre>
(1+ 2)   =&gt; 3
(1+ 2.5) =&gt; 3.5
(1- 2)   =&gt; 1
(1- 2.5) =&gt; 1.5
</pre>
<p> <b>incf</b> と <b>decf</b> は次の S 式と同じ働きをします。
</p>
<pre class="item">
(incf a)   ≡ (setf a (1+ a))
(incf a n) ≡ (setf a (+ a n))
(decf a)   ≡ (setf a (1- a))
(decf a n) ≡ (setf a (- a n))
</pre>
<p> incf は第 2 引数が省略されると、第 1 引数のシンボルに格納されている数値に 1 を加えます。第 2 引数が与えられると、その値を加えます。incf は足し算した結果を返します。decf は incf とは逆に引き算を行います。
</p>
<p> <b>gcd</b> はすべての引数の最大公約数を返します。<b>lcm</b> はその引数の最小公倍数を返します。どちらの関数も引数は整数でなければいけません。
</p>
<pre>
(gcd 91 49)     =&gt; 7
(gcd 63 42 35)  =&gt; 7
(lcm 14 35)     =&gt; 70
(lcm 1 2 3 4 5) =&gt; 60
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap04">関数定義</h3>
<h4>●defun は関数を定義する</h4>
<p> Common Lisp で関数を定義する方法を説明します。簡単な例として、数を 2 乗する関数を作ってみます。
</p>

<pre class="list">
List 1 : 数を 2 乗する関数

(defun square (x) (* x x))
</pre>

<p> 関数を定義するときは <b>defun (DEfine FUNction)</b> を使います。defun の構文を下図に示します。
</p>

<pre class="fig">
 (defun   関数名            --- (defun square 
        ( 仮引数名  ... )   ---     (x)
             処理１
             処理２
             ・・・         ---     (* x x))  
             処理Ｍ)

            図 9 : defun の構文
</pre>

<p> defun は数式と比較するとわかりやすいでしょう。
</p>
<pre class="fig">
          ｆ   （ｘ） ＝  ｘ * ｘ

        関数名  引数     処理内容

 (defun  square  (x)      (* x x)  ) 

    図 10 : defun と数式の比較
</pre>

<p> それでは、実際に実行してみます。
</p>
<pre>
(defun square (x) (* x x))
=&gt; square
(square 4)
=&gt; 16
</pre>

<p> 関数を定義するには名前が必要です。defun の次に関数名をシンボルで定義します。文字列や数値ではいけません。defun で定義された処理内容は、関数名で指定したシンボルに格納されます。
</p>
<p> 関数名の次にはリストが必要です。これを<b>ラムダリスト (lambda-list)</b> といい、関数の引数名をシンボルで定義します。引数を取らない関数は空リスト () を設定します。それから、関数定義で使用する引数のことを<b>仮引数</b>、実際に与えられる引数を<b>実引数</b>といいます。square の定義で使用した x が仮引数で、(square 4) の 4 が実引数となります。
</p>
<p> そして、最後に処理内容を定義します。square の処理内容は (* x x) の 1 つだけですが、defun では複数の S 式を定義することができます。この場合、S 式はリストに並べた順番で評価され、最後に評価された S 式の結果を、その関数の評価結果として返します。
</p>
<p> defun は正常に関数を定義できたら、関数名のシンボルを返します。square を実行するには今まで説明したように、リストの先頭に square をセットしその後ろに引数を与えれば、square に定義された処理内容を実行できます。
</p>

<h4>●レキシカル変数とスペシャル変数</h4>
<p> では、ここで変数 x に値が代入されている場合を考えてみましょう。
</p>
<pre>
(setq x 100)
=&gt; 100
(square 5) =&gt; ?
</pre>
<p> 結果はどうなると思いますか。100 の 2 乗で 10000 になるのでしょうか。これはちゃんと 5 の 2 乗が計算されて、結果は 25 になります。そして、square を実行したあとでも x の値は変わりません。
</p>
<pre>
(square 5)
=&gt; 25
x
=&gt; 100
</pre>

<p> 関数 square の仮引数 x は、その関数が実行されている間だけ有効です。このような変数を<b>レキシカル変数 (Lexical variable)</b> もしくは<b>局所変数</b>といいます。これに対し、最初 x に値を代入した場合、その値は一時的なものではなく、その値はずっと残っています。このような変数を<b>スペシャル変数 (Special variable)</b> もしくは<b>グローバル変数</b>といいます。
</p>
<p> Common Lisp はシンボルの値を求めるとき、それがレキシカル変数であればその値を使います。レキシカル変数でなければ、スペシャル変数の値を使います。次の例を見てください。
</p>

<pre>
(setq x 10)
=&gt; 10
(setq y 20)
=&gt; 20
(defun foo (x) (print x) (print y))
=&gt; foo

(foo 100)

100       &lt;= print の出力
20 20     &lt;= 最初は print の出力で、次が foo の返り値
</pre>

<p> print は S 式を出力する関数です。print は改行してから S 式を出力して、最後に空白文字を 1 文字つけます。print は出力した S 式をそのまま返します。
</p>
<p> 最初にスペシャル変数として x と y に値を代入します。関数 foo は仮引数として x を使います。foo を実行すると、x はレキシカル変数なので値は実引数の 100 になります。y はレキシカル変数ではないのでスペシャル変数の値 20 になります。この関係を図に示すと、次のようになります。
</p>
<pre class="fig">
 ┌────── Lisp system  ───────┐ 
 │                                        │ 
 │  スペシャル変数  x                     │ 
 │  スペシャル変数  y ←───────┐  │ 
 │                                    │  │ 
 │      ┌─ 関数 foo  仮引数 x ─┐  │  │ 
 │      │                    ↑  │  │  │ 
 │      │          ┌────┘  │  │  │ 
 │      │    (print x)           │  │  │ 
 │      │          ┌──────┼─┘  │ 
 │      │    (print y)           │      │ 
 │      │                        │      │ 
 │      └────────────┘      │ 
 │                                        │ 
 └────────────────────┘ 

 図 11 : スペシャル変数とレキシカル変数の関係
</pre>
<p> このように、スペシャル変数の値はレキシカル変数の値で隠されるわけです。Common Lisp では、変数の種類を見た目で区別できるように、スペシャル変数を '*' (アスタリスク) で囲む慣習があります。ここでは説明のために、スペシャル変数とレキシカル変数に同じシンボル x を使いましたが、スペシャル変数を定義する場合は慣習に従って *x* としたほうがよいでしょう。
</p>

<h4>●let はレキシカル変数を定義する</h4>
<p> 関数の仮引数はレキシカル変数として扱われますが、このほかに Common Lisp では、レキシカル変数を定義するための特殊形式 <b>let</b> が用意されています。let の構文を見てみましょう。
</p>

<pre class="fig">
 (let ((変数１ 初期値１)
       (変数２ 初期値２)
        ・・・・・・
       (変数Ｍ 初期値Ｍ)) 
     Ｓ式１
     ・・・
     Ｓ式Ｍ)

    図 12 : let の構文
</pre>

<p> let は関数の仮引数のように与えられた名前をレキシカル変数として扱い、あとに続く S 式を順番に評価します。変数は初期値を評価した値に初期化されます。初期値が省略されると変数は nil に初期化されます。定義されたレキシカル変数は、let の実行が終了するまで有効です。let は最後に評価した S 式の値を評価結果として返します。それでは、簡単な例を示しましょう。
</p>
<pre>
(setq x 10)
=&gt; 10
(let ((x 100)) (print x))
=&gt; 100 100
x
=&gt; 10
</pre>

<p> 最初 x に 10 を代入します。この場合、変数 x はスペシャル変数として扱われます。次の let では、まず x をレキシカル変数として定義して 100 に初期化します。そのあと、(print x) を実行します。最初の 100 は、print が画面へ出力したもので、次の 100 が let の返り値です。let の終了後、変数 x の値は 10 のままです。let で定義した変数 x は、確かにレキシカル変数として扱われたことがわかります。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abclisp01.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp03.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>