<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Common Lisp 入門</title>
  <meta name="description" content="xyzzy,xyzzy Lisp,Common Lisp,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881765</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>xyzzy Lisp Programming</h1>
<h2>Common Lisp 入門</h2>
<div class="small">
[ <a href="abclisp05.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp07.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chap11">列関数</h3>
<p> Common Lisp はリスト (list)、文字列 (string)、ベクタ (vector) を、<b>列 (sequence)</b> として統一して扱うことができます。
</p>

<pre class="fig">
            ┌── list  （リスト型） 
            │
 sequence ─┼── string（文字列型） 
 （列型）   │
            └── vector（ベクタ型） 

    図 1 : 列型データの型指定子
</pre>

<p> 列型データを操作する関数を<b>列関数</b>と呼びます。列関数には有用な関数が多数用意されています。
</p>

<h4>●単純な列関数</h4>
<p> まずは単純な列関数を説明します。表 1 を見てください。
</p>
<table border=1>
<caption>表 1 : 単純な列関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>elt</b> sequence index</td><td>index 番目の要素を返す</td></tr>
  <tr><td><b>subseq</b> sequence start [end]</td><td>部分列を取り出す</td></tr>
  <tr><td><b>copy-seq</b> sequence</td><td>列のコピー（(subseq sequence 0) と同じ）</td></tr>
  <tr><td><b>length</b> sequence</td><td>列の長さを返す</td></tr>
  <tr><td><b>reverse</b> sequence</td><td>要素を逆順にした新しい列を返す</td></tr>
  <tr><td><b>make-sequence</b> type size</td><td>型が type で長さが size の列型データを生成する</td></tr>
</tbody>
</table>

<p> 列はベクタと同様に 0 から数えます。elt で指定する index の範囲は、列の長さを len とすると 0 から len - 1 までとなります。subseq の start と end はコピーする範囲を指定します。end を省略すると列の最後尾が範囲となります。start 位置の要素はコピー範囲に含まれますが、end 位置の要素は範囲外になることに注意してください。次の図を見てください。
</p>
<pre class="fig">
           範  囲
       │←───→│
       │          │
 （ａ  ｂ  ｃ  ｄ  ｅ  ｆ  ｇ） 
       ↑              ↑
       │              │
      start (1)        end (5)

   (subseq '(a b c d e f) 1 5)
   =&gt; (b c d e)

    図 2 : 列関数の範囲指定
</pre>
<p> 1 番目の要素 b は範囲内ですが 5 番目の要素 f は範囲外なので、コピーされたリストに f は含まれません。
</p>
<p> 関数 make-sequence は type で指定した列型データを作成します。キーワード :initial-element を指定すると、列はその値で初期化されます。
</p>
<p> それでは簡単な例を示しましょう。
</p>
<pre>
(setq a '(10 11 12 13 14 15)) =&gt; (10 11 12 13 14 15)

(elt a 0) =&gt; 10

(subseq a 1 4) =&gt; (11 12 13)

(copy-seq a) =&gt; (10 11 12 13 14 15)

(length a) =&gt; 6

(reverse a) =&gt; (15 14 13 12 11 10)

(make-sequence 'list 10 :initial-element 0)
=&gt; (0 0 0 0 0 0 0 0 0 0)
</pre>
<h4>●文字</h4>
<p> 文字列から取り出した要素は <b>文字 (character)</b> として扱われます。Common Lisp には文字型データが用意されていて、<b>#\</b> に続けて文字自身を書いて表します。xyzzy Lisp は日本語を 1 文字として扱うことができます。簡単な例を示しましょう。
</p>
<pre>
(setq a "abcdeあいうえお") =&gt; "abcdeあいうえお"

(elt a 0) =&gt; #\a
(elt a 5) =&gt; #\あ

(length a) =&gt; 10

(reverse a) =&gt; "おえういあedcba"

(make-sequence 'string 10 :initial-element #\a)
=&gt; "aaaaaaaaaa"

(make-sequence 'string 10 :initial-element #\あ)
=&gt; "ああああああああああ"
</pre>
<p> 文字列から文字を取り出すには、elt のほかに関数 <b>char</b> を使うことができます。
</p>
<pre class="item">
char string index
</pre>
<pre>
(char "あいうえお" 3) =&gt; #\え
</pre>
<p> char の引数 string は文字列でなければいけません。
</p>
<h4>●列の探索</h4>
<p> 次に、列を探索する関数を説明します。表 2 を見てください。
</p>
<table border=1>
<caption>表 2 : 列の探索</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>find</b> item sequence</td><td>item と等しい最初の要素を返す</td></tr>
  <tr><td><b>find-if</b> predicate sequence</td><td>predicate が真となる最初の要素を返す</td></tr>
  <tr><td><b>find-if-not</b> predicate sequence</td><td>predicate が偽となる最初の要素を返す</td></tr>
  <tr><td><b>position</b> item sequence</td><td>item と等しい最初の要素の位置を返す</td></tr>
  <tr><td><b>position-if</b> predicate sequence</td><td>predicate が真となる最初の要素の位置を返す</td></tr>
  <tr><td><b>position-if-not</b> predicate sequence</td><td>predicate が偽となる最初の要素の位置を返す</td></tr>
  <tr><td><b>count</b> item sequence</td><td>item と等しい要素の個数を返す</td></tr>
  <tr><td><b>count-if</b> predicate sequence</td><td>predicate が真となる要素の個数を返す</td></tr>
  <tr><td><b>count-if-not</b> predicate sequence</td><td>predicate が偽となる要素の個数を返す</td></tr>
</tbody>
</table>

<p> 名前の最後に -if, -if-not がつく関数は述語 predicate を受け取る高階関数です。それから、単純な列関数以外では、表 3 に示すキーワードを使用することができます。
</p>
<table border=1>
<caption>表 3 : 列関数の主なキーワード</caption>
<thead>
  <tr><th>キーワード</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>:start, :end</td><td>始点と終点を指定</td></tr>
  <tr><td>:test, :test-not</td><td>述語の指定</td></tr>
  <tr><td>:key</td><td>比較するときのキーにアクセスする関数</td></tr>
  <tr><td>:count</td><td>個数の制限</td></tr>
  <tr><td>:from-end</td><td>列の後ろから処理を行う</td></tr>
</tbody>
</table>

<p> もっともよく使われるキーワードは :start と :end です。これは subseq の start, end と同様に部分列を指定します。簡単な例を示しましょう。
</p>
<pre>
(setq a '(10 11 12 13 14 15 16 17 18 19))
=&gt; (10 11 12 13 14 15 16 17 18 19)

(find-if #'oddp a :start 2) =&gt; 13

(position-if #'oddp a :start 4) =&gt; 5

(count-if #'oddp a :start 3 :end 7) =&gt; 2
</pre>
<p> find-if の例では、2 番目から奇数を探すので 11 ではなく 13 を返します。position-if では、4 番目から奇数を探すので 15 の位置 5 を返します。count-if では部分列 (13 14 15 16) の奇数をカウントするので 2 を返します。
</p>

<p> :test, :test-not は述語を指定します。このキーワードは、-if, -if-not がついている列関数で使うことはできません。-if, -if-not 以外の関数では、デフォルトで要素の比較に述語 eql を使います。たとえば、文字列を格納しているリストからデータを探す場合、eql では探すことができません。次の例を見てください。
</p>
<pre>
(find "def" '("abc" "def" "ghi")) =&gt; nil

(find "def" '("abc" "def" "ghi") :test #'equal) =&gt; "def"
</pre>
<p> この場合、:test に equal を指定することで文字列を検索することができます。:test-not は :test の逆で、指定した述語が偽となる要素を探します。
</p>
<p> 列に格納されたデータがリストの場合、その中の要素をキーにして探索できると便利です。この場合はキーワード :key を使います。次の例を見てください。
</p>
<pre>
(find 'b '((a . 1) (b . 2) (c . 3))) =&gt; nil

(find 'b '((a . 1) (b . 2) (c . 3)) :key #'car) =&gt; (b . 2)
</pre>
<p> :key を指定しないと b と要素 (リスト) を eql で比較することになるので、データを見つけることができません。:key に car を指定することで、要素に car を適用した結果と b を比較することができるので、(b . 2) を見つけることができます。:from-end に t を指定すると、列の最後尾から検索を開始します。:count は列を修正する関数で説明します。
</p>

<h4>●列の修正</h4>
<p> 次は列を修正する関数を説明します。表 4 を見てください。
</p>
<table border=1>
<caption>表 4 : 列の修正</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>remove</b> item sequence</td><td>item と等しい要素を取り除く</td></tr>
  <tr><td><b>remove-if</b> predicate sequence</td><td>predicate が真となる要素を取り除く</td></tr>
  <tr><td><b>remove-if-not</b> predicate sequence</td><td>predicate が偽となる要素を取り除く</td></tr>
  <tr><td><b>substitute</b> new old sequence</td><td>old と等しい要素を new に置き換える</td></tr>
  <tr><td><b>substitute-if</b> new predicate sequence</td><td>predicate が真となる要素を new に置き換える</td></tr>
  <tr><td><b>substitute-if-not</b> new predicate sequence</td><td>predicate が偽となる要素を new に置き換える</td></tr>
  <tr><td><b>fill</b> sequence item</td><td>列の要素を item で置き換える</td></tr>
  <tr><td><b>remove-duplicates</b> sequence</td><td>列の重複した要素を取り除く (2005/04/17 追加)</td></tr>
</tbody>
</table>

<p> remove と substitute は引数を変更しませんが、fill は引数 sequence を破壊的に修正します。このほかに、引数を破壊的に修正する関数 delete と nsubstitute があります。簡単な例を示しましょう。
</p>
<pre>
(setq a '(10 11 12 13 14 15 16 17 18 19))
=&gt; (10 11 12 13 14 15 16 17 18 19)

(remove-if #'oddp a) =&gt; (10 12 14 16 18)

(remove-if #'oddp a :start 2 :end 8) =&gt; (10 11 12 14 16 18 19)

(substitute-if 99 #'oddp a) =&gt; (10 99 12 99 14 99 16 99 18 99)

(substitute-if 99 #'oddp a :start 3 :end 7)
=&gt; (10 11 12 99 14 99 16 17 18 19)

(fill a 99 :start 3 :end 7) =&gt; (10 11 12 99 99 99 99 17 18 19)

a =&gt; (10 11 12 99 99 99 99 17 18 19)
</pre>
<p> キーワード :count は、処理する要素の個数を制限します。たとえば、remove であれば item と等しい要素を列からすべて削除しますが、:count で個数が指定されていると、それ以上の削除は行いません。次の例を見てください。
</p>
<pre>
(remove 'a '(a b c a b c a b c)) =&gt; (b c b c b c)

(remove 'a '(a b c a b c a b c) :count 2) =&gt; (b c b c a b c)

(remove 'a '(a b c a b c a b c) :count 2 :from-end t)
=&gt; (a b c b c b c)
</pre>
<p> このように、:count に 2 を指定すれば、a は 2 つしか削除されません。:from-end を設定すれば、後ろから 2 つ a を削除します。また、:test-not を指定することで、item と等しくないデータを削除する、つまり、item と等しいデータを取り出すこともできます。
</p>
<pre>
(remove 'b '((a . 1) (b . 2) (c . 3) (b . 4)) :test-not #'eql :key #'car)
=&gt; ((b . 2) (b . 4))
</pre>
<p> remove-duplicates は sequence の要素を順番に比較し、一致する要素が 2 つあれば sequence の前にある要素を削除します。等しい要素が複数個ある場合、結果として一番最後の要素だけが 1 つ残ります。:form-end が真の場合、sequence の後ろにある要素が削除されるので、一番前の要素だけが 1 つ残ります。このほかに、引数を破壊的に修正する delete-duplicates があります。簡単な使用例を示します。
</p>
<pre>
(remove-duplicates '(a b c b d d d e))
=&gt; (a c b d e)
(remove-duplicates '(a b c b d d d e) :from-end t)
=&gt; (a b c d e)
(remove-duplicates '("abc" "def" "abc" "ghi") :test #'equal)
=&gt; ("def" "abc" "ghi")
(remove-duplicates '("abc" "def" "abc" "ghi") :test #'equal :from-end t)
=&gt; ("abc" "def" "ghi")
</pre>
<h4>●マッピング</h4>
<p> マップ関数 mapcar はリストにしか適用できませんが、Common Lisp には列型データに適用できるマップ関数が用意されています。
</p>
<table border=1>
<caption>表 5 : マッピング</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>map</b> result-type func sequences ...</td><td>列の要素に func を適用し結果を列に格納して返す</td></tr>
  <tr><td><b>map-into</b> result-seq func sequences ...</td><td>列の要素に func を適用し結果を result-seq に代入する</td></tr>
</tbody>
</table>

<p> 関数 map は、引数の列の要素に関数 func を適用し、その結果を要素とする列型データを返します。返り値のデータ型は result-type で指定します。関数 map-into は、map と同様に引数の列の要素に関数 func を適用しますが、その結果を列 result-seq に代入します。result-seq の内容は書き換えられることに注意してください。
</p>
<p> それから、map-into の result-seq には文字列を指定できません。リストかベクタだけなので注意してください。簡単な例を示します。
</p>
<pre>
(map 'list #'+ '(1 2 3) '(10 20 30 40)) =&gt; (11 22 33)

(map 'vector #'* '(10 20 30) '(1 2 3)) =&gt; #(10 40 90)

(setq a #(10 20 30 40)) =&gt; #(10 20 30 40)

(map-into a #'+ '(1 2 3) '(4 5 6)) =&gt; #(5 7 9 40)
a =&gt; #(5 7 9 40)
</pre>

<h4>●列の連結</h4>
<p> 複数の列を連結するには関数 concatenate を使います。
</p>
<table border=1>
<caption>表 6 : 列の連結</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>concatenate</b> result-type sequences ...</td><td>引数を連結した結果を result-type で指定した列で返す</td></tr>
</tbody>
</table>

<p> concatenate は複数の列を連結し、結果を result-type で指定したデータ型で返します。concatenate の場合、ふつう list, string, vector のどれかを指定します。簡単な使用例を示しましょう。
</p>
<pre>
(concatenate 'list '(a b c) '(d e f g)) =&gt; (a b c d e f g)

(concatenate 'vector '(a b c) '(d e f g)) =&gt; #(a b c d e f g)

(concatenate 'string '(#\a #\b #\c) '(#\d #\e #\f #\g)) =&gt; "abcdefg"
</pre>
<p> リストやベクタを文字列に変換する場合、列の要素は文字でなければいけません。
</p>

<h4>●縮約 (2005/04/17 追加)</h4>
<p> 関数 reduce は 2 つの引数を取る関数 function と sequence を引数に取ります。
</p>
<pre class="item">
<b>reduce</b> function sequence
</pre>
<p> reduce は sequence の各要素に対して関数 function (F) を次のように適用します。
</p>
<pre class="fig">
(A1 A2 A3 ... An-1 An) = reduce F =&gt; (F (F ... (F (F A1 A2) A3) ...) An-1) An)

:from-end t の場合
(A1 A2 A3 ... An-1 An) = reduce F =&gt; (F A1 (F A2 (F A3 ... (F An-1 An) ...)))
</pre>
<p> たとえば、関数 F が単純な加算関数とすると、reduce の結果は列の要素の和になります。
</p>
<pre class="item">
F(x, y) = x + y の場合 : reduce =&gt; A1 + A2 + A3 + ... + An-1 + An
</pre>
<p> このような操作を「縮約」とか「畳み込み」といいます。簡単な例を示しましょう。
</p>
<pre>
(reduce #'+ '(1 2 3 4 5 6)) =&gt; 21
(reduce #'list '(1 2 3 4 5 6)) =&gt; (((((1 2) 3) 4) 5) 6)
(reduce #'list '(1 2 3 4 5 6) :from-end t) =&gt; (1 (2 (3 (4 (5 6)))))
</pre>
<p> キーワード :initial-value が指定された場合、reduce は関数 F を次のように適用します。
</p>
<pre>
:initial-vallue G の場合

(G A1 A2 A3 ... An-1 An) = reduce F =&gt; (F (F ... (F (F G A1) A2) ...) An-1) An)

(reduce #'list '(1 2 3 4 5 6) :initial-value 0) =&gt; ((((((0 1) 2) 3) 4) 5) 6)
</pre>
<pre>
:initial-vallue G :from-end t の場合
(A1 A2 A3 ... An-1 An G) = reduce F =&gt; (F A1 (F A2 (F A3 ... (F An G) ...)))

(reduce #'list '(1 2 3 4 5 6) :from-end t :initial-value 7)
=&gt; (1 (2 (3 (4 (5 (6 7))))))
</pre>
<p> :initial-value がなくて列の要素が 1 つしかない場合、reduce はその要素を返します。列が空で :initial-value が指定されている場合、reduce は :initial-value の値を返します。もしも、列が空で :initial-value も指定されていない場合、reduce は関数 function を引数無しで呼び出してその結果を返します。簡単な例を示します。
</p>
<pre>
(reduce #'+ '(1)) =&gt; 1
(reduce #'+ nil :initial-value 2) =&gt; 2
(reduce #'+ nil) =&gt; 0
</pre>
<p> reduce と 2 引数の関数を組み合わせることで、いろいろな関数を実現することができます。たとえば、length と append は次のようになります。
</p>
<pre>
(reduce #'(lambda (x y) (+ x 1)) '(a b c d e) :initial-value 0)
=&gt; 5
(reduce #'cons '(a b c d e) :initial-value '(1 2 3 4 5) :from-end t)
=&gt; (a b c d e 1 2 3 4 5)
</pre>
<h4>●ソートとマージ</h4>
<p> ソート (sort) はデータを昇順または降順に整列させる操作です。マージ (merge) は整列済みの 2 つのデータ列を 1 つの整列済みのデータ列にまとめる操作です。Common Lisp には関数 sort と merge が用意されています。
</p>

<table border=1>
<caption>表 7 : ソートとマージ</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td><b>sort</b> sequence predicate</td><td>sequence をソートする</td></tr>
  <tr><td><b>merge</b> result-type seq1 seq2</td><td>seq1 と seq2 をマージする</td></tr>
</tbody>
</table>

<p> 関数 sort は引数の sequence を破壊的にソートし、関数 merge はソート済みの 2 つの列 seq1 と seq2 をマージします。簡単な使用例を示しましょう。
</p>
<pre>
(setq a #(9 1 8 2 7 3 4 6 5))

(sort a #'<) =&gt; #(1 2 3 4 5 6 7 8 9)
a =&gt; #(1 2 3 4 5 6 7 8 9)

(setq a #((9 a) (1 b) (8 c) (2 d) (7 e) (3 f) (4 g) (6 h) (5 i)))
=&gt; #((9 a) (1 b) (8 c) (2 d) (7 e) (3 f) (4 g) (6 h) (5 i))

(sort a #'&lt; :key #'car)
=&gt; #((1 b) (2 d) (3 f) (4 g) (5 i) (6 h) (7 e) (8 c) (9 a))

(merge 'list '(1 3 5 7 9) '(2 4 6 8) #'<)
=&gt; (1 2 3 4 5 6 7 8 9)
</pre>
<p> キーワード :key を設定することで、複雑なデータでもソートやマージを簡単に行うことができます。
</p>
</section>
<hr>
<section class="contents">
<h3 id="yori06">ちょっと寄り道</h3>
<h4>■パスカルの三角形</h4>
<p> <a href="abclisp04.html#yori02">組み合わせの数</a> では、組み合わせの数を求める関数 ncr を使って「パスカルの三角形」を作りました。ここでは ncr を使わずにパスカルの三角形を作ってみましょう。リストとベクタどちらを使っても簡単にプログラムできます。
</p>

<p> パスカルの三角形は、両側がすべて 1 で内側の数はその左上と右上の和になっています。したがって、n 段の三角形を作る場合、一段前の値を記憶しておいて隣同士の要素を足し算すればいいわけです。一段前の値をリストに格納すると、プログラムは次のようになります。
</p>

<pre class="list">
List 1 : パスカルの三角形（リスト版）

(defun pascal-sub (num-list)
  (if (second num-list)
      (cons (+ (first num-list) (second num-list))
            (pascal-sub (rest num-list)))
    '(1)))

(defun pascal-list (n)
  (let (buf)
    (dotimes (i n)
      (setq buf (pascal-sub (cons 0 buf)))
      (print buf))))
</pre>

<p> 関数 pascal-sub は、リストの隣同士の要素を足した値をリストに格納して返します。この処理は再帰呼び出しを使えば簡単です。num-list の先頭要素と次の要素を足し算し、その値を再帰呼び出しの返り値に cons で追加すればいいわけです。リストの要素がひとつになると、second は nil を返すので再帰呼び出しが停止します。ここでリスト (1) を返します。また、pascal-sub を呼び出すときは num-list の先頭に 0 を追加します。これで、リストの先頭と最後尾を 1 にすることができます。あとは、関数 pascal-list で pascal-sub を n 回呼び出すだけです。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
(pascal-list 6)

(1) 
(1 1) 
(1 2 1) 
(1 3 3 1) 
(1 4 6 4 1) 
(1 5 10 10 5 1) 
nil
</pre>
<p> 次は、ベクタを使ってプログラムを作ります。n 段の三角形を作る場合、大きさが n + 1 のベクタを用意します。たとえば、6 段の三角形を作ってみましょう。次の図を見てください。
</p>
<pre class="fig">
      0  1  2  3  4  5  6
   ------------------------- 
 1 [  0  1  0  0  0  0  0  ]
       ＼|＼|
 2 [  0  1  1  0  0  0  0  ]
       ＼|＼|＼|
 3 [  0  1  2  1  0  0  0  ]
       ＼|＼|＼|＼|
 4 [  0  1  3  3  1  0  0  ]
       ＼|＼|＼|＼|＼|
 5 [  0  1  4  6  4  1  0  ]
       ＼|＼|＼|＼|＼|＼|
 6 [  0  1  5 10 10  5  1  ]

図 3 : パスカルの三角形の求め方
</pre>
<p> 最初にベクタの内容を 0 に初期化し、1 番目に 1 をセットします。これが 1 段目になります。あとは図のように、隣の要素を足し算するだけです。プログラムは次のようになります。
</p>

<pre class="list">
List 2 : パスカルの三角形（ベクタ版）

(defun pascal (n)
  (let ((buff (make-array (1+ n) :initial-element 0)))
    (setf (aref buff 1) 1)
    (dotimes (i n)
      (do ((j (1+ i) (1- j)))
          ((zerop j))
        (format t "  ~3D" (setf (aref buff j)
                                (+ (aref buff j) (aref buff (1- j))))))
      (terpri))))
</pre>

<p> ベクタはひとつあれば十分です。ただし、ベクタの値を書き換えていくので、ベクタの後方から計算していくことに注意してください。前方から計算すると、値がおかしくなります。実行結果は次のようになります。
</p>
<pre>
(pascal 6)
    1
    1    1
    1    2    1
    1    3    3    1
    1    4    6    4    1
    1    5   10   10    5    1
nil
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap12">ラムダリストキーワード</h3>
<p> Common Lisp は defun やラムダ式の仮引数を定義するリスト (ラムダリスト) で、<b>ラムダリストキーワード</b>を使うことができます。表 8 を見てください。
</p>

<table border=1>
<caption>表 8 : ラムダリストキーワード</caption>
<thead>
  <tr><th>キーワード名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>&amp;optional</td><td>引数のデフォルト値を設定</td></tr>
  <tr><td>&amp;rest</td><td>引数をリストにまとめて関数へ渡す</td></tr>
  <tr><td>&amp;key</td><td>キーワードの設定</td></tr>
  <tr><td>&amp;aux</td><td>補助変数の指定</td></tr>
</tbody>
</table>

<p> ラムダリストキーワードは &amp; で始まり、その後ろに引数 (パラメータ) が続きます。それでは &amp;optional から説明しましょう。
</p>

<h4>●&amp;optional</h4>
<p> &amp;optional で指定された引数を<b>オプションパラメータ</b>といい、その引数のデフォルト値を設定することができます。指定範囲は次のラムダリストキーワードまで、またはラムダリストの終わりまでです。次の例を見てください。
</p>
<pre>
((lambda (a &amp;optional (b 10)) (+ a b)) 1 2)
=&gt; 3
((lambda (a &amp;optional (b 10)) (+ a b)) 1)
=&gt; 11
</pre>
<p> b がオプションパラメータです。デフォルト値は (パラメータ デフォルト値）で指定します。また、&amp;optional b のように引数名だけ指定すると、デフォルト値は nil になります。オプションパラメータは対応する実引数が省略された場合、その引数にはデフォルト値がセットされます。実引数が指定された場合は、その値がセットされます。最初の例では実引数 1 と 2 があるので、b には 2 がセットされます。次の例では、実引数が 1 しかないので、b にはデフォルト値 10 がセットされます。
</p>

<p> 簡単な例題として、リストを反転する関数 reverse を再帰定義で作ってみましょう。Common Lisp には列関数 reverse が用意されているので、関数名は my-reverse とします。reverse はリストを car と cdr で分解して、残りのリストを反転させてから先頭の要素を最後尾に追加することで実現できます。プログラムは次のようになります。
</p>

<pre class="list">
List 3 : リストの反転

(defun my-reverse (l)
  (if (atom l)
      l
      (append (my-reverse (cdr l)) (list (car l)))))
</pre>

<p> append で反転したリストの最後尾に先頭の要素を追加します。簡単なプログラムですが append を使っているので、リストが長くなると時間がかかるのが欠点です。そこで、次に示すように補助的な関数を用意します。
</p>

<pre class="list">
List 4 : リストの反転（改良版）

(defun my-rev-sub (l z)
  (if (atom l)
      z
      (my-rev-sub (cdr l) (cons (car l) z))))

(defun my-reverse (l) (my-rev-sub l nil))
</pre>

<p> 関数 my-rev-sub は、リスト l の先頭要素を引数 z の先頭に追加していきます。したがって、(my-rev-sub l nil) と呼び出せば、リスト l を反転することができます。my-rev-sub の呼び出しを図に示すと、次のようになります。
</p>

<pre class="fig">
(my-rev-sub '(1 2 3 4) nil)
  (my-rev-sub '(2 3 4) '(1))
    (my-rev-sub '(3 4) '(2 1))
      (my-rev-sub '(4) '(3 2 1))
        (my-rev-sub nil '(4 3 2 1))
        =&gt; z の値 (4 3 2 1) を返す
      =&gt; (4 3 2 1)
    =&gt; (4 3 2 1)
  =&gt; (4 3 2 1)
=&gt; (4 3 2 1)
</pre>

<p> 引数 z には反転途中の値が格納されていることがわかりますね。このような補助的な関数を使う場合、引数 z をオプションパラメータとして指定すれば、ひとつの関数で my-reverse を実現することができます。プログラムは次のようになります。
</p>

<pre class="list">
List 5 : リストの反転(&amp;optionalを使用)

(defun my-reverse (l &amp;optional z)
  (if (atom l)
      z
      (my-reverse (cdr l) (cons (car l) z))))
</pre>
<p> これで (my-reverse '(1 2 3 4)) と呼び出せば、リストの反転 (4 3 2 1) を求めることができます。
</p>

<h4>●&amp;rest</h4>
<p> &amp;rest で指定された引数を<b>レストパラメータ</b>といい、引数をひとつのリストにまとめて関数へ渡します。&amp;rest の後ろには引数が定義され、その後ろにはほかのラムダリストキーワードか、ラムダリストの終わりでなければいけません。&amp;rest を使うことで、可変個の引数を受け取る関数を定義することができます。
</p>
<p> たとえば、2 個以上の引数を受け取る関数は次のように定義します。
</p>
<pre class="item">
(defun foo (a b &amp;rest z)  ・・・・・  )
</pre>
<p> 2 個の実引数は a と b に代入され、残りの引数はリストに格納され z に代入されます。それでは、実際に試してみましょう。
</p>
<pre>
(defun foo (a b &amp;rest z) (format t "a = ~S, b = ~S, z =~S\n" a b z))
=&gt; foo

(foo 1 2 3 4 5)
a = 1, b = 2, z = (3 4 5)

(foo 1 2)
a = 1, b = 2, z = nil
</pre>

<p> format の ~S は S 式を表示する指定子です。引数が 2 つしかない場合、z には nil が代入されます。また、引数が 2 つに満たない場合はエラーとなります。つまり、&amp;rest で指定した変数に、余った実引数がすべてリストに格納されて渡されるのです。
</p>
<a name="update">
<p> 次は、0 個以上の引数を受け取る関数、つまり、引数が有っても無くてもどちらでも動作する関数を定義します。</p>
</a>

<pre class="item">
(defun foo (&amp;rest x) ・・・・・ )
</pre>

<p> この場合、仮引数は &amp;rest だけで指定します。実引数がない場合、x には nil が代入されます。もし、複数の引数があれば、それらをリストにまとめて x に代入します。それでは、実際に試してみましょう。
</p>
<pre>
<del>(defun foo z (format t "z =~S\n" z))</del> <sup>(訂正 2004/12/02)</sup>
(defun foo (&amp;rest z) (format t "z = ~S\n" z))
=&gt; foo

(foo 1 2 3 4 5)
z = (1 2 3 4 5)

(foo)
z = nil
</pre>
<h4>●&amp;key</h4>
<p> &amp;key で指定された引数を<b>キーパラメータ</b>といい、キーワードを設定することができます。有効範囲は次のラムダリストキーワードまで、またはラムダリストの終わりまでです。次の例を見てください。
</p>
<pre>
; &amp;key の使用例
((lambda (a &amp;key b c) (list a b c)) 10)
=&gt; (10 nil nil)
; デフォルト値の指定
((lambda (a &amp;key (b 1) (c 2) (d 3)) (list a b c d)) 10 :c 20 :b 30 :d 40)
=&gt; (10 30 20 40)

; オプションパラメータとの比較
((lambda (a &amp;key (b 1) (c 2) (d 3)) (list a b c d)) 10 :d 20)
=&gt; (10 1 2 20)
((lambda (a &amp;optional (b 1) (c 2) (d 3)) (list a b c d)) 10 1 2 20)
=&gt; (10 1 2 20)
</pre>
<p> キーパラメータは、オプションパラメータと同様にデフォルト値を設定することができます。複数の引数にデフォルト値を設定する場合、オプションパラメータよりもキーパラメータを使った方が便利です。最後の例を見てください。引数 d の値を設定する場合、オプションパラメータで定義すると、引数 b と c の値を省略することはできません。キーパラメータを利用することで、引数の個数や順番を気にせずに値を設定することができます。
</p>

<h4>●&amp;aux</h4>
<p> &amp;aux で指定された引数を<b>補助 (AUX) パラメータ</b>といいます。補助パラメータはどの実引数にもマッチしません。let* でレキシカル変数を定義することと同じ働きをします。
</p>
<p> let* は let と同様にレキシカル変数を定義しますが、変数の初期化が逐次的に行われるところが異なります。つまり setq と同様に、先に初期化された変数の値を参照することができます。次の例を見てください。
</p>
<pre>
(let* ((a 10)
       (b (* a 10)))
  (format t "a = ~D, b = ~D~%" a b))

a = 10, b = 100
</pre>
<p> 変数 b の初期化で変数 a の値を参照しています。a の値は先に初期化された 10 なので、変数 b の値は 100 になります。let の場合、変数 b の初期化で変数 a の値を参照することはできません。
</p>

<p> それでは &amp;aux の使用例を示します。
</p>
<pre>
; &amp;aux の使用例
((lambda (a b &amp;aux (c (car a))) (list a b c)) '(10 20) 30)
((10 20) 30 10)

; このプログラムと同じ
((lambda (a b) (let* ((c (car a))) (list a b c))) '(10 20) 30)
((10 20) 30 10)
</pre>
<p> &amp;aux c のように引数名だけ指定すると、変数は nil に初期化されます。
</p>

<h4>●注意事項</h4>
<p> これらのキーワードはいっしょに使うことができます。その場合、通常の引数の後ろに &amp;optional を定義し、その後ろで &amp;rest だけを定義、最後に &amp;key と &amp;aux を定義するようにしてください。
</p>
</section>
<hr>
<section class="contents">
<h3 id="yori07">ちょっと寄り道</h3>
<h4 id="sort">■ソート（その２）</h4>
<p> <a href="abclisp05.html#yori03">ソート（その１）</a>では、挿入ソートとクイックソートを説明しました。今回はクイックソートの弱点とマージソートを説明します。
</p>
<h4 id="quick_1">■クイックソートの弱点</h4>
<p> クイックソートは高速なアルゴリズムですが、枢軸の選び方によっては遅いソートと同じになってしまいます。たとえば、リストの先頭要素を枢軸として選ぶ場合、リストの要素が昇順または降順に並んでいると最悪の結果になります。次の図を見てください。
</p>

<pre class="fig">
         9 8 7 6 5 4 3 2 1

          9 を枢軸に分割

      (8 7 6 5 4 3 2 1)  9  ()

   8を枢軸に分割

 (7 6 5 4 3 2 1)  8  () | 9 | ()

  ・・・分割を繰り返していく・・・ 

 図 4 : クイックソート（最悪の場合）
</pre>
<p> クイックソートは、ソートするデータの中で中間の値を枢軸に選ぶと、データをほぼ半分に分割することができます。この場合がいちばん効率が良いのですが、上図のようにデータの最大値を枢軸として選ぶと、その要素と残りの要素にしか分割されません。これが最悪の場合で、分割のたびに最大値もしくは最小値を枢軸に選ぶと、実行時間は要素数の 2 乗に比例する、つまり遅いソートと同じ結果になるのです。
</p>

<p> このため、クイックソートをプログラムする場合、枢軸の選び方を工夫するのが一般的です。たとえば、データの中からいくつかの要素を選び、その中で中間の値を持つ要素を枢軸に選びます。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、中間の値を選ぶのに時間がかかってしまいます。実際には、3 つから 5 つの要素を選んで、その中で中間の値を枢軸とする場合が多いようです。
</p>

<p> ただし、この改良はベクタであれば簡単に実現できるのですが、リストには不向きであることに注意してください。たとえば、データが 1000 個ある場合、ベクタであれば 0, 500, 999 番目のデータを取り出すのは簡単ですが、リストではデータ数が多くなるほど、後ろのデータを取り出すのに時間がかかるようになります。先頭から 3 つのデータを取り出して枢軸を選んだとしても、降順または昇順に並んだデータには効果が無いのは明らかです。クイックソートは、リストよりもベクタに向いているソートアルゴリズムといえます。
</p>

<p> 次は、クイックソートと同様に高速なアルゴリズムであるマージソートを説明します。
</p>

<h4 id="merge">■マージ</h4>
<p> マージ (併合) とは、複数のソート済み列をひとつのソート済みの列にまとめる操作です。最初にマージから説明します。次の図を見てください。
</p>

<pre class="fig">
      ┌─ (1 3 5)  ; リスト a 
 () ←┤
      └─ (2 4 6)  ; リスト b 

    小さい方をセットする

       ┌─ (3 5)   ; リスト a 
 (1) ←┘
            (2 4 6) ; リスト b 

    1 をセットする

              (3 5) ; リスト a 
 (1 2) ←┐
         └─ (4 6) ; リスト b 

    2 をセットする

 データがなくなるまで繰り返す 

    図 5 : リストのマージ
</pre>

<p> 2 つのリスト a と b があります。これらのリストはソート済みとしましょう。これらのリストをソート済みのリストにまとめることを考えます。
</p>
a と b はソート済みなので先頭のデータがいちばん小さな値です。したがって、上図のように先頭のデータを比較し、小さい方のデータを取り出して順番に並べていけば、ソート済みのリストにまとめることができます。途中でどちらかのリストが空になったら、残ったリストのデータをそのまま追加します。
<p> Common Lisp には列関数 merge が用意されていますが、実際にプログラムを作ってみましょう。次のリストを見てください。
</p>

<pre class="list">
List 6 : リストのマージ

(defun merge-list (f l1 l2)
  (cond ((atom l1) l2)
        ((atom l2) l1)
        ((funcall f (car l1) (car l2))
         (cons (car l1) (merge-list f (cdr l1) l2)))
        (t (cons (car l2) (merge-list f l1 (cdr l2))))))
</pre>
<p> 関数 merge-list の引数 f がデータを比較する述語、l1 と l2 がマージするリストです。最初に、述語 atom でリスト l1 と l2 にデータがあるかチェックします。どちらかが空リストであれば、もう一方のリストを返します。これが再帰呼び出しの停止条件になります。
</p>
<p> l1 と l2 にデータがあれば、先頭要素を述語 f で比較します。f が真であれば l1 の先頭要素を、そうでなければ l2 の先頭要素をmerge-list が返すリストに追加します。merge-list を再帰呼び出しするときは、追加する先頭要素をリストから取り除くことに注意してください。これでリストをマージすることができます。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
(merge-list #'&lt; '(2 4 6 8) '(1 3 5 7 9))
=&gt; (1 2 3 4 5 6 7 8 9)
(merge-list #'&lt; '(10 20 30) '(1 2 3 4))
=&gt; (1 2 3 4 10 20 30)
</pre>
<h4 id="merge_sort">■マージソート</h4>
<p> マージソートは、このマージを使ってデータをソートします。次の図を見てください。
</p>

<pre class="fig">
  9 5 3 7 6 4 2 8  最初の状態

 |5 9|3 7|4 6|2 8| 長さ２の列に併合

 |3 5 7 9|2 4 6 8| 長さ４の列に併合 

  2 3 4 5 6 7 8 9  ソート終了

        図 6 : マージソート
</pre>

<p> マージをソートに応用する場合、最初は各要素をソート済みのリストとして考えます。この状態で隣のリストとマージを行い、長さ 2 のリストを作ります。次に、このリストに対して再度マージを行い、長さ 4 のリストを作ります。このように順番にマージしていくと、最後にはひとつのリストにマージされソートが完了します。
</p>

<p> それではプログラムを作りましょう。マージソートの場合、リストの長さを 1, 2, 4, 8, ... と増やしていくよりも、再帰的に考えた方が簡単にプログラムを作ることができます。まず、ソートするリストを 2 つに分割して、前半部分をソートします。次に、後半部分をソートして、その結果をマージすればいいわけです。
</p>
<p> 再帰呼び出しするたびにリストは 2 つに分割されるので、最後にリストの要素はひとつとなります。これはソート済みのリストなので、ここで再帰呼び出しを終了してマージ処理を行えばいいわけです。プログラムは次のようになります。
</p>

<pre class="list">
List 7 : マージソート

(defun merge-sort (f l n)
  (cond ((= n 1) (list (car l)))   ; 新しいリストを返す
        ((= n 2)
         (let ((x (first l)) (y (second l)))
           (if (funcall f x y) (list x y) (list y x))))
        (t (let ((m (truncate n 2)))
             ; リストを二分割し再帰呼び出しの結果をマージする
             (merge-list f
                         (merge-sort f l m)
                         (merge-sort f (nthcdr m l) (- n m)))))))
</pre>

<p> 関数 merge-sort の引数 f がデータを比較する述語、l がソートするリスト、n がリストの長さを表します。merge-list はリストを分割する処理で、新しいリストを作らないことに注意してください。次の図を見てください。
</p>

<pre class="fig">
  引数 l
   ｜
   ｜←── 長さn ──→｜
 （１ ２ ３ ４ ５ ６ ７ ８）   
   ｜←n/2→｜ ｜←n/2→｜
   ｜          ｜
  引数 l      引数 l1     再帰呼び出し 

        図 7 : リストの分割
</pre>

<p> merge-sort はソートするリストの範囲を開始位置と長さで表しています。上図のリストを二分割する場合、前半部分は l と n / 2 で表し、後半部分を l1 と n / 2 で表します。l1 は cdr を n / 2 回繰り返せば求めることができます。Common Lisp には cdr を繰り返す関数 nthcdr が用意されています。
</p>
<pre class="item">
nthcdr n list
</pre>
<p> nthcdr は list に対して n 回だけ cdr を適用します。n は非負の整数でなければなりません。簡単な例を示しましょう。
</p>

<pre>
(nthcdr 0 '(a b c d)) =&gt; (a b c d)
(nthcdr 2 '(a b c d)) =&gt; (c d)
(nthcdr 5 '(a b c d)) =&gt; nil
</pre>

<p> あとは再帰呼び出しでリストを分割していき、リストの長さが 1 になったならば新しいリストを返します。リストの長さが 2 の場合は簡単なので、2 つの要素を比較してソート済みのリストを作成して返します。そして、merge-sort の返り値を merge-list でマージすればいいわけです。
</p>

<p> それでは実行してみましょう。
</p>
<pre>
(merge-sort #'&lt; '(9 5 3 7 6 4 2 8) 8)
=&gt; (2 3 4 5 6 7 8 9)
(merge-sort #'&gt; '(9 5 3 7 6 4 2 8) 8)
=&gt; (9 8 7 6 5 4 3 2)
</pre>
<h4 id="result">■実行結果</h4>
<p> マージソートの実行時間は、データ数を N とすると平均して N * log<sub>2</sub> N に比例します。マージソートはクイックソートと同様に高速なアルゴリズムですが、実際にプログラムを作って比較してみるとクイックソートの方が高速です。ただし、マージソートは単純にリストを二分割するため、クイックソートと違いデータによって性能が劣化することはありません。どのようなデータに対しても力を発揮してくれるわけです。
</p>
<p> それでは、挿入ソート、クイックソート、マージソートの実行時間を比較してみましょう。データは整数値 1000 個とし、ランダム、昇順 (ソート済み)、降順 (逆順のこと) に要素を並べたリストを昇順にソートします。M.Hiroi のオンボロマシン (Pentium 166 MHz, Windows95) で実行しました。
</p>
<table border=1>
<caption>表 9 : 実行時間（秒）</caption>
<tbody>
  <tr><td></td><td>insert</td><td>quick</td><td>merge</td></tr>
  <tr><td>乱数</td><td>14.0</td><td>0.17</td><td>0.52</td></tr>
  <tr><td>昇順</td><td>0.08</td><td>8.3</td><td>0.27</td></tr>
  <tr><td>降順</td><td>29.8</td><td>8.3</td><td>0.29</td></tr>
</tbody>
</table>
<p> クイックソートは乱数データではいちばん速いのですが、昇順または降順のデータでは極端に遅くなります。今回のプログラムでは、これらのデータが最悪の結果になります。これがクイックソートの弱点です。これに対し、マージソートはデータの種類にかかわらず高速にソートできることがわかります。挿入ソートはとても遅いのですが、ソート済みのデータだけはとても速いですね。これが挿入ソートの特徴です。もしも、リストがほとんどソートされている状態であれば、挿入ソートでも高速にソートすることができます。
</p>

<p> また、要素数が少ない場合は単純なアルゴリズムである挿入ソートの方が速いです。クイックソートやマージソートでも、要素数が少なくなったら挿入ソートに切り換えると少しだけ速くなります。切り換えるタイミングですが、一般には 10 がその境目になるといわれています。この値は使用するプログラミング言語や実行環境によって変わるので、興味のある方は試してみてください。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2000-2005 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abclisp05.html">PrevPage</a> | <a href="../xyzzy_lisp.html">xyzzy Lisp</a> | <a href="abclisp07.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>