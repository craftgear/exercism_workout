<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Tcl/Tk お気楽 GUI プログラミング入門編</title>
  <meta name="description" content="Tcl/Tk,GUI,プログラミング,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881831</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Tcl/Tk GUI Programming</h1>
<h2>Tcl/Tk お気楽 GUI プログラミング入門編</h2>
<div class="small">
[ <a href="tcltk102.html">PrevPage</a> | <a href="tcltk_doc.html">Tcl/Tk GUI Programming</a> | <a href="tcltk104.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 ="d12">メニューバー</h3>
<p> 次は GUI には欠かせないメニューの作り方を説明します。Tcl/Tk ではメニューのためのコマンドがたくさん用意されていて、いろいろなメニューを構成することができますが、入門編は Windows でも標準になっている「メニューバー」という方法を説明します。
</p>

<h4>●menu</h4>
<p> メニューを作るにはコマンド menu を使います。
</p>
<pre class="item">
menu ウィジェット名 オプション
</pre>
<p> メニューバーの場合はオプション -type で menubar を指定します。作成したメニューバーはウィンドウを作成するコマンド toplevel のオプション -menu で設定します。メインウィジェット「 . 」 の場合は configure を使って変更します。
</p>
<pre class="list">
menu .m -type menubar
. configure -menu .m
</pre>
<p> これでウィンドウにメニューバーが設定されました。あとはこのメニューバーに具体的なメニューを追加します。これにはウィジェットコマンド add を使います。
</p>
<pre class="item">
.m add 項目 オプション
</pre>
<p> 第 2 引数の項目には、具体的なメニューを指定します。
</p>
<ul>
  <li><b>cascade</b><br>     複数のメニューを表示する
  <li><b>checkbutton</b><br> チェックボタンを表示
  <li><b>command</b><br>     -command で指定したコマンドを実行
  <li><b>radiobutton</b><br> ラジオボタンを表示
  <li><b>separator</b><br>   区切りを表示する
</ul>
<p> cascade を指定すると、そのメニューを選択したときに複数のメニューを表示します。checkbutton は yes / no のような二者択一の情報を設定するために使います。command はメニューが選択されたときに、オプション -command で指定したコマンドを実行します。radiobutton は複数の値からひとつを選ぶ場合に使います。separator は区切りを表示するだけです。
</p>

<p> checkbutton と radiobutton はメニューバーに直接定義するのではなく、cascade と組み合わせて使うことが一般的です。checkbutton と radiobutton を使う場合、選択する値をオプション -value で指定し、その値を格納する変数をオプション -variable で指定します。また、-command オプションを設定することもできます。この場合、変数に値がセットされるとともに、指定したコマンドが実行されます。
</p>

<p> たとえば、将棋やリバーシのようなゲームのメニューを考えてみましょう。最低限必要となるメニューは、ゲームの開始、先手と後手の選択、コンピュータの強さの設定、などでしょうか。最初の 2 つはメニュー Games で設定し、強さはメニュー Level で選択することにします。この場合、まず Games と Level をメニューバーに追加します。
</p>
<pre class="list">
.m add cascade -label "Games" -underline 0 -menu .m.m1
.m add cascade -label "Level" -underline 0 -menu .m.m2
</pre>
<p> オプション -underline は、ラベルの文字に下線を付け加えます。Windows の場合、Alt キーでメニューを選択できますが、この状態で下線のついた文字をキーボードから入力することで、そのメニューを選ぶことができます。
</p>

<p> cascade を使う場合、表示するメニューをオプション -menu で設定します。このメニューはメニューバー .m の中に設定するので、ウィジェット名は .m.m1 のようになります。それではメニュー Games を設定します (リスト 7)。
</p>

<pre class="list">
リスト 7 : Games メニューを作る

menu .m.m1 -tearoff no
.m.m1 add command -label "Start" -underline 0 -command "start"
.m.m1 add separator
.m.m1 add radiobutton -label "先手" -variable action -value 0
.m.m1 add radiobutton -label "後手" -variable action -value 1
.m.m1 add separator
.m.m1 add command -label "Exit" -underline 0 -command "exit"
</pre>

<p> menu のオプション -tearoff は、そのメニューをウィンドウから引きちぎることができるかを設定します。デフォルトでは yes になっています。その場合、メニューを選択するといちばん上に破線が表示され、そこをクリックするとそのメニューが独立したウィンドウになります。
</p>

<p> Start を選ぶとゲームを開始します。ゲームを開始するコマンド、これはゲームによって異なりますが、この例では start を実行します。
</p>

<p> 先手・後手の選択はラジオボタンを使っています。これで、先手、後手のどちらかを選ぶことができます。たとえば、後手をクリックすると、action の値は 1 にセットされ、ラベルの左側にレ点がつきます。使用する変数は、あらかじめ初期化しておきましょう。
</p>

<p> これで Games をクリックすると、Start、先手・後手、Exit という 3 つのメニューが現れます。
</p>

<p> 次はメニュー Level の設定です (リスト 8)。
</p>

<pre class="list">
リスト 8 : Level メニューの作成

menu .m.m2 -tearoff no
.m.m2 add radiobutton -label "Level 1" -variable level -value 1
.m.m2 add radiobutton -label "Level 2" -variable level -value 2
.m.m2 add radiobutton -label "Level 3" -variable level -value 3
</pre>

<p> ラジオボタンを使えば 3 つの中からひとつを選ぶことができます。ゲームの中身は空ですが、このように簡単にメニューを設定することができます。
</p>

<img src="img/10.gif" alt="メニューの画面"> メニューも数行で作成できる

<p> チェックボタンとラジオボタンは、メニューだけではなくウィジェットとして生成することができます。コマンドは checkbutton と radiobutton で、使うオプションはメニューの場合と同じです。Widget Tour にデモプログラムがありますので、参考にしてください。
</p>
<hr>
<h3 id="d13">キー入力とバインド</h3>
<p> いままでの例題は、マウスで操作するものばかりでした。今度はキーボードからの入力を受け付けるウィジェットを説明します。
</p>

<h4>●エントリー</h4>
<p> エントリー (entry) は 1 行の文字列を入力、または編集することができます。例題として、数式を入力して計算する calc.tcl を作ります。これはとても簡単に作ることができます。まずエントリーから説明しましょう。
</p>
<pre class="item">
entry ウィジェット名 オプション
</pre>
<p> entry でよく使うオプションは -textvariable です。entry で入力されたデータは指定した大域変数に格納されます。また、大域変数の値が変更されると、entry の内容も変更されます。面白いオプションが -show です。これはパスワードのように画面に見えてはいけない文字列を打ち込むときに使います。たとえば、-show "*" とすれば、入力された文字は * として表示されます。
</p>

<p> ウィジェットコマンドには cget, configure のほかに、文字列の取得、挿入、削除、カーソルの移動、カット &amp; ペースト、スクロールなど、たくさん用意されていますが、文字列の入力だけならば、それらを使う機会はあまりないでしょう。また、エントリーのキー操作は Emacs に準じているので、Emacs / Mule を使っているユーザーには扱いやすいと思います。
</p>

<h4>●式入力電卓の制作</h4>
<p> それではプログラムを作りましょう。データの入力が完了したらボタンを押してもらってもいいのですが、データはキーボードから入力するのですから、マウスよりもキーボードで操作したほうがいいでしょう。リターンキーの入力でデータを計算するようにします。キー入力もイベントのひとつですからバインディングを設定することができます。プログラムは次のようになります。
</p>
<pre class="list">
entry .e0 -textvariable buffer
pack .e0

bind .e0 &lt;Return&gt; {
    set buffer [expr $buffer]
}
</pre>
<p> 計算は expr を使えばいいので簡単ですね。といっても、Tcl の数学関数が使えるので、sin, cos, tan など関数電卓としても使うことができます。
</p>
<img src="img/11.gif" alt="電卓入力の画面"> 数式を入力する
<br>
<img src="img/12.gif" alt="計算結果の画面"> リターンキーで計算する

<h4>●イベント処理</h4>
<p>このプログラムのポイントは bind コマンドです。
</p>
<pre class="item">
bind ウィジェット名 イベント [+]コマンド
</pre>
<p> すでにバインドされているコマンドがある場合、新しいコマンドに差し替えられます。コマンドの前に + をつけると、既存のコマンドに新しいコマンドが追加されます。コマンドを省略すると、そのイベントにバインドされているコマンドが返されます。ウィジェット名だけを指定すると、そのウィジェットにバインドされているイベントが返されます。
</p>
<p> イベントの指定は次のような構文を持っています。
</p>
<pre class="item">
&lt;modifier-modifier-type-detail&gt;
</pre>
<p> type は GUI 環境上で発生するイベントタイプを表します。ユーザーが操作するときに発生する主なイベントタイプには次のようなものがあります。
</p>

<table border=1>
<thead>
  <tr><th>名前</th><th>イベント</th></tr>
</thead>
<tbody>
  <tr><td>Key, KeyPress       </td><td>キーが押された</td></tr>
  <tr><td>KeyRelease          </td><td>キーが離された</td></tr>
  <tr><td>Button, ButtonPress </td><td>マウスのボタンが押された</td></tr>
  <tr><td>ButtonRelease       </td><td>マウスのボタンが離された</td></tr>
  <tr><td>Motion              </td><td>マウスの移動</td></tr>
  <tr><td>Enter               </td><td>マウスカーソルがウィンドウの中に入った</td></tr>
  <tr><td>Leave               </td><td>マウスカーソルがウィンドウから出た</td></tr>
</tbody>
</table>

<p> このほかにも、ウィンドウが破棄された時に発生するイベントなど、さまざまなイベントタイプがあります。
</p>

<p> マウスとキーのイベントには、ボタンやキーの種類を detail で指定します。マウスでは左ボタンが 1 となります。キーの種類は名前 (Keysym) で指定します。英数字はその文字がそのまま名前となります。このほかに、改行キーに対する Return、バックスペースキーに対する BackSpace などがあります。
</p>

<p> detail を指定する場合は type を省略することができます。ただし、&lt;1&gt; という指定は &lt;KeyPress-1&gt; ではなく &lt;Button-1&gt; となるので注意してください。また、通常の英数字の場合、&lt; &gt; も省略することができます。つまり、&lt;KeyPress-a&gt; は a と書くことができます。それから、&lt;KeyPress&gt; のように detail を省略すると、種類によらずキーが押された時にバインドされたコマンドが実行されます。
</p>

<h4>●モディファイア</h4>
<p> イベントタイプの前にはモディファイア (modifier) をつけることができます。たとえば、&lt;Control-d&gt; はコントロールキーと d を同時に押したときのイベントを表します。主なモディファイアを次に示します。
</p>

<table border=1>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>Control     </td><td>Ctrl キーを押しながらの入力</td></tr>
  <tr><td>Shift       </td><td>Shift キーを押しながらの入力</td></tr>
  <tr><td>Alt         </td><td>Alt キーを押しながらの入力</td></tr>
  <tr><td>Button1, B1&nbsp;&nbsp; </td><td>マウスの左ボタンを押しながらの入力</td></tr>
  <tr><td>Button3, B3 </td><td>マウスの右ボタンを押しながらの入力</td></tr>
  <tr><td>Double      </td><td>ダブルクリック</td></tr>
  <tr><td>Triple      </td><td>トリプルクリック</td></tr>
</tbody>
</table>

<p> Tcl/Tk の出身地である X Window では 3 ボタンマウスを使うので、Button2 は右ボタンではなく中ボタンとなります。たとえば、左ボタンのダブルクリックに対応するイベントは &lt;Double-1&gt; となります。また、イベントタイプは複数個指定することができます。たとえば、&lt;Escape&gt;a はEsc キーが押されたあとでキー a を押したイベントに対応します。
</p>

<p> バインドされたコマンド内では、イベント情報を取得するための方法が用意されています。% から始まる文字列はイベント情報に置換されます。
</p>

<table border=1>
<thead>
  <tr><th>記号</th><th>イベント情報</th></tr>
</thead>
<tbody>
  <tr><td>%b    </td><td>マウスボタンの番号</td></tr>
  <tr><td>%x, %y</td><td>マウスカーソルの座標</td></tr>
  <tr><td>%W    </td><td>ウィンドウのパス名</td></tr>
  <tr><td>%A    </td><td>キーに対応する文字</td></tr>
  <tr><td>%K    </td><td>キーに対応する名前 (Keysym)</td></tr>
  <tr><td>%%    </td><td>% 自身を表す</td></tr>
</tbody>
</table>

<p> 置換の指定は 30 種類以上ありますので、詳細はヘルプを参照してください。たとえば、次のプログラムを wish のコンソール上から実行すると、キーに対応する名前を表示することができます。
</p>
<pre class="item">
bind . &lt;KeyPress&gt; {puts "Keysym is %K"}
</pre>
<p> 実際に試してみると、F1 や F2 キーには F1, F2 という名前が割り当てられていることがわかります。
</p>
<hr>
<h3 id="d14">リストボックスとスクロールバー</h3>
<p> 次は、リストボックスとスクロールバーというウィジェットを説明します。リストボックスは複数の文字列を表示し、ユーザーはその中からひとつ以上の文字列を選ぶことができます。スクロールバーは、ほかのウィジェットの表示範囲を制御します。例題として、calc.tcl で入力した計算式をリストボックスに格納しておいて、必要なときに取り出せるように改造してみましょう。最初にリストボックスから説明します。
</p>
<pre class="item">
listbox ウィジェット名 オプション
</pre>
<p> listbox で指定する主なオプションは、表示範囲のコントロールと選択方法です。
</p>

<table border=1>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>-xscrollcommand&nbsp;&nbsp;  </td><td>x 方向のスクロールコマンドを指定</td></tr>
  <tr><td>-yscrollcommand  </td><td>y 方向のスクロールコマンドを指定</td></tr>
  <tr><td>-selectmode      </td><td>セレクションモード</td></tr>
</tbody>
</table>
<p> スクロールコマンドは、リストボックスの表示範囲が変更されたときに呼び出されるコマンドです。たとえば、スクロールバーと連動させる場合、このコマンドはスクロールバーの位置を動かすウィジェットコマンド set が指定されます。これはコマンド scrollbar と一緒に説明します。セレクションには次のモードが用意されています。
</p>
<ul>
  <li><b>single</b><br>
ひとつの行をマウスの左クリックで選択する。
  <li><b>browse</b><br>
single と同じだが、ドラッグによって選択される行が変化し、ボタンを離したところの行が選択される。
  <li><b>multiple</b><br>
左クリックで複数行を選択する（ドラッグは不可）。
  <li><b>extended</b><br>
ドラッグで複数行を選択するが、左クリックでは今まで選択した行はキャンセルされ、クリックした行のみ選択される。Ctrl キーを押しながら左クリックするとトグル動作 (結果が反転) となり、シフトキーを押しながら左クリックすると直前に左クリックした行から現在の行までが選択される。
</ul>
<p> -selectmode のデフォルト値は browse です。データの挿入、削除、取得はウィジェットコマンドで行います。
</p>

<table border=1>
<thead>
  <tr><th>コマンド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>insert 位置 文字列 ...&nbsp;&nbsp;</td><td>指定した位置の直前に文字列を挿入</td></tr>
  <tr><td>delete first last       </td><td>指定した範囲の行を削除する</td></tr>
  <tr><td>get    first last       </td><td>指定した範囲の行をひとつの文字列として返す</td></tr>
  <tr><td>index  位置             </td><td>指定した位置の行番号を返す</td></tr>
  <tr><td>curselection            </td><td>選択された行番号をリストにして返す</td></tr>
  <tr><td>see    位置             </td><td>指定した位置が見えるようにスクロールする</td></tr>
</tbody>
</table>

<p> このほかにもいろいろなコマンドがありますが、特にスクロールバーに関係する xview / yview コマンドが重要です。これは、scroll コマンドのところで説明します。
</p>

<p>  位置の指定には次の方法があります。
</p>
<ul>
  <li><b>n (数値)</b><br>
n 行目
  <li><b>active</b><br>
左ボタンを離した時の行
  <li><b>anchor</b><br>
左ボタンを押した時の行
  <li><b>end</b><br>
最後の行、ただし、insert で指定すると最終行の次にデータが追加される
  <li><b>@x,y</b><br>
指定した座標に最も近い行
</ul>
<p> セレクションモードが extended のときにドラッグで選択した場合、最初の行が anchor で最後の行が active となります。したがって、delete に anchor と active を指定すると、選択した行をリストボックスから削除することになります。
</p>

<h4>●スクロールバー</h4>
<p> 次はスクロールバーを説明します。スクロールバーは、その両端に矢印がつき、中央付近には四角いスライダが表示されます。矢印を左クリックするか、スライダをドラッグすることで表示位置を変更します。また、矢印とスライダの隙間をクリックすると 1 画面分スクロールします。スクロールバーを作るコマンドは scrollbar です。
</p>
<pre class="item">
scrollbar ウィジェット名 オプション
</pre>
<p>scrollbar で主に使用されるオプションには次のものがあります。
</p>
<table border=1>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>-orient</td><td>スクロールバーの方向</td></tr>
  <tr><td>-troughcolor&nbsp;&nbsp;</td><td>矢印とスクロールの隙間の色</td></tr>
  <tr><td>-command</td><td>スクロールバーが動いたときに実行するコマンド</td></tr>
</tbody>
</table>

<p> -orient はスケールと同じくスクロールバーの方向を指定するもので、horizontal または h を指定すると水平になり、vertical または v で垂直になります。-command はスクロールバーを動かしたときに実行するコマンドを指定します。リストボックスとスクロールバーを連動させる場合、このコマンドはリストボックスの表示位置を制御するコマンド xview や yview が指定されます。
</p>

<h4>● set コマンド</h4>
<p> スクロールバーで重要なウィジェットコマンドは set です。
</p>
<pre class="item">
set first last    スライダの位置を指定する
</pre>
<p> set の引数 first と last は 0 から 1 の間の実数で、表示されている範囲を表しています。たとえばリストボックスと連動している場合、全体の行数が 100 行で 20 行目から 30 行分表示されているとすると、set 0.2 0.5 となります。つまり、データ全体の 20 % の位置から 50 % の位置まで表示されていることを表します。スクロールバーではこのデータからスライダの位置と大きさを調整します。
</p>

<p> set はリストボックスのオプション -xscrollcommand や -yscrollcommand で指定します。スクロールバーのウィジェット名を .s とすると、指定方法は次のようになります。
</p>
<pre class="list">
-xscrollcommand ".s set"
</pre>
<p> リストボックスで表示範囲が変更されるとスクロールコマンドが実行されますが、このとき、リストボックスの表示範囲が引数として付け加えられ、コマンドが実行されます。
</p>

<p> set はリストボックスの変更をスクロールバーに反映させるために使いましたが、スクロールバーの変更をリストボックスに反映させるためのオプションが -command です。ここにリストボックスのウィジェットコマンド xview や yview を指定します。指定方法は簡単で、リストボックスのウィジェット名を .lb とすると次のようになります。
</p>
<pre class="list">
listbox .lb -yscrollcommand ".s set"
scrollbar -orient v -command ".lb yview"
</pre>
<p> スクロールバーの操作によって、次に示す文字列が付け加えられてコマンドが実行されます。
</p>
<ul>
  <li><b>moveto 数値</b><br>
指定した数値 (0 - 1.0) の位置までスクロール
  <li><b>scroll [+|-]1 unit</b><br>
上または下に１単位スクロールする
  <li><b>scroll [+|-]1 pages</b><br>
上または下に１ページスクロールする
</ul>
<p> まあ、付け加えられるデータを無理に覚える必要はありません。スクロールバーを使うときは、連動するウィジェットのスクロールオプションに set を指定して、スクロールバーの -command に表示を制御するウィジェットコマンドを指定する、と理解しておけば十分でしょう。
</p>

<h4>●電卓の改造</h4>
<p> それでは、calc.tcl を改造しましょう。まず必要なウィジェットを生成します (リスト 9)。
</p>

<pre class="list">
リスト 9 : ウィジェットの追加

entry .e0 -textvariable buffer
listbox .lb -yscrollcommand ".s1 set" -xscrollcommand ".s2 set"
scrollbar .s1 -orient vertical -command ".lb yview"
scrollbar .s2 -orient horizontal -command ".lb xview"
grid .e0 -row 0 -column 0 -columnspan 2 -sticky ew
grid .lb -row 1 -column 0 -sticky nsew
grid .s1 -row 1 -column 1 -sticky ns
grid .s2 -row 2 -column 0 -sticky ew
</pre>

<p> リストボックスとスクロールバーは grid で配置します。grid は格子状にウィジェットを配置するジオメトリマネージャです。ウィンドウを M 行 N 列のセルに分割し、そこにウィジェットを配置するのです。x 方向の位置はオプション -column で指定し、y 方向の位置は -row で指定します。grid には pack とは違うオプション -columnspan と -rowspan があります。これは、複数のセルにまたがってウィジェットを配置するために使います。-columnspan は x 方向にまたがるセルの数、-rowspan は y 方向にまたがるセルの数を指定します。それから、pack ではオプション -fill でウィジェットを引き伸ばすことができましたが、grid ではオプション -sticky を使います。
</p>

<table border=1>
<tr><td>{ } &nbsp;&nbsp</td><td>上下左右とも中央寄せ</td></tr>
<tr><td>n     </td><td>上寄せ</td></tr>
<tr><td>s     </td><td>下寄せ</td></tr>
<tr><td>e     </td><td>右寄せ</td></tr>
<tr><td>w     </td><td>左寄せ</td></tr>
<tr><td>ns    </td><td>上下方向に引き伸ばす</td></tr>
<tr><td>ew    </td><td>左右方向に引き伸ばす</td></tr>
</table>

<p> -sticky は pack のオプション -anchor と同じ機能もあわせ持っています。
</p>
<p> エントリーはいちばん上に配置しますが、-columnspan で x 方向にセルをつなげて、-sticky ew で左右に広げています。
</p>

<h4>●バインディングの設定</h4>
<p> 次はバインディングを設定します。リストボックスからデータを選ぶ処理ですが、ダブルクリックしてもらうことにします (リスト 10)。
</p>

<pre class="list">
リスト 10 : データの選択

bind .e0 &ltReturn&gt; {
    .lb insert end $buffer
    .lb see end
    set buffer [expr $buffer]
}

bind .lb &lt;Double-1&gt; {
    set buffer [.lb get active]
}
</pre>

<p> エントリーではリターンキーが入力されたら、データをリストボックスに代入し、expr の計算結果を buffer にセットします。これが逆になると、答えをリストボックスに代入することになります。それから、ウィジェットコマンド see を使って、セットした計算式が見えるようにスクロールしています。
</p>
<p> リストボックスでは、ダブルクリックされた位置から get でデータを取り出して buffer にセットします。ダブルクリックですから位置は active と anchor どちらでもかまいません。
</p>

<IMG SRC="img/13.gif" ALT="履歴が残る電卓">  式の履歴が残るように改造した電卓
<hr>
<h3 id="d15">イメージ</h3>
<p> 今度は画像の取り扱いについて説明しましょう。以前の Tk では、白黒のビットマップしか扱えませんでしたが、ver 4.0 以降の Tk では標準でカラーイメージをサポートし、GIF や PPM / PGM 形式の画像ファイルを扱うことができるようになりました。PPM はカラー、PGM はグレイスケールの画像を扱う、UNIX で標準的に用いられるベタフォーマットです。
</p>

<p> Tk では、コマンド image でイメージを作り出し、そのイメージをラベルやボタンなどのウィジェットに使うことができます。たとえば、画像ファイルからイメージを作るには、次のように行います。
</p>
<pre class="item">
image create photo 名前 -file ファイル名
</pre>
<p> create はイメージの生成、photo はイメージの種別でカラーを意味します。名前は生成したイメージを表します。省略した場合は適当な名前がつけられ、その名前が image の返り値となります。image は create 以外にも次の操作を行うことができます。
</p>

<table border=1>
<thead>
  <tr><th>コマンド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>image delete 名前 </td><td>イメージを削除する</td></tr>
  <tr><td>image types       </td><td>指定可能な種別のリストを返す</td></tr>
  <tr><td>image names       </td><td>全イメージの名前をリストにして返す</td></tr>
  <tr><td>image type 名前   </td><td>イメージの種別を返す</td></tr>
  <tr><td>image height 名前 </td><td>イメージの高さを返す</td></tr>
  <tr><td>image weight 名前 </td><td>イメージの幅を返す</td></tr>
</tbody>
</table>

<p> ラベルやボタンにイメージを表示するには -image オプションを使います。
</p>
<pre class="item">
label .l0 -image 名前
</pre>
<p> これでラベルにイメージが表示されます。それでは簡単な例題として、GIF / PPM の画像を表示するプログラムを作ります。このようなアプリケーションの場合、ファイルの指定方法が GUI らしくないとボロクソにいわれるものですが、幸いなことに Tk にはファイルを選択するためのコマンドが用意されています。
</p>
<pre class="item">
tk_getOpenFile  入力ファイルを選択
tk_getSaveFile  出力ファイルを選択
</pre>
<p> これらのコマンドを実行すると、ファイル選択のウィンドウ (ダイアログ) が開かれ、ウィンドウ上の操作でディレクトリをたどり、ファイルを選ぶことができます。使用できるオプションは次の通りです。
</p>
<ul>
  <li><b> -initialdir ディレクトリ </b><br>
最初に選択されているディレクトリ
  <li><b> -initialfile ファイル</b><br>
最初に選択されているファイル（出力ファイルのみ有効）
  <li><b>-defaultextension 拡張子</b><br>
最初に選択されている拡張子
  <li><b>-filetypes パターンリスト</b><br>
使用可能なファイル種別と拡張子のリストを指定
  <li><b>-parent ウィンドウ</b><br>
ダイアログボックスの親ウィンドウを指定
  <li><b>-title 文字列</b><br>
ダイアログボックスのタイトル
</ul>
<p> このなかで重要なオプションが -filetypes です。アプリケーションで扱うことができるファイル種別を拡張子で指定し、そのファイルだけを表示します。指定はリストで行います。
</p>
<pre class="item">
-filetypes { ファイル種別 ... }
ファイル種別 := {{名前} {拡張子 ... }
</pre>
<p> たとえば、GIF / PPM ファイルを指定する場合は、次のようになります。
</p>
<pre class="list">
-filetypes {
  {{画像Files} {.gif .ppm}}
}
</pre>
<p> この場合は GIF と PPM ファイルが一緒に表示されます。次のように指定すると、表示するファイルをダイアログの操作で切り替えることができます。
</p>
<pre class="list">
-filetypes {
  {{GIF Files} {.gif}}
  {{PPM Files} {.ppm}}
  {{ALL Files} {*}}
}
</pre>
<p> すべてのファイルを表示する場合は * を使います。また、空文字列 "" を指定すると、拡張子のないファイルを表示します。ファイルを選択すると、ファイル名をフルパス形式で返します。選択しない (キャンセル) 場合は、空文字列が返されます。
</p>

<h4>●GIF/PPM ローダーの制作</h4>
<p>  それでは、GIF / PPM 画像ローダーを作りましょう。まず、メニューから設定します (リスト 11)。
</p>

<pre class="list">
リスト 11 : 画像ローダ用メニュー

menu .m -type menubar
. configure -menu .m
.m add cascade -label "File" -under 0 -menu .m.m1
menu .m.m1 -tearoff no
.m.m1 add command -label "Open" -under 0 -command "load_file"
.m.m1 add separator
.m.m1 add command -label "Exit" -under 0 -command "exit"
</pre>

<p> メニュー File の下に、ファイルを選択する Open とアプリケーションを終了する Exit の 2 つのメニューを設定します。次に、イメージとグローバル変数を定義します (リスト 12)。
</p>

<pre class="list">
リスト 12 : グローバル変数の定義

set path_name ""
image create photo image_data -width 64 -height 64
label .l0 -image image_data
pack .l0
</pre>

<p> path_name は選択されたファイルのパスを格納しておきます。tk_getOpenFile にこのパスを指定することで、次にファイルを選ぶときは同じディレクトリから始めることができます。アプリケーションの開始時にはファイルは指定されていないので、空のイメージを作って表示しておきます。あとは、画像ファイルをロードする本体を作ります (リスト 13)。
</p>

<pre class="list">
リスト 13 : ローダ本体

proc load_file {} {
    global image_data path_name
    set filename [tk_getOpenFile -initialdir $path_name \
                                 -filetypes {{{画像Files} {.gif .ppm}}}]
    if {$filename != ""} {
        set path_name [file dirname $filename]
        image delete image_data
        image create photo image_data -file $filename
        .l0 configure -image image_data
    }
}
</pre>

<p> tk_getOpenFile でファイル名を取得したら、パスを取り出して path_name にセットします。file はファイル情報を取得する Tcl のコマンドです。file dirname はファイル名からパス部分を返します。tail を指定するとパス部分を取り除いたファイル本体の名前を返します。このほかにも、ファイルの種別や時刻などさまざまな情報を得ることができますが、詳細はヘルプを参照してください。
</p>

<p> ファイル名をゲットしたら、それが空文字列でないことを確認します。次に、表示しているイメージを image delete で削除してから、新しいイメージを image create で生成します。最後に、ラベルの configure で表示するイメージを変更します。とても簡単ですね。
</p>

<img src="img/14.gif" alt="ファイル選択ダイアログ"> 表示する GIF ファイルの選択
</p>

<p> ところで、イメージを生成するには、ファイルからロードするだけではありません。イメージを直接操作することができます。いろいろなコマンドが用意されていますが、入門編では説明を割愛させていただきます。興味のある方は参考文献やヘルプをあたってみてください。
</p>

<div align="right">
<cite>＜ Oh!X 1999 春号 (ソフトバンク) pp.105 - 110 から転載 ＞</cite>
</div>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 1999-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="tcltk102.html">PrevPage</a> | <a href="tcltk_doc.html">Tcl/Tk GUI Programming</a> | <a href="tcltk104.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>