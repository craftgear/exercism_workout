<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Tcl/Tk お気楽 GUI プログラミング応用編</title>
  <meta name="description" content="Tcl/Tk,GUI,プログラミング,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881832</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Tcl/Tk GUI Programming</h1>
<h2>Tcl/Tk お気楽 GUI プログラミング応用編</h2>
<div class="small">
[ PrevPage | <a href="tcltk_doc.html">Tcl/Tk GUI Programming</a> | <a href="tcltk202.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chapter1">トップレベルのウィンドウ</h3>
<h4>●コマンド toplevel</h4>
<p> Tcl/Tk は wish (WIndow SHell) が用意するメインウィンドウのほかにも、複数のウィンドウを操作することができます。新しくウィンドウを作るにはコマンド toplevel を使います。
</p>
<pre class="item">
toplevel ウィジェット名
</pre>
<p> toplevel 独自のオプションはそれほど多くありません。よく使うオプションがメニューを設定する -menu です。新しいウィンドウは、メインウィンドウから生成されるので、ウィジェット名はピリオド ( . ) から始まることに注意してください。
</p>

<p> それでは簡単な例題として、アプリケーションの情報 (バージョンや作者名など) を表示するためのウィンドウを作ってみます。メインウィンドウのメニュー About が選択されたら表示することにしましょう。まず、メインウィンドウとメニューを設定します。
</p>

<pre class="list">
リスト : メインウィンドウとメニュー

# フォントの設定
option add *font {FixedSys 14}

# メニューの設定
menu .m -type menubar
. configure -menu .m
.m add command -label "About" -under 0 -command message_window

# メインウィンドウ
label .l -text "メニュー About を選んでね"
pack .l
</pre>

<p> ここまでは、入門編で説明したことと同じなので簡単ですね。ウィンドウの生成は、プロシージャ message_window で行います。プログラムは次のようになります。
</p>

<pre class="list">
リスト : ウィンドウの生成

proc message_window {} {
    toplevel .t0
    message .t0.msg \
            -text "toplevel と message のサンプルプログラムです"
    pack .t0.msg
}
</pre>

<p> 最初に toplevel で新しいウィンドウ .t0 を作成します。次に、コマンド message でメッセージウィジェットを作りテキストを表示します。ウィジェット名は、ウィンドウ .t0 の中に配置するので .t0.msg となります。メッセージウィジェットはラベルと違い、複数行の文字列を表示することができます。デフォルトでは、縦と横の比率が 150 % になるように、文字列を表示する領域を調整します。この例では、-text で指定した文字列は 4 行に渡って表示されます。この比率を指定するオプションが -aspect です。
</p>
<ul>
  <li><b>-aspect</b><br>
文字列を表示する領域の縦横比、100 より大きいと横長で、デフォルトは 150。
  <li><b>-justify</b><br>
文字列の揃えを指定。center (中央寄せ)、right (右寄せ)、left (左寄せ) が指定できる。
</ul>
<p> -aspect は -width よりも優先順位が低いので、-width の値が優先されます。メッセージウィジェットの場合、-width の値は文字数ではなくドット数になるので注意してください。
</p>

<p> これでプログラムは完成です。たったこれだけで、メニュー About をクリックするとウィンドウが表示されます。
</p>

<img src="img/top0.png" alt="メインウィンドウ"> メインウィンドウ
<br>
<img src="img/top1.png" alt="サブウィンドウ"> About をクリックしてサブウィンドウを表示

<p> ところが、このままでは都合の悪いことがあるのです。このウィンドウを表示したまま、もう一度 About をクリックしてみてください。エラーが発生するはずです。これはウィジェット .t0 が存在しているのに、同じウィジェットを再度作成しようとしたためエラーとなるのです。このように、同じ名前のウィジェットを複数作ることはできません。それから、ウィンドウに表示されるタイトルが .t0 になっていますね。きちんとしたタイトルをつけた方が良いでしょう。
</p>

<h4>●ウィンドウの状態を調べる</h4>
<p> ウィンドウの状態を調べるにはコマンド winfo を使います。ウィンドウの状態を調べるサブコマンドの一部を表に示します。winfo には 40 以上のサブコマンドがあるので、詳細はヘルプを参照してください。
</p>

<table border=1>
<caption>表：winfo のサブコマンド (一部)</caption>
<thead>
  <tr><th>コマンド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>winfo geometry window</td><td>ウィンドウの位置を文字列 (幅x高さ+x+y) で返す</td></tr>
  <tr><td>winfo width window</td><td>ウィンドウの幅を返す</td></tr>
  <tr><td>winfo height wondow</td><td>ウィンドウの高さを返す</td></tr>
  <tr><td>winfo x window</td><td>親ウィンドウ内での x 座標を返す</td></tr>
  <tr><td>winfo y window</td><td>親ウィンドウ内での y 座標を返す</td></tr>
  <tr><td>winfo rootx window</td><td>ディスプレイ上での x 座標を返す</td></tr>
  <tr><td>winfo rooty window</td><td>ディスプレイ上での y 座標を返す</td></tr>
  <tr><td>winfo exists window</td><td>ウィンドウが存在するか </td></tr>
</tbody>
</table>

<p> 引数の window にはウィジェットを指定することができます。サブコマンド geometry でウィジェットを指定した場合、返される座標はディスプレイを基準にした座標ではなく、そのウィジェットが配置されたウィンドウを基準にした座標となります。また、winfo x/y でメインウィンドウを指定すると、ディスプレイ上での座標を返します。
</p>
<p> このプログラムで必要になる、ウィンドウの存在を調べるコマンドは winfo exists です。たとえば、ウィンドウ .t0 を調べるには、winfo exists .t0 とすればいいわけです。.t0 が開いていれば 1 を、そうでなければ 0 を返します。
</p>

<h4>●ウィンドウの設定</h4>
<p> ウィンドウの設定はコマンド wm (Window Manager) で行います。このコマンドもたくさんのサブコマンドがあるので、こちらもヘルプを参照してください。ウィンドウの状態を設定するサブコマンドの一部を表に示します。
</p>

<table border=1>
<caption>表：wm のサブコマンド (一部)</caption>
<thead>
  <tr><th>コマンド</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>wm withdraw window</td><td>ウィンドウを画面から取り除く</td></tr>
  <tr><td>wm deiconify window</td><td>ウィンドウを見える状態に戻す</td></tr>
  <tr><td>wm iconify window</td><td>ウィンドウをアイコン化する</td></tr>
  <tr><td>wm state window</td><td>ウィンドウの状態を返す (状態は normal, withdrawn, iconic)</td></tr>
  <tr><td>wm geometry window string</td><td>ウィンドウを表示する位置を文字列で (幅x高さ+x+y) で指定する</td></tr>
  <tr><td>wm maxsize window 幅 高さ</td><td>ウィンドウの最大値を指定</td></tr>
  <tr><td>wm minsize window 幅 高さ</td><td>ウィンドウの最小値を指定</td></tr>
  <tr><td>wm resizable window 真/偽 真/偽</td><td>幅と高さの変更を許すか</td></tr>
  <tr><td>wm title window タイトル名</td><td>ウィンドウのタイトルを指定</td></tr>
</tbody>
</table>

<p> タイトルを設定するにはコマンド wm title を使います。ウィンドウ .t0 にタイトルをつけるには、wm title .t0 "タイトル" とすればいいわけです。
</p>

<h4>●プログラムの改良</h4>
<p> それでは wm と winfo を使ってプログラムを改良してみましょう。
</p>

<pre class="list">
リスト : ウィンドウの生成 (改良版)

proc message_window {} {
    if {![winfo exists .t0]} {
        toplevel .t0
        wm title .t0 "About"
        message .t0.msg -width 100 \
                -text "toplevel と message のサンプルプログラムです"
        pack .t0.msg
    }
}
</pre>

<p> まず winfo exists でウィンドウ .t0 が開いているかチェックします。まだ開いていないのであれば、toplevel で .t0 を生成します。次に、wm title でタイトルを設定します。Tcl/Tk 8.2 以前のバージョンでは、タイトルに全角文字を使うと文字化けすることがあるので注意してください。あとは今までと同じです。実際にプログラムを実行すると、ウィンドウが開いた状態でメニュー about をクリックしても、エラーは発生しません。
</p>

<img src="img/top2.png" alt="サブウィンドウ"> サブウィンドウ（改良版）
<hr>
<h3 id="chapter2">ダイアログ</h3>
<h4>●メッセージボックス</h4>
<p> ところで、短いテキストを表示するだけならば、もっと簡単な方法があります。それは「メッセージボックス」というダイアログを使うことです。
</p>
<p>  GUI アプリケーションの場合、ボタンを押すとかメニューを選ぶといった操作は、基本的にはユーザーが自由に行うことができます。ところが、ある操作をしないと次の処理に進めない場合があります。たとえば、画像を表示する場合、表示するファイル名をユーザーから入力してもらわないと、画像ファイルを表示することはできませんね。このようなときは、必要な操作を行ってもらうようにユーザーを誘導した方がよいでしょう。このときによく使われるのが <b>ダイアログ</b> です。
</p>

<p> ダイアログは重要なメッセージを表示するために開かれるウィンドウで、画面の前面に表示され、ユーザーがダイアログに応答しないかぎり、そのアプリケーションではほかの操作を行うことはできません。ダイアログは、ユーザーに特定の操作を強制したい場合には便利ですが、その反面、操作の自由度は減少します。使いすぎるとユーザーの不満が溜まることになるので注意してください。
</p>

<p> メッセージボックスを表示するには、コマンド tk_messageBox を使います。このコマンドにはウィジェット名を指定する必要はありません。メッセージを表示してボタンが押されるのを待つだけです。指定できるオプションを表に示します。
</p>
<table border=1>
<caption>表：tk_messageBox のオプション</caption>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>-type</td><td>
    <table>
    <caption>種別 (ボタン構成の選択)</caption>
    <tbody>
      <tr><td>ok</td><td>OK ボタン</td></tr>
      <tr><td>okcancel</td><td>OK, キャンセルボタン</td></tr>
      <tr><td>yesno</td><td>はい、いいえボタン</td></tr>
      <tr><td>yesnocancel</td><td>はい、いいえ、キャンセルボタン</td></tr>
      <tr><td>retrycancel</td><td>再試行、キャンセルボタン</td></tr>
      <tr><td>abortretryignore</td><td>中止、再試行、無視ボタン</td></tr>
    </tbody>
    </table>
  </td></tr>
  <tr><td>-message</td><td>ダイアログに表示する文字列</td></tr>
  <tr><td>-icon</td><td>ダイアログに表示するアイコン<br>(error, info, question, warning のいずれかを指定)</td></tr>
  <tr><td>-default</td><td>デフォルトボタンの名前を指定</td></tr>
  <tr><td>-title</td><td>ダイアログのタイトルを指定</td></tr>
  <tr><td>-parent</td><td>ダイアログを表示するウィンドウを指定</td></tr>
</tbody>
</table>

<p> tk_messageBox は押されたボタンの種類を文字列で返します。たとえば、種別に yesno を指定した場合、「はい」のボタンを押せば yes という文字列を返します。メッセージを表示するだけであれば、-type には ok を、-icon には info を指定すればいいでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : tk_messageBox のサンプル

# メッセージボックス
proc message_window {} {
    tk_messageBox -type ok -icon info -title "About" \
      -message "tk_messageBox のサンプルプログラムです"
}

# フォントの設定
option add *font {FixedSys 14}

# メニューの設定
menu .m -type menubar
. configure -menu .m
.m add command -label "About" -under 0 -command message_window

# メインウィンドウ
label .l -text "メニュー About を選んでね"
pack .l
</pre>

<p> メッセージウィジェットと違い、文字列はそのまま表示されます。文字列中に改行文字を含めれば、複数行に渡って表示することができます。ほかの種別のメッセージボックスは、Widget Tour のデモプログラムを参考にしてください。
</p>

<img src="img/dialog0.png" alt="メッセージボックス"> メッセージボックスの画像

<h4>●ダイアログの作成</h4>
<p> このほかにも、ダイアログを作成するコマンド tk_dialog が用意されています。
</p>
<pre class="item">
tk_dialog ウィジェット名 title message bitmap 番号 文字列 ...
</pre>
<p> tk_dialog の場合、同じ名前のウィジェットがあると、それを削除するので注意してください。title、message、bitmap は、ダイアログに表示するタイトル、メッセージ、ビットマップを指定します。空文字列を指定すると表示されません。それから bitmap にイメージを指定することはできません。
</p>
<p> ボタンの設定は番号と文字列で行います。文字列はボタンにつけるラベルで、いくつでも指定することができます。番号はデフォルトのボタンを指定します。ボタンの順番は、リストと同様に 0 から数えます。押したボタンの種類は、名前ではなく番号で返されます。
</p>

<p> それでは、tk_dialog を使ってメッセージを表示してみましょう。
</p>

<pre class="list">
リスト : tk_dialog のサンプル

# tk_dialog
proc message_window {} {
    tk_dialog .d0 "Message" \
                  "tk_dialog のサンプルプログラムです" \
                  "" 0 OK
}

# ・・・ 以下省略 ・・・
</pre>

<p> この例ではビットマップを表示していません。tk_messageBox のように、決められたビットマップでは都合が悪い場合は、tk_dialog を使うといいでしょう。
</p>

<img src="img/dialog1.png" alt="tk_dialog"> tk_dialog の画像
<hr>
<h3 id="chapter3">独自のダイアログを作る</h3>
<p> Tcl/Tk では、コマンド tk_messageBox や tk_dialog を使って、メッセージを表示するダイアログを簡単に作成することができます。また、入門編で説明したように、ファイル名の入力であれば tk_getOpenFile や tk_getSaveFile を利用することができます。しかしながら、これだけではほかの操作、たとえばキーボードからデータが入力されるのを待つ、といった処理には対応できません。この場合、自前のダイアログを作成することになりますが、このときに使うコマンドが grab と tkwait です。
</p>

<h4>●grab と tkwait</h4>
<p> グラブ (grab) はマウスやキーボードからの入力を、特定のアプリケーションやウィンドウにだけ割り当てる働きをします。
</p>
<ul>
  <li><b>grab set [-global] ウィンドウ</b><br>
指定したウィンドウにグラブをセットする。-global を指定すると大域グラブとなり、グラブをセットしたアプリケーションしか操作できない。デフォルトでは局所グラブとなり、グラブを実行したアプリケーションだけにしか影響しない。
  <li><b>grab release ウィンドウ</b><br>
ウィンドウにグラブがセットされていれば、それを解除する。
  <li><b>grab current [ウィンドウ]</b><br>
グラブが設定されているウィンドウを返す。
  <li><b>grab status ウィンドウ</b><br>
ウィンドウにグラブがセットされていなければ none を返す。局所グラブの場合は local を、大域グラブの場合は global を返す。
</ul>

<p> グラブを設定したウィンドウが廃棄されると、グラブは自動的に解除されます。<a href="tcltk_doc.html#cite">参考文献 [1]</a> には、次のように書かれています。
</p>
<blockquote>
<cite>大域グラブは解除を忘れると画面全体がロックする恐れがあるので使用しない方がよい。</cite>
</blockquote>
<p> ただし、M.Hiroi が使用している Windows 版 Tcl/Tk 8.2 では、大域グラブを設定してもほかのアプリケーションの操作は可能でした。このため、M.Hiroi が作成したプログラムの中には、気楽に大域グラブを設定しているものがありますが、ほかの環境では不具合の原因になるかもしれません。大域グラブは慎重に扱ってください。
</p>

<p> tkwait は待ち合わせのためのコマンドです。次に示すように 3 つの形式があります。
</p>
<ul>
  <li><b>tkwait window ウィンドウ</b><br>
指定したウィンドウが廃棄 (destory) されるまで待つ
  <li><b>tkwait visibility ウィンドウ</b><br>
指定したウィンドウの可視・不可視の状態が変化するまで待つ
  <li><b>tkwait variable 変数名</b><br>
指定した大域変数に書き込みが行われるまで待つ
</ul>
<p> このほかに、tkwait variable と同じ働きをするコマンド vwait があります。こちらは Tcl のコマンドなので、tclsh でも利用することができます。
</p>

<p> grab と tkwait を組み合わせることで、ユーザーがデータを入力するまで待つ、といった処理を作ることができます。簡単な例題を示しましょう。ボタンを押したら名前を入力するウィンドウを開くプログラムを作ります。これにはふたつの方法があります。ひとつは、ウィンドウを作っては壊す方法で、もうひとつは、あらかじめウィンドウを作っておいて、表示しては隠す方法です。このふたつの方法でプログラムを作ってみましょう。
</p>

<h4>●ウィンドウを壊す方法</h4>
<p>  最初に、作っては壊す方法でプログラムを作ります。
</p>

<pre class="list">
リスト : ウィンドウを壊す方式 (1)

# フォントの設定
option add *font {FixedSys 14}

# 画面の設定
set message "ボタンを押すと入力ウィンドウが開きます"
button .b -text "InputName" -command "input_name"
label .l -textvariable message
pack .b .l

# 名前を入力する
proc input_name {} {
    global buffer message
    input_window .t0
    tkwait window .t0
    set message [format "入力された名前は %s です" $buffer]
}
</pre>

<p> まずボタンとラベルを配置します。ボタンが押されたら input_name を実行して、名前入力用のウィンドウを開きます。input_name はウィンドウを開いたら、そのウインドウが廃棄されるまで tkwait で待機します。input_window は、入力された名前を大域変数 buffer にセットします。あとは、入力された名前を buffer から取り出して、ラベル表示用の変数 message にセットするだけです。
</p>

<pre class="list">
リスト : ウィンドウを壊す方式 (2)

# 名前入力ウィンドウ
proc input_window {win} {
    global buffer
    set buffer ""
    toplevel $win
    wm title $win "Input Your Name"
    wm geometry $win "+[expr [winfo x .] + 10]+[expr [winfo y .] + 10]"
    label $win.l0 -text "名前を入力してね"
    entry $win.e0 -textvariable buffer
    focus -force $win.e0
    grab set $win
    bind $win.e0 &lt;Return&gt; "destroy $win"
    pack $win.l0 $win.e0
}
</pre>

<p> input_window は作成するウィンドウ名を受け取り、名前が入力されらウィンドウを廃棄します。名前の入力はエントリーウィジェットを使うと簡単です。入力用バッファとして大域変数 buffer を設定します。ウィンドウを開く位置は、メインウィンドウの近くがいいでしょう。
</p>
<p> コマンド winfo でメインウィンドウの位置を求め、作成するウィンドウの位置をコマンド wm geometry で設定します。このプログラムではウィンドウの位置を指定するだけなので、幅と高さは省略しています。また、メインウィンドウの位置を求めているので、winfo x / y の返す座標はディスプレイを基準にしていることに注意してください。
</p>

<p> あとは、入力フォーカスとグラブをセットします。一般の GUI アプリケーションでは、キー入力はアクティブになっているウィンドウに渡されます。Tcl/Tk では、これをフォーカスウィンドウ (focus window) といいます。フォーカスウィンドウは、マウスの操作によって変更することができますが、コマンド focus によって設定することもできます。
</p>
<pre class="item">
focus        [ウィジェット名]
focus -force  ウィジェット名
</pre>
<p> focus はフォーカスウィンドウを指定したウィジェットに設定します。ウィジェット名が省略された場合は、フォーカスウィンドウが設定されているウィジェット名を返します。オプション -force を指定した場合は、フォーカスウィンドウを強制的にウィジェットに設定します。このオプションを使うと、ほかのアプリケーションがアクティブになっている場合でも、指定したウィンドウがアクティブになります。このプログラムでは、エントリウィジェットに入力フォーカスを設定します。
</p>

<p> リターンキーが入力されたならば、データ入力終了とみなしてウィンドウを destroy で廃棄します。この処理は、エントリーのリターンキーにバインドすればいいですね。これでプログラムは完成です。
</p>

<img src="img/dialog2.png" alt="メインウィンドウ"> メインウィンドウ
<br>
<img src="img/dialog3.png" alt="ダイアログ"> 名前を入力するダイアログ

<h4>●ウィンドウを隠す方法</h4>
<p> 今度は、表示して隠す方式で作ってみましょう。ウィンドウを作ったらコマンド wm withdraw でウィンドウを隠しておきます。そして、ボタンが押されたら wm deiconify でウィンドウを表示し、名前の入力が終わったならば、wm withdraw でウィンドウを隠します。<p> ところで、ウィンドウを隠す方法では問題点がひとつあります。それは、名前を入力するウィンドウで、右上隅の閉じるボタンを押したときの処理です。通常の動作では、このボタンが押されるとウィンドウが廃棄されるのですが、それでは困ってしまいますね。
</p>
<p> Tcl/Tk の場合、重要なイベントが起こった、もしくはこれから起こるというときには、そのイベントをアプリケーションに知らせる仕組みが用意されています。これを「ウィンドウマネージャープロトコル」と呼びます。ウィンドウが廃棄されるときは WM_DELETE_WINDOW というプロトコルが通知されます。アプリケーション側ではコマンド wm protocol を使って、このプロトコルが通知されたときの動作を設定することができます。
</p>
<pre class="item">
wm protocol ウィンドウ プロトコル スクリプト
</pre>
<p> WM_DELETE_WINDOW のデフォルトの動作がウィンドウを廃棄することです。このプロトコルに新しい動作を定義することで、閉じるボタンが押されてもウィンドウを廃棄せずに隠すことができます。
</p>
<p> 今回は、名前の入力が終了したら大域変数 flag に 1 をセットすることにします。名前入力用ウィンドウを表示したら、tkwait variable で flag に値が書き込まれるのを待ちます。また、WM_DELETE_WINDOW が通知された場合も入力終了とみなして、flag に 1 をセットすればいいでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : ウィンドウを隠す方式

# ウィンドウを作る
proc make_window {win} {
    global buffer
    toplevel $win
    wm title $win "Input Your Name"
    label $win.l0 -text "名前を入力してね"
    entry $win.e0 -textvariable buffer
    bind $win.e0 &lt;Return&gt; "set flag 1"
    bind $win.e0 &lt;Map&gt;    "focus -force $win.e0"
    pack $win.l0 $win.e0
    wm protocol $win WM_DELETE_WINDOW "set flag 1"
    wm withdraw $win
}
</pre>

<p> エントリーウィジェットで Return が入力されたら flag に 1 をセットします。この flag は大域変数として扱われることに注意してください。バインドされたスクリプト "set flag 1" は、プロシージャ make_window 内で実行されるのではないからです。つまり、バインドを設定するときとスクリプトを実行するときとでは、アクセスできる局所変数が異なっているのです。
</p>
<p> たとえば、make_window で有効な局所変数である win は、スクリプトを実行するときには make_window を実行していたときの値ではなく、大域変数として扱われます。次行のバインドでは win を使っていますが、この場合は変数展開が行われるため問題はありません。
</p>
<p> もうひとつ、エントリーにバインドを定義しています。ウィンドウが見える状態になったら、エントリーにフォーカスを設定します。ウィジェットが見える状態になると発生するイベントが Map です。逆に、見えなくなると発生するイベントが Unmap です。よく使われるイベントを表に示します。
</p>
<table border=1>
<caption>表：一般的なイベントの種類</caption>
<thead>
  <tr><th>イベント</th><th>種類</th></tr>
</thead>
<tbody>
  <tr><td>ButtonPress (Button)</td><td>マウスボタンが押されたときに発生</td></tr>
  <tr><td>ButtonRelease</td><td>マウスボタンが離されたときに発生</td></tr>
  <tr><td>KeyPress (Key)</td><td>キーが押されたときに発生</td></tr>
  <tr><td>KeyRelease</td><td>キーが離されたときに発生</td></tr>
  <tr><td>Motion</td><td>ウィジェット上でマウスが移動したときに発生</td></tr>
  <tr><td>Enter</td><td>マウスがウィジェットの内に入ったときに発生</td></tr>
  <tr><td>Leave</td><td>マウスがウィジェットの外に出たときに発生</td></tr>
  <tr><td>FocusIn</td><td>ウィジェットが入力フォーカスを得たときに発生</td></tr>
  <tr><td>FocusOut</td><td>ウィジェットが入力フォーカスを失ったときに発生</td></tr>
  <tr><td>Map</td><td>ウィジェットがスクリーンに現れたときに発生</td></tr>
  <tr><td>Unmap</td><td>ウィジェットがスクリーンから消えたときに発生</td></tr>
  <tr><td>Configure</td><td>ウィンドウの大きさが変更されたときに発生</td></tr>
</tbody>
</table>

<p> あとは、wm protocol で WM_DELETE_WINDOW が通知されたら flag を 1 にセットするように定義し、wm withdraw で作成したウィンドウを隠します。それから、名前入力用ウィンドウはボタンが押される前に作っておかなければいけません。画面の設定が終わったら make_window を実行してウィンドウを作成しておきます。
</p>
<p> input_window はウィンドウを表示して、名前が入力されたらウィンドウを隠します。
</p>

<pre class="list">
リスト : 名前の入力

proc input_name {} {
    global buffer message flag
    set buffer ""
    wm deiconify .t0
    wm geometry .t0 "+[expr [winfo x .] + 10]+[expr [winfo y .] + 10]"
    grab set .t0
    tkwait variable flag
    grab release .t0
    wm withdraw .t0
    set message [format "入力された名前は %s です" $buffer]
}
</pre>

<p> まず wm deiconify でウィンドウを見える状態にし、wm geometry でウィンドウの位置を指定します。次にグラブを設定し、tkwait variable で大域変数 flag に書き込みが行われるまで待ちます。入力が終了したら、グラブを解除してウィンドウを隠します。ウィンドウを隠しただけでは、グラブは解除されません。ウィンドウを壊す方法とは違い、グラブの解除を忘れないでください。あとはメインウィンドウに入力された名前を表示します。これでプログラムは完成です。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2001-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="tcltk_doc.html">Tcl/Tk GUI Programming</a> | <a href="tcltk202.html">NextPage</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>