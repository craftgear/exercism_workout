<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881806</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo20.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo22.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>電卓プログラムの改良</h3>
<p> 今回は電卓プログラムに新しいデータ型「整数 (integer)」、「文字列 (string)」、「ベクタ (vector)」<sup><a href="abcgo21.html#note1">[*1]</a></sup> を追加してみましょう。
</p>

<div class="note">
-- <a name="note1">note</a> --------<br>
[*1] ベクタは 1 次元配列のことです。
</div>
<h4>●型 Value の変更</h4>
<p> 今までの電卓プログラムでは、値 (Value) として扱うデータ型は実数 (float64) だけしかありませんでした。今回は整数、文字列、ベクタも値として扱う必要があるので、型 Value をインターフェースに変更します。
</p>
<pre class="list">
リスト : 値を表すインターフェース

type Value interface {
    isTrue() bool
}
</pre>
<p> メソッド isTrue は値の真偽を判定します。整数 0 と実数 0.0 を偽とし、あとの値は真と判定することにします。また、関数で真を返す場合は整数 1 を、偽を返す場合は整数 0 を使うことにします。
</p>

<h4>●整数の追加</h4>
<p> 次は、値に整数を追加します。最初に数値を表すインターフェース Num を定義します。
</p>
<pre class="list">
リスト : 数を表すインターフェース

type Num interface {
    Value
    Expr
    neg() Value
    sign() int
    add(Value) Value
    sub(Value) Value
    mul(Value) Value
    div(Value) Value
}
</pre>
<p> メソッド neg は符号を反転し、sign は数の符号 (-1, 0, 1) を返します。add, sub, mul, div は四則演算を行うメソッドです。今回は、整数と整数の演算結果は整数、実数と実数の演算結果は実数とし、整数と実数の演算は、整数を実数に変換して行うことにします。
</p>
<p> 数の定義は次のようになります。
</p>
<pre class="list">
リスト : 数の定義

type Int int64
type Flt float64

// Value の実装
func (n Int) isTrue() bool { return n != 0 }
func (n Flt) isTrue() bool { return n != 0.0 }

// Expr の実装
func (e Int) Eval(_ *Env) Value { return e }
func (e Flt) Eval(_ *Env) Value { return e }

// 符号の反転
func (n Int) neg() Value { return -n }
func (n Flt) neg() Value { return -n }

// 符号を求める
func (n Int) sign() int {
    switch {
    case n &gt; 0: return 1
    case n &lt; 0: return -1
    default: return 0
    }
}

func (n Flt) sign() int {
    switch {
    case n &gt; 0.0: return 1
    case n &lt; 0.0: return -1
    default: return 0
    }
}

// 四則演算
func (n Int) add(x Value) Value {
    switch m := x.(type) {
    case Int: return n + m
    case Flt: return Flt(n) + m
    }
    panic(errorNum("+, ", x))
}

func (n Flt) add(x Value) Value {
    switch m := x.(type) {
    case Int: return n + Flt(m)
    case Flt: return n + m
    }
    panic(errorNum("+, ", x))
}
</pre>
<p> 整数の型名は Int で実体は int64、実数の型名は Flt で実体は float64 です。isTrue, Eval, neg, sign の実装は簡単ですね。add の場合、型 switch で引数 x の型を判定し、レシーバ n と型が異なる場合は Int を Flt に変換してから計算します。Int, Flt 以外の場合は関数 errorNum で error を生成し、panic でエラーを送出します。他のメソッド sub, mul, div も同様です。
</p>
<p> この他に、数値の型を判定する組み込み関数 isInt, isFlt を追加します。
</p>
<h4>●値の比較</h4>
<p> 次は値を比較するためのインターフェース Cmp を定義します。
</p>
<pre class="list">
リスト : 値の比較

type Cmp interface {
    compare(Value) int
}
</pre>
<p> Cmp のメソッド compare は、レシーバ n と引数 x を比較して、n &lt; x であれば -1 を、同じ値であれば 0 を、n &gt; x であれば 1 を返します。数値の場合、compare は次のようになります。
</p>

<pre class="list">
リスト : Cmp の実装

func (n Int) compare(x Value) int {
    switch m := x.(type) {
    case Int: return (n - m).sign()
    case Flt: return (Flt(n) - m).sign()
    }
    panic(errorNum("compare, ", x))
}

func (n Flt) compare(x Value) int {
    switch m := x.(type) {
    case Int: return (n - Flt(m)).sign()
    case Flt: return (n - m).sign()
    }
    panic(errorNum("compare, ", x))
}
</pre>
<p> 型が異なる場合は Flt を Int に変換して比較します。数値以外の型は panic でエラーを送出します。
</p>

<h4>●文字列の追加</h4>
<p> 次は値に文字列を追加します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 文字列の定義

type Str string

// Value, Expr, Cmp の実装
func (_ Str) isTrue() bool { return true }
func (s Str) Eval(_ *Env) Value { return s }

func (n Str) compare(x Value) int {
    m, ok := x.(Str)
    if !ok {
        panic(errorStr("compare, ", x))
    }
    switch {
    case n &gt; m: return 1
    case n &lt; m: return -1
    default: return 0
    }
}
</pre>
<p> 文字列を表す型名は Str で実体は string です。メソッド isTrue は true を返し、Eval はレシーバ s をそのまま返します。compare は引数 x の型をチェックして、Str でなければ panic でエラーを送出します。あとは、n と型変換した値 m を比較するだけです。
</p>
<p> この他に、文字列の型を判定する組み込み関数 isStr を追加します。
</p>
<h4>●ベクタの生成とアクセス方法</h4>
<p> ベクタは Go 言語のスライスをそのまま使います。ベクタの生成は関数 vector と角カッコ [ ] で行います。vector は Go 言語の組み込み関数 make を呼び出すだけです。角カッコによるベクタの生成は Ruby や Python などスクリプト言語で使われている方法と同じです。文法は次のようになります。
</p>
<pre class="item">
ベクタ生成式 = "[", [要素リスト], "]"
要素リスト = 式, {",", 式 }
</pre>
<p> ベクタ生成式の処理は関数 factor で行います。式を評価した値がベクタの要素になります。ベクタ生成式は「式」なので、ベクタ生成式を入れ子にして多次元配列を実現することも可能です。
</p>
<p> ベクタのアクセスも角カッコを使います。文法は次のようになります。
</p>
<pre class="item">
代入式 = 左辺値, "=", 式.
左辺値 = 変数 | 変数, "[", 式, "]", {"[", 式, "]"}.

  因子   = 整数 | 実数 | 文字列 | ("+" | "-" | "not"), 因子 | "(", 式, ")" | 変数 |
           関数, "(", [引数リスト], ")" | if式 | begin式 | while式 | let式 |
           ベクタ生成式 | 変数, "[", 式, "]", {"[", 式, "]"}.
</pre>
<p> ベクタのアクセスは一般的な手続き型言語と同じです。a[0] はベクタ a の 0 番目の要素を取り出し、a[4] = 10 はベクタ a の 4 番目の要素を 10 に書き換えます。角カッコを 2 つ使うと入れ子の配列を 2 次元配列として利用することができます。簡単な例を示しましょう。
</p>
<pre>
Calc&gt; a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Calc&gt; a[0];
[1, 2, 3]
Calc&gt; a[0][1];
2
Calc&gt; a[2];
[7, 8, 9]
Calc&gt; a[2][2];
9
</pre>
<p> ベクタの中にベクタを入れることで 2 次元配列を表すことができます。a の 0 番目の要素はベクタ [1, 2, 3] で、そのベクタの 1 番目の要素は 2 です。この要素は角カッコを 2 つ使って a[0][1] とアクセスすることができます。a[0] で 0 番目のベクタを取り出し、そのベクタの 1 番目の要素を [1] で取り出します。同様に、a[2][2] の値は 9 になります。
</p>
<p> ベクタの定義は次のようになります。
</p>
<pre class="list">
リスト : ベクタの定義

type Vec []Value

// Value の実装
func (_ Vec) isTrue() bool { return true }
</pre>
<p> ベクタの型名は Vec で実体はスライス []Value です。ベクタは構文木に格納されることはないので、Eval を実装する必要はありません。今回はベクタの比較は行いませんが、ベクタを比較したい場合はメソッド compare を実装してください。
</p>

<p> この他に組み込み関数としてベクタの大きさを求める len と、ベクタの型を判定する isVec を追加します。
</p>
<h4>●構文解析の修正</h4>
<p> 次は、関数 factor を修正します。
</p>
<pre class="list">
リスト : factor の修正

func factor(lex *Lex) Expr {
    switch lex.Token {

    ・・・省略・・・

    case '[':
        lex.getToken()
        xs := getBody(lex)
        if lex.Token != ']' {
            panic(fmt.Errorf("']' expected"))
        }
        lex.getToken()
        return newCrv(xs)

    ・・・省略・・・

    case scanner.Int:
        var n int64
        fmt.Sscan(lex.TokenText(), &amp;n)
        lex.getToken()
        return Int(n)
    case scanner.Float:
        var n float64
        fmt.Sscan(lex.TokenText(), &amp;n)
        lex.getToken()
        return Flt(n)
    case scanner.String:
        var s string
        fmt.Sscanf(lex.TokenText(), "%q", &amp;s)
        lex.getToken()
        return Str(s)
    case scanner.Ident:
        name := lex.TokenText()
        lex.getToken()
        if name == "quit" {
            panic(name)
        }
        v, ok := funcTable[name]
        if ok {
            xs := getArgs(lex)
            if len(xs) != v.Argc() {
                panic(fmt.Errorf("wrong number of arguments, %v", name))
            }
            return newApp(v, xs)
        } else if lex.Token == '[' {
            return newRef(Variable(name), getIndex(lex))
        } else {
            return Variable(name)
        }
    default:
        panic(fmt.Errorf("unexpected token, %v", lex.TokenText()))
    }
}
</pre>
<p> 関数 factor でトークンが '[' の場合、ベクタの生成を表す構造体 Crv を返します。まず、getbody でカンマで区切られた式を取得して、変数 xs にセットします。次に、トークンが ']' であることを確認し、getToken で次のトークンを求めてから newCrv(xs) を返します。トークンが ']' でない場合はエラーを送出します。
</p>
<p> トークンが scanner.Int の場合は整数 Int を生成し、scanner.Float の場合は実数 Flt を生成します。scanner.String の場合は文字列を生成します。このとき、TokenText で取り出された文字列は " で囲まれているので、Sscanf で変換指示子 %q を指定して、" の中の文字列を取り出すようにします。
</p>
<p> トークンが scanner.Ident で次のトークンが '[' の場合、ベクタのアクセスを表す構造体 Ref を返します。添字は関数 getIndex で取得します。
</p>
<pre class="list">
リスト : 添字の取得

func getIndex(lex *Lex) []Expr {
    xs := make([]Expr, 0)
    lex.getToken()
    for {
        e := expression(lex)
        if lex.Token != ']' {
            panic(fmt.Errorf("']' expected"))
        }
        xs = append(xs, e)
        lex.getToken()
        if lex.Token != '[' {
            return xs
        }
        lex.getToken()
    }
}
</pre>
<p> 添字を格納するスライス xs を用意します。次の for ループで、添字を表す式を expression で取得して変数 e にセットします。トークンが ']' で終わっていない場合は panic でエラーを送出します。e をスライス xs に追加して、次のトークンが '[' かチェックします。そうでなければ、添え字の指定は終わりなので return で xs を返します。'[' の場合は次の添字を求めるため処理を繰り返します。
</p>

<p> もうひとつ、ベクタの要素を書き換える処理を関数 expression に追加します。
</p>

<pre class="list">
リスト : ベクタの更新処理

func expression(lex *Lex) Expr {
    e := expr1(lex)
    if lex.Token == '=' {
        switch x := e.(type) {
        case Variable:
            lex.getToken()
            return newAgn(x, expression(lex))
        case *Ref:
            lex.getToken()
            return newUdt(x, expression(lex))
        default:
            panic(fmt.Errorf("invalid assign form"))
        }
    }
    return e
}
</pre>
<p> 代入式の処理で、左辺値がベクタのアクセスを表す *Ref であれば、ベクタの代入処理を行う構造体 Udt を生成して返します。
</p>
<p> この他に、剰余を求める演算子 % を関数 term に追加します。優先順位は *, / と同じになります。
</p>
<h4>●単項演算子と二項演算子の修正</h4>
<p> 次は単項演算子と二項演算子の評価を修正します。
</p>
<pre class="list">
リスト : 単項演算子と二項演算子の評価

// 型変換とチェック
func toNum(v Value) Num {
    n, ok := v.(Num)
    if !ok {
        panic(errorNum("", v))
    }
    return n
}

func toInt(v Value) Int {
    n, ok := v.(Int)
    if !ok {
        panic(fmt.Errorf("Integer required, %v", v))
    }
    return n
}

func toCmp(v Value) Cmp {
    n, ok := v.(Cmp)
    if !ok {
        panic(fmt.Errorf("%v is uncomparable type", v))
    }
    return n
}

// 単項演算子
func (e *Op1) Eval(env *Env) Value {
    v := e.expr.Eval(env)
    switch e.code {
    case '-': return toNum(v).neg()
    case '+': return v
    case NOT: return boolToValue(!v.isTrue())
    default:
        panic(fmt.Errorf("invalid Op1 code"))
    }
}

// 二項演算子
func (e *Op2) Eval(env *Env) Value {
    x := e.left.Eval(env)
    y := e.right.Eval(env)
    switch e.code {
    case '+': return toNum(x).add(y)
    case '-': return toNum(x).sub(y)
    case '*': return toNum(x).mul(y)
    case '/': return toNum(x).div(y)
    case '%': return toInt(x) % toInt(y)
    case EQ:  return boolToValue(toCmp(x).compare(y) == 0)
    case NE:  return boolToValue(toCmp(x).compare(y) != 0)
    case LT:  return boolToValue(toCmp(x).compare(y) &lt; 0)
    case GT:  return boolToValue(toCmp(x).compare(y) &gt; 0)
    case LE:  return boolToValue(toCmp(x).compare(y) &lt;= 0)
    case GE:  return boolToValue(toCmp(x).compare(y) &gt;= 0)
    default:
        panic(fmt.Errorf("invalid Op2 code"))
    }
}
</pre>
<p> 単項演算子の '-' は x を関数 toNum で Num に型変換して、メソッド neg を呼び出すだけです。NOT は isTrue の否定を boolToValue に渡すだけです。二項演算子の四則演算は、toNum で x を Num に型変換して、演算子に対応するメソッドを呼び出すだけです。'%' は整数の剰余を求める演算子です。比較演算子の処理は、関数 toCmp で x を Cmp に型変換してメソッド compare を呼び出して 0 と比較するだけです。
</p>

<h4>●ベクタの生成とアクセス</h4>
<p> 次はベクタを生成する処理を作ります。
</p>
<pre class="list">
リスト : ベクタの生成

type Crv struct {
    xs []Expr
}

func newCrv(xs []Expr) *Crv {
    return &amp;Crv{xs}
}

// 評価
func (a *Crv) Eval(env *Env) Value {
    v := make(Vec, len(a.xs))
    for i := 0; i &lt; len(a.xs); i++ {
        v[i] = a.xs[i].Eval(env)
    }
    return v
}
</pre>
<p> 構造体 Crv のメソッド Eval は、最初に make でスライス v を作り、引数 a.xs の式を順番に Eval で評価して、その値を v に代入していくだけです。
</p>

<p> ベクタから値を求める処理は次のようになります。
</p>
<pre class="list">
リスト :  ベクタの参照

type Ref struct {
    name Variable
    idxs []Expr
}

func newRef(name Variable, idxs []Expr) *Ref {
    return &amp;Ref{name, idxs}
}

// アクセス位置を求める
func getPos(a *Ref, env *Env) *Value {
    v := a.name.Eval(env)
    for k := 0; ; k++ {
        xs, ok := v.(Vec)
        if !ok {
            panic(errorVec("", v))
        }
        y := a.idxs[k].Eval(env)
        i := toInt(y)
        if j := int(i); j &lt; 0 || j &gt;= len(xs) {
            panic(fmt.Errorf("Out of Range, %v, %v", xs, j))
        } else if k == len(a.idxs) - 1 {
            return &amp;xs[j]
        } else {
            v = xs[j]
        }
    }
}

// 評価
func (a *Ref) Eval(env *Env) Value {
    return *getPos(a, env)
}
</pre>
<p> 実際の処理は関数 getPos で行います。getPos はポインタを返すことに注意してください。最初に、a.name を評価して、その結果を v にセットします。次の for ループの中で、v がベクタであるかチェックします。そうでなければ、panic でエラーを送出します。次に、a.idxs[k] を Eval で評価して添字を求めます。添字がベクタの範囲外であれば panic でエラーを送出します。
</p>
<p> 次に、求めた添字が最後かチェックします。そうであれば、アクセスする位置は xs[j] になるので、ポインタ &amp;xs[j] を返します。まだ、添字が残っている場合は v の値を xs[j] に書き換えて処理を繰り返します。
</p>

<p> ベクタの更新は関数 getPos を使うと簡単です。
</p>
<pre class="list">
リスト : ベクタの更新

type Udt struct {
    ref *Ref
    val Expr
}

func newUdt(ref *Ref, val Expr) *Udt {
    return &amp;Udt{ref, val}
}

// 評価
func (a *Udt) Eval(env *Env) Value {
    x := getPos(a.ref, env)
    v := a.val.Eval(env)
    *x = v
    return v
}
</pre>
<p> getPos で値を書き換える位置を求め、変数 x にセットします。次に、a.val を Eval で評価して、変数 v にセットします。あとは、*x に v を代入して、return で v を返すだけです。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="abcgo21.html#list1">プログラムリスト</a> をお読みください。
</p>
<h4>●簡単な実行例</h4>
<p> それでは簡単な実行例を示します。
</p>
<pre>
Calc&gt; 1;
1
Calc&gt; isInt(1);
1
Calc&gt; 1.0;
1
Calc&gt; isFlt(1.0);
1
Calc&gt; 1 + 1.1;
2.1
Calc&gt; 1 + 2;
3
Calc&gt; isInt(1 + 2);
1
Calc&gt; "hello, world";
hello, world
Calc&gt; isStr("hello, world");
1
Calc&gt; "abc" == "abc";
1
Calc&gt; "abc" < "def";
1
Calc&gt; "abc" > "def";
0
Calc&gt; [1,2,3,4,5];
[1 2 3 4 5]
Calc&gt; isVec([1,2,3,4,5]);
1Calc&gt; a = [1,2,3,4,5];
[1, 2, 3, 4, 5]
Calc&gt; a[0];
1
Calc&gt; a[4];
5
Calc&gt; a[0] = 10;
10
Calc&gt; a;
[10, 2, 3, 4, 5]
Calc&gt; b = [[1,2,3],[4,5,6],[7,8,9]];
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Calc&gt; b[0];
[1, 2, 3]
Calc&gt; b[0][0];
1
Calc&gt; b[2][2];
9
Calc&gt; b[2][2] = 100;
100
Calc&gt; b;
[[1, 2, 3], [4, 5, 6], [7, 8, 100]]
Calc&gt; c = vector(10, 0);
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Calc&gt; len(c);
10
</pre>
<p> 正常に動作していますね。今回はここまでです。次回はベクタを使った簡単なサンプルプログラムを作ってみましょう。
</p>

<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// calc6.go : 電卓プログラム (整数, 文字列, ベクタの追加)
//
//            Copyright (C) 2014 Makoto Hiroi
//
package main

import (
    "fmt"
    "os"
    "math"
    "text/scanner"
)

// キーワード
const (
    DEF = -(iota+10)
    END
    IF
    THEN
    ELSE
    NOT
    AND
    OR
    EQ
    NE
    LT
    GT
    LE
    GE
    BGN
    WHL
    DO
    LET
    IN
)

// キーワード表
var keyTable = make(map[string]rune)

func initKeyTable() {
    keyTable["def"]   = DEF
    keyTable["end"]   = END
    keyTable["if"]    = IF
    keyTable["then"]  = THEN
    keyTable["else"]  = ELSE
    keyTable["and"]   = AND
    keyTable["or"]    = OR
    keyTable["not"]   = NOT
    keyTable["begin"] = BGN
    keyTable["while"] = WHL
    keyTable["do"]    = DO
    keyTable["let"]   = LET
    keyTable["in"]    = IN
}

// 値
type Value interface {
    isTrue() bool
}

// 変数
type Variable string

// 局所変数の環境
type Env struct {
    name Variable
    val  Value
    next *Env
}

// 構文木
type Expr interface {
    Eval(*Env) Value
}

// 数
type Num interface {
    Value
    Expr
    neg() Value
    sign() int
    add(Value) Value
    sub(Value) Value
    mul(Value) Value
    div(Value) Value
}

// 比較
type Cmp interface {
    compare(Value) int
}

//
// 数値
//
type Int int64
type Flt float64

// エラー
func errorNum(mes string, v Value) error {
    return fmt.Errorf("%sNumber required, %v", mes, v)
}

func errorInt(mes string, v Value) error {
    return fmt.Errorf("%sInteger required, %v", mes, v)
}

// Value の実装
func (n Int) isTrue() bool { return n != 0 }
func (n Flt) isTrue() bool { return n != 0.0 }

// Expr の実装
func (e Int) Eval(_ *Env) Value { return e }
func (e Flt) Eval(_ *Env) Value { return e }

// 符号の反転
func (n Int) neg() Value { return -n }
func (n Flt) neg() Value { return -n }

// 符号を求める
func (n Int) sign() int {
    switch {
    case n &gt; 0: return 1
    case n &lt; 0: return -1
    default: return 0
    }
}

func (n Flt) sign() int {
    switch {
    case n &gt; 0.0: return 1
    case n &lt; 0.0: return -1
    default: return 0
    }
}

// 四則演算
func (n Int) add(x Value) Value {
    switch m := x.(type) {
    case Int: return n + m
    case Flt: return Flt(n) + m
    }
    panic(errorNum("+, ", x))
}

func (n Flt) add(x Value) Value {
    switch m := x.(type) {
    case Int: return n + Flt(m)
    case Flt: return n + m
    }
    panic(errorNum("+, ", x))
}

func (n Int) sub(x Value) Value {
    switch m := x.(type) {
    case Int: return n - m
    case Flt: return Flt(n) - m
    }
    panic(errorNum("-, ", x))
}

func (n Flt) sub(x Value) Value {
    switch m := x.(type) {
    case Int: return n - Flt(m)
    case Flt: return n - m
    }
    panic(errorNum("-, ", x))
}

func (n Int) mul(x Value) Value {
    switch m := x.(type) {
    case Int: return n * m
    case Flt: return Flt(n) * m
    }
    panic(errorNum("*, ", x))
}

func (n Flt) mul(x Value) Value {
    switch m := x.(type) {
    case Int: return n * Flt(m)
    case Flt: return n * m
    }
    panic(errorNum("*, ", x))
}

func (n Int) div(x Value) Value {
    switch m := x.(type) {
    case Int: return n / m
    case Flt: return Flt(n) / m
    }
    panic(errorNum("/, ", x))
}

func (n Flt) div(x Value) Value {
    switch m := x.(type) {
    case Int: return n / Flt(m)
    case Flt: return n / m
    }
    panic(errorNum("/, ", x))
}

// Cmp の実装
func (n Int) compare(x Value) int {
    switch m := x.(type) {
    case Int: return (n - m).sign()
    case Flt: return (Flt(n) - m).sign()
    }
    panic(errorNum("compare, ", x))
}

func (n Flt) compare(x Value) int {
    switch m := x.(type) {
    case Int: return (n - Flt(m)).sign()
    case Flt: return (n - m).sign()
    }
    panic(errorNum("compare, ", x))
}

//
// 文字列
//
type Str string

// エラー
func errorStr(mes string, v Value) error {
    return fmt.Errorf("%sString required, %v", mes, v)
}

// Value, Expr, Cmp の実装
func (_ Str) isTrue() bool { return true }
func (s Str) Eval(_ *Env) Value { return s }

func (n Str) compare(x Value) int {
    m, ok := x.(Str)
    if !ok {
        panic(errorStr("compare, ", x))
    }
    switch {
    case n &gt; m: return 1
    case n &lt; m: return -1
    default: return 0
    }
}

//
// 配列
//
type Vec []Value

// エラー
func errorVec(mes string, v Value) error {
    return fmt.Errorf("%sVector required , %v", mes, v)
}

// Value の実装
func (_ Vec) isTrue() bool { return true }

// ベクタ生成用構文木
type Crv struct {
    xs []Expr
}

func newCrv(xs []Expr) *Crv {
    return &amp;Crv{xs}
}

// ベクタの生成
func (a *Crv) Eval(env *Env) Value {
    v := make(Vec, len(a.xs))
    for i := 0; i &lt; len(a.xs); i++ {
        v[i] = a.xs[i].Eval(env)
    }
    return v
}

// ベクタの参照
type Ref struct {
    name Variable
    idxs []Expr
}

func newRef(name Variable, idxs []Expr) *Ref {
    return &amp;Ref{name, idxs}
}

// アクセス位置を求める
func getPos(a *Ref, env *Env) *Value {
    v := a.name.Eval(env)
    for k := 0; ; k++ {
        xs, ok := v.(Vec)
        if !ok {
            panic(errorVec("", v))
        }
        y := a.idxs[k].Eval(env)
        i := toInt(y)
        if j := int(i); j &lt; 0 || j &gt;= len(xs) {
            panic(fmt.Errorf("Out of Range, %v, %v", xs, j))
        } else if k == len(a.idxs) - 1 {
            return &amp;xs[j]
        } else {
            v = xs[j]
        }
    }
}

// 評価
func (a *Ref) Eval(env *Env) Value {
    return *getPos(a, env)
}
    
// ベクタの更新
type Udt struct {
    ref *Ref
    val Expr
}

func newUdt(ref *Ref, val Expr) *Udt {
    return &amp;Udt{ref, val}
}

// 評価
func (a *Udt) Eval(env *Env) Value {
    x := getPos(a.ref, env)
    v := a.val.Eval(env)
    *x = v
    return v
}

//
// 変数と環境
//

// 環境の生成
func newEnv(name Variable, val Value, env *Env) *Env {
    return &amp;Env{name, val, env}
}

func makeBinding(xs []Variable, es []Expr, env *Env) *Env {
    var env1 *Env
    for i := 0; i &lt; len(xs); i++ {
        env1 = newEnv(xs[i], es[i].Eval(env), env1)
    }
    return env1
}

// 局所変数を環境に追加
func addBinding(xs []Variable, es []Expr, env *Env) *Env {
    for i := 0; i &lt; len(xs); i++ {
        env = newEnv(xs[i], es[i].Eval(env), env)
    }
    return env
}

// 局所変数の探索
func lookup(name Variable, env *Env) (Value, bool) {
    for ; env != nil; env = env.next {
        if name == env.name {
            return env.val, true
        }
    }
    return Int(0), false
}

// 局所変数の更新
func update(name Variable, val Value, env *Env) bool {
    for ; env != nil; env = env.next {
        if name == env.name {
            env.val = val
            return true
        }
    }
    return false
}

// 大域的な環境
var globalEnv = make(map[Variable]Value)

// 変数の評価
func (v Variable) Eval(env *Env) Value {
    // 局所変数の探索
    val, ok := lookup(v, env)
    if ok {
        return val
    }
    // 大域変数の探索
    val, ok = globalEnv[v]
    if !ok {
        panic(fmt.Errorf("unbound variable, %v", v))
    }
    return val
}

//
// 単項演算子
//
type Op1 struct {
    code rune
    expr Expr
}

func newOp1(code rune, e Expr) Expr {
    return &amp;Op1{code, e}
}

// bool を Value に変換する
func boolToValue(x bool) Value {
    if x {
        return Int(1)
    } else {
        return Int(0)
    }
}

// 型変換とチェック
func toNum(v Value) Num {
    n, ok := v.(Num)
    if !ok {
        panic(errorNum("", v))
    }
    return n
}

// 評価
func (e *Op1) Eval(env *Env) Value {
    v := e.expr.Eval(env)
    switch e.code {
    case '-': return toNum(v).neg()
    case '+': return v
    case NOT: return boolToValue(!v.isTrue())
    default:
        panic(fmt.Errorf("invalid Op1 code"))
    }
}

//
// 二項演算子
//
type Op2 struct {
    code rune
    left, right Expr
}

func newOp2(code rune, left, right Expr) Expr {
    return &amp;Op2{code, left, right}
}

// 型変換とチェック
func toInt(v Value) Int {
    n, ok := v.(Int)
    if !ok {
        panic(fmt.Errorf("Integer required, %v", v))
    }
    return n
}

func toCmp(v Value) Cmp {
    n, ok := v.(Cmp)
    if !ok {
        panic(fmt.Errorf("%v is uncomparable type", v))
    }
    return n
}

// 評価
func (e *Op2) Eval(env *Env) Value {
    x := e.left.Eval(env)
    y := e.right.Eval(env)
    switch e.code {
    case '+': return toNum(x).add(y)
    case '-': return toNum(x).sub(y)
    case '*': return toNum(x).mul(y)
    case '/': return toNum(x).div(y)
    case '%': return toInt(x) % toInt(y)
    case EQ:  return boolToValue(toCmp(x).compare(y) == 0)
    case NE:  return boolToValue(toCmp(x).compare(y) != 0)
    case LT:  return boolToValue(toCmp(x).compare(y) &lt; 0)
    case GT:  return boolToValue(toCmp(x).compare(y) &gt; 0)
    case LE:  return boolToValue(toCmp(x).compare(y) &lt;= 0)
    case GE:  return boolToValue(toCmp(x).compare(y) &gt;= 0)
    default:
        panic(fmt.Errorf("invalid Op2 code"))
    }
}

//
// 短絡演算子
//
type Ops struct {
    code rune
    left, right Expr
}

func newOps(code rune, left, right Expr) Expr {
    return &amp;Ops{code, left, right}
}

// 評価
func (e *Ops) Eval(env *Env) Value {
    x := e.left.Eval(env)
    switch e.code {
    case AND:
        if x.isTrue() {
            return e.right.Eval(env)
        }
        return x
    case OR:
        if x.isTrue() {
            return x
        }
        return e.right.Eval(env)
    default:
        panic(fmt.Errorf("invalid Ops code"))
    }
}

//
// if
//
type Sel struct {
    testForm, thenForm, elseForm Expr
}

func newSel(testForm, thenForm, elseForm Expr) *Sel {
    return &amp;Sel{testForm, thenForm, elseForm}
}

func (e *Sel) Eval(env *Env) Value {
    if e.testForm.Eval(env).isTrue() {
        return e.thenForm.Eval(env)
    }
    return e.elseForm.Eval(env)
}

//
// while
//
type Whl struct {
    testForm, body Expr
}

func newWhl(testForm, body Expr) *Whl {
    return &amp;Whl{testForm, body}
}

func (e *Whl) Eval(env *Env) Value {
    for e.testForm.Eval(env).isTrue() {
        e.body.Eval(env)
    }
    return Int(0)
}

//
// begin
//
type Bgn struct {
    body []Expr
}

func newBgn(xs []Expr) *Bgn {
    return &amp;Bgn{xs}
}

func (e *Bgn) Eval(env *Env) Value {
    var r Value
    for _, expr := range e.body {
        r = expr.Eval(env)
    }
    return r
}

//
// let 
//
type Let struct {
    vars []Variable
    vals []Expr
    body Expr
}

func newLet(vars []Variable, vals []Expr, body Expr) *Let {
    return &amp;Let{vars, vals, body}
}

func (e *Let) Eval(env *Env) Value {
    return e.body.Eval(addBinding(e.vars, e.vals, env))
}

//
// 代入演算子
//
type Agn struct {
    name Variable
    expr Expr
}

func newAgn(v Variable, e Expr) *Agn {
    return &amp;Agn{v, e}
}

func (a *Agn) Eval(env *Env) Value {
    val := a.expr.Eval(env)
    if !update(a.name, val, env) {
        globalEnv[a.name] = val
    }
    return val
}

//
// 関数
//
type Func interface {
    Argc() int
}

// 組み込み関数
type Func1 func(float64) float64

func (f Func1) Argc() int {    return 1 }

type Func2 func(float64, float64) float64

func (f Func2) Argc() int {    return 2 }

type FuncV1 func(Value) Value

func (f FuncV1) Argc() int { return 1 }

type FuncV2 func(Value, Value) Value

func (f FuncV2) Argc() int { return 2 }

// ユーザ定義関数
type FuncU struct {
    name string
    xs   []Variable
    body Expr
}

func newFuncU(name string, xs []Variable, body Expr) *FuncU {
    return &amp;FuncU{name, xs, body}
}

func (f *FuncU) Argc() int { return len(f.xs) }

//
// 関数呼び出し
//
type App struct {
    fn Func
    xs []Expr
}

func newApp(fn Func, xs []Expr) *App {
    return &amp;App{fn, xs}
}

// 数値を float64 に変換
func valueToFloat(v Value) float64 {
    switch x := v.(type) {
    case Int: return float64(x)
    case Flt: return float64(x)
    default:
        panic(errorNum("", v))
    }
}

func (a *App) Eval(env *Env) Value {
    switch f := a.fn.(type) {
    case Func1:
        x := valueToFloat(a.xs[0].Eval(env))
        return Flt(f(x))
    case Func2:
        x := valueToFloat(a.xs[0].Eval(env))
        y := valueToFloat(a.xs[1].Eval(env))
        return Flt(f(x, y))
    case FuncV1:
        return f(a.xs[0].Eval(env))
    case FuncV2:
        return f(a.xs[0].Eval(env), a.xs[1].Eval(env))
    case *FuncU:
        return f.body.Eval(makeBinding(f.xs, a.xs, env))
    default:
        panic(fmt.Errorf("%v is not function", f))
    }
}

//
// 組み込み関数の初期化
//
var funcTable = make(map[string]Func)

// 値の表示
func print(x Value) Value {
    fmt.Print(x)
    return x
}

func println(x Value) Value {
    fmt.Println(x)
    return x
}

// ベクタの生成
func makeVector(n, x Value) Value {
    k := toInt(n)
    xs := make(Vec, int(k))
    for i := 0; i &lt; int(k); i++ {
        xs[i] = x
    }
    return xs
}

func length(v Value) Value {
    xs, ok := v.(Vec)
    if !ok {
        panic(errorVec("len, ", v))
    }
    return Int(len(xs))
}

func isInt(v Value) Value {
    _, ok := v.(Int)
    return boolToValue(ok)
}

func isFlt(v Value) Value {
    _, ok := v.(Flt)
    return boolToValue(ok)
}

func isVec(v Value) Value {
    _, ok := v.(Vec)
    return boolToValue(ok)
}

func isStr(v Value) Value {
    _, ok := v.(Str)
    return boolToValue(ok)
}

func initFunc() {
    funcTable["sqrt"]  = Func1(math.Sqrt)
    funcTable["sin"]   = Func1(math.Sin)
    funcTable["cos"]   = Func1(math.Cos)
    funcTable["tan"]   = Func1(math.Tan)
    funcTable["sinh"]  = Func1(math.Sinh)
    funcTable["cosh"]  = Func1(math.Cosh)
    funcTable["tanh"]  = Func1(math.Tanh)
    funcTable["asin"]  = Func1(math.Asin)
    funcTable["acos"]  = Func1(math.Acos)
    funcTable["atan"]  = Func1(math.Atan)
    funcTable["atan2"] = Func2(math.Atan2)
    funcTable["exp"]   = Func1(math.Exp)
    funcTable["pow"]   = Func2(math.Pow)
    funcTable["log"]   = Func1(math.Log)
    funcTable["log10"] = Func1(math.Log10)
    funcTable["log2"]  = Func1(math.Log2)
    funcTable["print"] = FuncV1(print)
    funcTable["println"] = FuncV1(println)
    funcTable["len"]   = FuncV1(length)
    funcTable["vector"] = FuncV2(makeVector)
    funcTable["isInt"] = FuncV1(isInt)
    funcTable["isFlt"] = FuncV1(isFlt)
    funcTable["isStr"] = FuncV1(isStr)
    funcTable["isVec"] = FuncV1(isVec)
}

//
// 字句解析
//
type Lex struct {
    scanner.Scanner
    Token rune
}

func (lex *Lex) getToken() {
    lex.Token = lex.Scan()
    switch lex.Token {
    case scanner.Ident:
        key, ok := keyTable[lex.TokenText()]
        if ok {
            lex.Token = key
        }
    case '=':
        if lex.Peek() == '=' {
            lex.Next()
            lex.Token = EQ
        }
    case '!':
        if lex.Peek() == '=' {
            lex.Next()
            lex.Token = NE
        } else {
            lex.Token = NOT
        }
    case '&lt;':
        if lex.Peek() == '=' {
            lex.Next()
            lex.Token = LE
        } else {
            lex.Token = LT
        }
    case '&gt;':
        if lex.Peek() == '=' {
            lex.Next()
            lex.Token = GE
        } else {
            lex.Token = GT
        }
    }
}

//
// 構文解析
//

// 仮引数の取得
func getParameter(lex *Lex) []Variable {
    e := make([]Variable, 0)
    if lex.Token != '(' {
        panic(fmt.Errorf("'(' expected"))
    }
    lex.getToken()
    if lex.Token == ')' {
        lex.getToken()
        return e
    }
    for {
        if lex.Token == scanner.Ident {
            e = append(e, Variable(lex.TokenText()))
            lex.getToken()
            switch lex.Token {
            case ')':
                lex.getToken()
                return e
            case ',':
                lex.getToken()
            default:
                panic(fmt.Errorf("unexpected token in parameter list"))
            }
        } else {
            panic(fmt.Errorf("unexpected token in parameter list"))
        }
    }
}


// 引数の取得
func getArgs(lex *Lex) []Expr {
    e := make([]Expr, 0)
    if lex.Token != '(' {
        panic(fmt.Errorf("'(' expected"))
    }
    lex.getToken()
    if lex.Token == ')' {
        lex.getToken()
        return e
    }
    for {
        e = append(e, expression(lex))
        switch lex.Token {
        case ')':
            lex.getToken()
            return e
        case ',':
            lex.getToken()
        default:
            panic(fmt.Errorf("unexpected token in argument list"))
        }
    }
}

// if 式の解析
func makeSel(lex *Lex) Expr {
    testForm := expression(lex)
    if lex.Token == THEN {
        lex.getToken()
        thenForm := expression(lex)
        switch lex.Token {
        case ELSE:
            lex.getToken()
            elseForm := expression(lex)
            if lex.Token != END {
                panic(fmt.Errorf("if, 'end' expected"))
            }
            lex.getToken()
            return newSel(testForm, thenForm, elseForm)
        case END:
            lex.getToken()
            return newSel(testForm, thenForm, Int(0))
        default:
            panic(fmt.Errorf("if, 'else' or 'end' expected"))
        } 
    } else {
        panic(fmt.Errorf("if, 'then' expected"))
    }
}

// begin 式の解析
func getBody(lex *Lex) []Expr {
    body := make([]Expr, 0)
    for {
        body = append(body, expression(lex))
        switch lex.Token {
        case ',':
            lex.getToken()
        default:
            return body
        }
    }
}

func makeBegin(lex *Lex) Expr {
    if lex.Token == END {
        panic(fmt.Errorf("invalid begin form"))
    }
    body := getBody(lex)
    if lex.Token != END {
        panic(fmt.Errorf("'end' expected"))
    }
    lex.getToken()
    return newBgn(body)
}

// while 式の解析
func makeWhile(lex *Lex) Expr {
    testForm := expression(lex)
    if lex.Token == DO {
        lex.getToken()
        return newWhl(testForm, makeBegin(lex))
    } else {
        panic(fmt.Errorf("'do' expected"))
    }
}

// let 式の解析
func makeLet(lex *Lex) Expr {
    vars := make([]Variable, 0)
    vals := make([]Expr, 0)
    for {
        e := expression(lex)
        a, ok := e.(*Agn)
        if !ok {
            panic(fmt.Errorf("let: invalid assign form"))
        }
        vars = append(vars, a.name)
        vals = append(vals, a.expr)
        if lex.Token == IN {
            break
        } else if lex.Token != ',' {
            panic(fmt.Errorf("let, 'in' or ',' expected"))
        }
        lex.getToken()
    }
    lex.getToken()
    return newLet(vars, vals, makeBegin(lex))
}

// 添字の取得
func getIndex(lex *Lex) []Expr {
    xs := make([]Expr, 0)
    lex.getToken()
    for {
        e := expression(lex)
        if lex.Token != ']' {
            panic(fmt.Errorf("']' expected"))
        }
        xs = append(xs, e)
        lex.getToken()
        if lex.Token != '[' {
            return xs
        }
        lex.getToken()
    }
}

// 因子
func factor(lex *Lex) Expr {
    switch lex.Token {
    case '(':
        lex.getToken()
        e := expression(lex)
        if lex.Token != ')' {
            panic(fmt.Errorf("')' expected"))
        }
        lex.getToken()
        return e
    case '[':
        lex.getToken()
        xs := getBody(lex)
        if lex.Token != ']' {
            panic(fmt.Errorf("']' expected"))
        }
        lex.getToken()
        return newCrv(xs)
    case '+':
        lex.getToken()
        return newOp1('+', factor(lex))
    case '-':
        lex.getToken()
        return newOp1('-', factor(lex))
    case NOT:
        lex.getToken()
        return newOp1(NOT, factor(lex))
    case IF:
        lex.getToken()
        return makeSel(lex)
    case BGN:
        lex.getToken()
        return makeBegin(lex)
    case WHL:
        lex.getToken()
        return makeWhile(lex)
    case LET:
        lex.getToken()
        return makeLet(lex)
    case scanner.Int:
        var n int64
        fmt.Sscan(lex.TokenText(), &amp;n)
        lex.getToken()
        return Int(n)
    case scanner.Float:
        var n float64
        fmt.Sscan(lex.TokenText(), &amp;n)
        lex.getToken()
        return Flt(n)
    case scanner.String:
        var s string
        fmt.Sscanf(lex.TokenText(), "%q", &amp;s)
        lex.getToken()
        return Str(s)
    case scanner.Ident:
        name := lex.TokenText()
        lex.getToken()
        if name == "quit" {
            panic(name)
        }
        v, ok := funcTable[name]
        if ok {
            xs := getArgs(lex)
            if len(xs) != v.Argc() {
                panic(fmt.Errorf("wrong number of arguments, %v", name))
            }
            return newApp(v, xs)
        } else if lex.Token == '[' {
            return newRef(Variable(name), getIndex(lex))
        } else {
            return Variable(name)
        }
    default:
        panic(fmt.Errorf("unexpected token, %v", lex.TokenText()))
    }
}

// 項
func term(lex *Lex) Expr {
    e := factor(lex)
    for {
        switch lex.Token {
        case '*':
            lex.getToken()
            e = newOp2('*', e, factor(lex))
        case '/':
            lex.getToken()
            e = newOp2('/', e, factor(lex))
        case '%':
            lex.getToken()
            e = newOp2('%', e, factor(lex))
        default:
            return e
        }
    }
}

// 式
func expr3(lex *Lex) Expr {
    e := term(lex)
    for {
        switch lex.Token {
        case '+':
            lex.getToken()
            e = newOp2('+', e, term(lex))
        case '-':
            lex.getToken()
            e = newOp2('-', e, term(lex))
        default:
            return e
        }
    }
}

// 比較演算子
func expr2(lex *Lex) Expr {
    e := expr3(lex)
    x := lex.Token
    switch x {
    case EQ, NE, LT, GT, LE, GE:
        lex.getToken()
        return newOp2(x, e, expr3(lex))
    default:
        return e
    }
}

// 論理演算子
func expr1(lex *Lex) Expr {
    e := expr2(lex)
    for {
        x := lex.Token
        switch x {
        case AND, OR:
            lex.getToken()
            e = newOps(x, e, expr2(lex))
        default:
            return e
        }
    }
}

func expression(lex *Lex) Expr {
    e := expr1(lex)
    if lex.Token == '=' {
        switch x := e.(type) {
        case Variable:
            lex.getToken()
            return newAgn(x, expression(lex))
        case *Ref:
            lex.getToken()
            return newUdt(x, expression(lex))
        default:
            panic(fmt.Errorf("invalid assign form"))
        }
    }
    return e
}

// ユーザ関数の定義
func defineFunc(lex *Lex) string {
    lex.getToken()
    if lex.Token != scanner.Ident {
        panic(fmt.Errorf("invalid define form"))
    }
    name := lex.TokenText()
    lex.getToken()
    xs := getParameter(lex)    
    v, ok := funcTable[name]
    if ok {
        switch f := v.(type) {
        case *FuncU:
            if len(f.xs) != len(xs) {
                panic(fmt.Errorf("wrong number of arguments: %v", name))
            }
            body := newBgn(getBody(lex))
            if lex.Token != END {
                panic(fmt.Errorf("'end' expected"))
            }
            f.xs = xs
            f.body = body
        default:
            panic(fmt.Errorf("%v is built-in function", name))
        }
    } else {
        // 再帰呼び出し対応
        f := newFuncU(name, xs, nil)
        funcTable[name] = f
        f.body = newBgn(getBody(lex))
        if lex.Token != END {
            delete(funcTable, name)
            panic(fmt.Errorf("'end' expected"))
        }
    }
    return name
}

// ライブラリのロード
func loadLib(name string) {
    var lex Lex
    file, err := os.Open(name)
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    defer func(){
        err := recover()
        file.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, "%s: %v, %s\n", name, err, lex.Position)
            os.Exit(1)
        }
    }()
    lex.Init(file)
    for {
        lex.getToken()
        if lex.Token == scanner.EOF {
            break
        } else if lex.Token == DEF {
            defineFunc(&amp;lex)
        } else {
            e := expression(&amp;lex)
            if lex.Token != ';' {
                panic(fmt.Errorf("invalid expression"))
            }
            e.Eval(nil)
        }
    }
}

// 式の入力と評価
func toplevel(lex *Lex) (r bool) {
    r = false
    defer func(){
        err := recover()
        if err != nil {
            mes, ok := err.(string)
            if ok &amp;&amp; mes == "quit" {
                r = true
            } else {
                fmt.Fprintln(os.Stderr, err)
                for {
                    c := lex.Peek()
                    if c == '\n' { break }
                    lex.Next()
                }
            }
        }
    }()
    for {
        fmt.Print("Calc&gt; ")
        lex.getToken()
        if lex.Token == DEF {
            fmt.Println(defineFunc(lex))
        } else {
            e := expression(lex)
            if lex.Token != ';' {
                panic(fmt.Errorf("invalid expression"))
            } else {
                fmt.Println(e.Eval(nil))
            }
        }
    }
    return r
}

func main() {
    initKeyTable()
    initFunc()
    for _, name := range os.Args[1:] {
        loadLib(name)
    }
    var lex Lex
    lex.Init(os.Stdin)
    for {
        if toplevel(&amp;lex) { break }
    }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo20.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo22.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>