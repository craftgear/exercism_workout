<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881805</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo10.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo12.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>ファイル入出力</h3>
<p> 今回はデータの入出力について簡単に説明します。Go 言語は「ファイルディスクプリタ」というデータを介してファイルにアクセスします。ファイルディスクプリタはファイルと一対一に対応していて、ファイルからデータを入力する場合は、ファイルディスクプリタを経由してデータが渡されます。逆に、ファイルへデータを出力するときも、ファイルディスクプリタを経由して行われます。
</p>
<p> ファイルディスクプリタはパッケージ os に定義されている構造体 File に格納されてユーザーに渡されます。ただし、Go 言語の File には低レベルな処理 (メソッド) しか用意されていません。Go 言語の場合、パッケージ bufio に高レベルな処理を行うための構造体 Reader や Writer が用意されているので、File からそれらの型を生成して入出力処理を行います。
</p>

<h4>●標準入出力</h4>
<p> 通常のファイルは、ファイルディスクプリタ (File 構造体) を生成しないとアクセスすることはできません。ただし、標準入出力は Go 言語の起動時に File 構造体が自動的に生成されるので、簡単に利用することができます。一般に、キーボードからの入力を「標準入力」、画面への出力を「標準出力」といいます。標準入出力に対応する File 構造体は、パッケージ os の変数に格納されています。下表に変数名を示します。
</p>
<table border=1>
<caption>表 : 標準入出力</caption>
<thead>
  <tr><th>変数名</th><th>ファイル</th></tr>
</thead>
<tbody>
  <tr><td>Stdin  </td><td>標準入力</td></tr>
  <tr><td>Stdout </td><td>標準出力</td></tr>
  <tr><td>Stderr </td><td>標準エラー出力</td></tr>
</tbody>
</table>

<p> ファイルのアクセスは標準入出力を使うと簡単です。File 構造体のメソッドで、入出力の基本となるのが Read と Write です。
</p>
<pre class="item">
func (f *File) Read(b []byte) (n int, err error)
func (f *File) Write(b []byte) (n int, err error)
</pre>
<p> メソッド Read は f からデータをバッファ b に len(b) バイト読み込みます。正常にデータを読み込んだ場合、返り値は読み込んだバイト数と nil で、エラーが発生した場合は 0 とエラーを表す値 err を返します。たとえば、ファイルの終了を検出した場合、Read は 0 とエラー io.EOF を返します。
</p>
<p> 型 error はインターフェースで、そのメソッド Error はエラーメッセージを文字列として返します。
</p>
<pre class="list">
リスト : error の定義

type error interface {
    Error() string
}
</pre>
<p> Print や Println は error を受け取るとメソッド Error を呼び出して、返り値の文字列を表示します。
</p>

<p> Write はバッファ b に格納されている len(b) バイト分のデータを f へ書き込みます。返り値は書き込んだバイト数で、エラーが発生した場合は 0 とエラー err を返します。
</p>

<p> それでは簡単な例題として、入力されたデータをそのまま画面へ出力するコマンド echo を作ってみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : echo (echo.go)

package main

import "os"

func main() {
    buff := make([]byte, 256)
    for {
        c, _ := os.Stdin.Read(buff)
        if c == 0 { break }
        os.Stdout.Write(buff[:c])
    }
}
</pre>
<p> make で大きさ 256 バイトのバッファを用意して変数 buff にセットします。次の for ループの中で、標準入力から Read でデータを読み込み、データ数を変数 c にセットします。c が 0 ならば break で for ループを脱出します。そうでなければ、buff[:c] で c バイトのスライスを生成して、それを Write で標準出力へ書き込みます。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;go run echo.go
hello, world    &lt;- 入力
hello, world
foo bar baz     &lt;- 入力
foo bar baz
sayonara        &lt;- 入力
sayonara
                &lt;- CTRL-C を入力

C&gt;go run echo.go &lt; echo.go
package main

import "os"

func main() {
    buff := make([]byte, 256)
    for {
        c, _ := os.Stdin.Read(buff)
        if c == 0 { break }
        os.Stdout.Write(buff[:c])
    }
}
</pre>
<p> ファイルをリダイレクトすることで、ファイルの内容を表示することができます。
</p>

<h4>●バイト単位の入出力</h4>
<p> バイト単位や行単位で入出力を行いたい場合はパッケージ bufio を使うと便利です。bufio はバッファ付きの入出力処理を行います。これはＣ言語の FILE 構造体を使った高水準入出力処理に近い動作になります。
</p>
<p> バイト単位で入出力を行うには、メソッド ReadByte と WriteByte を使います。
</p>
<pre class="item">
func (b *Reader) ReadByte() (c byte, err error)
func (b *Writeer) WriteByte(c byte) error
</pre>
<p> Reader と Writer は bufio に定義されている構造体です。Reader と Writer は次の関数で生成します。
</p>
<pre class="item">
func NewReader(r io.Reader) *Reader
func NewWriter(w io.Writer) *Writer
</pre>
<p> io.Reader と io.Writer はパッケージ io に定義されているインターフェースです。
</p>
<pre class="list">
リスト : io.Reader と io.Writer の定義

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</pre>
<p> メソッド Read と Write は、File 構造体のメソッド Read と Write と同じ型です。したがって、File 型は io.Reader 型や io.Writer 型として扱うことができます。つまり、NewReader に File を渡せばそれに対応する Reader を、newWriter に File を渡せば Writer を生成することができます。
</p>

<p> それでは、ReadByte と WriteByte を使って echo を書き直してみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : echo (echo1.go)

package main

import (
    "os"
    "io"
    "bufio"
)

func main() {
    r := bufio.NewReader(os.Stdin)
    w := bufio.NewWriter(os.Stdout)
    for {
        c, err := r.ReadByte()
        if err == io.EOF { break }
        w.WriteByte(c)
        if c == '\n' { w.Flush() }
    }
    w.Flush()
}
</pre>
<p> NewReader に Stdin を、NewWriter に Stdout を渡して、Reader と Writer を生成します。変数 r が Reader で、変数 w が Writer です。次の for ループの中で、ReadByte を呼び出して 1 バイト読み込み、変数 c にセットします。err が io.EOF であればファイルの終了を検出したので、break で for ループを脱出します。そうでなければ、WriteByte で c を出力します。
</p>
<p> Writer はバッファが満杯になるまでデータを溜め込みます。実際にファイルに書き込むのはバッファが満杯になってからです。途中でバッファのデータをファイルに出力したい場合はメソッド Flush を使います。c が '\n' と等しい場合は Flush でバッファのデータを出力します。これで 1 行ごとにデータを出力することができます。最後に、Flush でバッファ内のデータを出力します。これで echo.go と同じ動作になります。
</p>

<h4>●行単位の入出力</h4>
<p> ファイルを行単位で処理したい場合は、次のメソッドを使うと便利です。
</p>
<pre class="item">
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
func (b *Reader) ReadString(delim byte) (line string, err error)
</pre>
<pre class="item">
func (b *Writer) WriteString(s string) (n int, err error)
</pre>
<p> ReadBytes と ReadString は引数 delim で指定した区切り文字までデータを読み込みます。ReadBytes は読み込んだデータをスライスに格納して返します。ReadString は文字列にして返します。どちらのメソッドも区切り文字は捨てずにスライス (または文字列) に格納することに注意してください。
</p>
<p> WriteString は引数の文字列 s を出力します。なお、Reader と Writer には File と同じ型のメソッド Read と Write が定義されているので、スライスに格納されているデータを出力することは Write を使って簡単に行うことができます。
</p>
<p> echo.go を ReadString, WriteString を使って書き直すと次のようになります。
</p>
<pre class="list">
リスト : echo (echo2.go)

package main

import (
    "os"
    "io"
    "bufio"
)

func main() {
    r := bufio.NewReader(os.Stdin)
    w := bufio.NewWriter(os.Stdout)
    for {
        s, err := r.ReadString('\n')
        if err == io.EOF { break }
        w.WriteString(s)
        w.Flush()
    }
}
</pre>
<p> このように、ReadString で区切り文字に '\n' を指定すれば、行単位でファイルの読み書きを行うことができます。
</p>

<h4>●Windows の改行文字</h4>
<p> 一般に、テキストファイルの「行」は改行文字で区切られます。改行文字は OS によって異なります。'\n' (0x0a) までを 1 行とする仕様は UNIX 系 の OS で、Windows は '\r\n' (0x0d, 0x0a) の 2 バイトで改行を表します。
</p>

<p> この違いを吸収するため、たとえばＣ言語では、ファイルのアクセスモードに「テキストモード」と「バイナリモード」が用意されています。次に示すように、テキストモードでは改行コードの変換が行われます。
</p>
<pre class="item">
読み込み時： '\r\n' ─→  '\n'
書き込み時： '\n'   ─→  '\r\n'
</pre>
<p> バイナリモードの場合、改行コードの変換は行われません。
</p>

<p> ところが Go 言語の場合、Windows でも改行文字の扱いは UNIX 系の OS と同じようです。たとえば、ReadString('\n') で 1 行読み込むと文字列の末尾には '\r\n' が付きます。逆に、Println で出力される改行文字は '\n' だけです。プログラムによっては、改行文字の違いで問題が発生する場合があるかもしれません。ご注意くださいませ。
</p>

<h4>●ファイルのアクセス方法</h4>
<p> 標準入出力を使わずにファイルにアクセスする場合、次の 3 つの操作が基本になります。
</p>

<OL>
  <LI>アクセスするファイルをオープンする
  <LI>入出力関数（メソッド）を使ってファイルを読み書きする。
  <LI>ファイルをクローズする。
</OL>

<p> 「ファイルをオープンする」とは、アクセスするファイルを指定して、それと一対一に対応するファイルディスクプリタを生成することです。入出力関数は、そのファイルディスクプリタを経由してファイルにアクセスします。
</p>

<p> ファイルをオープンするには関数 os.Open と os.Create を使います。
</p>
<pre class="item">
func Open(name string) (file *File, err error)
func Create(name string) (file *File, err error)
</pre>
<p> Open は引数 name で指定されたファイルをリードモードでオープンします。Create はライトモードでオープンします。正常にファイルをオープンできた場合、返り値は File 構造体へのポインタ *File と nil です。エラーが発生した場合は err に nil 以外の値がセットされます。リードモードの場合、ファイルが存在しないとエラーになります。ライトモードの場合、ファイルが存在すれば、そのファイルのサイズを 0 に切り詰めてからオープンします。
</p>

<p> オープンしたファイルは必ずクローズしてください。それを行うメソッドが os.Close です。
</p>
<pre class="item">
func (f *File) Close() error
</pre>
<p> 正常にファイルをクローズした場合、返り値は nil になります。
</p>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : ファイルのオープンとクローズ

package main

import "os"

func main() {
    input, err := os.Open("testin.txt")
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    output, _ := os.Create("testout.txt")
    buff := make([]byte, 256)
    for {
        c, _ := input.Read(buff)
        if c == 0 { break }
        output.Write(buff[:c])
    }
    input.Close()
    output.Close()
}
</pre>
<p> 最初に testin.txt をリードモードでオープンします。err が nil でない場合、fmt.Fprintln で os.Stderr にエラーメッセージを出力して os.Exit(1) でプログラムを終了します。
</p>
<p> Fprint, Fprintln は第 1 引数の io.Writer にデータを書き込む関数です。
</p>
<pre class="item">
func Fprint(w io.Writer, a... interface{}) (n int, err error)
func Fprintln(w io.Writer, a... interface{}) (n int, err error)
</pre>
<p> Exit はプログラムの実行を終了する関数です。引数はプログラムの終了コードを表していて、正常に終了した場合は 0 を、異常終了した場合は 0 以外の値、一般的には 1 を返すことが多いです。
</p>
<p> あとは for ループで testin.txt からデータを読み込み、それを testout.txt へ書き込みます。最後に Close でファイルをクローズします。これで testin.txt を testout.txt にコピーすることができます。
</p>

<h4>●コマンドライン引数の取得</h4>
<p> Go 言語の場合、パッケージ os の変数 Args にコマンドラインで与えられた引数が格納されています。次のリストを見てください。
</p>
<pre class="list">
リスト : 変数 Args の表示 (sample111.go)

package main

import (
    "fmt"
    "os"
)

func main() {
    fmt.Println(os.Args)
}
</pre>
<p> sample111.go は変数 Args の内容を表示するだけです。3 つの引数を与えて起動すると、次のように表示されます。
</p>

<pre>
C&gt;go build sample111.go

C&gt;sample111 foo bar baz
[sample112 foo bar baz]
</pre>

<p> スライスの先頭要素は実行したファイル名 (sample111) になることに注意してください。
</p>
<p> 簡単な例として、複数のファイルを表示するコマンド cat を作ってみましょう。
</p>
<pre class="list">
リスト : ファイルの表示 (cat.go)

package main

import (
    "os"
    "fmt"
    "io"
    "bufio"
)

func cat(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    rd := bufio.NewReader(file)
    for {
        s, err := rd.ReadString('\n')
        if err == io.EOF { break }
        fmt.Print(s)
    }
    file.Close()
}

func main() {
    for _, name := range os.Args[1:] {
        cat(name)
    }
}
</pre>
<p> Args[1:] でファイル名を格納したスライスを取り出し、そこから for ループでファイル名を取得して関数 cat を呼び出します。cat は filename をリードモードでオープンします。ファイルが見つからない場合はエラー終了します。あとは、NewReader で Reader を生成して、for ループで 1 行ずつ読み込んで、それを Print で標準出力へ書き込むだけです。最後に file をクローズします。
</p>

<h4>●ReadFile と WriteFile</h4>
<p> パッケージ io/ioutil の関数 ReadFile を使うと、ファイルをすべて読み込んでスライス [ ]byte に格納して返します。ファイルのオープンとクロースは ReadFile が行ってくれます。関数 WriteFile はスライス [ ]byte の全データをファイルに書き込みます。
</p>
<pre class="item">
func ReadFile(name string) (b []byte, err error)
func WriteFile(name string, b []byte, perm os.FileMode) error
</pre>
<p> WriteFile の引数 perm はパーミッションを整数値で指定します。os.FileMode は uint32 の別名です。UNIX 系の OS では、8 進数でパーミッションを指定します。たとえば 0644 とすると、そのファイルに対して所有者は読み書きすることができて、グループに所属する人と他の全員には読むことだけが許可されます。
</p>

<p> 関数 ReadFile を使うと、cat はとても簡単にプログラムすることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : ファイルの表示 (2)

package main

import (
    "os"
    "fmt"
    "io/ioutil"
)

func cat(filename string) {
    buff, err := ioutil.ReadFile(filename)
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    os.Stdout.Write(buff)
}

func main() {
    for _, name := range os.Args[1:] {
        cat(name)
    }
}
</pre>
<p> ReadFile でファイル filename のデータをすべて読み込み、それを Write で標準出力へ書き込むだけです。最近のパソコンはハイスペックなので、よほど大きなファイルでなければ、ReadFile でデータをすべて読み込んで処理することは十分に可能だと思います。
</p>

<h4>●書式付き出力 Printf</h4>
<p> Print, Fprint はデータをそのまま出力しますが、整形して出力したい場合は書式付き出力関数 Printf, Fprintf を使います。これはＣ言語の標準ライブラリ関数 printf と同様の機能です。
</p>
<pre class="item">
func Printf(format string, a... interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a... interface{}) (n int, err error)
</pre>
<p> 引数の文字列 format を書式文字列といい、出力に関する様々な指定を行います。書式文字列はそのまま文字列として扱われますが、文字列の途中にパーセント % が表れると、その後ろの文字を変換指示子として解釈し、引数に与えられたデータをその指示に従って表示します。
</p>

<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 整数の出力 (sample112.go)

package main

import "fmt"

func main() {
    fmt.Printf("%d, %x, %o\n", 100, 100, 100)
    fmt.Printf("[%d]\n", 10)
    fmt.Printf("[%4d]\n", 10)
    fmt.Printf("[%4d]\n", 100000)
    fmt.Printf("[%4d]\n", 123456)
    fmt.Printf("[%-8d]\n", 123456)
    fmt.Printf("[%08d]\n", 123456)
}
</pre>
<pre>
C&gt;go run sample112.go
100, 64, 144
[10]
[  10]
[123456]
[123456  ]
[00123456]
</pre>

<p> % の次の文字 d, x, o が変換指示子です。これらの指示子は整数値を表示する働きをします。例が示すように、d は 10 進数、x は 16 進数、o は 8 進数で表示します。変換指示子の個数と与えるデータの数が合わないとエラーになるので注意してください。% を出力したい場合は %% と続けて書きます。
</p>

<p> % と変換指示子の間にオプションでいろいろな設定を行うことができます。整数値を表示する変換指示子の場合、データを表示するフィールドの桁数を指定することができます。%d はフィールド幅を指定しない場合で、%4d がフィールド幅を 4 に指定した場合です。10 ではフィールド幅に満たないので、右詰めに出力されています。もし、フィールド幅に収まらない場合は、指定を無視して数値を出力します。フィールド幅を 0 で埋めたい場合は、フィールド桁数の前に 0 を指定します。左詰めにしたい場合は、フィールド桁数の前に - を指定します。
</p>

<p> v 変換子は Go 言語の任意のデータをデフォルトの形式で表示します。構造体を表示するとき、v の前に + を付けるとフィールド名も出力されます。# を付けると、値を Go 言語の構文で表示します。T 変換子は値の型を表示します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 任意のデータと型の表示 (sample113.go)

package main

import "fmt"

type Foo struct {
    bar, baz int
}

func main() {
    a := 123456789
    b := Foo{10, 20}
    fmt.Printf("%v\n", a)
    fmt.Printf("%T\n", a)
    fmt.Printf("%v\n", b)
    fmt.Printf("%+v\n", b)
    fmt.Printf("%#v\n", b)
    fmt.Printf("%T\n", b)
}
</pre>
<pre>
C&gt;go run sample113.go
123456789
int
{10 20}
{bar:10 baz:20}
main.Foo{bar:10, baz:20}
main.Foo
</pre>

<p> s 変換子は文字列または byte 型のスライス ([ ]byte) を表示します。q 変換子は Go 言語の構文で文字列または byte 型のスライスを表示します。s, q 変換子の場合でも、フィールド幅を指定することができます。簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 文字列の表示 (sample114.go)

package main

import "fmt"

func main() {
    a := "hello, world"
    fmt.Printf("[%s]\n", a)
    fmt.Printf("[%20s]\n", a)
    fmt.Printf("[%-20s]\n", a)
    fmt.Printf("[%q]\n", a)
    fmt.Printf("[%20q]\n", a)
    fmt.Printf("[%-20q]\n", a)
}
</pre>
<pre>
C&gt;go run sample114.go
[hello, world]
[        hello, world]
[hello, world        ]
["hello, world"]
[      "hello, world"]
["hello, world"      ]
</pre>

<p> このほかにも、変換した結果を文字列にして返す関数や浮動小数点数を表示する変換子など、fmt パッケージにはいろいろな機能があります。詳細は Go 言語 fmt パッケージのマニュアルをお読みください。
</p>

<h4>●Scan と Fscan</h4>
<p> ファイルからデータを読み込む場合、データを文字列やスライス ([ ]byte) ではなく数値や他の型に変換できると便利です。Go 言語の場合、fmt パッケージの関数 Scan と Fscan を使うと、入力データの変換を簡単に行うことができます。
</p>
<pre class="item">
func Scan(a... interface{}) (n int, err error)
fnnc Fscan(r io.Reader, a... interface{}) (n int, err error)
</pre>
<p> Scan は標準入力から、Fscan は io.Reader からデータを読み込み、可変長引数で指定された変数の型に従ってデータ変換を行い、その値を変数に格納します。可変長引数に渡す引数はポインタ変数でなければいけません。Scan と Fscanf はデータが空白文字 (改行やタブも含む) で区切られていることを前提に動作します。返り値は変換に成功したデータ数で、正常に変換できない場合は err に nil 以外の値がセットされます。
</p>

<p> 簡単な使用例を示します。
</p>

<pre class="list">
リスト : Scan の使用例 (sample115.go)

package main

import (
    "fmt"
    "io"
    "os"
)

func main() {
    sumi := 0
    sumf := 0.0
    suma := make([]string, 0)
    for {
        var n int
        var m float64
        var s string
        i, err := fmt.Scan(&amp;n, &amp;m, &amp;s)
        if i == 3 {
            sumi += n
            sumf += m
            suma = append(suma, s)
        } else if i == 0 &amp;&amp; err == io.EOF {
            break
        } else {
            fmt.Fprintln(os.Stderr, err)
            os.Exit(1)
        }
    }
    fmt.Println(sumi, sumf, suma)
}
</pre>
<p> 整数、実数、文字列が順番に格納されているファイルを読み込み、整数の合計値、実数の合計値を求め、文字列はスライスに格納して表示します。sumi, sumf, は整数と実数の合計値、suma は文字列を格納するスライスです。
</p>
<p> for ループの中で、読み込んだデータを格納する変数 n, m, s を宣言します。そして、Scan にそれらの変数へのポインタを渡します。返り値 i が 3 ならば、正常にデータを読み込むことができました。n, m は sumi, sumf に加算し、s は append で suma に追加します。i が 0 で err が io.EOF の場合、ファイルを最後まで読み込みました。break で for ループを脱出します。それ以外の場合はエラーが発生したので、エラーメッセージを表示してプログラムを終了します。
</p>
<p> それでは簡単な実行例を示します。
</p>
<pre class="fig">
10 1.234 foo
20 5.678 bar
30 9.876 baz

図 : test.dat
</pre>
<pre>
C&gt;go run sample115.go &lt; test.dat
60 16.788 [foo bar baz]
</pre>
<h4>●書式付き入力 Scanf</h4>
<p> Scanf と Fscanf は Printf と Fprintf の入力バージョンです。
</p>
<pre class="item">
func Scanf(fromat string, a... interface{}) (n int, err error)
func Fscanf(r io.Reader, fromat string, a... interface{}) (n int, err error)
</pre>
<p> 書式文字列の変換指示子は、基本的には書式付き出力と同じです。変換指示子以外の文字は入力データと照合されます。このとき、改行文字 ('\n') 以外の空白文字は区切り文字として扱われ、書式文字列と入力データともに、連続した空白文字は 1 文字の空白文字になります。それ以外の文字で照合に失敗したら変換は失敗します。ただし、改行文字は空白文字として扱われないので、1 行ずつ読み込む場合は書式文字列の最後に改行文字を指定する必要があります。
</p>
<p> たとえば、カンマで区切られたデータを読み込むプログラムは次のようになります。
</p>
<pre class="list">
リスト : Scanf の使用例 (sample116.go)

package main

import (
    "fmt"
    "os"
)

func main() {
    sumi := 0
    sumf := 0.0
    suma := make([]string, 0)
    for {
        var n int
        var m float64
        var s string
        i, err := fmt.Scanf("%d,%f,%q\n", &amp;n, &amp;m, &amp;s)
        if i == 3 {
            sumi += n
            sumf += m
            suma = append(suma, s)
        } else if i == 0 {
            break
        } else {
            fmt.Fprintln(os.Stderr, err)
            os.Exit(1)
        }
    }
    fmt.Println(sumi, sumf, suma)
}
</pre>
<p> 書式文字列の %f は浮動小数点数を表す変換指示子です。
</p>
<p> それでは簡単な実行例を示します。
</p>
<pre class="fig">
10,1.234,"foo"
20,5.678,"bar"
30,9.876,"baz"

図 : test1.dat
</pre>
<pre>
C&gt;go run sample116.go &lt; test1.dat
60 16.788 [foo bar baz]
</pre>

<p> このほかにも、文字列からデータを読み込む関数など、fmt パッケージにはいろいろな機能があります。詳細は Go 言語 fmt パッケージのマニュアルをお読みください。
</p>

<h4>●ファイルを行単位で連結する</h4>
<p> 最後に簡単な例題として、ファイルを行単位で連結するコマンドを作りましょう。名前は join.go としました。動作例を図に示します。
</p>

<pre class="fig">
C&gt;type file1.txt
abcd
efgh
ijkl

C&gt;type file2.txt
ABCD
EFGH
IJKL

C&gt;join file1.txt file2.txt
abcdABCD
efghEFGH
ijklIJKL

図 : 行単位でファイルを連結する
</pre>

<p> join.go は 2 つのファイル file1.txt と file2.txt の各行を連結して標準出力へ出力します。この場合、2 つのファイルを同時にオープンしなければいけませんが、近代的なプログラミング言語であれば特別なことをしなくても複数のファイルを扱うことができます。
</p>

<p> 2 つのファイルをリードモードでオープンし、それから 2 つの Reader を生成します。生成された Reader を別々の変数 file1, file2 にセットします。変数 file1 に ReadString を適用すれば、ファイル 1 から 1 行分データをリードすることができます。同様に、変数 file2 に ReadString を適用すれば、ファイル 2 からデータをリードできるのです。あとは、文字列を連結して標準出力へ出力すればいいわけです。
</p>

<p> ただし、一つだけ注意点があります。それは、2 つのファイルの行数は同じとは限らないということです。つまり、どちらかのファイルが先に終了する場合があるのです。この場合は、残ったファイルをそのまま出力します。処理内容を下図に示します。
</p>

<pre class="fig">
                              ↓
                      ┌───────┐
                      │file 1,2 open │
                      └───────┘
                              ├←────┐
                              ↓          │
      ┌─────┐ EOF┌─────┐    │
┌←─│file2 出力│←─│file1 read│    │
│    └─────┘    └─────┘    │
│                            ↓          │
│    ┌─────┐ EOF┌─────┐    │
│    │文字列出力│←─│file2 read│    │
│    └─────┘    └─────┘    │
│          ↓                ↓          │
│    ┌─────┐   ┌──────┐   │
├←─│file1 出力│   │連結して出力│   │
│    └─────┘   └──────┘   │
│                            ↓          │
↓                            └─────┘
└──────────────┐
                              ↓

                  図 : 処理の流れ
</pre>

<p> ファイル 1 が終了した場合は、ファイル 2 をそのまま出力します。ファイル 2 が終了した場合は、ファイル 1 をそのまま出力しますが、その前に入力したファイル 1 のデータが残っているので、読み込んだデータを出力することをお忘れなく。
</p>

<p> それでは、プログラムを作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 行の結合

package main

import (
    "os"
    "io"
    "bufio"
    "fmt"
)

func outputFile(file *bufio.Reader) {
    for {
        s, err := file.ReadString('\n')
        if err == io.EOF { break }
        fmt.Print(s)
    }
}

func join(file1 *bufio.Reader, file2 *bufio.Reader) {
    for {
        s1, err1 := file1.ReadString('\n')
        if err1 == io.EOF {
            outputFile(file2)
            break
        }
        s2, err := file2.ReadString('\n')
        if err == io.EOF {
            fmt.Print(s1)
            outputFile(file1)
            break
        }
        // Windows の改行は \r\n
        fmt.Print(s1[:len(s1) - 2] + s2)
    }
}

func main() {
    if len(os.Args) &lt; 3 {
        fmt.Fprint(os.Stderr, "not enough args\n")
        os.Exit(1)
    }
    file1, err1 := os.Open(os.Args[1])
    if err1 != nil {
        fmt.Fprint(os.Stderr, err1)
        os.Exit(1)
    }
    file2, err2 := os.Open(os.Args[2])
    if err2 != nil {
        fmt.Fprint(os.Stderr, err2)
        os.Exit(1)
    }
    join(bufio.NewReader(file1), bufio.NewReader(file2))
    file1.Close()
    file2.Close()
}
</pre>

<p> main で引数の個数をチェックし、ファイル名が 2 つ指定されていない場合はエラーを表示して終了します。次に、ファイル Args[1] と Args[2] をオープンします。オープンできない場合はエラーを表示して終了します。それから、NewReader で Reader を生成して、それらを関数 join に渡して呼び出します。最後に、Close でオープンしたファイルをクローズします。
</p>

<p> 関数 join は簡単です。file1 から ReadString で 1 行読み込みます。ファイルが終了した場合は関数 outputFile で file2 を出力してから break で for ループを脱出します。次に、file2 から 1 行読み込みます。ファイルが終了した場合は、file1 の文字列 s1 を出力してから outputFile で file1 を出力します。そうでなければ、文字列 s1 と s2 を連結して出力します。このとき、s1 の改行文字を取り除きます。今回は Windows 専用になりますが、末尾から 2 文字 (\r\n) 取り除きます。UNIX 系の OS であれば 1 文字取り除くだけです。
</p>
<p> 関数 outputFile も簡単で、ファイルの最後まで 1 行ずつ読み込んで、それを Print で出力するだけです。これでプログラムは完成です。実際に試して動作を確認してみてください。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo10.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo12.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>