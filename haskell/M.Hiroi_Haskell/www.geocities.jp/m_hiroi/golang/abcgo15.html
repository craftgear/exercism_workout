<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881805</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo14.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo16.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>エラー処理</h3>
<p> 今回は Go 言語のエラー処理について説明します。他のプログラミング言語、たとえばＣ++ や Java などには、try, throw, catch といったエラーを処理するための構文が用意されています。これを「例外処理」といいます。「例外＝エラー処理」と考えてもらってもかまいません。最近は例外処理を持っているプログラミング言語が多くなりました。Go 言語の場合、関数は多値を返すことができるので、エラーは簡単に報告することができます。このため、Go 言語には例外処理専用の構文はないのですが、組み込み関数 panic, recover と defer 文を使って例外処理と似たような動作を行わせることができます。
</p>

<h4>●エラーの返し方</h4>
<p> Go 言語にはエラーを表すインターフェース error が定義されています。Go 言語でエラーを報告する場合、error を多値で返すことがよく行われます。
</p>
<pre class="list">
リスト : error の定義

type error interface {
    Error() string
}
</pre>
<p> メソッド Error はエラーメッセージを文字列として返します。Print や Println は error を受け取るとメソッド Error を呼び出して、返り値の文字列を表示します。
</p>

<p> パッケージ errors の関数 New もしくはパッケージ fmt の関数 Errorf を使うと、簡単にエラーを返すことができます。
</p>
<pre class="item">
func New(text string) error
</pre>
<p> 関数 errors.New は引数 text を格納した構造体 (非公開) へのポインタを返します。この構造体にはメソッド Error が定義されているので、error 型として扱うことができます。
</p>
<pre class="item">
func Errorf(format string, args... interface{}) error
</pre>
<p> 関数 fmt.Errorf は fmt.Sprintf と errors.New を組み合わせたもので、書式文字列 format に従って変数 args を整形し、その結果を文字列に変換して errors.New に渡します。
</p>

<p> 簡単な例として、階乗を求める関数 fact で引数の範囲チェックを行うことにします。次のリストを見てください。
</p>
<pre class="list">
リスト : エラーの返し方 (sample1501.go)

package main

import (
    "fmt"
    "errors"
)

// 階乗
func fact(n int) (int, error) {
    if n &lt; 0 {
        return 0, errors.New("fact : domain error")
    }
    a := 1;
    for ; n &gt; 1; n-- {
        a *= n
    }
    return a, nil
}

func main() {
    for x := 10; x &gt;= -1; x-- {
        v, err := fact(x)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(v)
        }
    }
}
</pre>
<p> 関数 fact は int と error を多値で返します。引数 n が負の場合、int のゼロ値 0 と error を返します。error は errors.New で生成します。n が正常の範囲であれば、階乗を計算して、その結果 a と nil を返します。main では fact の返り値 err をチェックして、err が nil でなければ fmt.Println(err) でエラーメッセージを表示します。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;go run sample1501.go
3628800
362880
40320
5040
720
120
24
6
2
1
1
fact : domain error
</pre>
<p> このように、Go 言語は多値を使ってエラーを返すことができます。
</p>
<p> なお、自分でエラーを定義することも簡単にできます。次のリストを見てください。
</p>
<pre class="list">
リスト : エラーの返し方 (2)

package main

import "fmt"

// エラーの定義
type MyError struct {
    msg string
}

// エラーの生成
func newMyError(s string) *MyError {
    err := new(MyError) //
    err.msg = s         //
    return err          // return &amp;MyError{s} でもよい
}

// メソッドの定義
func (err *MyError) Error() string {
    return err.msg
}

// 階乗
func fact(n int) (int, error) {
    if n &lt; 0 {
        return 0, newMyError("fact : domain error")
    }
    a := 1;
    for ; n &gt; 1; n-- {
        a *= n
    }
    return a, nil
}

func main() {
    for x := 10; x &gt;= -1; x-- {
        v, err := fact(x)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(v)
        }
    }
}
</pre>
<p> エラーメッセージを格納する構造体 MyError を定義します。関数 newMyError は new で MyError のメモリを確保し、引数の文字列 s をフィールド変数 msg にセットします。なお、new を使わずに &amp;MyError{s} を return で返しても、メモリを動的に確保することができます。メソッド Error は MyError のフィールド変数 msg の値を返すだけです。これで MyError は error と同じ型として扱うことができます。関数 fact では、errors.New のかわりに newMyError を呼び出してエラーを生成します。
</p>

<h4>●panic</h4>
<p> 組み込み関数 panic はプログラムの実行を中断するランタイムエラーを生成します。
</p>
<pre class="item">
panic(err interface{})
</pre>
<p> panic に渡された引数 err はプログラムをエラー終了するとき画面に出力されます。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : panic の使用例 (sample1502.go)

package main

import "fmt"

// 階乗
func fact(n int) (int, error) {
    if n &lt; 0 {
        panic("fact : domain error")
    }
    a := 1;
    for ; n &gt; 1; n-- {
        a *= n
    }
    return a, nil
}

func main() {
    for x := 10; x &gt;= -1; x-- {
        v, err := fact(x)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(v)
        }
    }
}
</pre>
<p> 関数 fact は引数 n が負の場合、panic でランタイムエラーを生成します。panic を実行すると、画面にエラー情報を表示して、プログラムの実行を終了します。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;go run sample1502.go
3628800
362880
40320
5040
720
120
24
6
2
1
1
panic: fact : domain error

・・・エラー情報 (省略) ・・・

exit status 2
</pre>
<h4>●defer 文</h4>
<p> defer 文は関数の終了時に実行する処理を指定します。
</p>
<pre class="item">
defer 処理
</pre>
<p> defer 文で指定する処理は関数またはメソッド呼び出しでなければなりません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : defer 文の使用例 (sample1503.go)

package main

import "fmt"

func bar() {
    defer fmt.Println("bar end")
    fmt.Println("bar start!")
}

func foo() {
    defer fmt.Println("foo end")
    fmt.Println("foo start!")
    bar()
}

func main(){
    foo()
}
</pre>
<pre>
C&gt;go run sample1503.go
foo start!
bar start!
bar end
foo end
</pre>
<p> 関数 foo と bar は defer でメッセージを表示する処理を指定します。foo から bar を呼び出して、bar の実行が終了すると defer で指定した処理が実行されて bar end が表示されます。そのあと foo に戻ってきて foo の実行が終了すると、defer で指定した処理が実行されて foo end が表示されます。
</p>
<p> defer 文の指定は、ランタイムエラーで関数の実行が中断された場合にも有効です。次のリストを見てください。
</p>
<pre class="list">
リスト : defer 文の使用例 (sample1504.go)

package main

import "fmt"

func baz(){
    panic("oops!")
}

func bar() {
    defer fmt.Println("bar end")
    fmt.Println("bar start!")
    baz()
}

func foo() {
    defer fmt.Println("foo end")
    fmt.Println("foo start!")
    bar()
}

func main(){
    foo()
}
</pre>
<pre>
C&gt;go run sample1504.go
foo start!
bar start!
bar end
foo end
panic: oops!

・・・省略・・・

exit status 2
</pre>
<p> 関数 bar から関数 baz を呼び出し、baz の中で panic を実行します。ランタイムエラーが発生すると、Go 言語は関数の呼び出し履歴 (スタック) をたどり、呼び出した関数に defer 文の記述があれば、その処理を実行します。
</p>
<p> baz で panic を実行したとき、関数は main -&gt; foo -&gt; bar -&gt; baz の順番で呼び出されているので、baz, bar, foo, main の順番で defer 文の記述があるかチェックします。bar と foo には defer 文があるので、bar の defer 文の処理を実行して bar end が表示され、そのあと foo end が表示されます。最後に、ランタイムエラーのメッセージが表示されてプログラムの実行が終了します。
</p>

<h4>●ランタイムエラーの捕捉</h4>
<p> ところで、ランタイムエラーが発生するたびにプログラムをエラー終了するのではなく、致命的なエラーでなければプログラムの実行を継続したい場合もあるでしょう。Go 言語では組み込み関数 recover と defer 文を使ってランタイムエラーを捕まえることができます。
</p>
<pre class="item">
func recover() interface{}
</pre>
<p> recover は defer 文で指定した処理の中で使います。recover を実行すると、関数の呼び出し履歴をたどるのをやめて、panic に渡された引数を返します。エラーが発生していない場合、recover は nil を返します。defer 文の処理が終了すると、その関数の呼び出し元に戻ってプログラムの実行を継続します。
</p>

<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : recover の使用例 (sample1505.go)

package main

import "fmt"

func baz(){
    panic("oops!")
}

func bar() {
    defer fmt.Println("bar end")
    fmt.Println("bar start!")
    baz()
}

func foo() {
    defer func(){
        fmt.Println("foo end")
        err := recover()
        if err != nil {
            fmt.Println(err)
        }
    }()
    fmt.Println("foo start!")
    bar()
}

func main(){
    fmt.Println("main start!")
    foo()
    fmt.Println("main end")
}
</pre>

<pre>
C&gt;go run sample1505.go
main start!
foo start!
bar start!
bar end
foo end
oops!
main end
</pre>
<p> 関数 foo の defer 文の処理は匿名関数で、その中で recover を呼び出しています。関数 baz で panic を実行すると、foo の recover で捕捉されて、変数 err には "oops!" がセットされます。foo end と oops! を表示したあと、foo を呼び出した main に戻ってプログラムの実行を継続するので、main end が表示されます。recover でエラーを捕捉しないとプログラムはエラー終了するので、main end は表示されません。
</p>

<h4>●返り値がある関数でエラーを捕捉する</h4>
<p> 返り値がある関数でエラーを捕捉する場合は注意が必要です。関数 foo を次のように修正します。
</p>
<pre class="list">
リスト : 返り値がある関数でエラーを捕捉 (sample1506.go)

func foo(n int) int {
    defer func(){
        fmt.Println("foo end")
        err := recover()
        if err != nil {
            fmt.Println(err)
        }
    }()
    fmt.Println("foo start!")
    bar()
    return n * n
}

func main(){
    fmt.Println("main start!")
    fmt.Println(foo(10))
    fmt.Println("main end")
}
</pre>
<pre>
C&gt;go run sample1506.go
main start!
foo start!
bar start!
bar end
foo end
oops!
0
main end
</pre>
<p> 関数 foo は整数値 n * n を返します。ところが、bar の実行中にランタイムエラーが発生すると、return n * n は実行されません。この場合、foo の返り値はゼロ値 (0) になります。エラーを捕捉したあと、ゼロ値以外の値を返したい場合は、返り値の型で変数名を指定して、その変数に値をセットします。次の例を見てください。
</p>

<pre class="list">
リスト : 返り値がある関数でエラーを捕捉 (sample1507.go)

func foo(n int) (m int) {
    defer func(){
        fmt.Println("foo end")
        err := recover()
        if err != nil {
            fmt.Println(err)
            m = -1
        }
    }()
    fmt.Println("foo start!")
    bar()
    m = n * n
    return
}
</pre>
<pre>
C&gt;go run sample1507.go
main start!
foo start!
bar start!
bar end
foo end
oops!
-1
main end
</pre>
<p> foo は変数 m の値を返します。bar の実行でエラーがない場合は n * n を返します。エラーが発生した場合は defer 文の匿名関数の中で m に -1 をセットします。これで -1 を返すことができます。
</p>

<h4>●特定のエラーを捕捉する</h4>
<p> 特定のエラーだけを捕捉してプログラムの実行を継続することもできます。次のリストを見てください。
</p>
<pre class="list">
リスト : 特定のエラーを捕捉する (sample1508.go)

package main

import "fmt"

// エラーの定義
type MyError struct {
    msg string
}

// エラーの生成
func newMyError(s string) *MyError {
    err := new(MyError)
    err.msg = s
    return err
}

// メソッドの定義
func (err *MyError) Error() string {
    return err.msg
}

func baz1(){
    panic(newMyError("oops!"))
}

func baz2(){
    panic("oops!")
}

func bar(f func()) {
    defer fmt.Println("bar end")
    fmt.Println("bar start!")
    f()
}

func foo(f func()) {
    defer func(){
        fmt.Println("foo end")
        err := recover()
        if err != nil {
            v := err.(*MyError)
            fmt.Println(v)
        }
    }()
    fmt.Println("foo start!")
    bar(f)
}

func main(){
    fmt.Println("main start!")
    foo(baz1)
    foo(baz2)
    fmt.Println("main end")
}
</pre>
<p> 関数 foo の defer 文の匿名関数でエラーを捕捉します。このとき、型アサーションを使って err が *MyError かチェックします。そうであれば、エラーメッセージを表示してプログラムの実行を継続します。err が *MyError でなければ、型アサーションに失敗してエラーが発生するので、プログラムはエラー終了します。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;go run sample1508.go
main start!
foo start!
bar start!
bar end
foo end
oops!
foo start!
bar start!
bar end
foo end
panic: oops! [recovered]
        panic: interface conversion: interface is string, not *main.MyError

・・・省略・・・

exit status 2
</pre>
<p> foo(baz1) の呼び出しは MyError を返すので、oops! を表示したあとプログラムの実行は継続されます。このあと、foo(baz2) が呼び出されますが、baz2 では panic に文字列 "oops!" を渡して呼び出しているので、foo の defer 文で型アサーションに失敗します。エラー情報を表示したあと、プログラムはエラー終了するので main end は表示されません。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">パッケージ</h3>
<p> プログラムを作っていると、以前作った関数と同じ処理が必要になる場合があります。いちばんてっとり早い方法はソースファイルからその関数をコピーすることですが、賢明な方法とはいえません。このような場合、自分で作成した関数をライブラリとしてまとめておくと便利です。ライブラリの作成で問題になるのが「名前の衝突」です。複数のライブラリを使うときに、同じ名前の関数や変数が存在すると、そのライブラリは正常に動作しないでしょう。この問題は「パッケージ (package) 」を使うと解決することができます。
</p>

<h4>●パッケージの簡単な使い方</h4>
<p> パッケージを作成する場合、環境変数 GOPATH の設定が必要になりますが、それはあとで説明することにして、ここではパッケージの簡単な使い方を紹介しましょう。
</p>
<p> Go 言語のパッケージはディレクトリで管理します。ディレクトリを作成して、そこにソースファイルを格納すれば、それをパッケージとして使用することができます。このとき、ディレクトリ名がパッケージ名になります。ディレクトリ名とソースファイル名は異なっていてもかまいません。ディレクトリの中に複数のソースファイルがある場合、それらをまとめたものが一つのパッケージになります。
</p>

<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : foo/foo.go

package foo

import "fmt"

const (
    A = 10
)

func Test() {
    fmt.Println("package foo")
}
</pre>
<pre class="list">
リスト : bar/bar.go

package bar

import "fmt"

const (
    A = 100
)

func Test() {
    fmt.Println("package bar")
}
</pre>
<p> カレントディレクトリにディレクトリ foo を作成し、その中にファイル foo.go を格納します。同様に、ディレクトリ bar を作成して、ファイル bar.go を格納します。ファイルの先頭には package 文でパッケージ名を記述します。foo.go と bar.go は main パッケージではないので、関数 main は必要ありません。パッケージの中で英大文字から始まる名前 (関数、変数、定数、構造体名、フィールド名など) が外部に公開されます。これを「エクスポート (export) 」といいます。
</p>

<p> パッケージを利用する場合は import 文を使います。パッケージ foo と bar はカレントディレクトリにあるので、次のように指定します。
</p>
<pre class="list">
リスト : パッケージのインポート

import (
    "./foo"
    "./bar"
)
</pre>
<p> パッケージの指定はディレクトリのパス指定と同じです。ただし、パスの区切り記号は Windows でもスラッシュ / を使ってください。"foo", "bar" のように指定すると、Go 言語をインストールしたディレクトリ (C:\go) や、環境変数 GOPATH で指定したディレクトリを探します。
</p>
<p> 実行例は次のようになります。
</p>
<pre class="list">
リスト : パッケージの使用例

package main

import (
    "fmt"
    "./foo"
    "./bar"
)

func main() {
    foo.Test()
    fmt.Println("foo.A =", foo.A)
    bar.Test()
    fmt.Println("bar.A =", bar.A)
}
</pre>
<pre>
C&gt;go run sample1506.go
package foo
foo.A = 10
package bar
bar.A = 100
</pre>
<p> 最初に import で foo と bar をインポートします。あとは、パッケージ名 + "." + 名前で、関数や定数 (変数) にアクセスすることができます。foo.Test を実行すれば、package foo と表示され、bar.A の値を表示すると 100 になります。このように、パッケージを使うことで名前の衝突を回避することができます。
</p>

<p> foo と bar を一つのディレクトリに格納することもできます。次の図を見てください。
</p>
<pre class="fig">
./
    baz/
        foo/
            foo.go
        bar/
            bar.go
</pre>
<p> ディレクトリ baz の中にディレクトリ foo と bar があり、その中にソースファイル foo.go と bar.go があります。この場合、import 文のパスを次のように指定します。
</p>
<pre class="list">
import (
    "./baz/foo"
    "./baz/bar"
)
</pre>
<p> この場合でもパッケージ名は foo と bar になるので、アクセス方法は今までと同じです。baz.foo.Test() や baz.bar.A のように baz を指定する必要はありません。
</p>

<h4>●import 文の使い方</h4>
<p> import 文にはパッケージに別名を付ける機能があります。
</p>
<pre class="item">
import 別名 "パッケージ名"
</pre>
<p> たとえば、import f "./foo" とすると、foo.Test(), foo.A は f.Test(), f.A と書くことができます。
</p>
<p> また、別名にピリオド ( . ) を指定すると、インポートするパッケージで定義されている名前をそのまま自分のパッケージで利用することができます。たとえば、import . "./bar" とすると、bar.Test(), bar.A は Test(), A と書くことができます。名前の衝突がない場合は、パッケージ名を付けなくてすむので便利です。
</p>
<p> 簡単な例を示します。
</p>
<pre class="list">
リスト : パッケージに別名を付ける

package main

import (
    "fmt"
    f "./foo"
    . "./bar"
)

func main() {
    f.Test()
    fmt.Println("f.A =", f.A)
    Test()
    fmt.Println("A =", A)
}
</pre>
<pre>
C&gt;go run sample1507.go
package foo
f.A = 10
package bar
A = 100
</pre>
<p> パッケージ foo には f という別名を付け、パッケージ bar で公開されている名前は main パッケージにそのまま取り込みます。したがって、f.Test() は package foo を表示し、Test() は package bar を表示します。また、f.A の値は 10 になり、A の値は 100 になります。
</p>

<h4>●環境変数 GOPATH の設定とパッケージのコンパイル</h4>
<p> 環境変数 GOPATH はユーザが Go 言語でプログラムを開発するディレクトリを指定します。たとえば、M.Hiroi の環境では環境 GOPATH を次のように設定しています。
</p>
<pre class="item">
GOPATH=C:\Users\m_hiroi\go
</pre>
<p> このディレクトリに 3 つのサブディレクトリを作ります。次の図を見てください。
</p>
<pre class="fig">
GOPATH/
        src/
             foo/
                 foo.go
             bar/
                 bar.go
             sample/
                 main.go
        pkg　コンパイル済みのパッケージ
        bin  実行形式ファイル
</pre>
<p> src にはソースプログラムを格納します。コンパイル済みのパッケージは pkg に格納されます。実行形式ファイルは bin に格納されます。たとえば、パッケージ foo と bar は src の下にサブディレクトリ foo と bar を作成し、その中にソースファイル foo.go と foo.bar を格納します。
</p>

<p> main パッケージもサブディレクトリを作ってそこに格納します。たとえば、次に示すソースファイルをディレクトリ sample に格納します。
</p>
<pre class="list">
リスト : main.go

package main

import (
    "fmt"
    "foo"
    "bar"
)

func main() {
    foo.Test()
    fmt.Println("foo.A =", foo.A)
    bar.Test()
    fmt.Println("bar.A =", bar.A)
}
</pre>
<p> import 文の指定は "foo", "bar" で大丈夫です。sample ディレクトリで go run main.go とすると、Go 言語はディレクトリ foo と bar からソースファイルを読み込み、コンパイルしてプログラムを実行します。
</p>

<p> ディレクトリ foo や bar で go install を実行する、または他のディレクトリで go install foo や go install bar を実行すると、パッケージ内のソースファイルをコンパイルし、その結果をアーカイブ (foo.a, bar.a) にまとめて、pkg ディレクトリに格納します。
</p>

<p> sample ディレクトリで go build を実行すると、sample.exe という実行形式ファイルが作成されます。このとき、foo.go と bar.go がコンパイルされていなければ、それらをコンパイルして pkg にインストールします。go install を実行すると、main.go をコンパイルして、作成した sample.exe をディレクトリ bin に格納します。go build や go install は基本的にディレクトリにあるソースファイルをすべてコンパイルします。
</p>

<h4>●パッケージ tools の作成</h4>
<p> それでは簡単な例題として、パズルを解くときによく使う関数をまとめたパッケージ tools を作成してみましょう。関数の一覧表を示します。
</p>
<table border=1>
<caption>表 : tools の関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>func Equal(xs, ys []int) bool</td><td>xs と ys が等しければ true を返す</td></tr>
  <tr><td>func Dup(xs []int) []int</td><td>xs を複製する</td></tr>
  <tr><td>func Member(n int, xs []int) bool</td><td>n は xs に含まれているか</td></tr>
  <tr><td>func Position(n int, xs []int) int</td><td>n と等しい要素の位置を求める</td></tr>
  <tr><td>func Count(n int, xs []int) int</td><td>n と等しい要素を数える</td></tr>
  <tr><td>func Map(f func(int) int, xs []int) []int</td><td>xs の要素に関数 f を適用し、その結果を新しいスライスに格納して返す (マッピング)</td></tr>
  <tr><td>func Filter(f func(int) bool, xs []int) []int</td><td>関数 f が真を返す要素を新しいスライスに格納して返す (フィルター)</td></tr>
  <tr><td>func Fold(f func(int, int) int, a int, xs []int) int</td><td>xs の要素を関数 f で畳み込む</td></tr>
  <tr><td>func Remove(n int, xs []int) []int</td><td>n と等しい要素を取り除いた新しいスライスを返す</td></tr>
  <tr><td>func Permutation(f func([]int), n int, xs []int)</td><td>xs から n 個の要素を選ぶ順列を生成する</td></tr>
  <tr><td>func PermGen(n int, xs []int) &lt;-chan []int</td><td>xs から n 個の要素を選ぶ順列を生成するチャネルを返す</td></tr>
  <tr><td>func Combination(f func([]int), n int, xs []int)</td><td>xs から n 個の要素を選ぶ組み合わせを生成する</td></tr>
  <tr><td>func CombGen(n int, xs []int) &lt;-chan []int</td><td>xs から n 個の要素を選ぶ組み合わせを生成するチャネルを返す</td></tr>
</tbody>
</table>
<p> プログラムは簡単なので説明は割愛します。詳細は <a href="abcgo15.html#list1">プログラムリスト</a> をお読みください。
</p>

<h4>●パッケージのテスト</h4>
<p> パッケージを作成したら、それが正常に動作するかテストしましょう。Go 言語の場合、パッケージ testing とコマンド go test を使って、簡単にパッケージのテストを行うことができます。
</p>
<p> テストプログラムはパッケージとは別のファイルに書きます。ファイル名はパッケージ名の後ろに _test.go を付けたものになります。たとえば、tools.go のテストプログラムはファイル tools_test.go に書きます。テストを実行する関数は次のように定義します。
</p>
<pre class="item">
func TestXxx(t *testing.T)
</pre>
<p> 関数名は Test の後ろに英小文字以外から始まる名前 Xxx を付けます。たとえば、関数の単体テストであれば Xxx に関数名を付けます。今回はパッケージ tools のテストなので、関数名は TestTools としました。
</p>
<p> 引数の型 *testing.T にはテストで使用するメソッドが定義されていて、それらを使ってエラーの報告やテストの記録を残すことができます。たとえば、テストをパスしなかった場合は、メソッド Error でエラーを報告します。次のリストを見てください。
</p>
<pre class="list">
リスト : tools のテスト (tools_test.go)

package tools

import "testing"

func TestTools(t *testing.T) {
    a := []int{1,2,3,4,5}
    if Equal(a, []int{1,2,3,4,5}) != true {
        t.Error("Equal: not true")
    }
    if Equal(a, []int{1,2,0,4,5}) != false {
        t.Error("Equal: not false")
    }
    if Equal(a, []int{1,2,3,4,5,6}) != false {
        t.Error("Equal: not false")
    }
    if Equal(a, Dup(a)) != true {
        t.Error("Dup: error")
    }

    ・・・省略・・・

}
</pre>
<p> tools_test.go の package には tools.go と同じパッケージ名 tools を指定します。そして、パッケージ testing を import してください。
</p>
<p> 二つのスライスの等値を判定する関数 Equal に、等しいスライスを渡します。結果が true でなければテストには不合格です。t.Error でテストに失敗したことを報告します。異なるスライスを Equal に渡して、true が帰ってきた場合もテストは失敗です。同様に、t.Error で不合格を通知します。このように、Go 言語のテストプログラムは特別な構文を使うのではなく、Go 言語の普通のプログラムと変わりありません。基本的には、関数の返り値をチェックして、結果が異なればメソッドでエラーを報告していくだけです。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="abcgo15.html#list2">プログラムリスト２</a> をお読みください。
</p>
<p> テストの実行は簡単です。tools ディレクトリで go test を実行するだけです。
</p>
<pre>
C:\Users\m_hiroi\go\src\tools&gt;go test
PASS
ok      tools   0.085s

</pre>
<p> テストが正常に終了すれば PASS と表示されます。
</p>
<p> このほかにも、パッケージ testing にはログやベンチマークをとる機能があります。また、コマンド go test にはいろいろなオプションが用意されています。詳細は Go 言語のマニュアルをお読みください。
</p>
<h4>●参考 URL</h4>
<ol>
  <li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/ja/ebook/preface.md">build-web-application-with-golang (日本語訳)</a>, <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/ja/ebook/11.3.md">11.3 Goでどのようにテストを書くか</a>
  <li><a href="http://qiita.com/Jxck_">Jxck_ - Qiita</a>, <a href="http://qiita.com/Jxck_/items/8717a5982547cfa54ebc">Go の Test に対する考え方</a>
</ol>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// tools.go : パッケージ tools
//
//            Copyright (C) 2014 Makoto Hiroi
//

package tools

// xs と ys は等しいか
func Equal(xs, ys []int) bool {
    if len(xs) != len(ys) {
        return false
    }
    for i := 0; i &lt; len(xs); i++ {
        if xs[i] != ys[i] {
            return false
        }
    }
    return true
}

// xs を複製する
func Dup(xs []int) []int {
    ys := make([]int, len(xs))
    copy(ys, xs)
    return ys
}

// n は xs に含まれるか
func Member(n int, xs []int) bool {
    for _, x := range xs {
        if n == x {
            return true
        }
    }
    return false
}

// n と等しい要素の位置を求める
func Position(n int, xs []int) int {
    for i, x := range xs {
        if n == x {
            return i
        }
    }
    return -1
}

// n と等しい要素を数える
func Count(n int, xs []int) int {
    c := 0
    for _, x := range xs {
        if n == x {
            c++
        }
    }
    return c
}

// マッピング
func Map(f func(int) int, xs []int) []int {
    ys := make([]int, len(xs))
    for i, x := range xs {
        ys[i] = f(x)
    }
    return ys
}

// フィルター
func Filter(f func(int) bool, xs []int) []int {
    ys := make([]int, 0, len(xs))
    for _, x := range xs {
        if f(x) {
            ys = append(ys, x)
        }
    }
    return ys
}

// 畳み込み
func Fold(f func(int, int) int, a int, xs []int) int {
    for _, x := range xs {
        a = f(a, x)
    }
    return a
}

// n と等しい要素を取り除く
func Remove(n int, xs []int) []int {
    return Filter(func(x int) bool { return x != n }, xs)
}

// 順列の生成
func permSub(f func([]int), n int, xs, ys []int) {
    if n == 0 {
        f(ys)
    } else {
        for _, x := range xs {
            permSub(f, n - 1, Remove(x, xs), append(ys, x))
        }
    }
}

func Permutation(f func([]int), n int, xs []int) {
    permSub(f, n, xs, make([]int, 0, n))
}

func PermGen(n int, xs []int) &lt;-chan []int {
    ch := make(chan []int)
    go func(){
        Permutation(func(ys []int){ ch &lt;- Dup(ys) }, n, xs)
        close(ch)
    }()
    return ch
}

// 組み合わせの生成
func combSub(f func([]int), n int, xs, ys []int) {
    switch {
    case n == 0:
        f(ys)
    case len(xs) == n:
        f(append(ys, xs...))
    default:
        combSub(f, n - 1, xs[1:], append(ys, xs[0]))
        combSub(f, n, xs[1:], ys)
    }
}

func Combination(f func([]int), n int, xs []int) {
    combSub(f, n, xs, make([]int, 0, n))
}

func CombGen(n int, xs []int) &lt;-chan []int {
    ch := make(chan []int)
    go func(){
        Combination(func(ys []int){ ch &lt;- Dup(ys) }, n, xs)
        close(ch)
    }()
    return ch
}
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
//
// tools_test.go : パッケージ tools の簡単なテスト
//
//                 Copyright (C) 2014 Makoto Hiroi
//
package tools

import "testing"

func TestTools(t *testing.T) {
    a := []int{1,2,3,4,5}
    if Equal(a, []int{1,2,3,4,5}) != true {
        t.Error("Equal: not true")
    }
    if Equal(a, []int{1,2,0,4,5}) != false {
        t.Error("Equal: not false")
    }
    if Equal(a, []int{1,2,3,4,5,6}) != false {
        t.Error("Equal: not false")
    }
    if Equal(a, Dup(a)) != true {
        t.Error("Dup: error")
    }
    if Member(5, a) != true {
        t.Error("Member: not found 5")
    }
    if Member(0, a) != false {
        t.Error("Member: found 0")
    }
    if Position(5, a) != 4 {
        t.Error("Position: not found 5")
    }
    if Position(0, a) != -1 {
        t.Error("Position: found 0")
    }
    if Count(5, a) != 1 {
        t.Error("Count: not found 5")
    }
    if Count(0, a) != 0 {
        t.Error("Count: found 0")
    }
    square := func(x int) int { return x * x }
    b := Map(square, a)
    for i := 0; i &lt; len(a); i++ {
        if b[i] != a[i] * a[i] {
            t.Error("Map: square error")
        }
    }
    isOdd := func(x int) bool { return x % 2 == 1 }
    c := Filter(isOdd, a)
    if len(c) != 3 || c[0] != 1 || c[1] != 3 || c[2] != 5 {
        t.Error("Filter: isOdd error")
    }
    add := func(x, y int) int { return x + y }
    if Fold(add, 0, a) != 15 {
        t.Error("Fold: add error")
    }
    d := make([][]int, 0, 24)
    for x := range PermGen(4, []int{1,2,3,4}) {
        d = append(d, x)
    }
    if len(d) != 24 ||
       !Equal(d[0], []int{1,2,3,4}) ||
       !Equal(d[23], []int{4,3,2,1}) {
        t.Errorf("PermGem: error %d, %v", len(d), d)
    }
    e := make([][]int, 0, 10)
    for x := range CombGen(3, []int{1,2,3,4,5}){
        e = append(e, x)
    }
    if len(e) != 10 ||
       !Equal(e[0], []int{1,2,3}) ||
       !Equal(e[9], []int{3,4,5}) {
        t.Errorf("CombGen: error %d, %v", len(e), e)
    }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo14.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo16.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>