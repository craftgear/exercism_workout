<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門 / Puzzle DE Go!</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881807</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<h2>Puzzle DE Go!</h2>
<div class="small">
[ <a href="puzgo04.html">PrevPage</a> | <a href="index.html#puzgo">Golang</a> | <a href="puzgo06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>N Queens Problem</h3>
<p> 「8 クイーン」はコンピュータに解かせるパズルの中でも特に有名な問題です。このパズルは 8 行 8 列のチェス盤の升目に、8 個のクイーンを互いの利き筋が重ならないように配置する問題です。クイーンは将棋の飛車と角をあわせた駒で、縦横斜めに任意に動くことができます。解答の一例を下図に示します。
</p>
<pre class="fig">
               列           
         1 2 3 4 5 6 7 8    
       *-----------------*  
     1 | Q . . . . . . . |  
     2 | . . . . Q . . . |  
     3 | . . . . . . . Q |  
  行 4 | . . . . . Q . . |  
     5 | . . Q . . . . . |  
     6 | . . . . . . Q . |  
     7 | . Q . . . . . . |  
     8 | . . . Q . . . . |  
       *-----------------*  

    図 : 8 クイーンの解答例
</pre>
<p> N Queens Problem は「8 クイーン」の拡張バージョンで、N 行 N 列の盤面に N 個のクイーンを互いの利き筋が重ならないように配置する問題です。まず最初に「8 クイーン」を解いてみて、そのあと N Queens Problem に挑戦することにしましょう。
</p>
<p> なお、このドキュメントは拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/nqueens.html">N Queens Problem</a> を Go 言語向けに加筆・修正したものです。内容は重複していますが、あしからずご了承ください。
</p>

<h4>●8 クイーンの解法</h4>
<p> 8 クイーンを解くには、すべての置き方を試してみるしか方法はありません。最初のクイーンは、盤上の好きなところへ置くことができるので、64 通りの置き方があります。次のクイーンは 63 通り、その次は 62 通りあるので、置き方の総数は 64 から 57 までの整数を掛け算した 178462987637760 通りもあります。
</p>
<p> ところが、解答例を見ればわかるように、同じ行と列に 2 つ以上のクイーンを置くことはできません。上図の解答例をスライスを使って表すと、 次のようになります。
</p>

<pre class="fig">
  1  2  3  4  5  6  7  8    &lt;--- 列の位置
---------------------------
 [1, 7, 5, 8, 2, 4, 6, 3]   &lt;--- 要素が行の位置を表す  

        図 : スライスでの行と列の表現方法
</pre>

<p> 列をスライスの位置に、行番号を要素に対応させれば、各要素には 1 から 8 までの数字が重複しないで入ることになります。すなわち、1 から 8 までの順列の総数である 8! = 40320 通りの置き方を調べるだけでよいのです。パズルを解く場合、そのパズル固有の性質をうまく使って、調べなければならない場合の数を減らすように工夫することが大切です。あとは、その順列が 8 クイーンの条件を満たしているかチェックすればいいわけです。
</p>

<h4>●単純な生成検定法</h4>
<p> それでは、プログラムを作りましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : 8 クイーンの解法 (nqueen0.go)

package main

import "fmt"

// 順列の生成
func permSub(f func([]int), n int, xs []int, used []bool) {
    if len(xs) == n {
        f(xs)
    } else {
        for i := 1; i &lt;= n; i++ {
            if used[i] { continue }
            used[i] = true
            permSub(f, n, append(xs, i), used)
            used[i] = false
        }
    }
}

func permutation(f func([]int), n int) {
    xs := make([]int, 0, n)
    used := make([]bool, n + 1)
    permSub(f, n, xs, used)
}

// 衝突の検出
func attack(x int, ys []int) bool {
    n := 1
    for _, y := range ys {
        if x == y + n || x == y - n {
            return true
        }
        n++
    }
    return false
}

// 安全か？
func safe(xs []int) bool {
    for i := 0; i &lt; len(xs) - 1; i++ {
        if attack(xs[i], xs[i + 1:]){
            return false
        }
    }
    return true
}

func main() {
    permutation(func(xs []int){if safe(xs) { fmt.Println(xs) }}, 8)
}
</pre>

<p> 関数 permutation は 1 から n までの順列を生成します。main で permutation を呼び出し、匿名関数の中で生成された順列 xs が 8 クイーンの条件を満たしているかチェックします。関数 safe はスライスの先頭の要素から順番に衝突のチェックを行います。端にあるクイーンから順番に調べるとすると、斜めの利き筋は次のように表すことができます。
</p>

<pre class="fig">
    1 2 3    --&gt; 調べる方向
  *-------------
  | . . . . . .
  | . . . -3. .  5 - 3 = 2
  | . . -2. . .  5 - 2 = 3
  | . -1. . . .  5 - 1 = 4
  | Q . . . . .  Q の位置は 5  
  | . +1. . . .  5 + 1 = 6
  | . . +2. . .  5 + 2 = 7
  | . . . +3. .  5 + 2 = 8
  *-------------

    図 : 衝突の検出
</pre>

<p> 図を見てもらえばおわかりのように、Q が行 5 にある場合、ひとつ隣の列は 4 と 6 が利き筋に当たります。2 つ隣の列の場合は 3 と 7 が利き筋に当たります。このように単純な足し算と引き算で、利き筋を計算することができます。この処理を関数 attack で行います。
</p>

<p> attack はスライスの先頭から斜めの利き筋に当たるか調べます。引数 x がクイーンの位置、ys が残りのクイーンを格納したスライスです。変数 n が差分を表します。for ループで ys からクイーン y を取り出し、y + n または y - n が x と等しいかチェックします。等しい場合は衝突しているので true を返します。そうでなければ、次のクイーンを調べます。このとき、差分 n を +1 することをお忘れなく。すべてのクイーンを調べたら false を返します。
</p>

<h4>●実行結果</h4>
<p> これでプログラムは完成です。それでは実行してみましょう。
</p>
<pre>
C&gt;go run nqueen0.go
[1 5 8 6 3 7 2 4]
[1 6 8 3 7 4 2 5]
[1 7 4 6 8 2 5 3]

・・・省略・・・

[8 2 5 3 1 7 4 6]
[8 3 1 6 2 5 7 4]
[8 4 1 3 6 2 7 5]
</pre>
<p> 8 クイーンの場合、回転解や鏡像解を含めると全部で 92 通りあります。
</p>
<p> ところで、クイーンの個数を増やすと、プログラムの実行時間は極端に遅くなります。クイーンの個数を増やすのは簡単です。次のリストを見てください。
</p>
<pre class="list">
リスト : N Queens Problem

func main(){
    for i := 8; i &lt;= 12; i++ {
        fmt.Println("-----", i, "-----")
        s := time.Now()
        c := 0
        permutation(func(xs []int){if safe(xs) { c++ }}, i)
        e := time.Now().Sub(s)
        fmt.Println(c)
        fmt.Println(e)
    }
}
</pre>
<p> permutation の第 2 引数にクイーンの個数を指定するだけです。匿名関数は解を表示するのではなく、解の個数をカウントするように修正します。実行結果は次のようになりました。
</p>
<pre>
      表 : 実行結果 (時間 : 秒)

  個数 :  8  :   9  |  10  :  11  :  12
  -----+-----+------+------+------+-------
   解  :  92 :  352 :  724 : 2680 : 14200
  時間 : --- : 0.03 : 0.32 : 3.47 : 42.81

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> クイーンの個数をひとつ増やしただけでも、実行時間はとても遅くなります。実はこのプログラム、とても非効率なことをやっているのです。
</p>

<h4>●無駄を省く</h4>
<p> 実行速度が遅い理由は、失敗することがわかっている順列も生成してしまうからです。たとえば、最初 (1, 1) の位置にクイーンを置くと、次のクイーンは (2, 2) の位置に置くことはできませんね。したがって、[1, 2, X, X, X, X, X, X,] という配置はすべて失敗するのですが、順列を発生させてからチェックする方法では、このような無駄を省くことができません。
</p>
<p> そこで、クイーンの配置を決めるたびに衝突のチェックを行うことにします。これをプログラムすると次のようになります。
</p>

<pre class="list">
リスト : N Queens Problem (改良版)

package main

import (
    "fmt"
    "time"
)

// 衝突のチェック
func attack(x int, ys []int) bool {
    n := len(ys)
    for _, y := range ys {
        if x == y + n || x == y - n {
            return true
        }
        n--
    }
    return false
}

// N Queens Problem
func queenSub(f func([]int), n int, xs []int, used []bool) {
    if len(xs) == n {
        f(xs)
    } else {
        for i := 1; i &lt;= n; i++ {
            if used[i] || attack(i, xs) { continue }
            used[i] = true
            queenSub(f, n, append(xs, i), used)
            used[i] = false
        }
    }
}

func queen(f func([]int), n int) {
    xs := make([]int, 0, n)
    used := make([]bool, n + 1)
    permSub(f, n, xs, used)
}

func main(){
    for i := 8; i &lt;= 15; i++ {
        fmt.Println("-----", i, "-----")
        s := time.Now()
        c := 0
        queen(func(xs []int){ c++ }, i)
        e := time.Now().Sub(s)
        fmt.Println(c)
        fmt.Println(e)
    }
}
</pre>
<p> permutation と permSub の名前を queen と queenSub に変更します。queenSub でクイーンを選択するとき、関数 attack を呼び出して選択したクイーンが衝突しないかチェックします。クイーンはスライスの末尾に追加するので、関数 attack は差分 n をスライスの大きさに初期化して、スライスの先頭から順番にチェックし、n の値を -1 していくことに注意してください。
</p>
<p> 実行結果を示します
</p>
<pre>
                  表 : 実行結果 (時間 : 秒)

個数 :  8  :   9  |  10  :  11  :  12   :  13   :   14   :   15
-----+-----+------+------+------+-------+-------+--------+---------
 解  :  92 :  352 :  724 : 2680 : 14200 : 73712 : 365596 : 2279184
 (0) : --- : 0.03 : 0.32 : 3.47 : 42.81 : ----- : ------ : -------
 (1) : --- : ---- : ---- : 0.03 :  0.11 :  0.58 :  3.60  :  23.49

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 実行時間は速くなりましたが、クイーンの個数が 14 を超えると実行時間が極端に遅くなります。これは、斜めの利き筋をチェックする関数 attack と、異なる数字（クイーンの位置）を選ぶために行うスライス used のチェック処理に時間がかかるからです。そこで、<a href="http://www.pro.or.jp/~fuji/index.html">藤原博文さん</a> の <a href="http://www.pro.or.jp/~fuji/puzzlestudy/8queen.html">８クイーン＠勉強会のページ</a> を参考にプログラムを改良してみましょう。
</p>

<h4>●プログラムの改良</h4>
<p> まず、used のチェックですが、別のスライス zs に数字をひとつずつ入れておいて、選んだ数字と未使用の数字を交換していくことで改良することができます。n 列目のクイーンを選ぶ場合、確定済みのクイーンは zs の 0 から n - 1 までに格納されていて、残りが未使用のクイーンになります。これで未使用のクイーンを簡単に選ぶことができます。
</p>

<p> 次は斜めの利き筋のチェックです。実は、これも簡単な方法で高速化できます。次の図を見てください。
</p>

<pre class="fig">
   右斜め上の利き筋          左斜め上の利き筋
    0 1 2 3 4 5 6 7         0 1 2 3 4 5 6 7
 *-----------------*        *-----------------*    
 |／／／／／／／／ | 8   -1 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 9   -2 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 10  -3 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 11  -4 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 12  -5 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 13  -6 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ | 14  -7 |＼＼＼＼＼＼＼＼ |
 |／／／／／／／／ |        |＼＼＼＼＼＼＼＼ |
 *-----------------*        *-----------------*

  x + y = constant           x - y = constant

          図：斜めの利き筋のチェック
</pre>

<p> 斜めの利き筋は、行と列の位置を足す、または行から列を引くと一定の値になることを利用してチェックしています。attack は確定済みのクイーンと衝突していないかひとつずつチェックしていますが、斜めの利き筋を配列にセットしておけば、もっと簡単にチェックすることができます。
</p>
<p> 右斜め上の利き筋を rs, 左斜め上の利き筋を ls で表すことにすると、(x, y) にクイーンを置いた場合は次のようにセットします。
</p>
<pre class="item">
rs[x + y] = true
ls[x - y + n - 1] = true
</pre>
<p> n は盤面の大きさ (クイーンの個数) です。バックトラックするときはリセットすることをお忘れなく。プログラムは次のようになります。
</p>

<pre class="list">
リスト：N Queens Problem (nqueen2.go)

package main

import (
    "fmt"
    "time"
)

func queenSub(f func([]int), n int, zs, xs []int, rs, ls []bool) {
    if len(xs) == n {
        f(xs)
    } else {
        k := len(xs)
        for i := k; i &lt; n; i++ {
            m := zs[i]
            if rs[m + k] || ls[m - k + n - 1] {
                continue
            }
            rs[m + k] = true
            ls[m - k + n - 1] = true
            zs[i] = zs[k]
            zs[k] = m
            queenSub(f, n, zs, append(xs, m), rs, ls)
            zs[k] = zs[i]
            zs[i] = m
            rs[m + k] = false
            ls[m - k + n - 1] = false
        }
    }
}

func queen(f func([]int), n int) {
    xs := make([]int, 0, n)
    zs := make([]int, n)
    rs := make([]bool, n * 2)
    ls := make([]bool, n * 2)
    for i := 0; i &lt; n; i++ {
        zs[i] = i + 1
    }
    queenSub(f, n, zs, xs, rs, ls)
}

func main(){
    for i := 11; i &lt;= 15; i++ {
        fmt.Println("-----", i, "-----")
        s := time.Now()
        c := 0
        queen(func(xs []int){ c++ }, i)
        e := time.Now().Sub(s)
        fmt.Println(c)
        fmt.Println(e)
    }
}
</pre>
<p> プログラムは、とくに難しいところはないので、説明は割愛します。詳細はリストをお読みくださいませ。
</p>

<p> 実行結果を示します。
</p>
<pre>
        表 : 実行結果 (時間 : 秒)

個数 :  11  :  12   :  13   :   14   :   15
-----+------+-------+-------+--------+---------
 解  : 2680 : 14200 : 73712 : 365596 : 2279184
 (0) : 3.47 : 42.81 : ----- : ------ : -------
 (1) : 0.03 :  0.11 :  0.58 :  3.60  :  23.49
 (2) : 0.01 :  0.06 :  0.30 :  1.82  :  11.59

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 約 2 倍の高速化に成功しました。でも、まだまだ遅いですね。
</p>

<h4>●ビット演算による高速化</h4>
<p> 次はビット演算を使って高速化する方法を紹介します。オリジナルは Jeff Somers さんのプログラムですが、<a href="http://www.ic-net.or.jp/home/takaken/">高橋謙一郎さん</a> が再帰を使って書き直したプログラムを <a href="http://www.ic-net.or.jp/home/takaken/nt/queen/index.html">Ｎクイーン問題（解の個数を求める）</a> で発表されています。今回は高橋さんのプログラムを参考にさせていただきました。高橋さんに感謝します。
</p>

<p> プログラムのポイントは二つあります。一つはクイーンの選択処理をビット演算で行うこと、もう一つは斜めの利き筋のチェックをビット演算で行うことです。Go 言語のビット演算はＣ言語とだいたい同じですが、このほかにも覚えておくと便利なビット操作があるので、それを先に紹介しておきましょう。
</p>

<p> 最も右側 (LSB) にあるビット 1 を 0 にクリアする、逆に最も右側にある 0 を 1 にセットすることは簡単にできます。
</p>
<pre class="fig">
(1) 右側にある 1 をクリア =&gt; x &amp; (- x)

x     : 1 1 1 1
x - 1 : 1 1 1 0
----------------
 AND  : 1 1 1 0

x     : 1 0 0 0
x - 1 : 0 1 1 1
----------------
 AND  : 0 0 0 0

(2) 右側にある 0 を 1 にセット =&gt; x | (x + 1)

x     : 0 0 0 0
x + 1 : 0 0 0 1
----------------
  OR  : 0 0 0 1

x     : 0 1 1 1
x + 1 : 1 0 0 0
----------------
  OR  : 1 1 1 1
</pre>
<p> 上図 (1) を見てください。x から 1 を引くと、右側から連続している 0 は桁借りにより 1 になり、最初に出現する 1 が 0 になります。したがって、x &amp; (x - 1) を計算すると、最も右側にある 1 を 0 にクリアすることができます。(2) の場合、x に 1 を足すと、右側から連続している 1 は桁上がりにより 0 になり、最初に出現する 0 が 1 になります。x | (x + 1) を計算すれば、最も右側にある 0 を 1 にセットすることができます。
</p>

<p> また、最も右側にある 1 を取り出すことも簡単にできます。簡単な例として 4 ビットの整数値を考えてみます。負の整数を 2 の補数で表した場合、4 ビットで表される整数は -8 から 7 になります。次の図を見てください。
</p>
<pre class="fig">
 0 : 0000
 1 : 0001    -1 : 1111    1 &amp; (-1) =&gt; 0001
 2 : 0010    -2 : 1110    2 &amp; (-2) =&gt; 0010
 3 : 0011    -3 : 1101    3 &amp; (-3) =&gt; 0001
 4 : 0100    -4 : 1100    4 &amp; (-4) =&gt; 0100
 5 : 0101    -5 : 1011    5 &amp; (-5) =&gt; 0001
 6 : 0110    -6 : 1010    6 &amp; (-6) =&gt; 0010
 7 : 0111    -7 : 1001    7 &amp; (-7) =&gt; 0001
             -8 : 1000

        図 : 最も右側にある 1 を取り出す方法
</pre>
<p> 2 の補数はビットを反転した値 (1 の補数) に 1 を加算することで求めることができます。したがって、x と -x の論理積 (x &amp; (-x)) は、最も右側にある 1 だけが残り、あとのビットはすべて 0 になります。
</p>

<p> これらの操作はクイーンの選択処理に使うことができます。クイーンの位置をビットオンで表すことします。つまり、i 行目のクイーンは i ビットを 1 にした値になります。この場合、未選択のクイーンは整数値で表すことができます。8 クイーンの場合、まだ一つもクイーンを選択していない状態は 255 になります。残っているクイーンを表す値を n とすると、次の処理でクイーンを順番に取り出していくことができます。
</p>
<pre class="list">
リスト : クイーンの選択処理

for m := n; m &gt; 0; m &amp;= m - 1 {
    q := m &amp; (-m)
    ...
}
</pre>
<p> for ループの更新処理で m &amp;= m - 1 とすれば、右端の 1 を 0 にクリアすることができます。そして、ループの中で q := m &amp; (- m) とすれば、右端の 1 を取り出すことができます。n から取り出した q を削除するのも簡単で、排他的論理和 n ^ q を計算するだけです。
</p>

<p> 次は斜めの利き筋のチェックを説明します。下図を見てください。
</p>
<pre class="fig">
    0 1 2 3 4
  *-------------
  | . . . . . .
  | . . . -3. .  0x02
  | . . -2. . .  0x04
  | . -1. . . .  0x08 (1 bit 右シフト)
  | Q . . . . .  0x10 (Q の位置は 4)
  | . +1. . . .  0x20 (1 bit 左シフト)  
  | . . +2. . .  0x40
  | . . . +3. .  0x80
  *-------------

      図：斜めの利き筋のチェック
</pre>
<p> 上図の場合、1 列目の右斜め上の利き筋は 3 番目 (0x08)、2 列目の右斜め上の利き筋は 2 番目 (0x04) になります。この値は 0 列目のクイーンの位置 0x10 を 1 ビットずつ右シフトすれば求めることができます。また、左斜め上の利き筋の場合、1 列目では 5 番目 (0x20) で 2 列目では 6 番目 (0x40) になるので、今度は 1 ビットずつ左シフトすれば求めることができます。
</p>
<p> つまり、右斜め上の利き筋を right、左斜め上の利き筋を left で表すことにすると、right と left にクイーンの位置をセットしたら、隣の列を調べるときに right と left を 1 ビットシフトするだけで、斜めの利き筋を求めることができるわけです。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト：N Queens Problem (nqueen3.go)

package main

import (
    "fmt"
    "time"
)

func queen(f func([]int), n, right, left int, xs []int) {
    if n == 0 {
        f(xs)
    } else {
        for m := n; m &gt; 0; m &amp;= m - 1 {
            q := m &amp; (- m)
            if q &amp; (right | left) != 0 { continue }
            queen(f, n ^ q, (right | q) &gt;&gt; 1, (left | q) &lt;&lt; 1, append(xs, q))
        }
    }
}

func main(){
    for i := uint(12); i &lt;= 16; i++ {
        fmt.Println("-----", i, "-----")
        s := time.Now()
        c := 0
        xs := make([]int, 0, i)
        queen(func(_ []int){ c++ }, (1 &lt;&lt; i) - 1, 0, 0, xs)
        e := time.Now().Sub(s)
        fmt.Println(c)
        fmt.Println(e)
    }
}
</pre>

<p> 関数 queen の引数 n が未選択のクイーン、引数 right が右斜め上の利き筋、left が左斜め上の利き筋を表します。(rigth | left) のビットオンの位置が斜めの利き筋にあたります。そして、n から斜めの利き筋にあたらないクイーンを選びます。
</p>

<p> queen を再帰呼び出しするときは、right と left にクイーンの位置をセットして、それを 1 ビットシフトします。right と left は局所変数なので、元の値に戻す処理は必要ありません。あとは、とくに難しいところはないでしょう。詳細はプログラムリストをお読みください。
</p>

<p> 実行結果を示します。
</p>
<pre>
  表 : 実行結果 (時間 : 秒)

個数 :  12   :  13   :   14   :   15    :    16
-----+-------+-------+--------+---------+----------
 解  : 14200 : 73712 : 365596 : 2279184 : 14772512
 (1) :  0.11 :  0.58 :  3.60  :  23.49  : --------
 (2) :  0.06 :  0.30 :  1.82  :  11.59  : --------
 (3) :  0.03 :  0.12 :  0.69  :   4.28  :   28.85

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>

<p> (1) と比べると 5 倍以上、(2) と比べても 2 倍以上の高速化に成功しました。ビット操作でここまで速くなるとは M.Hiroi も大変驚きました。
</p>

<h4>●並列処理による高速化</h4>
<p> 最後に、並列処理でどのくらい速くなるか試してみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : N Queens Problem (nqueen4.go)

package main

import (
    "fmt"
    "time"
    "runtime"
)

func queen(f func([]int), n, right, left int, xs []int) {
    if n == 0 {
        f(xs)
    } else {
        for m := n; m &gt; 0; m &amp;= m - 1 {
            q := m &amp; (- m)
            if q &amp; (right | left) != 0 { continue }
            queen(f, n ^ q, (right | q) &gt;&gt; 1, (left | q) &lt;&lt; 1, append(xs, q))
        }
    }
}

func main(){
    runtime.GOMAXPROCS(runtime.NumCPU())
    for i := 12; i &lt;= 16; i++ {
        fmt.Println("-----", i, "-----")
        ch := make(chan int, i)
        s := time.Now()
        for m := (1 &lt;&lt; uint(i)) - 1; m &gt; 0; m &amp;= m - 1 {
            go func(i uint, m int){
                c := 0
                m &amp;= - m
                xs := make([]int, 1, i)
                xs[0] = m
                queen(func(_ []int){ c++ }, ((1 &lt;&lt; i) - 1) ^ m, m &gt;&gt; 1, m &lt;&lt; 1, xs)
                ch &lt;- c
            }(uint(i), m)
        }
        sum := 0
        for j := i; j &gt; 0; j-- {
            sum += &lt;- ch
        }
        e := time.Now().Sub(s)
        fmt.Println(sum)
        fmt.Println(e)
    }
}
</pre>
<p> 並列化の考え方は拙作のページ <a href="abcgo14.html">並列プログラミング</a> の「順列生成の並列化」と同じなので、説明は割愛します。興味のある方は「並列プログラミング」をお読みください。
</p>
<p> 実行結果を示します。
</p>
<pre>
       表 : 実行結果 (時間 : 秒)

個数 :  12   :  13   :   14   :   15    :    16
-----+-------+-------+--------+---------+----------
 解  : 14200 : 73712 : 365596 : 2279184 : 14772512
 (1) :  0.11 :  0.58 :  3.60  :  23.49  : --------
 (2) :  0.06 :  0.30 :  1.82  :  11.59  : --------
 (3) :  0.03 :  0.12 :  0.69  :   4.28  :   28.85
 (4) :  0.01 :  0.03 :  0.17  :   0.87  :    5.59

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 3 倍から 5 倍の高速化に成功しました。並列化の効果はとても大きいですね。並列処理はパズルの解法にも有効なことがわかります。
</p>

<h4>●参考URL</h4>
<p> <a href="http://www.ic-net.or.jp/home/takaken/">高橋謙一郎さん</a> が公開された <a href="http://www.ic-net.or.jp/home/takaken/nt/queen/index.html">Ｎクイーン問題（解の個数を求める）</a> では、ビット演算による高速化やユニーク解の判定方法が詳しく解説されていて、とても勉強になります。興味のある方は、高橋さんのドキュメントをお読みくださいませ。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="puzgo04.html">PrevPage</a> | <a href="index.html#puzgo">Golang</a> | <a href="puzgo06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>