<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881806</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo23.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo25.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>電卓プログラムの改良 (クロージャ編その２)</h3>
<p> 今回はクロージャを使って Lisp 風の「連結リスト (linked list) 」を作ってみましょう。最初に、Lisp のリストについて簡単に説明します。
</p>

<h4>●Lisp のリスト</h4>
<p> Lisp のリストは複数の「コンスセル (cons cell) 」を連結したものです。ひとつのコンスセルには、データを格納する CAR (カー) という場所と、次のセルを連結する CDR (クダー) という場所からなっています。次の図を見てください。
</p>
<pre class="fig">
 CAR CDR       CAR CDR  
┌─┬─┐    ┌─┬─┐
│・│・┼─→│・│・┼→終端 (NIL)
└┼┴─┘    └┼┴─┘
  ↓            ↓
  １            ２

            図 : リストの構造
</pre>
<p> 上図では、コンスセルを箱で表しています。左側の CAR がデータを格納する場所で、CDR が次のコンスセルと連結しています。上図の例では、先頭のコンスセルの CAR には 1 が格納され、CDR は次のコンスセルと連結しています。2 番目のコンスセルには CAR に 2 というデータが格納されています。このあとに接続されるコンスセルはもうないので、CDR にはリストの終わりを示す特別なデータ (NIL) が格納されます。このようなリストを Lisp では (1 2) と表記します。
</p>

<p> また、Lisp のリストは CAR にリストを格納して、リストを入れ子にすることができます。次の図を見てください。
</p>

<pre class="fig">
 ┌─┬─┐  ┌─┬─┐  ┌─┬─┐
 │・│・┼→│・│・┼→│・│／│  ／ : NIL
 └┼┴─┘  └┼┴─┘  └┼┴─┘
   ↓          │          │
   １          │          │
               │          ↓
               │        ┌─┬─┐  ┌─┬─┐  ┌─┬─┐
               │        │・│・┼→│・│・┼→│・│／│
               │        └┼┴─┘  └┼┴─┘  └┼┴─┘
               │          ↓          ↓          ↓
               │          ３         １２        １３
               ↓
             ┌─┬─┐  ┌─┬─┐  ┌─┬─┐
             │・│・┼→│・│・┼→│・│／│
             └┼┴─┘  └┼┴─┘  └┼┴─┘
               ↓          ↓          ↓
               ２         １０        １１

                  図 : リストの階層構造
</pre>
<p> 上図のリストを Lisp で記述すると (1 (2 10 11) (3 12 13)) になります。それから、Lisp のリストは異なるデータ型でもいっしょに格納することができます。
</p>

<h4>●リストの表記法</h4>
<p> ここで Lisp でのリストの表記法について簡単に説明しておきましょう。コンスセルの CDR は NIL だけではなく他のデータを格納することもできます。Lisp ではリストの終端が NIL 以外のデータの場合、そのリストを次のように表します。
</p>

<pre class="fig">
 ┌─┬─┐            ┌─┬─┐
 │・│・┼─→ NIL    │・│・┼─→２
 └┼┴─┘            └┼┴─┘
   ↓                    ↓
   １                    １

 (1) ≡ (1 . NIL)      (1 . 2)

 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→ NIL 
 └┼┴─┘    └┼┴─┘    └┼┴─┘
   ↓            ↓            ↓
   １            ２            ３

     (1 2 3) ≡ (1 . (2 . (3 . NIL)))

    図 : リストの終端 (その１)
</pre>

<p> 左右のカッコの中間にドット ( . ) を置き、左側に CAR のデータを、右側に CDR のデータを書きます。つまり、リスト (1) は (1 . NIL) と表すことができます。このようなデータを Lisp では「ドット対 (dotted pair) 」と呼びます。たとえば、CAR が 1 で CDR が 2 であれば (1 . 2) となります。普通のリストも次のようにドット対を使って表現できます。
</p>
<pre class="item">
(1)           ≡ (1 . NIL)
(1 2 3)       ≡ (1 . (2 . (3 . NIL)))
((1 2) (3 4)) ≡ ((1 . (2 . NIL)) . ((3 . (4 . NIL)) . NIL))
((1 2) 3 4)   ≡ ((1 . (2 . NIL)) . (3 . (4 . NIL)))
</pre>

<p> それでは、リスト (a b c) の終端を d に変えてみましょう。ドット対を使った表記法では、(a . (b . (c . d))) となりますが、これは (a b c . d) と表すことができます。
</p>
<pre class="fig">
 ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
 │・│・┼─→│・│・┼─→│・│・┼─→d 
 └┼┴─┘    └┼┴─┘    └┼┴─┘
   ↓            ↓            ↓
   ａ            ｂ            ｃ

     (a b c . d) ≡ (a . (b . (c . d)))

    図 : リストの終端（その２）
</pre>

<p> このように、NIL 以外のアトムで終端されたリストを Lisp では「ドットリスト (dotted list) 」と呼びます。
</p>
<p> ドットの後ろは CDR にセットするデータを指定するのですから、複数のデータを書いたり省略してはいけません。次の場合、Lisp ではエラーになります。
</p>
<pre class="item">
( . a)       ; CAR がない
(a . )       ; CDR がない
(a . b c)    ; CDR にデータが複数ある
(a . . b)    ; ドットが複数ある
(a . b . c )
</pre>

<h4>●クロージャによる連結リストの実装</h4>
<p> Lisp / Scheme の場合、関数 cons でコンスセルを生成し、関数 car でリストの先頭要素を取り出し、関数 cdr でリストから先頭要素を取り除きます。したがって、Lisp / Scheme の cons, car, cdr には次の関係が成り立ちます。
</p>
<pre class="item">
x == car(cons(x, y)) =&gt; 1 (true)
y == cdr(cons(x, y)) =&gt; 1 (true)
</pre>
<p> 演算子 == は今回作成した電卓プログラムの等値演算子と考えてください。Scheme で表すと次のようになります。
</p>
<pre class="item">
(eq? x (car (cons x y))) =&gt; #t
(eq? y (cdr (cons x y))) =&gt; #t
</pre>
<p> Scheme の場合、#t は true を、#f は false を表します。実際に Gauche (Scheme) での実行例を示します。
</p>
<pre>
gosh&gt; (define a 10)
a
gosh&gt; (define b 20)
b
gosh&gt; (eq? a (car (cons a b)))
#t
gosh&gt; (eq? b (cdr (cons a b)))
#t
</pre>
<p> ここで (cons x y) で生成したオブジェクトがセルではない場合を考えてみましょう。もし、そのオブジェクトに car を適用すれば cons の第 1 引数 x を返し、cdr を適用すれば第 2 引数を返すことができれば、セルと同じことが実現できます。
</p>
<p> そこで、cons はセルではなくクロージャを返すことにしましょう。クロージャは引数 x, y の値を保持することができます。そして、このクロージャは引数に関数を受け取ることにします。あとは、この関数に引数 x, y を渡して評価すれば car と cdr を実現することができます。
</p>

<p> Gauche でプログラムすると次のようになります。
</p>
<pre>
gosh&gt; (define (cons2 x y) (lambda (z) (z x y)))
cons2
gosh&gt; (define (car2 x) (x (lambda (a b) a)))
car2
gosh&gt; (define (cdr2 x) (x (lambda (a b) b)))
cdr2
gosh&gt; (car2 (cons2 'a 'b))
a
gosh&gt; (cdr2 (cons2 'a 'b))
b
gosh&gt; (define a (cons2 1 (cons2 2 (cons2 3 4))))
a
gosh&gt; (car2 a)
1
gosh&gt; (car2 (cdr2 a))
2
gosh&gt; (car2 (cdr2 (cdr2 a)))
3
gosh&gt; (cdr2 (cdr2 (cdr2 a)))
4
</pre>
<p> lambda はラムダ式 (匿名関数) を表します。関数 cons2 はクロージャを返します。このクロージャは引数 z に関数を受け取り、その関数に x, y を渡して評価します。car2 は引数 x にクロージャを渡して評価し、第 1 引数 a を返します。これで car と同じ動作になります。同様に、cdr2 は引数 x にクロージャを渡して評価し、第 2 引数 b を返します。これで cdr と同じ動作になります。
</p>

<p> クロージャをサポートしているプログラミング言語であれば、Lisp / Scheme と同じように cons, car, cdr を作ることができます。電卓プログラムで cons, car, cdr をプログラムすると次のようになります。
</p>
<pre class="list">
リスト ; 連結リストの基本関数

def cons(x, y)
  fn(z) z(x, y) end
end

def car(z)
  z(fn(x, y) x end)
end

def cdr(z)
  z(fn(x, y) y end)
end
</pre>
<p> それでは実際に試してみましょう。
</p>
<pre>
Calc&gt; def cons(x, y) fn(z) z(x, y) end end
cons
Calc&gt; def car(z) z(fn(x, y) x end) end
car
Calc&gt; def cdr(z) z(fn(x, y) y end) end
cdr
Calc&gt; a = cons(1, 0);
&lt;Closure&gt;
Calc&gt; car(a);
1
Calc&gt; cdr(a);
0
Calc&gt; b = cons(2, a);
&lt;Closure&gt;
Calc&gt; car(b);
2
Calc&gt; cdr(b);
&lt;Closure&gt;
Calc&gt; car(cdr(b));
1
</pre>
<p> このように、クロージャを使って連結リストを作成することができます。
</p>

<h4>●リストの表示</h4>
<p> それでは、連結リストを操作する関数を作っていきましょう。最初に、連結リストを表示する関数 printlist を作ります。
</p>
<pre class="list">
リスト : 連結リストの表示

nil = "NIL";

def pair(xs) isFunc(xs) end

def null(xs) isStr(xs) and xs == nil end

def printlist(xs)
  print("("),
  while pair(xs) do
    if pair(car(xs)) or null(car(xs)) then
      printlist(car(xs))
    else
      print(car(xs))
    end,
    if pair(cdr(xs)) then print(" ") end,
    xs = cdr(xs)
  end,
  if !null(xs) then
    begin print(" . "), print(xs) end
  end,
  print(")"),
  nil
end
</pre>
<p> 連結リストの表示は Lisp / Scheme の表示に合わせます。リストはカッコで囲って、要素は空白で区切ります。セルの CDR 部がリストでない場合、ドット ( . ) で区切ります。CDR 部が空リストの場合、NIL は表示しません。この仕様をそのままプログラムしたものが printlist です。
</p>

<p> 空リストは文字列 "NIL" で表すことにします。これを変数 nil にセットします。次に、リストを判定する述語 pair と空リストを判定する述語 null を定義します。pair は isFunc を呼び出すだけです。null は引数 xs が文字列で、nil と等しければ true を返します。
</p>
<p> printlist は最初に '(' を表示して、while ループで要素を順番に出力します。このとき、要素 car(xs) がリストまたは空リストであれば、printlist を再帰呼び出しします。これで入れ子のリストも表示することができます。
</p>
<p> 次に、cdr(xs) がリストであれば、要素を空白で区切るため putc で空白 ' ' を出力します。そして、xs を cdr(xs) に書き換えて処理を繰り返します。ループを終了したら、xs が空リストでなければ、要素をドットで区切って print で xs を表示します。最後に print で ")" を表示します。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; a = cons(1, nil);
&lt;Closure&gt;
Calc&gt; printlist(a);
(1)
Calc&gt; b = cons(2, a);
&lt;Closure&gt;
Calc&gt; printlist(b);
(2 1)
Calc&gt; c = cons(3, b);
&lt;Closure&gt;
Calc&gt; printlist(c);
(3 2 1)
Calc&gt; printlist(cons(c, b));
((3 2 1) 2 1)
Calc&gt; printlist(cons(c, cons(b, a)));
((3 2 1) (2 1) 1)
Calc&gt; printlist(cons(1, 2));
(1 . 2)
Calc&gt; printlist(cons(nil, nil));
(())
</pre>
<h4>●リストの生成</h4>
<p> 次はリストを生成する関数 makelist, iota, tabulate を作ります。
</p>
<pre class="list">
リスト : リストの生成

def makelist(n, x)
  let
    xs = nil
  in
    while n &gt; 0 do
      xs = cons(x, xs),
      n = n - 1
    end,
    xs
  end
end

def iota(n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(m, xs),
      m = m - 1
    end,
    xs
  end
end

def tabulate(f, n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(f(m), xs),
      m = m - 1
    end,
    xs
  end
end
</pre>
<p> makelist(n, x) は、x を n 個格納したリストを生成します。iota(n, m) は n から m までの整数列を返します。tabulate(f, n, m) は高階関数で、n から m までの整数列を生成し、その要素に関数 f を適用した結果をリストに格納して返します。つまり、map(f, iota(n, m)) と同じ動作になります。
</p>

<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; printlist(makelist(10, 0));
(0 0 0 0 0 0 0 0 0 0)NIL
Calc&gt; printlist(makelist(10, nil));
(() () () () () () () () () ())NIL
Calc&gt; printlist(iota(1, 10));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(tabulate(fn(x) x * 2 end, 1, 10));
(2 4 6 8 10 12 14 16 18 20)NIL
</pre>

<h4>●リストの基本的な操作</h4>
<p> 次は、リストの基本的な操作関数を定義しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : リストの基本操作関数

def nth(xs, n)
  if null(xs) then
    nil
  else
    if n == 0 then
      car(xs)
    else
      nth(cdr(xs), n - 1)
    end
  end
end

def length(xs)
  let
    c = 0
  in
    while !null(xs) do
      c = c + 1,
      xs = cdr(xs)
    end,
    c
  end
end

def reverse(xs)
  let
    ys = nil
  in
    while !null(xs) do
      ys = cons(car(xs), ys),
      xs = cdr(xs)
    end,
    ys
  end
end

def eql(xs, ys)
  if (isInt(xs) and isInt(ys)) or
     (isFlt(xs) and isFlt(ys)) or
     (isStr(xs) and isStr(xs)) then
    xs == ys
  end
end

def member(x, ls)
  while !null(ls) and !eql(car(ls), x) do
    ls = cdr(ls)
  end,
  ls
end

def append(xs, ys)
  if null(xs) then
    ys
  else
    cons(car(xs), append(cdr(xs), ys))
  end
end

def remove(x, ls)
  if null(ls) then
    nil
  else
    if eql(x, car(ls)) then
      remove(x, cdr(ls))
    else
      cons(car(ls), remove(x, cdr(ls)))
    end
  end
end

def take(xs, n)
  if n == 0 or null(xs) then
    nil
  else
    cons(car(xs), take(cdr(xs), n - 1))
  end
end

def drop(xs, n)
  if n == 0 or null(xs) then
    xs
  else
    drop(cdr(xs), n - 1)
  end
end
</pre>
<p> nth はリストの n 番目の要素を取り出します。リストは 0 から数えるものとします。範囲外は nil を返します。length はリストの長さを返します。reverse はリストを反転します。member はリストから x を探します。見つけた場合はリストを返し、見つからない場合は nil を返します。eql はデータの等値を判定する述語です。Lisp の eql はデータ型が同じで、値が同じ場合に真を返します。たとえば、整数 1 と実数 1.0 を比較すると eql は偽を返します。
</p>

<p> append は 2 つのリストを連結します。引数 xs のリストはコピーされることに注意してください。remove は x と等しい要素を削除したリストを返します。take はリスト xs の先頭から n 個の要素を取り出します。drop はリスト xs の先頭から n 個の要素を取り除きます。
</p>
<p> それでは簡単な実行例を示します。
</p>
<pre>
Calc&gt; a = iota(1, 10);
&lt;Closure&gt;
Calc&gt; printlist(a);
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; nth(a, 0);
1
Calc&gt; nth(a, 9);
10
Calc&gt; nth(a, 10);
NIL
Calc&gt; length(a);
10
Calc&gt; printlist(reverse(a));
(10 9 8 7 6 5 4 3 2 1)NIL
Calc&gt; printlist(member(1, a));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(member(5, a));
(5 6 7 8 9 10)NIL
Calc&gt; printlist(member(10, a));
(10)NIL
Calc&gt; printlist(member(11, a));
()NIL
Calc&gt; b = iota(11, 20);
&lt;Closure&gt;
Calc&gt; printlist(append(a, b));
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)NIL
Calc&gt; printlist(remove(1, a));
(2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(remove(5, a));
(1 2 3 4 6 7 8 9 10)NIL
Calc&gt; printlist(remove(10, a));
(1 2 3 4 5 6 7 8 9)NIL
Calc&gt; printlist(remove(11, a));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(take(a, 5));
(1 2 3 4 5)NIL
Calc&gt; printlist(take(a, 0));
()NIL
Calc&gt; printlist(take(a, 10));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(take(a, 11));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(drop(a, 5));
(6 7 8 9 10)NIL
Calc&gt; printlist(drop(a, 0));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; printlist(drop(a, 10));
()NIL
Calc&gt; printlist(drop(a, 11));
()NIL
</pre>
<h4>●高階関数</h4>
<p> 高階関数も簡単に作ることができます。
</p>
<pre class="list">
リスト : 高階関数

def map(f, xs)
  if null(xs) then
    nil
  else 
    cons(f(car(xs)), map(f, cdr(xs)))
  end
end

def filter(f, xs)
  if null(xs) then
    nil
  else
    if f(car(xs)) then
      cons(car(xs), filter(f, cdr(xs)))
    else
      filter(f, cdr(xs))
    end
  end
end

def foldl(f, a, xs)
  while !null(xs) do
    a = f(car(xs), a),
    xs = cdr(xs)
  end,
  a
end

def foldr(f, a, xs)
  if null(xs) then
    a
  else
    f(car(xs), foldr(f, a, cdr(xs)))
  end
end

def foreach(f, ls)
  while !null(ls) do
    f(car(ls)),
    ls = cdr(ls)
  end
end
</pre>
<p> map はマッピングを、filter はフィルターを、foldl, foldr は畳み込みを行います。foreach はリストの要素に関数 f を適用しますが、その副作用が目的となります。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; printlist(map(fn(x) x * x end, a));
(1 4 9 16 25 36 49 64 81 100)NIL
Calc&gt; printlist(filter(fn(x) x % 2 == 0 end, a));
(2 4 6 8 10)NIL
Calc&gt; foldl(fn(x, a) x + a end, 0, a);
55
Calc&gt; printlist(foldl(fn(x, a) cons(x, a) end, nil, a));
(10 9 8 7 6 5 4 3 2 1)NIL
Calc&gt; foldr(fn(x, a) x + a end, 0, a);
55
Calc&gt; printlist(foldr(fn(x, a) cons(x, a) end, nil, a));
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; foreach(println, a);
1
2
3
4
5
6
7
8
9
10
0
</pre>
<p> foreach の返り値は if の else 節がないため 0 になります。
</p>

<h4>●等値の判定</h4>
<p> 電卓プログラムの場合、等値演算子 ==, != で判定できるのは整数, 実数, 文字列だけです。Lisp / Scheme と同様に、リストとリストの等値を判定する述語 equal があると便利です。次のリストを見てください。
</p>
<pre class="list">
リスト : 等値の判定

def equal(xs, ys)
  if pair(xs) and pair(ys) then
    if equal(car(xs), car(ys)) then
      equal(cdr(xs), cdr(ys))
    else
      0
    end
  else
    if !pair(xs) and !pair(ys) then
      eql(xs, ys)
    end
  end
end
</pre>
<p> 等値の判定は簡単です。引数 xs, ys がリストの場合、その要素 car(xs) を equal で比較し、等しい場合は cdr(xs) と cdr(ys) を equal で比較します。xs と ys がどちらもリストではない場合は eql で判定します。そうでなければ、他方がリストになるので偽 (0) を返します。これで入れ子になったリストでも等値を判定することができます。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; equal(cons(1, 2), cons(1, 2));
1
Calc&gt; equal(cons(1, 2), cons(1, 0));
0
Calc&gt; equal(cons(1, 2), cons(1, 2.0));
0
Calc&gt; a = iota(1, 10);
&lt;Closure&gt;
Calc&gt; equal(a, a);
1
Calc&gt; b = iota(1, 5);
&lt;Closure&gt;
Calc&gt; equal(a, b);
0
</pre>
<h4>●簡単な例題</h4>
<p> 最後に、リスト操作関数を使った簡単なプログラムを作りましょう。
</p>
<pre class="list">
リスト : 簡単な例題

def zip(xs, ys)
  if null(xs) or null(ys) then
    nil
  else
    cons(cons(car(xs), car(ys)), zip(cdr(xs), cdr(ys)))
  end
end

def flatten(ls)
  if null(ls) then
    nil
  else
    if pair(ls) then
      append(flatten(car(ls)), flatten(cdr(ls)))
    else
      cons(ls, nil)
    end
  end
end

def permSub(f, n, xs, a)
  if n == 0 then
    f(reverse(a))
  else
    foreach(fn(x) permSub(f, n - 1, remove(x, xs), cons(x, a)) end, xs)
  end
end

def permutation(f, n, xs)
  permSub(f, n, xs, nil)
end
</pre>
<p> zip は 2 つのリスト xs, ys を受け取り、それぞれの要素をセルに格納したリストを返します。flatten はリストを平坦化する関数です。permutation はリスト xs から n 個の要素を選ぶ順列をすべて表示します。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; a = iota(1, 8);
&lt;Closure&gt;
Calc&gt; b = iota(11, 18);
&lt;Closure&gt;
Calc&gt; printlist(zip(a, b));
((1 . 11) (2 . 12) (3 . 13) (4 . 14) (5 . 15) (6 . 16) (7 . 17) (8 . 18))NIL
Calc&gt; printlist(flatten(zip(a, b)));
(1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18)NIL
Calc&gt; permutation(printlist, 3, iota(1, 3));
(1 2 3)(1 3 2)(2 1 3)(2 3 1)(3 1 2)(3 2 1)0
</pre>
<p> リストのマージソートも簡単にプログラムできます。
</p>
<pre class="list">
リスト : マージソート

def merge(xs, ys, pred)
  if null(xs) or null(ys) then
    if null(xs) then ys else xs end
  else
    if pred(car(xs), car(ys)) then
      cons(car(xs), merge(cdr(xs), ys, pred))
    else
      cons(car(ys), merge(xs, cdr(ys), pred))
    end
  end
end

def mergeSort(xs, n, pred)
  if n == 1 then
    cons(car(xs), nil)
  else
    let
      m = n / 2
    in
      merge(mergeSort(xs, m, pred),
            mergeSort(drop(xs, m), n - m, pred),
            pred)
    end
  end
end
</pre>
<p> merge は 2 つのリストをマージ (併合) し、mergeSort は merge を使ってリストをソートします。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; a = cons(1, cons(3, cons(5, cons(7, nil))));
&lt;Closure&gt;
Calc&gt; b = cons(2, cons(4, cons(6, cons(8, nil))));
&lt;Closure&gt;
Calc&gt; printlist(a);
(1 3 5 7)
Calc&gt; printlist(b);
(2 4 6 8)
Calc&gt; printlist(merge(a, b, fn(x, y) x &lt; y end));
(1 2 3 4 5 6 7 8)
Calc&gt; a = cons(4, cons(5, cons(7, cons(6, cons(8, cons(3, cons(1, cons(9, cons(2, nil)))))))));
&lt;Function&gt;
Calc&gt; printlist(a);
(4 5 7 6 8 3 1 9 2)
Calc&gt; printlist(mergeSort(a, 9, fn(x, y) x &lt; y end));
(1 2 3 4 5 6 7 8 9)
Calc&gt; printlist(mergeSort(a, 9, fn(x, y) x &gt; y end));
(9 8 7 6 5 4 3 2 1)
</pre>
<h4>●リストの破壊的な修正</h4>
<p> ところで、このままではコンスセルの CAR 部と CDR 部を破壊的に修正することはできません。Scheme の関数 set-car!, set-cdr! と同じ動作を実現する場合、cons が返すクロージャに値を書き換える処理を追加します。プログラムは次のようになります。
</p>
<pre class="list">
リスト : リストの破壊的な修正

def cons(x, y)
  fn(n, v)
    if n &lt; 2 then
      if n == 0 then
        x
      else
        y
      end
    else
      if n == 2 then
        x = v
      else
        y = v
      end
    end
  end
end

def car(z) z(0, 0) end

def cdr(z) z(1, 0) end

def setCar(z, v) z(2, v) end

def setCdr(z, v) z(3, v) end
</pre>
<p> クロージャの第 1 引数 n で実行する処理を指定します。0 が car, 1 が cdr です。2 が setCar で x の値を引数 v に書き換えます。3 が setCdr で y の値を v に書き換えます。あとは、関数 car, cdr, setCar, setCdr で適切な値を指定してクロージャを呼び出すだけです。あとのプログラムは修正しなくても大丈夫です。
</p>
<p> 簡単な実行例を示しましょう。
</p>
<pre>
Calc&gt; a = cons(1, 2);
&lt;Closure&gt;
Calc&gt; printlist(a);
(1 . 2)NIL
Calc&gt; setCar(a, 10);
10
Calc&gt; printlist(a);
(10 . 2)NIL
Calc&gt; setCdr(a, 20);
20
Calc&gt; printlist(a);
(10 . 20)NIL
</pre>
<p> リストの破壊的操作の例題として、リストの要素を書き換える書き換える listSet とリストを破壊的に反転する関数 nreverse を作ります。
</p>

<pre class="list">
リスト : リストの破壊的な操作

def listSet(xs, n, v)
  if null(xs) then
    nil
  else
    if n == 0 then
      setCar(xs, v)
    else
      listSet(cdr(xs), n - 1, v)
    end
  end
end

def nrevSub(xs, a)
  if null(xs) then
    a
  else
    let ys = cdr(xs) in
      setCdr(xs, a),
      nrevSub(ys, xs)
    end
  end
end

def nreverse(xs)
  nrevSub(xs, nil)
end
</pre>
<p> listSet は setCar で指定した位置の要素を書き換えます。nreverse は setCdr でセルの CDR 部を書き換えることでリストを反転しています。
</p>
<p> 簡単な実行例を示します。
</p>
<pre>
Calc&gt; b = iota(1, 10);
&lt;Closure&gt;
Calc&gt; printlist(b);
(1 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; listSet(b, 0, 100);
100
Calc&gt; printlist(b);
(100 2 3 4 5 6 7 8 9 10)NIL
Calc&gt; listSet(b, 5, 200);
200
Calc&gt; printlist(b);
(100 2 3 4 5 200 7 8 9 10)NIL
Calc&gt; listSet(b, 9, 300);
300
Calc&gt; printlist(b);
(100 2 3 4 5 200 7 8 9 300)NIL
Calc&lt; a = iota(1, 10);
&lt;Closure&gt;
Calc&lt; b = nreverse(a);
&lt;Closure&gt;
Calc&lt; printlist(b);
(10 9 8 7 6 5 4 3 2 1)NIL
Calc&lt; printlist(a);
(1)
</pre>
<p> 今回はここまでです。次回は電卓プログラムにデータ構造として「連結リスト」を追加してみましょう。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// list.cal : クロージャによる連結リストの実装
//
//            Copyright (C) 2014 Makoto Hiroi
//

// 空リスト
nil = "NIL";

// リストの基本操作
def cons(x, y)
  fn(n, v)
    if n &lt; 2 then
      if n == 0 then
        x
      else
        y
      end
    else
      if n == 2 then
        x = v
      else
        y = v
      end
    end
  end
end

def car(z) z(0, 0) end

def cdr(z) z(1, 0) end

def setCar(z, v) z(2, v) end

def setCdr(z, v) z(3, v) end

// 述語
def pair(xs) isFunc(xs) end

def null(xs) isStr(xs) and xs == nil end

def eql(xs, ys)
  if (isInt(xs) and isInt(ys)) or
     (isFlt(xs) and isFlt(ys)) or
     (isStr(xs) and isStr(xs)) then
    xs == ys
  end
end

def equal(xs, ys)
  if pair(xs) and pair(ys) then
    if equal(car(xs), car(ys)) then
      equal(cdr(xs), cdr(ys))
    else
      0
    end
  else
    if !pair(xs) and !pair(ys) then
      eql(xs, ys)
    end
  end
end

// リストの参照
def nth(xs, n)
  if null(xs) then
    nil
  else
    if n == 0 then
      car(xs)
    else
      nth(cdr(xs), n - 1)
    end
  end
end

// 長さ
def length(xs)
  let
    c = 0
  in
    while !null(xs) do
      c = c + 1,
      xs = cdr(xs)
    end,
    c
  end
end

// 反転
def reverse(xs)
  let
    ys = nil
  in
    while !null(xs) do
      ys = cons(car(xs), ys),
      xs = cdr(xs)
    end,
    ys
  end
end

// リストに x が含まれているか
def member(x, ls)
  while !null(ls) and !eql(car(ls), x) do
    ls = cdr(ls)
  end,
  ls
end

// 連結
def append(xs, ys)
  if null(xs) then
    ys
  else
    cons(car(xs), append(cdr(xs), ys))
  end
end

// x と等しい要素を削除
def remove(x, ls)
  if null(ls) then
    nil
  else
    if eql(x, car(ls)) then
      remove(x, cdr(ls))
    else
      cons(car(ls), remove(x, cdr(ls)))
    end
  end
end

// マッピング
def map(f, xs)
  if null(xs) then
    nil
  else 
    cons(f(car(xs)), map(f, cdr(xs)))
  end
end

// フィルター
def filter(f, xs)
  if null(xs) then
    nil
  else
    if f(car(xs)) then
      cons(car(xs), filter(f, cdr(xs)))
    else
      filter(f, cdr(xs))
    end
  end
end

// 畳み込み
def foldl(f, a, xs)
  while !null(xs) do
    a = f(car(xs), a),
    xs = cdr(xs)
  end,
  a
end

def foldr(f, a, xs)
  if null(xs) then
    a
  else
    f(car(xs), foldr(f, a, cdr(xs)))
  end
end

// 巡回
def foreach(f, ls)
  while !null(ls) do
    f(car(ls)),
    ls = cdr(ls)
  end
end

// 2 つのリストをまとめる
def zip(xs, ys)
  if null(xs) or null(ys) then
    nil
  else
    cons(cons(car(xs), car(ys)), zip(cdr(xs), cdr(ys)))
  end
end

// 平坦化
def flatten(ls)
  if null(ls) then
    nil
  else
    if pair(ls) then
      append(flatten(car(ls)), flatten(cdr(ls)))
    else
      cons(ls, nil)
    end
  end
end

// リストの先頭から n 個の要素を取り出す
def take(xs, n)
  if n == 0 or null(xs) then
    nil
  else
    cons(car(xs), take(cdr(xs), n - 1))
  end
end

// リストの先頭から n 個の要素を取り除く
def drop(xs, n)
  if n == 0 or null(xs) then
    xs
  else
    drop(cdr(xs), n - 1)
  end
end

// リストの生成
def makelist(n, x)
  let
    xs = nil
  in
    while n &gt; 0 do
      xs = cons(x, xs),
      n = n - 1
    end,
    xs
  end
end

def iota(n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(m, xs),
      m = m - 1
    end,
    xs
  end
end

def tabulate(f, n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(f(m), xs),
      m = m - 1
    end,
    xs
  end
end

// リストの表示
def printlist(xs)
  print("("),
  while pair(xs) do
    if pair(car(xs)) or null(car(xs)) then
      printlist(car(xs))
    else
      print(car(xs))
    end,
    if pair(cdr(xs)) then print(" ") end,
    xs = cdr(xs)
  end,
  if !null(xs) then
    begin print(" . "), print(xs) end
  end,
  print(")"),
  nil
end

// ベクタをリストに変換する
def fromVector(xs)
  let
    i = len(xs) - 1,
    a = nil
  in
    while i &gt;= 0 do
      a = cons(xs[i], a),
      i = i - 1
    end,
    a
  end
end

// 順列
def permSub(f, n, xs, a)
  if n == 0 then
    f(reverse(a))
  else
    foreach(fn(x) permSub(f, n - 1, remove(x, xs), cons(x, a)) end, xs)
  end
end

def permutation(f, n, xs)
  permSub(f, n, xs, nil)
end

// 組み合わせ
def combSub(f, n, xs, a)
  if n == 0 then
    f(reverse(a))
  else
    if length(xs) == n then
      f(append(reverse(a), xs))
    else
      begin
        combSub(f, n - 1, cdr(xs), cons(car(xs), a)),
        combSub(f, n, cdr(xs), a)
      end
    end
  end
end

def combination(f, n, xs)
  combSub(f, n, xs, nil)
end

// マージ
def merge(xs, ys, pred)
  if null(xs) or null(ys) then
    if null(xs) then ys else xs end
  else
    if pred(car(xs), car(ys)) then
      cons(car(xs), merge(cdr(xs), ys, pred))
    else
      cons(car(ys), merge(xs, cdr(ys), pred))
    end
  end
end

// マージソート
def mergeSort(xs, n, pred)
  if n == 1 then
    cons(car(xs), nil)
  else
    let
      m = n / 2
    in
      merge(mergeSort(xs, m, pred),
            mergeSort(drop(xs, m), n - m, pred),
            pred)
    end
  end
end

// リストの破壊的な修正
def listSet(xs, n, v)
  if null(xs) then
    nil
  else
    if n == 0 then
      setCar(xs, v)
    else
      listSet(cdr(xs), n - 1, v)
    end
  end
end

// リストを破壊的に反転する
def nrevSub(xs, a)
  if null(xs) then
    a
  else
    let ys = cdr(xs) in
      setCdr(xs, a),
      nrevSub(ys, xs)
    end
  end
end

def nreverse(xs)
  nrevSub(xs, nil)
end
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo23.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo25.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>