<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Yet Another Golang Problems</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881807</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>Yet Another Golang Problems</h2>
<div class="small">
[ PrevPage | <a href="index.html#yagp">Golang</a> | <a href="yagp02.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>はじめに</h3>
<p> このページは M.Hiroi が Go 言語の勉強で作成した簡単なプログラムをまとめたものです。元ネタは <a href="http://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">P-99: Ninety-Nine Prolog Problems</a> で、拙作のページ <a href="../prolog/yapp01.html">Yet Another Prolog Problems</a> や <a href="../func/scheme.html#yasp">Yet Another Scheme Problems</a> などの Go 言語バージョンになります。同じような問題が多くなると思いますが、あしからずご了承くださいませ。
</p>

<h4>●問題１</h4>
<p> 整数 n から m までの和、二乗の和、三乗の和を求める関数 sumofInt, sumOfSquare, sumofCube を定義してください。
</p>
<pre class="item">
func sumofInt(n, m int) int
func sumofSquare(n, m int) int
func sumofCube(n, m int) int
</pre>
<p> <a href="yagp01.html#ans01">解答</a>
</p>

<h4>●問題２</h4>
<p> 素因数分解とは、素数でない整数 (合成数) を素数の積の形に書き表すことです。たとえば、12 は 2 * 2 * 3 と素因数分解することができます。素因数分解を行う関数 primeFactor を定義してください。結果は画面 (標準出力) へ出力するものとします。
</p>
<pre class="item">
func primeFactor(n int) 
</pre>
<p> <a href="yagp01.html#ans02">解答</a>
</p>

<h4>●問題３</h4>
<p> 下図に示すフィボナッチ関数 fibo を定義してください。
</p>
<pre class="fig">
          ┌ 1;                     n = 0
fibo(n) = ┤ 1;                     n = 1
          └ fibo(n-1) + fibo(n-2); n > 1

1, 1, 2, 3, 5, 8, 13 .... という直前の 2 項を足していく数列

    図 : フィボナッチ関数の定義
</pre>
<pre class="item">
func fibo(n int) int
</pre>
<p> <a href="yagp01.html#ans03">解答</a>
</p>
<h4>●問題４</h4>
<p> n 個の中から r 個を選ぶ組み合わせの数 <SUB>n</SUB>Ｃ<SUB>r</SUB> を求める関数 combNum(n, r) を定義してください。
</p>
<pre class="item">
func combNum(n, r int) int
</pre>
<p><a href="yagp01.html#ans04">解答</a>
</p>

<h4>●問題５</h4>
<p> 次の公式を使って平方根の整数部分を求める関数 sqrtInt を定義してください。
</p>
<pre class="item">
(1) 1 + 3 + 5 + ... + (2n - 1) = n<sup>2</sup>
(2) 1 + 3 + 5 + ... + (2n - 1) = n<sup>2</sup> &lt; m &lt; 1 + 3 + ... (2n - 1) + (2n + 1) = (n + 1)<sup>2</sup>
</pre>
<p> 式 (1) は、奇数 1 から 2n - 1 の総和は n<sup>2</sup> になることを表しています。式 (2) のように、整数 m の値が n<sup>2</sup> より大きくて (n + 1)<sup>2</sup> より小さいのであれば、m の平方根の整数部分は n であることがわかります。これは m から奇数 1, 3, 5 ... (2n - 1), (2n + 1)  を順番に引き算していき、引き算できなくなった時点の (2n + 1) / 2 = n が m の平方根になります。<a href="yagp01.html#cite1">参考文献 [1]</a> によると、この方法を「めのこ平方」と呼ぶそうです。
</p>
<pre class="item">
func sqrtInt(n int) int
</pre>
<pre>
sqrtInt(10) =&gt;3
sqrtInt(100) =&gt;10
sqrtInt(1000) =&gt;31
sqrtInt(10000) =&gt;100
sqrtInt(123456789) =&gt; 11111
</pre>
<p><a href="yagp01.html#ans05">解答</a>
</p>
<div class="note">
-- <a name="cite1">参考文献</a> --------<br>
[1] <a href="http://antlers.cis.ibaraki.ac.jp/">仙波一郎のページ</a>, <a href="http://antlers.cis.ibaraki.ac.jp/PROGRAM/CPROG/235.pdf">『平方根計算法 (PDF)』</a>
</div>
<h4>●問題６</h4>
<p> 点を多角形の形に並べたとき、その総数を「多角数 (polygonal number) 」といいます。三角形に配置したものを三角数、四角形に配置したものを四角数、五角形に配置したものを五角数といいます。三角数、四角数、五角数を下図に示します。
</p>

<pre class="fig">
１    ３      ６        10          15
●    ●      ●        ●          ●
     ●●    ●●      ●●        ●●
            ●●●    ●●●      ●●●
                     ●●●●    ●●●●
                                ●●●●●

            図 : 三角数
</pre>

<pre class="fig">
１   ４      ９        16          25
●  ●●   ●●●   ●●●●   ●●●●●
    ●●   ●●●   ●●●●   ●●●●●
           ●●●   ●●●●   ●●●●●
                    ●●●●   ●●●●●
                               ●●●●●

            図 : 四角数
</pre>

<pre class="fig">
１       ５             12                      22
●       ●             ●                      ●
      ●    ●       ●    ●               ●      ●
                 ●            ●        ●             ●
       ●  ●         ●              ●      ●           ●
                   ●    ●  ●            ●     ●
                                       ●            ●  ●
                     ● ● ●               ●
                                         ●     ● ●  ●

                                           ● ● ● ●

            図 : 五角数
</pre>
<p> n 番目の p 角数を求める関数 polygonalNum を定義してください。
</p>
<pre class="item">
func polygonalNum(p, n int) int
</pre>
<pre>
polygonalNum(3, 1) =&gt; 1
polygonalNum(3, 2) =&gt; 3
polygonalNum(3, 3) =&gt; 6
polygonalNum(4, 1) =&gt; 1
polygonalNum(4, 2) =&gt; 4
polygonalNum(4, 3) =&gt; 9
polygonalNum(5, 1) =&gt; 1
polygonalNum(5, 2) =&gt; 5
polygonalNum(5, 3) =&gt; 12
</pre>
<p> <a href="yagp01.html#ans06">解答</a>
</p>
<h4>●問題７</h4>
<p> 配列 (スライス) に格納されている実数 (float64) の平均値と標準偏差を求める関数 meanSD を定義してください。
</p>

<p> データを x<sub>1</sub>, x<sub>2</sub>, ... , x<sub>N</sub> とすると、総計量 (合計値) と平均値は次式で求めることができます。
</p>
<pre class="fig">
総計量 T = x<sub>1</sub> + x<sub>2</sub> + ... + x<sub>N</sub>

            N
         = Σ x<sub>i</sub>
           i=1

平均値 M = (x<sub>1</sub> + x<sub>2</sub> + ... + x<sub>N</sub>) / N

                    N
         = (1/N) * Σ x<sub>i</sub>
                   i=1
</pre>
<p> 平均値が同じ場合でも、データの特徴が異なる場合があります。たとえば、A = {4, 4, 5, 5, 5, 6, 6, 6, 7, 7} と B = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} の平均値は 5.5 になります。A のデータは平均値の近くに集まっていてますが、B のデータはバラバラになっていますね。統計学では、ばらつきの大きさを表すために「分散 (variance) 」という値を使います。分散の定義を次に示します。
</p>
<pre class="fig">
分散 S<sup>2</sup> = ((x<sub>1</sub> - M)<sup>2</sup> + (x<sub>2</sub> - M)<sup>2</sup> + ... + (x<sub>N</sub> - M)<sup>2</sup>) / N

                   N
        = (1/N) * Σ (x<sub>i</sub> - M)<sup>2</sup>
                  i=1

標準偏差 S = √(S<sup>2</sup>)
</pre>
<p> 分散の定義からわかるように、平均値から離れたデータが多いほど、分散の値は大きくなります。逆に、平均値に近いデータが多くなると分散は小さな値になります。そして、分散の平方根が「標準偏差 (SD : standard deviation) 」になります。
</p>

<pre class="list">
リスト : テストデータ (乱数で作成した身長のデータ)

var height []float64 = []float64{
    148.7, 149.5, 133.7, 157.9, 154.2, 147.8, 154.6, 159.1, 148.2, 153.1,
    138.2, 138.7, 143.5, 153.2, 150.2, 157.3, 145.1, 157.2, 152.3, 148.3,
    152.0, 146.0, 151.5, 139.4, 158.8, 147.6, 144.0, 145.8, 155.4, 155.5,
    153.6, 138.5, 147.1, 149.6, 160.9, 148.9, 157.5, 155.1, 138.9, 153.0,
    153.9, 150.9, 144.4, 160.3, 153.4, 163.0, 150.9, 153.3, 146.6, 153.3,
    152.3, 153.3, 142.8, 149.0, 149.4, 156.5, 141.7, 146.2, 151.0, 156.5,
    150.8, 141.0, 149.0, 163.2, 144.1, 147.1, 167.9, 155.3, 142.9, 148.7,
    164.8, 154.1, 150.4, 154.2, 161.4, 155.0, 146.8, 154.2, 152.7, 149.7,
    151.5, 154.5, 156.8, 150.3, 143.2, 149.5, 145.6, 140.4, 136.5, 146.9,
    158.9, 144.4, 148.1, 155.5, 152.4, 153.3, 142.3, 155.3, 153.1, 152.3,
}
</pre>
<pre class="item">
func meanSD(data []float64) (float64, float64)
</pre>
<pre>
meadSD(height) =&gt; 150.62699999999998 6.433472701426501
</pre>
<p> <a href="yagp01.html#ans07">解答</a>
</p>

<h4>●問題８</h4>
<p> 配列 (スライス) の部分列の中から最大値を求める関数 maximum と 最小値を求める関数 minimum を定義してください。maximum と minimum は値とその位置を返すものとします。また、部分列の指定はスライスと同じで、省略することができるものとします。
</p>
<pre class="item">
maximum(buff)        // buff[0:len(buff)] の中から最大値を求める
maximum(buff, s)     // buff[s:len(buff)] の中から最大値を求める
maximum(buff, s, e)  // buff[s:e] の中から最大値を求める
</pre>
<pre class="item">
func maximum(buff []int, args ... int) (int, int)
func minimum(buff []int, args ... int) (int, int)
</pre>
<p> <a href="yagp01.html#ans08">解答</a>
</p>
<h4>●問題９</h4>
<p> 選択ソート (selection sort) は、ソートしていないデータの中から最小値（または最大値）を見つけ、それを先頭のデータと交換する、という手順を繰り返すことでソートを行います。最初は、すべてのデータの中から最小値を探し、それを配列の先頭 buff[0] と交換します。次は、buff[1] 以降のデータの中から最小値を探し、それを buff[1] と交換します。これを繰り返すことでソートすることができます。
</p>
<pre class="fig">
 [9 5 3 7 6 4 8]   3 と 9 を交換する
  +   +

 3 [5 9 7 6 4 8]   5 と 4 を交換する
    +       +

 3 4 [9 7 6 5 8]   9 と 5 を交換する
      +     +

 3 4 5 [7 6 9 8]   7 と 6 を交換する
        + +

 3 4 5 6 [7 9 8]   7 と 7 を交換する
          +

 3 4 5 6 7 [9 8]   9 と 8 を交換してソート終了
            + +

  図 : 選択ソート
</pre>
<p> 配列 (スライス) を選択ソートする関数 selectSort を定義してください。
</p>
<pre class="item">
func selectSort(buff []int) []int
</pre>
<p> <a href="yagp01.html#ans09">解答</a>
</p>
<h4>●問題10</h4>
<p> バブルソート (buble sort) は泡がぶくぶくと浮いてくるように、いちばん小さいデータが後ろから前に浮かび上がってくるアルゴリズムです。隣接する 2 つのデータを比較して、順序が逆であれば入れ換えます。これを順番に後ろから前に行っていけば、いちばん小さなデータは頂上に浮かび上がっているというわけです。先頭が決まったならば、残りのデータに対して同じことを行えば、2 番目には残りのデータの中でいちばん小さいものが浮かび上がります。これをデータ数だけ繰り返せばソートが完了します。
</p>
<pre class="fig">
 9 5 3 7 6 4 8   交換しない
           ~~~
 9 5 3 7 6 4 8   交換する
         ~~~
 9 5 3 7 4 6 8   交換する
       ~~~
 9 5 3 4 7 6 8   交換しない
     ~~~
 9 5 3 4 7 6 8   交換する
   ~~~
 9 3 5 4 7 6 8   交換する
 ~~~
 3 9 5 4 7 6 8   いちばん小さいデータが決定する
 +               残りのデータに対して同様な操作を行う

    図 : バブルソート
</pre>
<p> スライスをバブルソートする関数 bubleSort を定義してください。
</p>
<pre class="item">
func bubleSort(buff []int) []int
</pre>
<p> <a href="yagp01.html#ans10">解答</a>
</p>
<hr>
<h4 id="ans01">●解答１</h4>
<p> まず最初に、単純なループでプログラムを作ってみましょう。
</p>
<pre class="list">
リスト : 整数の和、二乗の和、三乗の和

func sumOfInt(n, m int) int {
    a := 0
    for ; n &lt;= m; n++ {
        a += n
    }
    return a
}

func sumOfSquare(n, m int) int {
    a := 0
    for ; n &lt;= m; n++ {
        a += n * n
    }
    return a
}

func sumOfCube(n, m int) int {
    a := 0
    for ; n &lt;= m; n++ {
        a += n * n * n
    }
    return a
}
</pre>
<p> 簡単なプログラムなので説明は不要ですね。ところで、数列の和を求める公式を使うと、プログラムはもっと簡単になります。
</p>
<ul>
  <li>1 + 2 + 3 + ... + n = n(n+1)/ 2
  <li>1 + 2<sup>2</sup> + 3<sup>2</sup> + ... + n<sup>2</sup> = n(n+1)(2n+1)/6
  <li>1 + 2<sup>3</sup> + 3<sup>3</sup> + ... + n<sup>3</sup> = n<sup>2</sup>(n+1)<sup>2</sup>/4
</ul>
<pre class="list">
リスト : 別解

func sumOfInt0(n, m int) int {
    sum := func(x int) int { return x * (x + 1) / 2}
    return sum(m) - sum(n - 1)
}

func sumOfSquare0(n, m int) int {
    sum := func(x int) int {
        return x * (x + 1) * (2 * x + 1) / 6
    }
    return sum(m) - sum(n - 1)
}

func sumOfCube0(n, m int) int {
    sum := func(x int) int {
        return x * x * (x + 1) * (x + 1) / 4
    }
    return sum(m) - sum(n - 1)
}
</pre>
<p> 公式を匿名関数でプログラムして、それを変数 sum にセットします。あとは sum(m) から sum(n - 1) を引き算すれば解を求めることができます。
</p>

<h4 id="ans02">●解答２</h4>
<pre class="list">
リスト : 素因数分解 (prime.go)

package main

import "fmt"

func primeFactor(n int) {
    // 2 で割り算する
    for ; n % 2 == 0; n /= 2 {
        fmt.Print(2, " ")
    }
    // 奇数で割り算する
    for i := 3; i * i &lt;= n; i += 2 {
        for ; n % i == 0; n /= i {
            fmt.Print(i, " ")
        }
    }
    if n &gt; 1 {
        fmt.Println(n)
    }
}

func main() {
    primeFactor(1234567890)
}
</pre>
<p> 最初に 2 で割り算します。それから、奇数で割り算していきます。割り算するときは、その数で割り切れるあいだは割り算を続けることに注意してください。たとえば、27 を素因数分解すると 3 * 3 * 3 になりますが、3 を一回だけしか割り算しないと、結果は 3 * 9 のように素数ではない数が含まれてしまいます。
</p>

<p> 実行結果は次のようになります。
</p>
<pre>
C&gt;go run prime.go
2 3 3 5 3607 3803
</pre>
<p> どの数も素数で、2 * 3 * 3 * 5 * 3607 * 3803 を計算すると 1234567890 になります。なお、これはとても単純なアルゴリズムなので、大きな整数の素因数分解には適していません。巨大な合成数の素因数分解はとても難しい問題です。興味のある方は素因数分解について調べてみてください。
</p>

<h4 id="ans03">●解答３</h4>
<p> フィボナッチ関数は再帰呼び出しを使えば簡単にプログラムできます。
</p>
<pre class="list">
リスト : フィボナッチ関数

func fibo(n int) int {
    if n &lt; 2 {
        return 1
    } else {
        return fibo(n - 1) + fibo(n - 2)
    }
}
</pre>

<p> 関数 fibo は自分自身を 2 回呼び出しています。これを「二重再帰」といいます。fibo の呼び出しをトレースすると下図のようになります。
</p>
<pre class="fig">
  fibo(5) ┬ fibo(4) ┬ fibo(3) ┬ fibo(2) ┬ fibo(1)  
          │         │         │         │
          │         │         │         └ fibo(0)
          │         │         └ fibo(1)
          │         └ fibo(2) ┬ fibo(1)
          │                    │
          │                    └ fibo(0)
          │
          └ fibo(3) ┬ fibo(2) ┬ fibo(1)
                     │         │
                     │         └ fibo(0)
                     └ fibo(1)

  図 : 関数 fibo のトレース
</pre>

<p> 同じ値を何回も求めているため、関数 fibo の効率はとても悪いのです。この場合、二重再帰を「末尾再帰」に変換すると高速化することができます。そこで累算変数を使って、二重再帰を末尾再帰へ変換してみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : フィボナッチ関数（末尾再帰）

func fiboSub(n, a1, a2 int) int {
    if n &lt; 1 {
        return a1
    } else {
        return fiboSub(n - 1, a1 + a2, a1)
    }
}

func fiboi(n int) int {
    return fiboSub(n, 1, 0)
}
</pre>

<p> 関数 fiboSub の累算変数 a1 と a2 の使い方がポイントです。現在のフィボナッチ数を変数 a1 に、ひとつ前の値を変数 a2 に格納しておきます。あとは a1 と a2 を足し算して、新しいフィボナッチ数を計算すればいいわけです。fiboSub の呼び出しを下図に示します。
</p>
<pre class="fig">
fiboSub(5, 1, 0)
  fiboSub(4, 1, 1)
    fiboSub(3, 2, 1)
      fiboSub(2, 3, 2)
        fiboSub(1, 5, 3)
          fiboSub(0, 8, 5)
          =&gt; a1 の値 8 を返す
        =&gt; 8
      =&gt; 8
    =&gt; 8
  =&gt; 8
=&gt; 8

  図 : 関数 fiboSub の呼び出し
</pre>

<p> 二重再帰では、同じ値を何回も求めていたため効率がとても悪かったのですが、このプログラムでは無駄な計算を行っていないので、値を高速に求めることができます。もちろん、末尾再帰になっているので、末尾再帰最適化を行う処理系では、プログラムをより高速に実行することができます。
</p>

<p> Go 言語の場合、末尾再帰最適化はサポートされていませんが、末尾再帰を繰り返しに変換することは簡単です。関数 fibo を繰り返しに変換すると次のようになります。
</p>

<pre class="list">
リスト : フィボナッチ関数（繰り返し）

func fibol(n int) int {
    a1, a2 := 1, 0
    for ; n &gt; 0; n-- {
        a1, a2 = a1 + a2, a1
    }
    return a1
}
</pre>

<p> このように、末尾再帰は簡単に繰り返しに変換することができます。
</p>

<h4 id="ans04">●解答４</h4>
<p> 組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> を (n, r) と表記します。(n, r) を求めるには、次の公式を使えば簡単です。
</p>
<pre class="item">
(n, r) = n * (n - 1) * (n - 2) * ... * (n - r + 1) / (1 * 2 * 3 * ... * r)
</pre>
<p> 皆さんお馴染みの公式ですね。ところが、整数値の範囲が限られているプログラミング言語では、この公式を使うと乗算で「桁あふれ」を起こす恐れがあります。Go 言語の整数 (int や int64 など) は多倍長整数ではないので、この公式をそのままプログラムするわけにはいきません。そこで、次の公式を使うことにします。
</p>
<pre class="item">
(n, 0) = (n, n) = 1
(n, r) = (n, r - 1) * (n - r + 1) / r
</pre>
<p> この式は (n, r) と (n, r - 1) の関係を表しています。あとは階乗やフィボナッチ関数と同じように、再帰定義を使って簡単にプログラムできます。次のリストを見てください。
</p>

<pre class="list">
リスト : 組み合わせの数を求める

func combNum(n, r int) int {
    if n == r || r == 0 {
        return 1
    } else {
        return combNum(n, r - 1) * (n - r + 1) / r
    }
}
</pre>

<p> とても簡単ですね。ところで、M.Hiroi が使用している Go 言語の int は 32 bit なので、このプログラムでも桁あふれする場合があります。どこまで計算できるか試してみましょう。
</p>
<pre class="item">
combNum(16, 8)  =&gt; 12870
combNum(18, 9)  =&gt; 48620
combNum(20, 10) =&gt; 184756
combNum(22, 11) =&gt; 705432
combNum(24, 12) =&gt; 2704156
combNum(26, 13) =&gt; 10400600
combNum(28, 14) =&gt; 40116600
combNum(30, 15) =&gt; -131213633
</pre>
<p> Go 言語の場合、桁あふれが発生してもランタイムエラーは発生しません。int のかわりに int64 を使うと、もう少し大きな値も計算することができます。
</p>
<pre class="item">
combNum(32, 16) =&gt; 601080390
combNum(34, 17) =&gt; 2333606220
combNum(36, 18) =&gt; 9075135300
combNum(38, 19) =&gt; 35345263800
combNum(40, 20) =&gt; 137846528820
combNum(42, 21) =&gt; 538257874440
combNum(44, 22) =&gt; 2104098963720
combNum(46, 23) =&gt; 8233430727600
combNum(48, 24) =&gt; 32247603683100
combNum(50, 25) =&gt; 126410606437752
combNum(52, 26) =&gt; 495918532948104
combNum(54, 27) =&gt; 1946939425648112
combNum(56, 28) =&gt; 7648690600760440
combNum(58, 29) =&gt; 30067266499541040
combNum(60, 30) =&gt; 118264581564861424
combNum(62, 31) =&gt; -284401161134521734
</pre>
<p> もっと大きな値を計算したい場合はパッケージ math/big を使ってみてください。big には多倍長整数を扱う関数が多数用意されています。
</p>

<h4 id="ans05">●解答５</h4>
<pre class="list">
リスト : めのこ平方

func sqrtInt(n int) int {
    m := 1
    for ; n &gt;= m; m += 2 {
        n -= m
    }
    return m / 2
}
</pre>
<p> アルゴリズムをそのままプログラムしただけなので、とくに難しいところは無いと思います。この方法はとても簡単ですが、数が大きくなると時間がかかるようになります。そこで、整数を 2 桁ずつ分けて計算していくことにします。次の図を見てください。
</p>
<pre class="fig">
整数 6789 を 67 と 89 に分ける

1 + 3 + ... + 15 = 8<sup>2</sup> &lt; 67

両辺を 100 倍すると 80<sup>2</sup> &lt; 6700 &lt; 6789

80<sup>2</sup> = 1 + 3 + ... + 159 (= 2 * 80 - 1)

161 + 163 &lt; (6789 - 6400 = 389) &lt; 161 + 163 + 165
</pre>
<p> 整数 6789 を 67 と 89 に分けます。最初に 67 の平方根を求めます。この場合は 8 になり、8<sup>2</sup> &lt; 67 を満たします。次に、この式を 100 倍します。すると、80<sup>2</sup> &lt; 6700 になり、6700 に 89 を足した 6789 も 80<sup>2</sup> より大きくなります。80<sup>2</sup> は 1 から 159 までの奇数の総和であることはすぐにわかるので、6789 - 6400 = 389 から奇数 161, 163, ... を順番に引き算していけば 6789 の平方根を求めることができます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : めのこ平方 (改良版)

func sqrtIntSub(n, m int) int {
    for ; n &gt;= m; m += 2 {
        n -= m
    }
    return m / 2
}

func sqrtInt1(n int) int {
    if n &lt; 100 {
        return sqrtIntSub(n, 1)
    } else {
        m := 10 * sqrtInt1(n / 100)
        return sqrtIntSub(n - m * m, 2 * m + 1)
    }
}
</pre>
<p> sqrtInt1 は n の平方根の整数部分を求めます。n が 100 未満の場合は sqrtIntSub で平方根を求めます。これが再帰呼び出しの停止条件になります。n が 100 以上の場合は、n の下位 2 桁を取り除いた値 (n / 100) の平方根を sqrtInt1 で求め、その値を 10 倍して変数 m にセットします。そして、sqrIntSub で n - m * m から奇数 2 * m + 1, 2 * m + 3 ... を順番に引き算していって n の平方根を求めます。
</p>

<h4 id="ans06">●解答６</h4>
<p> 多角数の点の増分を表に示すと、次のようになります。
</p>
<pre class="fig">
 n   三角数            四角数             五角数
---+-----------------------------------------------------------
 1 |  1                 1                  1
 2 |  3 = 1+2           4 = 1+3            5 = 1+4
 3 |  6 = 1+2+3         9 = 1+3+5         12 = 1+4+7
 4 | 10 = 1+2+3+4      16 = 1+3+5+7       22 = 1+4+7+10
 5 | 15 = 1+2+3+4+5    25 = 1+3+5+7+9     35 = 1+4+7+10+13
 6 | 21 = 1+2+3+4+5+6  36 = 1+3+5+7+9+11  51 = 1+4+7+10+13+16

      ・・・・・・      ・・・・・・・     ・・・・・

 n | n(n + 1) / 2      n^2                n(3n - 1) / 2
</pre>
<p> 表を見ればお分かりのように、三角数は公差 1、四角数は公差 2、五角数は公差 3、p 角数は公差 p - 2 の等差数列の和になります。初項を a, 公差を d とすると、等差数列の和 S<sub>n</sub> は次式で求めることができます。
</p>
<pre class="item">
S<sub>n</sub> = n(2a + (n - 1)d) / 2
</pre>
<p> a = 1, d = p - 2 を代入して計算すると、多角数 P<sub>p,n</sub> は次式で求めることができます。
</p>
<pre class="item">
P<sub>p,n</sub> = ((p - 2)n^2 - (p - 4)n) / 2
</pre>
<p> この式を Go 言語でプログラムすると、次のようになります。
</p>
<pre class="list">
リスト : 多角数 (polygon.go)

package main

import "fmt"

func polygonalNum(p, n int) int {
    return ((p - 2) * n * n - (p - 4) * n) / 2
}

func main() {
    for p := 3; p &lt;= 8; p++ {
        for i := 1; i &lt;= 20; i++ {
            fmt.Print(polygonalNum(p, i), " ")
        }
        fmt.Println("")
    }
}
</pre>
<p> それでは実行してみましょう。
</p>
<pre>
C&gt;go run polygon.go
1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210
1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400
1 5 12 22 35 51 70 92 117 145 176 210 247 287 330 376 425 477 532 590
1 6 15 28 45 66 91 120 153 190 231 276 325 378 435 496 561 630 703 780
1 7 18 34 55 81 112 148 189 235 286 342 403 469 540 616 697 783 874 970
1 8 21 40 65 96 133 176 225 280 341 408 481 560 645 736 833 936 1045 1160
</pre>
<p> p 角数の初項は 1 で、第 2 項は p になります。<a href="http://ja.wikipedia.org/wiki/%E5%A4%9A%E8%A7%92%E6%95%B0">多角数 - Wikipedia</a> によると、多角数にはいろいろな面白い性質があるようです。
</p>

<h4 id="ans07">●解答７</h4>
<p> 平均値と標準偏差を求めるプログラムは簡単です。次のリストを見てください。
</p>

<pre class="list">
リスト : 平均値と標準偏差

// 合計値を求める
func sum(buff []float64) float64 {
    a := 0.0
    for _, v := range buff {
        a += v
    }
    return a
}

func meanSD(buff []float64) (float64, float64) {
    n := float64(len(buff))
    m := sum(buff) / n
    s := 0.0
    for _, x := range buff {
        s += (x - m) * (x - m)
    }
    return m, math.Sqrt(s / n)
}
</pre>

<p> プログラムは簡単なので、説明は不要でしょう。
</p>

<p> <a href="yagp01.html#cite2">参考文献 [2]</a> によると、データを 1 回通読するだけで平均値と標準偏差 (分散) を求めることができるそうです。参考文献 [2] のプログラムを Go 言語で書き直すと、次のようになります。
</p>

<pre class="list">
リスト : 平均値と標準偏差 (2)

func meanSD2(buff []float64) (float64, float64) {
    n := float64(len(buff))
    m, s := 0.0, 0.0
    for i, x := range buff {
        x -= m
        m += x / float64(i + 1)
        s += float64(i) * x * x / float64(i + 1)
    }
    s = math.Sqrt(s / n)
    return m, s
}
</pre>

<p> 関数 meanSD2 でデータ height の平均値と標準偏差を求めると、次のようになります。
</p>
<pre>
150.62699999999998 6.433472701426506
</pre>
<p> 平均値は 150.63 cm で、標準偏差は 6.43 cm になりました。
</p>

<div class="note">
-- <a name="cite2">参考文献</a> --------<br>
[2] 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
</div>

<h4 id="ans08">●解答８</h4>
<pre class="list">
リスト : 最大値と最小値

// 引数の取得
func getRange(buff, args []int) (int, int) {
    var s, e int
    switch len(args) {
    case 0:  s, e = 0, len(buff)
    case 1:  s, e = args[0], len(buff)
    default: s, e = args[0], args[1]
    }
    return s, e
}

// 最小値を求める
func minimum(buff []int, args ... int) (int, int) {
    s, e := getRange(buff, args)
    m := s
    for s++ ; s &lt; e; s++ {
        if buff[s] &lt; buff[m] {
            m = s
        }
    }
    return buff[m], m
}

// 最大値を求める
func maximum(buff []int, args ... int) (int, int) {
    s, e := getRange(buff, args)
    m := s
    for s++ ; s &lt; e; s++ {
        if buff[s] &gt; buff[m] {
            m = s
        }
    }
    return buff[m], m
}
</pre>
<p> 部分列の範囲指定は minimum, maximum の可変長引数 args で受け取ります。そして、部分列の範囲は関数 getRange で求めます。args の長さが 0 ならば、始点が 0 で終点が len(buff) になり、args の長さが 1 ならば、始点が args[0] で終点が len(buff) になります。それ以外の場合は始点が args[0] で終点が args[1] です。
</p>
<p> minimum と maximum は getRange を呼び出して始点と終点を変数 s, e にセットします。そして、始点 s の要素を仮の最小値 (または最大値) として、その位置を変数 m にセットします。あとは、s + 1 から e 未満の範囲で buff[m] と buff[s] を比較して、buff[s] が小さい (または大きい) 場合は m の値を s に更新します。最後に buff[m] と m を返します。
</p>

<h4 id="ans09">●解答９</h4>
<pre class="list">
リスト : 選択ソート

func selectSort(buff []int) []int {
    k := len(buff)
    for i := 0; i &lt; k - 1; i++ {
        v, m := minimum(buff, i, k)
        buff[i], buff[m] = v, buff[i]
    }
    return buff
}
</pre>
<p> 選択ソートは関数 minimum を使うと簡単です。データの個数を変数 k にセットします。最初のループで変数 i の値は 0 から k - 1 まで動きます。そして、minimum で buff[i] から buff[k - 1] までの中から最小値を探し、それを buff[i] と交換するだけです。
</p>

<h4 id="ans10">●解答10</h4>
<pre class="list">
リスト : バブルソート

func bubleSort(buff []int) []int {
    k := len(buff) - 1
    for i := 0; i &lt; k; i++ {
        for j := k; j &gt; i; j-- {
            if buff[j - 1] &gt; buff[j] {
                buff[j - 1], buff[j] = buff[j], buff[j - 1]
            }
        }
    }
    return buff
}
</pre>
<p> 最初のループで k 回 (データの個数 - 1) だけ繰り返します。2 番目のループで buff の後ろから前に向かって、確定していないデータを比較していき、もしも順番が逆になっていたら交換します。
</p>
<p> 選択ソートとバブルソートは簡単なアルゴリズムですが、データ数が多くなると時間がかかります。データ数を n とすると実行時間は n の 2 乗に比例します。選択ソートとバブルソートは遅いアルゴリズムなのです。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ PrevPage | <a href="index.html#yagp">Golang</a> | <a href="yagp02.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>