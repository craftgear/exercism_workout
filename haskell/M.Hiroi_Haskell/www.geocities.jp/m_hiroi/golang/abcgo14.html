<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881805</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo13.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo15.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>並列プログラミング</h3>
<p> 今回は Go 言語で「並列 (parallel) プログラミング」に挑戦してみましょう。なお、M.Hiroi はマルチコア CPU で動作するプログラムを作るのはこれが初めてです。初心者が作るプログラムなので、何か問題点や間違いがあるかもしれません。お気づきの点がありましたら、ご指摘いただけると助かります。
</p>

<h4>●コア数の設定</h4>
<p> Go 言語 (ver 1.2) はマルチコア CPU に対応していますが、デフォルトの設定では使用する CPU のコア数が 1 になっています。複数の goroutine を複数のコアで並列に実行させるには、使用するコア数を runtime パッケージの関数 GOMAXPROCS で指定するか、環境変数 GOMAXPROCS で指定する必要があります。
</p>
<pre class="item">
func GOMAXPROCS(n int) int
</pre>
<p> 引数 n は同時に使用可能な最大コア数で、返り値は前に設定されていたコア数です。n &lt; 1 の場合、コア数を変更せずに現在設定されているコア数を返します。なお、Go 言語のスケジューラが改善されたときには、この呼び出しは不要になるそうです。本稿では関数 GOMAXPROCS でコア数を指定することにします。
</p>

<p> 利用できる CPU のコア数は runtime パッケージの関数 NumCPU で取得できます。
</p>
<pre class="item">
func NumCPU() int
</pre>
<p> 関数　NumGoroutine は現存している goroutine の数を返します。
</p>
<pre class="item">
func NumGoroutine() int
</pre>
<p> M.Hiroi のパソコンは物理コア数が 4 で、1 コアにつきハイパースレッディングで 2 分割できるので、NumCPU の値は 4 * 2 = 8 になります。実際に確かめてみましょう。
</p>
<pre class="list">
リスト : コア数を表示する (sample1400.go)

package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Println(runtime.NumCPU())
    fmt.Println(runtime.GOMAXPROCS(0))
    fmt.Println(runtime.NumGoroutine())
}
</pre>
<pre>
C&gt;go run sample1400.go
8
1
2
</pre>
<p> NumCPU の返り値は 8 になりました。また、goroutine の個数が 2 になっていますが、<a href="http://jxck.hatenablog.com/entry/20130414/1365960707">Go の並行処理 - Block Rockin' Codes</a> によると、 <CITE>『go 文で起動した goroutine や main() 以外にも、 Scavenger (GC) などランタイム環境でも goroutine が使われている』</CITE> とのことです。
</p>
<p> なお、GOMAXPROCS は引数に大きな値を与えてもエラーにはなりません。NumCPU の返り値より大きな値を与えても効果があるのか、あとで実際に試してみましょう。
</p>
<h4>●並列処理の効果</h4>
<p> それでは実際に並列処理の効果を試してみましょう。<a href="abcgo12.html">並行プログラミング</a> で作成したフィボナッチ関数を求めるプログラムで、CPU のコア数を 8 に増やします。
</p>

<pre class="list">
リスト : タイムアウト処理 (sample1401.go)

package main

import (
    "fmt"
    "time"
    "runtime"
)

// フィボナッチ関数
func fibo(n int) int {
    if n &lt; 2 {
        return 1
    } else {
        return fibo(n - 2) + fibo(n - 1)
    }
}

func main(){
    runtime.GOMAXPROCS(runtime.NumCPU())    // コア数の指定
    ch := make(chan int, 5)
    for _, n := range []int{41, 40, 38, 36, 34} {
        go func(x int){
            ch &lt;- fibo(x)
        }(n)
    }
    for i := 5; i &gt; 0; {
        select {
        case n := &lt;- ch:
            fmt.Println(n)
            i--
        case &lt;- time.After(time.Second):
            fmt.Println("Timeout")
            i = 0
        }
    }
}
</pre>
<pre>
C&gt;go run sample1401.go
9227465
24157817
63245986
165580141
267914296
</pre>
<p> コア数を 8 に増やすことで、すべての値をタイムアウトせずに求めることができました。
</p>

<p> 次は、フィボナッチ関数を使ってコア数を増やすと効率がどのくらい上がるか試してみましょう。
</p>
<pre class="list">
リスト : 並列処理の効率

package main

import (
    "fmt"
    "time"
    "runtime"
)

// フィボナッチ関数
func fibo(n int) int {
    if n &lt; 2 {
        return 1
    } else {
        return fibo(n - 1) + fibo(n - 2)
    }
}

func main() {
    ch := make(chan int, 10)
    for n := 1; n &lt;= 10; n++ {
        fmt.Println("-----", n, "-----")
        runtime.GOMAXPROCS(n)
        s := time.Now()
        for i := 0; i &lt; 8; i++ {
            go func(){
                ch &lt;- fibo(40)
            }()
        }
        for i := 8; i &gt; 0; i-- {
            fmt.Print(&lt;- ch, " ")
        }
        e := time.Now().Sub(s)
        fmt.Println(e)
    }
}
</pre>
<p> fibo(40) を 8 回計算しますが、1 回の計算を goroutine に割り当て、8 回の計算を並列に処理します。for ループの変数 n は使用するコア数を表します。n = 1 とすると逐次実行と変わりませんが、n の値を増やすと並列処理される goroutine の数も増えるので、8 個の goroutine がすべて終了するまでの所要時間 (Turn Around Time) は短縮されるはずです。
</p>
<p> 一般に、ある計算を p 台の演算装置で並列処理した場合の所要時間を T(p) とすると、並列処理の効果は次の式で表すことができます。
</p>
<pre class="item">
S(p) = T(1) / T(p)
E(p) = S(p) / p
</pre>
<p> S(p) を高速化率 (Speed up ratio) とか加速率と呼び、E(p) を並列化効率と呼びます。理想的には S(p) = p, E(p) = 1 となり、これを ideal speed up といいます。実際には S(p) &lt; p, E(p) &lt; 1 になり、p を増やしていくと E(p) の値が下がっていく場合が多いようです。
</p>

<p> それでは実行結果を示します。
</p>
<pre>
表 : 実行結果 (時間 ; 秒)

 p : 時間 : S(p) : E(p)
---+------+------+------
 1 : 8.04 : 1.00 : 1.00
 2 : 4.18 : 1.92 : 0.96
 3 : 2.88 : 2.79 : 0.93
 4 : 2.17 : 3.71 : 0.93
 5 : 2.02 : 3.78 : 0.76
 6 : 1.87 : 4.30 : 0.72
 7 : 1.75 : 4.59 : 0.65
 8 : 1.62 : 4.96 : 0.62
 9 : 1.64 : 4.90 : 0.54
10 : 1.64 : 4.90 : 0.49

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> E(p) は物理コア数の 4 までは 1 に近い値になりますが、それを超えると E(p) の値は下がっていきます。S(p) の値は p = 8 の 4.96 が最大で、それ以降は p の値を増やしても効果はほとんどありません。さすがに、実行速度は 1 / 8 にならなかったのですが、それでも約 5 倍の高速化ができるのですから、並列処理の効果はとても大きいことがわかります。
</p>
<h4>●数値積分</h4>
<p> 次は数値積分で円周率πを求めてみましょう。区間 [a, b] の定積分∫f(x)dx を数値的に求めるには、区間を細分して小区間の面積を求めて足し上げます。小区間の面積を求める一番簡単な方法は長方形で近似することです。この場合、3 つの方法が考えられます。
</p>
<OL>
  <LI> (b - a) * f(a)
  <LI> (b - a) * f(b)
  <LI> (b - a) * f((a + b) / 2)
</OL>
<p> 1 は左端の値 f(a) を、2 は右端の値 f(b) を、3 は中間点の値 f((a + b) / 2) を使って長方形の面積を計算します。この中で 3 番目の方法が一番精度が高く、これを「中点則」といいます。このほかに、台形で近似する「台形則」や、2 次近似で精度を上げる「シンプソン則」という方法があります。
</p>
<p> それでは実際に、1 の方法と中点則でπの値を求めてみましょう。πは次の式で求めることができます。
</p>
<pre class="item">
      1
π = ∫(4 / (1 + x * x)) dx
      0
</pre>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 数値積分で円周率を求める (sample1402.go)

package main

import (
    "fmt"
    "math"
)

// 左端
func leftPoint(n int) float64 {
    w := 1.0 / float64(n)
    s := 0.0
    for i := 0; i &lt; n; i++ {
        x := float64(i) * w
        s += 4.0 / (1.0 + x * x)
    }
    return s * w
}

// 中点則
func midPoint(n int) float64 {
    w := 1.0 / float64(n)
    s := 0.0
    for i := 1; i &lt;= n; i++ {
        x := (float64(i) - 0.5) * w
        s += 4.0 / (1.0 + x * x)
    }
    return s * w
}

func main() {
    n := 10
    for i := 1; i &lt;= 9; i++ {
        fmt.Println("-----", n, "-----")
        pi := midPoint(n)
        fmt.Println(pi, math.Pi - pi)
        pi = leftPoint(n)
        fmt.Println(pi, math.Pi - pi)
        n *= 10
    }
}
</pre>
<p> 関数 leftPoint は 1 の方法で、関数 midPoint が中点則でπの値を求めます。引数 n が分割数です。最初に小区間の幅を求めて変数 w にセットします。面積は変数 s にセットします。次の for ループで区間 [0, 1] を n 個に分割して面積を求めます。
</p>
<p> 最初に x 座標を計算します。leftPoint は float64(i) * w でいいのですが、midPoint は中間点を求めるため、変数 i を 1 から始めて、x 座標を次の式で求めます。
</p>
<pre class="item">
x := (float64(i) - 0.5) * w
</pre>
<p> たとえば、変数 i が 1 の場合は 0.5 になるので、x は区間 [0 * w, 1 * w] の中間点になります。あとは、4 / (1 + x * x) を計算して s に加算します。最後に s に w を掛け算して全体の面積を求めます。
</p>
<p> 実行結果を示します。
</p>
<pre>
C&gt;go run sample1402.go
----- 10 -----
3.1424259850010987 -0.0008333314113055934
3.2399259889071588 -0.09833333531736566
----- 100 -----
3.1416009869231254 -8.333333332277704e-06
3.151575986923129 -0.009983333333335676
----- 1000 -----
3.1415927369231227 -8.333332957022321e-08
3.1425924869231245 -0.0009998333333314235
----- 10000 -----
3.141592654423134 -8.3334095180021e-10
3.14169265192314 -9.999833334672914e-05
----- 100000 -----
3.1415926535981615 -8.36841707041458e-12
3.1416026535731527 -9.99998335959873e-06
----- 1000000 -----
3.1415926535897643 2.886579864025407e-14
3.141593653589793 -9.999999996956888e-07
----- 10000000 -----
3.141592653589731 6.217248937900877e-14
3.141592753589987 -1.0000019390332682e-07
----- 100000000 -----
3.1415926535904264 -6.332712132461893e-13
3.141592663590225 -1.0000432038026474e-08
----- 1000000000 -----
3.1415926535899708 -1.7763568394002505e-13
3.1415926545896586 -9.998655237097864e-10
</pre>
<p> 中点則の場合、分割数を 10 倍すると誤差はほぼ 1/100 になります。それに対し、1 の方法は分割数を 10 倍しても誤差は 1 / 10 にしかなりません。このように、1 の方法は分割数を増やさないと精度の高い値を求めることができません。
</p>
<p> ただし、浮動小数点数 (float64) の計算には誤差があるので、精度には限界があります。中点則の場合、分割数を 1000000 より増やしても精度は高くなりません。1 の方法は分割数を増やすと誤差は少なくなりますが、実行時間がかかるようになります。そこで、並列処理を使って実行時間を短縮してみましょう。
</p>

<h4>●数値積分の並列化</h4>
<p> 並列化の考え方は簡単です。たとえば、4 つの goroutine で並列化するのであれば、区間を [0, 0.25], [0.25, 0.5], [0.5, 0.75], [0.75, 1] のように四等分して、それぞれの区間を 1 つの goroutine で並列に計算します。あとは、その値の足し算すればいいわけです。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 数値積分で円周率を求める (並列化)

package main

import (
    "fmt"
    "time"
    "runtime"
)

const (
    N = 1000000000
    W = 1.0 / float64(N)
)

func leftPoint(n, m int) float64 {
    s := 0.0
    for i := n; i &lt; m; i++ {
        x := float64(i) * W
        s += 4.0 / (1.0 + x * x)
    }
    return s * W
}

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for i := 1; i &lt;= 8; i *= 2 {
        fmt.Println("-----", i, "-----")
        ch := make(chan float64, i)
        s := time.Now()
        k := N / i
        for j := 0; j &lt; i; j++ {
            go func(n, m int) {
                ch &lt;- leftPoint(n, m)
            }(j * k, (j + 1) * k)
        }
        sum := 0.0
        for j := i; j &gt; 0; j-- {
            sum += &lt;- ch
        }
        e := time.Now().Sub(s)
        fmt.Println(sum)
        fmt.Println(e)
    }
}
</pre>
<p> 定数 N が分割数で、W が小区間の幅を表します。関数 leftPoint の引数 n, m は区間を表します。main では、並列で実行する goroutine を 1, 2, 4, 8 と増やして実行時間を計測します。for ループの変数 i が起動する goroutine の個数になります。あとは、go で匿名関数を実行して、その中で leftPoint を呼び出します。最後に、チャネルから結果を取り出して変数 sum に加算します。
</p>
<p> それでは実行結果を示します。
</p>
<pre>
表 : 実行結果 (時間 : 秒)

    N :  時間  : 効率
   ---+--------+------
    1 : 14.294 : 1.00
    2 :  7.340 : 1.95
    4 :  3.766 : 3.80
    8 :  2.005 : 7.13

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 8 分割で約 7 倍の高速化に成功しました。数値積分は並列処理との相性がいいようで、その効果はとても高いですね。この結果には M.Hiroi も驚きました。
</p>

<h4>●モンテカルロ法</h4>
<p> 乱数を使って数学や物理などの問題を解くアルゴリズムを「モンテカルロ法 (Monte Carlo methods) 」といいます。簡単な例題として、円周率πをモンテカルロ法で求めてみましょう。
</p>

<p> 正方形の領域 (0 &lt;= x &lt; 1, 0 &lt;= y &lt; 1) に乱数で点を打ちます。乱数であれば点は領域内に一様に分布するので、x<SUP>2</SUP> + y<SUP>2</SUP> &lt; 1 の円内に入る確率は π / 4 になります。つまり、(円内の点の個数 / 点の総数) の値は 0.7853... になるはずです。たくさん点を打つほど値は π / 4 に近づくはずですが、コンピュータの乱数は疑似乱数なので規則性が生じてしまい、値の精度にはどうしても限界があります。
</p>
<p> また、たくさん点を打つと実行時間がかかるようになりますが、並列に処理することで実行時間を短縮することができます。たとえば、100 万個の点を打ってπを求める処理を並列に 8 回行って平均値を計算すれば、800 万個の点を打ってπを求めたことと同じになります。
</p>

<h4>●乱数列の生成</h4>
<p> このとき、goroutine ごとに異なる乱数列を発生するジェネレータを割り当てることがポイントです。Go 言語の場合、rand パッケージに新しい乱数ジェネレータを生成する関数が用意されています。
</p>
<pre class="item">
func NewSource(s int64) Source
func New(s Source) *Rand
</pre>
<p> 関数 NewSource は整数値 seed から乱数の元になるデータ Source を生成します。Source から乱数ジェネレータを生成する関数が New です。New は乱数ジェネレータ Rand へのポインタを返します。
</p>
<p> 一般に、乱数の元になるデータを「シード (seed : 種) 」といいます。乱数ジェネレータを生成する seed の値を変えることで、異なる乱数列を発生させることができます。あとは、Rand に定義されているメソッドを使って乱数列を生成すればいいわけです。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 乱数ジェネレータの生成 (sample1403.go)

package main

import (
    "fmt"
    "math/rand"
)

func main() {
    r1 := rand.New(rand.NewSource(1))
    r2 := rand.New(rand.NewSource(2))
    r3 := rand.New(rand.NewSource(3))
    for i := 0; i &lt 20; i++ {
        fmt.Print(r1.Intn(100), " ")
    }
    fmt.Println("")
    for i := 0; i &lt; 20; i++ {
        fmt.Print(r2.Intn(100), " ")
    }
    fmt.Println("")
    for i := 0; i &lt; 20; i++ {
        fmt.Print(r3.Intn(100), " ")
    }
    fmt.Println("")
}
</pre>

<pre>
C&gt;go run sample1403.go
81 87 47 59 81 18 25 40 56 0 94 11 62 89 28 74 11 45 37 6
86 86 92 40 4 54 30 64 11 76 10 59 45 32 76 27 35 64 49 57
8 77 96 50 77 79 16 17 44 47 66 10 81 27 6 73 74 78 74 82
</pre>
<p> メソッド Intn(n) は 0 から n 未満の乱数 (int) を生成します。結果を見ればおわかりのように、NewSource に与える整数値を変えることで、異なる乱数列が生成されていることがわかります。
</p>
<p> ちなみに、乱数を生成する関数 Int や Float64 などは、大域変数 globalRand に格納されている乱数ジェネレータを使っていて、これは NewSource(1) で初期化されています。Go 言語を起動して関数 Intn(100) で乱数を生成すると、乱数ジェネレータ r1 と同じ乱数列になります。異なる乱数列を生成したい場合は関数 Seed(s int64) で異なる値のシードを設定します。
</p>
<pre class="list">
リスト : シードの変更 (sample1404.go)

package main

import (
    "fmt"
    "math/rand"
    "time"
)

func main() {
    for i := 0; i &lt; 20; i++ {
        fmt.Print(rand.Intn(100), " ")
    }
    fmt.Println("")
    rand.Seed(time.Now().UnixNano())
    for i := 0; i &lt; 20; i++ {
        fmt.Print(rand.Intn(100), " ")
    }
}
</pre>
<pre>
C&gt;go run sample1404.go
81 87 47 59 81 18 25 40 56 0 94 11 62 89 28 74 11 45 37 6
35 4 28 56 20 86 74 79 63 8 47 78 46 25 31 10 35 16 34 98

C&gt;go run sample1404.go
81 87 47 59 81 18 25 40 56 0 94 11 62 89 28 74 11 45 37 6
58 11 88 92 26 39 76 80 68 23 46 70 58 84 92 86 32 22 8 86

C&gt;go run sample1404.go
81 87 47 59 81 18 25 40 56 0 94 11 62 89 28 74 11 45 37 6
28 84 73 81 47 0 13 23 1 89 28 21 64 29 64 16 11 5 26 47
</pre>
<p> time.Now() は現在時刻を求める関数で、UnixNano は January 1, 1970 UTC からの経過時間をナノ秒で返す関数です。Seed でシードの値を変えることで、大域的な乱数ジェネレータでも異なる乱数列を生成することができます。
</p>
<p> なお、globalRand は大域変数 (共有メモリ) なので、複数の goroutine からアクセスすることができます。このため、globalRand のアクセスには排他制御が行われています。並列処理で globalRand から多量の乱数を取得すると、排他制御に時間がかかるため、実行時間が遅くなる場合があります。ご注意くださいませ。
</p>

<h4>●モンテカルロ法の並列化</h4>
<p> モンテカルロ法の並列処理は次のようになります。
</p>
<pre class="list">
リスト : モンテカルロ法（πを求める）

package main

import (
    "fmt"
    "math/rand"
    "time"
    "runtime"
)

// モンテカルロ法
func montePi(n, s int) float64 {
    c := 0
    r := rand.New(rand.NewSource(int64(s)))
    for i := n; i &gt; 0; i-- {
        x := r.Float64()
        y := r.Float64()
        if x * x + y * y &lt; 1.0 {
            c++
        }
    }
    return (4.0 * float64(c)) / float64(n)
}

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for i := 1; i &lt;= 8; i *= 2 {
        fmt.Println("-----", i, "-----")
        n := 100000000 / i
        ch := make(chan float64, i)
        s := time.Now()
        for j := 0; j &gt; i; j++ {
            go func(x int) {
                ch &lt;- montePi(n, x)
            }(j + 1)
        }
        pi := 0.0
        for j := i; j &gt; 0; j-- {
            pi += &lt;- ch
        }
        fmt.Println(pi / float64(i))
        e := time.Now().Sub(s)
        fmt.Println(e)
    }
}
</pre>
<p> 試行回数を 100,000,000 とし、それを 1, 2, 4, 8 分割して実行時間を計測します。goroutine の返り値をチャネル ch で受け取り、その平均値を計算します。GOMAXPROCS は NumCPU の値 (8) にしました。
</p>
<p> モンテカルロ法の処理は関数 montePi で行います。引数 n が試行回数、s が乱数シードです。最初に rand.New(rand.NewSource(int64(s))) で乱数ジェネレータを生成します。次の for ループで n 個の点を打ちます。r.Float64() は [0, 1) の範囲の乱数 (float64) を生成します。点 (x, y) が円内に入っていれば c の値を +1 します。最後にπを計算して返します。
</p>
<p> それでは実行結果を示します。
</p>

<pre>
  表 : 実行結果 (時間 : 秒)

 N :     値     : 時間  : 効果
---+------------+-------+------
 1 : 3.14151812 : 5.967 : 1.00
 2 : 3.14163576 : 3.109 : 1.92
 4 : 3.1414764  : 1.710 : 3.49
 8 : 3.14167352 : 1.027 : 5.81

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 8 分割で 5.8 倍の高速化に成功しました。モンテカルロ法の場合も、並列処理の効果はとても高いことがわかります。
</p>

<h4>●クイックソートの並列化</h4>
<p> 次はクイックソートの並列化に挑戦してみましょう。クイックソートは枢軸を基準に区間を二分割し、分割した区間に再度クイックソートを適用します。分割した区間をソートするとき、他の区間には影響を及ぼさないので、二分割した区間を並列にソートすることが可能です。
</p>

<p> この場合、多数の goroutine が生成されて、ソート完了を通知するため頻繁に通信を行うことになります。このように通信の頻度が多くなるものを「細粒度並列性（fine-graind parallelism）」といいます。これに対し、数値積分やモンテカルロ法の関数 montePi の実行では通信を 1 回しか行いません。通信の頻度が少ないものを「粗粒度並列性（coarse-grained parallelism）」といいます。粒度が細かくなると通信の頻度が多くなり、通信処理のオーバーヘッドにより効率は低下します。
</p>

<p> そこで、区間の長さがある値以下になったら、逐次処理のクイックソートに切り替えることにします。なお、この処理を入れずにすべて並列処理で行うと、Go 言語ではランタイムエラーが発生します。ご注意くださいませ。
</p>

<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : クイックソートの並列化

func quickSortParaSub(data SortI, low, high int) {
    if high - low &lt; 1024 {
        quickSortSub(data, low, high)
        return
    }
    p := low + (high - low) / 2
    i, j := low, high
    for {
        for data.Less(i, p) { i++ }
        for data.Less(p, j) { j-- }
        if i &gt;= j { break }
        data.Swap(i, j)
        switch {
        case p == i: p = j
        case p == j: p = i
        }
        i++
        j--
    }
    ch := make(chan int, 2)
    go func(){
        quickSortParaSub(data, low, i - 1)
        ch &lt;- 0
    }()
    go func(){
        quickSortParaSub(data, j + 1, high)
        ch &lt;- 0
    }()
    &lt;- ch
    &lt;- ch
}

func quickSortPara(data SortI) {
    quickSortParaSub(data, 0, data.Len() - 1)
}
</pre>
<p> quickSortPara は関数 quickSortParaSub を呼び出します。基本的な処理は拙作のページ <a href="abcgo09.html">インターフェース</a> で作成した quickSortSub と同じです。最初に区間の長さをチェックして、1024 未満になったら逐次処理のクイックソート quickSortSub に切り替えます。この値は実行環境によって最適値が変わると思います。興味のある方はご自分の環境でいろいろ試してみてください。
</p>
<p> 枢軸を基準に区間を二分割したあと、go で匿名関数を並列に実行し、この中で quickSortParaSub を呼び出します。ソートが終了したらチャネル ch に 0 を送信します。あとはチャネル ch からデータを 2 回受信するまで待つだけです。
</p>

<p> あとのプログラムは簡単なので説明は省略します。詳細は <a href="abcgo14.html#list1">プログラムリスト</a> をお読みください。
</p>

<p> 実行結果は次のようになりました。
</p>
<pre>
   表 ; 実行結果 (単位 : 秒)

 データ数 : 逐次  : 並列  : 効率
----------+-------+-------+------
1,000,000 : 0.361 : 0.109 : 3.31
2,000,000 : 0.740 : 0.215 : 3.44
4,000,000 : 1.520 : 0.419 : 3.63
8,000,000 : 3.153 : 0.849 : 3.71

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 逐次処理よりも約 3 倍強の高速化に成功しました。粒度が細かい分だけ数値積分やモンテカルロ法よりも効率は悪くなりますが、並列処理の効果は十分に出ていると思います。
</p>

<h4>●順列生成の並列化</h4>
<p> 次は順列の生成を並列処理で行ってみましょう。今回は 1 から n までの数字から n 個の数字を選ぶ順列を生成することにします。処理の分割は簡単で、先頭要素の数字で処理を分けるだけです。ようするに、1 から始まる順列、2 から始まる順列、...、n から始まる順列を別々の goroutine で並列に生成するわけです。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : 順列の並列化

package main

import (
    "fmt"
    "time"
    "runtime"
)

// n と等しい要素があるか
func member(n int, xs []int) bool {
    for _, x := range xs {
        if n == x { return true }
    }
    return false
}

// 順列の生成
func permutation(f func([]int), n, m, k int, xs []int) {
    if len(xs) == k {
        f(xs)
    } else {
        for i := n; i &lt;= m; i++ {
            if !member(i, xs) {
                permutation(f, n, m, k, append(xs, i))
            }
        }
    }
}

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for i := 10; i &lt;= 12; i++ {
        fmt.Println("-----", i, "-----")
        s := time.Now()
        // 逐次処理
        func(){
            c := 0
            a := make([]int, 0, i)
            permutation(func(_ []int){ c++ }, 1, i, i, a)
            fmt.Println(c)
        }()
        e := time.Now().Sub(s)
        fmt.Println(e)
        s = time.Now()
        ch := make(chan int, i)
        // 並列処理
        for j := 0; j &lt; i; j++ {
            go func(i, j int){
                c := 0
                a := make([]int, 0, i)
                a = append(a, j + 1)
                permutation(func(_ []int){ c++ }, 1, i, i, a)
                ch &lt;- c
            }(i, j)
        }
        sum := 0
        for j := 0; j &lt; i; j++ {
            sum += &lt;- ch
        }
        fmt.Println(sum)
        e = time.Now().Sub(s)
        fmt.Println(e)
    }
}
</pre>
<p> 関数 permutation は n から m までの数字から k 個の数字を選ぶ順列を生成します。引数 xs が順列を格納する累積変数で、permutation を呼び出すとき、xs の先頭要素に数字を格納して渡せば、その数字から始まる順列を生成することができます。permutation に渡す匿名関数は、生成した順列をカウントするだけです。あとは、make でスライスを生成するとき、容量を指定することに注意してください。スライスの容量を動的に増加させると実行速度が遅くなってしまいます。
</p>
<p> 実行結果は次のようになりました。
</p>
<pre>
      表 : 実行結果

 N :  逐次   : 並列   : 効率
---+------------------+------
10 :   0.944 :  0.235 : 4.02
11 :  11.518 :  2.374 : 4.85
12 : 154.397 : 34.520 : 4.47

実行環境 : Windows 7, Core i7-2670QM 2.20GHz
</pre>
<p> 4 倍以上の高速化に成功しました。並列化の効果は十分に出ていると思いますが、起動する goroutine の個数が NumCPU の個数よりも多くなるので、数値積分やモンテカルロ法よりも効率が悪くなるのは仕方がないところです。順列の生成はパズルの解法でよく使うので、並列処理はパズルの解法にも有効だと思われます。興味のある方はいろいろ試してみてください。
</p>

<h4 id="cite">●参考文献, URL</h4>
<ol>
  <li>Ravi Sethi (著), 神林靖 (訳), 『プログラミング言語の概念と構造』, アジソンウェスレイ, 1995
  <li>奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991
  <li><a href="http://server-500.cc.kyushu-u.ac.jp/">Mutsumi Aoyagi Laboratory</a>, <a href="http://server-500.cc.kyushu-u.ac.jp/main/heiretsu/index.html">並列アルゴリズム (講義ノート)</a>
  <li><a href="http://www1.s2.starcat.ne.jp/fussy/">Fussy's Homepage</a>, <a href="http://fussy.web.fc2.com/algo/algo10-9.htm">数値積分法 -1-</a>
  <li><a href="http://ja.wikipedia.org/wiki/%E4%B8%A6%E5%88%97%E8%A8%88%E7%AE%97">並列計算 - Wikipedia</a>
</ol>

<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
リスト : クイックソートの並列化

package main

import (
    "fmt"
    "math/rand"
    "time"
    "runtime"
)

type SortI interface{
    Len() int
    Less(int, int) bool
    Swap(int, int)
}

func quickSortSub(data SortI, low, high int) {
    p := low + (high - low) / 2
    i, j := low, high
    for {
        for data.Less(i, p) { i++ }
        for data.Less(p, j) { j-- }
        if i &gt;= j { break }
        data.Swap(i, j)
        switch {
        case p == i: p = j
        case p == j: p = i
        }
        i++
        j--
    }
    if low &lt; i - 1  { quickSortSub(data, low,   i - 1) }
    if high &gt; j + 1 { quickSortSub(data, j + 1, high) }
}

func quickSort(data SortI) {
    quickSortSub(data, 0, data.Len() - 1)
}

func quickSortParaSub(data SortI, low, high int) {
    if high - low &lt; 1024 {
        quickSortSub(data, low, high)
        return
    }
    p := low + (high - low) / 2
    i, j := low, high
    for {
        for data.Less(i, p) { i++ }
        for data.Less(p, j) { j-- }
        if i &gt;= j { break }
        data.Swap(i, j)
        switch {
        case p == i: p = j
        case p == j: p = i
        }
        i++
        j--
    }
    ch := make(chan int, 2)
    go func(){
        quickSortParaSub(data, low, i - 1)
        ch &lt;- 0
    }()
    go func(){
        quickSortParaSub(data, j + 1, high)
        ch &lt;- 0
    }()
    &lt;- ch
    &lt;- ch
}

func quickSortPara(data SortI) {
    quickSortParaSub(data, 0, data.Len() - 1)
}

type IntArray []int

func (ary IntArray) Len() int {
    return len(ary)
}

func (ary IntArray) Less(i, j int) bool {
    return ary[i] &lt; ary[j]
}

func (ary IntArray) Swap(i, j int) {
    ary[i], ary[j] = ary[j], ary[i]
}

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for i := 1; i &lt;= 8; i *= 2 {
        a := make(IntArray, i * 1000000)
        b := make(IntArray, i * 1000000)
        for j := 0; j &lt; i * 1000000; j++ {
            x := rand.Int()
            a[j] = x
            b[j] = x
        }
        fmt.Println("-----", i, "-----")
        s := time.Now()
        quickSort(a)
        e := time.Now().Sub(s)
        fmt.Println(e)
        s = time.Now()
        quickSortPara(b)
        e = time.Now().Sub(s)
        fmt.Println(e)
    }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo13.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo15.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>