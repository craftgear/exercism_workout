<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Go 言語プログラミング入門</title>
  <meta name="description" content="Go,Golang,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881806</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Go Language Programming</h1>
<h2>お気楽 Go 言語プログラミング入門</h2>
<div class="small">
[ <a href="abcgo25.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo27.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>電卓プログラムの改良 (連結リスト編その２)</h3>
<p> 電卓プログラムの使用例として簡単なライブラリを作ってみました。
</p>

<h4>数値演算</h4>
<ul>
  <li>isEven(n), isOdd(n)<br>
n が偶数ならば isEven は 1 を isOdd は 0 を、奇数ならば isEven は 0 を isOdd は 1 を返す。
  <li>isPositive(n)<br>
n が正の値ならば 1 を返す。
  <li>isNegative(n)<br>
n が負の値ならば 1 を返す。
  <li>isZero(n)<br>
n が 0 ならば 1 を返す。
  <li>abs(n)<br>n の絶対値を返す。
  <li>sign(n)<br>n の符号 (-1, 0, 1) を返す。
  <li>max(a, b), min(a, b)<br>
max は引数 a, b の大きいほうを、min は小さいほうを返す。
  <li>gcd(a, b)<br>
整数値 a, b の最大公約数を求める。
  <li>lcm(a, b)<br>
整数値 a, b の最小公倍数を求める。
  <li>combNum(n, r)<br>
組み合わせの数 <SUB>n</SUB>Ｃ<SUB>r</SUB> を求める。
  <li>fact(n)<br>
n の階乗を求める。
  <li>expt(a, b)<br>
a の b 乗 を求める。(ただし、b は整数)
  <li>fibo(n)<br>
フィボナッチ数を求める。
  <li>sieve(n)<br>
整数 n 以下の素数を求める。
  <li>factorization(n)<br>
整数 n を素因数分解する。返り値はコンスセル (p . q) を格納したリストで、コンスセルは p<SUP>q</SUP> を表す。
</ul>
<pre>
Calc&gt; isEven(2);
1
Calc&gt; isEven(3);
0
Calc&gt; isOdd(4);
0
Calc&gt; isOdd(5);
1
Calc&gt; isPositive(10);
1
Calc&gt; isPositive(-10);
0
Calc&gt; isNegative(10);
0
Calc&gt; isNegative(-10);
1
Calc&gt; isZero(0);
1
Calc&gt; isZero(-1);
0
Calc&gt; abs(-10);
10
Calc&gt; abs(10);
10
Calc&gt; max(1, 10);
10
Calc&gt; min(1, 10);
1
Calc&gt; gcd(24, 32);
8
Calc&gt; lcm(24, 32);
96
Calc&gt; combNum(10, 5);
252
Calc&gt; combNum(30,15);
155117520
Calc&gt; fact(10);
3628800
Calc&gt; fact(20);
2432902008176640000
Calc&gt; expt(2,32);
4294967296
Calc&gt; expt(2,62);
4611686018427387904
Calc&gt; fibo(0);
1
Calc&gt; fibo(1);
1
Calc&gt; fibo(2);
2
Calc&gt; fibo(10);
89
Calc&gt; fibo(50);
20365011074
Calc&gt; sieve(100);
(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)
Calc&gt; factorization(1234567890);
((2 . 1) (3 . 2) (5 . 1) (3607 . 1) (3803 . 1))
Calc&gt; factorization(1111111111);
((11 . 1) (41 . 1) (271 . 1) (9091 . 1))
</pre>
<h4>述語</h4>
<ul>
  <li>pair(xs) [組み込み関数]<br>
xs がリストならば真を返す。
  <li>null(xs) [組み込み関数]<br>
xs が空リストならば真を返す。
  <li>isList(xs)<br>
xs がリストか空リストならば真を返す。
  <li>eql(x, y) [組み込み関数]<br>
x と y が等しい場合は真を返す。等値の定義は、x と y が同じデータ型で値が等しいこと。リストの場合は、同一のリストであれば真を返す。ベクタと関数値の場合は無条件に偽を返す。
  <li>equal(xs, ys)<br>
xs と ys が等しい場合は真を返す。等値の定義は、xs と ys が同じデータ型で値が等しいこと。リストとベクタの場合は要素に対して equal を再帰的に適用する。
  <li>any(pred, xs)<br>
リスト xs の要素がひとつでも述語 pred を満たせば真を返す。
  <li>every(pred, xs)<br>
リスト xs のすべての要素が述語 pred を満たせば真を返す。
</ul>
<pre>
Calc&gt; pair(cons(1, 2));
1
Calc&gt; pair(nil);
0
Calc&gt; null(nil);
1
Calc&gt; null(cons(1, 2));
0
Calc&gt; any(isEven, list(1,3,5,7,9));
0
Calc&gt; any(isEven, list(1,3,4,5,7,9));
1
Calc&gt; any(isOdd, [2,4,6,8,10]);
0
Calc&gt; any(isOdd, [2,4,5,6,8,10]);
1
Calc&gt; every(isEven, list(2,4,6,8));
1
Calc&gt; every(isEven, list(2,4,5,6,8));
0
Calc&gt; every(isEven, [2,4,6,8,10]);
1
Calc&gt; every(isEven, [2,4,6,8,10,11]);
0
Calc&gt; eql(1, 1);
1
Calc&gt; eql(1, 1.0);
0
Calc&gt; eql("abc", "abc");
1
Calc&gt; eql("abc", "def");
0
Calc&gt; eql("abc", 2);
0
Calc&gt; eql(nil, nil);
1
Calc&gt; equal(1, 1);
1
Calc&gt; equal(1, 1.0);
0
Calc&gt; equal("abc", "abc");
1
Calc&gt; equal("abc", "def");
0
Calc&gt; equal("abc", 2);
0
Calc&gt; equal(list(1,2,3), list(1,2,3));
1
Calc&gt; equal(list(1,2,3), list(1,2,3.0));
0
Calc&gt; equal([[1,2],[3,4]], [[1,2],[3,4]]);
1
Calc&gt; equal([[1,2],[3,4]], [[1,2],[3.0,4]]);
0
</pre>
<h4>リストのアクセス</h4>
<ul>
  <li>car(xs) [組み込み関数]<br>
リスト xs の先頭要素を返す。xs が空リストの場合は空リストを返す。
  <li>cdr(xs) [組み込み関数]<br>
リスト xs の先頭要素を取り除く。xs が空リストの場合は空リストを返す。
  <li>caar(xs), cadr(xs), cdar(xs), cddr(xs)<br>
cXYr(xs) は cXr(cYr(xs)) と同じ。
  <li>first(xs), second(xs), third(xs), fourth(xs), fifth(xs)<br>
first はリスト xs の先頭の要素、second は 2 番目の要素、 third は 3 番目の要素、fourth は 4 番目の要素、fifth は 5 番目の要素を取り出す。
  <li>nth(xs, n)<br>
リスト xs の n 番目の要素を取り出す。ただし、要素の順番は 0 から数える。
</ul>
<pre>
Calc&gt; a = list(1,2,3,4,5);
(1 2 3 4 5)
Calc&gt; first(a);
1
Calc&gt; second(a);
2
Calc&gt; third(a);
3
Calc&gt; fourth(a);
4
Calc&gt; fifth(a);
5
Calc&gt; nth(a, 0);
1
Calc&gt; nth(a, 4);
5
</pre>
<h4>リストの生成</h4>
<ul>
  <li>cons(x, y) [組み込み関数]<br>
CAR 部に x を、CDR 部に y を格納したコンスセルを返す。
  <li>makelist(n, x)<br>
要素が x で長さが n のリストを生成する。
  <li>iota(n, m)<br>
整数 n から m までの数列を格納したリストを生成する。
  <li>tabulate(f, n, m)<br>
整数 n から m までの数列の要素に関数 f を適用した結果をリストに格納して返す。
</ul>
<pre>
Calc&gt; cons(1, 2);
(1 . 2)
Calc&gt; cons(2, cons(1, nil));
(2 1)
Calc&gt; makelist(10, 0);
(0 0 0 0 0 0 0 0 0 0)
Calc&gt; iota(1, 10);
(1 2 3 4 5 6 7 8 9 10)
Calc&gt; tabulate(fn(x) x * x end, 1, 10);
(1 4 9 16 25 36 49 64 81 100)
</pre>
<h4>簡単なリスト操作</h4>
<ul>
  <li>append(xs, ys)<br>
リスト xs と ys を連結する。
  <li>length(xs)<br>
リスト xs の長さを求める。
  <li>reverse(xs)<br>
リスト xs を反転する。
  <li>revAppend(xs, ys)<br>
リスト xs を反転してリスト ys と連結する。
  <li>take(xs, n)<br>
リスト xs の先頭から n 個の要素を取り出す。
  <li>drop(xs, n)<br>
リスト xs の先頭から n 個の要素を取り除く。
  <li>last(xs, n)<br>
リスト xs の末尾から n 個の要素を取り出す。
  <li>butlast(xs, n)<br>
リスト xs の末尾から n 個の要素を取り除く。
  <li>partition(pred, xs)<br>
リスト xs を述語 pred が真を返す要素とそうでないものの 2 つに分ける。
</ul>
<pre>
Calc&gt; a = iota(1, 4);
(1 2 3 4)
Calc&gt; b = iota(5, 8);
(5 6 7 8)
Calc&gt; append(a, b);
(1 2 3 4 5 6 7 8)
Calc&gt; c = append(a, b);
(1 2 3 4 5 6 7 8)
Calc&gt; revAppend(a, b);
(4 3 2 1 5 6 7 8)
Calc&gt; length(c);
8
Calc&gt; reverse(c);
(8 7 6 5 4 3 2 1)
Calc&gt; c;
(1 2 3 4 5 6 7 8)
Calc&gt; c = iota(1, 9);
(1 2 3 4 5 6 7 8 9)
Calc&gt; drop(c, 3);
(4 5 6 7 8 9)
Calc&gt; take(c, 3);
(1 2 3)
Calc&gt; last(c, 3);
(7 8 9)
Calc&gt; butlast(c, 3);
(1 2 3 4 5 6)
Calc&gt; partition(isEven, c);
((2 4 6 8) 1 3 5 7 9)
Calc&gt; partition(isOdd, c);
((1 3 5 7 9) 2 4 6 8)
</pre>
<h4>簡単なリストとベクタの操作</h4>
<ul>
  <li>sum(xs)<br>
リストまたはベクタ xs の合計値を求める。
  <li>maximum(xs)<br>
リストまたはベクタ xs の中から最大値を求める。
  <li>minimum(xs)<br>
リストまたはベクタ xs の中から最小を求める。
  <li>toVector(xs)<br>
リスト xs をベクタに変換する。リストの要素がリストの場合、そのリストもベクタに変換する。
  <li>toList(xs)<br>
ベクタ xs をリストに変換する。ベクタの要素がベクタの場合、そのベクタもリストに変換する。
  <li>foreach(f, xs)<br>
リストまたはベクタ xs の要素に関数 f を適用する。関数 f の副作用が目的で、返り値は捨てられる。
  <li>copy(xs)<br>
リストまたはベクタ xs のコピーを返す。コピーされるのはトップレベルのみで、いわゆる深いコピーは行われない。
</ul>
<pre>
Calc&gt; a = list(5,6,4,7,3,8,2,9,1);
(5 6 4 7 3 8 2 9 1)
Calc&gt; b = [5,6,4,7,3,8,2,9,1];
[5, 6, 4, 7, 3, 8, 2, 9, 1]
Calc&gt; sum(a);
45
Calc&gt; sum(b);
45
Calc&gt; maximum(a);
9
Calc&gt; maximum(b);
9
Calc&gt; minimum(b);
1
Calc&gt; minimum(a);
1
Calc&gt; a = toList([1,2,3,4,5]);
(1 2 3 4 5)
Calc&gt; toVector(a);
[1, 2, 3, 4, 5]
Calc&gt; b = toList([1,[2,[3],4],5]);
(1 (2 (3) 4) 5)
Calc&gt; toVector(b);
[1, [2, [3], 4], 5]
Calc&gt; foreach(print, a);
12345678
Calc&gt; foreach(print, [1,2,3,4,5,6,7,8]);
12345678
Calc&gt; copy(list(1,2,3,4,5));
(1 2 3 4 5)
Calc&gt; copy([1,2,3,4,5]);
[1, 2, 3, 4, 5]
</pre>

<h4>リストとベクタの探索</h4>
<ul>
  <li>member(x, xs), memberIf(pred, xs)<br>
リスト xs の中から x と等しい要素を探す。比較は述語 eql で行われる。見つけた場合、その要素以降のリストを返す。見つからない場合は nil を返す。memberIf は述語 pred が真を返す要素を探す。
  <li>find(x, xs), findIf(pred, xs) <br>
リストまたはベクタ xs の中から x と等しい要素を探す。見つけた場合は真 (1) を返す。findIf はリストまたはベクタ xs の中から述語 pred を満たす最初の要素を返す。見つからない場合は nil を返す。
  <li>position(x, xs), positionIf(pred, xs)<br>
リストまたはベクタ xs の中から x と等しい要素の位置を返す。見つからない場合は -1 を返す。positionIf は述語 pred を満たす最初の要素の位置を返す。
  <li>count(x, xs), countIf(pred, xs)<br>
リストまたはベクタ xs の中から x と等しい要素の個数を返す。countIf は述語 pred を満たす要素の個数を返す。
</ul>
<pre>
Calc&gt; a;
(1 2 3 4 5 6 7 8 9)
Calc&gt; b;
[1, 2, 3, 4, 5, 6, 7, 8, 9]
Calc&gt; findIf(isEven, a);
2
Calc&gt; findIf(isEven, b);
2
Calc&gt; findIf(fn(x) x == 10 end, a);
()
Calc&gt; positionIf(isEven, b);
1
Calc&gt; positionIf(isEven, a);
1
Calc&gt; positionIf(fn(x) x == 10 end, a);
-1
Calc&gt; countIf(isEven, a);
4
Calc&gt; countIf(isEven, b);
4
Calc&gt; member(5, a);
(5 6 7 8 9)
Calc&gt; member(10, a);
()
</pre>
<h4>マッピング、フィルター、畳み込み</h4>
<ul>
  <li>map(f, xs)<br>
リスト xs の要素に関数 f を適用した結果をリストに格納して返す。
  <li>filter(pred, xs)<br>
filter はリスト xs から述語 pred を満たす要素を取り出す。
  <li>remove(x, xs), removeIf(pred, xs)<br>
remove はリスト xs から x と等しい要素を削除する。removeIf は pred を満たす要素を削除する。
  <li>foldl(f, a, xs), foldr(f, a, xs)<br>
リスト xs の要素 x と累積変数 a に関数 f(x, a) を適用して畳み込みを行う。foldl は先頭から順番に要素を取り出し、foldr は逆に末尾から順番に要素を取り出す。
</ul>
<pre>
Calc&gt; a = iota(1, 8);
(1 2 3 4 5 6 7 8)
Calc&gt; map(fn(x) x * 2 end, a);
(2 4 6 8 10 12 14 16)
Calc&gt; filter(isEven, a);
(2 4 6 8)
Calc&gt; removeIf(isEven, a);
(1 3 5 7)
Calc&gt; foldl(fn(x, a) cons(x, a) end, nil, iota(1, 8));
(8 7 6 5 4 3 2 1)
Calc&gt; foldr(fn(x, a) cons(x, a) end, nil, iota(1, 8));
(1 2 3 4 5 6 7 8)
</pre>

<h4>連想リスト</h4>
<ul>
  <li>zip(xs, ys)<br>
xs の要素がキー、ys の要素が値となる連想リストを生成する。
  <li>assoc(key, xs)<br>
連想リスト xs から key を探す。返り値はコンスセル (key . value) で、見つからない場合は nil を返す。
  <li>assocIf(pred, xs)<br>
連想リスト xs から述語 pred を満たす key を探す。返り値はコンスセル (key . value) で、見つからない場合は nil を返す。
</ul>
<pre>
Calc&gt; a = zip(iota(1, 5), iota(11, 15));
((1 . 11) (2 . 12) (3 . 13) (4 . 14) (5 . 15))
Calc&gt; assoc(1, a);
(1 . 11)
Calc&gt; assoc(5, a);
(5 . 15)
Calc&gt; assoc(6, a);
()
Calc&gt; assocIf(fn(x) x % 3 == 0 end, a);
(3 . 13)
</pre>
<h4>集合</h4>
<p> リストを集合として扱う関数で、リストには重複要素がないものとする。
</p>
<ul>
  <li>removeDup(xs)<br>
リスト xs から重複した要素を削除する。等値の判定には述語 eql を用いる。
  <li>union(xs, ys)<br>
リスト xs, ys の和集合を求める。
  <li>intersection(xs, ys)<br>
リスト xs, ys の積集合を求める。
  <li>difference(xs, ys)<br>
リスト xs, ys の差集合を求める。
  <li>product(xs, ys)<br>
リスト xs, ys の直積集合を求める。
  <li>powerSet(xs)<br>
リスト xs のべき集合を求める。
</ul>
<pre>
Calc&gt; a = removeDup(list(1,1,2,1,2,3,1,2,3,4,1,2,3,4));
(1 2 3 4)
Calc&gt; b = list(3,4,5,6);
(3 4 5 6)
Calc&gt; union(a, b);
(1 2 3 4 5 6)
Calc&gt; intersection(a, b);
(3 4)
Calc&gt; difference(a, b);
(1 2)
Calc&gt; difference(b, a);
(5 6)
Calc&gt; product(list(1,2,3), list(4,5));
((1 . 4) (1 . 5) (2 . 4) (2 . 5) (3 . 4) (3 . 5))
Calc&gt; powerSet(list(1,2,3,4));
(() (4) (3) (3 4) (2) (2 4) (2 3) (2 3 4) (1) (1 4) (1 3) (1 3 4) (1 2) (1 2 4) (1 2 3) (1 2 3 4))
</pre>
<h4>マージとソート</h4>
<ul>
  <li>mergeList(xs, ys)<br>
リスト xs, ys をひとつのリストに併合する。xs, ys は演算子 &lt; を満たすように整列しておくこと。
  <li>insertSortList(xs)<br>
リスト xs を昇順に整列 (単純挿入ソート) する。
  <li>mergeSortList(pred, n, xs)<br>
リスト xs を昇順に整列 (マージソート) する。
  <li>insertSort(xs)<br>
ベクタ xs を昇順に整列 (単純挿入ソート) する。
  <li>quickSort(xs)<br>
ベクタ xs を昇順に整列 (クイックソート) する。
</ul>
<pre>
Calc&gt; mergeList(list(1,3,5,7), list(2,4,6,8));
(1 2 3 4 5 6 7 8)
Calc&gt; insertSortList(list(1,3,5,7,2,4,6,8));
(1 2 3 4 5 6 7 8)
Calc&gt; mergeSortList(list(1,3,5,7,2,4,6,8));
(1 2 3 4 5 6 7 8)
Calc&gt; insertSort([1,3,5,7,2,4,6,8]);
[1, 2, 3, 4, 5, 6, 7, 8]
Calc&gt; quickSort([1,3,5,7,2,4,6,8]);
[1, 2, 3, 4, 5, 6, 7, 8]
</pre>
<h4>順列と組み合わせ</h4>
<ul>
  <li>permutation(f, n, xs)<br>
リスト xs から n 個を選ぶ順列を生成し、それを関数 f に渡して評価する。
  <li>combination(f, n, xs)<br>
リスト xs から n 個を選ぶ組み合わせを生成し、それを関数 f に渡して評価する。
</ul>
<pre>
Calc&gt; permutation(print, 3, list(1,2,3));
(1 2 3)(1 3 2)(2 1 3)(2 3 1)(3 1 2)(3 2 1)
Calc&gt; combination(print, 3, list(1,2,3,4,5));
(1 2 3)(1 2 4)(1 2 5)(1 3 4)(1 3 5)(1 4 5)(2 3 4)(2 3 5)(2 4 5)(3 4 5)
</pre>
<h4>スタックとキュー</h4>
<ul>
  <li>makeStack()<br>
スタックを生成する。スタックを表すリスト s を返す。
  <li>push(s, x)<br>
スタック s に x をプッシュする。
  <li>pop(s)<br>
スタックからデータをポップする。
  <li>top(s)<br>
スタックトップにあるデータを返す。
  <li>isEmptyStack(s)<br>
スタック s が空であれば真を返す。
  <li>makeQueue()<br>
キューを生成する。キューを表すリスト q を返す。
  <li>enqueue(q, x)<br>
キュー q にデータ x を挿入する。
  <li>dequeue(q)<br>
キュー q からデータを取り出す。
  <li>front(q)<br>
キュー q の先頭データを返す。
  <li>isEmptyQueue(q)<br>
キュー q が空であれば真を返す。
</ul>
<pre>
Calc&gt; s = makeStack();
(())
Calc&gt; push(s, 1);
(1)
Calc&gt; push(s, 2);
(2 1)
Calc&gt; push(s, 3);
(3 2 1)
Calc&gt; isEmptyStack(s);
0
Calc&gt; top(s);
3
Calc&gt; pop(s);
3
Calc&gt; pop(s);
2
Calc&gt; pop(s);
1
Calc&gt; isEmptyStack(s);
1
Calc&gt; q = makeQueue();
(())
Calc&gt; enqueue(q, 1);
(1)
Calc&gt; enqueue(q, 2);
(2)
Calc&gt; enqueue(q, 3);
(3)
Calc&gt; isEmptyQueue(q);
0
Calc&gt; front(q);
1
Calc&gt; dequeue(q);
1
Calc&gt; dequeue(q);
2
Calc&gt; dequeue(q);
3
Calc&gt; isEmptyQueue(q);
1
</pre>
<h4>乱数の生成</h4>
<p> 乱数生成のアルゴリズムは線形合同法なので、乱数の品質はあまりよくない。
</p>
<ul>
  <li>seed(n)<br>
乱数のシードを設定する。
  <li>rand()<br>
0 以上 RandMax (0x100000000) 未満の乱数 (整数) を生成する。
  <li>random()<br>
0 以上 1.0 未満の乱数 (実数) を生成する。
</ul>
<pre>
Calc&gt; srand(clock());
3979656540
Calc&gt; let i = 0 in while i &lt; 8 do println(rand()), i = i + 1 end end;
1580551853
1952172426
2688968067
1359605992
1461301705
3210973942
3827903743
4181785396
0
Calc&gt; let i = 0 in while i &lt; 8 do println(random()), i = i + 1 end end;
0.8788879301864654
0.9104500492103398
0.8744489091914147
0.3117089420557022
0.4249188455287367
0.7197418245486915
0.8480797538068146
0.020515683107078075
0
</pre>
<h4>おまけ (数当てゲーム)</h4>
<p> マスターマインド (数当てゲーム) です。lib.cal のあとに <a href="abcgo26.html#list2">mastermind.cal</a> をロードしてください。
</p>
<pre>
C&gt;calc8 lib.cal mastermind.cal
Calc&gt; mastermind();
[a,b,c,d]&gt;&gt;&gt; [0,1,2,3];
1 : [0, 1, 2, 3], Bulls; 0, Cows: 2
[a,b,c,d]&gt;&gt;&gt; [4,5,6,7];
2 : [4, 5, 6, 7], Bulls; 2, Cows: 0
[a,b,c,d]&gt;&gt;&gt; [3,5,6,0];
3 : [3, 5, 6, 0], Bulls; 1, Cows: 1
[a,b,c,d]&gt;&gt;&gt; [1,3,6,7];
4 : [1, 3, 6, 7], Bulls; 0, Cows: 0
[a,b,c,d]&gt;&gt;&gt; [4,5,0,2];
Good Job!
</pre>
<HR>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// lib.cal : 電卓プログラム用ライブラリ
//
//           Copyright (C) 2014 Makoto Hiroi

//
// 数値計算
//

// 述語
def isOdd(x) x % 2 != 0 end
def isEven(x) x % 2 == 0 end
def isPositive(x) x &gt; 0 end
def isNegative(x) x &lt; 0 end
def isZero(x) x == 0 end

// 絶対値
def abs(x)
  if x &lt; 0 then -x else x end
end

// 符号
def sign(x)
  if x &gt; 0 then
    1
  else
    if x &lt; 0 then -1 end
  end
end

// 最大値と最小値
def max(a, b)
  if a &gt; b then a else b end
end

def min(a, b)
  if a &lt; b then a else b end
end

// 最大公約数
def gcd(a, b)
  if b == 0 then
    a
  else
    gcd(b, a % b)
  end
end

// 最小公倍数
def lcm(a, b)
  a * b / gcd(a, b)
end

// 累乗 x ** y (y is Int)
def expt(x, y)
  if y == 0 then
    1
  else
    if y == 1 then
      x
    else
      let z = expt(x, y / 2) in
        if isOdd(y) then
          z * z * x
        else
          z * z
        end
      end
    end
  end
end

// 階乗
def fact(n)
  let
    a = 1
  in
    while n &gt; 0 do
      a = a * n,
      n = n - 1
    end,
    a
  end
end

// フィボナッチ関数
def fibo(n)
  let
    a = 1,
    b = 0,
    c = 0
  in
    while n &gt; 0 do
      c = a,
      a = a + b,
      b = c,
      n = n - 1
    end,
    a
  end
end

// 組み合わせの数
def combNum(n, r)
  if n == 0 or r == 0 then
    1
  else
    combNum(n, r - 1) * (n - r + 1) / r
  end
end

//
// 連結リスト
//

def caar(xs) car(car(xs)) end
def cadr(xs) car(cdr(xs)) end
def cdar(xs) cdr(car(xs)) end
def cddr(xs) cdr(cdr(xs)) end

// 述語
def isList(xs)
  pair(xs) or null(xs)
end

def equal(xs, ys)
  if isVec(xs) then
    if isVec(ys) and len(xs) == len(ys) then
      let r = 1, i = 0 in
        while i &lt; len(xs) and r do
          if !equal(xs[i], ys[i]) then
            r = 0
          else
            i = i + 1
          end
        end,
        r
      end
    end
  else
    let r = 1 in
      while pair(xs) and pair(ys) and r do
        if !equal(car(xs), car(ys)) then
          r = 0
        else
          begin xs = cdr(xs), ys = cdr(ys) end
        end
      end,
      if r then
        if !pair(xs) and !pair(ys) then
          eql(xs, ys)
        end
      end
    end
  end
end

// 高階関数
def map(f, xs)
  if null(xs) then
    nil
  else 
    cons(f(car(xs)), map(f, cdr(xs)))
  end
end

def filter(f, xs)
  if null(xs) then
    nil
  else
    if f(car(xs)) then
      cons(car(xs), filter(f, cdr(xs)))
    else
      filter(f, cdr(xs))
    end
  end
end

def foldl(f, a, xs)
  while !null(xs) do
    a = f(car(xs), a),
    xs = cdr(xs)
  end,
  a
end

def foldr(f, a, xs)
  if null(xs) then
    a
  else
    f(car(xs), foldr(f, a, cdr(xs)))
  end
end

def every(f, xs)
  let r = 1 in
    while pair(xs) and r do
      if !f(car(xs)) then r = 0 end,
      xs = cdr(xs)
    end,
    r
  end
end

def any(f, xs)
  let r = 0 in
    while pair(xs) and !r do
      if f(car(xs)) then r = 1 end,
      xs = cdr(xs)
    end,
    r
  end
end

// リストの参照
def nth(xs, n)
  while !null(xs) and n &gt; 0 do
    xs = cdr(xs),
    n = n - 1
  end,
  car(xs)
end

def first(xs) car(xs) end
def second(xs) cadr(xs) end
def third(xs) car(cddr(xs)) end
def fourth(xs) nth(xs, 3) end
def fifth(xs) nth(xs, 4) end

// 長さ
def length(xs)
  foldl(fn(x, a) a + 1 end, 0, xs)
end

// 反転
def reverse(xs)
  foldl(fn(x, a) cons(x, a) end, nil, xs)
end

// 連結
def append(xs, ys)
  if null(xs) then
    ys
  else
    cons(car(xs), append(cdr(xs), ys))
  end
end

def revAppend(xs, ys)
  while !null(xs) do
    ys = cons(car(xs), ys),
    xs = cdr(xs)
  end,
  ys
end

// 削除
def remove(x, xs)
  foldr(fn(y, a) if eql(x, y) then a else cons(y, a) end end, nil, xs)
end

def removeIf(f, xs)
  foldr(fn(x, a) if f(x) then a else cons(x, a) end end, nil, xs)
end

// 先頭から n 個の要素を取り出す
def take(xs, n)
  if n == 0 or null(xs) then
    nil
  else
    cons(car(xs), take(cdr(xs), n - 1))
  end
end

// 先頭から n 個の要素を取り除く
def drop(xs, n)
  while !null(xs) and n &gt; 0 do
    xs = cdr(xs),
    n = n - 1
  end,
  xs
end

// 末尾から n 個の要素を取り出す
def last(xs, n)
  drop(xs, length(xs) - n)
end

// 末尾から n 個の要素を取り除く
def butlast(xs, n)
  take(xs, length(xs) - n)
end

// リストの生成
def makelist(n, x)
  let
    xs = nil
  in
    while n &gt; 0 do
      xs = cons(x, xs),
      n = n - 1
    end,
    xs
  end
end

def iota(n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(m, xs),
      m = m - 1
    end,
    xs
  end
end

def tabulate(f, n, m)
  let
    xs = nil
  in
    while m &gt;= n do
      xs = cons(f(m), xs),
      m = m - 1
    end,
    xs
  end
end

// リストの分割
def partition(f, xs)
  if null(xs) then
    list(nil)
  else
    let ys = partition(f, cdr(xs)) in
      if f(car(xs)) then
        cons(cons(car(xs), car(ys)), cdr(ys))
      else
        cons(car(ys), cons(car(xs), cdr(ys)))
      end
    end
  end
end


// 探索
def member(x, ls)
  while !null(ls) and !eql(car(ls), x) do
    ls = cdr(ls)
  end,
  ls
end

def memberIf(f, ls)
  while !null(ls) and !f(car(ls)) do
    ls = cdr(ls)
  end,
  ls
end

// 連想リスト
def zip(xs, ys)
  if null(xs) or null(ys) then
    nil
  else
    cons(cons(car(xs), car(ys)), zip(cdr(xs), cdr(ys)))
  end
end

def assoc(x, xs)
  while !null(xs) and !eql(caar(xs), x) do
    xs = cdr(xs)
  end,
  car(xs)
end

def assocIf(f, xs)
  while !null(xs) and !f(caar(xs)) do
    xs = cdr(xs)
  end,
  car(xs)
end

//
// 集合演算
//

// 重複要素を取り除く
def removeDup(xs)
  foldr(fn(x, a) if member(x, a) then a else cons(x, a) end end, nil, xs)
end

// 集合の和
def union(xs, ys)
  foldr(fn(x, a) if member(x, ys) then a else cons(x, a) end end, ys, xs)
end

// 集合の積
def intersection(xs, ys)
  foldr(fn(x, a) if member(x, ys) then cons(x, a) else a end end, nil, xs)
end

// 集合の差
def difference(xs, ys)
  foldr(fn(x, a) if member(x, ys) then a else cons(x, a) end end, nil, xs)
end

// 直積集合
def product(xs, ys)
  foldr(fn(x, a) append(map(fn(y) cons(x, y) end, ys), a) end, nil, xs)
end

// べき集合
def powerSet(xs)
  if null(xs) then
    list(nil)
  else
    append(powerSet(cdr(xs)),
           map(fn(ys) cons(car(xs), ys) end, powerSet(cdr(xs))))
  end
end

//
// ベクタ
//

// 高階関数
def vectorFold(f, a, xs)
  let i = 0 in
    while i &lt; len(xs) do
      a = f(xs[i], a),
      i = i + 1
    end,
    a
  end
end

//
// 列関数
//

def selectFold(xs)
  if isList(xs) then
    foldl
  else
    if isVec(xs) then
      vectorFold
    else
      error("list or vector required")
    end
  end
end

def sum(xs)
  let
    f = selectFold(xs)
  in
    f(fn(x, y) x + y end, 0, xs)
  end
end

def maximum(xs)
  if pair(xs) then
    foldl(fn(x, a) max(x, a) end, car(xs), cdr(xs))
  else
    if isVec(xs) then
      vectorFold(fn(x, a) max(x, a) end, xs[0], xs)
    else
      error("list or vector required")
    end
  end
end

def minimum(xs)
  if pair(xs) then
    foldl(fn(x, a) min(x, a) end, car(xs), cdr(xs))
  else
    if isVec(xs) then
      vectorFold(fn(x, a) min(x, a) end, xs[0], xs)
    else
      error("list or vector required")
    end
  end
end

def positionIf(f, xs)
  let i = 0, r = 0 in
    if isList(xs) then
      while !null(xs) and !r do
        if f(car(xs)) then
          r = 1
        else
          begin i = i + 1, xs = cdr(xs) end
        end
      end
    else
      if isVec(xs) then
        while i &lt; len(xs) and !r do
          if f(xs[i]) then
            r = 1
          else
            i = i + 1
          end
        end
      else
        error("list or vector required")
      end
    end,
    if r then i else -1 end
  end
end

def position(x, xs)
  positionIf(fn(y) eql(x, y) end, xs)
end

def findIf(f, xs)
  if isList(xs) then
    car(memberIf(f, xs))
  else
    if isVec(xs) then
      let i = positionIf(f, xs) in
        if i &gt;= 0 then xs[i] else nil end
      end
    else
      error("list or vector required")
    end
  end
end

def find(x, xs)
  !null(findIf(fn(y) eql(x, y) end, xs))
end

def countIf(f, xs)
  let
    g = selectFold(xs)
  in
    g(fn(x, a) if f(x) then a + 1 else a end end, 0, xs)
  end
end

def count(x, xs)
  countIf(fn(y) eql(x, y) end, xs)
end

//
// リストとベクタの変換
//
def toList(xs)
  let ys = nil, i = len(xs) - 1 in
    while i &gt;= 0 do
      if isVec(xs[i]) then
        ys = cons(toList(xs[i]), ys)
      else
        ys = cons(xs[i], ys)
      end,
      i = i - 1
    end,
    ys
  end
end

def toVector(xs)
  let ys = vector(length(xs), 0), i = 0 in
    while pair(xs) do
      if pair(car(xs)) then
        ys[i] = toVector(car(xs))
      else
        ys[i] = car(xs)
      end,
      xs = cdr(xs),
      i = i + 1
    end,
    ys
  end
end

// foreach と copy
def foreach(f, xs)
  let
    g = selectFold(xs)
  in
    g(fn(x, a) f(x) end, 0, xs)
  end
end

def copy(xs)
  if isList(xs) then
    foldr(cons, nil, xs)
  else
    if isVec(xs) then
      let i = 0, ys = vector(len(xs), 0) in
        while i &lt; len(xs) do
          ys[i] = xs[i],
          i = i + 1
        end,
        ys
      end
    else
      error("list or vector required")
    end
  end
end

//
// 順列と組み合わせ
//
def permSub(f, n, xs, a)
  if n == 0 then
    f(reverse(a))
  else
    foreach(fn(x) permSub(f, n - 1, remove(x, xs), cons(x, a)) end, xs)
  end
end

def permutation(f, n, xs)
  permSub(f, n, xs, nil)
end

def combSub(f, n, xs, a)
  if n == 0 then
    f(reverse(a))
  else
    if length(xs) == n then
      f(append(reverse(a), xs))
    else
      begin
        combSub(f, n - 1, cdr(xs), cons(car(xs), a)),
        combSub(f, n, cdr(xs), a)
      end
    end
  end
end

def combination(f, n, xs)
  combSub(f, n, xs, nil)
end

//
// 素数
//
def sieve(n)
  let
     xs = iota(2, n), ys = nil
  in
    while car(xs) &lt;= sqrt(n) do
      ys = cons(car(xs), ys),
      xs = removeIf(fn(x) x % car(xs) == 0 end, xs)
    end,
    revAppend(ys, xs)
  end
end

// 素因数分解
def factorSub(n, m)
  let c = 0 in
    while n % m == 0 do
      c = c + 1,
      n = n / m
    end,
    cons(c, n)
  end
end

def factorization(n)
  let
    xs = factorSub(n, 2),
    ys = if car(xs) != 0 then list(cons(2, car(xs))) else nil end,
    i = 3
  in
    n = cdr(xs),
    while n &gt;= i * i and n != 1 do
      xs = factorSub(n, i),
      if car(xs) != 0 then
        ys = cons(cons(i, car(xs)), ys)
      end,
      n = cdr(xs),
      i = i + 2
    end,
    if n != 1 then ys = cons(cons(n, 1), ys) end,
    reverse(ys)
  end
end

//
// 線形合同法による乱数の生成
//
Seed = 1;
Mask = 0x100000000;
RandMax = Mask - 1;

def srand(n)
  Seed = n % Mask
end

def rand()
  Seed = (69069 * Seed + 1) % Mask,
  Seed
end

def random()
  (1.0 / (RandMax + 1.0)) * rand()
end

//
// マージとソート
//
def insertElement(x, xs)
  if null(xs) then
    list(x)
  else
    if x &lt;= car(xs) then
      cons(x, xs)
    else
      cons(car(xs), insertElement(x, cdr(xs)))
    end
  end
end

def insertSortList(xs)
  let ys = nil in
    while !null(xs) do
      ys = insertElement(car(xs), ys),
      xs = cdr(xs)
    end,
    ys
  end
end

def mergeList(xs, ys)
  if null(xs) then
    ys
  else
    if null(ys) then
      xs
    else
      if car(xs) &lt;= car(ys) then
        cons(car(xs), mergeList(cdr(xs), ys))
      else
        cons(car(ys), mergeList(xs, cdr(ys)))
      end
    end
  end
end

//
def mergeSortSub(n, xs)
  if n &lt; 16 then
    insertSortList(take(xs, n))
  else
    let m = n / 2 in
      mergeList(mergeSortSub(m, xs),
                mergeSortSub(n - m, drop(xs, m)))
    end
  end
end 

def mergeSortList(xs)
  mergeSortSub(length(xs), xs)
end

//
// ベクタのソート
//

// 単純挿入ソート
def insertSort(v)
  let
    i = 1, k = len(v), j = 0, tmp = 0
  in
    while i &lt; k do
      j = i,
      tmp = v[i],
      while j &gt; 0 and v[j - 1] &gt;= tmp do
        v[j] = v[j - 1],
        j = j - 1
      end,
      v[j] = tmp,
      i = i + 1
    end
  end,
  v
end

// クイックソート
def qsort(v, low, high)
  if high - low &gt; 16 then
    let
      pivot = v[(low + high) / 2],
      flag = 1,
      i = low,
      j = high
    in
      while flag do
        while v[i] &lt; pivot do i = i + 1 end,
        while pivot &lt; v[j] do j = j - 1 end,
        if i &lt; j then
          let tmp = v[i] in
            v[i] = v[j],
            v[j] = tmp,
            i = i + 1,
            j = j - 1
          end
        else
          flag = 0
        end
      end,
      qsort(v, low, i - 1),
      qsort(v, j + 1, high)
    end
  end
end

def quickSort(v)
  qsort(v, 0, len(v) - 1),
  insertSort(v)
end

//
// スタックとキュー
//
def makeStack() list(nil) end

def push(s, x) setCar(s, cons(x, car(s))) end

def pop(s)
  if null(car(s)) then
    error("Stack is empty")
  else
    let x = caar(s) in
      setCar(s, cdar(s)),
      x
    end
  end
end

def top(s)
  if null(car(s)) then
    error("Stack is empty")
  else
    caar(s)
  end
end

def isEmptyStack(s) null(car(s)) end

// キュー
def makeQueue() cons(nil, nil) end

def enqueue(q, x)
  let
    newCell = list(x)
  in
    if null(car(q)) then
      begin setCar(q, newCell), setCdr(q, newCell) end
    else
      begin setCdr(cdr(q), newCell), setCdr(q, newCell) end
    end
  end
end

def dequeue(q)
  if null(car(q)) then
    error("Queue is empty")
  else
    let x = car(q) in
      setCar(q, cdr(x)),
      if null(cdr(x)) then setCdr(q, nil) end,
      car(x)
    end
  end
end

def front(q)
  if null(car(q)) then
    error("Queue is empty")
  else
    caar(q)
  end
end

def isEmptyQueue(q) null(car(q)) end
</pre>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
//
// mastermind.cal : 数当てゲーム
//
//                  Copyright (C) 2014 Makoto Hiroi
//

def makeQuestion()
  let
    xs = vector(4, -1),
    x = 0, n = 0
  in
    while n &lt; 4 do
      x = (rand() / 0x10000) % 10,
      if !find(x, xs) then
        begin xs[n] = x, n = n + 1 end
      end
    end,
    xs
  end
end

def countBulls(xs, ys)
  let c = 0, i = 0 in
    while i &lt; 4 do
      if xs[i] == ys[i] then c = c + 1 end,
      i = i + 1
    end,
    c
  end
end

def countSameNumber(xs, ys)
  let c = 0, i = 0 in
    while i &lt; 4 do
      if find(xs[i], ys) then c = c + 1 end,
      i = i + 1
    end,
    c
  end
end

def check(xs)
  if isVec(xs) and len(xs) == 4 then
    let i = 0, r = 1 in
      while i &lt; 4 and r do
        if count(xs[i], xs) != 1 then
          r = 0
        else
          i = i + 1
        end
      end,
      r
    end
  end
end

def initRand(n)
  while n &gt; 0 do rand(), n = n - 1 end
end

def mastermind()
  initRand(clock() % 0x100),
  let xs = makeQuestion(),
      ys = 0, r = 1
  in
    while r do
      ys = input("[a,b,c,d]&gt;&gt;&gt; "),
      if eql(ys, 0) then
        begin print("oops! : "), error(xs) end
      end,
      if !check(ys) then
        println("input error")
      else
        let bulls = countBulls(xs, ys),
            cows = countSameNumber(xs, ys) - bulls
        in
          if bulls == 4 then
            r = 0
          else
            begin
              print(r), print(" : "), print(ys),
              print(", Bulls; "), print(bulls),
              print(", Cows: "), println(cows),
              r = r + 1
            end
          end
        end
      end
    end,
    "Good Job!"
  end
end
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2014 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="abcgo25.html">PrevPage</a> | <a href="index.html">Golang</a> | <a href="abcgo27.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>