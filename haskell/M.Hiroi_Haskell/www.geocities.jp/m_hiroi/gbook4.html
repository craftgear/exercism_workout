<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>M.Hiroi's Home Page / Guest Book Log</title>
  <meta name="description" content="M.Hiroi's Home Page,Guest Book Log">
  <link rel="stylesheet" type="text/css" href="home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881755</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Guest Book Log</h1>
</div>
<div class="small">
[ <a href="index.html">Home</a> ]
<hr>
</div>
<section class="contents">
<h3>120.完全ハッシュ関数の逆関数
 </h3>投稿者:高橋謙一郎 - 2000年 12月 21日 20時 32分 53秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.5; Windows 98; Win 9x 4.90)<br>メールアドレス：<a 
href="mailto:takaken@ic-net.or.jp">takaken@ic-net.or.jp</a><br><br><br>広井さん、deepgreenさん、鎌田さん　こんばんは。<br>お久しぶりです。コンピュータ＆パズルの高橋です。<br>完全ハッシュ関数は面白いですね。とても勉強になりました。<br><br>ところで、完全ハッシュ値から逆算して元の状態を復元できる<br>逆関数があれば「局面を保存する場所は不要」になりますね。<br>メモリが不足する場合などには便利に使えると思います。<br>さっそく作ってみたのが下のコードですが、組合せ型の最後の<br>２行は若干の不安が残ります。<br><br>/* 
順列型の完全ハッシュ逆関数(広井さんのコードより) */<br>void change_board(int value, char 
*board)<br>{<br>　　int i, j;<br>　　for (i=0; i&lt;SIZE-1; i++) {<br>　　　　board[i] = 
value / fact_table[i];<br>　　　　value -= fact_table[i] * 
board[i];<br>　　}<br>　　board[i] = 0;<br>　　for (i=SIZE-2; i&gt;=0; i--) 
{<br>　　　　for (j=i+1; j&lt;SIZE; j++)<br>　　　　　if (board[i] &lt;= board[j]) 
board[j]++;<br>　}<br>}<br>/* 組合せ型の完全ハッシュ逆関数(鎌田さんのコードより) */<br>void ncr2inv(int 
n, int r, int value, char *p)<br>{<br>　　int c;<br>　　n--;<br>　　c = ncr(n, r); /* 
nCr */<br>　　while (n&gt;=r &amp;&amp; r&gt;0) {<br>　　　if (value / c) 
{<br>　　　　　value -= c;<br>　　　　　c = (c * r) / (n - r + 1); /* nC(r-1) 
*/<br>　　　　　r--;<br>　　　　　*p++ = 1;<br>　　　} else {<br>　　　　　*p++ = 
0;<br>　　　}<br>　　　c = (c * (n - r)) / n; /* (n-1)Cr */<br>　　　n--;<br>　　}<br>　　for 
(n++; n; n--)<br>　　　　*p++ = (n &gt; r)? 0: 1;<br>}<br>
<blockquote></blockquote>
<hr>

<h3>119.KaMemo
 </h3>投稿者:M.Hiroi - 2000年 12月 21日 18時 42分 00秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geicoties.co.jp">m_hiroi@geicoties.co.jp</a><br><br>xyzzy 
の作者である亀井さんのホームページでは、<br>リンク先ホームページの紹介のほかに、コメントがつく場合が<br>あります。これを ＫａＭｅｍｏ [(C) 
Toy] といいます。 <br><br>このたび、私のところにもついに KaMemo が書いてありました。<br>よっしゃー！ 
さて内容はなんだろうと読んでみたら、<br><br>あうあう、そうでした。defmacro はそれが使えるのね（笑）。<br><br>ということで、「xyzzy 
Lisp：マクロ」を更新しました。<br>亀井さんに感謝です！<br>
<blockquote></blockquote>
<hr>

<h3>118.うさぎと犬
 </h3>投稿者:M.Hiroi - 2000年 12月 12日 22時 16分 22秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt;少し前のＣマガに「うさぎと犬」というゲームの問題がありました。<br>&gt;丁度、状態の数が少ないので使えそうです。<br><br>Ｃマガジン10月号ですね。なるほど、組み合わせが使えそうです。<br>解答発表は次号(12/18発売予定)なので、どんなプログラムが掲載<br>されるか楽しみです。<br><br>思考ゲームといえば、ミニマックス法＋αβ枝刈りが定番アルゴリズム<br>ですが、例題にぴったりのゲームがあります。８行８列に＋と－の数字<br>が配置されていて、その数字を取り合うもので、名前が「MinMax」だっ<br>たはずです（笑）。これは簡単にプログラムできるので、そのうちに<br>紹介したいと思います。<br>
<blockquote></blockquote>
<hr>

<h3>117.ｒｅ＾8：組み合わせ
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 12月 12日 21時 00分 48秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>こんばんは、deepgreenです。<br><br>少し前のＣマガに「うさぎと犬」というゲームの問題がありました。<br>（先手必勝なのでその手順をもとめよというもの）<br>丁度、状態の数が少ないので使えそうです。それに、α・β枝刈りも解説が<br>ありましたし、ぴったりの問題かもしれませんね。<br>
<blockquote></blockquote>
<hr>

<h3>116.ｒｅ＾7：組み合わせ
 </h3>投稿者:M.Hiroi - 2000年 12月 10日 18時 04分 43秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>鎌田さん、deepgreen 
さん、こんばんは。<br><br>せっかく良い方法を教えてもらったのですから、<br>実際のパズルの解法に応用してみたいですね。<br>逆に、そのようなパズルを考えてみるのも<br>面白いかもしれません（笑）。<br>
<blockquote></blockquote>
<hr>

<h3>115.ｒｅ＾６：組み合わせ
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 12月 09日 21時 43分 34秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>kamadaさん、広井さん　こんばんは。　deepgreenです。<br><br>どうもありがとうございます。意外と簡単にできましたね。<br>チャンスがあれば、どこかで利用してみます。<br>
<blockquote></blockquote>
<hr>

<h3>114.re^5:組み合わせ
 </h3>投稿者:M.Kamada - 2000年 12月 09日 15時 48分 17秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.01; Windows 98)<br>メールアドレス：<a 
href="mailto:m_kamada@nifty.com">m_kamada@nifty.com</a><br>ホームページ：<a 
href="http://homepage2.nifty.com/m_kamada/index.htm">http://homepage2.nifty.com/m_kamada/index.htm</a><br><br>広井さん、こんにちは。<br><br>&gt;最上位ビットが０の場合、ncr(7,4)=35 
通りの組み合わせがあるので、<br>&gt;0 - 34 の数値を割り当てる、１の場合は残りの組み合わせが<br>&gt;ncr(7,3)=35 
通りあるので、35 - 69 
の数値を割り当てる、<br>&gt;あとは各ビットに対してこれを繰り返せば求めることができる、<br>&gt;というわけですね。<br><br>そうそう、そんな感じ。<br>パスカルの三角形の上の経路に番号を振っているだけです。<br><br>下の位からやったほうがncr(n,r)を計算しなくて済むぶん速いかも。<br>そうすればncr(n,r)の計算中のオーバーフローを気にしなくて済むし。<br>
<blockquote></blockquote>
<hr>

<h3>113.re^4:組み合わせ
 </h3>投稿者:M.Hiroi - 2000年 12月 09日 14時 30分 24秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>鎌田さん、こんにちは。<br><br>&gt;nCrの組み合わせを0～(nCr)-1の番号に変換する方法ですが、<br>&gt;基数変換の応用で簡単にできます。<br><br>書き込み、ありがとうございます！<br><br>最上位ビットが０の場合、ncr(7,4)=35 
通りの組み合わせがあるので、<br>0 - 34 の数値を割り当てる、１の場合は残りの組み合わせが<br>ncr(7,3)=35 通りあるので、35 - 69 
の数値を割り当てる、<br>あとは各ビットに対してこれを繰り返せば求めることができる、<br>というわけですね。<br><br>なるほど、納得しました。さすが鎌田さんです。<br>目からウロコが落ちました（笑）。<br>素晴らしい方法を教えていただき、大感謝です。<br>
<blockquote></blockquote>
<hr>

<h3>112.re^3:組み合わせ
 </h3>投稿者:M.Kamada - 2000年 12月 09日 04時 25分 32秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.01; Windows 98)<br>メールアドレス：<a 
href="mailto:m_kamada@nifty.com">m_kamada@nifty.com</a><br>ホームページ：<a 
href="http://homepage2.nifty.com/m_kamada/index.htm">http://homepage2.nifty.com/m_kamada/index.htm</a><br><br>広井さん、deepgreenさん、こんにちは。<br><br>nCrの組み合わせを0～(nCr)-1の番号に変換する方法ですが、<br>基数変換の応用で簡単にできます。<br><br>てきとーに書いたサンプルなので不完全and/or無駄があるかも知れませんが、<br>下のCの関数で<br>ncr2num(8,4,"00001111")==0<br>ncr2num(8,4,"00010111")==1<br>　:<br>ncr2num(8,4,"11110000")==69<br>になります。<br><br>--------<br>int 
ncr2num(int n, int r, char *p)<br>{<br>int c, a = 0;<br>n--;<br>c = ncr(n, r); 
/* nCr */<br>while (n &gt;= r &amp;&amp; r &gt; 0) {<br>if (*p++ &amp; 1) {<br>a 
+= c;<br>c = (c * r) / (n - r + 1); /* nC(r-1) */<br>r--;<br>}<br>c = (c * (n - 
r)) / n; /* (n-1)Cr */<br>n--;<br>}<br>return a;<br>}<br>
<blockquote></blockquote>
<hr>

<h3>111.re^2:組み合わせ
 </h3>投稿者:M.Hiroi - 2000年 12月 08日 22時 50分 30秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt;やはり、簡単な方法はないのでしょうか。<br>&gt;ときどきでてくるパターンなので、よい方法あるといいなぁ<br>&gt;と思っていました。<br><br>Google 
で検索してみましたが、やはり見つかりません。<br>よい方法を知っている方がいましたら、書き込みお願いいたします。<br>
<blockquote></blockquote>
<hr>
<h3>110.ｒｅ：組み合わせ
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 12月 08日 20時 53分 26秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>広井さん、こんばんは。　deepgreenです。<br><br>&gt;&gt;しかし、不思議なことに組み合わせ 
nＣｋの完全ハッシュ関数を解説して<br>&gt;&gt;いるところはありません。<br><br>&gt;たとえば、８個の中から４個を選ぶ組み合わせは７０通りありますが、<br>&gt;それを 
0 から 69 の数値に変換する方法ならば、M.Hiroi 
もわかり<br>&gt;ません。<br><br>そうそう、これが知りたかったのですが、やはり、簡単な方法はないの<br>でしょうか。ときどきでてくるパターンなので、よい方法あるといいなぁ<br>と思っていました。<br>
<blockquote></blockquote>
<hr>

<h3>109.組み合わせ
 </h3>投稿者:M.Hiroi - 2000年 12月 08日 20時 03分 04秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt;しかし、不思議なことに組み合わせ 
nＣｋの完全ハッシュ関数を解説して<br>&gt;いるところはありません。<br><br>たとえば、８個の中から４個を選ぶ組み合わせは７０通りありますが、<br>それを 
0 から 69 の数値に変換する方法ならば、M.Hiroi 
もわかり<br>ません。<br><br>ところで、組み合わせは次の方法で簡単に数値へ変換することができます。<br>たとえば、0 - 7 
の数字の組み合わせを考える場合、0 - 7 を 0 bit から<br>7 bit に対応させます。すると、2,3,4,6 という組み合わせは 
01011100<br>になるので 92 と表すことができます。<br><br>たしか、値が衝突しないハッシュ関数を完全ハッシュ関数、Ｎ個のデータ<br>を 0 
から N - 1 
に変換するハッシュ関数を最小完全ハッシュ関数と呼ん<br>でいたように記憶しています。すいません、記憶があやふやです（苦笑）。<br><br>そうだとすると、この方法でも値は衝突しないので、完全ハッシュ関数と<br>考えてよいと思うのですが、どうでしょうか。<br>
<blockquote></blockquote>
<hr>

<h3>108.単なる興味の質問：組み合わせ nＣｋ の完全ハッシュ関数は？
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 12月 08日 00時 01分 26秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>こんばんは、deepgreenです。<br><br>単なる興味ですが、８パズルの解法でｎ個の順列の完全ハッシュ関数の<br>説明がありました。この方法は他のサイトでも目にしたことがあります。<br>しかし、不思議なことに組み合わせ 
nＣｋ の完全ハッシュ関数を解説して<br>いるところはありません。（私が知らないだけでしょうけど）<br>もし、ご存知でしたら教えてください。<br>
<blockquote></blockquote>
<hr>

<h3>107.Vivisimo Search
 </h3>投稿者:M.Hiroi - 2000年 12月 07日 20時 54分 24秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>Memo 
に書いた Vivisimo Search の続きです。<br><br>M.Hiroi's Home Pageを検索すると、「anime, 
sakura」という<br>カテゴリに分類されるＨＰがあります。これは、どうやら作家（？）<br>の広井王子氏に関連したホームページのようです。<br>sakura 
は「ＣＣさくら」ではなくて、「サクラ大戦」みたいで<br>す。なるほど、きちんと分類されているんですね。<br><br>Vivisimo 
Search、ただ者ではないようです（笑）。<br>
<blockquote></blockquote>
<hr>

<h3>106.Re.Prolog:平面上の蛙とびゲーム＆ペグ・ソリテア
 </h3>投稿者:M.Hiroi - 2000年 11月 29日 21時 38分 05秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; ついでに、平面上の蛙とびゲームをＰｒｏｌｏｇで解いてみました。<br><br>４６手と長い手数かかりますが、それを 
Prolog で解くとは、さすが<br>deepgreen さんですね。お見事です。<br><br>&gt; 
広井さんの枝刈り（グループ化）を追加した場合、以下のような<br>&gt; 
結果となりました。<br><br>さっそく試していただき、ありがとうございます。<br>なるほど、deepgreen 
さんの枝刈りと組み合わせた場合でも、<br>効果は出ていますね。おかげさまで、有効な枝刈りであることを<br>確かめることができました。<br><br>幅優先探索の場合、枝刈りの効果は少ないですが、それだけ無駄な<br>状態を生成していないのでしょう。双方からの幅優先探索の効果は<br>絶大であることを、あらためて実感しました。<br>
<blockquote></blockquote>
<hr>

<h3>105.Prolog:平面上の蛙とびゲーム＆ペグ・ソリテア
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 29日 01時 26分 26秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>こんばんは、deepgreenです。<br><br>ついでに、平面上の蛙とびゲームをＰｒｏｌｏｇで解いてみました。<br>やはり、最短手数は４６手です。直線の場合と違って、解はたくさんあります。<br><br>　　探索時間：５２５秒　　ノード数：４５２９７<br><br><br>それから、広井さんの枝刈り（グループ化）を追加した場合、以下のような<br>結果となりました。<br>　　　　　　　　　　前回　　　　　　今回 
　前回／今回<br>　　反復深化　　２３８４秒　　　１６８３秒 　　 １．４２　<br>　　（ノード数）1,083,994 840,926　　　 
１．２９<br><br>　　幅優先　　　　７２７秒　　　　６４２秒　　　　１．１３　<br>　　（ノード数）　 94,396　　　 　 88,514　　　 
１．０７<br>　　　<br>
<blockquote></blockquote>
<hr>

<h3>104.Re.Prolog:変形三角盤（ペグソリティア）
 </h3>投稿者:M.Hiroi - 2000年 11月 23日 20時 27分 04秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; 割り算を１桁間違えていました。約２８０倍でした。<br><br>はい、そうでしたね。M.Hiroi 
も後から気がつきました（笑）。<br>280 倍でも大きな違いであることは、かわりありません。<br><br>&gt; 
反復深化の方の結果がでました。<br>&gt; 探索時間：約４０分 
ノード数：１，０８３，９９４<br><br>おめでとうございます！<br>いやー、凄いです。M.Hiroi 
は、１時間以上かかるだろうと思ってい<br>ましたが、40 分とはとても速いです。<br><br>deepgreen 
さんの枝刈りは凄いですね。探索ノード数が拙作の約半分<br>なのを見て、目が点になりましたよ（笑）。must と need 
に分けて<br>管理する方法は素晴らしいと思います。<br><br>プログラムの公開、ありがとうございます。<br>Prolog 
に興味のある方は、ぜひ参考にしてください。<br>とても勉強になります。<br>
<blockquote></blockquote>
<hr>

<h3><a name="103">103.</a>Re.Prolog:変形三角盤（ペグソリティア）
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 23日 02時 12分 57秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br>ホームページ：<a 
href="http://www2.tokai.or.jp/deepgreen/shortnotes/pegida.txt">http://www2.tokai.or.jp/deepgreen/shortnotes/pegida.txt</a><br><br>こんばんは、deepgreenです。<br><br>&gt; 
ノード数は、（目安ですが）約２８００倍の差があります。<br><br>すみません。割り算を１桁間違えていました。約２８０倍でした。<br><br>反復深化の方の結果がでました。下記のＵＲＬにあります。<br><br>枝刈りの着眼点は同じですが、実装は少し違うようです。<br>　　　　　Ａ　Ｂ<br>　　　　　　Ｃ　<br>　　　　　Ｄ　Ｅ<br>　　　　Ｆ　Ｇ　Ｈ<br>　　　・　・　・　・<br>隅のＡ，Ｂ，Ｃのパターンに着目すると、<br>　(1)Ａ，Ｂにピンがある場合は、そこが始点になる必要がありますので<br>　　これをｍｕｓｔカウントとします。<br>　(2)Ａ，Ｂにピンがあり、Ｃの位置にピンがないときは、Ｃの位置にピンが<br>　　こなければなりません。これをｎｅｅｄカウントとします。<br>　(3)Ａ，Ｂにピンがなく、Ｃの位置にピンがあるときは、Ｃの位置が始点に<br>　　なる必要があります。これはｍｕｓｔカウントとします。この場合連続<br>　　跳びで別の隅のｎｅｅｄカウントをさげる可能性があるため、ｎｅｅｄ<br>　　カウントは－１にします。<br>　　<br>　　Ｃ　Ｂ　Ａ　　ｍｕｓｔ　　ｎｅｅｄ<br>　　０　０　０　　　　０　　　　　０<br>　　０　０　１　　　　１　　　　　１<br>　　０　１　０　　　　１　　　　　１<br>　　０　１　１　　　　２　　　　　２<br>　　１　０　０　　　　１　　　　－１<br>　　１　０　１　　　　１　　　　　０<br>　　１　１　０　　　　１　　　　　０<br>　　１　１　１　　　　２　　　　　１<br>　　<br>　下限値は、３つの隅について、上記のｍｕｓｔの合計＋ｎｅｅｄの合計とな<br>　ります。ただし、ｎｅｅｄの合計が負のときは０にします。また、最終手の<br>　位置の考慮も必要です。<br>　　<br>　　探索時間：約４０分　　ノード数：１，０８３，９９４<br>
<blockquote></blockquote>
<hr>

<h3>102.Re.Prolog:変形三角盤（ペグソリティア）
 </h3>投稿者:M.Hiroi - 2000年 11月 22日 22時 58分 46秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; 私も、ＩＤＡサーチの方は、この方法でやっています。この枝刈りは、ちょっと<br>&gt; 
面倒なところがあります。今までは、それ以前の探索制御でトラブッていました。<br><br>いやー、実は M.Hiroi 
もトラブってしまいました。<br>連続跳びの途中で枝刈りを行うとダメなことに気づかず、<br>最初は何で動かないんだ？ 
と混乱してしまいました（苦笑）。<br>詳しいことは、Puzzle DE Programming 
でプログラムを公開するときに<br>説明する予定です。<br><br>それで、結果は Memo 
に書きましたが、うまくいきません（泣）。<br>そのほかの枝刈りも試しましたのですが、探索ノード数は減っても、<br>幅優先探索の約９５０００個には及びません。<br><br>うーん、残念です。なにか効率的な枝刈りがありましたら、<br>教えてくださいませ。＞ＡＬＬ<br>
<blockquote></blockquote>
<hr>

<h3>101.ｒｅ：Re.Ｐｒｏｌｏｇ：変形三角盤（ペグソリティア）
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 22日 21時 22分 15秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>広井さん、こんばんは。deepgreenです。<br><br>&gt;コーナーペグが移動するためには、自分で跳ぶしかありません。この<br>&gt;時、跳び越すペグが必要になります。つまり、この位置にペグが無い<br>&gt;場合は、そこにペグを移動させてから、コーナーペグを移動させることに<br>&gt;なります。つまり、それだけ手数がかかるわけです。この条件も下限値と<br>&gt;して利用すれば、もっと効率的に枝刈りができると思われます。<br><br>私も、ＩＤＡサーチの方は、この方法でやっています。この枝刈りは、ちょっと<br>面倒なところがあります。今までは、それ以前の探索制御でトラブッていました。<br>ようやく、それがわかったので少し前進です。これで答えがでてくれると<br>Ｈａｐｐｙですが、。。。<br>
<blockquote></blockquote>
<hr>
<h3>100.Re.Ｐｒｏｌｏｇ：変形三角盤（ペグソリティア）
 </h3>投稿者:M.Hiroi - 2000年 11月 21日 20時 13分 01秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>Prolog ソースプログラムを公開していただき、ありがとうございました。<br>いやー、M.Hiroi 
が考えていた以上のアイデアが盛り込まれていて、<br>もはや脱帽するしかありません（笑）。<br><br>&gt; 
ノード数は、（目安ですが）約２８００倍の差があります。<br><br>おおっと、そんなに差がありましたか。幅優先探索の場合、スタート<br>からの探索と平行に、ゴールからも探索すると、探索する局面数（ノード数）<br>を劇的に減らすことができます。<br>（詳しい説明は、「変形版：おしどりの遊び」で行う予定です。）<br><br>となると、抜本的に枝刈りを見直さないと、反復深化で解くのは難しい<br>ですね。そこで、次のような方法を思いつきました。<br><br>コーナーペグが移動するためには、自分で跳ぶしかありません。この<br>時、跳び越すペグが必要になります。つまり、この位置にペグが無い<br>場合は、そこにペグを移動させてから、コーナーペグを移動させることに<br>なります。つまり、それだけ手数がかかるわけです。この条件も下限値と<br>して利用すれば、もっと効率的に枝刈りができると思われます。<br><br>とりあえず、Ｃプログラムを改造して試してみるつもりですが、探索<br>ノード数が劇的に減少しないと、別の枝刈りを考えないといけませんね。<br><br>それではまた。<br>
<blockquote></blockquote>
<hr>

<h3>99.Re.Ｐｒｏｌｏｇ：変形三角盤（ペグソリティア）
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 20日 23時 42分 47秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br>ホームページ：<a 
href="http://www2.tokai.or.jp/deepgreen/">http://www2.tokai.or.jp/deepgreen/</a><br><br>広井さん、こんばんは。deepgreenです。<br><br>Ｐｒｏｌｏｇソースは、量が多いので私のＨＰの掲示板にｕｐしました。<br><br>　　　　　　　　　　　　　　　探索ノード数　　　　　探索時間<br>　幅優先探索（ｐｒｏｌｏｇ）　約９５０００ノード　　７２６秒<br>　反復深化（広井さんのＣ）　　約２８Ｍノード　　　　　８１秒<br><br>ノード数は、（目安ですが）約２８００倍の差があります。<br>
<blockquote></blockquote>
<hr>

<h3>98.Re.Ｐｒｏｌｏｇ：変形三角盤（ペグソリティア）
 </h3>投稿者:M.Hiroi - 2000年 11月 20日 21時 20分 00秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; やっと、Prologで変形三角盤（ペグソリティア）が解けました。<br>&gt; 
探索方式は幅優先探索（双方向）で、約１２分かかりました。<br><br>それは凄いです！ たしか、deepgreen さんのＰＣは Pentium 133 
MHz<br>だったと思いますが、それで１２分というのは、そうとうに速いのでは<br>ないですか。ぜひ、プログラムを拝見したいものです。<br><br>&gt; 
反復深化もトライしていますが、時間的にちょっと無理のようです。<br>&gt; Prologのデバッグは大変でこちらはまだ解けていません。<br>&gt; 
うまい方法があればアドバイスをお願いしたいなぁ。。。<br><br>私も挑戦してみますね。うまい方法が見つればいいのですが、<br>力及ばずギブアップするかもしれません。<br>今のところ、盤面の操作はビット演算かな、という方向で<br>考えています（笑）。Prolog 
好きの方は、チャレンジして<br>みてください。<br>
<blockquote></blockquote>
<hr>

<h3>97.Ｐｒｏｌｏｇ：変形三角盤（ペグソリティア）
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 19日 23時 44分 22秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>こんばんは、deepgreenです。<br><br>やっと、Prologで変形三角盤（ペグソリティア）が解けました。<br>探索方式は幅優先探索（双方向）で、約１２分かかりました。<br><br>反復深化もトライしていますが、時間的にちょっと無理のようです。<br>Prologのデバッグは大変でこちらはまだ解けていません。<br>うまい方法があればアドバイスをお願いしたいなぁ。。。<br>
<blockquote></blockquote>
<hr>

<h3>96.re^2:白黒ｎ個ずつの蛙跳びゲーム
 </h3>投稿者:M.Hiroi - 2000年 11月 16日 00時 10分 59秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; 
わかってしまえば、簡単な手順ですけど、なかなかそこまではいけない。<br><br>西山氏の移動手順を見ると簡単なように思えますが、自分で考えるとなると、<br>なかなか難しいことですね。まあ、そこがパズルの面白いところなのでしょ<br>うが、自力で解けないとやっぱりくやしいですね（笑）。<br><br>&gt; 
Ｐｒｏｌｏｇでペグソリチア（３）をやって遊ばれてます。（なかなか<br>&gt; 
うまくいかないけど、こちらの方ははなんとかしたい。。。）<br><br>うーん、変形三角盤を Prolog 
で解くのは大変ではないですか。<br>それでも、deepgreen さんなら、なんとかなるかもしれませんね。<br>うまくいったら、教えてください。<br>
<blockquote></blockquote>
<hr>

<h3>95.re:白黒ｎ個ずつの蛙跳びゲーム
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 15日 21時 01分 22秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>こんばんは、deepgreenです。<br><br>広井さん、ありがとうございます。いつもながらすばやいうごきですね。<br>わかってしまえば、簡単な手順ですけど、なかなかそこまではいけない。<br><br>Ｐｒｏｌｏｇでペグソリチア（３）をやって遊ばれてます。（なかなか<br>うまくいかないけど、こちらの方ははなんとかしたい。。。）<br>
<blockquote></blockquote>
<hr>

<h3>94.白黒ｎ個ずつの蛙跳びゲーム
 </h3>投稿者:M.Hiroi - 2000年 11月 13日 19時 43分 36秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>蛙跳びゲームを検索したところ、白黒ｎ個ずつの移動手順を<br>具体的に示し、その手順から移動回数を求めているホームページが<br>ありました。このほかにも、数学関連や数理パズルで面白い<br>ホームページがありましたので、Memorandom 
にて紹介しました。<br>興味のある方はご覧くださいませ。<br>
<blockquote></blockquote>
<hr>

<h3>93.Re.蛙跳びゲームの最短手数は？
 </h3>投稿者:M.Hiroi - 2000年 11月 12日 23時 19分 47秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>deepgreen 
さん、こんばんは。<br><br>&gt; この説明は、もし解が存在する場合にはこうなるといっているだけで、<br>&gt; 
本当に解が存在するかどうかはわからないようにおもいましたが、<br>&gt; 
いかがでしょうか？<br><br>ご指摘ありがとうございます。たしかに、そのとおりだと思います。<br><br>参考文献にあげた「ゲームにひそむ数理」を読み直してみましたが、<br>移動のルールを２つ示して、「それに従えばｎ個ずつのときも確実に<br>成功する」という記述しかなく、ｎ個ずつでも解が存在することを<br>厳密に証明していないように思いました。<br><br>さて、実際に証明するとなると、M.Hiroi 
はお手上げです（笑）。<br>証明できた方は、書き込みよろしくお願いしますね。<br>
<blockquote></blockquote>
<hr>

<h3>92.Re.蛙跳びゲームの最短手数は？
 </h3>投稿者:ｄｅｅｐｇｒｅｅｎ - 2000年 11月 12日 21時 05分 48秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 4.01; Windows 95)<br>メールアドレス：<a 
href="mailto:deepgreen@thn.ne.jp">deepgreen@thn.ne.jp</a><br><br>deepgreenです。<br><br>一言、多いようなきがしますが、この説明は、もし解が存在する場合には<br>こうなるといっているだけで、本当に解が存在するかどうかはわからない<br>ようにおもいましたが、いかがでしょうか？<br>
<blockquote></blockquote>
<hr>

<h3>91.Re.蛙跳びゲームの最短手数は？
 </h3>投稿者:M.Hiroi - 2000年 11月 12日 20時 43分 44秒<br>ブラウザ:Mozilla/4.0 (compatible; 
MSIE 5.0; Windows 95; DigExt)<br>メールアドレス：<a 
href="mailto:m_hiroi@geocities.co.jp">m_hiroi@geocities.co.jp</a><br><br>問題の解答です。<br><br>白黒ｎ個ずつの移動回数は 
ｎ＊ｎ＋２ｎ となります。<br><br>説明は Puzzle DE Programming：蛙飛びゲーム を<br>ご覧くださいませ。<br>
</section>
<div class="small">
<hr>
[ <a href="index.html">Home</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>