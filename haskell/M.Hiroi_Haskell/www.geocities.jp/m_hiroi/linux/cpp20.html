<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881812</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp19.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp21.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>キュー</h3>
<p> 今回は簡単な例題として「キュー (queue)」という基本的なデータ構造を作ってみましょう。なお、標準ライブラリ (Standard Template Library) には &lt;queue&gt; というコンテナアダプタ <sup><a href="cpp20.html#note1">[*1]</a></sup> が用意されています。私たちがキューを作る必要はまったくありませんが、Ｃ++とデータ構造のお勉強ということで、実際にプログラムを作ってみましょう。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> コンテナアダプタとは、内部に他のコンテナを保持して、そのコンテナの一部の機能のみを公開することで、目的の機能を実装するクラスのことです。たとえば、スタックの機能 (FILO : first-in, last-out) は vector で実装できますが、ベクタはどの位置の要素にもアクセスすることができるので、スタックの機能を破壊してしまう恐れがあります。このような機能を制限して、スタックに必要な機能だけを公開するのがアダプタの基本的な考え方です。実際、STL には stack というコンテナアダプタが用意されています。
</div>

<h4>●キューとは？</h4>
<p> 私たちがチケットを買うとき、カウンタの前に並んで順番を待たなくてはいけませんね。キューはカウンタの前に並ぶ行列と考えてください。列の先頭にいる人から順番にチケットを買うことができますが、あとから来た人は列の後ろに並ばなくてはいけません。列の先頭まで進むと、チケットを購入することができます。これを表したのが下図です。
</p>
<pre class="fig">
 out                            in
    ──────────────
&lt;=  A  B  C  D  E  .  .  .  Z    &lt;=
    ──────────────

       図 : キューの動作
</pre>
<p> このように、キューはデータを取り出すときは列の先頭から行い、データを追加するときは列の後ろへ行います。このため、キューは「待ち行列」とか「先入れ先出し (FIFO : first-in, first-out) 」と呼ばれています。
</p>

<h4>●リングバッファよるキューの実装</h4>
<p> キューは配列や連結リスト <sup><a href="cpp20.html#note2">[*2]</a></sup> を使って簡単に実装することができます。配列でキューを実装する場合、先頭位置を示す front と末尾を示す rear を用意し、front と rear の間にあるデータをキューに格納されているデータとするのがポイントです。次の図を見てください。
</p>
<pre class="fig">
           0  1  2  3  4  5  6  7  8  9
rear = 0  ↓
QUEUE    [                              ]  : QUEUE は空
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : データの追加
front= 0  ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 10を取り出す
front= 1     ↑

rear = 3           ↓
QUEUE    [10 20 30                      ]  : 20,30を取り出す
front= 3           ↑

                図 : キューの動作
</pre>
<p> まずキューは空の状態で、rear, front ともに 0 です。データの追加は、rear が示す位置にデータを書き込み、rear の値を +1 します。データ 10, 20, 30 を追加すると、図のようにデータが追加され rear は 3 になります。このとき front は 0 のままなので、先頭のデータは 10 ということになります。
</p>
<p> 次に、データを取り出す場合、front の示すデータを取り出しから front の値を +1 します。この場合、front が 0 なので 10 を取り出して front の値は 1 となり、次のデータ 20 が先頭になります。データを順番に 20, 30 と取り出していくと、3 つしかデータを書き込んでいないので当然キューは空になります。このとき front は 3 になり rear と同じ値になります。このように、front と rear の値が 0 の場合だけが空の状態ではなく、front と rear の値が等しくなると、キューは空になることに注意してください。
</p>
<p> rear, fornt ともに値は増加していく方向なので、いつかは配列の範囲をオーバーします。このため、配列を先頭と末尾がつがっているリング状と考えて、rear, front が配列の範囲を超えたら 0 に戻すことにします。これを「循環配列」とか「リングバッファ」と呼びます。一般に、配列を使ってキューを実装する場合は、リングバッファとするのが普通です。
</p>
<div class="note">
-- note --------<br>
<a name="note2">[*2]</a> 連結リストによるキューの実装方法は、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo02.html">連結リストとキュー</a> で詳しく説明しています。興味のある方は読んでみてください。
</div>
<h4>●クラス Queue の定義</h4>
<p> それでは実際にプログラムを作ってみましょう。クラス名は Queue とします。今回はプログラムを簡単にするため、キューに格納するデータは整数 (int) に限定します。最初に、基本的なメンバ関数を下表に示します。
</p>
<table border=1>
<caption>表 : Queue のメンバ関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>Queue(int n)</td><td>指定した大きさのキューを作る (コンストラクタ)。</td></tr>
  <tr><td>int dequeue()</td><td>キューからデータを取り出して返す。</td></tr>
  <tr><td>void enqueue(int x)</td><td>キューにデータを追加する。</td></tr>
  <tr><td>int peek_front()</td><td>キューの先頭データを返す。</td></tr>
  <tr><td>bool empty()</td><td>キューが空の場合は true を、そうでなければ false を返す。</td></tr>
  <tr><td>bool full()</td><td>キューが満杯の場合は true を、そうでなければ false を返す。</td></tr>
  <tr><td>int size()</td><td>キューに格納されたデータ数を返す。</td></tr>
  <tr><td>void clear()</td><td>キューを空にする。</td></tr>
</tbody>
</table>
<p> 次はクラス Queue を定義します。
</p>
<pre class="list">
リスト : Queue の定義

class Queue {
  int front, rear, count, limit;
  int *buff;
  // コンストラクタと代入演算子は無効化
  Queue(const Queue&amp;);
  Queue&amp; operator=(const Queue&amp;);
public:
  explicit Queue(int n) :
    front(0), rear(0), count(0), limit(n), buff(new int [n]) {}
  ~Queue() { delete[] buff; }
  void enqueue(int);
  int dequeue();
  int peek_front() const;
  void clear();
  int size() const { return count; }
  bool empty() const { return !count; }
  bool full() const { return count == limit; }
};
</pre>
<p> メンバ変数 count はキューに格納されたデータ数をカウントします。この変数を用意することで、キューの状態を簡単にチェックすることができます。buff がキューの本体 (配列) です。メモリの取得はコンストラクタで行います。大きさはメンバ変数 limit に格納します。今回は簡単な例題なので、コピーコンストラクタと代入演算子の処理は無効化しておきます。
</p>
<h4>●データの挿入</h4>
<p> 次はデータを追加するメンバ関数 enqueue() を作ります。
</p>
<pre class="list">
リスト : キューにデータを追加する

void Queue::enqueue(int x)
{
  if (full()) throw runtime_error("Queue::enqueue overflow");
  buff[rear++] = x;
  count++;
  if (rear == limit) rear = 0;
}
</pre>
<p> 最初にメンバ関数 full() を呼び出してキューが満杯かチェックします。full() は count と limit が等しいかチェックするだけです。キューが満杯であれば、enqueue() は例外を送出します。データは rear の位置に格納し、count と rear の値を更新します。rear の値が buff の範囲を超えたならば 0 に戻します。
</p>

</pre>
<h4>●データの取り出し</h4>
<p> 次は、キューからデータを取り出す関数 dequeue() を作ります。
</p>
<pre class="list">
リスト : キューからデータを取り出す

int Queue::dequeue()
{
  if (empty()) throw runtime_error("Queue::dequeue underflow");
  int x = buff[front++];
  count--;
  if (front == limit) front = 0;
  return x;
}
</pre>
<p> まず、メンバ関数 empty() を呼び出してキューにデータがあるかチェックします。empty() は count が 0 かチェックするだけです。キューが空の場合、dequeue() は例外を送出します。データがある場合は buff[front] の位置にあるデータを取り出して返します。あとは、front と count の値を更新し、front の値が buff の範囲を超えたら 0 に戻します。
</p>
<p> あとの操作関数は簡単なので説明は割愛します。詳細は <a href="cpp20.html#list1">プログラムリスト1</a> をお読みくださいませ。
</p>
<h4>●実行例</h4>
<p> これでプログラムは完成です。それでは、簡単な実行例を示しましょう。
</p>
<pre class="list">
リスト : 簡単なテスト

int main()
{
  Queue q(10);
  for (int i = 0; i &lt; 5; i++) q.enqueue(i);
  cout &lt;&lt; q.empty() &lt;&lt; endl;
  cout &lt;&lt; q.full() &lt;&lt; endl;
  cout &lt;&lt; q.size() &lt;&lt; endl;
  while (!q.empty()) cout &lt;&lt; q.dequeue() &lt;&lt; " ";
  cout &lt;&lt; endl;
  int j = 10;
  while (!q.full()) q.enqueue(j++);
  while (!q.empty()) cout &lt;&lt; q.dequeue() &lt;&lt; " ";
  cout &lt;&lt; endl;
}  
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0
0
5
0 1 2 3 4 
19 18 17 16 15 14 13 12 11 10 
10 11 12 13 14 15 16 17 18 19 
</pre>
<p> コンストラクタでキューを作成して変数 q にセットします。for ループでキューにデータを 5 個セットします。size() の返り値は 5 で、empty() と full() の返り値はどちらも 0 (false) です。次に、while ループでキューにデータがある間、dequeue() でデータを取り出します。先に入れたデータから順番に取り出されていることがわかります。
</p>
<p> 最後にデータを 10 個追加します。これでキューは満杯になるので、これ以上データを追加することはできません。full() の返り値は 1 (true) になります。次に、dequeue でデータを取り出します。これでキューは空の状態になります。
</p>
<h4>●ディーキュー (deque)</h4>
<p> もう一つ簡単な例題として「deque (double ended queue)」というデータ構造を作ってみましょう。deque は「両端キュー」のことで、「デック」とか「ディーキュー」と呼ばれています。キューの場合、データの追加は末尾に、データの取り出しは先頭に対してのみ行えます。これに対しディーキューは、先頭および末尾のどちらでもデータの追加と取り出しが行えるデータ構造です。
</p>
<p> ディーキューは双方向リストやリングバッファを使って簡単に実装することができます。今回はリングバッファを使ってプログラムを作ってみましょう。なお、Ｃ++の STL には &lt;deque&gt; という vector に両端キューの機能を追加したコンテナクラスが用意されています。私たちが deque を作る必要はまったくありませんが、Ｃ++とデータ構造のお勉強ということで、実際にプログラムを作ってみましょう。
</p>

<h4>●ディーキューの定義</h4>
<p> クラス名は Deque とします。今回はプログラムを簡単にするため、ディーキューに格納するデータは整数 (int) に限定します。最初に、基本的なメンバ関数を下表に示します。
</p>
<table border=1>
<caption>表 : ディーキューのメンバ関数</caption>
<thead>
  <tr><th>メンバ関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>void push_front(int x)</td><td>先頭にデータを追加する</td></tr>
  <tr><td>void push_back(int x)</td><td>末尾にデータを追加する</td></tr>
  <tr><td>void pop_front() </td><td>先頭からデータを取り出す</td></tr>
  <tr><td>void pop_back() </td><td>末尾からデータを取り出す</td></tr>
  <tr><td>int peek_front() </td><td>末尾にあるデータを求める</td></tr>
  <tr><td>int peek_back() </td><td>先頭にあるデータを求める</td></tr>
  <tr><td>int size() </td><td>ディーキューの要素数を返す</td></tr>
  <tr><td>bool empty() </td><td>ディーキューが空ならば true を返す</td></tr>
  <tr><td>bool full() </td><td>ディーキューが満杯ならば true を返す</td></tr>
  <tr><td>void clear() </td><td>ディーキューを空にする</td></tr>
</tbody>
</table>
<p> 先頭にデータを追加する push_front(), 末尾からデータを取り出す pop_back(), 末尾要素を参照する peek_back() を追加します。それから、STL (deque) のまねをして、添字演算子 [] で要素にアクセスできるようにしてみましょう。
</p>
<p> クラス Deque の定義は次のようになります。
</p>
<pre class="list">
リスト : クラス Deque の定義

class Deque {
  int front, rear, count, limit;
  int *buff;
  // コンストラクタと代入演算子は無効化
  Deque(const Deque&amp;);
  Deque&amp; operator=(const Deque&amp;);
public:
  explicit Deque(int n) :
    front(0), rear(0), count(0), limit(n), buff(new int [n]) {}
  ~Deque() { delete[] buff; }
  void push_front(int);
  void pop_front();
  void push_back(int);
  void pop_back();
  int peek_front() const;
  int peek_back() const;
  void clear();
  int size() const { return count; }
  bool empty() const { return !count; }
  bool full() const { return count == limit; }
  int&amp; operator[](int);
};
</pre>

<h4>●データの挿入</h4>
<p> 次はデータを挿入する push_front() と push_back() を作ります。
</p>
<pre class="list">
リスト : データの挿入

void Deque::push_front(int x)
{
  if (full()) throw runtime_error("Deque::push_front overflow");
  if (front == 0) front = limit;
  buff[--front] = x;
  count++;
}

void Deque::push_back(int x)
{
  if (full()) throw runtime_error("Deque::push_back overflow");
  buff[rear++] = x;
  count++;
  if (rear == limit) rear = 0;
}
</pre>
<p> push_front() の場合、先頭データの位置は front なので、front - 1 の位置にデータを書き込みます。最初に front が 0 ならば limit に更新しておいて、buff[--front] に引数 x をセットします。そして、count を + 1 します。push_back() は Queue のメンバ関数 enqueue() と同じです。
</p>
<h4>●データの削除</h4>
<p> 次はディーキューからデータを削除するメンバ関数 pop_front() と pop_back() を作ります。
</p>
<pre class="list">
リスト : データの削除

void Deque::pop_front()
{
  if (empty()) throw runtime_error("Deque::pop_front underflow");
  front++;
  count--;
  if (front == limit) front = 0;
}

void Deque::pop_back()
{
  if (empty()) throw runtime_error("Deque::pop_back underflow");
  rear--;
  count--;
  if (rear &lt; 0) rear = limit - 1;
}
</pre>
<p> pop_front() は Queue のメンバ関数 dequeue() とほぼ同じです。pop_back() は末尾データを取り除きます。末尾データは rear - 1 の位置にあるので、rear と count を -1 するだけです。rear が 0 よりも小さくなったら、buff の末尾の位置 (limit - 1) に書き換えます。
</p>
<h4>●データの参照</h4>
<p> 次は先頭データと末尾データを返すメンバ関数 peek_front() と peek_back() を作ります。
</p>
<pre class="list">
リスト : データの参照

int Deque::peek_front() const
{
  if (empty()) throw runtime_error("Deque::peek_front underflow");
  return buff[front];
}

int Deque::peek_back() const
{
  if (empty()) throw runtime_error("Deque::peek_back underflow");
  if (rear == 0) return buff[limit - 1];
  return buff[rear - 1];
}
</pre>
<p> peek_front() は Queue のメンバ関数と同じです。peek_back() は rear - 1 の位置にある要素を返します。ただし、rear が 0 の場合は buff の末尾にある要素 (buff[limit - 1]) を返します。
</p>
<h4>●添字演算子の多重定義</h4>
<p> 最後に、添字演算子を多重定義します。
</p>
<pre class="list">
リスト : 添字演算子

int&amp; Deque::operator[](int n)
{
  if (n &lt; 0 || n &gt;= count) throw runtime_error("Deque out of range");
  return buff[(front + n) % limit];
}
</pre>
<p> 引数 n が 0 未満または count 以上の場合、要素は存在しないので例外を送出します。そうでなければ、先頭から n 番目の要素を返します。先頭要素は front の位置にあるので、要素の位置は (front + n) % limit で求めることができます。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="cpp20.html#list2">プログラムリスト２</a> をお読みください。
</p>
<h4>●簡単なテスト</h4>
<p> これでプログラムは完成です。それでは実際に試してみましょう。
</p>
<pre class="list">
リスト : 簡単なテスト

int main()
{
  Deque q(10);
  for (int i = 0; i &lt; 5; i++) q.push_back(i);
  cout &lt;&lt; q.empty() &lt;&lt; endl;
  cout &lt;&lt; q.full() &lt;&lt; endl;
  cout &lt;&lt; q.size() &lt;&lt; endl;
  while (!q.empty()) {
    cout &lt;&lt; q.peek_front() &lt;&lt; " ";
    q.pop_front();
  }
  cout &lt;&lt; endl;
  int j = 10;
  while (!q.full()) q.push_front(j++);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; q[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
  while (!q.empty()) {
    cout &lt;&lt; q.peek_back() &lt;&lt; " ";
    q.pop_back();
  }
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0
0
5
0 1 2 3 4 
19 18 17 16 15 14 13 12 11 10 
10 11 12 13 14 15 16 17 18 19 
</pre>
<p> コンストラクタでディーキューを作成して変数 q にセットします。for ループでディーキューにデータを 5 個 push_back() で追加します。size() の返り値は 5 で、empty() と full() の返り値はどちらも 0 (false) です。次に、while ループでディーキューにデータがある間、push_front() でデータを取り出します。この場合、キューと同じ動作になり、先に入れたデータから順番に取り出されていることがわかります。
</p>
<p> 最後にデータを 10 個 push_front() で追加します。これでディーキューは満杯になるので、これ以上データを追加することはできません。次の for ループで 0 番目から 9 番目の要素を表示します。すると、データを追加した順番とは逆に表示されます。先頭にデータを追加しているので、スタックと同じ動作になるわけです。最後に、while ループでディーキューが空になるまで、データを取り出して表示します。pop_back() で末尾からデータを取り出すと、キューと同じ動作になります。
</p>
<h4>●コンテナ deque の使い方</h4>
<p> ご参考までに、STL に用意されている deque の使い方を簡単に説明します。deque は vector にメンバ関数 push_front(), pop_front(), front() を追加したコンテナクラスと考えてください。これらの操作は定数時間 (O(1)) で行うことができます。それ以外は vector とほとんど同じです。ただし、vector と違って配列本体のメモリ領域は連続して確保されているとは限りません。要素へのポインタや参照を使う場合は注意が必要です。
</p>
<p> 簡単な使用例を示しましょう。
</p>
<pre class="list">
リスト : deque の使用例

#include &lt;iostream&gt;
#include &lt;deque&gt;
using namespace std;

int main()
{
  deque&lt;int&gt; a;
  for (int i = 0; i &lt; 10; i++) a.push_front(i);
  for (auto iter = a.begin(); iter != a.end(); ++iter)
    cout &lt;&lt; *iter &lt;&lt; " ";
  cout &lt;&lt; endl;
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a.front() &lt;&lt; " ";
    a.pop_front();
  }
  cout &lt;&lt; endl;
  for (int i = 0; i &lt; 10; i++) a.push_back(i);
  for (int i = 0; i &lt; 10; i++) {
    cout &lt;&lt; a.front() &lt;&lt; " ";
    a.pop_front();
  }
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
9 8 7 6 5 4 3 2 1 0 
9 8 7 6 5 4 3 2 1 0 
0 1 2 3 4 5 6 7 8 9 
</pre>
<p> push_front() と pop_front() を使えばスタックと同じ動作になり、push_back() と pop_front() を使えばキューと同じ動作になります。
</p>
<h4>●アダプタ queue の使い方</h4>
<p> 最後に、STL のコンテナアダプタ queue の使い方を簡単に説明します。queue はデフォルトでコンテナクラスに deque を使います。主なメンバ関数を下表に示します。
</p>
<table border=1>
<caption>表 : queue&lt;T&gt; の主なメンバ関数</caption>
<thead>
  <tr><th>メンバ関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>T&amp; front()</td><td>先頭要素への参照を返す</td></tr>
  <tr><td>T&amp; back()</td><td>末尾要素への参照を返す</td></tr>
  <tr><td>void pop()</td><td>先頭要素を削除する</td></tr>
  <tr><td>void push(const T&amp; x)</td><td>キューの末尾にデータ x を追加する</td></tr>
  <tr><td>bool empty()</td><td>キューが空の時に true を返す</td></tr>
  <tr><td>size_type size()</td><td>キューの要素数を返す</td></tr>
</tbody>
</table>
<p> size_type は STL の中で定義されているデータ型で配列の要素数を表すための値 (無符号整数) です。メンバ関数の使い方は、今まで説明したキューやディーキューとほとんど同じです。
</p>
<p> 簡単な使用例を示しましょう。
</p>
<pre class="list">
リスト : queue の簡単な使用例

#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main()
{
  queue&lt;int&gt; q0;
  for (int i = 0; i &lt; 10; i++) q0.push(i);
  while (!q0.empty()) {
    cout &lt;&lt; q0.front() &lt;&lt; " ";
    q0.pop();
  }
  cout &lt;&lt; endl;
  queue&lt;double&gt; q1;
  for (int i = 0; i &lt; 10; i++) q1.push(i + 0.12345);
  while (!q1.empty()) {
    cout &lt;&lt; q1.front() &lt;&lt; " ";
    q1.pop();
  }
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 8 9 
0.12345 1.12345 2.12345 3.12345 4.12345 5.12345 6.12345 7.12345 8.12345 9.12345 
</pre>
<p> 今回はここまでです。次回は C++11 で導入された「右辺値参照 (rvalue reference)」と unique_ptr というスマートポインタについて説明します。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
//
// queue.cpp : キュー
//
//             Copyright (C) 2015 Makoto Hiroi
//
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

class Queue {
  int front, rear, count, limit;
  int *buff;
  // コンストラクタと代入演算子は無効化
  Queue(const Queue&amp;);
  Queue&amp; operator=(const Queue&amp;);
public:
  explicit Queue(int n) :
    front(0), rear(0), count(0), limit(n), buff(new int [n]) {}
  ~Queue() { delete[] buff; }
  void enqueue(int);
  int dequeue();
  int peek_front() const;
  void clear();
  int size() const { return count; }
  bool empty() const { return !count; }
  bool full() const { return count == limit; }
};

// データの挿入
void Queue::enqueue(int x)
{
  if (full()) throw runtime_error("Queue::enqueue overflow");
  buff[rear++] = x;
  count++;
  if (rear == limit) rear = 0;
}

// データの取り出し
int Queue::dequeue()
{
  if (empty()) throw runtime_error("Queue::dequeue underflow");
  int x = buff[front++];
  count--;
  if (front == limit) front = 0;
  return x;
}

int Queue::peek_front() const
{
  if (empty()) throw runtime_error("Queue::peek_front underflow");
  return buff[front];
}

// クリア
void Queue::clear()
{
  front = rear = count = 0;
}

int main()
{
  Queue q(10);
  for (int i = 0; i &lt; 5; i++) q.enqueue(i);
  cout &lt;&lt; q.empty() &lt;&lt; endl;
  cout &lt;&lt; q.full() &lt;&lt; endl;
  cout &lt;&lt; q.size() &lt;&lt; endl;
  while (!q.empty()) cout &lt;&lt; q.dequeue() &lt;&lt; " ";
  cout &lt;&lt; endl;
  int j = 10;
  while (!q.full()) q.enqueue(j++);
  while (!q.empty()) cout &lt;&lt; q.dequeue() &lt;&lt; " ";
  cout &lt;&lt; endl;
}  
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
//
// deque.cpp : ディーキュー
//
//             Copyright (C) 2015 Makoto Hiroi
//
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

class Deque {
  int front, rear, count, limit;
  int *buff;
  // コンストラクタと代入演算子は無効化
  Deque(const Deque&amp;);
  Deque&amp; operator=(const Deque&amp;);
public:
  explicit Deque(int n) :
    front(0), rear(0), count(0), limit(n), buff(new int [n]) {}
  ~Deque() { delete[] buff; }
  void push_front(int);
  void pop_front();
  void push_back(int);
  void pop_back();
  int peek_front() const;
  int peek_back() const;
  void clear();
  int size() const { return count; }
  bool empty() const { return !count; }
  bool full() const { return count == limit; }
  int&amp; operator[](int);
};

// データの挿入
void Deque::push_front(int x)
{
  if (full()) throw runtime_error("Deque::push_front overflow");
  if (front == 0) front = limit;
  buff[--front] = x;
  count++;
}

void Deque::push_back(int x)
{
  if (full()) throw runtime_error("Deque::push_back overflow");
  buff[rear++] = x;
  count++;
  if (rear == limit) rear = 0;
}

// データの取り出し
void Deque::pop_front()
{
  if (empty()) throw runtime_error("Deque::pop_front underflow");
  front++;
  count--;
  if (front == limit) front = 0;
}

void Deque::pop_back()
{
  if (empty()) throw runtime_error("Deque::pop_back underflow");
  rear--;
  count--;
  if (rear &lt; 0) rear = limit - 1;
}

int Deque::peek_front() const
{
  if (empty()) throw runtime_error("Deque::peek_front underflow");
  return buff[front];
}

int Deque::peek_back() const
{
  if (empty()) throw runtime_error("Deque::peek_back underflow");
  if (rear == 0) return buff[limit - 1];
  return buff[rear - 1];
}

// クリア
void Deque::clear()
{
  front = rear = count = 0;
}

int&amp; Deque::operator[](int n)
{
  if (n &lt; 0 || n &gt;= count) throw runtime_error("Deque out of range");
  return buff[(front + n) % limit];
}

int main()
{
  Deque q(10);
  for (int i = 0; i &lt; 5; i++) q.push_back(i);
  cout &lt;&lt; q.empty() &lt;&lt; endl;
  cout &lt;&lt; q.full() &lt;&lt; endl;
  cout &lt;&lt; q.size() &lt;&lt; endl;
  while (!q.empty()) {
    cout &lt;&lt; q.peek_front() &lt;&lt; " ";
    q.pop_front();
  }
  cout &lt;&lt; endl;
  int j = 10;
  while (!q.full()) q.push_front(j++);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; q[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
  while (!q.empty()) {
    cout &lt;&lt; q.peek_back() &lt;&lt; " ";
    q.pop_back();
  }
  cout &lt;&lt; endl;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp19.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp21.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>