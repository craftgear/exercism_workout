<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881812</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp16.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp18.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>テンプレートの基礎知識</h3>
<p> 初心者 (M.Hiroi を含む) にとって、Ｃ++は大変難しいプログラミング言語ですが、そのなかで M.Hiroi が興味を持っている機能に「テンプレート (template)」があります。最初にテンプレートを見たときは、ただでさえ複雑なＣ++に新しい機能がまた追加されるのか、とうんざりしたものです。ところが、実際に試してみると、これがとても便利な機能なのです。
</p>
<p> 一般的なオブジェクト指向言語は「クラス (class)」が中心で、再利用性を高めるためにもクラスの設計がとても重要になります。ところが、初心者にとってクラスを適切に設計することは大変荷の重い作業です。これにＣ++特有の複雑な機能が加わるため、Ｃ++のメリットを実感できない方もいるのではないでしょうか。
</p>
<p> テンプレートの場合、クラスの設計といった難しいことをあまり意識しなくても、プログラムの再利用が可能になります。それに、テンプレートの基本的な機能はそれほど難しくはないので、M.Hiroi のようなＣ++初心者でもその恩恵を受けることができるのではないか、と思っております。
</p>
<p> このように書くと、エキスパートの方から怒られてしまうかもしれませんね。テンプレートは高度で複雑な機能なので、難しいところがあるのは事実です。ですが、基本的な機能であれば、初心者でも理解することができますし、標準ライブラリ (Standard Template Library : STL) も簡単に使うことができるようになります。とりあえず難しいところはおいといて、基本的なところからゆっくりと勉強していきましょう。
</p>

<h4>●テンプレートの定義</h4>
<p> テンプレートの基本的な考え方は簡単です。クラスや関数の定義するとき、メンバ変数や関数の引数 (返り値) にデータ型を指定しますが、これをパラメータ化できるようにしたものがテンプレートです。テンプレートを定義するとき、関数の仮引数のようにデータ型を受け取るパラメータを指定します。これを「テンプレートパラメータ」とか「テンプレート仮引数」と呼びます。
</p>
<p> 実際に使用するときはデータ型をテンプレートに渡します。関数を呼び出すときに渡す実引数のように、これを「テンプレート実引数」といいます。すると、そのデータ型に合わせたクラスや関数が生成されます。これにより、一つのプログラムでいろいろなデータ型に対応することが可能になります。<sup><a href="cpp17.html#note1">[*1]</a></sup> 
</p>
<p> テンプレートの定義はキーワード template を使います。テンプレートの構文を示します。
</p>
<ol>
  <li>template &lt;class 名前, ...&gt; クラス定義;
  <li>template &lt;class 名前, ...&gt; 関数定義
</ol>
<p> template の後ろの &lt; &gt; の中に "class 名前" を指定します。この名前がテンプレート仮引数になります。テンプレート仮引数は複数指定することができます。名前の前に class が付いていますが、クラスに限定する意味はなく、テンプレート実引数には int や double など基本的なデータ型も指定することができます。
</p>
<p> class のほかに typename というキーワードを使うこともできます。基本的には、class と typename に大きな違いはないのですが、複雑なテンプレートを定義するとき typename が必要になる場合があります。とりあえず、本稿では class を使うことにしましょう。
</p>
<p> また、class (or typename) のかわりに、int や double などのデータ型を指定することもできます。その場合、テンプレート実引数にはデータ型の値 (整数や浮動小数点数など) を渡すことになります。
</p>
<p> 1 のようにテンプレートで定義されたクラスを「クラステンプレート」といい、テンプレートから生成されたクラスを「テンプレートクラス」といいます。2 のようにテンプレートで定義された関数を「関数テンプレート」といい、テンプレートから生成された関数を「テンプレート関数」といいます。クラス定義や関数定義の中で、テンプレート仮引数はデータ型として使用することができます。
</p>

<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> SML/NJ や OCaml などの関数型言語でも、データ型をパラメータ化することができます。これを「型変数」といい、いろいろなデータ型に対応できる関数のことを「多相型関数」といいます。これらの言語には「型推論」という機能があり、プログラマがデータ型を宣言する必要はほとんどありません。
</div>

<h4>●クラステンプレート</h4>
<p> それでは実際にテンプレートでクラスを定義してみましょう。まず最初に、テンプレートを使わないでクラスを定義します。
</p>
<pre class="list">
リスト : クラス Foo の定義

#include &lt;iostream&gt;
using namespace std;

class Foo {
  int x;
public:
  Foo() : x(0) {}
  Foo(int n) : x(n) {}
  int get_x() const { return x; }
  void put_x(int n) { x = n; }
};

int main()
{
  Foo a;
  cout &lt;&lt; a.get_x() &lt;&lt; endl;
  a.put_x(10);
  cout &lt;&lt; a.get_x() &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0
10
</pre>
<p> クラス Foo は int 型の整数を格納します。テンプレートを使うと、int 型だけではなく他のデータ型を格納するクラスを簡単に作ることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : クラステンプレート

#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt; class Foo {
  T x;
public:
  Foo() : x(T()) {}
  Foo(T n) : x(n) {}
  T get_x() const { return x; }
  void put_x(T n) { x = n; }
};

int main()
{
  Foo&lt;int&gt; a;
  cout &lt;&lt; a.get_x() &lt;&lt; endl;
  a.put_x(10);
  cout &lt;&lt; a.get_x() &lt;&lt; endl;
  Foo&lt;double&gt; b;
  cout &lt;&lt; b.get_x() &lt;&lt; endl;  
  b.put_x(1.2345);
  cout &lt;&lt; b.get_x() &lt;&lt; endl;
  Foo&lt;string&gt; c;
  cout &lt;&lt; "[" &lt;&lt; c.get_x() &lt;&lt; "]" &lt;&lt; endl;  
  c.put_x("hello, world");
  cout &lt;&lt; c.get_x() &lt;&lt; endl;
}
</pre>
<p> ここでは仮引数名を T としました。仮引数名は 1 文字にする必要はありません。わかりやすい名前を付けたほうが良いでしょう。一般的には、名前の先頭を英大文字にすることが多いようです。
</p>
<p> 仮引数名 T は Foo の中で参照することができます。具体的には、int のかわりに T を使ってプログラムを記述するだけです。メンバ変数の宣言は int x から T x に書き換えます。メンバ関数の定義も int get_x() を T get_x() に、void put_x(int n) を void put_x(T n) に書き換えます。
<p> コンストラクタも同様に書き換えます。デフォルトコンストラクタの場合、T() と記述することでデータ型 T のデフォルトコンストラクタを呼び出して、メンバ変数 x を初期化することができます。これは基本的なデータ型でも大丈夫です。たとえば int() は 0 を返し、double() は 0.0 を返します。string() は空文字列を返します。
</p>
<p> テンプレートから実際のクラスとインスタンスを生成する場合は次のように宣言します。
</p>
<pre class="item">
テンプレート名&lt;テンプレート引数, ...&gt; 変数名;
テンプレート名&lt;テンプレート引数, ...&gt; 変数名(引数, ...);
</pre>
<p> テンプレート名の後ろの &lt; &gt; の中にテンプレート実引数を指定します。データ型は "テンプレート名&lt;テンプレート実引数, ...&gt;" になります。テンプレートが同じでも、異なる実引数を与えれば、別のデータ型として扱われます。
</p>
<p> main() で Foo&lt;int&gt; a; とすれば、変数 a に int を格納する Foo のインスタンスが生成されます。Foo&lt;double&gt; b; とすれば、変数 b に double を格納する Foo のインスタンスが生成され、Foo&lt;string&gt; c; とすれば、変数 c に string を格納する Foo のインスタンスが生成されます。

<p> それでは実行してみましょう。
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0
10
0
1.2345
[]
hello, world
</pre>
<p> 変数 a, b, c のインスタンスはデフォルトコンストラクタによって初期化されるので、メンバ変数の値は 0, 0.0, "" になります。そのあと、メンバ関数 put_x() で値を書き換え、その値を get_x() で取り出して表示します。このように、一つのテンプレートで複数のデータ型に対応するプログラムを作ることができます。
</p>
<h4>●関数テンプレート</h4>
<p> 次は関数テンプレートを作ってみましょう。簡単な例として、クイックソートを取り上げます。次のリストを見てください。
</p>
<pre class="list">
リスト : クイックソート

#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
void qsort_sub(T buff[], int low, int high)
{
  T pivot = buff[low + (high - low) / 2];
  int i = low;
  int j = high;
  while (true) {
    while (pivot &gt; buff[i]) i++;
    while (pivot &lt; buff[j]) j--;
    if (i &gt;= j) break;
    T temp = buff[i];
    buff[i] = buff[j];
    buff[j] = temp;
    i++;
    j--;
  }
  if (low &lt; i - 1) qsort_sub(buff, low, i - 1);
  if (high &gt; j + 1) qsort_sub(buff, j + 1, high);
}

template&lt;class T&gt;
void quick_sort(T buff[], int size)
{
  qsort_sub(buff, 0, size - 1);
}

template&lt;class T&gt;
void print_buffer(T buff[], int size)
{
  for (int i = 0; i &lt; size; i++)
    cout &lt;&lt; buff[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
}

int main()
{
  int a[10] = {5, 6, 4, 7, 3, 8, 2, 9, 1, 0};
  quick_sort(a, 10);
  print_buffer(a, 10);
  double b[10] = {5.5, 6.6, 4.4, 7.7, 3.3, 8.8, 2.2, 9.9, 1.1, 0};
  quick_sort(b, 10);
  print_buffer(b, 10);
}
</pre>
<p> 関数をテンプレートで定義する場合も template から始まります。その次に、&lt; &gt; の中に 1 個以上のテンプレート仮引数を指定するのも同じです。あとは普通の関数と同じように定義します。関数を呼び出すときは関数名の後ろに &lt; &gt; を付けて、そこにテンプレート実引数を指定します。
</p>
<pre class="item">
関数名&lt;テンプレート実引数, ...&gt;(引数, ...);
</pre>
<p> ただし、関数に渡す引数のデータ型などによってテンプレート実引数のデータ型が決定できる場合、テンプレート実引数の指定を省略することができます。関数 quick_sort, qsort_sub, print_buffer は関数の仮引数 buff のデータ型が T であり、関数の実引数として与えられるデータ型から、テンプレート実引数として渡されるデータ型を決定することができます。この場合、テンプレート実引数を省略して、通常の関数のように呼び出すことができます。
</p>
<p> main() で quick_sort を呼び出すところが 2 か所ありますが、最初の quick_sort は引数の型が int なので、パラメータ T を int に置き換えた関数が生成されます。次の quick_sort の場合は T を double に置き換えた関数が生成されます。Ｃ++は関数を多重定義できるので、このような芸当が可能になるのです。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 8 9 
0 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 
</pre>

<h4>●Pair の作成</h4>
<p> それでは簡単な例題として、2 つの異なるデータ型を格納する構造体 Pair をテンプレートで作成してみましょう。Ｃ++の構造体はクラスと同様にテンプレートを使って定義することができます。なお、Ｃ++の標準ライブラリには pair という同等の機能を持つテンプレートが用意されていますが、Ｃ++のお勉強ということで、実際にプログラムを作ってみましょう。
</p>

<pre class="list">
リスト : Pair テンプレート

#include &lt;iostream&gt;
using namespace std;

template&lt;class T, class U&gt; struct Pair {
  T fst;
  U snd;
  Pair() : fst(T()), snd(U()) { }
  Pair(T x, U y) : fst(x), snd(y) { }
  // 出力演算子の多重定義
  friend ostream&amp; operator&lt;&lt;(ostream&amp; output, const Pair&amp; p) {
    output &lt;&lt; "(" &lt;&lt; p.fst &lt;&lt; "," &lt;&lt; p.snd &lt;&lt; ")";
    return output;
  }
};

int main()
{
  Pair&lt;string,int&gt; a("hello", 10);
  cout &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; a.fst &lt;&lt; endl;
  cout &lt;&lt; a.snd &lt;&lt; endl;
  a.fst = "world";
  a.snd = 20;
  cout &lt;&lt; a &lt;&lt; endl;
  Pair&lt;int,int&gt; b;
  cout &lt;&lt; b &lt;&lt; endl;
  b.fst = 1;
  b.snd = 2;
  cout &lt;&lt; b &lt;&lt; endl;
  Pair&lt;string, int&gt; c[4] = {
    {string("foo"), 1},
    {string("bar"), 2},
    {string("baz"), 3},
    {string("oops"), 4}
  };
  for (auto x : c) cout &lt;&lt; x &lt;&lt; endl;
}
</pre>
<p> Pair には 2 つの異なるデータ型を格納するので、テンプレート仮引数は T, U の 2 つが必要になります。メンバ変数 fst が T 型のデータを格納し、snd が U 型のデータを格納します。Ｃ++の構造体はデフォルトのアクセス制御が public のクラスとほぼ同じです。クラスと同様に、構造体の中でコンストラクタなどのメンバ関数や friend 関数を定義することができます。メンバ変数は public なのでアクセス関数は定義していません。
</p>
<p> なお、テンプレートで friend 関数を定義する場合、たとえば出力演算子をクラスの中で定義するのは簡単ですが、クラスの外側で定義するときには注意が必要です。これはあとで説明します。
</p>
<p> main() の中で、Pair&lt;string,int&gt; とすると、string と int を格納するインスタンスが生成されます。T と U には同じデータ型を指定してもかまいません。Pair&lt;int,int&gt; とすると、int と int を格納するインスタンスが生成されます。配列に格納する場合、初期値を指定しなければデフォルトコンストラクタで初期化されます。
</p>
<p> テンプレートの型指定は複雑になりがちです。最近の規格 (C++11) では、データ型に auto を指定すると、コンパイラがデータ型を推論してくれるようになりました。最後の for 文では、auto を使わないと変数 x のデータ型 Pair&lt;string,int&gt; を記述しないといけませんが、auto を使えばコンパイラが決めてくれるので簡単です。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
(hello,10)
hello
10
(world,20)
(0,0)
(1,2)
(foo,1)
(bar,2)
(baz,3)
(oops,4)
</pre>

<h4>●テンプレートのデフォルト引数</h4>
<p> テンプレート仮引数には関数のデフォルト引数のようにデフォルトの値を設定することができます。
</p>
<pre class="item">
template &lt;class T = type, ...&gt;
</pre>
<p> 仮引数名の後ろに = を付けて、その後ろにデフォルトのデータ型 (または値) を指定します。 
</p>
<p> それでは簡単な例題として、テンプレートでスタッククラス Stack を作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : stack_t.cpp

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

template&lt;class T = int, int N = 8&gt; class Stack {
  T *buff;
  int sp;
  // コピーコンストラクタと代入演算子の無効化
  Stack(const Stack&amp;);
  Stack&amp; operator=(const Stack&amp;); 
public:
  Stack() : buff(new T [N]), sp(0) { }
  ~Stack() { delete[] buff; }
  bool empty() const { return !sp; }
  bool full() const { return sp == N; }
  void push(T x) {
    if (sp &gt;= N) throw runtime_error("Stack::push overflow");
    buff[sp++] = x;
  }
  T pop() {
    if (sp == 0) throw runtime_error("Stack::pop underfolw");
    return buff[--sp];
  }
};

int main()
{
  Stack&lt;&gt; a;
  for (int i = 0; i &lt; 8; i++) a.push(i);
  while (!a.empty()) cout &lt;&lt; a.pop() &lt;&lt; " ";
  cout &lt;&lt; endl;
  Stack&lt;double, 4&gt; b;
  for (int i = 0; i &lt; 4; i++) b.push(1.2345 + i);
  while (!b.empty()) cout &lt;&lt; b.pop() &lt;&lt; " ";
  cout &lt;&lt; endl;
}
</pre>
<pre>
hiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
7 6 5 4 3 2 1 0 
4.2345 3.2345 2.2345 1.2345 
</pre>
<p> Stack はテンプレート仮引数に T と N を受け取ります。T がスタックに格納するデータ型、N がスタックの大きさです。どちらの引数もデフォルト値が設定されていて、T は int で N が 8 になります。テンプレート引数に整数値が指定されているので、整数値が異なるとデータ型は別なものになります。つまり、Stack&lt;int, 8&gt; と Stack&lt;int, 9&gt; は異なるデータ型として扱われます。ご注意くださいませ。
</p>
<p> なお、今回は簡単な例題なので、コピーコンストラクタと代入演算子を無効化しています。これはプロトタイプを private で宣言するだけです。コピーコンストラクタや代入演算子が必要になる処理はコンパイルでエラーとなります。
</p>
<p> メンバ関数は full(), empty(), push(), pop() の 4 つを用意しました。この中でテンプレート仮引数 N を参照することができます。なお、N に渡すことができるのは整数 (または定数) だけで、変数の値を渡すことはできません。Stack は 2 つの引数がありますが、どちらも省略する場合は Stack&lt;&gt; のように &lt;&gt; を付けてください。&lt;&gt; を省略することはできません。
</p>
<h4>●テンプレートの特殊化</h4>
<p> テンプレートはとても便利な機能ですが、特定のデータ型だけ特別な処理を行いたい場合もあるでしょう。このような場合、汎用的なテンプレートを定義したあと、データ型を指定した特別なテンプレートを定義することで対応することができます。これを「テンプレートの特殊化」といいます。
</p>
<p> テンプレートの特殊化は次のように定義します。
</p>
<pre class="item">
template&lt;class T, ...&gt; class Foo { ... };   // 汎用
template&lt;&gt; class Foo&lt;type, ...&gt; { ... };    // type 専用
</pre>
<p> 最初に汎用のクラステンプレート Foo を定義します。テンプレートを特殊化する場合は、template で指定する仮引数を省略して &lt;&gt; だけを指定し、クラス名の後ろで特定のデータ型を &lt; &gt; の中で指定します。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : テンプレートの特殊化

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

template&lt;class T&gt; class Foo {
  T x;
public:
  Foo() : x(T()) {}
  Foo(T n) : x(n) {}
  void print() const { cout &lt;&lt; x &lt;&lt; endl; }
};

template&lt;&gt; class Foo&lt;double&gt; {
  double x;
public:
  Foo() : x(0) {}
  Foo(double n) : x(n) {}
  void print() const {
    cout &lt;&lt; setprecision(16) &lt;&lt; x &lt;&lt; endl;
  }
};

int main()
{
  Foo&lt;int&gt; a(123);
  Foo&lt;double&gt; b(1.11111111 * 1.11111111);
  Foo&lt;string&gt; c("hello, world");
  a.print();
  b.print();
  c.print();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
123
1.234567898765432
hello, world
</pre>
<p> クラス Foo はデータ型 T を格納し、メンバ関数 print でそれを表示します。print は標準的な方法でデータを表示しますが、double だけ小数点数の桁を増やしたい場合、double 専用のテンプレートを作成します。template&lt;&gt; class Foo&lt;double&gt; とすれば、double に特化したテンプレートになります。あとは、Foo&lt;double&gt; b; と宣言すれば、特殊化したテンプレートが使用されます。それ以外のデータ型は汎用のテンプレートが使用されます。
</p>
<h4>●テンプレートの部分特殊化</h4>
<p> テンプレートの一部分だけを特殊化することもできます。たとえば、テンプレート仮引数が複数ある場合、一部の仮引数を特定のデータ型に指定することができます。次の例を見てください。
</p>
<pre class="list">
リスト : テンプレートの部分特殊化

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

template&lt;class T, class U&gt; struct Pair {
  T fst;
  U snd;
  Pair() : fst(T()), snd(U()) { }
  Pair(T x, U y) : fst(x), snd(y) { }
  // 出力演算子の多重定義
  friend ostream& operator&lt;&lt;(ostream& output, const Pair& p) {
    output &lt;&lt; "(" &lt;&lt; p.fst &lt;&lt; "," &lt;&lt; p.snd &lt;&lt; ")";
    return output;
  }
};

// 部分特殊化
template&lt;class T&gt; struct Pair&lt;T, double&gt; {
  T fst;
  double snd;
  Pair() : fst(T()), snd(0) { }
  Pair(T x, double y) : fst(x), snd(y) { }
  // 出力演算子の多重定義
  friend ostream& operator&lt;&lt;(ostream& output, const Pair& p) {
    output &lt;&lt; "(" &lt;&lt; p.fst &lt;&lt; "," &lt;&lt; setprecision(16) &lt;&lt; p.snd &lt;&lt; ")";
    return output;
  }
};

int main()
{
  Pair&lt;string,double&gt; a("hello", 1.11111111 * 1.11111111);
  cout &lt;&lt; a &lt;&lt; endl;
  Pair&lt;int,double&gt; b(123, 1.11111111 * 1.11111111);
  cout &lt;&lt; b &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
(hello,1.234567898765432)
(123,1.234567898765432)
</pre>
<p> Pair のメンバ変数 snd のデータ型を double に特定します。この場合、テンプレート仮引数は fst のデータ型 T だけ指定して、Pair の後ろでは &lt;T, double&gt; とします。これで、Pair&lt;string, double&gt; a; や Pair&lt;int, double&gt; b; とすると、特殊化したテンプレートが使用されます。
</p>
<p> また、次のようにポインタ型だけ特殊化することも可能です。
</p>
<pre class="list">
リスト : ポインタ型の特殊化

#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt; class Foo {
  T x;
public:
  Foo() : x(T()) {}
  Foo(T n) : x(n) {}
  void print() const { cout &lt;&lt; x &lt;&lt; endl; }
};

template&lt;class T&gt; class Foo&lt;T*&gt; {
  T* x;
public:
  Foo(T* n) : x(n) {}
  void print() const { cout &lt;&lt; *x &lt;&lt; endl; }
};

int main()
{
  Foo&lt;int&gt; a(123);
  a.print();
  int x = 10;
  Foo&lt;int*&gt; b(&x);
  b.print();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
123
10
</pre>
<p> template&lt;class T&gt; class Foo の後ろで &lt;T*&gt; を指定すると、ポインタ型 T* だけを特殊化することができます。たとえば、Foo&lt;int&gt; は汎用のテンプレートが使用されますが、Foo&lt;int*&gt; は特殊化したテンプレートが使用されます。
</p>

<h4>●テンプレート関数の特殊化</h4>
<p> テンプレートクラスと同様に、テンプレート関数も特殊化することができます。
</p>
<pre class="item">
template&lt;class T, ...&gt; 返り値の型 関数名(引数, ...) { 本体 }    // 汎用
template&lt;&gt; 返り値の型 関数名&lt;type, ...&gt;(引数, ...) { 本体 }     // type 専用
</pre>
<p> 最初に汎用の関数テンプレート Foo を定義します。テンプレートを特殊化する場合は、template で指定する仮引数を省略して &lt;&gt; だけを指定し、関数名の後ろで特定のデータ型を &lt; &gt; の中で指定します。なお、関数の引数のデータ型などで type を特定できる場合は、関数名の後ろの &lt;type, ... &gt; を省略することができます。
</p>
<p> たとえば、関数テンプレートで取り上げたクイックソートですが、Ｃスタイル文字列 (const char*) はアドレスを比較してしまうので、ソートすることができません。この場合、次のようにテンプレート関数を特殊化します。。
</p>
<pre class="list">
リスト : テンプレート関数の特殊化

#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

// 汎用
template&lt;class T&gt;
void qsort_sub(T buff[], int low, int high)
{
  T pivot = buff[low + (high - low) / 2];
  int i = low;
  int j = high;
  while (true) {
    while (pivot &gt; buff[i]) i++;
    while (pivot &lt; buff[j]) j--;
    if (i &gt;= j) break;
    T temp = buff[i];
    buff[i] = buff[j];
    buff[j] = temp;
    i++;
    j--;
  }
  if (low &lt; i - 1) qsort_sub(buff, low, i - 1);
  if (high &gt; j + 1) qsort_sub(buff, j + 1, high);
}

template&lt;class T&gt;
void quick_sort(T buff[], int size)
{
  qsort_sub(buff, 0, size - 1);
}

template&lt;class T&gt;
void print_buffer(T buff[], int size)
{
  for (int i = 0; i &lt; size; i++)
    cout &lt;&lt; buff[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
}

// 特殊化
template&lt;&gt;
void qsort_sub(const char* buff[], int low, int high)
{
  const char* pivot = buff[low + (high - low) / 2];
  int i = low;
  int j = high;
  while (true) {
    while (strcmp(pivot, buff[i]) &gt; 0) i++;
    while (strcmp(pivot, buff[j]) &lt; 0) j--;
    if (i &gt;= j) break;
    const char* temp = buff[i];
    buff[i] = buff[j];
    buff[j] = temp;
    i++;
    j--;
  }
  if (low &lt; i - 1) qsort_sub(buff, low, i - 1);
  if (high &gt; j + 1) qsort_sub(buff, j + 1, high);
}

template&lt;&gt;
void quick_sort(const char* buff[], int size)
{
  qsort_sub(buff, 0, size - 1);
}

template&lt;&gt;
void print_buffer(const char* buff[], int size)
{
  for (int i = 0; i &lt; size; i++)
    cout &lt;&lt; buff[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
}

int main()
{
  int a[10] = {5, 6, 4, 7, 3, 8, 2, 9, 1, 0};
  quick_sort(a, 10);
  print_buffer(a, 10);
  const char* b[5] = {
    "foo", "baz", "bar","oops", "abc"
  };
  quick_sort(b, 5);
  print_buffer(b, 5);
}
</pre>
<p> Ｃスタイル文字列は標準ライブラリ &lt;cstring&gt; の関数 strcmp() で比較することができます。これはＣ言語の標準ライブラリ string.h の関数 strcmp() と同じものです。関数 qsort_sub(), quick_sort(), print_buffer() の特殊化は、引数のデータ型から const char* が特定できるので、関数名の後ろにデータ型を指定する必要はありません。あとは、汎用バージョンのパラメータ T のかわりに const char* を指定するだけです。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 8 9 
abc bar baz foo oops 
</pre>

<h4>●テンプレートと高階関数</h4>
<p> テンプレートを使うと、いろいろなデータ型に対応する高階関数を簡単に作成することができます。たとえば、配列の要素に関数を適用する高階関数 for_each は関数テンプレートを使って次のように定義することができます。
</p>
<pre class="list">
リスト : 高階関数 for_each (テンプレート版)

template&lt;class T, class F&gt;
void for_each(T buff[], int size, F func)
{
  for (int i = 0; i &lt; size; i++)
    func(buff[i]);
}
</pre>
<p> テンプレート仮引数 T が配列のデータ型、F が関数の型を表します。for ループで配列の要素を順番に取り出して、関数 func に渡して呼び出すだけです。for_each に渡す関数もテンプレートで定義することができます。
</p>
<pre class="list">
リスト : データの表示

template&lt;class T&gt;
void print(T x) { cout &lt;&lt; x &lt;&lt; " "; }
</pre>
<p> 関数 print はデータ型 T の値を画面に表示します。for_each に渡すときは、関数名の後ろに &lt;データ型&gt; を指定して、テンプレート関数を生成してください。
</p>
<p> それでは実行してみましょう。
<pre class="list">
リスト : for_each の実行例

int main()
{
  int a[8] = {0,1,2,3,4,5,6,7};
  double b[5] = {1.1, 2.2, 3.3, 4.4, 5.5};
  string c[4] = {
    "foo", "bar", "baz", "oops"
  };
  for_each(a, 8, print&lt;int&gt;);
  cout &lt;&lt; endl;
  for_each(b, 5, print&lt;double&gt;);
  cout &lt;&lt; endl;
  for_each(c, 4, print&lt;string&gt;);
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 
1.1 2.2 3.3 4.4 5.5 
foo bar baz oops 
</pre>
<p> 正常に動作していますね。ところで、関数呼び出しができるのは、関数ポインタだけではなく、関数オブジェクトでも可能です。つまり、for_each には関数オブジェクトも渡すことができるのです。次の例を見てください。
</p>
<pre class="list">
リスト : 関数オブジェクトを for_each に渡す

#include &lt;iostream&gt;
using namespace std;

// クラステンプレート
template&lt;class T&gt; class Display {
public:
  void operator()(T x) { cout &lt;&lt; x &lt;&lt; " "; }
};
  
int main()
{
  int a[8] = {0,1,2,3,4,5,6,7};
  double b[5] = {1.1, 2.2, 3.3, 4.4, 5.5};
  string c[4] = {
    "foo", "bar", "baz", "oops"
  };
  for_each(a, 8, Display&lt;int&gt;());
  cout &lt;&lt; endl;
  for_each(b, 5, Display&lt;double&gt;());
  cout &lt;&lt; endl;
  for_each(c, 4, Display&lt;string&gt;());
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 
1.1 2.2 3.3 4.4 5.5 
foo bar baz oops 
</pre>
<p> Display はクラステンプレートです。関数呼び出し演算子 () を定義しているので、Display のインスタンスは関数オブジェクトになります。for_each に渡すときには、Display の後ろに &lt;データ型&gt;() を指定してインスタンスを生成してください。
</p>

<h4>●イテレータと高階関数</h4>
<p> イテレータを使うと、より汎用的な高階関数を作成することができます。たとえば、for_each は次のように定義することができます。
</p>
<pre class="list">
リスト : for_each (イテレータ版)

template&lt;class T, class F&gt;
void for_each(T buff, F func)
{
  for (auto iter = buff.begin(); iter != buff.end(); ++iter)
    func(*iter);
}
</pre>
<p> イテレータのデータ型は auto を使うと簡単に指定することができます。コンパイルするときはオプション -std=c++11 を付けることを忘れないでください。
</p>
<p> 固定長の配列でイテレータを使用する場合は、標準ライブラリ &lt;array&gt; が便利です。array はクラステンプレートで、テンプレート仮引数にはデータ型と大きさを指定します。簡単な使用例を示します。
</p>
<pre class="list">
リスト : array と for_each の使用例

#include &lt;iostream&gt;
#include &lt;array&gt;
using namespace std;

template&lt;class T, class F&gt;
void for_each(T buff, F func)
{
  for (auto iter = buff.begin(); iter != buff.end(); ++iter)
    func(*iter);
}

template&lt;class T&gt;
void print(T x) { cout &lt;&lt; x &lt;&lt; " "; }

template&lt;class T&gt; class Display {
public:
  void operator()(T x) { cout &lt;&lt; x &lt;&lt; " "; }
};
  
int main()
{
  array&lt;int, 8&gt; a = {0,1,2,3,4,5,6,7};
  array&lt;double, 5&gt; b = {1.1, 2.2, 3.3, 4.4, 5.5};
  array&lt;string, 4&gt; c = {
    "foo", "bar", "baz", "oops"
  };
  for_each(a, print&lt;int&gt;);
  cout &lt;&lt; endl;
  for_each(b, print&lt;double&gt;);
  cout &lt;&lt; endl;
  for_each(c, print&lt;string&gt;);
  cout &lt;&lt; endl;
  for_each(a, Display&lt;int&gt;());
  cout &lt;&lt; endl;
  for_each(b, Display&lt;double&gt;());
  cout &lt;&lt; endl;
  for_each(c, Display&lt;string&gt;());
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
0 1 2 3 4 5 6 7 
1.1 2.2 3.3 4.4 5.5 
foo bar baz oops 
0 1 2 3 4 5 6 7 
1.1 2.2 3.3 4.4 5.5 
foo bar baz oops 
</pre>
<p> なお、Ｃ++の標準ライブラリ algorithm に定義されている for_each は、引数にイテレータを渡すように定義されています。
</p>
<pre class="list">
リスト : 標準ライブラリ関数 for_each の定義例

template&lt;class It, class Fn&gt;
F for_each(It first, It last, Fn f)
{
  for (; first != last; ++first)
    f(*first);
  return f;
}
</pre>
<p> Ｃ++の場合、イテレータはポインタと同じような文法でコンテナの要素にアクセスできるように設計されています。イテレータを引数に受け取る関数は、ポインタを渡してもたいていの場合は動作します。たとえば、配列にイテレータは用意されていませんが、ポインタを渡せば for_each でも動作します。次の例を見てください。
</p>
<pre class="list">
リスト : for_each の使用例

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

void print_int(int x) { cout &lt;&lt; x &lt;&lt; " "; }

int main()
{
  int a[8] = {1,2,3,4,5,6,7,8};
  for_each(a, a + 8, print_int);
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
1 2 3 4 5 6 7 8 
</pre>
<p> このように、配列 a の先頭アドレス a と終端のアドレス a + 8 を for_each に渡して、関数 print_int() を呼び出すことができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp16.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp18.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>