<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881817</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>ビット操作</h3>
<p> 今回は Rust のビット操作について説明します。
</p>
<h4>●ビット演算子</h4>
<p> Rust のビット演算子を下表に示します。
</p>
<table border=1>
<caption>表 : ビット演算子</caption>
<thead>
  <tr><th>演算子</th><th>操作</th></tr>
</thead>
<tbody>
  <tr><td>x &amp; y </td><td>ビットごとの論理積</td></tr>
  <tr><td>x | y </td><td>ビットごとの論理和</td></tr>
  <tr><td>x ^ y </td><td>ビットごとの排他的論理和</td></tr>
  <tr><td>!x </td><td>ビットごとの否定 (Ｃ言語の ~ と同じ)</td></tr>
  <tr><td>x &lt;&lt; y </td><td> x を y ビット左シフト</td></tr>
  <tr><td>x &gt;&gt; y </td><td> x を y ビット右シフト</td></tr>
</tbody>
</table>
<p> 演算子 &amp; はビットごとの論理積を返します。
</p>
<pre class="item">
5 &amp; 3 =&gt; 1
</pre>
<pre class="fig">
     0101
 AND 0011
---------
     0001
</pre>
<p> 演算子 | はビットごとの論理和を返します。
</p>
<pre class="item">
5 | 3 =&gt; 7
</pre>
<pre class="fig">
    0101
 OR 0011
--------
    0111
</pre>
<p> 演算子 ^ はビットごとの排他的論理和を返します。
</p>
<pre class="item">
5 ^ 3 =&gt; 6
</pre>
<pre class="fig">
     0101
 XOR 0011
---------
     0110
</pre>
<p> 演算子 ! はビットごとの論理的な否定を返します。
</p>
<pre class="item">
!1 =&gt; -2
!0 =&gt; -1
</pre>
<p> &lt;&lt;, &gt;&gt; はビットをシフトする演算子です。左シフトの場合、下位ビットには 0 が挿入されます。右シフトの場合、正の整数 (または無符号整数) では上位ビットに 0 が挿入されます。負の整数では 1 が挿入されます。これを「算術シフト」といいます。
</p>
<pre class="item">
1 &lt;&lt; 8 =&gt; 256
1 &lt;&lt; 16 =&gt; 65536
256 &gt;&gt; 8 =&gt; 1
65536 &gt;&gt; 8 =&gt; 256
-256 &gt;&gt; 8 =&gt; -1
</pre>
<p> それでは簡単な例題として、基本的なビット操作関数を作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 基本的なビット操作

fn test_bit(x: i32, n: i32) -&gt; bool {
    x &amp; (1 &lt;&lt; n) != 0
}

fn set_bit(x: i32, n: i32) -&gt; i32 {
    x | (1 &lt;&lt; n)
}

fn clear_bit(x: i32, n: i32) -&gt; i32 {
    x &amp; !(1 &lt;&lt; n)
}

fn main() {
    println!("{}", test_bit(256, 7));
    println!("{}", test_bit(256, 8));
    println!("{}", test_bit(256, 9));
    for i in 0 .. 8  {
        let x = set_bit(0, i);
        println!("{}", x);
        println!("{}", clear_bit(x, i));
    }
}
</pre>
<p> test_bit() は整数 x の n 番目のビットが 1 ならば true を返します。最下位 (LSB) のビットが 0 番目になります。i32 の場合、n は 0 から 31 になります。1 を n ビット左シフトして、x との論理積が 0 でなければ、n 番目のビットは 1 であることがわかります。
</p>
<p> bit_set() は x の n 番目のビットを 1 にセットします。1 を n ビット左シフトして、x との論理和を計算すれば、n 番目のビットを 1 にすることができます。clear_bit() は x の n 番目のビットを 0 にクリアします。これは n 番目以外のビットを 1 に、n 番目のビットを 0 にして、それと x の論理積を計算すれば、n 番目のビットをクリアすることができます。1 を n ビット左シフトして、その否定を計算すると、n 番目のビット以外は 1 になります。
</p>
<p> それでは実際に試してみましょう。
<pre>
false
true
false
1
0
2
0
4
0
8
0
16
0
32
0
64
0
128
0
</pre>
<h4>●組み合わせの生成</h4>
<p> 組み合わせの生成は <a href="rust01.html#chap10">拙作のページ</a> で取り上げました。このほかに、n 個の中から m 個を選ぶ組み合わせは、ビットの 0, 1 で表すことができます。たとえば、5 個の数字 (0 - 4) から 3 個を選ぶ場合、数字を 0 番目 から 4 番目のビットに対応させます。すると、1, 3, 4 という組み合わせは 11010 と表すことができます。簡単な例題として、ビットを使って組み合わせを求めてみましょう。
</p>
<p> 組み合わせを求めるプログラムは次のようになります。
</p>
<pre class="list">
リスト : 組み合わせの生成

fn combinations(n: i32, m: i32, func: &amp;Fn(i32) -&gt; ()) {
    fn comb_sub(n: i32, m: i32, a: i32, func: &amp;Fn(i32) -&gt; ()) {
        if m == 0 {
            func(a);
        } else if m == n {
            func(a | ((1 &lt;&lt; m) - 1));
        } else {
            comb_sub(n - 1, m, a, func);
            comb_sub(n - 1, m - 1, a | (1 &lt;&lt; (n - 1)), func);
        }
    }
    comb_sub(n, m, 0, func);
}

fn main() {
    combinations(5, 3, &amp;|x| println!("{:x}", x));
}
</pre>
<p> 関数 combinations() は n 個の中から m 個を選ぶ組み合わせを生成して、引数の関数 func() に渡します。実際の処理は関数 comb_sub() で行います。組み合わせは引数 a にセットします。m が 0 になったら、組み合わせがひとつできたので func(a) を呼び出します。n が m と等しくなったならば、残り m 個を全て選びます。(1 &lt;&lt; m) - 1 で m 個のビットをオンにして関数 func() を呼び出します。
</p>
<P> あとは comb_sub() を再帰呼び出しします。最初の呼び出しは n 番目の数字を選ばない場合です。n - 1 個の中から m 個を選びます。次の呼び出しが n 番目の数字を選ぶ場合で、a の n - 1 番目のビットをオンにします。そして、n - 1 個の中から m - 1 個を選びます。
</p>
<p> それでは 5 個の中から 3 個を選ぶ combinations(5, 3) の実行例を示します。
</p>
<pre>
7
b
d
e
13
15
16
19
1a
1c
</pre>
<p> この場合、最小値は 0x07 (111) で最大値は 0x1c (11100) になります。このように、combinations() は組み合わせを表す数を昇順で出力します。
</p>
<h4>●組み合わせに番号を付ける方法</h4>
<p> 次は、N 通りある組み合わせに 0 から N - 1 までの番号を付ける方法を紹介しましょう。たとえば、6 個の中から 3 個を選ぶ組み合わせは 20 通りありますが、この組み合わせに 0 から 19 までの番号を付けることができます。1 1 1 0 0 0 を例題に考えてみましょう。次の図を見てください。
</p>
<pre class="fig">
  5 4 3 2 1 0
  ─────────
  0 0 0 1 1 1    ↑
  0 0 1 0 1 1    │
  0 0 1 1 0 1    │
  0 0 1 1 1 0    │
  0 1 0 0 1 1    │
  0 1 0 1 0 1   5Ｃ3 = 10 通り
  0 1 0 1 1 0    │
  0 1 1 0 0 1    │
  0 1 1 0 1 0    │
  0 1 1 1 0 0    ↓
  ─────────
  1 0 0 0 1 1    ↑
  1 0 0 1 0 1    │
  1 0 0 1 1 0    │
  1 0 1 0 0 1   4Ｃ2 = 6 通り
  1 0 1 0 1 0    │
  1 0 1 1 0 0    ↓
    ────────
  1 1 0 0 0 1    ↑
  1 1 0 0 1 0   3Ｃ1 = 3 通り
  1 1 0 1 0 0    ↓
      ───────
  1 1 1 0 0 0    19 番目
  ─────────

  図：6Ｃ3 の組み合わせ
</pre>

<p> 最初に 5 をチェックします。5 を選ばない場合は <sub>5</sub>Ｃ<sub>3</sub> = 10 通りありますね。この組み合わせに 0 から 9 までの番号を割り当てることにすると、5 を選ぶ組み合わせの番号は 10 から 19 までとなります。
</p>
<p> 次に、4 をチェックします。4 を選ばない場合は、<sub>4</sub>Ｃ<sub>2</sub> = 6 通りあります。したがって、5 を選んで 4 を選ばない組み合わせに 10 から 15 までの番号を割り当てることにすると、5 と 4 を選ぶ組み合わせには 16 から 19 までの番号となります。
</p>
<p> 最後に、3 をチェックします。同様に 3 を選ばない場合は 3 通りあるので、これに 16 から 18 までの番号を割り当て、5, 4, 3 を選ぶ組み合わせには 19 を割り当てます。これで組み合わせ 1 1 1 0 0 0 の番号を求めることができました。
</p>
<p> では、0 0 0 1 1 1 はどうなるのでしょうか。左から順番にチェックしていくと、最初の 1 が見つかった時点で、その数字を選ばない組み合わせは存在しません。つまり、残りの数字をすべて選ぶしかないわけです。したがって、これが 0 番目となります。
</p>
<p> このように、数字を選ぶときに、数字を選ばない場合の組み合わせの数を足し算していけば、その組み合わせの番号を求めることができるのです。
</p>
<h4>●組み合わせを番号に変換</h4>
<p> 組み合わせを番号に変換するプログラムは次のようになります。
</p>
<pre class="list">
リスト : 組み合わせを番号に変換

// 組み合わせの数
fn comb_num(n: i32, r: i32) -&gt; i32 {
    if n == r || r == 0 {
        1
    } else {
        comb_num(n, r - 1) * (n - r + 1) / r
    }
}

// 組み合わせを番号に変換
fn comb_to_num(c: i32, n: i32, r: i32) -&gt; i32 {
    fn comb_to_num_sub(c: i32, n: i32, r: i32, value: i32) -&gt; i32 {
        if r == 0 || n == r {
            value
        } else if test_bit(c, n - 1) {
            comb_to_num_sub(c, n - 1, r - 1, value + comb_num(n - 1, r))
        } else {
            comb_to_num_sub(c, n - 1, r, value)
        }
    }
    comb_to_num_sub(c, n, r, 0)
}
</pre>

<p> 関数 comb_num() は組み合わせの数を求めます。comb_to_num() の引数 c はビットのオンオフで表した組み合わせ、引数 n と r は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。実際の処理は comb_to_num_sub() で行います。引数 value は求める番号を表します。n と r の値が同じになるか、もしくは r が 0 になれば、組み合わせの番号を計算できたので value を返します。
</p>
<p> そうでない場合、c の n - 1 ビットの値を調べます。ビットがオンであれば、value に comb_num(n - 1, r) の値を足し算し、r を -1 して comb_to_num_sub() を再帰呼び出しします。そうでなければ、value と r の値はそのままで comb_to_num_sub() を再帰呼び出しします。
</p>

<h4>●番号を組み合わせに変換</h4>
<p> 逆に、番号から組み合わせを求めるプログラムも簡単に作ることができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 番号を組み合わせに変換

fn num_to_comb(value:i32, n: i32, r: i32) -&gt; i32 {
    fn num_to_comb_sub(value: i32, n: i32, r: i32, c: i32) -&gt; i32 {
        if r == 0 {
            c
        } else if n == r {
            c | ((1 &lt;&lt; n) - 1)
        } else {
            let k = comb_num(n - 1, r);
            if value &gt;= k {
                num_to_comb_sub(value - k, n - 1, r - 1, set_bit(c, n - 1))
            } else {
                num_to_comb_sub(value, n - 1, r, c)
            }
        }
    }
    num_to_comb_sub(value, n, r, 0)
}
</pre>

<p> 引数 value が番号で、引数 n と r は <sub>n</sub>Ｃ<sub>r</sub> の n と r を表しています。実際の処理は num_to_comb_sub() で行います。引数 c が求める組み合わせです。たとえば、n = 5, r = 3 の場合、ビットが 1 になるのは <sub>4</sub>C<sub>2</sub> = 6 通りあり、0 になるのは <sub>4</sub>C<sub>3</sub> = 4 通りあります。したがって、数値が 0 - 3 の場合はビットを 0 にし、4 - 9 の場合はビットを 1 にすればいいわけです。
</p>
<p> ビットを 0 にした場合、残りは <sub>4</sub>C<sub>3</sub> = 4 通りになるので、同様に次のビットを決定します。ビットを 1 にした場合、残りは <sub>4</sub>C<sub>2</sub> = 6 通りになるので、value から 4 を引いて num_to_comb_sub() を再帰呼び出しして次のビットを決定します。
</p>
<p> r が 0 の場合は、組み合わせが完成したので c を返します。n と r が等しい場合は、残りのビットをすべて 1 にセットしてから c を返します。それ以外の場合は、<sub>n-1</sub>C<sub>r</sub> の値を comb_num(n - 1, r) で求めて変数 k にセットします。value が k 以上であれば変数 c のビットを 1 にセットし、value から k を引き算して num_to_comb_sub() を再帰呼び出しします。そうでなければ、num_to_comb_sub() を再帰呼び出しするだけです。

<p> それでは、n = 5, r = 3 の場合の実行例を示します。
</p>
<pre class="list">
リスト : 簡単なテスト

fn main() {
    for i in 0 .. 10 {
        let c = num_to_comb(i, 5, 3);
        println!("{} =&gt; {:x} =&gt; {}", i, c, comb_to_num(c, 5, 3));
    }
}
</pre>
<pre>
0 =&gt; 7 =&gt; 0
1 =&gt; b =&gt; 1
2 =&gt; d =&gt; 2
3 =&gt; e =&gt; 3
4 =&gt; 13 =&gt; 4
5 =&gt; 15 =&gt; 5
6 =&gt; 16 =&gt; 6
7 =&gt; 19 =&gt; 7
8 =&gt; 1a =&gt; 8
9 =&gt; 1c =&gt; 9
</pre>
<p> 正常に動作していますね。この方法を使うと、n 個ある組み合わせの中の i 番目 (0 &lt;= i &lt; n) の組み合わせを簡単に求めることができます。
</p>
<h4>●ちょっと便利なビット操作</h4>
<p> 最も右側 (LSB 側) にある 1 を 0 にクリアする、逆に最も右側にある 0 を 1 にセットすることは簡単にできます。
<pre class="fig">
(1) 右側にある 1 をクリア =&gt; x &amp; (- x)

x     : 1 1 1 1
x - 1 : 1 1 1 0
----------------
 AND  : 1 1 1 0

x     : 1 0 0 0
x - 1 : 0 1 1 1
----------------
 AND  : 0 0 0 0

(2) 右側にある 0 を 1 にセット =&gt; x | (x + 1)

x     : 0 0 0 0
x + 1 : 0 0 0 1
----------------
  OR  : 0 0 0 1

x     : 0 1 1 1
x - 1 : 1 0 0 0
----------------
  OR  : 1 1 1 1
</pre>
<p> 上図 (1) を見てください。x から 1 を引くと、右側から連続している 0 は桁借りにより 1 になり、最初に出現する 1 が 0 になります。したがって、x &amp; (x - 1) を計算すると、最も右側にある 1 を 0 にクリアすることができます。(2) の場合、x に 1 を足すと、右側から連続している 1 は桁上がりにより 0 になり、最初に出現する 0 が 1 になります。x | (x + 1) を計算すれば、最も右側にある 0 を 1 にセットすることができます。
</p>
<p> また、最も右側にある 1 を取り出すことも簡単にできます。簡単な例として 4 ビットの整数値を考えてみます。負の整数を 2 の補数で表した場合、4 ビットで表される整数は -8 から 7 になります。次の図を見てください。
</p>
<pre class="fig">
 0 : 0000
 1 : 0001    -1 : 1111    1 &amp; (-1) =&gt; 0001
 2 : 0010    -2 : 1110    2 &amp; (-2) =&gt; 0010
 3 : 0011    -3 : 1101    3 &amp; (-3) =&gt; 0001
 4 : 0100    -4 : 1100    4 &amp; (-4) =&gt; 0100
 5 : 0101    -5 : 1011    5 &amp; (-5) =&gt; 0001
 6 : 0110    -6 : 1010    6 &amp; (-6) =&gt; 0010
 7 : 0111    -7 : 1001    7 &amp; (-7) =&gt; 0001
             -8 : 1000

        図 : 最も右側にある 1 を取り出す方法
</pre>

<p> 2 の補数はビットを反転した値 (1 の補数) に 1 を加算することで求めることができます。したがって、x と -x の論理積 x &amp; (-x) は、最も右側にある 1 だけが残り、あとのビットはすべて 0 になります。
</p>
<h4>●ビットが 1 の個数を求める</h4>
<p> Rust にはビットが 1 の個数を求めるメソッド count_ones() と、0 の個数を求めるメソッド count_zeros() が用意されています。
</p> 
<pre class="item">
fn count_ones(self) -&gt; u32
fn count_zeros(self) -&gt; u32
</pre>
    
<p> ここではビット操作の簡単な例題として、ビットが 1 の個数を求めるプログラムを作ってみましょう。データ型を u32 とすると、プログラムは次のようになります。
</p>
<pre class="list">
リスト : ビットカウント

fn bit_count(n: u32) -&gt; u32 {
    let mut c = 0;
    let mut m = n;
    while m != 0 {
        m &amp;= m - 1;
        c += 1;
    }
    c
}
</pre>
<p> 整数 n の右側から順番に 1 をクリアしていき、0 になるまでの回数を求めます。とても簡単ですね。32 個のビットを順番に調べるよりも高速です。また、次の方法で 1 の個数をもっと高速に求めることができます。
</p>
<pre class="list">
リスト : ビットカウント (2)

fn bit_count1(n: u32) -&gt; u32 {
    let a = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);
    let b = (a &amp; 0x33333333) + ((a &gt;&gt; 2) &amp; 0x33333333);
    let c = (b &amp; 0x0f0f0f0f) + ((b &gt;&gt; 4) &amp; 0x0f0f0f0f);
    let d = (c &amp; 0x00ff00ff) + ((c &gt;&gt; 8) &amp; 0x00ff00ff);
    (d &amp; 0xffff) + (d &gt;&gt; 16)
}
</pre>
<p> 最初に、整数を 2 bit ずつに分割して、1 の個数を求めます。たとえば、整数 n を 4 bit で考えてみましょう。5 を 2 進数で表すと 0101 になり、n と論理積を計算すると 0, 2 番目のビットが 1 であれば、結果の 0, 2 番目のビットは 1 になります。同様に n を 1 ビット右シフトして論理積を計算すると、1, 3 番目のビットが 1 であれば、結果の 0, 2 番目のビットは 1 になります。あとは、それを足し算すれば 2 bit の中にある 1 の個数を求めることができます。
</p>
<p> 変数 a には 2 ビットの中の 1 の個数が格納されています。左隣の 2 ビットの値を足し算すれば、4 ビットの中の 1 の個数を求めることができます。次に、左隣の 4 ビットの値を足し算して 8 ビットの中の 1 の個数を求め、左隣の 8 ビットの値を足し算して、というように順番に値を加算していくと 32 ビットの中にある 1 の個数を求めることができます。
</p>
<p> bit_count() は 1 の個数が多くなると遅くなりますが、bit_count1() は 1 の個数に関係なく高速に動作します。興味のある方は実際に試してみてください。
</p>
<h4>●N Queens Problem の高速化</h4>
<p> 最後に、ビット操作を使った高速化の例として <a href="rust01.html#chap12">N Queens Problem</a> を取り上げます。アルゴリズムの詳しい説明は拙作のページ <a href="clang18.html#chap02">お気楽Ｃ言語超入門: N Queens Problem</a> をお読みください。
</p>
<p> プログラムと実行結果を示します。
</p>
<pre class="list">
リスト : N Queens Problem の高速化

use std::time::Instant;

static mut CNT: i32 = 0;

// 衝突の検出
fn attack(q: i32, qs: &amp;Vec&lt;i32&gt;) -&gt; bool {
    let mut i = qs.len();
    let mut d = 1;
    while i &gt; 0 {
        if q + d == qs[i - 1] || q - d == qs[i - 1] { return true; }
        i -= 1;
        d += 1;
    }
    false
}

// N Queens Problem の解法
fn nqueens(n: i32) {
    fn queen_sub(n: i32, qs: &amp;mut Vec&lt;i32&gt;) {
        if n == qs.len() as i32 {
            unsafe { CNT += 1; }
        } else {
            for q in 1 .. n + 1 {
                if !qs.contains(&amp;q) &amp;&amp; !attack(q, qs) {
                    qs.push(q);
                    queen_sub(n, qs);
                    qs.pop();
                }
            }
        }
    }
    queen_sub(n, &amp;mut vec![]);
}

// ビット操作による高速化
fn nqueens1(n: i32, right: i32, left: i32) {
    if n == 0 {
        unsafe { CNT += 1; }
    } else {
        let mut m = n;
        while m &gt; 0 {
            let q = m &amp; (-m);
            if (q &amp; (right | left)) == 0 {
                nqueens1(n ^ q, (right | q) &lt;&lt; 1, (left | q) &gt;&gt; 1);
            }
            m &amp;= m - 1;
        }
    }
}

fn main() {
    for n in 10 .. 16 {
        let s = Instant::now();
        unsafe { CNT = 0; }
        nqueens(n);
        unsafe { println!("{}", CNT); }
        let e = s.elapsed();
        println!("{}.{:03}秒経過しました。", e.as_secs(), e.subsec_nanos() / 1_000_000);

        let s1 = Instant::now();
        unsafe { CNT = 0; }
        nqueens1((1 &lt;&lt; n) - 1, 0, 0);
        unsafe { println!("{}", CNT); }
        let e1 = s1.elapsed();
        println!("{}.{:03}秒経過しました。", e1.as_secs(), e1.subsec_nanos() / 1_000_000);
    }
}
</pre>
<pre>
724
0.005秒経過しました。
724
0.001秒経過しました。
2680
0.031秒経過しました。
2680
0.005秒経過しました。
14200
0.154秒経過しました。
14200
0.018秒経過しました。
73712
0.863秒経過しました。
73712
0.107秒経過しました。
365596
5.408秒経過しました。
365596
0.609秒経過しました。
2279184
35.907秒経過しました。
2279184
3.865秒経過しました。   
</pre>
<h4>●参考 URL</h4>
<p> ビットが 1 の個数を数える方法は <a href="http://www.st.rim.or.jp/~phinloda/">フィンローダさん</a> の <a href="http://www.st.rim.or.jp/~phinloda/cqa/cqa15.html#Q2">初級Ｃ言語Ｑ＆Ａ(15)</a> を参考にさせていただきました。フィンローダさんに感謝いたします。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chap02">循環リスト</h3>
<h4>●循環リストの構造</h4>
<p> 連結リストは要素を一列に並べたデータ構造ですが、最後尾のセルと先頭のセルを連結することで要素をリング状に並べることができます。これを「循環リスト (circular list)」 といいます。次の図を見てください。
</p>
<pre class="fig">
         Cell の cdr を直接 Cell A に書き換える
                              └─────┐
         Cell A                           ↓
         car  cdr      car  cdr      car  cdr
        ┌─┬─┐    ┌─┬─┐    ┌─┬─┐
変数─→│・│・┼─→│・│・┼─→│・│／│
        └┼┴─┘    └┼┴─┘    └┼┴─┘
          ↓            ↓            ↓
          １            ２            ３

          ┌───────────────┐
          ↓                              │
        ┌─┬─┐    ┌─┬─┐    ┌─┬┼┐
変数─→│・│・┼─→│・│・┼─→│・│・│
        └┼┴─┘    └┼┴─┘    └┼┴─┘
          ↓            ↓            ↓
          １            ２            ３

                 図 : 循環リスト
</pre>
<p> 上図の連結リスト (1 2 3) は None で終端されています。この連結リストで、最後尾のセルの cdr を先頭のセル A に書き換えると、循環リストを作ることができます。循環リストは環状に並んだデータを表すのに便利なデータ構造です。
</p>

<h4>●循環リストによるキューの実装</h4>
<p> それでは簡単な例題として、循環リストを使って「キュー (queue)」を実装してみましょう。拙作のページ <a href="rust07.html#chap72">キュー (連結リスト)</a> で作成したキューの構造は次のようになっています。
</p>
<pre class="fig">
rear  ─→ None
front ─→ None

(1) キューが空の状態

rear  ─────────────────────┐
                                                ↓
          ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  ┌─┬─┐
front ─→│・│・┼→│・│・┼→│・│・┼→│・│・┼→ None
          └┼┴─┘  └┼┴─┘  └┼┴─┘  └┼┴─┘
            ↓          ↓          ↓          ↓
           data1       data2       data3       data4

(2) キューにデータがある場合

               図 : 連結リストによるキューの構造
</pre>
<p> 先頭のセルを参照する変数 front のほかに、最後尾のセルを参照する変数 rear を用意します。キューにデータがない場合は、(1) のように front と rear は None になっています。データがある場合は、(2) のように front は先頭のセルを参照し、rear は最後尾のセルを参照しています。これで、データの追加を効率的に行うことができます。 
</p>
<p> 循環リストの場合、最後尾のセルを参照する変数 rear を用意するだけでキューを実現することができます。下図を見てください。
</p>
<pre class="fig">
rear  ─→ None

(1) キューが空の状態


rear  ───┐
            ↓
          ┌─┬─┐
    ┌─→│・│・┼─┐
    │    └┼┴─┘  │
    │      ↓        │
    │     data1      │
    │                │
    └────────┘

(2) キューにデータが一つある場合


rear  ─────────────────────┐
                                                ↓
          ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  ┌─┬─┐
    ┌─→│・│・┼→│・│・┼→│・│・┼→│・│・┼─┐
    │    └┼┴─┘  └┼┴─┘  └┼┴─┘  └┼┴─┘  │
    │      ↓          ↓          ↓          ↓        │
    │     data1       data2       data3       data4      │
    │                                                    │
    └──────────────────────────┘

(3) キューに複数のデータがある場合

             図 : 循環リストによるキューの構造
</pre>
<p> 循環リストの場合、最後尾のセルの次のセルが先頭になります。(3) を見てください。循環リストの場合、rear が参照する最後尾のセルの cdr は None ではありません。cdr が参照するセルがキューの先頭になるのです。データが一つしかない場合、(2) のように rear が参照するセルの cdr は自分自身を参照しています。つまり、このセルが先頭であり最後尾でもあるわけです。キューにデータがない場合、rear の値は (1) のように None になります。
</p>

<h4>●プログラムの作成</h4>
<p> それでは、プログラムを作りましょう。最初に作成するメソッドを表に示します。
</p>
<table border=1>
<caption>表 : Queue&lt;T&gt; のメソッド</caption>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>fn new(n: usize) -&gt; Queue&lt;T&gt;</td><td>指定した大きさのキューを作る (コンストラクタ)</td></tr>
  <tr><td>fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt;</td><td>キューからデータを取り出して返す</td></tr>
  <tr><td>fn enqueue(&amp;mut self, x: T) -&gt; bool</td><td>キューにデータを追加する</td></tr>
  <tr><td>fn front(&amp;self) -&gt; Option&lt;&amp;T&gt;</td><td>キューの先頭データの参照を返す</td></tr>
  <tr><td>fn is_empty(&amp;self) -&gt; bool</td><td>キューが空の場合は true を、そうでなければ false を返す</td></tr>
  <tr><td>fn is_full(&amp;self) -&gt; bool</td><td>キューが満杯の場合は true を、そうでなければ false を返す</td></tr>
  <tr><td>fn len(&amp;self) -&gt; usize</td><td>キューに格納されたデータ数を返す</td></tr>
  <tr><td>fn clear(&amp;mut self)</td><td>キューを空にする</td></tr>
</tbody>
</table>
<h4>●データ構造の定義</h4>
<p> 次はデータ構造を定義します。
</p>
<pre class="list">
リスト : 循環リストによるキューの実装

use std::rc::Rc;
use std::cell::UnsafeCell;

// 連結リスト
struct List&lt;T&gt; {
    car: T,
    cdr: Link&lt;T&gt;
}

type Link&lt;T&gt; = Option&lt;Rc&lt;UnsafeCell&lt;List&lt;T&gt;&gt;&gt;&gt;;

// 循環リストによるキューの実装
struct Queue&lt;T&gt; {
    rear: Link&lt;T&gt;,
    size: usize
}

// メソッド
impl&lt;T&gt; Queue&lt;T&gt; {
    // キューの生成
    fn new() -&gt; Queue&lt;T&gt; {
        Queue { rear: None, size: 0 }
    }

    // メソッドの定義 (省略)
}
</pre>
<p> 末尾のセルは Queue の rear と一つ手前のセルの 2 カ所から参照されるので、Box&lt;T&gt; ではなく Rc&lt;T&gt; を使う必要があります。それから、拙作のページ <a href="rust07.html#chap72">キュー (連結リスト)</a> では RefCell&lt;T&gt; を使いましたが、メソッド front() でライフタイムのコンパイルエラーを解決できなかったので、今回は UnsafeCell&lt;T&gt; を使うことにしました。
</p>
<h4>●データの追加</h4>
<p> 次はデータを追加するメソッド enqueue() を作ります。
</p>
<pre class="list">
リスト : データの追加

    fn enqueue(&amp;mut self, item: T) {
        let new_node = Rc::new(UnsafeCell::new(List { car: item, cdr: None }));
        match self.rear.take() {
            None =&gt; unsafe {
                let p = new_node.get();
                (*p).cdr = Some(new_node.clone());
            },
            Some(tail_node) =&gt; unsafe {
                let p = tail_node.get();
                let head_node = (*p).cdr.take();
                let q = new_node.get();
                (*q).cdr = head_node;
                (*p).cdr = Some(new_node.clone());
            }
        }
        self.rear = Some(new_node);
        self.size += 1;
    }
</pre>
<p> 最初にデータ item を格納したセルを生成して変数 new_node にセットします。次に、self.rear.take() で末尾のセルを取り出します。None の場合、キューは空なので new_node をキューに追加します。ここで、new_node の cdr を自分自身に書き換えます。UnsafeCell の場合、メソッド get() で格納しているデータへの生ポインタを取得することができます。
</p>
<pre class="item">
fn get(&amp;self) -&gt; *mut T
</pre>
<p> Rc には Deref が実装されているので、new_node.get() で生ポインタを取得することができます。それを変数 p にセットすると、List&lt;T&gt; のフィールド car, cdr は (*p).car, (*p).cdr でアクセスすることができます。(*p).cdr に値をセットするときは、new_node を clone() することをお忘れなく。最後に、self.rear に new_node をセットします。
</p>
<p> 末尾のセル (tail_node) がある場合、その後ろに new_node を追加します。tail_node の生ポインタを取得して変数 p に、new_node の生ポインタを変数 q にセットします。次に、(*p).cdr.take() で先頭セル (head_node) を取得して (*q).cdr にセットします。これで new_node の後ろに head_node をつなぐことができます。あとは、(*p).cdr に Some(new_node.clone()) をセットすれば、head_node と tail_node の間に new_node を挿入することができます。
</p>    
<h4>●データの取り出し</h4>
<p> 次はデータを取り出すメソッド dequeue() を作ります。
</p>
<pre class="list">
リスト : データの取り出し

    fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.size == 0 {
            None
        } else {
            self.size -= 1;
            if self.size == 0 {
                self.rear.take().map(|node| unsafe {
                    let p = node.get();
                    (*p).cdr = None;
                    match Rc::try_unwrap(node) {
                        Ok(node) =&gt; node.into_inner().car,
                        Err(_) =&gt; panic!("dequeue error")
                    }
                })
            } else {
                self.rear.as_mut().map(|tail| unsafe {
                    let p = tail.get();
                    (*p).cdr.take().map(|head| {
                        let q = head.get();
                        (*q).cdr.take().map(|next| {
                            (*p).cdr = Some(next);
                        });
                        match Rc::try_unwrap(head) {
                            Ok(node) =&gt; node.into_inner().car,
                            Err(_) =&gt; panic!("dequeue error")
                        }
                    })
                }).unwrap()
            }
        }
    }
</pre>
<p> キューが空の場合は None を返します。そうでなければ、self.size を -1 して先頭セルからデータを取り出します。self.size が 0 の場合、キューは空になりました。self.rear.take().map() で末尾セル (node) を取り出します。このとき node の参照カウンタは 2 なので、node の cdr を None に書き換えて参照カウンタを 1 にします。そして、try_unwrap() で Rc からデータを取り出し、メソッド into_inner() で UnsafeCell からセルを取り出して、その要素 car を返します。into_inner() は UnsafeCell に格納しているデータを move することに注意してください。
</p>
<pre class="item">
unsafe fn into_inner(self) -&gt; T
</pre>
<p> キューが空にならない場合は先頭セルを取り除きます。最初に、self.rear.as_mut().map() で末尾セル (tail) を求めます。self.rear の値はそのままでよいので、mutable な参照を取得していることに注意してください。次に、tail の生ポインタを変数 p にセットします。すると、先頭セル (head) は (*p).cdr take().map() で取り出すことができます。
</p>
<p> そのあと、head の生ポインタを変数 q にセットし、(*q).cdr.take().map() で head の次のセル next を取得します。そして、末尾セル tail の cdr を next に書き換えます。これで head を連結リストから削除することができます。最後に、head から要素を取り出します。map() を二重に使っているので、このままでは返り値が Option&lt;Option&lt;T&gt;&gt; になってしまいます。unwrap() で Option を一つはがしていることに注意してください。
</p>
<p> なお、データが 2 つしかない場合、next は tail と同じセルになるので、tail の cdr は自分自身を指し示すことになります。これで正常に動作します。
</p>
<h4>●先頭データの参照</h4>
<p> 次はメソッド front() を作ります。
</p>
<pre class="list">
リスト : 先頭要素の参照を返す

    fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.size == 0 {
            None
        } else if self.size == 1 {
            self.rear.as_ref().map(|node| unsafe {
                let p = node.get();
                &amp;((*p).car)
            })
        } else {
            self.rear.as_ref().map(|node| unsafe {
                let p = node.get();
                (*p).cdr.as_ref().map(|head| {
                    let q = head.get();
                    &amp;((*q).car)
                })
            }).unwrap()
        }
    }
</pre>
<p> self.size が 0 の場合は None を返します。self.size が 1 の場合は末尾セルが先頭セルなので、self.rear が格納している要素 car の参照を返します。それ以外の場合は末尾セル (node) から先頭セル (head) を求め、head が格納している要素 car の参照を返します。
</p>
<p> ところで、最初は UnsafeCell のかわりに RefCell を使いました。この場合、node.borrow() ... とプログラムすることになるのですが、node.borrow() でライフタイム関連のコンパイルエラーが発生し、それを解決することができませんでした。Rust のライフタイムは難しいですね。Rust で木構造やグラフなどのデータ構造を操作する場合、unsafe な処理を使うのはやむを得ないのかもしれません。
</p>
<p> あとのメソッドは簡単なので説明は省略します。詳細は <a href="rust08.html#list1">プログラムリスト</a> をお読みください。
</p>

<h4>●実行例</h4>
<p> それでは実際に実行してみましょう。次に示す簡単なテストを行ってみました。
</p>
<pre class="list">
リスト : 簡単なテスト

fn main() {
    let mut que = Queue::new();
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    for i in 0 .. 5 {
        que.enqueue(i);
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    while !que.is_empty() {
        println!("{:?}", que.front());
        println!("{:?}", que.dequeue());
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());

    for i in 0 .. 10 {
        que.enqueue(i + 10);
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    for _ in 0 .. 8 {
        println!("{:?}", que.front());
        println!("{:?}", que.dequeue());
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    que.clear();
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
}
</pre>
<p> 実行結果は次のようになります。
</p>
<pre>
true
false
0
false
false
5
Some(0)
Some(1)
Some(2)
Some(3)
Some(4)
true
false
0
false
false
10
Some(10)
Some(11)
Some(12)
Some(13)
Some(14)
Some(15)
Some(16)
Some(17)
false
false
2
true
false
0
</pre>
<p> 正常に動作しているようです。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// queue2.rs : 循環リストによるキューの実装
//
//             Copyright (C) 2017 Makoto Hiroi
//
use std::rc::Rc;
use std::cell::UnsafeCell;

// 連結リスト
struct List&lt;T&gt; {
    car: T,
    cdr: Link&lt;T&gt;
}

type Link&lt;T&gt; = Option&lt;Rc&lt;UnsafeCell&lt;List&lt;T&gt;&gt;&gt;&gt;;

// 循環リストによるキューの実装
struct Queue&lt;T&gt; {
    rear: Link&lt;T&gt;,
    size: usize
}

// キューのメソッド
impl&lt;T&gt; Queue&lt;T&gt; {
    // キューの生成
    fn new() -&gt; Queue&lt;T&gt; {
        Queue { rear: None, size: 0 }
    }

    // データの追加
    fn enqueue(&amp;mut self, item: T) {
        let new_node = Rc::new(UnsafeCell::new(List { car: item, cdr: None }));
        match self.rear.take() {
            None =&gt; unsafe {
                let p = new_node.get();
                (*p).cdr = Some(new_node.clone());
            },
            Some(tail_node) =&gt; unsafe {
                let p = tail_node.get();
                let head_node = (*p).cdr.take();
                let q = new_node.get();
                (*q).cdr = head_node;
                (*p).cdr = Some(new_node.clone());
            }
        }
        self.rear = Some(new_node);
        self.size += 1;
    }

    // 先頭からデータを取り出す
    fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.size == 0 {
            None
        } else {
            self.size -= 1;
            if self.size == 0 {
                self.rear.take().map(|node| unsafe {
                    let p = node.get();
                    (*p).cdr = None;
                    match Rc::try_unwrap(node) {
                        Ok(node) =&gt; node.into_inner().car,
                        Err(_) =&gt; panic!("dequeue error")
                    }
                })
            } else {
                self.rear.as_mut().map(|tail| unsafe {
                    let p = tail.get();
                    (*p).cdr.take().map(|head| {
                        let q = head.get();
                        (*q).cdr.take().map(|next| {
                            (*p).cdr = Some(next);
                        });
                        match Rc::try_unwrap(head) {
                            Ok(node) =&gt; node.into_inner().car,
                            Err(_) =&gt; panic!("dequeue error")
                        }
                    })
                }).unwrap()
            }
        }
    }

    // 先頭要素の参照を返す
    fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.size == 0 {
            None
        } else if self.size == 1 {
            self.rear.as_ref().map(|node| unsafe {
                let p = node.get();
                &amp;((*p).car)
            })
        } else {
            self.rear.as_ref().map(|node| unsafe {
                let p = node.get();
                (*p).cdr.as_ref().map(|head| {
                    let q = head.get();
                    &amp;((*q).car)
                })
            }).unwrap()
        }
    }

    // キューの要素数を返す
    fn len(&amp;self) -&gt; usize { self.size }

    // キューは空か？
    fn is_empty(&amp;self) -&gt; bool { self.size == 0 }

    // キューは満杯か？ (常に false を返す)
    fn is_full(&amp;self) -&gt; bool { false }

    // キューを空にする
    fn clear(&amp;mut self) {
        match self.rear.take() {
            None =&gt; (),
            Some(tail) =&gt; unsafe {
                let p = tail.get();
                (*p).cdr = None;
                self.size = 0;
            }
        }
    }
}

// Queue を drop するときは連結リストも drop する
impl&lt;T&gt; Drop for Queue&lt;T&gt; {
    fn drop(&amp;mut self) { self.clear(); }
}

// 簡単なテスト
fn main() {
    let mut que = Queue::new();
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    for i in 0 .. 5 {
        que.enqueue(i);
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    while !que.is_empty() {
        println!("{:?}", que.front());
        println!("{:?}", que.dequeue());
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());

    for i in 0 .. 10 {
        que.enqueue(i + 10);
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    for _ in 0 .. 8 {
        println!("{:?}", que.front());
        println!("{:?}", que.dequeue());
    }
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
    que.clear();
    println!("{}", que.is_empty());
    println!("{}", que.is_full());
    println!("{}", que.len());
}
</pre>
</section>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html><!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>