<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881812</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp21.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp23.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Yet Another C++ Problems (3)</h3>
<h4>●シーケンス (列) とは？</h4>
<p> 要素を一列に並べたデータ構造を「シーケンス (sequence)」とか「列」と呼びます。たとえば、Common Lisp はリスト、一次元配列 (ベクタ)、文字列を列型データとして統一して扱うことができます。列を操作する関数を列関数といい、Common Lisp には便利な列関数が多数用意されています。Ｃ++の場合、vector, array, list, forward_list などのコンテナクラスは、シーケンスとして共通な操作を考えることができます。今回はシーケンスを操作する関数をテンプレートで作ってみましょう。
</p>
<h4>●問題21</h4>
<p> シーケンスの中から最大値を求める関数 maximum(), 最小値を求める関数 minimum() を定義してください。引数は先頭と終端を示すイテレータで、返り値は求めた要素へのイテレータとします。
</p>
<p><a href="cpp22.html#ans21">解答</a>
</p>
<h4>●問題22</h4>
<p> シーケンスを線形探索する関数 member(), position(), count() を定義してください。member() の返り値は bool で、position() の返り値は見つけた位置 (見つからない場合は -1) で、count は見つけた要素の個数です。
</p>
<p><a href="cpp22.html#ans22">解答</a>
</p>
<h4>●問題23</h4>
<p> 引数の叙述関数が真を返すデータを線形探索する高階関数 member_if(), position_if(), count_if() を定義してください。
</p>
<p><a href="cpp22.html#ans23">解答</a>
</p>
<h4>●問題24</h4>
<p> シーケンスの要素に引数の関数オブジェクト func を適用して、その結果を新しいシーケンスに格納して返す高階関数 mapcar() を定義してください。このような操作を「マッピング (写像)」といいます。
</p>
<p><a href="cpp22.html#ans24">解答</a>
</p>
<h4>●問題25</h4>
<p> 引数 x と等しい要素をシーケンスから削除する関数 remove() と、叙述関数が真を返す要素をシーケンスから削除する関数 remove_if() を定義してください。なお、どちらの関数も引数にはシーケンスのイテレータ (始点と終点) を受け取り、シーケンスを破壊的に修正することにします。返り値は最後に書き込んだ要素の次を示すイテレータです。
</p>
<p><a href="cpp22.html#ans25">解答</a>
</p>
<h4>●問題26</h4>
<p> シーケンスの要素を先頭から畳み込む高階関数 fold_left() と末尾から畳み込む fold_right() を定義してください。
</p>
<p><a href="cpp22.html#ans26">解答</a>
</p>
<h4>●問題27</h4>
<p> シーケンスの要素に叙述関数 p を適用し、一つでも真を返す要素があれば真を返す関数 any と、一つでも偽を返す要素があれば偽を返す (全てが真の場合に真を返す) 関数 every を定義してください。
</p>
<p><a href="cpp22.html#ans27">解答</a>
</p>
<h4>●問題28</h4>
<p> シーケンスに整数 n から始まる数列をセットする関数 iota() と、n から始まる数列の要素に関数 f を適用して、その結果をシーケンスにセットする高階関数 tabulate() を定義してください。
</p>
<p><a href="cpp22.html#ans28">解答</a>
</p>
<h4>●問題29</h4>
<p> 引数 x と等しいシーケンスの要素を引数 y に置換する関数 substitute() と、叙述関数が真を返す要素を引数 y に置換する高階関数 substitute_if() を定義してください。なお、これらの関数は引数のシーケンスを破壊的に修正するものとします。
</p>
<p><a href="cpp22.html#ans29">解答</a>
</p>
<h4>●問題30</h4>
<p> 「連想リスト (association list : a-list)」は Lisp でよく用いられるデータ構造で、キーとデータの組を要素とする連結リストで実現することができます。
</p>
<pre class="fig">
                    ┌────┬────┬────┬──→ データ 
                    │        │        │        │
連想リスト => [("a", 1), ("b", 2), ("c", 3), ("d", 4)]
                │        │        │        │
                └────┴────┴────┴──→ キー

                図 : 連想リストの構造
</pre>
<p> 上図の場合、文字列 "a", "b", "c", "d" がキーで、整数 1, 2, 3, 4 がデータとなります。Ｃ++の場合、連想リストは list&lt;pair&lt;K, V&gt;&gt; で表すことができます。また、他のコンテナクラスを使っても簡単に実装することができます。
</p>
<p> 連想リストの先頭にキーと値を追加する関数 acons() と、連想リストからキーを線形探索する関数 assoc() を定義してください。
</p>
<p><a href="cpp22.html#ans30">解答</a>
</p>
<hr>
<h4 id="ans21">●解答21</h4>
<pre class="list">
リスト : 最大値と最小値

template&lt;class It&gt;
It maximum(It first, It last)
{
  if (first == last) return last;
  It m = first++;
  while (first != last) {
    if (*m &lt; *first) m = first;
    ++first;
  }
  return m;
}

template&lt;class It&gt;
It minimum(It first, It last)
{
  if (first == last) return last;
  It m = first++;
  while (first != last) {
    if (*m &gt; *first) m = first;
    ++first;
  }
  return m;
}
</pre>
<p> どちらの関数も引数 first から last までの区間から最大値 (または最小値) を探します。これ以降、シーケンスの区間を [first, last) と記述することにします。first と last が等しい場合は last を返します。そして、先頭要素へのイテレータを変数 m にセットして、first を次の要素へ進めます。あとは、while ループで要素を順番にチェックしていき、*m よりも *frist が大きい (または小さい) 場合は m を first に書き換えます。最後に m を返すだけです。
</p>
<p> なお、STL の algorithm には同等の機能を持つ関数 max_element() と min_element() が用意されています。
</p>
<h4 id="ans22">●解答22</h4>
<p> 探索する区間をイテレータ [first, last) で渡すことにすると、プログラムは次のようになります。
</p>
<pre class="list">
リスト : シーケンスの線形探索 (1)

template&lt;class It, class T&gt;
bool member(It first, It last, const T&amp; val)
{
  while (first != last)
    if (*first++ == val) return true;
  return false;
}

template&lt;class It, class T&gt;
int position(It first, It last, const T&amp; val)
{
  int i = 0;
  while (first != last) {
    if (*first++ == val) return i;
    i++;
  }
  return -1;
}

template&lt;class It, class T&gt;
int count(It first, It last, const T&amp; val)
{
  int c = 0;
  while (first != last)
    if (*first++ == val) c++;
  return c;
}
</pre>
<p> テンプレート仮引数の It がイテレータ、T が探索するデータの型を表します。member() は *first と val が等しければ true を返します。postion() は位置 (添字) i を返します。count() は *first と val が等しければ変数 c を +1 して、最後に c を返します。
</p>
<p> シーケンス自身をそのまま渡すこともできます。次のリストを見てください。
</p>
<pre class="list">
リスト : シーケンスの線形探索 (2)

template&lt;class T, class U&gt;
bool member(const T&amp; seq, const U&amp; val)
{
  for (auto&amp; x : seq)
    if (x == val) return true;
  return false;
}

template&lt;class T, class U&gt;
int position(const T&amp; seq, const U&amp; val)
{
  int i = 0;
  for (auto&amp; x : seq) {
    if (x == val) return i;
    i++;
  }
  return -1;
}

template&lt;class T, class U&gt;
int count(const T&amp; seq, const U&amp; val)
{
  int c = 0;
  for (auto&amp; x : seq)
    if (x == val) c++;
  return c;
}
</pre>
<p> T がシーケンスのデータ型を表す仮引数で、U が探索するデータの型です。シーケンスの要素は範囲 for 文で順番に取り出すことができます。データ型の指定も auto を使えば簡単です。関数型言語では、このような仕様が一般的ですが、Ｃ++ではイテレータを渡すのが普通のようです。
<?p>
<h4 id="ans23">●解答23</h4>
<pre class="list">
リスト : 線形探索 (高階関数版)

template&lt;class It, class F&gt;
bool member_if(It first, It last, F func)
{
  while (first != last)
    if (func(*first++)) return true;
  return false;
}

template&lt;class It, class F&gt;
int position_if(It first, It last, F func)
{
  int i = 0;
  while (first != last) {
    if (func(*first++)) return i;
    i++;
  }
  return -1;
}

template&lt;class It, class F&gt;
int count_if(It first, It last, F func)
{
  int c = 0;
  while (first != last)
    if (func(*first++)) c++;
  return c;
}
</pre>
<p> It がイテレータを表す仮引数、F が関数オブジェクトを表す仮引数です。区間 [first, last) から叙述関数 func が真を返す要素を探索します。member_if() は func(*first) が真ならば true を返します。positon_if() は位置 (添字) i を返します。count_if() は変数 c の値を +1 して、最後に c を返します。
</p>
<p> シーケンス自身を渡す場合は次のようになります。
</p>
<pre class="list">
リスト : 線形探索 (高階関数版)

template&lt;class T, class F&gt;
bool member_if(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (func(x)) return true;
  return false;
}

template&lt;class T, class F&gt;
int position_if(const T&amp; seq, F func)
{
  int i = 0;
  for (auto&amp; x : seq)
    if (func(x)) return i;
  return -1;
}

template&lt;class T, class F&gt;
int count_if(const T&amp; seq, F func)
{
  int c = 0;
  for (auto&amp; x : seq)
    if (func(x)) c++;
  return c;
}
</pre>
<p> func(x) が真を返すとき、member_if() は true を返し、position_if() は変数 i を返し、count_if() は変数 c を +1 して、最後に c を返します。
</p>

<h4 id="ans24">●解答24</h4>

<pre class="list">
リスト : マッピング

template&lt;class T, class F&gt;
T mapcar(const T&amp; seq, F func)
{
  T new_seq(seq.size());
  auto iter = new_seq.begin();
  for (auto&amp; x : seq)
    *iter++ = func(x);
  return new_seq;
}
</pre>
<p> 最初に、コンストラクタで大きさ seq.size() の新しいシーケンス new_seq を生成します。そして、新しいシーケンスの先頭要素を示すイテレータ iter を生成します。あとは範囲 for 文でシーケンス seq から要素 x を取り出し、*iter に func(x) の返り値をセットします。最後に new_seq を返します。
</p>
<p> メンバ関数に push_back() があるならば、空の新しいシーケンスを生成して、そこに push_back() で追加していく方法もあります。ただし、forward_list には push_back() がないので、今回はこのようなプログラムにしてみました。
</p>
<p> シーケンスをイテレータで渡す場合は次のようになります。
</p>
<pre class="list">
リスト : マッピングの別解

template&lt;class It, class F&gt;
It mapcar(It first, It last, F func, It result)
{
  while (first != last)
    *result++ = func(*first++);
  return result;
}
</pre>
<p> 引数 result は結果を格納するシーケンスへのイテレータです。この場合、mapcar() を呼び出す前に出力先のシーケンスを生成しておいてください。
</p>
<h4 id="ans25">●解答25</h4>
<pre class="list">
リスト : 要素の削除

template&lt;class It, class U&gt;
It remove(It first, It last, const U&amp; val)
{
  It result = first;
  while (first != last) {
    if (*first != val) *result++ = *first;
    ++first;
  }
  return result;
}
</pre>
<p> remove() は区間 [first, last) の中から val と等しい要素を削除します。変数 result は書き込む位置を表すイテレータで、first に初期化します。あとは、*first と val が等しくなければ、*resulte に *first をセットするだけです。区間を上書きすることに注意してください。最後に result を返します。つまり、区間 [first, result) に要素を削除した結果がセットされます。
</p>
<pre class="list">
リスト : 要素の削除 (高階関数版)

template&lt;class It, class F&gt;
It remove_if(It first, It last, F func)
{
  It result = first;
  while (first != last) {
    if (!func(*first)) *result++ = *first;
    ++first;
  }
  return result;
}
</pre>
<p> remove_if() は叙述関数 func が真を返す要素を削除します。処理は remove() とほとんど同じです。なお、STL の algorithm には同等の機能を持つ関数 remove(), remove_if() が用意されています。
</p>
<h4 id="ans26">●解答26</h4>
<pre class="list">
リスト : 畳み込み

template&lt;class T, class U, class F&gt;
U fold_left(const T&amp; seq, U init, F func)
{
  for (auto&amp; x : seq) init = func(init, x);
  return init;
}

template&lt;class T, class U, class F&gt;
U fold_right(const T&amp; seq, U init, F func)
{
  for (auto iter = seq.crbegin(); iter != seq.crend(); ++iter)
    init = func(*iter, init);
  return init;
}
</pre>
<p> テンプレート仮引数 T がシーケンスのデータ型、U が初期値のデータ型、F が 2 引数の関数オブジェクトを表します。fold_left() は範囲 for 文を使えば簡単です。init の値を func(init, x) で書き換えていくだけです。fold_right() は reverse イテレータを使っています。
</p>
<p> なお、forward_list は reverse イテレータをサポートしていないので、fold_right() を適用することはできません。
</p>
<p> func() の引数は fold_left() と fold_right() で逆になっていることに注意してください。なお、畳み込み fold_left() と fold_right() の仕様は、プログラミング言語によって異なります。関数型言語でも統一されているわけではありません。ご注意くださいませ。
</p>
<p> イテレータを渡す場合は次のようになります。
<pre class="list">
リスト : 別解

template&lt;class It, class T, class F&gt;
T fold(It first, It last, T init, F func)
{
  while (first != last) init = func(init, *first++);
  return init;
}
</pre>
<p> とくに難しいところはないと思います。
</p>
<h4 id="ans27">●解答27</h4>
<pre class="list">
リスト : any と every

template&lt;class It, class F&gt;
bool any(It first, It last, F func)
{
  while (first != last)
    if (func(*first++)) return true;
  return false;
}

template&lt;class It, class F&gt;
bool every(It first, It last, F func)
{
  while (first != last)
    if (!func(*first++)) return false;
  return true;
}
</pre>
<p> どちらの関数もイテレータ [first, last) が表す区間の要素に関数オブジェクト func を適用し、any() は真を返す要素がひとつでもあれば true を返します。every() は偽を返す要素が一つでもあれば false を返します。Ｃ++の algorithm には同等の機能を持つ関数 any_of() と all_of() が用意されています。
</p>
<p> シーケンス自身を渡す場合は次のようになります。
</p>
<pre class="list">
リスト : 別解

template&lt;class T, class F&gt;
bool any(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (func(x)) return true;
  return false;
}

template&lt;class T, class F&gt;
bool every(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (!func(x)) return false;
  return true;
}
</pre>
<p> 範囲 for 文を使えば簡単にプログラムすることができます。
</p>
<h4 id="ans28">●解答28</h4>
<pre class="list">
リスト : iota と tabulate

template&lt;class T&gt;
void iota(T&amp; seq, int n)
{
  for (auto&amp; x : seq) x = n++;
}

template&lt;class T, class F&gt;
void tabulate(T&amp; seq, int n, F func)
{
  for (auto&amp; x : seq) x = func(n++);
}
</pre>
<p> iota() は範囲 for 文で要素への参照 x に整数値 n をセットしていくだけです。tabulate() は func(n++) をセットしていくだけです。なお、Ｃ++ (C++11) の STL numeric には同等の機能を持つ関数 iota() が用意されています。
</p>
<h4 id="ans29">●解答29</h4>
<p> シーケンスをイテレータ [first, last) で渡す場合は次のようになります。
</p>
<pre class="list">
リスト : シーケンスの置換

template&lt;class It, class U&gt;
void substitute(const U&amp; x, const U&amp; y, It first, It last)
{
  while (first != last) {
    if (*first == x) *first = y;
    first++;
  }
}

template&lt;class It, class U, class F&gt;
void substitute_if(F func, const U&amp; y, It first, It last)
{
  while (first != last) {
    if (func(*first)) *first = y;
    first++;
  }
}
</pre>
<p> substitute() は *frist と引数 x が等しいとき、*first に引数 y を代入します。substitute_if() は func(*first) が真を返すとき、*first に y を代入します。
</p>
<p> シーケンス自身を渡す場合は次のようになります。
</p>
<pre class="list">
リスト : 別解

template&lt;class T, class U&gt;
void substitute(const U&amp; x, const U&amp; y, T&amp; seq)
{
  for (auto&amp; z : seq) {
    if (z == x) z = y;
  }
}

template&lt;class T, class U, class F&gt;
void substitute_if(F func, const U&amp; y, T&amp; seq)
{
  for (auto&amp; x : seq) {
    if (func(x)) x = y;
  }
}
</pre>
<p> どちらの関数も範囲 for 文を使うと簡単にプログラムすることができます。
</p>
<h4 id="ans30">●解答30</h4>
<pre class="list">
リスト : 連想リスト

template&lt;class K, class V, class T&gt;
void acons(const K&amp; key, const V&amp; val, T&amp; seq)
{
  seq.emplace_front(key, val);
}

template&lt;class K, class It&gt;
It assoc(const K&amp; key, It first, It last)
{
  while (first != last) {
    if (first-&gt;first == key) return first;
    ++first;
  }
  return first;
}
</pre>
<p> テンプレート仮引数の K がキーを、V が値を表します。acons() は emplace_front() を使うと簡単です。これで、シーケンスの先頭にキーと値の組を追加することができます。assoc() はイテレータ [first, last) の中からキー key を探索し、見つけたらその組を指し示すイテレータを返します。見つからない場合は last を返します。
<?p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
//
// yacp03.cpp : Yet Another C++ Problems (3)
//
//              Copyright (C) 2015 Makoto Hiroi
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
using namespace std;

// Q21 最大値と最小値
template&lt;class It&gt;
It maximum(It first, It last)
{
  if (first == last) return last;
  It m = first++;
  while (first != last) {
    if (*m &lt; *first) m = first;
    ++first;
  }
  return m;
}

template&lt;class It&gt;
It minimum(It first, It last)
{
  if (first == last) return last;
  It m = first++;
  while (first != last) {
    if (*m &gt; *first) m = first;
    ++first;
  }
  return m;
}

// Q22
template&lt;class T, class U&gt;
bool member(const T&amp; seq, const U&amp; val)
{
  for (auto&amp; x : seq)
    if (x == val) return true;
  return false;
}

template&lt;class It, class T&gt;
bool member(It first, It last, const T&amp; val)
{
  while (first != last)
    if (*first++ == val) return true;
  return false;
}

template&lt;class T, class U&gt;
int position(const T&amp; seq, const U&amp; val)
{
  int i = 0;
  for (auto&amp; x : seq) {
    if (x == val) return i;
    i++;
  }
  return -1;
}

template&lt;class It, class T&gt;
int position(It first, It last, const T&amp; val)
{
  int i = 0;
  while (first != last) {
    if (*first++ == val) return i;
    i++;
  }
  return -1;
}

template&lt;class T, class U&gt;
int count(const T&amp; seq, const U&amp; val)
{
  int c = 0;
  for (auto&amp; x : seq)
    if (x == val) c++;
  return c;
}

template&lt;class It, class T&gt;
int count(It first, It last, const T&amp; val)
{
  int c = 0;
  while (first != last)
    if (*first++ == val) c++;
  return c;
}

// Q23
template&lt;class T, class F&gt;
bool member_if(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (func(x)) return true;
  return false;
}

template&lt;class It, class F&gt;
bool member_if(It first, It last, F func)
{
  while (first != last)
    if (func(*first++)) return true;
  return false;
}

template&lt;class T, class F&gt;
int position_if(const T&amp; seq, F func)
{
  int i = 0;
  for (auto&amp; x : seq)
    if (func(x)) return i;
  return -1;
}

template&lt;class It, class F&gt;
int position_if(It first, It last, F func)
{
  int i = 0;
  while (first != last) {
    if (func(*first++)) return i;
    i++;
  }
  return -1;
}

template&lt;class T, class F&gt;
int count_if(const T&amp; seq, F func)
{
  int c = 0;
  for (auto&amp; x : seq)
    if (func(x)) c++;
  return c;
}

template&lt;class It, class F&gt;
int count_if(It first, It last, F func)
{
  int c = 0;
  while (first != last)
    if (func(*first++)) c++;
  return c;
}

// Q24
template&lt;class T, class F&gt;
T mapcar(const T&amp; seq, F func)
{
  T new_seq(seq.size());
  auto iter = new_seq.begin();
  for (auto&amp; x : seq)
    *iter++ = func(x);
  return new_seq;
}

template&lt;class It, class F&gt;
It mapcar(It first, It last, F func, It result)
{
  while (first != last)
    *result++ = func(*first++);
  return result;
}

// Q25
template&lt;class It, class U&gt;
It remove(It first, It last, const U&amp; val)
{
  It result = first;
  while (first != last) {
    if (*first != val) *result++ = *first;
    ++first;
  }
  return result;
}

template&lt;class It, class F&gt;
It remove_if(It first, It last, F func)
{
  It result = first;
  while (first != last) {
    if (!func(*first)) *result++ = *first;
    ++first;
  }
  return result;
}

// Q26
template&lt;class T, class U, class F&gt;
U fold_left(cost T&amp; seq, U init, F func)
{
  for (auto&amp; x : seq) init = func(init, x);
  return init;
}

template&lt;class T, class U, class F&gt;
U fold_right(const T&amp; seq, U init, F func)
{
  for (auto iter = seq.crbegin(); iter != seq.crend(); ++iter)
    init = func(*iter, init);
  return init;
}

template&lt;class It, class T, class F&gt;
T fold(It first, It last, T init, F func)
{
  while (first != last) init = func(init, *first++);
  return init;
}

// Q27
template&lt;class T, class F&gt;
bool any(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (func(x)) return true;
  return false;
}

template&lt;class It, class F&gt;
bool any(It first, It last, F func)
{
  while (first != last)
    if (func(*first++)) return true;
  return false;
}

template&lt;class T, class F&gt;
bool every(const T&amp; seq, F func)
{
  for (auto&amp; x : seq)
    if (!func(x)) return false;
  return true;
}

template&lt;class It, class F&gt;
bool every(It first, It last, F func)
{
  while (first != last)
    if (!func(*first++)) return false;
  return true;
}

// Q28
template&lt;class T&gt;
void iota(T&amp; seq, int n)
{
  for (auto&amp; x : seq) x = n++;
}

template&lt;class T, class F&gt;
void tabulate(T&amp; seq, int n, F func)
{
  for (auto&amp; x : seq) x = func(n++);
}

// Q29
template&lt;class T, class U&gt;
void substitute(const U&amp; x, const U&amp; y, T&amp; seq)
{
  for (auto&amp; z : seq) {
    if (z == x) z = y;
  }
}

template&lt;class It, class U&gt;
void substitute(const U&amp; x, const U&amp; y, It first, It last)
{
  while (first != last) {
    if (*first == x) *first = y;
    first++;
  }
}

template&lt;class T, class U, class F&gt;
void substitute_if(F func, const U&amp; y, T&amp; seq)
{
  for (auto&amp; x : seq) {
    if (func(x)) x = y;
  }
}

template&lt;class It, class U, class F&gt;
void substitute_if(F func, const U&amp; y, It first, It last)
{
  while (first != last) {
    if (func(*first)) *first = y;
    first++;
  }
}

// Q30 連想リスト (emplace_front() が必要)
template&lt;class K, class V, class T&gt;
void acons(const K&amp; key, const V&amp; val, T&amp; seq)
{
  seq.emplace_front(key, val);
}

template&lt;class K, class It&gt;
It assoc(const K&amp; key, It first, It last)
{
  while (first != last) {
    if (first-&gt;first == key) return first;
    ++first;
  }
  return first;
}

template&lt;class T&gt;
void print_seq(const T&amp; seq)
{
  for (auto&amp; x : seq) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
}

bool is_even(int x) { return x % 2 == 0; }
bool is_odd(int x) { return x % 2 != 0; }
int square(int x) { return x * x; }

int main()
{
  vector&lt;int&gt; a = {1, 3, 5, 7, 9};
  list&lt;int&gt; b = {2, 4, 6, 8, 10};
  cout &lt;&lt; "-- maximum --\n";
  auto m1 = maximum(a.begin(), a.end());
  cout &lt;&lt; *m1 &lt;&lt; endl;
  auto m2 = maximum(b.begin(), b.end());
  cout &lt;&lt; *m2 &lt;&lt; endl;
  cout &lt;&lt; "-- minimum --\n";
  auto m3 = minimum(a.begin(), a.end());
  cout &lt;&lt; *m3 &lt;&lt; endl;
  auto m4 = minimum(b.begin(), b.end());
  cout &lt;&lt; *m4 &lt;&lt; endl;
  cout &lt;&lt; "-- member --\n";
  cout &lt;&lt; member(a, 1) &lt;&lt; endl;
  cout &lt;&lt; member(a, 10) &lt;&lt; endl;
  cout &lt;&lt; member(b, 1) &lt;&lt; endl;
  cout &lt;&lt; member(b, 10) &lt;&lt; endl;  
  cout &lt;&lt; member(a.begin(), a.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; member(a.begin(), a.end(), 10) &lt;&lt; endl;
  cout &lt;&lt; member(b.begin(), b.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; member(b.begin(), b.end(), 10) &lt;&lt; endl;
  cout &lt;&lt; "-- position--\n";
  cout &lt;&lt; position(a, 1) &lt;&lt; endl;
  cout &lt;&lt; position(a, 10) &lt;&lt; endl;
  cout &lt;&lt; position(b, 1) &lt;&lt; endl;
  cout &lt;&lt; position(b, 10) &lt;&lt; endl;
  cout &lt;&lt; position(a.begin(), a.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; position(a.begin(), a.end(), 10) &lt;&lt; endl;
  cout &lt;&lt; position(b.begin(), b.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; position(b.begin(), b.end(), 10) &lt;&lt; endl;
  cout &lt;&lt; "-- count --\n";
  cout &lt;&lt; count(a, 1) &lt;&lt; endl;
  cout &lt;&lt; count(a, 10) &lt;&lt; endl;
  cout &lt;&lt; count(b, 1) &lt;&lt; endl;
  cout &lt;&lt; count(b, 10) &lt;&lt; endl;
  cout &lt;&lt; count(a.begin(), a.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; count(a.begin(), a.end(), 10) &lt;&lt; endl;
  cout &lt;&lt; count(b.begin(), b.end(), 1) &lt;&lt; endl;
  cout &lt;&lt; count(b.begin(), b.end(), 10) &lt;&lt; endl;

  cout &lt;&lt; "-- member_if --\n";
  cout &lt;&lt; member_if(a, is_even) &lt;&lt; endl;
  cout &lt;&lt; member_if(a, is_odd) &lt;&lt; endl;
  cout &lt;&lt; member_if(b, is_even) &lt;&lt; endl;
  cout &lt;&lt; member_if(b, is_odd) &lt;&lt; endl;
  cout &lt;&lt; member_if(a.begin(), a.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; member_if(a.begin(), a.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; member_if(b.begin(), b.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; member_if(b.begin(), b.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; "-- position_if --\n";
  cout &lt;&lt; position_if(a, is_even) &lt;&lt; endl;
  cout &lt;&lt; position_if(a, is_odd) &lt;&lt; endl;
  cout &lt;&lt; position_if(b, is_even) &lt;&lt; endl;
  cout &lt;&lt; position_if(b, is_odd) &lt;&lt; endl;
  cout &lt;&lt; position_if(a.begin(), a.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; position_if(a.begin(), a.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; position_if(b.begin(), b.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; position_if(b.begin(), b.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; "-- count_if --\n";
  cout &lt;&lt; count_if(a, is_even) &lt;&lt; endl;
  cout &lt;&lt; count_if(a, is_odd) &lt;&lt; endl;
  cout &lt;&lt; count_if(b, is_even) &lt;&lt; endl;
  cout &lt;&lt; count_if(b, is_odd) &lt;&lt; endl;
  cout &lt;&lt; count_if(a.begin(), a.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; count_if(a.begin(), a.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; count_if(b.begin(), b.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; count_if(b.begin(), b.end(), is_odd) &lt;&lt; endl;

  cout &lt;&lt; "-- mapcar --\n";
  vector&lt;int&gt; c1 = mapcar(a, square);
  print_seq(c1);
  list&lt;int&gt; c2 = mapcar(b, square);
  print_seq(c2);
  vector&lt;int&gt; d1(a.size());
  mapcar(a.begin(), a.end(), square, d1.begin());
  print_seq(d1);
  list&lt;int&gt; d2(b.size());
  mapcar(b.begin(), b.end(), square, d2.begin());
  print_seq(d2);
  cout &lt;&lt; "-- remove --\n";
  vector&lt;int&gt; e1 = {1, 2, 3, 4, 5, 6, 7, 8};
  auto iter1 = remove(e1.begin(), e1.end(), 5);
  for (auto iter = e1.begin(); iter != iter1; ++iter)
    cout &lt;&lt; *iter &lt;&lt; " ";
  cout &lt;&lt; endl;
  auto iter2 = remove_if(e1.begin(), e1.end(), is_even);
  for (auto iter = e1.begin(); iter != iter2; ++iter)
    cout &lt;&lt; *iter &lt;&lt; " ";
  cout &lt;&lt; endl;
  list&lt;int&gt; e2 = {1, 2, 3, 4, 5, 6, 7, 8};
  auto iter3 = remove(e2.begin(), e2.end(), 5);
  for (auto iter = e2.begin(); iter != iter3; ++iter)
    cout &lt;&lt; *iter &lt;&lt; " ";
  cout &lt;&lt; endl;
  auto iter4 = remove_if(e2.begin(), e2.end(), is_even);
  for (auto iter = e2.begin(); iter != iter4; ++iter)
    cout &lt;&lt; *iter &lt;&lt; " ";
  cout &lt;&lt; endl;
  cout &lt;&lt; "-- fold --\n";
  cout &lt;&lt; fold_left(a, 0, plus&lt;int&gt;()) &lt;&lt; endl;
  cout &lt;&lt; fold_right(a, 0, plus&lt;int&gt;()) &lt;&lt; endl;
  cout &lt;&lt; fold_left(b, 0, plus&lt;int&gt;()) &lt;&lt; endl;
  cout &lt;&lt; fold_right(b, 0, plus&lt;int&gt;()) &lt;&lt; endl;
  cout &lt;&lt; fold(a.begin(), a.end(), 0, plus&lt;int&gt;()) &lt;&lt; endl;
  cout &lt;&lt; fold(b.begin(), b.end(), 0, plus&lt;int&gt;()) &lt;&lt; endl;

  cout &lt;&lt; "-- any --\n";
  cout &lt;&lt; any(a, is_even) &lt;&lt; endl;
  cout &lt;&lt; any(a, is_odd) &lt;&lt; endl;
  cout &lt;&lt; any(b, is_even) &lt;&lt; endl;
  cout &lt;&lt; any(b, is_odd) &lt;&lt; endl;
  cout &lt;&lt; any(a.begin(), a.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; any(a.begin(), a.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; any(b.begin(), b.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; any(b.begin(), b.end(), is_odd) &lt;&lt; endl;

  cout &lt;&lt; "-- every --\n";
  cout &lt;&lt; every(a, is_even) &lt;&lt; endl;
  cout &lt;&lt; every(a, is_odd) &lt;&lt; endl;
  cout &lt;&lt; every(b, is_even) &lt;&lt; endl;
  cout &lt;&lt; every(b, is_odd) &lt;&lt; endl;
  cout &lt;&lt; every(a.begin(), a.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; every(a.begin(), a.end(), is_odd) &lt;&lt; endl;
  cout &lt;&lt; every(b.begin(), b.end(), is_even) &lt;&lt; endl;
  cout &lt;&lt; every(b.begin(), b.end(), is_odd) &lt;&lt; endl;
  
  cout &lt;&lt; "-- iota  --\n";
  vector&lt;int&gt; h1(10);
  iota(h1, 1);
  for (int x : h1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  list&lt;int&gt; h2(10);
  iota(h2, 11);
  for (int x : h2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  cout &lt;&lt; "-- tabulate --\n";
  vector&lt;int&gt; i1(10);
  tabulate(i1, 1, square);
  for (int x : i1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  list&lt;int&gt; i2(10);
  tabulate(i2, 11, square);
  for (int x : i2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;

  cout &lt;&lt; "-- substitute --\n";
  vector&lt;int&gt; j1 = {1, 2, 3, 1, 2, 3, 1, 2, 3};
  substitute(2, 4, j1);
  for (int x : j1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  substitute(1, 10, j1.begin(), j1.end());
  for (int x : j1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  list&lt;int&gt; j2 = {1, 2, 3, 1, 2, 3, 1, 2, 3};
  substitute(2, 4, j2);
  for (int x : j2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  substitute(1, 10, j2.begin(), j2.end());
  for (int x : j2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;

  cout &lt;&lt; "-- substitute_if --\n";
  vector&lt;int&gt; k1 = {1,2,3,4,5,6,7,8};
  substitute_if(is_even, 0, k1);
  for (int x : k1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  substitute_if(is_odd, 1, k1.begin(), k1.end());
  for (int x : k1) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  list&lt;int&gt; k2 = {1,2,3,4,5,6,7,8};
  substitute_if(is_even, 0, k2);
  for (int x : k2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  substitute_if(is_odd, 1, k2.begin(), k2.end());
  for (int x : k2) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;

  cout &lt;&lt; "-- acons --\n";
  list&lt;pair&lt;string, int&gt;&gt; alist;
  acons("foo", 1, alist);
  acons("bar", 2, alist);
  acons("baz", 3, alist);
  for (auto&amp; p : alist)
    cout &lt;&lt; p.first &lt;&lt; "," &lt;&lt; p.second &lt;&lt; " ";
  cout &lt;&lt; endl;
  auto aiter1 = assoc("foo", alist.begin(), alist.end());
  if (aiter1 != alist.end())
    cout &lt;&lt; aiter1-&gt;second &lt;&lt; endl;
  else
    cout &lt;&lt; "not found\n";
  auto aiter2 = assoc("oops", alist.begin(), alist.end());
  if (aiter2 != alist.end())
    cout &lt;&lt; aiter2-&gt;second &lt;&lt; endl;
  else
    cout &lt;&lt; "not found\n";
  
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
-- maximum --
9
10
-- minimum --
1
2
-- member --
1
0
0
1
1
0
0
1
-- position--
0
-1
-1
4
0
-1
-1
4
-- count --
1
0
0
1
1
0
0
1
-- member_if --
0
1
1
0
0
1
1
0
-- position_if --
-1
0
0
-1
-1
0
0
-1
-- count_if --
0
5
5
0
0
5
5
0
-- mapcar --
1 9 25 49 81 
4 16 36 64 100 
1 9 25 49 81 
4 16 36 64 100 
-- remove --
1 2 3 4 6 7 8 
1 3 7 
1 2 3 4 6 7 8 
1 3 7 
-- fold --
25
25
30
30
25
30
-- any --
0
1
1
0
0
1
1
0
-- every --
0
1
1
0
0
1
1
0
-- iota  --
1 2 3 4 5 6 7 8 9 10 
11 12 13 14 15 16 17 18 19 20 
-- tabulate --
1 4 9 16 25 36 49 64 81 100 
121 144 169 196 225 256 289 324 361 400 
-- substitute --
1 4 3 1 4 3 1 4 3 
10 4 3 10 4 3 10 4 3 
1 4 3 1 4 3 1 4 3 
10 4 3 10 4 3 10 4 3 
-- substitute_if --
1 0 3 0 5 0 7 0 
1 0 1 0 1 0 1 0 
1 0 3 0 5 0 7 0 
1 0 1 0 1 0 1 0 
-- acons --
baz,3 bar,2 foo,1 
1
not found
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp21.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp23.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>