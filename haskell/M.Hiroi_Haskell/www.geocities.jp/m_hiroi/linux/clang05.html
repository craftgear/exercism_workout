<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881808</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang04.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>ポインタ</h3>
<p> プログラミング言語の学習には、どの言語にもいくつかの難関があります。Ｃ言語の場合、「ポインタ」が最大の難関と言われていますが、コンピュータの基本 (CPU やメモリの概念) を正しく理解していれば、けっして難しい話ではありません。
</p>
<p> 問題があるとすれば、Ｃ言語のポインタが不適切な操作や演算によってプログラムを簡単に暴走させてしまうことでしょう。もともとＣ言語は、UNIX という OS を記述するために開発されたプログラミング言語です。マシン語なみの操作ができないようでは役に立たないわけで、ポインタという危険なものでもユーザーに開放されているわけです。
</p>

<p> まず最初に、基本となるメモリの構成から説明しましょう。
</p>

<h4>●メモリの構成</h4>
<p> メモリにはプログラムやデータが記憶されています。メモリのことを「主記憶装置」といいます。CPU はメモリに格納されているプログラムを実行します。ハードディスクや CD-ROM, USB メモリなどに格納されているプログラムは、メモリに読み込まないと実行することはできません。
</p>
<p> メモリ以外の記憶装置を「補助記憶装置」といいます。ハードディスクや CD-ROM, USB メモリなどいろいろな記憶装置がありますが、すべての方法に共通しているのは、情報をなんらかの方法で ON / OFF という 2 つの状態で表していることです。
</p>
<p> この ON / OFF を数値の 1 と 0 に対応させます。つまり、コンピュータは情報を 0 と 1 で表すわけです。これを「ビット (bit) 」といいます。ひとつのビットでは、0 か 1 かの 2 つの情報しか表せませんが、使用するビットの数を増やすと、それだけたくさんの情報を表すことができます。たとえば、4 ビット使用すると 16 通りの情報を表すことができます。このビットをたくさん集めたものがメモリなのです。
</p>
<p> ビットでは情報が細かすぎるので、いくつかのビットをまとめた「バイト (byte) 」を単位として、メモリは構成されています。現在は、1 バイトを 8 ビットとしてメモリを構成するコンピュータ <sup><a href="clang05.html#note1">[*1]</a></sup> がほとんどです。1 バイトは数値で表すと 0 から 255 までの 256 通りの情報を記憶できます。
</p>
<p> メモリから値を読み出す、または書き込む場合、最小の大きさがバイトとなります。どのメモリから値を読み出すのか、またはどのメモリに値を書き込むのかを指定するために、メモリにはバイト単位で「アドレス (番地 : address) 」がつけられています。これは私たちの住所や電話番号と同じです。メモリの場合は単純に数値で表します。下図を見てください。
</p>
<pre class="fig">
                        ビ  ッ  ト
              ７  ６  ５  ４  ３  ２  １  ０
            ┌─┬─┬─┬─┬─┬─┬─┬─┐
        ０  │  │  │  │  │  │  │  │  │
            ├─┼─┼─┼─┼─┼─┼─┼─┤
        １  │  │  │  │  │  │  │  │  │
  ア        ├─┼─┼─┼─┼─┼─┼─┼─┤
        ２  │  │  │  │  │  │  │  │  │
  ド        ├─┼─┼─┼─┼─┼─┼─┼─┤
        ・  │  │  │  │  │  │  │  │  │
  レ    ・  │  │  │  │  │  │  │  │  │
        ・  │  │  │  │  │  │  │  │  │
  ス    ・  │  │  │  │  │  │  │  │  │
        ・  │  │  │  │  │  │  │  │  │
            ├─┼─┼─┼─┼─┼─┼─┼─┤
      Ｍ－１│  │  │  │  │  │  │  │  │
            ├─┼─┼─┼─┼─┼─┼─┼─┤
        Ｍ  │  │  │  │  │  │  │  │  │
            └─┴─┴─┴─┴─┴─┴─┴─┘
            │←───   １バイト   ───→│

                   図 : メモリの構成
</pre>

<p> Ｃ言語の場合、配列は 0 から数えましたね。コンピュータの世界では、ビットもアドレスも 0 から数えるのが普通です。32 bit CPU の場合、M の値は 2<sup>32</sup> - 1 = 4,294,967,295 (約 4 ギガ: giga) になります。64 bit CPU の場合は 2<sup>64</sup> - 1 = 18,446,744,073,709,551,615 (約 18 エクサ: exa <sup><a href="clang05.html#note2">[*2]</a></sup>) になります。
</p>
<p> 数値計算をするときなど、1 バイトでは情報量が少ない場合は、2 バイトまたは 4 バイトまとめてメモリを使用します。文字を表したい場合は、文字を数値に対応させます。アルファベットは 26 種類ありますから、大文字小文字、そしてほかの記号を合わせても 1 バイトあれば表現できます。たとえば、アスキーコードという規則では、A という文字は 0x41 に対応します。漢字は 1 バイトで表現できないので、複数のバイトを使います。よく使われている漢字コードに JIS, シフトJIS, EUC などがありますが、最近は UTF-8 を採用する Unix 系 OS やプログラミング言語が増えてきました。
</p>
<p> グラフィックの場合は、点 (ドット : dot) をメモリに対応させて表現します。たとえば、1 ドットを 1 バイトで表現してみましょう。そのメモリの内容が 0 ならば、ドットが書かれていないことにします。それ以外のときはドットが書かれているという規則にします。このとき、1 から 255 に対応する色を決めておけば、256 色の絵が描けるわけです。もし、65536 色の絵を描くのであれば、１バイトでは表現できないので、1 ドットにつき 2 バイト使用することになります。フルカラー (1600 万色) 表示であれば、1 ドットにつき 3 バイト必要になるわけです。
</p>
<p> このように、メモリに格納されるデータは、単なる数値に過ぎないのですが、使うソフトウェアによってその意味は異なるのです。ある場合は、数値計算のために使用され、ほかでは文字を格納するために、またあるときはグラフィックデータを保持します。
</p>
<p> メモリをどのように使うかは、プログラマが決めます。そして、それを実現するための道具がプログラミング言語なのです。変数、配列、文字列といったデータも、すべてメモリに割り当てられますが、マシン語以外の高級言語ではアドレスを意識することはありません。プログラマは変数を定義するだけで、メモリの割り当てといった面倒なことはすべてプログラミング言語 (と OS) が行ってくれます。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 昔は 1 word  = 16 ビットでメモリを構成するコンピュータもありました。<br><br>
<a name="note2">[*2]</a> ギガやエクサは数を表す接頭辞で、大きな値ではメガ (mega) = 10<sup>6</sup>, ギガ (giga) = 10<sup>9</sup>, テラ (tera) = 10<sup>12</sup>, ペタ (peta) = 10<sup>15</sup>, エクサ (exa) = 10<sup>18</sup> などがあります。
</div>

<h4>●ポインタの基本</h4>
<p> 一般に、プログラミング言語で扱う名前は、そのデータが割り当てられたメモリの先頭アドレスを表しています。変数名や配列名は、そのデータが割り当てられたメモリの先頭アドレスであり、関数名は、そのコードが配置されたメモリの先頭アドレス (関数の開始アドレス) を表しています。高水準と呼ばれるプログラミング言語の場合、名前から実際のアドレスを求めることはできません。プログラマが勝手にメモリ割り当てを操作したり変更すると困る場合があるからです。もっとも、そのようなことをしなくてもプログラミングできないようでは、とても高水準とはいえません。
</p>
<p> ところがＣ言語の場合は違います。Ｃ言語では名前からアドレスを求める演算子 &amp; <sup><a href="clang05.html#note3">[*3]</a></sup> が用意されているのです。変数名にこの演算子を適用することで、変数が割り当てられたメモリの先頭アドレスを求めることができます。また、配列名や関数名はデータやコードの先頭アドレスに付けられた名前にすぎず、&amp; 演算子を使わなくてもアドレスとして使用することができます。
</p>
<p> そして、Ｃ言語ではアドレスを格納する変数を定義することができます。これが「ポインタ」です。アドレスは整数値ですから、ポインタの中身は整数値です。ですが、その値はある変数が割り当てられているメモリの先頭アドレスです。つまり、ポインタは「ある変数を指し示している変数」ということになります。また、関数名もアドレスを示しているのですから、ポインタに代入することができます。これを「関数へのポインタ」と呼びます。どちらにしても、ポインタはあるデータを指し示している変数なのです。これを図に示すと次のようになります。
</p>
<pre class="fig">

   番地 0x68000                                        0x70000
         ↓                                              ↓
       ┬─┬─┬─┬─┬─┬─┬─┬─┬  ┬─┬─┬─┬─┬─┬─┬─┬
メモリ │   0x70000    │  │  │  │  │～│  │  │  │   0x100000   │
       ┴─┴─┴─┴─┴─┴─┴─┴─┴  ┴─┴─┴─┴─┴─┴─┴─┴
      変数 p   │                                      ↑ 変数 i
               └───────────────────┘

                           図 : ポインタ
</pre>
<p> 変数 p はポインタです。図に示すように、ポインタもメモリ <sup><a href="clang05.html#note4">[*4]</a></sup> に割り当てられます。この例では 0x68000 番地になっています。CPU が 32 bit の場合、Ｃコンパイラはポインタに 4 バイトのメモリを割り当てる場合がほとんどで、0 から 0xFFFFFFFF までのアドレス指定が可能になります。これだと約 4 G バイトのメモリを扱うことができます。CPU が 64 bit の場合、ポインタには 8 バイトのメモリを割り当てることになりますが、本稿ではポインタの大きさは 4 バイトとして説明することにします。
</p>
<p> 変数 i は int 型としましょう。上図の場合、変数 i は 0x70000 番地から割り当てられていて、値は 0x100000 です。変数 p はポインタなので、変数 i のアドレスを代入することができます。すると、図のように変数 p の値は 0x70000 となり、変数 i を指し示すことになります。そして、ポインタ p を使って、変数 i の値を読み書きすることができるのです。これがポインタの基本的な考え方です。
</p>
<p> ポインタは次のように宣言します。
</p>
<pre class="item">
データ型 *変数名;
データ型 *変数名 = &amp;変数;
</pre>
<p> ポインタは変数名の前にアスタリスク ( <b>*</b> ) を付けて表します。たとえば、int *p; とすると、p は int 型のポインタになります。変数 i を参照したい場合、アドレス演算子を使って p =&amp;i; とします。これで変数 p は int 型の変数 i を指すポインタになります。また、ポインタを宣言するとき、初期値に変数のアドレスを指定することもできます。
</p>
<p> p が参照している変数の値にアクセスする方法も簡単です。変数名の前に * を付けて *p とするだけです。これでポイントしている変数 (この場合は int 型の整数) にアクセスすることができます。つまり、*p は p が保持しているアドレスに格納されているデータを参照 <SUP><A href="clang05.html#note5">[*5]</A></SUP> するわけです。たとえば、int j = *p; とすれば、変数 j の値は 0x100000 になります。また、*p = 10 とすれば、p が指し示している変数の値を書き換えるので、i の値は 10 になります。
</p>

<p> それでは実際にポインタを使ってみましょう。なお、図のアドレスは説明のためのもので、これから示すプログラムとは関係ありません。プログラムがロードされるアドレスは実行環境によって異なるので、変数 i と p のアドレスは実際にプログラムを実行してみないとわからないのです。ご注意くださいませ。
</p>
<pre class="list">
リスト : ポインタの使用例 (sample50.c)

#include &lt;stdio.h&gt;

int main(void)
{
  int i = 10;
  int *p = &amp;i;
  printf("%p\n", &amp;i);
  printf("%p\n", p);
  printf("i = %d\n", i);
  printf("*p = %d\n", *p);
  *p = 100;
  printf("i = %d\n", i);
  printf("*p = %d\n", *p);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample50
0xbfb44540
0xbfb44540
i = 10
*p = 10
i = 100
*p = 100
mhiroi@mhiroi-VirtualBox:~/clang$ cat sample40.c
</pre>
<p> printf の %p はポインタ変換指定子で、引数がポインタであれば格納しているアドレスを 16 進数で表示します。&amp;i のように変数のアドレスを渡してもかまいません。ポインタ p は &amp;i で初期化されているので、どちらも同じアドレスが表示され、i と *p は同じ値 10 が表示されます。*p に 100 を代入すれば、i の値も 100 に書き換えられます。p は変数 i のアドレスを保持し、*p はそのアドレスに格納されているデータにアクセスできるのですから、*p に書き込みすれば変数 i の値も書き変わるのは当然ですね。
</p>
<h4>●ポインタの利点と欠点</h4>
<p> ところでこのポインタ、一体何の役に立つのでしょうか。Ｃ言語の場合、次の利点があります。
</p>
<pre class="item">
(1) 「参照呼び (call by reference) 」を実現する
(2) コンパクトで効率的なプログラムを書くことができる
</PRE>
<p> (1) ですが、Ｃ言語の関数は「値呼び (call by value) 」です。関数の引数にポインタを渡すことで、呼び出し先の関数から呼び出し元の関数に定義されている変数にアクセスすることができるようになります。これはあとで詳しく説明します。
</p>
<p> (2) はアドレス計算によって実現されます。ポインタが格納しているアドレスは単なる正の整数値です。四則演算ができるわけではありませんが、整数値の代入や加減算 <sup><a href="clang05.html#note6">[*6]</a></sup>、ポインタ同士の比較を行うことができます。とくに、インクリメント (++)、デクリメント (--) 演算子と組み合わせることで、効率的なプログラムを記述することができます。
</p>
<p> このほかに、プログラムの実行時にメモリを取得するときや、連結リストや二分木といった複雑なデータ構造を作るとき、ポインタはとても役に立ちます。
</p>
<p> もっとも、いいことばかりではありません。よくある間違いがポインタの初期化忘れです。局所変数の場合、ポインタを宣言しただけでは、その値は定まっていません。どこをポイントしているのかわからないのですから大変危険です。また、ポインタには整数値を代入することができますが、次のように 0 を代入したらどうなるでしょうか。
</p>

<pre class="list">
リスト : ポインタの危険な操作 (sample51.c)

#include &lt;stdio.h&gt;

int *q;

int main(void)
{
  int *p;
  p = 0;
  printf("%p\n", p);
  printf("%p\n", q);
  printf("%d\n", *p);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample51
(nil)
(nil)
Segmentation fault (コアダンプ)
</pre>
<p> 近代的な OS の場合、メモリはシステムエリアとユーザーエリアに区別されていて、ユーザーのプログラムがシステムエリアにアクセスすることを禁止しています。もし、このメモリにアクセスすると OS で Segmentation fault という例外 (エラー) が発生します。
</p>
<p> Ｃ言語の場合、アドレス 0 を指すポインタを「ヌルポインタ (null pointer) 」といい、マクロ記号 NULL で表します。実際には、次のように定義されています。
</p>
<pre class="item">
#define NULL (void *)0
</pre>
<p> void * は void 型のポインタを表していて、NULL は整数値 0 を void * に型変換した値になります。明示的に型変換を行うことを「キャスト (cast) 」といい、望む型をカッコでくくって式の前につけます。void * はどんな型のポインタにもキャストせずに代入したり、値を比較することができます。
</p>
<p> printf の p 変換指定子はヌルポインタを (nil) と表示します。ポインタを外部変数として宣言したとき、初期値を指定しないとヌルポインタに初期化されます。ご注意くださいませ。
</p>
<p> このように、ポインタの操作には危険がつきまとうのですが、そのかわりに、ハードウェアを制御するプログラム <sup><a href="clang05.html#note7">[*7]</a></sup> でも、Ｃ言語だけで作ることができます。このため、Ｃ言語は高級アセンブラとか汎用アセンブラと呼ばれています。
</p>
<div class="note">
-- note --------<BR>
<a name="note3">[*3]</a> アドレス演算子といいます。
<br><br>
<a name="note4">[*4]</a> これは一般的な話で、Ｃコンパイラの最適化によって「レジスタ」に割り当てられることもあります。レジスタ (register) とは、CPU 内部にある一時記憶メモリのことです。一般に、レジスタはメモリよりも高速にアクセスすることができるので、変数はメモリよりもレジスタに割り当てた方がプログラムを高速に実行できます。
<br><br>
<a name="note5">[*5]</a> これを「間接参照」といいます。マシン語でいえば「間接アドレッシング」ですね。Ｃ言語では * を間接演算子と呼びます。
<br><br>
<a name="note6">[*6]</a> 実は単純な加減算ではなく、データのサイズが考慮されます。たとえば、int *p というポインタに p++ という操作を行うと、p に格納されているアドレスの値は +1 されるのではなく、int の大きさである 4 が加えられます。このことにより、配列のようにデータが連続して配置されている領域では、p++ だけで次のデータをポイントすることができるわけです。
<br><br>
<a name="note7">[*7]</a> メモリマップド I/O という考え方を採用している CPU では、ハードウェアとの入出力 (I/O) は、特定のメモリ (本当はメモリではないがメモリと同じようなアクセスが可能) を介して行われます。Ｃ言語であれば、ポインタを使うことで特定のメモリにアクセスすることが可能です。
</div>

<h4>●配列とポインタ</h4>
<p> 次は配列へのポインタを考えてみましょう。Ｃ言語の場合、配列名が配列の先頭要素のアドレスを表します。たとえば、int a[100]; という配列を定義すると、配列名 a は配列の先頭要素のアドレス &amp;a[0] と同じ意味になります。Ｃ言語の配列は連続したメモリ領域に配置されるので、ポインタを使って配列の要素にアクセスすることができます。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 配列とポインタ (sample52.c)

#include &lt;stdio.h&gt;

int main(void)
{
  int a[] = {1, 2, 3, 4, 5, 6, 7, 8};
  int *p = a;
  printf("p = %p\n", p);

  printf("%d\n", *p);
  printf("%d\n", *(p + 3));
  printf("%d\n", *(p + 7));

  int *q = a + 8;
  printf("q = %p\n", q);
  while (p &lt; q) {
    printf("p = %p\n", p);
    printf("%d\n", *p++);
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample52
p = 0xbffcc79c
1
4
8
q = 0xbffcc7bc
p = 0xbffcc79c
1
p = 0xbffcc7a0
2
p = 0xbffcc7a4
3
p = 0xbffcc7a8
4
p = 0xbffcc7ac
5
p = 0xbffcc7b0
6
p = 0xbffcc7b4
7
p = 0xbffcc7b8
8
</pre>

<p> 配列 a の要素は int なので、変数 p を int 型のポインタとして宣言して、p を a の先頭要素のアドレスに初期化すれば、p を使って配列の要素にアクセスすることができます。配列名は先頭要素のアドレスを表すので、int *p = a; とすれば OK です。
</p>
<p> 要素のアクセスは簡単で、*p が先頭要素、*(p + 1) が 1 番目の要素というように、*(p + n) で n 番目の要素にアクセスすることができます。p は int 型のポイントなので、p + 1 は p のアドレスに 1 を加えるのではなく、int の大きさである 4 が加算されることに注意してください。また、*(p + 1) = 100; とすれば、a[1] の値を書き換えることができます。
</p>

<p> 配列は連続した領域に配置されるので、配列 a の領域を半区間 [p, q) (p 以上 q 未満) で表すと、[0xbffcc79c, 0xbffcc79 + 4 * 8) であることがわかります。これは int *q = a + 8; で求めることができます。ここで、*p++ とすると、*p の要素を参照したあと、ポインタ p を次の要素へ進める (アドレスを +4 する) ことができます。
</p>
<p> Ｃ言語の場合、ポインタ同士の比較は可能なので、条件 p &lt; q を満たすあいだ処理を繰り返せば、配列 a の要素を順番に表示することができます。このとき、p のアドレスが +4 ずつ増えていることに注意してください。
</p>
<p> もう一つ簡単な例を示しましょう。Ｃ言語の文字列は文字 (char) の配列なので、ポインタを使って操作することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 文字列とポインタ (sample53.c)

#include &lt;stdio.h&gt;

int main(void)
{
  char a[] = "hello, world";
  char b[] = "hello, Linux";
  char c[16];
  char *p, *q;
  // 長さ
  int len = 0;
  p = a;
  while (*p++ != '\0') len++;
  printf("%d\n", len);
  // コピー
  p = a;
  q = c;
  while ((*q++ = *p++) != '\0');
  printf("%s\n", c);
  // 比較
  p = a;
  q = b;
  while (*p == *q) {
    if (*p == '\0') break;
    p++;
    q++;
  }
  if (*p == 0 &amp;&amp; *q == 0) {
    printf("equal\n");
  } else {
    printf("not equal\n");
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample53
12
hello, world
not equal
</pre>
<p> 文字列はヌル文字 '\0' で終端されているので、文字数を数えるのは簡単です。ポインタ p を a に初期化し、ヌル文字でなければ p と len をインクリメントしていくだけです。文字列のコピーも簡単です。p を a に、q を c に初期化します。*p の値を *q に代入して、その値がヌル文字でなければ p と q をインクリメントしていきます。
</p>
<p> 文字列の比較も簡単です。p と q を初期化して、*p と *q が等しいあいだ、p と q をインクリメントします。このとき、*p がヌル文字かチェックして、そうであれば文字列の終端に到達したので break で while ループを脱出します。*p と *q がともにヌル文字であれば、文字列の内容は等しいことがわかります。そうでなければ、途中で文字が一致しなかったので、文字列は等しくないことがわかります。
</p>
<p> このように、文字列の操作はポインタを使って簡単に行うことができます。なお、Ｃ言語には文字列操作用の標準ライブラリ (string.h) が用意されているので、実際にこのようなプログラムを作る必要はありません。
</p>
<h4>●値呼びと参照呼び</h4>
<p> 一般に、関数呼び出しには二つの方法があります。一つが「値呼び (call by value) 」で、もう一つが「参照呼び (call by reference) 」です。近代的なプログラミング言語では「値呼び」が主流です。
</p>
<p> 値呼びの概念はとても簡単です。
<pre class="item">
(1) 受け取るデータを格納する変数 (仮引数) を用意する。
(2) データを引数に代入する。
(3) 関数の実行終了後、引数を廃棄する。
</pre>
<p> 値呼びのポイントは (2) です。データを引数に代入するとき、データのコピーが行われるのです。たとえば、変数 a の値が 10 の場合、関数 foo(a) を呼び出すと、実引数 a の値 10 が foo の仮引数にコピーされます。変数に格納されている値そのものを関数に渡すので、「値渡し」とか「値呼び」と呼ばれます。また、値呼びは任意の式の値を実引数として渡すことができます。たとえば foo(a + b) の場合、引数に渡された式 a + bを計算し、その結果が foo の仮引数に渡されます。
</p>
<p> 値呼びは単純でわかりやすいのですが、呼び出し先 (caller) から呼び出し元 (callee) の局所変数にアクセスできると便利な場合もあります。仮引数に対する更新が直ちに実引数にも及ぶような呼び出し方が「参照呼び」です。
</p>

<h4>●関数にポインタを渡す</h4>
<p> Ｃ言語の関数は「値呼び」ですが、引数にポインタを渡すと「参照呼び」と同様の動作を行うことができます。次の例を見てください。
</p>
<pre class="list">
リスト : 関数にポインタを渡す (sample54.c)

#include &lt;stdio.h&gt;

void swap_bad(int a, int b)
{
  int c = a;
  a = b;
  b = c;
}

void swap(int *a, int *b)
{
  int c = *a;
  *a = *b;
  *b = c;
}

int main(void)
{
  int a = 10;
  int b = 20;
  swap_bad(a, b);
  printf("a = %d, b = %d\n", a, b);
  swap(&amp;a, &amp;b);
  printf("a = %d, b = %d\n", a, b);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample54
a = 10, b = 20
a = 20, b = 10
</pre>
<p> 関数 swap はＣ言語の関数が「値呼び」であることの説明によく使われる例題です。Ｃ言語で局所変数の値を交換するには、一時的に値を格納する局所変数を使って行います。この処理を関数で行う場合、swap_bad のように引数の型を int a, int b とすると、変数の値が引数にコピーされるので、元の局所変数の値を交換することはできません。この場合、swap のように引数の型を int *a, int *b として変数のアドレスを渡すと、元の局所変数の値を交換することができます。
</p>
<h4>●配列と関数</h4>
<p> Ｃ言語の場合、関数の引数に int a[10] のような配列を宣言することはできますが、実際に配列の領域が確保されて要素がコピーされることはありません。引数 a に渡されるのは配列の先頭アドレスだけです。このとき、添字は無視されます。意味を持つのは多次元配列を渡すときです。
</p>
<p> 関数に配列を渡す場合、引数の宣言はポインタを使って int *a とするか、[ ] の中の数字を省略して int a[] とします。どちら方法でも引数 a には配列の先頭アドレスが渡されます。簡単な例を示しましょう。
</p>

<pre class="list">
リスト : 配列と関数 (sample55.c)

#include &lt;stdio.h&gt;

void foo(int a[], int n)   // int *a でもよい
{
  for (int i = 0; i &lt; n; i++)
    printf("%d ", a[i]);
  printf("\n");
  a[0] = 100;
}

int main(void)
{
  int a[8] = {1, 2, 3, 4, 5, 6, 7, 8};
  foo(a, 8);
  for (int i = 0; i &lt; 8; i++)
    printf("%d ", a[i]);
  printf("\n");
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample55
1 2 3 4 5 6 7 8 
100 2 3 4 5 6 7 8 
</pre>
<p> 関数 foo は受け取った配列 a の内容を表示します。配列の大きさは引数 n で受け取ります。最後に a[0] の値を 100 に書き換えます。foo を呼び出したあと、配列 a の内容を表示すると、先頭要素が 100 に書き換えられていて、配列 a の先頭アドレスが関数 foo に渡されていることがわかります。
</p>
<p> なお、Ｃ言語の文字列は文字の配列なので、文字列を関数に渡す場合も、配列と同様に先頭アドレスが渡されることになります。
</p>
<h4>●多段階のポインタ</h4>
<p> Ｃ言語の場合、ポインタを指すポインタを作ることができます。次の図を見てください。
</p>
<pre class="fig">

   番地 0x68000            0x69000             0x70000
       ┬─┬─┬─┬─┬  ┬─┬─┬─┬─┬  ┬─┬─┬─┬─┬
メモリ │   0x69000    │～│   0x70000    │～│   0x100000   │
       ┴─┴─┴─┴─┴  ┴─┴─┴─┴─┴  ┴─┴─┴─┴─┴
      変数 q   │          ↑変数 p│          ↑ 変数 a
               └─────┘      └─────┘

                       図 : 多段階のポインタ

</pre>
<P> 変数 q はポインタです。q はポインタ p を指しています。p は変数 a を指しています。つまり、q は p を経由して変数 a を指し示しているのです。これをＣ言語のプログラムで表すと、次のようになります。
</p>
<pre class="list">
リスト : 多段階のポインタ (sample56.c)

#include &lt;stdio.h&gt;

int main(void)
{
  int a = 100;
  int b = 1000;
  int *p = &amp;a;
  int **q = &amp;p;
  printf("%d\n", a);
  printf("%d\n", *p);
  printf("%d\n", **q);
  **q = 200;
  printf("%d\n", a);
  printf("%d\n", *p);
  printf("%d\n", **q);
  *q = &amp;b;
  printf("%d\n", b);
  printf("%d\n", *p);
  printf("%d\n", **q);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample56
100
100
100
200
200
200
1000
1000
1000
</pre>

<p> Ｃ言語の場合、ポインタを指し示すポインタは、経由するポインタと同じ数だけ * を追加します。変数 q はポインタ p を経由して変数 a を指し示すので int **q; となります。2 つのポインタを経由するのであれば、int ***q; と宣言します。
</p>
<p> ポインタ q はポインタ p を指し示すので、初期化は変数 p のアドレスをセットします。p の値は変数 a のアドレスなので、q にセットしてはいけません。もし q = p; とプログラムすると、コンパイル時にワーニングが表示されます。
</p>
<p> これで、**q とすることで変数 a の値にアクセスすることができます。**q =200; のように値を代入すると、変数 a の値を書き換えることができます。また、*q とすることで変数 p の値にアクセスすることができます。このとき、*q の値を書き換えると、ポインタ q と p は変数 a ではなく、別の値を指し示すことになります。このように、ポインタを操作するときには細心の注意が必要になります。
</p>
<h4>●ポインタ配列</h4>
<p> Ｃ言語はポインタを配列に格納することができます。
</p>
<pre class="item">
データ型 *配列名[大きさ];
</pre>

<p> 配列名の前に * を付けると、配列の要素はポインタになります。たとえば、文字列を格納する配列は次のように定義することができます。
</p>
<pre class="list">
リスト : 配列に文字列を格納する (sample57.c)

#include &lt;stdio.h&gt;

int main(void)
{
  char a[] = "foo";
  char b[] = "bar";
  char c[] = "baz";
  char d[] = "hello, world";
  char *msg[] = {a, b, c, d};
  /*
  char *msg[] = {
    "foo",
    "bar",
    "baz",
    "hello, world"
  };
  */
  for (int i = 0; i &lt; 4; i++) {
    printf("%s\n", msg[i]);
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample57
foo
bar
baz
hello, world
</pre>
<p> 変数 a, b, c, d は文字列で、それを格納する配列が msg です。msg は char *msg[] と宣言し、{a, b, c, d} で初期化します。これはコメントにあるように、直接文字列を指定することもできます。普通はコメントのような書き方をします。これで、msg の要素は文字列を指し示すアドレスが格納されます。つまり、msg[1] は "foo" で、msg[3] は "hello, world" になります。
</p>
<p> もちろん、文字列以外のポインタも格納することができます。次のリストを見てください。
</p>
<pre class="list">
リスト : 配列に int 型の配列を格納する (sample58.c)

#include &lt;stdio.h&gt;

int main(void)
{
  int a[] = {1, 2};
  int b[] = {3, 4, 5};
  int c[] = {6, 7, 8, 9};
  int *d[] = {a, b, c};
  /*
  int d[3][4] = {
    {1, 2}, 
    {3, 4, 5}, 
    {6, 7, 8, 9}
  };
  */
  printf("%d\n", *d[0]);
  printf("%d\n", *(d[0] + 1));
  printf("%d\n", d[1][0]);
  printf("%d\n", d[2][3]);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample58
1
2
3
9
</pre>
<p> 配列 a, b, c を定義し、それらを配列 d にセットします。この場合、d は int *d[] と宣言します。これで d の要素は各配列の先頭アドレスになります。なお、この場合はコメントのように多次元配列で定義したほうが簡単ですね。int d[n][m] と定義した場合、d[0] は d[0][0] の先頭アドレス、d[i] (0 &lt; n) は d[i][0] の先頭アドレスになります。
</p>
<h4>●関数へのポインタ</h4>
<p> Ｃ言語の場合、関数名はコードの先頭アドレスを表します。そのアドレスを格納する変数が「関数へのポインタ」になります。基本的な考え方は他のポインタと同様に簡単なのですが、関数へのポインタを表す構文がちょっと複雑になります。関数へのポインタの構文を示します。
</p>
<pre class="item">
返り値のデータ型 (*変数名)(引数のデータ型 仮引数名, ...);
返り値のデータ型 (*変数名)(引数のデータ型 仮引数名, ...) = 関数名;
</pre>
<p> 関数プロトタイプと同じような形式で、関数名のかわりに変数名を指定します。そして、名前の前に <b>*</b> を付けます。これでこの変数は関数へのポインタになります。仮引数名は省略してもかまいません。呼び出し方は (*変数名)(実引数, ...) とします。<del>この構文はＣ++でも同じですが、Ｃ言語にかぎり</del> <sup><a href="clang05.html#update">[修正]</a></sup> または、変数名(実引数, ... ) としてもかまいません。
</p>
<div class="note">
-- <a name="update">修正</a> (2015/08/09) --------<br>
Ｃ言語だけではなくＣ++でも 変数名(実引数, ... ) で呼び出すことができます。修正するとともにお詫び申しあげます。
</div>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 関数へのポインタ

#include &lt;stdio.h&gt;

double identity(double x)
{
  return x;
}

double square(double x)
{
  return x * x;
}

double cube(double x)
{
  return x * x * x;
}

double sumof(double (*func)(double), int n, int m)
{
  double sum = 0;
  for (; n &lt;= m; n++) {
    sum += func(n);          // (*func)(n) でもよい
  }
  return sum;
}

int main(void)
{
  double (*func)(double);
  func = identity;
  printf("%f\n", func(1.2345));
  func = square;
  printf("%f\n", func(1.2345));
  func = cube;
  printf("%f\n", func(1.2345));
  printf("%f\n", sumof(identity, 1, 100));
  printf("%f\n", sumof(square, 1, 100));
  printf("%f\n", sumof(cube, 1, 100));
  // 配列
  double (*func_tbl[])(double) = {identity, square, cube};
  for (int i = 0; i &lt; 3; i++)
    printf("%f\n", func_tbl[i](6.789));
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample52
1.234500
1.523990
1.881366
5050.000000
338350.000000
25502500.000000
6.789000
46.090521
312.908547
</pre>
<p> 関数 identity は引数 x をそのまま返します。このような関数を「恒等関数」といいます。関数 square は引数 x を二乗し、関数 cube は三乗を計算します。どの関数も引数の型は double で、返り値の型も double です。これらの関数へのポインタは double (*func)(double) で表すことができます。
</p>
<p> func = identity でポインタ func に identity のアドレスを代入し、func(1.2345) と呼び出すとポインタ経由で identity を呼び出すことができます。同様に、関数 square と cube を func にセットすれば、func(1.2345) で square や cube を呼び出すことができます。
</p>
<p> Ｃ言語の場合、関数へのポインタを使って、関数を他の関数の引数に渡すことができます。関数 sumof の第 1 引数 func は引数が double で返り値が double の関数を表します。func に identity を渡せば、n から m までの和を求めることができます。square を渡せば二乗の和を、cube を三乗の和を求めることができます。
</p>

<p> sumof のように、関数を引数として受け取る関数を「高階関数 (higher order function) 」と呼ぶことがあります。Lisp / Scheme などの関数型言語の場合、高階関数は特別なものではく、ごく普通に使用する機能です。Ｃ言語の場合、高階関数を使う機会は少ないと思いますが、標準ライブラリには配列をソートする qsort や、配列を二分探索する bsearch などの高階関数が用意されています。これはあとで試してみましょう。
</p>
<p> また、double (*func_tbl[])(double) とすれば、関数へのポインタを格納する配列を定義することができます。初期化も簡単で、{identity, square, cube} のように関数名を記述するだけです。呼び出し方も簡単で、func_tbl[0](1.2345) とすれば、func_tbl[0] に格納されている関数を呼び出すことができます。
</p>
<p> 関数へのポインタはデータ型が複雑になるので、typedef で別名を付けると便利です。typedef で別名を付ける場合、他のポインタとは違って書式はちょっと複雑になります。以下に構文を示します。
</p>
<pre class="item">
typedef 返り値のデータ型 名前(引数のデータ型 仮引数名, ...);
名前 *変数名 = 関数名;
</pre>
<pre class="item">
typedef 返り値のデータ型 (*名前)(引数のデータ型 仮引数名, ...);
名前 変数名 = 関数名;
</pre>
<p> typedef の場合、定義した "名前" または "(*名前)" の部分の "名前" が新しいデータ型名になります。最初の構文は、typedef で関数のデータ型に新しい名前を付けるもので、関数へのポインタを定義しているわけではないことに注意してください。したがって、関数へのポインタを宣言するときは、変数名の前に <b>*</b> を付ける必要があります。二番目の構文は <b>*</b> を付けて定義しているので、名前 変数; と宣言すれば関数へのポインタになります。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 関数へのポインタ (sample53.c)

#include &lt;stdio.h&gt;

// 別名の定義
typedef double (*Func)(double);

// 恒等関数
double identity(double x)
{
  return x;
}

// 二乗
double square(double x)
{
  return x * x;
}

// 三乗
double cube(double x)
{
  return x * x * x;
}

// 総和
double sumof(Func func, int n, int m)
{
  double sum = 0;
  for (; n &lt;= m; n++) {
    sum += func(n);
  }
  return sum;
}

int main(void)
{
  Func func_tbl[] = {identity, square, cube};
  for (int i = 0; i &lt; 3; i++) {
    printf("%f\n", func_tbl[i](1.2345));
    printf("%f\n", sumof(func_tbl[i], 1, 100));
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample53
1.234500
5050.000000
1.523990
338350.000000
1.881366
25502500.000000
</pre>
<p> double を受け取り double を返す関数へのポインタに typedef で別名 Func を付けます。すると、関数 sumof の引数のデータ型は Func func と表すことができ、func(実引数) で引数 func の関数を呼び出すことができます。関数へのポインタを格納する配列 func_tbl も簡単に定義することができます。
</p>
<h4>●qsort と bsearch</h4>
<p> 最後にライブラリ関数 qsort と bsearch の使い方を簡単に説明しておきましょう。これらの関数のプロトタイプはヘッダファイル stdlib.h に定義されています。
</p>
<pre class="item">
&lt;stdlib.h&gt;
void qsort(void *buff, size_t size, size_t n, int (*comp)(const void *, const void *));
void *bsearch(void *key, void *buff, size_t size, size_t n, int (*comp)(const void *, const void *));
</pre>
<p> 引数 buff が操作対象となる配列へのポインタ、size は配列の大きさ、n は要素の大きさ (バイト数)、comp が比較関数へのポインタ、bsearch の key が検索するキーへのポインタです。size_t は無符号整数を表すデータ型です。bsearch は見つけた要素へのポインタを返し、見つからない場合は NULL を返します。
</p>
<p> これらの関数は汎用的に作られているので、配列の先頭アドレスは void * で、比較関数の引数も、要素を値渡しするのではなく要素へのポインタ (void *) を渡すようになっています。関数内部では、要素の位置をアドレス (たとえば char *ptr) で管理していて、次の要素は ptr に要素の大きさ n を加えて求めます。たとえば int であれば 4 を加え、double であれば 8 を加えます。
</p>
<p> 要素を比較するときは、そのアドレスを比較関数に渡します。比較関数は要素のデータ型がわかっているので、比較するのは簡単です。comp(a, b) の返り値は a == b ならば 0 を、a &lt; b ならば負の整数、a &gt; b ならば正の整数とします。
</p>
<p> const で宣言された変数は値を変更することができません。たとえば、const int a = 10; と宣言したあと、a = 20; のように代入するとコンパイルエラーになります。ポインタの場合、たとえば const int *p であれば *p = 100 のような代入はエラーになりますが、p++ とか p = &a; のように p が保持しているアドレスを変更することは可能です。つまり、ポインタが参照している変数の値を更新できない、という意味になります。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : qsort と bsearch (sample54.c)

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define N 10

int buff[N] = {5, 6, 4, 7, 3, 8, 2, 9, 1, 0};

int comp(const int *x, const int *y)
{
  return *x - *y;
}

int main(void)
{
  qsort(buff, N, sizeof(int), (int (*)(const void *, const void *))comp);
  for (int i = 0; i &lt; N; i++) printf("%d ", buff[i]);
  printf("\n");
  //
  int key = 2;  
  int *p = bsearch(&amp;key, buff, N, sizeof(int), (int (*)(const void *, const void *))comp);
  printf("%p\n", p);
  key = 7;
  p = bsearch(&amp;key, buff, N, sizeof(int), (int (*)(const void *, const void *))comp);
  printf("%p\n", p);
  key = 10;
  p = bsearch(&amp;key, buff, N, sizeof(int), (int (*)(const void *, const void *))comp);
  printf("%p\n", p);
  return 0;
}
</pre>
<p> int 型の配列 buff を qsort で昇順に並べ替えて、そのあと bsearch で検索します。比較関数は int comp(const int *x, const int *y) と宣言します。返り値は *x - *y で OK です。comp をそのまま qsort や bsearch に渡すとワーニングが出るので、comp をキャストする必要があります。関数へのポインタをキャストする場合、データ型の指定は次の形式で行います。
</p>
<pre class="item">
返り値のデータ型 (*)(引数のデータ型, ...)
</pre>
<p> 変数名の部分を取り除いた形式になります。(int (*)(const void *, const void*))comp と指定すれば、ワーニングは出なくなります。キャストするのがいやであれば、比較関数を次のように定義すればいいでしょう。
</p>
<pre class="list">
リスト : 比較関数

int compare(const void *x, const void *y)
{
  return *(const int *)x - *(const int *)y;
}
</pre>
<p> 引数のデータ型を const void * とし、関数の中で x と y を (const int *) でキャストします。このほうが簡単かもしれませんね。
</p>
<p> それでは実行してみましょう。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample54
0 1 2 3 4 5 6 7 8 9 
0x80498c4
0x80498d8
(nil)
</pre>
<p> 正常に動作していますね。今回はここまでです。二分探索とソートについては次回の Yet Another Clang Problems (2) で取り上げる予定です。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang04.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>