<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881808</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang11.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang13.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>連結リスト</h3>
<p> 今回は簡単な例題として「連結リスト (linked list) 」という基本的なデータ構造を作ってみましょう。
</p>
<h4>●連結リストとは？</h4>
<p> 連結リストはデータを一方向につなげたデータ構造です。リストを操作するプログラミング言語では Lisp が有名ですが、Lisp で扱うリストが連結リストです。下図に連結リストの構造を示します。
</p>
<pre class="fig">
(1)変数
  ┌─┐    ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  
  │・┼─→│10│・┼→│20│・┼→│30│／│ ／：終端(NULL)
  └─┘    └─┴─┘  └─┴─┘  └─┴─┘  

(2)ヘッダセル
  ┌─┬─┐    ┌─┬─┐  ┌─┬─┐  ┌─┬─┐  
  │  │・┼─→│10│・┼→│20│・┼→│30│／│ ／：終端(NULL)
  └─┴─┘    └─┴─┘  └─┴─┘  └─┴─┘  

                図 : 連結リスト
</PRE>
<p> 連結リストはセル (cell) というデータを繋げて作ります。セルにはデータを格納する場所と、次のセルを指し示す場所から構成されます。図でいうと、箱がひとつのセルを表していて、左側にデータを格納し、右側に次のセルへのポインタを格納します。リストの終わりを示すため、最後のセルの右側には特別な値（たとえば NULL）を格納します。そして、図 (1) のように先頭セルへの参照を変数に格納しておけば、この変数を使って連結リストにアクセスすることができます。また、図 (2) のようにヘッダセルを用意する方法もあります。
</p>
<p> 連結リストの長所は、データの挿入や削除が簡単にできることです。配列でデータの削除や挿入を行う場合、要素を移動しなければいけませんが、連結リストはセルを付け替えるだけで実現できます。逆に、配列はどの要素にも一定の時間でアクセスすることができますが、連結リストはセルを順番にたどっていくため、後ろのデータほどアクセスに時間がかかります。これが連結リストの短所です。
</p>
<h4>●データ型の定義</h4>
<p> それではプログラムを作りましょう。今回は簡単な例題なので、格納するデータ型は int とします。最初に連結リストを格納する構造体 List とセルを表す構造体 Cell を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : 連結リストの定義

// セル
typedef struct cell {
  int item;
  struct cell *next;
} Cell;

// リスト
typedef struct {
  Cell *top;
} List;
</pre>
<p> Cell のメンバ変数 item にデータを格納し、next に次のセルへのポインタを格納します。構造体は自分自身を格納することはできませんが、自分自身へのポインタであれば格納することができます。これを「自己参照構造体」といいます。構造体の中で自分自身のデータ型 (struct cell) が必要になるので、タグ名 cell を省略することはできません。List は簡単で、セルを格納するメンバ変数 top を保持するだけです。
</p>
<p> あとは、連結リストを操作する関数を定義します。基本的な操作関数を下表に示します。
</p>
<table border=1>
<caption>表 : 連結リストの操作関数</caption>
<thead>
  <tr><th>関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>List *make_list(void)</td><td>連結リスト List を生成する</td></tr>
  <tr><td>int nth(List *ls, int n, bool *err)</td><td>n 番目の要素を求める</td></tr>
  <tr><td>int pop(List *ls, bool *err)</td><td>先頭の要素を取り出す</td></tr>
  <tr><td>bool insert_nth(List *ls, int n, int val)</td><td>n 番目の位置にデータ val を挿入する</td></tr>
  <tr><td>bool push(List *ls, int val)</td><td>先頭にデータ val を追加する</td></tr>
  <tr><td>bool delete_nth(List *ls, int n)</td><td>n 番目の要素を削除する</td></tr>
  <tr><td>bool empty_list(List *ls) </TD><TD>連結リストが空の場合は真を返す</td></tr>
  <tr><td>void print_list(List *ls)</td><td>連結リストを画面に表示する</td></tr>
</tbody>
</table>
<p> 要素の位置は配列と同様に 0 から数えることにします。位置 n がリストの要素数（長さ）よりも多い場合、nth は *err に false をセットして 0 を返します。リストが空の場合、pop は *err に false をセットして 0 を返します。あとは特に難しいところはないと思います。
</p>
<p> 上表のように、連結リストの操作関数は引数に List へのポインタを受け取ります。セルを操作する関数は、これらの関数を実現するための作業用関数になります。このような場合、上表の連結リスト操作関数だけをユーザに公開して、作業用の関数は非公開にできると、ユーザが作業用関数を呼び出してしまう間違いを防ぐことができます。Ｃ言語の場合、ファイル単位でアクセス制御を行うことができます。これは「分割コンパイル」を説明するときに試してみましょう。
</p>

<h4>●連結リストの生成と廃棄</h4>
<p> まずは最初にコンストラクタから作ります。
</p>
<pre class="list">
リスト : コンストラクタ

// セルの生成
Cell *make_cell(int val, Cell *cp)
{
  Cell *newcp = malloc(sizeof(Cell));
  if (newcp != NULL) {
    newcp-&gt;item = val;
    newcp-&gt;next = cp;
  }
  return newcp;
}

// リストの生成
List *make_list(void)
{
  List *ls = malloc(sizeof(List));
  if (ls != NULL) {
    ls-&gt;top = make_cell(0, NULL);  // ヘッダセルをセット
    if (ls-&gt;top == NULL) {
      free(ls);
      return NULL;
    }
  }
  return ls;
}
</pre>
<p> 関数 make_cell は新しいセルを malloc で取得し、メンバ変数 item と next を引数 val と cp で初期化します。make_list は List 本体を malloc で取得し、ヘッダセルを make_cell で生成してメンバ変数 top にセットします。このとき、ヘッダセルの next は NULL で初期化します。これでリストは空リストになります。なお、ヘッダセルの item の値 (0) はダミーデータになります。
</p>
<p> 次はリストとセルを廃棄する関数 delete_list と delete_cell を作ります。
</p>
<pre class="list">
リスト : 廃棄

// セルの削除
void delete_cell(Cell *cp)
{
  while (cp != NULL) {
    Cell *temp = cp-&gt;next;
    free(cp);
    cp = temp;
  }
}

// リストの削除
void delete_list(List *ls)
{
  delete_cell(ls-&gt;top);
  free(ls);
}
</pre>
<p> 関数 delete_cell はセルを順番にたどり、free でセルを解放します。次のセル (next) を変数 temp に退避しておいて、free(cp) を実行したあと、temp を cp にセットします。delete_list は簡単で、delete_cell でヘッダセルから後続のセルを開放してから、free で List 本体を解放します。
</p>

<h4>●n 番目のセルを求める</h4>
<p> 次は、セルを操作するときに便利な関数 nth_cell を作ります。nth_cell は n 番目のセルを求めます。
</p>
<pre class="list">
リスト : n 番目のセルを求める

// n 番目のセルを返す
Cell *nth_cell(Cell *cp, int n)
{
  for (int i = -1; cp != NULL; i++, cp = cp-&gt;next)
    if (i == n) break;
  return cp;
}
</pre>
<p> 引数 cp にはヘッダセル top を渡します。ヘッダセルから数えるので、変数 i は -1 に初期化します。次に、for ループでセルをたどり、i が n と等しくなったとき、そのセルを return で返します。
</p>
<p> セルのたどり方は実に簡単です。次の図を見てください。
</p>
<pre class="fig">
 cp1         cp2         cp3
┌─┬─┐  ┌─┬─┐  ┌─┬─┐
│10│・┼→│20│・┼→│30│・┼→
└─┴─┘  └─┴─┘  └─┴─┘
↑          ↑
(1)         (2)

(1) cp = cp-&gt;next =&gt; cp2
(2) cp = cp-&gt;next =&gt; cp3

    図 : セルのたどり方
</pre>
<p> セル cp1 の next にはセル cp2 へのポインタが格納されています。変数 cp が cp1 の場合、cp = cp-&gt;next とすれば、cp の値はセル cp2 になります (図 (1))。さらに cp = cp-&gt;next とすれば、cp の値は cp3 になります (図 (2))。nth_cell の場合、for ループでセルをたどっていきますが、途中でセルがなくなった場合、cp の値は NULL になるので for ループを終了して NULL を返します。
</p>
<h4>●データの参照</h4>
<p> 次は、n 番目の要素を求める関数 nth を作ります。
</p>
<PRE class="list">
リスト : n 番目の要素を求める

int nth(List *ls, int n, bool *err)
{
  Cell *cp = nth_cell(ls-&gt;top, n);
  if (cp == NULL) {
    *err = false;
    return 0;
  }
  *err = true;
  return cp-&gt;item;
}
</pre>
<p> 関数 nth_cell を呼び出して n 番目のセルを求めます。cp が NULL の場合は *err に false をセットしてから return で 0 を返します。そうでなければ、*err に true をセットして、格納されているデータ cp-&gt;item を返します。
</p>
<h4>●データの挿入</h4>
<p> 次は、データの挿入を行う関数 insert_nth を作ります。データの挿入はセルの next を書き換えることで実現できます。次の図を見てください。セル (1) とセル (2) の間に、セル (3) を挿入します。
</p>
<pre class="fig">
 top         (1)                (2)
┌─┐      ┌─┬─┐         ┌─┬─┐  ┌─┬─┐
│  ┼──→│10│・┼─ X ─→│20│・┼→│30│／│
└─┘      └─┴┼┘         └─┴─┘  └─┴─┘
                  │   (3)      ↑
                  │  ┌─┬─┐│
                  └→│40│・┼┘
                      └─┴─┘

セル(1)とセル(2)の間にセル(3)を挿入する場合

            図 : データの挿入
</pre>
<p> セル (1) の後ろにセル (3) を挿入する場合、セル (1) の next にはセル (2) へのポインタがセットされているので、この値をセル (3) の next にセットします。これで、セル (3) とセル (2) がリンクされます。次に、セル (1) の next にセル (3) へのポインタをセットします。これで、セル (1) とセル (2) の間に、セル (3) を挿入することができます。
</p>
<p> プログラムは次のようになります。
</p>
<PRE class="list">
リスト : データの挿入

bool insert_nth(List *ls, int n, int x)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL) return false;
  cp-&gt;next = make_cell(x, cp-&gt;next);
  return true;
}

// 先頭に追加
bool push(List *ls, int x)
{
  return insert_nth(ls, 0, x);
}
</PRE>

<p> 連結リストにデータを挿入する場合、挿入する位置のひとつ手前のセルが必要になります。nth_cell で n - 1 番目のセルを求めます。セル cp が見つかれば、cp の後ろに x を挿入します。n が 0 の場合、nth_cell はヘッダセルを返すので、リストの先頭にデータが挿入されることになります。
</p>
<p> make_cell(x, cp-&gt;next) で x を格納する新しいセルを生成します。第 2 引数に cp-&gt;next を指定することで、新しいセルの後ろに、cp の次のセルを接続することができます。そして、cp-&gt;next の値を新しいセルに書き換えます。これで cp の後ろに新しいセルを挿入することができます。最後に true を返します。先頭にデータを追加する関数 push は insert_nth を呼び出すだけです。
</p>
<h4>●データの削除</h4>
<p> 次は、データを削除する関数 delete_nth を作ります。
</p>
<pre class="fig">
 (1)           (2)         (3)
┌─┬─┐    ┌─┬─┐  ┌─┬─┐  
│10│・┼Ｘ→│20│・┼→│30│・┼→
└─┴┼┘    └─┴─┘  └─┴─┘  
      │                  ↑
      └─────────┘

図 : データの削除:セル(2) を削除する場合
</pre>
<p> データを削除する場合も、セルを付け替えるだけで済ますことができます。上図を見てください。セル (1) の後ろにあるセル (2) を削除する場合、セル (1) の next をセル (3) へのポインタに書き換えればいいのです。セル (3) はセル (2) の next から求めることができます。たとえば、セル (1) を保持する変数を cp とすると、セル (3) は cp-&gt;next-&gt;next で求めることができます。とても簡単ですね。
</p>
<p> プログラムは次のようになります。
</p>
<PRE class="list">
リスト : データの削除

// n 番目の要素を削除
bool delete_nth(List *ls, int n)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL || cp-&gt;next == NULL) return false;
  Cell *temp = cp-&gt;next;
  cp-&gt;next = cp-&gt;next-&gt;next;
  free(temp);
  return true;
}

// 先頭から要素を取り出す
int pop(List *ls, bool *err)
{
  int x = nth(ls, 0, err);
  if (*err) delete_nth(ls, 0);
  return x;
}
</PRE>

<p> データを削除する場合も、削除する位置のひとつ手前のセルが必要になります。nth_cell で n - 1 番目のセルを求めます。次に、削除するセルがあるか cp-&gt;next の値をチェックします。値が NULL でなければ、cp-&gt;next の値を cp-&gt;next-&gt;next に書き換えるだけです。これで連結リストから n 番目の要素を削除することができます。なお、標準のＣ言語ではガベージコレクション (GC) がないので、削除したセルは free で解放することを忘れないでください。
</p>
<p> 関数 pop は簡単です。nth で先頭要素の値を参照して変数 x にセットします。エラーがなければ delete_nth で先頭セルを削除して、return で x を返します。エラーが発生した場合、*err には false、変数 x には 0 がセットされているので、x をそのまま返すだけで OK です。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <A href="clang12.html#list1">プログラムリスト１</A> をお読みください。
</p>
<h4>●実行例</h4>
<p> それでは実行してみましょう。
</p>
<PRE class="list">
リスト : 簡単な実行例

int main(void)
{
  List *ls = make_list();
  bool err;
  for (int i = 0; i &lt; 8; i++) {
    push(ls, i + 10);
    print_list(ls);
  }
  insert_nth(ls, 3, 100);
  print_list(ls);
  insert_nth(ls, 9, 200);
  print_list(ls);
  for (int i = 0; i &lt; 11; i++) {
    int x = nth(ls, i, &amp;err);
    printf("%d, %d\n", x, err);
  }
  delete_nth(ls, 0);
  print_list(ls);
  delete_nth(ls, 5);
  print_list(ls);
  delete_nth(ls, 7);
  print_list(ls);
  while (!empty_list(ls)) {
    int x = pop(ls, &amp;err);
    printf("%d, %d\n", x, err);
    print_list(ls);
  }
  delete_list(ls);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./linklist
( 10 )
( 11 10 )
( 12 11 10 )
( 13 12 11 10 )
( 14 13 12 11 10 )
( 15 14 13 12 11 10 )
( 16 15 14 13 12 11 10 )
( 17 16 15 14 13 12 11 10 )
( 17 16 15 100 14 13 12 11 10 )
( 17 16 15 100 14 13 12 11 10 200 )
17, 1
16, 1
15, 1
100, 1
14, 1
13, 1
12, 1
11, 1
10, 1
200, 1
0, 0
( 16 15 100 14 13 12 11 10 200 )
( 16 15 100 14 13 11 10 200 )
( 16 15 100 14 13 11 10 )
16, 1
( 15 100 14 13 11 10 )
15, 1
( 100 14 13 11 10 )
100, 1
( 14 13 11 10 )
14, 1
( 13 11 10 )
13, 1
( 11 10 )
11, 1
( 10 )
10, 1
( )
</PRE>
<p> 正常に動作していますね。
</p>
<h4>●分割コンパイル</h4>
<p> Ｃ言語で大きいプログラムを作る場合、ソースファイルを機能単位 (または他の基準) で複数のファイルに分割して管理することがよく行われます。Ｃ言語の場合、分割したファイルを個別にコンパイルすることが可能で、そのあとオブジェクトファイル (拡張子が .o のファイル) をリンクで結合すれば、実行ファイルを生成することができます。これを「分割コンパイル (separate compilation) 」といいます。
</p>
<p> プログラムのテスト段階になると、不具合を見つけては修正し、またテストを行うということを繰り返します。ソースファイルを修正したあと再コンパイルするのですが、ファイルが大きいとコンパイルに時間がかかります。ファイルを分割しておけば、修正したファイルだけコンパイルすればいいので、コンパイル時間を短縮することができるわけです。
</p>

<p> 簡単な例として、今回作成した連結リスト (<a href="clang12.html#list1">プログラムリスト</a>) を main.c と linklist.c に分割してみましょう。ファイルを分割する場合、linklist.c に定義されているデータ型や関数などの情報を main.c に知らせる必要があります。これにはヘッダファイルを使います。
</p>
<p> Ｃ言語ユーザならば、標準ライブラリを使用するときにヘッダファイルをインクルードしているはずです。ヘッダファイルには、そのライブラリで使用できる関数のプロトタイプ宣言、マクロ、構造体の定義などが格納されています。たとえば、stdio.h では FILE 構造体が定義され、fgetc や fputc などの入出力関数のプロトタイプ、stdin, stdout, stderr などのマクロが宣言されています。
</p>
<p> プロトタイプは、関数の引数と返り値の型を前もって宣言することです。そうすることで、コンパイル時において型チェックを行うことができます。ANSI C 規格 (C89/C90) 以前のコンパイラにはこの機能がないので、引数の型が間違っていてもそのままコンパイルされてしまい、不具合の原因になることがあったようです。
</p>
<h4>●ヘッダファイルの定義</h4>

<p>それでは、ヘッダファイルを書いてみましょう。
</p>
<pre class="list">
リスト : linklist.h

#ifndef _LINKLIST_H_
#define _LINKLIST_H_

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

// セル
typedef struct cell {
  int item;
  struct cell *next;
} Cell;

// リスト
typedef struct {
  Cell *top;
} List;

// 関数宣言
List *make_list(void);
void delete_list(List *ls);
int nth(List *ls, int n, bool *err);
bool insert_nth(List *ls, int n, int x);
bool delete_nth(List *ls, int n);
bool push(List *ls, int x);
int pop(List *ls, bool *err);
bool empty_list(List *ls);
void print_list(List *ls);

#endif
</pre>
<p> #ifndef はプリプロセッサ指令です。
</p>
<pre class="item">
#ifndef マクロ
  処理１
#else
  処理２
#endif
</pre>
<p> マクロが定義されていなければ、処理 1 の展開を行い、定義されていれば処理 2 の展開を行います。linklist.h の場合、_LINKLIST_H_ が定義されていなければ _LINKLISH_H_ を定義します。それから、必要なヘッダファイルの読み込みと構造体の定義と関数宣言を行います。_LINKLIST_H_ が定義されている場合は何も行いません。
</p>
<p> 標準ライブラリ のヘッダファイルも同様な処理がなされていて、stdio.h ならば _STDIO_H のマクロをチェックしています。これは、ヘッダファイルを何回読み込んでもコンパイルできるようにするためです。たとえば、linklist.h では stdbool.h を読み込んでいますね。ほかのヘッダファイルでも stdbool.h を読み込んでいるものがあるかもしれません。単純に読み込むだけでは、stdbool.h での定義は二重に定義されたとしてコンパイルエラーになってしまいます。
</p>
<p> それでは、linklist.h で stdbool.h の読み込み (インクルード) をやめればいいはずです。しかし、今度は stdbool.h をインクルードしないヘッダファイルといっしょに使用する場合に困ってしまいます。linklist.h を使う場合は、ほかのヘッダファイルを調べてから stdbool.h をインクルードしてください、というのではとても使いにくいですね。ヘッダファイル側で二重定義にならないように工夫されているので、ほかのヘッダファイルの内容まで考えなくて済むのです。
</p>
<p> ヘッダファイルは、ユーザにとってそのライブラリの顔を意味しています。ヘッダファイルを見れば、そのライブラリの機能概要や使い方がわかるように、きちんと書いておくといいでしょう。
</p>
<h4>●static 宣言</h4>
<p> 次は linklist.c を修正します。<a href="clang12.html#list3">プログラムリスト３</a> を見てください。関数 make_cell, delete_cell, nth_cell の前に static が付いています。関数名の前にある static は、関数名がこのファイルの中だけ有効であることを示します。プロトタイプ宣言されていないので、他のファイルでこれらの関数を呼び出すとワーニングが表示されます。それを無視してコンパイルすると、リンクでエラーが発生して実行ファイルは作成できません。
</p>
<p> static は関数だけではなく変数にも宣言することができます。ソースファイルがひとつの場合には、関数や変数を static 宣言する必要はありませんが、大きなプログラムを複数のソースファイルに分けて作る場合、関数や変数の static 宣言はとても重要になります。変数の static 宣言は必要になったら説明することにしましょう。
</p>
<h4>●実行ファイルの作成</h4>
<p> 最後に main.c を作ります。
</p>
<pre class="list">
リスト : main.c 

#include &lt;stdio.h&gt;
#include "linklist.h"

int main(void)
{
  List *ls = make_list();
  bool err;
  for (int i = 0; i &lt; 8; i++) {
    push(ls, i + 10);
    print_list(ls);
  }
  insert_nth(ls, 3, 100);
  print_list(ls);
  insert_nth(ls, 9, 200);
  print_list(ls);
  for (int i = 0; i &lt; 11; i++) {
    int x = nth(ls, i, &err);
    printf("%d, %d\n", x, err);
  }
  delete_nth(ls, 0);
  print_list(ls);
  delete_nth(ls, 5);
  print_list(ls);
  delete_nth(ls, 7);
  print_list(ls);
  while (!empty_list(ls)) {
    int x = pop(ls, &err);
    printf("%d, %d\n", x, err);
    print_list(ls);
  }
  delete_list(ls);
  return 0;
}
</pre>
<p> #include 命令で "..." を指定すると、カレントディレクトリからヘッダファイルを探します。見つからない場合は、標準ライブラリのヘッダファイルと同じディレクトリを探します。一般に、ユーザが定義したヘッダファイルはソースファイル (.c) と同じディレクトリに置き、#include "..." でインクルートします。main.c で printf を使っているので stido.h もインクルードしていますが、二重定義でエラーが発生することはありません。
</p>
<p> 分割したファイルをコンパイルするのは簡単です。今回のように小さなプログラムでは、次のように複数のソースファイルを指定するだけで十分です。
</p>
<pre class="item">
clang -o linklist main.c linklist.c
</pre>
<p> これで実行ファイル linklist を生成することができます。
</p>
<p> ソースファイルを個別にコンパイルすることもできます。この場合、コンパイルオプションに -c を追加してリンクを実行しないようにします。
<pre>
mhiroi@mhiroi-VirtualBox:~/clang/linklist$ clang -c main.c
mhiroi@mhiroi-VirtualBox:~/clang/linklist$ clang -c linklist.c
mhiroi@mhiroi-VirtualBox:~/clang/linklist$ ls *.o
linklist.o  main.o
</pre>
<p> オブジェクトファイル main.o と linklist.o が出力されます。オブジェクトファイルだけでは実行ファイルを作ることはできません。ライブラリから実行ファイルを作るのに必要な関数を探して、その関数を結合しないといけません。この作業が「リンク」です。リンクも簡単で、コンパイラにオブジェクトファイルを指定すれば、そのファイルをリンクしてくれます。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang/linklist$ clang -o linklist main.o linklist.o
mhiroi@mhiroi-VirtualBox:~/clang/linklist$ ls linklist
linklist
</pre>
<p> オブジェクトファイルをリンクによって結合し、それでも足りない関数があれば、ライブラリから探して結合します。リンク作業が正常に終了すると、実行ファイルが完成します。この作業によく使用されるツールが make です。
</p>
<p> make は、ソースファイルの日付と実行ファイルもしくはオブジェクトファイルの日付を比較して、ソースファイルが変更されていれば、指定した処理（コンパイルやリンク）を自動的に行ってくれるツールです。Makefile というファイルに必要な処理を記述しておけば、make を起動するだけで、その処理を行ってくれます。ちょっと大きなプログラムを作る場合、make はなくてはならない必須ツールです。
</p>
<p> 最近は Makefile を自分で作るのではなく、自動的に生成するツールを使うことが多いようですが、M.Hiroi は勉強不足でよくわかりません。make だけならば、それほど難しいことはないので、使うときに説明することにしましょう。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
/*
 * linklist.c : 連結リスト
 *
 *              Copyright (C) 2015 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

// セル
typedef struct cell {
  int item;
  struct cell *next;
} Cell;

// リスト
typedef struct {
  Cell *top;
} List;

// コンストラクタ
Cell *make_cell(int val, Cell *cp)
{
  Cell *newcp = malloc(sizeof(Cell));
  if (newcp != NULL) {
    newcp-&gt;item = val;
    newcp-&gt;next = cp;
  }
  return newcp;
}

List *make_list(void)
{
  List *ls = malloc(sizeof(List));
  if (ls != NULL) {
    ls-&gt;top = make_cell(0, NULL);  // ヘッダセルをセット
    if (ls-&gt;top == NULL) {
      free(ls);
      return NULL;
    }
  }
  return ls;
}

// 解放
void delete_cell(Cell *cp)
{
  while (cp != NULL) {
    Cell *temp = cp-&gt;next;
    free(cp);
    cp = temp;
  }
}

void delete_list(List *ls)
{
  delete_cell(ls-&gt;top);
  free(ls);
}

// n 番目のセルを返す
Cell *nth_cell(Cell *cp, int n)
{
  for (int i = -1; cp != NULL; i++, cp = cp-&gt;next)
    if (i == n) break;
  return cp;
}

// n 番目の要素を返す
int nth(List *ls, int n, bool *err)
{
  Cell *cp = nth_cell(ls-&gt;top, n);
  if (cp == NULL) {
    *err = false;
    return 0;
  }
  *err = true;
  return cp-&gt;item;
}

// n 番目に x を挿入
bool insert_nth(List *ls, int n, int x)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL) return false;
  cp-&gt;next = make_cell(x, cp-&gt;next);
  return true;
}

// n 番目の要素を削除
bool delete_nth(List *ls, int n)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL || cp-&gt;next == NULL) return false;
  Cell *temp = cp-&gt;next;
  cp-&gt;next = cp-&gt;next-&gt;next;
  free(temp);
  return true;
}

// 先頭に追加
bool push(List *ls, int x)
{
  return insert_nth(ls, 0, x);
}

// 先頭から要素を取り出す
int pop(List *ls, bool *err)
{
  int x = nth(ls, 0, err);
  if (*err) delete_nth(ls, 0);
  return x;
}

// リストは空か
bool empty_list(List *ls)
{
  return ls-&gt;top-&gt;next == NULL;
}

// リストの表示
void print_list(List *ls)
{
  printf("( ");
  for (Cell *cp = ls-&gt;top-&gt;next; cp != NULL; cp = cp-&gt;next)
    printf("%d ", cp-&gt;item);
  printf(")\n");
}

int main(void)
{
  List *ls = make_list();
  bool err;
  for (int i = 0; i &lt; 8; i++) {
    push(ls, i + 10);
    print_list(ls);
  }
  insert_nth(ls, 3, 100);
  print_list(ls);
  insert_nth(ls, 9, 200);
  print_list(ls);
  for (int i = 0; i &lt; 11; i++) {
    int x = nth(ls, i, &amp;err);
    printf("%d, %d\n", x, err);
  }
  delete_nth(ls, 0);
  print_list(ls);
  delete_nth(ls, 5);
  print_list(ls);
  delete_nth(ls, 7);
  print_list(ls);
  while (!empty_list(ls)) {
    int x = pop(ls, &amp;err);
    printf("%d, %d\n", x, err);
    print_list(ls);
  }
  delete_list(ls);
  return 0;
}
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
/*
 * linklist.h : 連結リスト
 *
 *              Copyright (C) 2015 Makoto Hiroi
 */
#ifndef _LINKLIST_H_
#define _LINKLIST_H_

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

// セル
typedef struct cell {
  int item;
  struct cell *next;
} Cell;

// リスト
typedef struct {
  Cell *top;
} List;

// 関数宣言
List *make_list(void);
void delete_list(List *ls);
int nth(List *ls, int n, bool *err);
bool insert_nth(List *ls, int n, int x);
bool delete_nth(List *ls, int n);
bool push(List *ls, int x);
int pop(List *ls, bool *err);
bool empty_list(List *ls);
void print_list(List *ls);

#endif
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
/*
 * linklist.c : 連結リスト
 *
 *              Copyright (C) 2015 Makoto Hiroi
 */
#include "linklist.h"

// コンストラクタ
static Cell *make_cell(int val, Cell *cp)
{
  Cell *newcp = malloc(sizeof(Cell));
  if (newcp != NULL) {
    newcp-&gt;item = val;
    newcp-&gt;next = cp;
  }
  return newcp;
}

List *make_list(void)
{
  List *ls = malloc(sizeof(List));
  if (ls != NULL) {
    ls-&gt;top = make_cell(0, NULL);  // ヘッダセルをセット
    if (ls-&gt;top == NULL) {
      free(ls);
      return NULL;
    }
  }
  return ls;
}

// 解放
static void delete_cell(Cell *cp)
{
  while (cp != NULL) {
    Cell *temp = cp-&gt;next;
    free(cp);
    cp = temp;
  }
}

void delete_list(List *ls)
{
  delete_cell(ls-&gt;top);
  free(ls);
}

// n 番目のセルを返す
static Cell *nth_cell(Cell *cp, int n)
{
  for (int i = -1; cp != NULL; i++, cp = cp-&gt;next)
    if (i == n) break;
  return cp;
}

// n 番目の要素を返す
int nth(List *ls, int n, bool *err)
{
  Cell *cp = nth_cell(ls-&gt;top, n);
  if (cp == NULL) {
    *err = false;
    return 0;
  }
  *err = true;
  return cp-&gt;item;
}

// n 番目に x を挿入
bool insert_nth(List *ls, int n, int x)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL) return false;
  cp-&gt;next = make_cell(x, cp-&gt;next);
  return true;
}

// n 番目の要素を削除
bool delete_nth(List *ls, int n)
{
  Cell *cp = nth_cell(ls-&gt;top, n - 1);
  if (cp == NULL || cp-&gt;next == NULL) return false;
  Cell *temp = cp-&gt;next;
  cp-&gt;next = cp-&gt;next-&gt;next;
  free(temp);
  return true;
}

// 先頭に追加
bool push(List *ls, int x)
{
  return insert_nth(ls, 0, x);
}

// 先頭から要素を取り出す
int pop(List *ls, bool *err)
{
  int x = nth(ls, 0, err);
  if (*err) delete_nth(ls, 0);
  return x;
}

// リストは空か
bool empty_list(List *ls)
{
  return ls-&gt;top-&gt;next == NULL;
}

// リストの表示
void print_list(List *ls)
{
  printf("( ");
  for (Cell *cp = ls-&gt;top-&gt;next; cp != NULL; cp = cp-&gt;next)
    printf("%d ", cp-&gt;item);
  printf(")\n");
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang11.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang13.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>