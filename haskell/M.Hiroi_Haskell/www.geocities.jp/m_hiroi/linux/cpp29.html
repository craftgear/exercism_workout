<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881812</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp28.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp30.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>文字列 (string)</h3>
<p> 今回は標準ライブラリ (STL) の中から「文字列 (string)」を取り上げます。STL には basic_string というテンプレートがあり、string は basic_string&lt;char&gt; の別名として定義されています。string は vector とよく似ていますが、文字列を操作するのに都合がよいメンバ関数が追加されているところが異なります。Ｃ++の場合、Ｃスタイル文字列よりも string を使ったほうが便利です。本稿では string の基本的な使い方を簡単に説明します。
</p>
<h4>●string の宣言と初期化</h4>
<p> string はＣスタイル文字列や他の string、それらの部分文字列を使って初期化することができます。文字や整数で string を初期化することはできませんが、文字と長さを指定して string を初期化することは可能です。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : string の宣言と初期化

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void print_string(string&amp; s)
{
  cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "]\n";
}

int main()
{
  string s0;                       // 空文字列
  print_string(s0);
  string s1("hello, world");       // リテラル
  print_string(s1);
  const char* a = "Hello, World";  // ポインタ
  string s2(a);
  print_string(s2);
  string s3(s1);        // s1 をコピー
  print_string(s3);
  string s4(8, 'a');
  print_string(s4);     // 文字と長さの指定
  const char* b = "foo bar baz oops";
  string s5(b + 4, 3);  // b[4] から 3 文字
  print_string(s5);
  vector&lt;char&gt; c = {'a', 'b', 'c', 'd', 'e', 'f'};
  string s6(c.begin(), c.end());
  print_string(s6);
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
[]
[hello, world]
[Hello, World]
[hello, world]
[aaaaaaaa]
[bar]
[abcdef]
</pre>
<p> 文字を格納しているコンテナクラスであれば、イテレータを指定して string を生成することもできます。
</p>
<h4>●要素のアクセス</h4>
<p> string は vector と同様に添字演算子 [] やメンバ関数 at() で要素 (文字) にアクセスすることができます。メンバ関数には front() や back() も用意されています。
</p>
<p> 簡単な例を示します。
</p>
<pre class="list">
リスト : 要素のアクセス

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s = "hello, world";
  cout &lt;&lt; s[0] &lt;&lt; endl;
  cout &lt;&lt; s[s.length() - 1] &lt;&lt; endl;
  s[0] = 'H';
  s[s.length() - 1] = 'D';
  for (auto x : s) cout &lt;&lt; x;
  cout &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
h
d
Hello, worlD
</pre>
<p> length() は文字列の長さを求めるメンバ関数です。コンテナクラスのメンバ関数 size() と同じです。string は範囲 for 文で要素にアクセスすることもできます。
</p>
<h4>●string のイテレータ</h4>
<p> string はランダムイテレータをサポートしています。どの要素でも定数時間 O(1) でアクセスすることが可能です。イテレータを生成するメンバ関数を下表に示します。
</p>
<table border=1>
<caption>表 : イテレータの生成 (string)</caption>
<thead>
  <tr><th>メンバ関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>begin()</td><td>先頭要素を指し示すイテレータを返す</td></tr>
  <tr><td>end()</td><td>終端を指し示すイテレータを返す</td></tr>
  <tr><td>cbegin()</td><td>先頭要素を指し示す const イテレータを返す</td></tr>
  <tr><td>cend()</td><td>終端を指し示す const イテレータを返す</td></tr>
  <tr><td>rbegin()</td><td>先頭要素を指し示すリバースイテレータを返す</td></tr>
  <tr><td>rend()</td><td>終端を指し示すリバースイテレータを返す</td></tr>
  <tr><td>crbegin()</td><td>先頭要素を指し示す const リバースイテレータを返す</td></tr>
  <tr><td>crend()</td><td>終端を指し示す const リバースイテレータを返す</td></tr>
</tbody>
</table>
<p> const イテレータは要素を更新することができません。リバースイテレータは末尾要素が先頭で、先頭要素が末尾になります。要素が n 個ある場合、n - 1 番目の要素が先頭で、0 番目の要素が末尾になります。
</p>
<p> イテレータのデータ型は次のようになります。
</p>
<pre class="item">
string::iterator               // 通常のイテレータ
string::const_iterator         // const イテレータ
string::reverse_iterator       // リバースイテレータ
string::const_reverse_iterator // const リバースイテレータ
</pre>
<p> 最近の規格 (C++11) を利用できるコンパイラでは auto を使ったほうが簡単でしょう。
</p>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : イテレータの使用例

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
  string s = "hello, world";
  for (string::const_iterator iter = s.cbegin(); iter != s.cend(); ++iter)
    cout &lt;&lt; *iter;
  cout &lt;&lt; endl;
  for (auto iter = s.rbegin(); iter != s.rend(); ++iter)
    cout &lt;&lt; *iter;
  cout &lt;&lt; endl;
  auto p = find(s.begin(), s.end(), 'w');
  if (p != s.end()) cout &lt;&lt; *p &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
hello, world
dlrow ,olleh
w
</pre>
<p> string はイテレータをサポートしているので、STL の algorithm に用意されている関数、たとえば find() や for_each() などを利用することができます。ただし、文字列の操作は汎用の関数を使うよりも、string のメンバ関数を使ったほうが便利です。
</p>
<h4>●文字列の連結</h4>
<p> string は演算子 + で連結することができます。s1 + s2 は文字列 s1 と s2 を連結した新しい文字列を生成します。
</p>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : 文字列の連結

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s1 = "hello";
  string s2 = "world";
  string s3 = s1 + ", " + s2;
  cout &lt;&lt; s1 &lt;&lt; endl;
  cout &lt;&lt; s2 &lt;&lt; endl;
  cout &lt;&lt; s3 &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
hello
world
hello, world
</pre>

<h4>●文字列の挿入</h4>
<p> string は vector と同様にメンバ関数 insert() で文字列の途中にデータを挿入することができますが、データを末尾に追加する演算子 += やメンバ関数 append() も用意されています。もちろん、push_back() もあります。
</p>
<table border=1>
<caption>表 : 文字列の挿入</caption>
<thead>
  <tr><th>メンバ関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>push_back(c)</td><td>末尾に文字 c を追加する</td></tr>
  <tr><td>operator+=(str)</td><td>末尾に文字列 str を追加する</td></tr>
  <tr><td>operator+=(c)</td><td>末尾に文字 c を追加する</td></tr>
  <tr><td>append(str)</td><td>末尾に文字列 str を追加する</td></tr>
  <tr><td>append(n, c)</td><td>末尾に文字 c を n 個追加する</td></tr>
  <tr><td>insert(pos, str)</td><td>位置 pos に文字列 str を挿入する</td></tr>
  <tr><td>insert(pos, n, c)</td><td>位置 pos に文字 c を n 個挿入する</td></tr>
  <tr><td>insert(it, c)</td><td>イテレータ it の位置に文字 c を挿入する</td></tr>
  <tr><td>insert(it, n, c)</td><td>イテレータ it の位置に文字 c を n 個挿入する</td></tr>
  <tr><td>insert(it, first, last)</td><td>イテレータ it の位置にイテレータ [first, last) が示す区間の文字を挿入する</td></tr>
</tbody>
</table>
<p> 簡単な例を示します。
</p>
<pre class="list">
リスト : 文字列の末尾にデータを追加する

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
  string s1;
  s1.push_back('f');
  s1.push_back('o');
  s1.push_back('o');
  cout &lt;&lt; s1 &lt;&lt; endl;
  string s2 = "bar";
  s1 += " ";
  s1 += s2;
  cout &lt;&lt; s1 &lt;&lt; endl;
  s1.append(" baz");
  cout &lt;&lt; s1 &lt;&lt; endl;
  s1.append(5, '!');
  cout &lt;&lt; s1 &lt;&lt; endl;
  s1.insert(0, "abc ");
  cout &lt;&lt; s1 &lt;&lt; endl;
  string s3 = "oops ";
  s1.insert(4, s3);
  cout &lt;&lt; s1 &lt;&lt; endl;
  vector&lt;char&gt; s4 = {'A', 'B', 'C'};
  s1.insert(s1.begin(), s4.begin(), s4.end());
  cout &lt;&lt; s1 &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
foo
foo bar
foo bar baz
foo bar baz!!!!!
abc foo bar baz!!!!!
abc oops foo bar baz!!!!!
ABCabc oops foo bar baz!!!!!
</pre>
<h4>●文字列の削除</h4>
<p> 末尾の文字は pop_back() で取り除くことができます。途中の文字や文字列はメンバ関数 erase() で取り除くことができます。
</p>

<table border=1>
<caption>表 : 文字列の削除</caption>
<thead>
  <tr><th>メンバ関数</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>pop_back()</td><td>末尾から 1 文字削除する</td></tr>
  <tr><td>erase()</td><td>文字をすべて削除する (空文字列)</td></tr>
  <tr><td>erase(pos, n)</td><td>位置 pos から n 文字を削除する</td></tr>
  <tr><td>erase(it)</td><td>イテレータ it の位置の文字を削除する</td></tr>
  <tr><td>erase(first, last)</td><td>イテレータ [first, last) の区間にある文字を削除する</td></tr>
</tbody>
</table>

<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : 文字列の削除

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s1 = "foo bar baz oops!";
  cout &lt;&lt; s1.back() &lt;&lt; endl;
  s1.pop_back();
  cout &lt;&lt; s1 &lt;&lt; endl;
  cout &lt;&lt; s1.front() &lt;&lt; endl;
  s1.erase(s1.begin());  // イテレータの位置の文字を削除
  cout &lt;&lt; s1 &lt;&lt; endl;
  s1.erase(0, 3);        // 0 番目から 3 文字を削除
  cout &lt;&lt; s1 &lt;&lt; endl;
  s1.erase(s1.begin());
  cout &lt;&lt; s1 &lt;&lt; endl;  
  s1.erase(s1.begin(), s1.begin() + 3);
  cout &lt;&lt; s1 &lt;&lt; endl;  
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
!
foo bar baz oops
f
oo bar baz oops
bar baz oops
ar baz oops
baz oops
</pre>

<h4>●文字列の探索</h4>
<p> 文字列の探索はメンバ関数 find() を使うと簡単です。
</p>
<pre class="item">
size_type find(文字列, 検索開始位置 = 0);
</pre>
<p> find() は引数の文字列と等しい部分文字列を探索し、見つけたらその位置を返します。見つからない場合は string::npos を返します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : find() の使用例

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s1 = "foo bar baz foo bar baz oops!";
  string s2 = "baz";
  int n = 0;
  while (true) {
    n = s1.find(s2, n);
    if (n == string::npos) break;
    cout &lt;&lt; n &lt;&lt; endl;
    n += s2.length();
  }
}   
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
8
20
</pre>
<p> このほかにも、末尾から部分文字列を探索するメンバ関数 rfind() や、引数の文字列に含まれる文字を探索するメンバ関数 find_first_of() や find_last_of()、引数の文字列に含まれていない文字を探索するメンバ関数 find_first_not_of() や find_last_not_of() などがあります。詳細はＣ++のリファレンスマニュアルをお読みください。
</p>
<h4>●文字列の置換</h4>
<p> メンバ関数 replace() を使うと、文字列を置換することができます。
</p>
<pre class="item">
string&amp; replace(開始インデックス, 文字数, 置換文字列);
string&amp; replace(開始イテレータ, 終了イテレータ, 置換文字列);
</pre>
<p> replace() は置換開始位置から文字数の部分文字列を置換文字列に置き換えます。イテレータで置換する部分を指定することもできます。
</p>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : replace() の使用例

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s1 = "foo bar baz oops!";
  s1.replace(4, 3, "ABCD");
  cout &lt;&lt; s1 &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
foo ABCD baz oops!
</pre>
<p> replace() にはいろいろな使い方があります。詳細はリファレンスマニュアルをお読みください。
</p>
<h4>●部分文字列の取得</h4>
<p> メンバ関数 substr() を使うと、文字列から部分文字列を求めることができます。
</p>
<pre class="item">
string substr(開始位置, 文字数);
</pre>
<p> substr() は開始位置から文字数で指定した部分文字列を格納した新しい string を生成して返します。
</p>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : substr() の使用例

#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s = "abcdefghijklmn";
  for (int i = 0; i &lt;= s.length(); i++)
    cout &lt;&lt; s.substr(i, s.length() - i) &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
abcdefghijklmn
bcdefghijklmn
cdefghijklmn
defghijklmn
efghijklmn
fghijklmn
ghijklmn
hijklmn
ijklmn
jklmn
klmn
lmn
mn
n

</pre>
<h4>●Ｃスタイル文字列への変換</h4>
<p> string はメンバ関数 c_str() や data() でＣスタイル文字列に変換することができます。
</p>
<pre class="item">
const char* c_str();
const char* data();
</pre>
<p> 簡単な使用例を示します。
</p>
<pre class="list">
リスト : c_str() と data() の使用例

#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int main()
{
  string s1 = "hello, world";
  cout &lt;&lt; s1.c_str() &lt;&lt; endl;
  cout &lt;&lt; strlen(s1.data()) &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
hello, world
12
</pre>
</section>
<hr>
<section class="contents">
<h3 id="chap02">Yet Another C++ Problems (6)</h3>
<h4>●問題44</h4>
<p> ファイルの文字数 (ファイルサイズ) と行数をカウントするプログラムを作ってください。コマンドラインでファイル名が省略された場合は標準入力を使うものとします。なお、Unix 系 OS には同等の機能を持つコマンド wc があります。
</p>
<pre class="item">
prog [input_file]
</pre>
<p><a href="cpp29.html#ans44">解答</a></p>

<h4>●問題45</h4>
<p> ファイルから文字列を探索し、見つけたらその行を出力するプログラムを作ってください。コマンドラインでファイル名が省略された場合は標準入力を使うものとします。
</p>
<p> なお、Unix 系 OS には正規表現を使って文字列を検索するコマンド grep があります。
</p>
<pre class="item">
prog key [input_file]
</pre>
<p><a href="cpp29.html#ans45">解答</a></p>

<h4>●問題46</h4>
<p> ファイルを読み込んで、ある特定の文字を他の文字で置換するプログラムを作ってください。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。
</p>
<p> コマンドラインの第 1 引数が置換対象となる文字、第 2 引数が置き換える文字とします。これらの引数は文字列で指定することができ、たとえば prog abc ABC とすると、a -&gt; A, b -&gt; B, c -&gt; と置換します。引数の長さが異なる場合はエラー終了するものとします。
</p>
<p> なお、Unix 系 OS にはもっと多くの機能を持つコマンド tr があります。
</p>
<pre class="item">
prog char_set1 char_set2 [input_file [output_file]]
</pre>
<p><a href="cpp29.html#ans46">解答</a></p>

<h4>●問題47</h4>
<p> ファイルを読み込んで、第 1 引数で指定した文字列を、第 2 引数で指定した文字列に置換するプログラムを作ってください。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。
</p>
<p> なお、Unix 系 OS ではコマンド sed で文字列の置換を行うことができます。もちろん、正規表現も利用することができます。
</p>
<pre class="item">
prog key_str replace_str [input_file [output_file]]
</pre>
<p><a href="cpp29.html#ans47">解答</a></p>

<h4>●問題48</h4>
<p>ファイルの単語をカウントするプログラムを作ってください。単語は空白文字で区切られた文字列とします。コマンドラインでファイル名が省略された場合は標準入力を使うものとします。
</p>
<p> なお、Unix 系 OS には同等の機能を持つコマンド wc があります。
</p>
<pre class="item">
prog [input_file]
</pre>
<p><a href="cpp29.html#ans48">解答</a></p>

<h4>●問題49</h4>
<p> タブを空白文字に展開するプログラムを作ってください。タブの値は 8 個とします。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。
</p>
<p> なお、Unix 系 OS には同等の機能を持つコマンド expand があります。
</p>
<pre class="item">
prog [input_file [output_file]]
</pre>
<p><a href="cpp29.html#ans49">解答</a></p>

<h4>●問題50</h4>
<p> 空白文字をタブに置き換えるプログラムを作ってください。タブの値は 8 個とします。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。
</p>
<p> なお、Unix 系 OS には同等の機能を持つコマンド unexpand があります。
</p>
<pre class="item">
prog [input_file [output_file]]
</pre>
<p><a href="cpp29.html#ans50">解答</a></p>
<hr>
<h4 id="ans44">●解答44</h4>
<pre class="list">
リスト : ファイルの文字数と行数

#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

void read_file(istream&amp; fin)
{
  int line = 0;
  int size = 0;
  int c;
  while ((c = fin.get()) != EOF) {
    if (c == '\n') line++;
    size++;
  }
  cout &lt;&lt; "line : " &lt;&lt; line &lt;&lt; ", size = " &lt;&lt; size &lt;&lt; endl;
}

int main(int argc, char* argv[])
{
  if (argc &lt; 2) {
    read_file(cin);
  } else {
    ifstream fin(argv[1]);
    if (fin) {
      read_file(fin);
    } else {
      cerr &lt;&lt; argv[1] &lt;&lt; " が見つかりません" &lt;&lt; endl;
      return 1;
    }
  }
}
</pre>
<p> 行数と文字数は関数 read_file() でカウントします。行数を変数 line, 文字数を変数 size でカウントします。どちらの変数も 0 で初期化します。あとは、get() で 1 バイトずつ読み込み、それが改行文字ならば line を +1 して、size を +1 します。最後に、size と line を演算子 &lt;&lt; で表示するだけです。
</p>
<h4 id="ans45">●解答45</h4>
<pre class="list">
リスト : 文字列の探索

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

void search_key(const char* key, istream&amp; fin)
{
  string buff;
  while (getline(fin, buff)) {
    if (buff.find(key, 0) != string::npos) {
      cout &lt;&lt; buff &lt;&lt; endl;
    }
  }
}

int main(int argc, char* argv[])
{
  if (argc &lt; 2) {
    cerr &lt;&lt; "引数が足りません\n";
    return 1;
  }
  if (argc == 2) {
    search_key(argv[1], cin);
  } else {
    ifstream fin(argv[2]);
    if (fin) {
      search_key(argv[1], fin);
    } else {
      cerr &lt;&lt; argv[2] &lt;&lt; " が見つかりません\n" &lt;&lt; endl;
    }
  }
}
</pre>
<p> 文字列の検索は関数 search_key() で行います。search_key は getline() で fin から 1 行ずつバッファ buff に読み込み、メンバ関数 find() で buff から key を探します。見つかった場合は演算子 &lt;&lt; で buff を出力します。
</p>
<h4 id="ans46">●解答46</h4>
<pre class="list">
リスト : 文字の置換

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
using namespace std;

int position(const char* buff, int c)
{
  for (int i = 0; buff[i] != '\0'; i++)
    if (buff[i] == c) return i;
  return -1;
}

void replace_char(const char* src, const char* dst, istream&amp; fin, ostream&amp; fout)
{
  int c;
  while ((c = fin.get()) != EOF) {
    int n = position(src, c);
    if (n &gt;= 0) {
      fout.put(dst[n]);
    } else {
      fout.put(c);
    }
  }
}

int main(int argc, char* argv[])
{
  if (argc &lt; 3) {
    cerr &lt;&lt; "引数が足りません" &lt;&lt; endl;
    return 1;
  }
  if (strlen(argv[1]) != strlen(argv[2])) {
    cerr &lt;&lt; "引数 (文字列) の長さが異なります" &lt;&lt; endl;
    return 1;
  }
  if (argc == 3) {
    replace_char(argv[1], argv[2], cin, cout);
  } else if (argc &gt;= 4) {
    ifstream fin(argv[3]);
    if (!fin) {
      cerr &lt;&lt; argv[3] &lt;&lt; " が見つかりません" &lt;&lt; endl;
      return 1;
    }
    if (argc == 4) {
      replace_char(argv[1], argv[2], fin, cout);
    } else {
      ofstream fout(argv[4]);
      if (!fout) {
        cerr &lt;&lt;  argv[4] &lt;&lt; " をライトオープンできません" &lt;&lt; endl;
        return 1;
      }
      replace_char(argv[1], argv[2], fin, fout);
    }
  }
}
</pre>
<p> 最初に引数をチェックして、argv[1] と argv[2] の長さが異なればエラー終了します。実際の処理は関数 replace_char() で行います。fin から get() で 1 バイト読み込み、それが文字列 src にあるか関数 position() で検索します。position は単純な線形探索です。見つかった場合は dst[n] を put() で出力し、そうでなければ文字 c を put() で出力します。
</p>

<h4 id="ans47">●解答47</h4>
<pre class="list">
リスト : 文字列の置換

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
using namespace std;

void replace_string(const char* s, const char* d, istream&amp; fin, ostream&amp; fout)
{
  string buff;
  int k = strlen(s);
  while (getline(fin, buff)) {
    int n = 0;
    while (true) {
      n = buff.find(s, n);
      if (n == string::npos) break;
      buff.replace(n, k, d);
      n += k;
    }
    fout &lt;&lt; buff &lt;&lt; endl;
  }
}

int main(int argc, char* argv[])
{
  if (argc &lt; 3) {
    cerr &lt;&lt; "引数が足りません" &lt;&lt; endl;
    return 1;
  }
  if (argc == 3) {
    replace_string(argv[1], argv[2], cin, cout);
  } else if (argc &gt;= 4) {
    ifstream fin(argv[3]);
    if (!fin) {
      cerr &lt;&lt; argv[3] &lt;&lt; " が見つかりません" &lt;&lt; endl;
      return 1;
    }
    if (argc == 5) {
      ofstream fout(argv[4]);
      if (!fout) {
        cerr &lt;&lt; argv[4] &lt;&lt; " をライトオープンできません" &lt;&lt; endl;
        return 1;
      }
      replace_string(argv[1], argv[2], fin, fout);
    } else {
      replace_string(argv[1], argv[2], fin, cout);
    }
  }
}
</pre>
<p> 文字列の置換は関数 replace_string() で行います。replace_string() は getline() で fin から 1 行ずつバッファ buff に読み込みます。変数 k は文字列 key の長さをセットします。一致する文字列をすべて置換するため、find() の返り値が npos になるまで while ループで処理を繰り返します。変数 n が検索開始位置を表します。最初は buff の先頭 (0) に初期化します。
</p>
<p> n が npos でなければ、key が見つかりました。メンバ関数 replace() で、n 番目から k 個の文字を引数の文字列 d に置き換えます。そして、検索開始位置 n を n + k に更新します。key が見つからない場合は buff を fout に出力して、次の行を読み込みます。これをファイルの終端に到達するまで繰り返します。
</p>
<h4 id="ans48">●解答48</h4>
<pre class="list">
リスト : 単語のカウント

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cctype&gt;
using namespace std;


void wc1(istream&amp; fin)
{
  bool inword = false;
  int c, n = 0;
  while ((c = fin.get()) != EOF) {
    if (isspace(c))
      inword = false;
    else {
      if (!inword) {
        inword = true;
        n++;
      }
    }
  }
  cout &lt;&lt; n &lt;&lt; endl;
}

void wc(istream&amp; fin)
{
  int count = 0;
  string buff;
  while (fin &gt;&gt; buff) count++;
  cout &lt;&lt; count &lt;&lt; endl;
}

int main(int argc, char *argv[])
{
  if (argc &gt;= 2) {
    ifstream fin(argv[1]);
    if (!fin) {
      cerr &lt;&lt; argv[1] &lt;&lt; " が見つかりません" &lt;&lt; endl;
      return 1;
    }
    wc1(fin);
  } else {
    wc1(cin);
  }
}
</pre>
<p> 単語のカウントは関数 wc() で行います。入力演算子 &gt;&gt; は空白文字を読み飛ばすので、fin &gt;&gt; buff で単語を読み込むことができます。あとは、ファイルの終端に到達するまで単語を読み込んで count を +1 するだけです。
</p>

<p> 関数 wc1() は別解で、入力演算子を使わずに 1 文字ずつ入力する場合です。単語を読んでいるときは、変数 inword を true にし、空白文字が現れたら inword を false にします。そして、inword を false から true に変更するとき、単語の個数 n をインクリメントします。空白文字のチェックはライブラリ (cctype) の関数 isspace() で簡単に行うことができます。
</p>
<pre class="item">
int isspace(int c);
</pre>
<p> isspace() は文字 c が空白文字であれば真を返します。ASCII コードの場合、isspace() が真を返す空白文字には次の種類があります。
</p>
<pre class="item">
' '  : 空白     (0x20)
'\t' : 水平タブ (0x09)
'\n' : 改行     (0x0a)
'\v' : 垂直タブ (0x0b)
'\f' : 書式送り (0x0c)
'\r' : 復帰     (0x0d)
</pre>
<h4 id="ans49">●解答49</h4>
<pre class="list">
リスト : タブの展開

#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

void detab(istream&amp; fin, ostream&amp; fout)
{
  int col = 0;
  int c;
  while ((c = fin.get()) != EOF) {
    if (c == '\t') {
      do {
        fout.put(' ');
        col++;
      } while (col % 8 != 0);
    } else {
      if (c == '\n')
        col = 0;
      else
        col++;
      fout.put(c);
    }
  }
}

int main(int argc, char *argv[])
{
  if (argc &lt; 2) {
    detab(cin, cout);
  } else if (argc &gt;= 2) {
    ifstream fin(argv[1]);
    if (!fin) {
      cerr &lt;&lt; argv[1] &lt;&lt; " が見つかりません";
      return 1;
    }
    if (argc &gt;= 3) {
      ofstream fout(argv[2]);
      if (!fout) {
        cerr &lt;&lt; argv[2] &lt;&lt; " をライトオープンできません" &lt;&lt; endl;
        return 1;
      }
      detab(fin, fout);
    } else {
      detab(fin, cout);
    }
  }
}
</pre>
<p> 実際の処理は関数 detab() で行います。変数 col が欄の位置を表します。get() で読み込んだ文字 c がタブ (\t) の場合、col % 8 が 0 になるまで put() で空白文字を出力します。これでタブを空白に展開することができます。c が改行文字ならば col を 0 にリセットします。そうでなければ、col をインクリメントして、文字 c を put() で出力します。
</p>
<h4 id="ans50">●解答50</h4>
<pre class="list">
リスト : 空白をタブに置換

#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
void entab(istream&amp; fin, ostream&amp; fout)
{
  int col = 0;
  int c;
  while ((c = fin.get()) != EOF) {
    int sc = 0;
    // 空白を集める
    if (c == ' ') {
      do {
        sc++;
        col++;
        if (col % 8 == 0) {
          fout.put('\t');
          sc = 0;
        }
      } while ((c = fin.get()) == ' ');
      if (sc &gt; 0) while (sc-- &gt; 0) fout.put(' ');
    }
    if (c == '\n') {
      col = 0;
    } else {
      col++;
    }
    fout.put(c);
  }
}

int main(int argc, char *argv[])
{
  if (argc &lt; 2) {
    entab(cin, cout);
  } else if (argc &gt;= 2) {
    ifstream fin(argv[1]);
    if (!fin) {
      cerr &lt;&lt; argv[1] &lt;&lt; " が見つかりません";
      return 1;
    }
    if (argc &gt;= 3) {
      ofstream fout(argv[2]);
      if (!fout) {
        cerr &lt;&lt; argv[2] &lt;&lt; " をライトオープンできません" &lt;&lt; endl;
        return 1;
      }
      entab(fin, fout);
    } else {
      entab(fin, cout);
    }
  }
}
</pre>
<p> 実際の処理は関数 entab() で行います。変数 col が欄の位置を表します。get() で文字を読み込み、文字 c が空白であれば、連続している空白の個数を変数 sc に求めます。このとき、col % 8 が 0 になったならば、連続している空白をタブに置換することができます。put() でタブを出力して、sc の値を 0 にリセットします。
</p>
<p> do - while ループが終了して、sc が 0 よりも大きい場合、その空白はタブに置換することができません。put() で空白を sc 個だけ出力します。文字 c が空白文字でなければ、文字 c が改行文字かチェックします。そうであれば、col を 0 にリセットします。あとは、文字 c をそのまま put() で出力するだけです。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp28.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp30.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>