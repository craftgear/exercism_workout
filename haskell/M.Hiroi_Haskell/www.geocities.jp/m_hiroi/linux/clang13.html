<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881808</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang12.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang14.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>二分探索木</h3>
<p> 今回は簡単な例題として「二分探索木 (binary search tree) 」を取り上げます。二分探索木は「木構造 (tree structer) 」または「木 (tree) 」と呼ばれるデータ構造の一種です。最初に木について簡単に説明します。
</p>
<h4>●木構造</h4>
<p> 木は「節 (ノード) 」と呼ばれる要素に対して、階層的な関係を表したものです。身近な例では、ディレクトリの階層構造が木にあたります。ディレクトリに「ルートディレクトリ」があるように、木にも「根 (ルート) 」と呼ばれる節が存在します。下図を見てください。
</p>
<pre class="fig">
          (root)
            Ａ    ────────  レベル０
          ／｜＼                ↑
        ／  ｜  ＼
      Ｂ    Ｃ    Ｄ            木  レベル１
    ／｜＼        ｜＼          の
  ／  ｜  ＼      ｜  ＼        高
Ｅ    Ｆ    Ｇ    Ｈ    Ｉ      さ  レベル２
          ／  ＼
        ／      ＼              ↓
      Ｊ          Ｋ    ─────  レベル３


        図 : 一般的な木構造の一例
</pre>
<p> 木を図示する場合、階層関係がはっきりわかるように、根を上にして、同じ階層にある節を並べて書きます。根からレベル 0、レベル 1 と階層を数えていき、最下層の節までの階層数を「木の高さ」といいます。木は、ある節から下の部分を切り出したものも、木としての性質を持っています。これを「部分木」といいます。
</p>
<p> 木は、ある節からほかの節に至る「経路」を考えることができます。たとえば、A から J には、A - B - G - J という経路がありますね。これは、ディレクトリやファイルを指定するときのパスと同じです。
</p>
<p> ある節から根の方向にさかのぼるとき、途中で通っていく節を「先祖」といい、直接繋がっている節を「親」といます。これは、逆から見ると「子孫」と「子」という関係になります。子を持たない節をとくに「葉」と呼ぶことがあります。上図でいうと、G は J, K の親で、J は G の子になります。J は子を持っていないので葉となります。
</p>
<p> 子は、「左 &lt; 右」の順番で節に格納するのが一般的です。これを「順序木」といいます。また、順番がない木を「無順序木」と呼びます。節が持っている子の数を「次数」といいます。上図の場合、A は 3 つの子 B, C, D を持っているので、A の次数は 3 となります。すべての節の次数を n に揃えた順序木を「 n 分木」と呼びます。
</p>
<h4>●二分木</h4>
<p> 特に、次数が 2 の二分木は、プログラムでよく使われるデータ構造です。
</p>
<pre class="fig">
                    (root)
                      18
                    ／  ＼
                  ／      ＼
                ／          ＼
              ／              ＼
            ／                  ＼
          14                      22
        ／  ＼                  ／  ＼
      ／      ＼              ／      ＼
    12          16          20          24
  ／  ＼      ／  ＼      ／  ＼      ／  ＼
11      13  15      17  19      21  23      25


             図 : 二分木の一例
</pre>
<p> 上図に二分木の例を示します。二分木では、節に一つのデータを格納します。そして、その節の左側の子には小さいデータが、右側の子には大きいデータが配置されるように木を構成します。
</p>
<p> この二分木をデータの探索に使うアルゴリズムが「二分探索木」です。二分探索木はデータの探索・挿入を高速に行うことができます。たとえば、上図の木から 19 を探してみましょう。まず root の 18 と比較します。18 &lt; 19 ですから、右側の子をたどり 22 と比較します。今度は 19 &lt; 22 なので左側の子をたどります。次は 20 と比較し 19 &lt; 20 なので左側の子をたどり、ここで 19 を見つけることができます。
</p>
<p> 二分探索木の探索は「二分探索」と同じ原理です。左右どちらかの子をたどるたびに、探索するデータ数は半分になります。上図の場合でも、探索するデータ数が 15, 7, 3, 1 となり、最後に見つけることができました。
</p>
<p> データ数を N とすると、単純な線形探索では平均で N / 2 回の比較が必要になりますが、二分探索木を使うと log<SUB>2</SUB> N 程度の回数で収まります。たとえば、データが 100個ある場合、線形探索では 50 回データを比較しなければいけないのに、二分探索木では 7 回程度の比較で済むわけです。
</p>
<p> ただし、これは左右の部分木のバランスがとれている理想的な状態での話です。バランスが崩れると二分探索木の性能は劣化し、最悪の場合は線形探索と同じになってしまいます。そこで、左右のバランスを一定の範囲に収める「平衡木 (balanced tree) 」が考案されています。有名なところでは AVL 木、2 色木 (赤黒木)、2-3 木、B 木、B* 木などがあります。
</p>
<h4>●節の定義</h4>
<p> それではプログラムを作りましょう。まず最初に、節を表す構造体を定義します。
<pre class="list">
リスト : 節の定義

// 節の定義
typedef struct node {
  double item;
  struct node *left;
  struct node *right;
} Node;

// 節の生成
static Node *make_node(double x)
{
  Node *node = malloc(sizeof(Node));
  if (node != NULL) {
    node-&gt;item = x;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
  }
  return node;
}
</pre>

<p> 連結リストと違い、節へのポインタが 2 つ必要になります。left が左の子、right が右の子を表します。子を持たない場合は、連結リストと同様に NULL をセットすることにします。二分木に格納するデータ item の型は double とします。関数 make_node は malloc で節本体のメモリを取得し、item を引数 x に、left と right を NULL に初期化します。
</p>
<p> 連結リストのように、節を箱で表すと下図のようになります。
<pre class="fig">
 変数 root
   ┌─┐    
   │  ┼──┐
   └─┘    │
             ↓
           ┌─┬─┬─┐
           │18│・│・│
           └─┴┼┴┼┘
                 │  │
   ┌──────┘  └─┐
   ↓                    ↓
 ┌─┬─┬─┐        ┌─┬─┬─┐
 │14│／│／│        │22│／│／│
 └─┴─┴─┘        └─┴─┴─┘

      ┌─┬─┬─┐
  節：│Ｄ│Ｌ│Ｒ│
      └─┴─┴─┘
  Ｄ：data, Ｌ：left, Ｒ：right, ／：NULL

           図 : 二分木の構造
</pre>

<p> 連結リストと同様に、ルートへの参照を変数 root に格納しておけば、この変数を使って二分木にアクセスすることができます。また、節が一つもない空の木は、変数 root に NULL をセットすれば表すことができます。なお、NULL のかわりに終端を表す節を用意する方法もあります。
</p>
<p> 今回は節 (Node) のほかに、root を格納する構造体 Tree を定義することにします。そして、節を操作する関数 (xxx_node) を static 宣言し、ユーザに公開するのは Tree を操作する関数 (xxx_tree) だけに限定します。分割コンパイルできるように、ソースファイルは tree,h と tree.c に分けて記述します。
</p>
<h4>●データの探索</h4>
<p> それでは、データを探索する関数 search_node から作りましょう。次のリストを見てください。
<pre class="list">
リスト : データの探索

static bool search_node(double x, Node *node)
{
  while (node != NULL) {
    if (node-&gt;item == x)
      return true;
    else if (x &lt; node-&gt;item)
      node = node-&gt;left;
    else
      node = node-&gt;right;
  }
  return false;
}
</pre>
<p> 関数 search_node には節 node と探索するデータ x を渡します。x と node-&gt;item を比較し、値が等しければ true を返します。x が小さいのであれば左の子をたどり、そうでなければ右の子をたどります。たどるべき木がなくなれば node の値は NULL になるので、while ループを終了し false を返します。二分探索木の動作をそのままプログラムしているだけなので、難しいところはないと思います。
</p>
<h4>●データの挿入</h4>
<p> 次は、データを挿入する関数 insert_node を作ります。この関数は木を引数として受け取り、データを挿入した新しい木を返します。たとえば、変数 root に木が格納されている場合、データを挿入するときは次のように呼び出します。
</p>
<pre class="item">
root = insert_node(x, root)
</pre>
<p> この処理は再帰定義を使うと簡単にプログラムできます。次のリストを見てください。
</p>
<pre class="list">
リスト : データの挿入

static Node *insert_node(double x, Node *node)
{
  if (node == NULL)
    return make_node(x);
  else if (x &lt; node-&gt;item)
    node-&gt;left = insert_node(x, node-&gt;left);
  else if (x &gt; node-&gt;item)
    node-&gt;right = insert_node(x, node-&gt;right);
  return node;
}
</pre>
<p> 最初に節 node が NULL かチェックします。そうであれば木は空なので、新しい節を make_node(x) で生成して返します。たとえば、変数 root が NULL の場合、すなわち空の木であれば、新しい節が生成されて root にセットされます。
</p>
<p> そうでなければ、x と node-&gt;item を比較します。x と等しいデータが見つかった場合は、新しいデータを挿入する必要はないので、何も行わずに node を返します。x が小さい場合は、左部分木に x を挿入します。ここで関数 insert_node を再帰呼び出しします。そして、返り値を node-&gt;left にセットして node を返します。
</p>
<p> たとえば、node-&gt;left が NULL の場合、再帰呼び出しの返り値は新しい節なので、それが node-&gt;left にセットされ、木にデータが挿入されたことになります。そして、新しいデータが挿入された木 (node) を返せばいいわけです。x が item よりも大きければ、同様に右部分木にデータを挿入します。
</p>
<p> けっきょく、子を格納している節には、同じ子が再度セットされることになります。無駄なように思われるかもしれませんが、その分だけ簡単にプログラムを作ることができます。
</p>
<h4>●データの削除</h4>
<p> 次はデータを削除する処理を作りましょう。これは今までと違って少々面倒です。削除するデータが「葉」の場合は、それを削除するだけなので簡単ですが、木の途中のデータを削除する場合は、二分木の構成を崩さないように注意しないといけません。最初に、葉を削除する場合を説明します。下図を見てください。
</p>
<pre class="fig">
          14                            14
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          16
  ／  ＼      ／  ＼            ／  ＼      ／  ＼
11      13  15      17        11      13 NULL     17
                                          ↑
    15 を削除する                        削除

             図 : データの削除（葉の場合）
</pre>
<p> 15 を削除する場合を考えてみましょう。15 は「葉」にあたるので、それを削除するだけで大丈夫です。親の left に NULL を代入するだけです。
</p>
<p> 次に、子が一つある場合を考えてみましょう。
<pre class="fig">
          14                            14
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          15
  ／  ＼      ／                ／  ＼
11      13  15                11      13

    16 を削除する

          図 : データの削除（子が一つの場合）
</pre>
<p> 16 を削除する場合、その子である 15 と置き換えれば二分探索木の構成は保たれます。これも簡単ですね。問題は、子が二つある節を削除する場合です。
</p>
<pre class="fig">
          14                            15  &lt;- 最小値と置き換え
        ／  ＼                        ／  ＼
      ／      ＼                    ／      ＼
    12          16       =&gt;       12          16
  ／  ＼      ／  ＼            ／  ＼      ／  ＼
11      13  15      17        11      13  nil     17
                                          ↑
    14 を削除する                        削除

          図 : データの削除（子が二つの場合）
</pre>
<p> この場合、削除するデータの右部分木の中から最小値のデータ <sup><a href="clang13.html#note1">[*1]</a></sup> を探し、それと削除するデータと置き換えれば「右部分木 &lt; 節 &lt; 左部分木」の構成を崩さなくてすみます。上図で、14 を削除することを考えてみましょう。右部分木の中で 15 が最小値なので、それと 14 を置き換えます。そして、15 を格納していた節は削除します。節が最小値を格納している場合、その節の左側の子は存在しないので、その節を削除することは簡単です。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 逆に、左部分木の中から最大値を探し、それと削除するデータを置き換えてもかまいません。
</div>

<h4>●最小値の探索と削除</h4>
<p> まず、木の中から最小値を探す関数と、最小値の節を削除する関数を作りましょう。次のリストを見てください。
<pre class="list">
リスト : 最小値の探索と削除

// 最小値の探索
static double search_min(Node *node)
{
  while (node-&gt;left != NULL) node = node-&gt;left;
  return node-&gt;item;
}

// 最小値の削除
static Node *delete_min(Node *node)
{
  if (node-&gt;left == NULL) {
    Node *temp = node-&gt;right;
    free(node);
    return temp;
  }
  node-&gt;left = delete_min(node-&gt;left);
  return node;
}
</pre>
<p> 最小値は簡単に求めることができます。左の子を順番にたどっていき、左の子がない節に行き着いたとき、その節のデータが最小値になります。関数 search_min は、最小値を求めてそれを返します。最初に、node-&gt;left の値をチェックします。もし、NULL であれば左の子がないので、その節のデータが最小値です。return で node-&gt;item を返します。そうでなければ、search_min を再帰呼び出しして左の子をたどります。
</p>
<p> 関数 delete_min は最小値を格納している節を削除します。node-&gt;left が NULL の節を探すのは search_min と同じです。見つけた場合、一時変数 temp に node-&gt;right をセットして、削除する node を free で解放します。最後に temp を返します。これで、親の左部分木が書き換えられ、最小値を持つ節が削除されます。葉の場合であれば node-&gt;right は NULL なので、単純に削除されることになります。
</p>
<p> 左の子があれば delete_min を再帰呼び出しして、その左部分木の中から最小値を探し出して削除します。そして、その返り値を node-&gt;left にセットして、return で node を返します。
</p>
<h4>●データ削除のプログラム</h4>
<p> それでは、データを削除する関数 delete_node を作ります。まず削除するデータを探索して、見つけたら子の有無に合わせた削除処理を行います。
</p>
<pre class="list">
リスト : データの削除

static Node *delete_node(double x, Node *node)
{
  if (node == NULL) return NULL;
  if (x == node-&gt;item) {
    if (node-&gt;left == NULL) {
      Node *temp = node-&gt;right;
      free(node);
      return temp;
    }
    if (node-&gt;right == NULL) {
      Node *temp = node-&gt;left;
      free(node);
      return temp;
    }
    node-&gt;item = search_min(node-&gt;right);
    node-&gt;right = delete_min(node-&gt;right);
  } else if (x &lt; node-&gt;item)
    node-&gt;left = delete_node(x, node-&gt;left);
  else
    node-&gt;right = delete_node(x, node-&gt;right);
  return node;
}
</pre>
<p> まず、node が NULL ならば木は空なので、何もしないで NULL を返します。削除するデータが見つからない場合や空の木を与えた場合がこれに相当します。次に、削除するデータ x と node-&gt;item を比較します。等しい場合はその節を削除します。node-&gt;left が NULL の場合は node-&gt;right を返し、node-&gt;right が NULL の場合は node-&gt;left を返します。
</p>
<p> 子が 2 つある場合は、右部分木の最小値を関数 search_min で求め、node-&gt;item の値を書き換えます。そして、関数 delete_min で最小値を格納していた節を削除します。これで、削除するデータを最小値で置き換え、不要になった節を二分木から削除することができます。x と item が等しくない場合は、左右の部分木をたどって削除するデータを探索します。最後に node を返します。
</p>

<h4>●巡回 (traverse)</h4>
<p> 最後に、二分木のすべての要素にアクセスする関数を作りましょう。二分木はデータの大小関係を使って構成されているので、ある順番で節をすべて出力すると、それはソートした結果と同じになります。「木」のすべての節を規則的な順序で回ることを「巡回 (traverse) 」といいいます。このなかで、次の 3 つの方法が重要です。
</p>
<ol>
 <li>行きがけ順<BR>
    まず節のデータを出力、その後左の子、右の子の順番で出力する。
 <li>帰りがけ順<BR>
    左の子、右の子と出力してから、節のデータを出力する。
 <li>通りがけ順<BR>
    左の子を出力、次に節のデータを出力、最後に右の子を出力する。
</ol>

<p> 名前の由来は、節のデータを出力するタイミングからきています。節に最初に到達したときに出力する方法が「行きがけ」、子を出力してその節に戻ってきたときに出力する方法が「帰りがけ」、子を出力する途中でその節に戻ってきたときに出力する方法が「通りがけ」です。
</p>
<p> 二分木は「左の子 &lt; 節のデータ &lt; 右の子」という関係が成り立つので、通りがけ順に出力すれば、ソートされた出力結果を得ることができます。この処理も、再帰定義を使えば簡単に実現できます。次のリストを見てください。
</p>
<pre class="list">
リスト : 木の巡回

static void foreach_node(void (*func)(double), Node *node)
{
  if (node != NULL) {
    foreach_node(func, node-&gt;left);
    func(node-&gt;item);
    foreach_node(func, node-&gt;right);
  }
}
</pre>
<p> 関数 foreach_node は高階関数で、通りがけ順で木を巡回します。node が NULL でなければ、再帰呼び出しで左部分木を巡回してから関数 func(node-&gt;item) を実行し、そのあとで右部分木を巡回します。たとえば、次に示すようにデータを出力する関数を引数 func に与えれば、二分木のデータを昇順に表示することができます。
<pre class="list">
リスト : 要素の表示

void print_item(double x)
{
  printf("%.3f ", x);
}
</pre>

<h4>●構造体 Tree と操作関数の定義</h4>
<p> 最後に、構造体 Tree と操作関数を定義します。Tree の操作関数を下表に示します。
</p>
<table border=1>
<caption>表 : Tree の操作関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>Tree *make_tree(void);</td><td>空の二分木を生成する</td></tr>
  <tr><td>void destroy_tree(Tree *tree);</td><td>tree を廃棄する</td></tr>
  <tr><td>bool search_tree(double x, Tree *tree);</td><td>tree から x を探索する</td></tr>
  <tr><td>double search_min_tree(Tree *tree, bool *err)</td><td>tree の最小値を求める</td></tr>
  <tr><td>double search_max_tree(Tree *tree, bool *err)</td><td>tree の最大値を求める</td></tr>
  <tr><td>void insert_tree(double x, Tree *tree);</td><td>tree に x を挿入する</td></tr>
  <tr><td>void delete_tree(double x, Tree *tree);</td><td>tree から x を削除する</td></tr>
  <tr><td>void delete_min_tree(Tree *tree, bool *err);</td><td>tree の最小値を削除する</td></tr>
  <tr><td>void delete_max_tree(Tree *tree, bool *err);</td><td>tree の最大値を削除する</td></tr>
  <tr><td>void foreach_tree(void (*func)(double), Tree *tree);</td><td>tree を巡回して、要素を関数 func に渡して呼び出す</td></tr>
  <tr><td>bool is_empty_tree(Tre *tree);</td><td>tree が空ならば真を返す</td></tr>
</tbody>
</table>
<p> Tree の定義と主な操作関数は次のようになります。
</p>
<pre class="list">
リスト : 構造体 Tree と操作関数の定義

// 木の定義
typedef struct {
  Node *root;
} Tree;

// 木の生成
Tree *make_tree(void)
{
  Tree *tree = malloc(sizeof(Tree));
  if (tree != NULL) {
    tree-&gt;root = NULL;
  }
  return tree;
}

// データの探索
bool search_tree(double x, Tree *tree)
{
  return search_node(x, tree-&gt;root);
}

// データの挿入
void insert_tree(double x, Tree *tree)
{
  tree-&gt;root = insert_node(x, tree-&gt;root);
}

// データの削除
void delete_tree(double x, Tree *tree)
{
  tree-&gt;root = delete_node(x, tree-&gt;root);
}
</pre>
<p> Tree のメンバ変数は root で、これが二分木の根 (ルート) になります。あとは、処理に対応する操作関数を呼び出すだけです。
</p>
<p> 二分木を廃棄するときは関数 destory_tree を呼び出します。
</p>
<pre class="list">
リスト : 二分木の廃棄

// 節の廃棄
static void destroy_node(Node *node)
{
  if (node != NULL) {
    destroy_node(node-&gt;left);
    destroy_node(node-&gt;right);
    free(node);
  }
}

// 木の廃棄
void destroy_tree(Tree *tree)
{
  destroy_node(tree-&gt;root);
  free(tree);
}
</pre>
<p> destroy_tree は関数 destory_node を呼び出して節を廃棄し、そのあとで tree を free で解放します。destory_node は traverse とほぼ同じ処理で、node が NULL でなければ、左部分木と右部分木を destory_node で廃棄してから node 本体を free で解放します。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="clang13.html#list1">プログラムリスト</a> をお読みください。
</p>
<h4>●簡単なテスト</h4>
<p> それでは実際に実行してみましょう。次に示す簡単なテストを行ってみました。
</p>
<pre class="list">
リスト : 簡単なテスト

#define N 10

void test1(void)
{
  double buff[N] = {5,6,4,7,3,8,2,9,1,0};
  Tree *tree = make_tree();
  for (int i = 0; i &lt; N; i++) {
    insert_tree(buff[i], tree);
    print_tree(tree);
  }
  for (int i = -1; i &lt; N + 1; i++) 
    printf("%d\n", search_tree(i, tree));
  for (int i = 0; i &lt; N; i++) {
    delete_tree(buff[i], tree);
    print_tree(tree);
  }
  destroy_tree(tree);
}

int main(void)
{
  test1();
  return 0;
}
</pre>
<p> 実行結果を示します。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./tree
5.000 
5.000 6.000 
4.000 5.000 6.000 
4.000 5.000 6.000 7.000 
3.000 4.000 5.000 6.000 7.000 
3.000 4.000 5.000 6.000 7.000 8.000 
2.000 3.000 4.000 5.000 6.000 7.000 8.000 
2.000 3.000 4.000 5.000 6.000 7.000 8.000 9.000 
1.000 2.000 3.000 4.000 5.000 6.000 7.000 8.000 9.000 
0.000 1.000 2.000 3.000 4.000 5.000 6.000 7.000 8.000 9.000 
0
1
1
1
1
1
1
1
1
1
1
0
0.000 1.000 2.000 3.000 4.000 6.000 7.000 8.000 9.000 
0.000 1.000 2.000 3.000 4.000 7.000 8.000 9.000 
0.000 1.000 2.000 3.000 7.000 8.000 9.000 
0.000 1.000 2.000 3.000 8.000 9.000 
0.000 1.000 2.000 8.000 9.000 
0.000 1.000 2.000 9.000 
0.000 1.000 9.000 
0.000 1.000 
0.000 
</pre>
<p> 正常に動作していますね。
</p>
<h4>●簡単なテスト (2)</h4>
<p> 次は、挿入、探索、削除の実行時間と、二分木の高さを求めてみましょう。二分木の高さ求める関数 height_tree は次のようになります。
</p>
<pre class="list">
リスト : 木の高さ

int height_node(Node *node)
{
  if (node == NULL) return 0;
  int a = height_node(node-&gt;left);
  int b = height_node(node-&gt;right);
  return 1 + (a &gt; b ? a : b);
}

int height_tree(Tree *tree)
{
  return height_node(tree-&gt;root);
}
</pre>
<p> 実際の処理は関数 height_node で行います。引数 node が NULL ならば 0 を返します。次に、height_node を再帰呼び出しして、右部分木と左部分木の高さを求めます。あとは、大きいほうの値に 1 を足して返すだけです。これで二分木の高さを求めることができます。
</p>
<p> テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : 簡単なテスト (2)

#define M 2000000

double buff[M];

void test2(void)
{
  for (int n = 250000; n &lt;= M; n *= 2) {
    Tree *tree = make_tree();
    for (int i = 0; i &lt; n; i++) buff[i] = rand();
    shuffle(buff, n);
    printf("----- %d -----\n", n);
    clock_t s = clock();
    for (int i = 0; i &lt; n; i++) 
      insert_tree(buff[i], tree);
    printf("挿入時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    printf("高さ %d\n", height_tree(tree));
    s = clock();
    for (int i = 0; i &lt; n; i++)
      if (!search_tree(buff[i], tree)) fprintf(stderr, "search error\n");
    printf("探索時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    s = clock();
    for (int i = 0; i &lt; n; i++)
      delete_tree(buff[i], tree);
    printf("削除時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    destroy_tree(tree);
  }
}
</pre>
<p> 0 から n - 1 までのデータを配列 buff に格納し、関数 shuffle でシャッフルします。あとは、二分木 tree に挿入する時間、探索する時間、削除する時間を計測します。このとき、二分木の高さを height_tree で求めます。実行結果は次のようになりました。
</p>
<pre>
  表 : 実行結果 (単位 : 秒)

  個数  : 挿入  探索  削除   高さ (log<sub>2</sub> N)
-----------------------------------------
 250000 : 0.118 0.084 0.095  47 (18)
 500000 : 0.346 0.291 0.300  45 (19)
1000000 : 1.016 0.876 0.863  50 (20)
2000000 : 2.616 2.297 2.224  54 (21)

実行環境 : Lubuntu 14.10 on VirtualBox, Core i7-2670QM 2.20GHz
</pre>
<p> データの挿入が一番遅くなりました。データ数が多くなると探索よりも削除のほうが少しだけ速くなりました。データを挿入したときと同じ順番で削除しているので、それが影響しているのかもしれません。
</p>
<p> 二分木の高さは log<sub>2</sub> N の約 2.5 倍ほど高くなりました。まあ、コンピュータで扱う乱数は「擬似乱数」なので、二分木のバランスが崩れるのはしょうがないでしょう。AVL 木などの平衡木を使うと、木の高さをもっと低く抑えることができるので、データの探索はもっと速くなります。興味のある方は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo12.html">AVL 木 [1]</a>, <a href="../light/pyalgo13.html">[2]</a> をお読みください。ほかにも、2-3 木と赤黒木を説明しています。
</p>
<hr>
<h4 id="list1">●プログラムリスト</h4>
<pre class="list">
/*
 * tree.h : 二分探索木
 *
 *          Copyright (C) 2015 Makoto Hiroi
 */
#ifndef _TREE_H_
#define _TREE_H_

#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

// 節の定義
typedef struct node {
  double item;
  struct node *left;
  struct node *right;
} Node;

// 木の定義
typedef struct {
  Node *root;
} Tree;

// 関数宣言
Tree *make_tree(void);
void destroy_tree(Tree *tree);
bool is_empty_tree(Tree *tree);
bool search_tree(double x, Tree *tree);
double search_min_tree(Tree *tree, bool *err);
double search_max_tree(Tree *tree, bool *err);
void insert_tree(double x, Tree *tree);
void delete_tree(double x, Tree *tree);
void delete_min_tree(Tree *tree);
void delete_max_tree(Tree *tree);
void foreach_tree(void (*func)(double), Tree *tree);
</pre>
<hr>
<pre class="list">
/*
 * tree.c : 二分探索木
 *
 *          Copyright (C) 2015 Makoto Hiroi
 */
#include "tree.h"

// 節の生成
static Node *make_node(double x)
{
  Node *node = malloc(sizeof(Node));
  if (node != NULL) {
    node-&gt;item = x;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
  }
  return node;
}

// 節の廃棄
static void destroy_node(Node *node)
{
  if (node != NULL) {
    destroy_node(node-&gt;left);
    destroy_node(node-&gt;right);
    free(node);
  }
}

// データの探索
static bool search_node(double x, Node *node)
{
  while (node != NULL) {
    if (node-&gt;item == x)
      return true;
    else if (x &lt; node-&gt;item)
      node = node-&gt;left;
    else
      node = node-&gt;right;
  }
  return false;
}

// データの挿入
static Node *insert_node(double x, Node *node)
{
  if (node == NULL)
    return make_node(x);
  else if (x &lt; node-&gt;item)
    node-&gt;left = insert_node(x, node-&gt;left);
  else if (x &gt; node-&gt;item)
    node-&gt;right = insert_node(x, node-&gt;right);
  return node;
}

// 最小値の探索
static double search_min(Node *node)
{
  while (node-&gt;left != NULL) node = node-&gt;left;
  return node-&gt;item;
}

// 最大値の探索
static double search_max(Node *node)
{
  while (node-&gt;right != NULL) node = node-&gt;right;
  return node-&gt;item;
}

// 最小値の削除
static Node *delete_min(Node *node)
{
  if (node-&gt;left == NULL) {
    Node *temp = node-&gt;right;
    free(node);
    return temp;
  }
  node-&gt;left = delete_min(node-&gt;left);
  return node;
}

// 最大値の削除
static Node *delete_max(Node *node)
{
  if (node-&gt;right == NULL) {
    Node *temp = node-&gt;left;
    free(node);
    return temp;
  }
  node-&gt;right = delete_max(node-&gt;right);
  return node;
}

// データの削除
static Node *delete_node(double x, Node *node)
{
  if (node == NULL) return NULL;
  if (x == node-&gt;item) {
    if (node-&gt;left == NULL) {
      Node *temp = node-&gt;right;
      free(node);
      return temp;
    }
    if (node-&gt;right == NULL) {
      Node *temp = node-&gt;left;
      free(node);
      return temp;
    }
    node-&gt;item = search_min(node-&gt;right);
    node-&gt;right = delete_min(node-&gt;right);
  } else if (x &lt; node-&gt;item)
    node-&gt;left = delete_node(x, node-&gt;left);
  else
    node-&gt;right = delete_node(x, node-&gt;right);
  return node;
}

// 巡回
static void foreach_node(void (*func)(double), Node *node)
{
  if (node != NULL) {
    foreach_node(func, node-&gt;left);
    func(node-&gt;item);
    foreach_node(func, node-&gt;right);
  }
}

//
// 公開する関数
//

// 木の生成
Tree *make_tree(void)
{
  Tree *tree = malloc(sizeof(Tree));
  if (tree != NULL) {
    tree-&gt;root = NULL;
  }
  return tree;
}

// 木の廃棄
void destroy_tree(Tree *tree)
{
  destroy_node(tree-&gt;root);
  free(tree);
}

// 空の木か
bool is_empty_tree(Tree *tree)
{
  return tree-&gt;root == NULL;
}

// データの探索
bool search_tree(double x, Tree *tree)
{
  return search_node(x, tree-&gt;root);
}

// 最小値を求める
double search_min_tree(Tree *tree, bool *err)
{
  if (is_empty_tree(tree)) {
    *err = false;
    return 0;
  }
  *err = true;
  return search_min(tree-&gt;root);
}

// 最大値を求める
double search_max_tree(Tree *tree, bool *err)
{
  if (is_empty_tree(tree)) {
    *err = false;
    return 0;
  }
  *err = true;
  return search_max(tree-&gt;root);
}

// データの挿入
void insert_tree(double x, Tree *tree)
{
  tree-&gt;root = insert_node(x, tree-&gt;root);
}

// データの削除
void delete_tree(double x, Tree *tree)
{
  tree-&gt;root = delete_node(x, tree-&gt;root);
}

// 最小値を削除
void delete_min_tree(Tree *tree)
{
  if (!is_empty_tree(tree))
    tree-&gt;root = delete_min(tree-&gt;root);
}

// 最大値を削除
void delete_max_tree(Tree *tree)
{
  if (!is_empty_tree(tree))
    tree-&gt;root = delete_max(tree-&gt;root);
}

// 巡回
void foreach_tree(void (*func)(double), Tree *tree)
{
  foreach_node(func, tree-&gt;root);
}
</pre>
<pre class="list">
リスト : main.c

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include "tree.h"

// データの表示
void print_item(double x)
{
  printf("%.3f ", x);
}

void print_tree(Tree *tree)
{
  foreach_tree(print_item, tree);
  printf("\n");
}

// 木の高さ
int height_node(Node *node)
{
  if (node == NULL) return 0;
  int a = height_node(node-&gt;left);
  int b = height_node(node-&gt;right);
  return 1 + (a &gt; b ? a : b);
}

int height_tree(Tree *tree)
{
  return height_node(tree-&gt;root);
}

// シャッフル
void shuffle(double *buff, int size)
{
  for (int i = size - 1; i &gt; 0; i--) {
    int j = rand() % (i + 1);
    double tmp = buff[i];
    buff[i] = buff[j];
    buff[j] = tmp;
  }
}

#define N 10

void test1(void)
{
  double buff[N] = {5,6,4,7,3,8,2,9,1,0};
  Tree *tree = make_tree();
  for (int i = 0; i &lt; N; i++) {
    insert_tree(buff[i], tree);
    print_tree(tree);
  }
  for (int i = -1; i &lt; N + 1; i++) 
    printf("%d\n", search_tree(i, tree));
  for (int i = 0; i &lt; N; i++) {
    delete_tree(buff[i], tree);
    print_tree(tree);
  }
  destroy_tree(tree);
}

#define M 2000000

double buff[M];

void test2(void)
{
  for (int n = 250000; n &lt;= M; n *= 2) {
    Tree *tree = make_tree();
    for (int i = 0; i &lt; n; i++) buff[i] = rand();
    printf("----- %d -----\n", n);
    clock_t s = clock();
    for (int i = 0; i &lt; n; i++) 
      insert_tree(buff[i], tree);
    printf("挿入時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    printf("高さ %d\n", height_tree(tree));
    s = clock();
    for (int i = 0; i &lt; n; i++)
      if (!search_tree(buff[i], tree)) fprintf(stderr, "search error\n");
    printf("探索時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    s = clock();
    for (int i = 0; i &lt; n; i++)
      delete_tree(buff[i], tree);
    printf("削除時間 %.3f\n", (double)(clock() - s) / CLOCKS_PER_SEC);
    destroy_tree(tree);
  }
}

int main(void)
{
  test1();
  test2();
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang12.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang14.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>