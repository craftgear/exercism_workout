<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Perl プログラミング超入門</title>
  <meta name="description" content="Perl,Perl入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881814</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Perl プログラミング超入門</h2>
<div class="small">
[ <a href="perl02.html">PrevPage</a> | <a href="perl.html">Perl</a> | <a href="perl04.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>正規表現 (前編)</h3>
<p> 今回は Perl の強力な文字列処理の中心である「正規表現 (regular expression) 」を取り上げます。正規表現は、Unix 系 OS のコマンド grep, sed, awk などで使われる「文字列のパターンを示した式」のことです。Perl の正規表現は、基本的には awk と同じです。そこにいくつかの拡張機能が追加されています。最初に awk で採用されている基本的な正規表現について説明します。
</p>

<h4>●正規表現の基礎知識</h4>
<p> 正規表現は、ワイルドカードの * や ? のように、ある文字に特別の意味を持たせています。これを「メタ文字」といいます。このメタ文字を組み合わせることで、複雑な条件を表すことができます。基本的なメタ文字を下表に示します。
</p>
<table border=1>
<caption>表 : 基本的なメタ文字</caption>
<thead>
  <tr><th>記号</th><th>意味</th></tr>
</thead>
<tbody>
  <tr><td><b>|</b></td><td>この前後にある正規表現のどちらかと一致する</td></tr>
  <tr><td><b>*</b></td><td>直前の正規表現の０回以上の繰り返しに一致する</td></tr>
  <tr><td><b>+</b></td><td>直前の正規表現の１回以上の繰り返しに一致する</td></tr>
  <tr><td><b>?</b></td><td>直前の正規表現に０回もしくは１回一致する</td></tr>
  <tr><td><b>[...]</b></td><td> ... に指定した文字のどれかと一致する</td></tr>
  <tr><td><b>[^...]</b></td><td> ...  に指定した文字でない場合に一致する</td></tr>
  <tr><td><b>.</b></td><td>任意の１文字と一致する</td></tr>
  <tr><td><b>^</b></td><td>行頭と一致する</td></tr>
  <tr><td><b>$</b></td><td>行末と一致する</td></tr>
  <tr><td><b>( )</b></td><td>正規表現をグループにまとまる</td></tr>
</tbody>
</table>

<p> それでは、具体的に説明していきましょう。まず大前提として、メタ文字以外の文字は、それ自身の正規表現です。つまり、abc という正規表現は、文字列 abc と一致します。
</p>
<p> メタ文字 <b>.</b> はどんな文字にも一致します。
</p>
<pre class="item">
a.c   =&gt; aac, abc, aAc, aBc
a..c  =&gt; aaac, abcc, aABc
</pre>

<p> これは簡単ですね。ファイルのワイルドカード ? と似ています。
</p>
<p> 次は文字クラス <b>[ ]</b> です。[ ] 中の文字のどれかと一致します。
</p>
<pre class="item">
a[ABC]c    =&gt; aAc, aBc, aCc
a[AB][CD]c =&gt; aACc, aADc, aBCc, aBDc
</pre>

<p> 文字クラスは、- を使って文字の範囲を表すことができます。文字コードの大小関係が逆になると、範囲を示さずその文字が文字クラスの指定になります。
</p>
<pre class="item">
[a-zA-Z]    ; アルファベットと一致
[0-9]       ; 数値と一致
[z-a]       ; a, -, z と一致
[a-]        ; a, - と一致
</PRE>

<p> 文字クラスの先頭に ^ を付けると、指定した文字以外の文字と一致します。^ は先頭に付けたときに有効で、それ以外の位置では通常の文字として扱われます。
</p>
<pre class="item">
[^a-zA-Z]    ; アルファベット以外の文字と一致
[^0-9]       ; 数値以外の文字と一致
[^z-a]       ; a, -, z 以外の文字と一致
[^a-]        ; a, - 以外の文字と一致
</pre>

<p> メタ文字 <b>*</b> と <b>+</b> と <b>?</b> は、繰り返しを指定します。* は直前の正規表現の 0 回以上の繰り返しと一致します。0 回以上とは空文字列にも一致する、というとです。
</p>
<pre class="item">
a*b   =&gt; b  （a がない場合にも一致する）
         ab aab aaaab aaaaab など
</pre>

<p> + は直前の正規表現の 1 回以上の繰り返しと一致します。* と違って空文字列とは一致しません。
</p>
<pre class="item">
a+b   =&gt; ab aab aaaab aaaaab など  （b とは一致しない）
</pre>

<p> ? は空文字列もしくは直前の正規表現と一致します。
</p>
<pre class="item">
a?b   =&gt; b ab
</pre>

<p> 繰り返しは、優先順位が高いことに注意して下さい。たとえば、ab* は ab の繰り返しではなく、b の繰り返しです。ab の繰り返しを実現するには ( ) を使って、正規表現をひとつのグループにまとめます。
</p>
<pre class="item">
(ab)+   =&gt; ab abab ababab abababab など
(ab)*c  =&gt; c abc ababc abababc ababababc など
</pre>

<p> 文字クラスと繰り返しを組み合わせることで、いろいろな文字列を表現することができます。
</p>
<pre class="item">
[a-zA-Z]+   ; 英文字列と一致
a[a-zA-Z]*  ; a で始まる英文字列と一致 (a １文字とも一致)
a[a-zA-Z]+  ; a で始まる英文字列と一致 (a １文字には一致しない)
[0-9]+      ; 数字列と一致
</pre>

<p> <b>$</b> と <b>^</b> は位置を指定するメタコードです。^ は行頭を指定し $ は行末を指定します。^ は文字クラス内とは別の意味になりますので注意が必要です。また、コードの意味と矛盾する位置にある場合は、通常の文字として扱われます。
</p>
<pre class="item">
^abcd       ; 行頭の abcd と一致する
^[a-z]+     ; 行頭にある英文字列と一致する
abcd$       ; 行末にある abcd と一致する
[a-z]+$     ; 行末にある英文字列と一致する
abc^        ; abc^ と一致（^ は先頭にないから）
$abc        ; $abc と一致（$ は最後尾にないから）
</pre>

<p> <b>|</b> は選択を表すメタ文字で、前後どちらかの正規表現と一致します。
</p>
<pre class="item">
ab|cd        =&gt; ab cd
(a|b)c       =&gt; ac bc
(ab|cd)e     =&gt; abe cde
</pre>

<p> 選択は優先順位が低いことに注意して下さい。ab|cd は (ab)|(cd) であり、a(b|c)d ではないのです。
</p>
<h4>●Perl の正規表現</h4>
<p> 次は、Perl 独自の正規表現について説明します。Perl の場合、エスケープ記号 \ でメタ文字を打ち消しますが、ある英数字に \ をつけると、Perl はそれをメタ文字として認識します。たとえば、\t と \n がタブと改行を表すのは当然ですが、それ以外に次のようなものがあります。
</p>
<pre class="item">
\w    英数字とアンダースコア _ に一致 ([_a-zA-Z0-9] と同じ)
\W    \w 以外と一致
\s    空白文字と一致 ([ \t\n\r\f] と同じ)
\S    \s 以外と一致
\d    数字と一致 ([0-9] と同じ)
\D    \d 以外と一致
\b    単語境界と一致 (\w と \W の間の空文字列と一致)
\B    \B 以外と一致
</pre>

<p> このほかに、8 進数や 16 進数で文字を表すこともできます。
</p>
<pre class="item">
\nnn  8 進数で表現 (n : 0 - 7)
\xnn  16 進数で表現 (n : 0 - 9, a - f)
</pre>

<p> この表現方法は文字列中にも使うことができます。これにより、ASCII コードで表示できない文字を、正規表現や文字列中に含めることができます。
</p>
<p> 次は繰り返しです。Perl では {n,m} を使って繰り返しの回数を指定することができます。
</p>
<pre class="item">
{n,m}     直前の正規表現の n 回以上 m 回以下の繰り返し
{n,}      直前の正規表現の n 回以上の繰り返し
{n}       直前の正規表現のちょうど n 回の繰り返し
{0,}      * と同じ
{1,}      + と同じ
{0,1}     ? と同じ
</pre>

<p> さて、ここまで説明した機能は確かに便利ですが、なくてもどうにかなるかな、といった程度です。実は Perl には「後方参照」という必殺技があるのですが、説明ばかりではたいくですね。それでは、実際に正規表現を使ってみましょう。
</p>
<h4>●文字列の検索</h4>
<p> Perl では、いろいろなところで正規表現を使うことができますが、いちばんよく使われるのが m 演算子です。
</p>
<pre class="item">
 /pattern/
m/pattern/
</pre>

<p> / で区切られた pattern に正規表現を指定します。区切り文字 (デリミタ) として / を使う場合は、先頭の m を省略することができます。m を指定すると、その直後の文字がデリミタとなります。たとえば、# を使いたい場合は、次のようになります。
</p>
<pre class="item">
m#pattern#
</pre>

<P> / を含むパターン (Unix 系 OS でのパスなど) を検索する場合、この機能が役に立ちます。
</p>
<p>  m 演算子は、スカラーコンテキストでは真 (1) か偽 ("") を返します。文字列の指定がない場合、$_ が検索対象となります。文字列を指定する場合は =~ か !~ を使います。
</p>
<pre class="item">
/abcd/         # $_ と abcd のマッチング
$s =~ /abcd/   # $s と abcd のマッチング
</pre>

<p> !~ を使うと、結果が反転されます。つまり、正規表現と一致しなかった場合に真を返すことになります。
</p>
<p> たとえば、ファイルの中から 3 桁以上の数字を探す場合は、次のようにプログラムできます。
</p>
<pre class="list">
リスト : 3 桁以上の数字を探す

use strict;
use warnings;

while (&lt;&gt;) {
    if( /\d{3,}/ ){
	print "$.: $_";
    }
}
</pre>

<p> 行入力演算子 &lt;&gt; は while の条件部で使用されると、特殊変数 $_ にデータをセットすることを思い出してください。まず $_ と /\d{3,}/ を照合します。一致すれば真を返すので、print で $_を表示すればいいわけです。とても簡単ですね。
</p>
<p> pattern に変数を書くと、" で囲まれた文字列と同じく変数展開が行われます。したがって、/$foo/ とすると、$foo にセットされている文字列を正規表現として認識します。
</p>
<pre class="item">
$foo = '\w+';
/$foo/;         # /\w+/ と同じこと
</pre>

<p> この機能を使うと、指定した文字列をファイルから検索する grep のようなプログラムは、簡単に作ることができます。
</p>
<pre class="list">
リスト : grep.pl

use strict;
use warnings;

my $pattern = shift;
my $filename = shift;
open my $in, $filename or die "Can't open file: $filename\n";
while (&lt;$in&gt;) {
    if (/$pattern/o) {
	print "$.: $_";
    }
}
close $in;
</pre>

<p> このプログラムは次のように起動します。
</p>
<pre>
$ perl grep.pl pattern file
</pre>

<p> まず、特殊変数 @ARGV から正規表現 pattern とファイル名 file を取り出して、変数 $pattern と $filename にセットします。shift は引数が省略されると、@ARGV が操作対象になることを思い出してください。あとは、ファイルをオープンして正規表現 $pattern と照合すればいいわけです。
</p>
<p> ここで、/$pattern/o の o に注目してください。Perl は正規表現をあるデータ構造 <sup><a href="perl03.html#note1">[*1]</a></sup> に変換 (コンパイル) してから文字列と照合します。m 演算子に変数が使われている場合、その値が変化しているかもしれないので、Perl は文字列と照合する前に正規表現を再コンパイルします。今回のプログラムでは、$pattern の値は変化しませんね。この場合、m 演算子に o を指定 <sup><a href="perl03.html#note2">[*2]</a></sup> することで、正規表現のコンパイルを 1 回だけに抑制することができます。
</p>
<p> 照合に成功すると、次に示す特殊変数に結果がセットされます。
<pre class="item">
$&amp;   正規表現と一致した文字列
$`   一致した文字列の前の文字列
$'   一致した文字列の後の文字列
</pre>

<p> たとえば、/\d+/ と "abcd1234ABCD" を照合させると、各変数の値は次のようになります。
</p>
<pre class="item">
$&amp;  =&gt;  1234
$`  =&gt;  abcd
$'  =&gt;  ABCD
</pre>

<p> 照合に失敗した場合、これらの変数には値がセットされません。失敗したからといって、$&amp; は空文字列にはならないのです。直前に成功したときの値がそのまま残っているので、注意してください。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> Perl は正規表現を「非決定性オートマトン (NFA) 」というデータ構造に変換し、それを使って照合を行います。
<br>
<a name="note2">[*2]</a> 英大小文字を区別しないで検索する場合は i を指定します。
</div>

<h4>●クロスリファレンスの作成</h4>
<p> それでは簡単な例題として、クロスリファレンスを作成するプログラムを作ってみましょう。クロスリファレンスとは、プログラムで使用された変数名と、それが現れる行番号をすべて書き出した一覧表のことです。今回作成するプログラムは変数名ではなく、正規表現と一致する文字列をキーワードとし、それが現れる行番号を出力することにします。 
</p>

<p> 処理内容を流れ図で表すと、次のようになります。
</p>
<pre class="fig">
                  ├←───────┐
                  ↓                │
       EOF ┌──────┐         │
 終了←──│１行読み込む│         │
           └──────┘         │
                  │                │
  ┌──────→┤                │
  │              ↓                │
  │    ┌──────────┐無  │
  │    │キーワードを取り出す│──┘
  │    └──────────┘
  │              ↓有
  │    ┌──────────┐No
  │    │新しいキーワードか？│──┐
  │    └──────────┘    │
  │              ↓Yes             │
  │    ┌──────────┐    │
  │    │キーワードを記憶する│    │
  │    └──────────┘    │
  │              │                │
  │              ├←───────┘
  │              ↓
  │     ┌────────┐
  │     │行番号を格納する│
  │     └────────┘
  └───────┘

  図 : クロスリファレンスの処理の流れ
</pre>

<p> キーワードは文字コード順に整列して出力した方が見やすいので、今まで出てきたキーワードと行番号を覚えておいて、ファイルを読み終わってから結果をまとめで出力することにします。したがって、キーワードを取り出して行番号を追加する場合、記憶してあるキーワードがあれば、そこに行番号を追加し、新しいキーワードであれば、それを記憶する必要があります。
</p>
<p> このプログラムは、キーワードの検索処理によって実行時間が大きく左右されます。コンピュータの世界では、昔からデータを高速に検索するアルゴリズムが研究されています。基本的なところでは「二分探索」や「ハッシュ法」があります。これらのアルゴリズムは、拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a>, <a href="../light/pyalgo03.html">二分木とヒープ</a>, <a href="../light/pyalgo04.html">ハッシュ法</a> で詳しく説明していますので、興味のある方は読んでみてください。Perl の場合、連想配列を使うことで、キーワードを高速に検索することができます。
</p>
<p> ところで、連想配列はスカラーしか格納できないので <sup><a href="perl03.html#note3">[*3]</a></sup>、複数の行番号を格納することができません。そこで、行番号は文字列として格納し、新しい行番号は後ろに連結していくことにします。 キーワードと行番号は、連想配列 %word_table に格納することにします。結果を出力するときは、そこからデータを取り出す処理が必要になります。
</p>

<div class="note">
-- Note --------<br>
<a name="note3">[*3]</a> まだ説明していませんが、スカラーだけではなく「リファレンス (reference) 」も格納することができます。クロスリファレンスのプログラムは、リファレンスを説明するときに改良する予定です。
</div>

<h4>●連想配列の操作関数</h4>
<p> Perl には、連想配列からデータを順番に取り出す関数が用意されています。
</p>
<pre class="item">
keys   %table  : %table に登録されているキーをリストにして返す。
values %table  : %table に登録されている値をリストにして返す。
each   %table  : %table に登録されているキーと値を取り出して、
                 2 要素のリスト値にして返す。
</pre>

<p> 簡単な使用例を示しましょう。Perl には、環境変数を保持する連想配列 %ENV が定義されています。たとえば、環境変数 path の値を表示する場合は、次のようにプログラムすればいいでしょう。
</p>
<pre class="list">
print $ENV{'path'};
</pre>
<p> keys を使えば、設定されている環境変数を表示することができます。
</p>
<pre class="list">
foreach my $key (keys(%ENV)) {
    print "$key\n";
}
</pre>

<p> 値も表示したい場合は、each を使いましょう。
</p>
<pre class="list">
while (my ($key, $value) = each(%ENV)) {
    print "$key=$value\n";
}
</pre>

<p> これで、環境変数とその値をすべて表示することができます。keys や each  は、連想配列に登録された順番でデータを取り出すわけではありません。取り出される順番は、連想配列のアルゴリズム (ハッシュ法) によって左右されます。したがって、データを文字コード順に表示したい場合は、データを「ソート (sort) 」しないといけません。
</p>
<p> ソートとは、ある規則に従ってデータを順番に並べることです。たとえば、データが数値であれば、小さい順かもしくは大きい順に並べることになります。Perl では文字列をソートする場合、関数 sort を使います。
</p>
<pre class="item">
sort LIST
</pre>

<p> sort は、LIST に格納されている文字列を文字コード順に並べ、その結果をリストにまとめて返します。この場合、英大小文字は区別されます。英大小文字を区別せずにソートするとか、数値データをソートすることもできますが、データを比較する関数を sort に渡さないといけません。これは、関数を取り上げるときに詳しく説明します。
</p>

<h4>●行番号の表示</h4>
<p> 今度は行番号を表示する処理を考えてみます。行番号は文字列として格納されています。これをそのまま表示するよりも、桁をそろえて表示した方が見やすいですね。今回は 1 行につき 8 個ずつ行番号を書き出すことにします。
</p>
<p> 文字列から行番号を切り出す処理ですが、Perl には split という便利な関数が用意されています。
</p>
<pre class="item">
split /pattern/, 文字列
</pre>

<p> split は正規表現 pattern と一致する文字をデリミタとして、文字列を分割してリストにまとめて返します。スカラーコンテキストで split を評価すると分割数を返します。文字列の指定を省略すると、特殊変数 $_ に格納されたデータが対象となります。引数を省略すると、空白文字 (\s) をデリミタとして、$_ に格納されている文字列を分割します。次の例を見てください。
</pre>
<pre class="item">
@a = split /,/, "abcd,efgh,ijkl,mnop"; =&gt; ("abcd", "efgh", "ijkl", "mnop")

$_ = "123 456 789";
@b = split; =&gt; ("123", "456", "789")
</pre>

<p> 最初の例では、カンマ ( <b>,</b> ) をデリミタとして文字列を分割して、配列 @a に代入しています。次の例では、$_ に文字列をセットして、split を引数なしで呼び出しています。配列 @b には、空白文字をデリミタとして分割された文字列がセットされます。
</p>
<p> split とは逆の働きをする関数が join です。
</p>
<pre class="item">
join セパレータ, LIST
</pre>

<p> join は LIST に格納されている文字列を連結します。このとき、セパレータで指定した文字を間に挿入します。join を使えば split で分割した文字列を結合することができます。
</p>
<pre class="item">
@a = ("abcd", "efgh", "ijkl", "mnop");
join ',', @a; =&gt; "abcd,efgh,ijkl,mnop"
join '', @a;  =&gt; "abcdefghijklmnop"
</pre>

<p> 最初の例は、カンマ , で文字列をつないでいます。空文字列をセパレータとして join を実行すると、文字列を連結したことになります。join を使わずに連結しようとすると、次のようにプログラムしなければいけません。
</p>
<pre class="list">
リスト : @a に格納されている文字列を連結

my $result = '';
foreach my $str (@a) {
    $result .= $str;
}
</pre>

<p> join だけで文字列を連結できるのですから、とても便利ですね。
</p>
<p> 次は、行番号の桁をそろえる処理ですが、今回は関数 printf を使うことにします。これはＣ言語の関数 printf とほぼ同じ機能を持っています。
</p>
<pre class="item">
printf 書式文字列, データ, ...
</pre>

<p> printf は、基本的には書式文字列を STDOUT へ出力するのですが、その中にデータの出力形式を指定することができます。整数値を出力する書式は %d です。% から書式指定が始まり、d が整数値を出力することを表します。そして、% とd の間に出力する桁数 (フィールド幅) などを指定することができます。
</p>
<p> 簡単な使用例を示しましょう。[ ] の中に数値を出力する場合を考えてみます。
</p>
<PRE class="item">
(1) printf "[%d]\n", 10;      # [10]
(2) printf "[%4d]\n", 10;     # [  10]
(3) printf "[%4d]\n", 10000;  # [10000]
</pre>

<p> (1) がフィールド幅を指定しない例で、(2) は 4 に指定した例です。10 ではフィールド幅に満たないので、左詰めに出力されていますね。もし、フィールド幅に収まらない場合は、(3) のように指定を無視して数値を出力します。
</p>
<pre class="item">
(4) printf "[%04d]\n", 10;    # [0010]
(5) printf "[%-4d]\n", 10;    # [10  ]
</pre>

<p> フィールド幅の前に 0 を付けると、左側の空いたフィールドに 0 を詰め込みます。(4) のように、10 の場合は [0010] と出力されます。- を指定すると右詰めに出力されます。(5) のように、10 の場合は [10&nbsp;&nbsp;] となります。
</p>
<p> このほかにも、printf は文字列や浮動小数点数の指定も可能です。高機能なのですが、それだけ指定方法が複雑です。実をいうと、Perl には BASIC の PRINT USING 文と同様の書式が使える format という機能があります。こちらの方が直感的でわかりやすいのですが、ページ単位でレイアウトを決めるものなので、今回は printf を使いました。たいていの場合は format で処理できるので、複雑な printf の書式を無理に覚えることはありません。format は別の機会で詳しく説明することにします。
</p>
<h4>●プログラムの作成</h4>
<p> それでは、プログラムを作りましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : クロスリファレンスの作成 (cref.pl)

use strict;
use warnings;

my $pattern = shift;
my $filename = shift;
my %word_table = ();
open my $in, $filename or die "Can't open file: $filename\n";

# 探索処理
while (&lt;$in&gt;) {
    while (/$pattern/o) {
        if($word_table{$&amp;}){
            $word_table{$&amp;} .= " $.";   # 文字列として連結する
        } else {
            $word_table{$&amp;} = "$.";
        }
        $_ = $';                        # 残りの文字列をセットする
    }
}
close $in;

# 表示処理
foreach my $word (sort(keys(%word_table))) {
    print "$word\n";
    my $count = 0;
    foreach my $num (split(/ /, $word_table{$word})) {
        printf("%8d", $num);
        if (++$count &gt;= 8) {
            print "\n";
            $count = 0;
        }
    }
    print "\n";
}
</pre>

<p> 少し長いですが、前半部分が探索処理で、後半部分が表示処理です。まず、探索処理から見ていきましょう。まず、連想配列 %word_table に空リスト ( ) を代入しています。これで、連想配列の中身を空にすることができます。実は、%word_table は Perl によって空に初期化されるので、この処理はなくても動作します。
</p>

<p> 2 番目の while 文で、正規表現 $pattern との照合を行います。一致する部分文字列を見つけたら、次の if 文で連想配列に行番号が登録されているかチェックします。$&amp; にはキーワードがセットされているので、$word_table{$&amp;} で文字列が出現した行番号を取り出すことができます。
</p>
<p> Perl の場合、まだデータがセットされていない変数にアクセスすると、空文字列または 0 をセットしてから使用されます。したがって $word_table{$&amp;} が真であれば、既に行番号がセットされていることがわかります。この場合、文字列連結演算子 . を使って、後ろに行番号をつなげます。このとき、先頭に空白を付けることをお忘れなく。
</p>
<p> $word_table{$&amp;} が偽の場合、そこに行番号をセットします。行番号は特殊変数 $. で求めることができました。$. を文字列に変換してからセットしていますが、そのままセットしても正常に動作します。探索処理の最後で、残りの文字列 $' を $_ にセットして、正規表現との照合を繰り返します。見つからない場合、m 演算子は偽を返すので while ループが終了し、先頭の while 文に戻ってファイルから新しいデータが読み込まれます。
</p>

<p> 次は、表示処理を見ていきます。最初の foreach は少々複雑ですが、やっていることは簡単です。まず keys で連想配列 %work_table に格納されたキーワードを求め、sort で文字コード順に並べ、それを foreach でひとつずつ取り出します。変数 $word には、取り出されたキーワードがセットされます。
</p>
<p> 次に $word を表示してから、$word_table{$word} でデータを取り出し、split で行番号に分割します。それを foreach でひとつずつ取り出して書き出します。変数 $count は、書き出した行番号を数えるカウンタとして使います。
</p>
<P>  行番号を 8 個出力したら改行します。ここで、インクリメント演算子 ++ の位置に注目してください。
</p>
<pre class="list">
        if (++$count &gt;= 8) {
</pre>

<p> インクリメント演算子 ++ が $count の前に付いていますね。これを後ろに付けると 1 行に 9 個の行番号を出力してしまいます。インクリメント演算子は前に付けると、$count を +1 してから変数の値が取り出されます。ところが後ろに付けると、$count の値を取り出してから +1 するのです。これはデクリメント演算子でも同じです。次の例を見てください。
</p>
<pre class="item">
$a = 10;
$b = ++$a;   # $b =&gt; 11, $a =&gt; 11
$c = $a++;   # $c =&gt; 10, $a =&gt; 11
</pre>

<p> ++$a は 10 + 1 を実行してから、その値が $b に代入されるので 11  になります。$a++ では、$a の値 10 が $c に代入されてから $a の値を +1 するので、$c は 10 のままですが、$a は 11 になるのです。前後の位置関係で結果は大きく変わるので注意してください。
</p>
<p> 改行を出力したら変数 $count を 0 に戻すことを忘れないでください。これでプログラムは完成です。
</p>
<h4>●簡単な実行例</h4>
<p> それでは実際に動かしてみましょう。下図に示すファイル test.txt で、\w+ をキーワードにしたクロスリファレンスを作成します。
</p>
<pre class="fig">
  abc def ghi jkl
  def ghi jkl mno
  ghi jkl mno pqr
  jkl mno pqr stu
  mno pqr stu vwx

図 : test.txt の内容
</pre>
<p> 実行結果は次のようになりました。
<p>
<pre>
mhiroi@mhiroi-VirtualBox:~/perl$ perl cref.pl '\w+' test.txt
abc
       1
def
       1       2
ghi
       1       2       3
jkl
       1       2       3       4
mno
       2       3       4       5
pqr
       3       4       5
stu
       4       5
vwx
       5
</pre>
<p> 正規表現で表せるパターンであれば、そのクロスリファレンスを cref.pl で作成することができます。このように、正規表現を使うと文字列を処理するプログラムを簡単に作ることができます。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="perl02.html">PrevPage</a> | <a href="perl.html">Perl</a> | <a href="perl04.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>