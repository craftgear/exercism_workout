<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881810</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang23.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang25.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>数独の解法</h3>
<p> 今回は皆さんお馴染みのパズル「数独 (ナンバープレース) 」の解法プログラムを作ってみましょう。
</p>

<h4>●数独とは？</h4>
<p> 数独は 9×9 の盤を用いて、縦 9 列、横 9 行のそれぞれに 1 から 9 までの数字をひとつずつ入れます。また、太線で囲まれた 3×3 の枠内にも 1 から 9 までの数字をひとつずつ入れます。ただし、縦、横、枠の中で、同じ数字が重複して入ることはありません。
</p>
<p> パズルの解き方 <sup><a href="clang24.html#note1">[*1]</a></sup> ですが、基本的には次の条件を満たすマスを探して数字を確定していきます。
</p>
<ol>
 <li>置くことができる数字がただひとつしかない場合
 <li> 縦、横、枠の中で、数字を置くことができるマスがひとつしかない場合
</ol>
<p> (1) は簡単ですね。(2) は次の例をみてください。
</p>
<pre class="item">
      置くことができる数字
--------------------------
  ８
  Ａ  [4,5,7,9]
  Ｂ  [4,5,7]
  ６
  ２
  Ｃ  [3,5,7]
  １
  Ｄ  [4,5,9]
  Ｅ  [4,9]
</pre>
<p> これは縦 1 列を抜き出したものです。マス C に注目してください。C には 3, 5, 7 を置くことができるので、条件 (1) で確定することはできません。ここで縦全体を見てください。この中で、数字 3 を置くことができるのは、このマスしかありませんね。したがって、C は 3 に確定することができるのです。同じように、横の関係、枠の関係で数字を確定することができます。
</p>
<p> 条件を満たすマスを探して数字を確定していくと、そのことで新たに (1) か (2) を満たすマスが出てくるので、それを探して数字を確定します。これを繰り返すことで、数独を解くことができます。本稿ではこれを「確定サーチ」と呼ぶことにします。数独の多くは、この確定サーチで解くことができるのですが、実はこれでは解けない難しい問題があるのです。
</p>
<p> このような難しい問題をどうやって解くのか、M.Hiroi には見当もつきませんが、コンピュータを使えば「試行錯誤」という力技で解を見つけることができます。つまり、適当な数字を選んでマスを埋めていき、矛盾するようであれば元に戻って違う数字を選び直せばいいわけです。最近のパソコンはハイスペックなので、9 行 9 列盤の数独であれば単純なバックトラックで簡単に解くことができます。
</p>
<div class="note">
-- Note --------<br>
<a name="note1">[*1]</a> 今回説明した数独の解き方は基本的なもので、<a href="http://puzzle.gr.jp/show/Japanese">Puzzle Generater Japan</a> の <a href="http://puzzle.gr.jp/show/Japanese/NPStrategies">ナンプレ手筋集</a> には基本的なものから上級者向けのものまで、数独を解くためのいろいろなテクニックが紹介されています。
</div>
<h4>●盤面の定義</h4>
<p> 最初に盤面を定義します。次の図を見てください。
</p>
<pre class="fig">
  列 0 1 2   3 4 5   6 7 8
行 +-------+-------+-------+    board[x][y]
 0 |       |       |       |    x : 行 (横)
 1 | 枠 0  |   1   |   2   |    y : 列 (縦)
 2 |       |       |       |
   +-------+-------+-------+
 3 |       |       |       |
 4 |   3   |   4   |   5   |
 5 |       |       |       |
   +-------+-------+-------+
 6 |       |       |       |
 7 |   6   |   7   |   8   |
 8 |       |       |       |
   +-------+-------+-------+

   図 : 数独 (9 * 9) の盤面
</pre>
<p> 盤面を 2 次元配列 board で表します。要素は 0 から 9 までの数字です。0 が空き場所を表します。board[x][y] の x が行 (横) を、y が列 (縦) を表します。枠の左上の位置 (x1, y1) は、次の式で求めることができます。
</p>
<pre class="item">
x1 = (x / 3) * 3, y1 = (y / 3) * 3
</pre>
<p> 整数の割り算なので、0, 1, 2 は 0 に、3 ,4, 5 は 1 に、6, 7, 8 は 2 になります。それに 3 を掛け算すれば、枠の左上の位置を求めることができます。
</p>
<p> また、枠の番号 g は次の式で求めることができます。
<pre class="item">
g = (x / 3) * 3 + y / 3
</pre>
<p> y = 0 の場合、x の値で 0, 3, 6 になればいいので、(x / 3) * 3 で求めることができます。x = 0 の場合、y / 3 で 0, 1, 2 になります。あとは、これを足し算すればいいわけです。
</p>
<h4>●縦横枠のチェック</h4>
<p> 縦、横、枠で同じ数字がないかチェックするプログラムは次のようになります。
</p>
<pre class="list">
リスト : 縦、横、枠のチェック

#define N 9

// 盤面
int board[N][N];

// 横のチェック
bool check_line(int n, int x)
{
  for (int i = 0; i &lt; N; i++) {
    if (board[x][i] == n) return false;
  }
  return true;
}

// 縦のチェック
bool check_column(int n, int y)
{
  for (int i = 0; i &lt; N; i++) {
    if (board[i][y] == n) return false;
  }
  return true;
}

// 枠のチェック
bool check_group(int n, int x, int y)
{
  int x1 = (x / 3) * 3; 
  int y1 = (y / 3) * 3; 
  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      if (board[x1 + i][y1 + j] == n) return false;
    }
  }
  return true;
}

// 数字をおけるかチェックする
bool check(int n, int x, int y)
{
  return check_column(n, y) &amp;&amp; check_line(n, x) &amp;&amp; check_group(n, x, y);
}
</pre>
<p> 関数 check_line は x 行目に引数 n と同じ数字があるかチェックします。関数 check_column は y 列目に引数 n と同じ数字があるかチェックします。関数 check_group は位置 (x, y) が属する枠の中で、引数 n と同じ数字があるかチェックします。関数 check は、これら 3 つの関数を呼び出して、位置 (x, y) に数字 n を置くことができれば true を返します。
</p>
<h4>●単純なバックトラックによる解法</h4>
<p> 最後に、深さ優先探索で解を求める関数 solver を作ります。
</p>
<pre class="list">
リスト : 数独の解法 (1)

void solver(int n)
{
  if (n == N * N) 
    print_board();
  else {
    int x = n / N;
    int y = n % N;
    if (board[x][y] != 0)
      solver(n + 1);
    else {
      for (int i = 1; i &lt;= N; i++) {
        if (check(i, x, y)) {
          board[x][y] = i;
          solver(n + 1);
          board[x][y] = 0;
        }
      }
    }
  }
}
</pre>
<p> 引数 n が N * N と等しい場合、すべてのマスに数字を置くことができました。関数 print_board で解を表示します。そうでなければ、引数 n を位置 (x, y) に変換します。board[x][y] が空き場所でなければ、solver を再帰呼び出しして次のマスをチェックします。
</p>
<p> 空き場所の場合、1 から 9 までの数字を関数 check に渡して、その数字を位置 (x, y) に置くことができるかチェックします。返り値が true の場合、board[x][y] に数字 i をセットして、solver を再帰呼び出しします。戻ってきたら board[x][y] を空き場所 (0) に戻すことをお忘れなく。
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は<a href="clang24.html#list1">プログラムリスト１</a> をお読みください。
</p>
<h4>●実行結果 (1)</h4>
<P> それでは、実際に数独を解いてみましょう。<A href="http://puzzle.gr.jp/show/Japanese">Puzzle Generater Japan</A> にある <A href="http://puzzle.gr.jp/show/Japanese/NPProblems/Java">Java版標準問題集</A> より問題 8-a, 8-b, 9-a, 9-b, 10-a, 10-b と <a href="http://puzzle.gr.jp/show/Japanese/NPProblems/JavaFiendish">Java版超難問集</a> の超難問 849 と 1122 を試してみたところ、実行時間は次のようになりました。
<pre>
  表 : 実行結果 (単位 : 秒)

  問題 : Hint : 時間
 ------+------+------
   8-a :  20  : 0.023
   8-b :  20  : 0.030
   9-a :  20  : 0.031
   9-b :  21  : 0.011
  10-a :  22  : 0.002
  10-b :  22  : 0.006
   849 :  24  : 0.044
  1122 :  24  : 0.025
-------+------+------
  合計 :      : 0.173

実行環境 : Lubuntu 14.10 on VirtualBox, Core i7-2670QM 2.20GHz
</pre>
<p> どの問題も 0.1 秒未満で解くことができました。このように、9 行 9 列盤の数独は単純なバックトラックで簡単に解くことができます。このままでも十分に速いのですが、高速化する余地はまだ残っています。今回の処理で時間がかかっているのは、数字を選択する処理です。空き場所に置くことができる数字を簡単に求めることができれば、もっと速くなると思われます。
</p>
<h4>●データ構造を工夫する</h4>
<p> そこで、空き場所に置くことができる数字をデータとして持たせることにします。置くことができる数字は、各マスごとに持たせるのが自然な考え方です。必要なときに数字を直に求めることができますし、マスに数字を置いたならば、そのマスが属している縦、横、枠のマスに対して数字を削除すればいいわけです。
</p>
<p> この方法では、縦と横で 16 個、枠で 4 個、合計で 20 個のマスを書き換えることになります。最近のパソコンはハイスペックなので、この程度であれば高速に動作すると思いますが、もっとクールな方法が <a href="clang24.html#cite">参考文献 [1]</a> に書かれています。それは、「縦、横、枠のそれぞれについて、置くことができる数字をビットで管理する」という方法です。今回はこの方法を採用することにします。
</p>
<p> ビットと数字の関係は次のように定義しましょう。
</p>
<pre class="fig">
bit 9 8 7 6 5 4 3 2 1 0  =&gt; 数字に対応させる
   ---------------------
    1 1 1 1 1 1 1 1 1 0  =&gt; 0x3fe : すべての数字を置くことができる
</pre>
<p> 第 0 ビットはダミーとします。置くことができる数字は対応するビットをセットし、そうでなければビットをクリアします。
</p>
<p> 縦、横、枠の状態は、配列 yflag, xflag, gflag で管理することにしましょう。次の図を見てください。
</p>
<pre class="fig">
                      9876543210
                      ----------
          yflag[0] =&gt; 0110111010
              ↓
            ┏━┯━┯━┳━┯━┯━┳━┯━┯━┓
 xflag[0] →┃◎│３│  ┃９│１│７┃  │  │８┃
            ┠─┼─┼─╂─┼─┼─╂─┼─┼─┨
  9876543210┃  │８│２┃  │  │６┃  │３│  ┃
  ----------┠─┼─┼─╂─┼─┼─╂─┼─┼─┨
  0001110100┃９│  │  ┃  │２│  ┃  │  │  ┃
            ┣━┿━┿━╋━┿━┿━╋━┿━┿━┫
            ┃  │  │７┃
            ┠─┼─┼─╂              9876543210
            ┃  │  │９┃              ----------
            ┠─┼─┼─╂  gflag[0] =&gt; 0011110010
            ┃  │２│  ┃
            ┣━┿━┿━╋
            ┃６│９│  ┃
            ┠─┼─┼─╂
            ┃２│  │８┃
            ┠─┼─┼─╂
            ┃  │  │５┃
            ┗━┷━┷━┻
</pre>
<p> 左上隅のマス◎に注目してください。縦で使われている数字は 2, 6, 9 なので、yflag[0] の値は 2 進数で表すと 0110111010 になります。横は 1, 3, 7, 8, 9 が使われているので、xflag[0] の値は 0001110100 となります。枠 gflag[0] の値は、2, 3, 8, 9 が使われているので 0011110010 となります。
</p>
<p> マス◎に置くことができる数字は、この 3 つの状態でビットが立っている数字、つまり、ビットの論理積で求めることができます。
</p>
<pre class="fig">
            9876543210
            ----------
xflag[0] =&gt; 0110111010
yflag[0] =&gt; 0001110100
gflag[0] =&gt; 0011110010
        AND ----------
            0000110000
</pre>
<p> マス◎に置くことができる数字は 4, 5 であることがわかります。
</p>
<p> このように、縦、横、枠に分けて数字を管理するため、マスに置くことができる数字は、いちいち AND 演算しなければ求めることができません。ところが、マスに数字を置くときは縦、横、枠の該当するビットをクリアするだけで済ますことができます。
</p>
<h4>●盤面とフラグの定義</h4>
<p> それではプログラムを作りましょう。最初にデータ構造を定義します。次のリストを見てください。
<PRE class="list">
リスト : データ構造の定義

// 盤面
int board[N][N];

// フラグ
int xflag[N], yflag[N], gflag[N];
</pre>
<p> 盤面 board の数字はビットの位置で表すことにします。空き場所は今までと同じく 0 で表します。配列 xflag, yflag, gflag は行、列、枠のフラグを格納します。フラグの初期化は関数 init_board で行います。
</p>

<h4>●フラグの操作</h4>
<p> 次はフラグを書き換える関数を作りましょう。
<pre class="list">
リスト : フラグの操作

// グループ番号を求める
int get_group(int x, int y)
{
  return (x / 3) * 3 + y / 3;
}

// 数字を置く
void set_number(int n, int x, int y)
{
  board[x][y] = n;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}

// 数字を削除する
void del_number(int n, int x, int y)
{
  board[x][y] = 0;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}
</pre>
<p> 関数 get_group は位置 (x, y) が属する枠の番号を求めます。関数 set_number は数字 n を board[x][y] にセットし、xflag, yflag, gflag のビットをクリアします。関数 del_number は board[x][y] を空き場所に戻し、xflag, yflag, gflag のビットをオンにします。どちらの関数も排他的論理和 (xor) を使ってビットのオンオフを行っています。
</p>

<p> 次はフラグを初期化する関数 init_board を作ります。
</p>
<pre class="list">
リスト : 盤面の初期化

void init_board(int q[][N])
{
  for (int i = 0; i &lt; N; i++)
    xflag[i] = yflag[i] = gflag[i] = 0x3fe;
  for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
      int n = q[i][j];
      if (n == 0)
        board[i][j] = n;
      else
        set_number(1 &lt;&lt; n, i, j);
    }
  }
}
</pre>
<p> xflag, yflag, zflag はすべての数字のビットを 1 にセットした値 (0x3fe) に初期化します。次に、二重の for ループで引数 q のデータを取り出し、外部変数 board にセットします。n が 0 ならば、そのまま board にセットします。そうでなければ、1 を n ビット左へシフトして、それを set_number に渡して board とフラグの値を更新します。
</p>

<p> 次は空き場所に置くことができる数字を求める関数 get_numbers を作ります。
</p>
<pre class="list">
リスト : 置くことができる数字を求める

int get_numbers(int x, int y)
{
  return xflag[x] &amp; yflag[y] &amp; gflag[get_group(x, y)];
}
</pre>
<p> get_numbers は簡単で、xflag, yflag, gflag の論理積を求めるだけです。
</p>
<h4>●バックトラックによる解法</h4>
<p> 最後にバックトラックで解を求める関数 solver を作ります。
</p>
<pre class="list">
リスト : 数独の解法 (2)

void solver(int n)
{
  if (n == N * N) 
    print_board();
  else {
    int x = n / N;
    int y = n % N;
    if (board[x][y] != 0)
      solver(n + 1);
    else {
      for (int m = get_numbers(x, y); m &gt; 0; m &amp;= m - 1) {
        int i = m &amp; (-m);
        set_number(i, x, y);
        solver(n + 1);
        del_number(i, x, y);
      }
    }
  }
}
</pre>
<p> get_numbers で置くことができる数字を求め、m &amp (-m) で一番右側のビットを取り出して変数 i にセットします。あとは、set_number で数字 i を書き込み、solver を再帰呼び出しします。戻ってきたら、del_number で空き場所に戻して、m &amp;= m - 1 で一番右側のビットをクリアします。 
</p>
<p> あとのプログラムは簡単なので説明は割愛します。詳細は <a href="clang24.html#list2">プログラムリスト２</a> をお読みください。
</p>
<h4>●実行結果 (2)</h4>
<p> 実行時間は次のようになりました。
<pre>
  表 : 実行結果 (単位 : 秒)

  問題 : Hint :  (1)  :  (2)
 ------+------+-------+-------
   8-a :  20  : 0.023 : 0.007
   8-b :  20  : 0.030 : 0.011
   9-a :  20  : 0.031 : 0.008
   9-b :  21  : 0.011 : 0.003
  10-a :  22  : 0.002 : 0.001
  10-b :  22  : 0.006 : 0.001
   849 :  24  : 0.044 : 0.010
  1122 :  24  : 0.025 : 0.005
-------+------+-------+-------
  合計 :      : 0.173 : 0.046

実行環境 : Lubuntu 14.10 on VirtualBox, Core i7-2670QM 2.20GHz
</pre>

<p> 実行時間はどの問題でも速くなりました。全体では約 3.8 倍速くなっているので、ビット操作の効果は十分に出ていると思います。
</p>
<h4>●確定サーチ</h4>
<p> 数独 (9 行 9 列盤) を解くだけならば、これ以上の高速化は必要ないのですが、ついでに「確定サーチ」も試してみることにしましょう。関数 init_board でヒント数字を解析したら、空き場所に対して確定サーチを行います。確定サーチで注意する点は、確定できなかったマスでも、ほかのマスで数字が決定することで、確定できる場合があることです。したがって、一度だけ調べるのではなく、数字が確定したマスがある限り、何度でも調べなければいけません。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 確定サーチ + バックトラック

bool decide_number(void)
{
  while (true) {
    int c = decide_cell();
    c += decide_line();
    c += decide_column();
    c += decide_group();
    if (c == 0) break;
  }
  return is_finish();
}

void solver1(int q[][N])
{
  init_board(q);
  clock_t s = clock();
  if (decide_number()) {
    printf("finish!\n");
    print_board();
  } else {
    printf("backtack!\n");
    solver(0);
  }
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
}
</pre>

<p> 関数 solver1 は solver を呼び出す前に確定サーチを行う関数 decide_number を呼び出します。decide_number の返り値が true であれば、解が見つかりました。print_board で盤面を表示します。false の場合は solver を呼び出してバックトラックで解を探します。
</p>
<p> decide_number は while ループの中で 4 つの関数を呼び出します。decide_cell は置くことができる数字がひとつしかないマスを探します。decide_column は縦方向の中で置くことができるマスがひとつしかない数字を探します。decide_line が横方向の中で、decide_group が枠の中で数字を決定できるマスを探します。
</p>
<p> これらの関数の返り値は確定したマスの個数です。確定したマスが一つでもあれば、確定サーチを繰り返します。確定したマスがひとつも無い場合は break で while ループを脱出して、関数 is_finish を呼び出します。is_finish は空き場所が一つでもあれば false を返し、空き場所がない (解くことができた) 場合は true を返します。
</p>
<p> 簡単な問題であれば、確定サーチだけで解くことができるでしょう。また、難しい問題でも、確定サーチだけで解ける場合もあります。
</p>
<h4>●置ける数字がひとつしかないマスを探す</h4>
<p> 次は関数 decide_cell を作ります。
</p>
<pre class="list">
リスト : 置ける数字がひとつしかないマスを探す

int decide_cell(void)
{
  int c = 0;
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      if (board[x][y] == 0) {
        int n = get_numbers(x, y);
        if (bit_count(n) == 1) {
          set_number(n, x, y);
          c++;
        }
      }
    }
  }
  return c;
}
</pre>

<p> decide_cell は簡単です。二重の for ループで盤面の要素を取り出し、その値が 0 であれば、get_numbers で置くことができる数字を求めます。そして、bit_count でビット 1 の個数を求め、それが 1 であれば (x, y) に数字 n を置くことができます。set_number で数字を書き込み、変数 c をインクリメントします。最後に return で c を返します。
</p>

<h4>●縦横枠で置くことができる数字を探す</h4>
<p> 縦、横、枠の確定サーチはほとんど同じ処理なので、縦方向で確定できる数字を探す関数 decide_column だけ説明することにします。
</p>
<pre class="list">
リスト : 縦方向の確定サーチ

int decide_column_sub(int y)
{
  int c = 0;
  for (int m = yflag[y]; m &gt; 0; m &amp;= m - 1) {
    int n = m &amp; (-m), c1 = 0, x1;
    for (int x = 0; x &lt; N; x++) {
      if (board[x][y] == 0 &amp;&amp; get_numbers(x, y) &amp; n) {
        if (++c1 &gt; 1) break;
        x1 = x;
      }
    }
    if (c1 == 1) {
      set_number(n, x1, y);
      c++;
    }
  }
  return c;
}
    
int decide_column(void)
{
  int c = 0;
  for (int y = 0; y &lt; N; y++)
    c += decide_column_sub(y);
  return c;
}
</pre>
<p> 実際の処理は関数 dicide_column_sub で行います。yflag[y] から y 列目の未確定の数字を取り出して変数 m にセットします。m &amp; (-m) で一番右側のビット (数字) を取り出して変数 n にセットします。次の for ループで、その数字を置くことができる場所の個数をカウントします。board[x][y] が空き場所 (0) で、get_numbers(x. y) と n の論理積が真であれば、n を位置 (x, y) に置くことができます。
</p>
<p> カウント c1 をインクリメントして、それが 1 より大きくなったら、その数字はまだ決定することができません。break で for ループを脱出して次の数字を調べます。そうでなければ、x の値を変数 x1 にセットします。for ループが終了したら、c1 が 1 かチェックします。そうであれば、set_number で n を (x1, y) に書き込み、変数 c をインクリメントします。最後に return で c を返します。
</p>
<p> あとは特に難しいところはないでしょう。詳細は <a href="clang24.html#list3">プログラムリスト３</a> をお読みください。
</p>

<h4>●実行結果 (3)</h4>
<p> 実行時間は次のようになりました。
</p>
<pre>
        表 : 実行結果 (単位 : 秒)

  問題 : Hint :  (1)  :  (2)  :  (3)
 ------+------+-------+-------+-----------
   8-a :  20  : 0.023 : 0.007 : 0.001
   8-b :  20  : 0.030 : 0.011 : 0.000 (確)
   9-a :  20  : 0.031 : 0.008 : 0.001
   9-b :  21  : 0.011 : 0.003 : 0.000 (確)
  10-a :  22  : 0.002 : 0.001 : 0.001
  10-b :  22  : 0.006 : 0.001 : 0.000 (確)
   849 :  24  : 0.044 : 0.010 : 0.010
  1122 :  24  : 0.025 : 0.005 : 0.002
-------+------+-------+-------+-----------
  合計 :      : 0.173 : 0.046 : 0.015

実行環境 : Lubuntu 14.10 on VirtualBox, Core i7-2670QM 2.20GHz
</pre>
<p> (確) は確定サーチだけで解けたことを表します。実行時間は速すぎで計測不能でした。確定サーチの効果は大きいことがわかります。ただし、どのような問題でも高速に解けるわけではなく、基本的な確定サーチだけでは限界があるようです。興味のある方はいろいろ試してみてください。
</p>
<p> なお、バックトラックを使わないで数独を解く方法もあります。興味のある方は拙作のページ <A href="../func/scheme.html">Scheme Programming</A> <A href="../func/abcscm41.html">パズルの解法 [6]</A> <A href="../func/abcscm42.html">[7]</A> をお読みください。
</p>
<h4><A name="cite">●参考文献</A></h4>
[1] 松田晋, 『実践アルゴリズム戦略 解法のテクニック &lt;第11回&gt; バックトラックによる｢数独｣の解法』, C MAGAZINE 1993 年 3 月号, ソフトバンク
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
/*
 * numpla0.c : 数独の解法
 *
 *             Copyright (C) 2015 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

#define N 9

// 盤面
int board[N][N];

// 横のチェック
bool check_line(int n, int x)
{
  for (int i = 0; i &lt; N; i++) {
    if (board[x][i] == n) return false;
  }
  return true;
}

// 縦のチェック
bool check_column(int n, int y)
{
  for (int i = 0; i &lt; N; i++) {
    if (board[i][y] == n) return false;
  }
  return true;
}

// 枠のチェック
bool check_group(int n, int x, int y)
{
  int x1 = (x / 3) * 3; 
  int y1 = (y / 3) * 3; 
  for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 3; j++) {
      if (board[x1 + i][y1 + j] == n) return false;
    }
  }
  return true;
}

// 数字をおけるかチェックする
bool check(int n, int x, int y)
{
  return check_column(n, y) &amp;&amp; check_line(n, x) &amp;&amp; check_group(n, x, y);
}

// 盤面の表示
void print_board(void)
{
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      printf("%d ", board[x][y]);
    }
    printf("\n");
  }
}

// 数独の解法
void solver(int n)
{
  if (n == N * N) 
    print_board();
  else {
    int x = n / N;
    int y = n % N;
    if (board[x][y] != 0)
      solver(n + 1);
    else {
      for (int i = 1; i &lt;= N; i++) {
        if (check(i, x, y)) {
          board[x][y] = i;
          solver(n + 1);
          board[x][y] = 0;
        }
      }
    }
  }
}

// 問題を board にコピー
void copy_question(int q[][N])
{
  for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
      board[i][j] = q[i][j];
    }
  }
}

//
// 問題は省略
//

void test(int q[][N])
{
  copy_question(q);
  clock_t s = clock();
  solver(0);
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
}

int main(void)
{
  clock_t s = clock();
  test(q8a);
  test(q8b);
  test(q9a);
  test(q9b);
  test(q10a);
  test(q10b);
  test(q849);
  test(q1122);
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
  return 0;
}
</pre>
<hr>
<h4 id="list2">●プログラムリスト２</h4>
<pre class="list">
/*
 * numpla1.c : 数独の解法
 *
 *             Copyright (C) 2015 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

#define N 9

// 盤面
int board[N][N];

// フラグ
int xflag[N], yflag[N], gflag[N];

// ビットカウント
int bit_count(unsigned int n)
{
  unsigned int a = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);
  unsigned int b = (a &amp; 0x33333333) + ((a &gt;&gt; 2) &amp; 0x33333333);
  unsigned int c = (b &amp; 0x0f0f0f0f) + ((b &gt;&gt; 4) &amp; 0x0f0f0f0f);
  unsigned int d = (c &amp; 0x00ff00ff) + ((c &gt;&gt; 8) &amp; 0x00ff00ff);
  return (d &amp; 0xffff) + (d &gt;&gt; 16);
}

// グループ番号を求める
int get_group(int x, int y)
{
  return (x / 3) * 3 + y / 3;
}

// 置くことができる数字を求める
int get_numbers(int x, int y)
{
  return xflag[x] &amp; yflag[y] &amp; gflag[get_group(x, y)];
}

// 数字を置く
void set_number(int n, int x, int y)
{
  board[x][y] = n;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}

// 数字を削除する
void del_number(int n, int x, int y)
{
  board[x][y] = 0;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}

// 盤面の表示
void print_board(void)
{
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      printf("%d ", bit_count(board[x][y] - 1));
    }
    printf("\n");
  }
}

// 数独の解法
void solver(int n)
{
  if (n == N * N) 
    print_board();
  else {
    int x = n / N;
    int y = n % N;
    if (board[x][y] != 0)
      solver(n + 1);
    else {
      for (int m = get_numbers(x, y); m &gt; 0; m &amp;= m - 1) {
        int i = m &amp; (-m);
        set_number(i, x, y);
        solver(n + 1);
        del_number(i, x, y);
      }
    }
  }
}

// 初期化
void init_board(int q[][N])
{
  for (int i = 0; i &lt; N; i++)
    xflag[i] = yflag[i] = gflag[i] = 0x3fe;
  for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
      int n = q[i][j];
      if (n == 0)
        board[i][j] = n;
      else
        set_number(1 &lt;&lt; n, i, j);
    }
  }
}

//
// 問題は省略
//

void test(int q[][N])
{
  init_board(q);
  clock_t s = clock();
  solver(0);
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
}

int main(void)
{
  clock_t s = clock();
  test(q8a);
  test(q8b);
  test(q9a);
  test(q9b);
  test(q10a);
  test(q10b);
  test(q849);
  test(q1122);
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
  return 0;
}
</pre>
<hr>
<h4 id="list3">●プログラムリスト３</h4>
<pre class="list">
/*
 * numpla2.c : 数独の解法 (バックトラック＋確定サーチ)
 *
 *             Copyright (C) 2015 Makoto Hiroi
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

#define N 9

// 盤面
int board[N][N];

// フラグ
int xflag[N], yflag[N], gflag[N];

// ビットカウント
int bit_count(unsigned int n)
{
  unsigned int a = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);
  unsigned int b = (a &amp; 0x33333333) + ((a &gt;&gt; 2) &amp; 0x33333333);
  unsigned int c = (b &amp; 0x0f0f0f0f) + ((b &gt;&gt; 4) &amp; 0x0f0f0f0f);
  unsigned int d = (c &amp; 0x00ff00ff) + ((c &gt;&gt; 8) &amp; 0x00ff00ff);
  return (d &amp; 0xffff) + (d &gt;&gt; 16);
}

// グループ番号を求める
int get_group(int x, int y)
{
  return (x / 3) * 3 + y / 3;
}

// 置くことができる数字を求める
int get_numbers(int x, int y)
{
  return xflag[x] &amp; yflag[y] &amp; gflag[get_group(x, y)];
}

// 数字を置く
void set_number(int n, int x, int y)
{
  board[x][y] = n;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}

// 数字を削除する
void del_number(int n, int x, int y)
{
  board[x][y] = 0;
  xflag[x] ^= n;
  yflag[y] ^= n;
  gflag[get_group(x, y)] ^= n;
}

// 盤面の表示
void print_board(void)
{
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      if (board[x][y] == 0) 
        printf("0 ");
      else
        printf("%d ", bit_count(board[x][y] - 1));
    }
    printf("\n");
  }
}

// バックトラックによる解法
void solver(int n)
{
  if (n == N * N) 
    print_board();
  else {
    int x = n / N;
    int y = n % N;
    if (board[x][y] != 0)
      solver(n + 1);
    else {
      for (int m = get_numbers(x, y); m &gt; 0; m &amp;= m - 1) {
        int i = m &amp; (-m);
        set_number(i, x, y);
        solver(n + 1);
        del_number(i, x, y);
      }
    }
  }
}

// 初期化
void init_board(int q[][N])
{
  for (int i = 0; i &lt; N; i++)
    xflag[i] = yflag[i] = gflag[i] = 0x3fe;
  for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
      int n = q[i][j];
      if (n == 0)
        board[i][j] = n;
      else
        set_number(1 &lt;&lt; n, i, j);
    }
  }
}

//
// 確定サーチ
//

// マス
int decide_cell(void)
{
  int c = 0;
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      if (board[x][y] == 0) {
        int n = get_numbers(x, y);
        if (bit_count(n) == 1) {
          set_number(n, x, y);
          c++;
        }
      }
    }
  }
  return c;
}

// 縦
int decide_column_sub(int y)
{
  int c = 0;
  for (int m = yflag[y]; m &gt; 0; m &amp;= m - 1) {
    int n = m &amp; (-m), c1 = 0, x1;
    for (int x = 0; x &lt; N; x++) {
      if (board[x][y] == 0 &amp;&amp; get_numbers(x, y) &amp; n) {
        if (++c1 &gt; 1) break;
        x1 = x;
      }
    }
    if (c1 == 1) {
      set_number(n, x1, y);
      c++;
    }
  }
  return c;
}
    
int decide_column(void)
{
  int c = 0;
  for (int y = 0; y &lt; N; y++)
    c += decide_column_sub(y);
  return c;
}

// 横
int decide_line_sub(int x)
{
  int c = 0;
  for (int m = xflag[x]; m &gt; 0; m &amp;= m - 1) {
    int n = m &amp; (-m), c1 = 0, y1;
    for (int y = 0; y &lt; N; y++) {
      if (board[x][y] == 0 &amp;&amp; get_numbers(x, y) &amp; n) {
        if (++c1 &gt; 1) break;
        y1 = y;
      }
    }
    if (c1 == 1) {
      set_number(n, x, y1);
      c++;
    }
  }
  return c;
}

int decide_line(void)
{
  int c = 0;
  for (int x = 0; x &lt; N; x++)
    c += decide_line_sub(x);
  return c;
}

// 枠 (x, y) は左上の位置
int decide_group_sub(int x, int y)
{
  int c = 0;
  for (int m = gflag[get_group(x, y)]; m &gt; 0; m &amp;= m - 1) {
    int n = m &amp; (-m), c1 = 0, x1, y1;
    for (int i = 0; i &lt; 3; i++) {
      for (int j = 0; j &lt; 3; j++) {
        if (board[x + i][y + j] == 0 &amp;&amp; get_numbers(x + i, y + j) &amp; n) {
          if (++c1 &gt; 1) goto end;
          x1 = x + i;
          y1 = y + j;
        }
      }
    }
  end:
    if (c1 == 1) {
      set_number(n, x1, y1);
      c++;
    }
  }
  return c;
}
  
int decide_group(void)
{
  int c = 0;
  for (int x = 0; x &lt; N; x += 3) {
    for (int y = 0; y &lt; N; y += 3) {
      c += decide_group_sub(x, y);
    }
  }
  return c;
}

// 解けたか
bool is_finish()
{
  for (int x = 0; x &lt; N; x++) {
    for (int y = 0; y &lt; N; y++) {
      if (board[x][y] == 0) return false;
    }
  }
  return true;
}

// 確定サーチ
bool decide_number(void)
{
  while (true) {
    int c = decide_cell();
    c += decide_line();
    c += decide_column();
    c += decide_group();
    if (c == 0) break;
  }
  return is_finish();
}

//
// 問題は省略
//

// バックトラック＋確定サーチ
void solver1(int q[][N])
{
  init_board(q);
  clock_t s = clock();
  if (decide_number()) {
    printf("finish!\n");
    print_board();
  } else {
    printf("backtack!\n");
    solver(0);
  }
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
}

int main(void)
{
  clock_t s = clock();
  solver1(q8a);
  solver1(q8b);
  solver1(q9a);
  solver1(q9b);
  solver1(q10a);
  solver1(q10b);
  solver1(q849);
  solver1(q1122);
  printf("%.3f\n", (double)(clock() - s)/CLOCKS_PER_SEC);
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang23.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang25.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>