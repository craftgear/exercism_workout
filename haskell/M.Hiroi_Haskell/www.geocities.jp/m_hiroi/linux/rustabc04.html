<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881816</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>Rust の基礎知識</h3>
<h4 id="abc47">●ポインタの基本</h4>
<ul>
  <li>Rust には *const T と *mut T という「ポインタ」がある</li>
  <li>Rust では「生ポインタ (raw pointers)」と呼ばれている</li>
  <li>Rust の参照 (&amp;T, &amp;mut T) には制約がある (借用チェッカー)</li>
  <li>生ポインタの場合、*mut T はいくつでも作ることができ、*const T と混在させることもできる</li>
  <li>ただし、生ポインタが指し示すデータの安全性は保証されていない</li>
  <li>また、生ポインタ自身の値も正しいことは保証されていない</li>
    <ul>
      <li>null ポインタかもしれないし、でたらめなメモリを指し示しているかもしれない</li>
      <li>安全確認はプログラマの責任</li>
    </ul>
  <li>このため、生ポインタをデリファレンスするときには unsafe が必要になる</li>
  <li>なお、生ポインタからデータを move することはできないようだ</li>
</ul>
<ul>
  <li>参照を生ポインタに型変換する操作は安全である</li>
    <ul>
      <li>let x = 123; の生ポインタは let raw = &amp;x as *const i32;</li>
      <li>または let raw: *const i32 = &amp;x;</li>
      <li>let mut y = 456; の生ポインタは let raw_mut = &amp;mut y as *mut i32;</li>
      <li>または let raw_mut: *mut i32 = &amp;mut y;</li>
    </ul>
  <li>デリファレンスは * を使う (unsafe)</li>
    <ul>
      <li>println!("{}", *raw); とか *raw_mut = 789; など</li>
    </ul>
  <li>生ポインタを参照に変換することもできる (unsafe)</li>
    <ul>
      <li>let ref_x = &amp;*raw; とか let mut ref_y = &amp;mut *raw_mut; など</li>
    </ul>
</ul>
<pre class="list">
リスト : ポインタの簡単な使用例

struct Foo {
    nums: i32
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("drop foo {}", self.nums);
    }
}

fn main() {
    let x = 123;
    let raw_x = &amp;x as *const i32;
    let ref_x;
    println!("{:p}", raw_x);   // :p はポインタ (アドレス) を表示する
    unsafe {
        ref_x = &amp;*raw_x;
        println!("{}", *raw_x);
    }
    println!("{}", ref_x);

    let mut y = 456;
    let raw_y = &amp;y as *const i32;
    let raw_mut_y = &amp;mut y as *mut i32;
    let raw_mut_y1 = &amp;mut y as *mut i32;
    println!("{:p}", raw_y);
    println!("{:p}", raw_mut_y);
    println!("{:p}", raw_mut_y1);
    let mut ref_mut_y;
    unsafe {
        println!("{}", *raw_y);
        *raw_mut_y = 999;
        println!("{}", *raw_y);
        *raw_mut_y1 = 9999;
        println!("{}", *raw_y);
        ref_mut_y = &amp;mut *raw_mut_y;
    }
    *ref_mut_y = 10000;
    println!("{}", y);

    let mut z = Foo { nums: 1000 };
    let raw_z = &amp;z as *const Foo;
    let raw_mut_z = &amp;mut z as *mut Foo;
    unsafe {
        println!("{}", (*raw_z).nums);
        // let a = *raw_z; raw pointer から move はできない
        // println!("{}", a.nums);
        *raw_mut_z = Foo { nums: 2000 };
        println!("{}", (*raw_z).nums);
    }
}
</pre>
<pre>
0x6af8dc
123
123
0x6af9cc
0x6af9cc
0x6af9cc
456
999
9999
10000
1000
drop foo 1000
2000
drop foo 2000
</pre>
<ul>
  <li>生ポインタはメソッド offset() で位置 (アドレス) を変更することができる</li>
<pre class="item">
unsafe fn offset(self, cnt: isize) -&gt; *const T
unsafe fn offset(self, cnt: isize) -&gt; *mut T
</pre>
  <li>cnt は要素の個数を表す (バイト数ではない, Ｃ言語のポインタと同じ)</li>
  <li>Rust の場合、配列やベクタの要素は連続したメモリ領域に配置される</li>
  <li>先頭要素の参照を生ポインタに型変換すると、それはメモリ領域の先頭アドレスを指し示す</li>
  <li>offset() を使えば各要素にアクセスすることができる</li>
</ul>
<pre class="list">
リスト : offset() の簡単な使用例

fn main() {
    let a = [1, 2, 3, 4, 5, 6, 7, 8];
    let raw_a = &amp;a[0] as *const i32;
    println!("{:p}", raw_a);
    unsafe {
        for i in 0 .. 8 {
            print!("{} ", *raw_a.offset(i));
        }
        println!("");
    }
    let mut b = vec![1, 2, 3, 4, 5, 6, 7, 8];
    let mut raw_b = &amp;mut b[0] as *mut i32;
    println!("{:p}", raw_b);
    unsafe {
        for _ in 0 .. 8 {
            *raw_b *= 10;
            print!("{} ", *raw_b);
            raw_b = raw_b.offset(1)
        }
        println!("");
    }
}
</pre>
<pre>
0x6afac8
1 2 3 4 5 6 7 8
0x7fed30
10 20 30 40 50 60 70 80
</pre>
<ul>
  <li>Box&lt;T&gt; などに格納されている要素の参照を生ポインタに変換することもできる</li>
  <li>Box::into_raw(box) を使っても、生ポインタ *mut T を取得することができる</li>
  <li>このとき、Box は消費 (破棄) されるので、ポインタが剥き出しの状態になる</li>
  <li>メモリ領域の解法はプログラマの責任になる</li>
  <ul>
    <li>関数 unsafe Box::from_raw(ptr) で生ポインタを Box に包み直す</li>
    <li>関数 drop() でその Box を解放する</li>
    <li>もしくは std::ptr::drop_in_place(ptr) を使う</li>
  </ul>
</ul>
<pre class="list">
リスト : Box と生ポインタの使用例

struct Foo {
    nums: i32
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("drop foo {}", self.nums);
    }
}

fn main() {
    let a = Box::new(Foo { nums: 123 });
    let raw_a = &amp;*a as *const Foo;
    unsafe {
        println!("{}", (*raw_a).nums);
    }
    let mut b = Box::new(Foo { nums: 456 });
    let raw_mut_b = &amp;mut *b as *mut Foo;
    unsafe {
        println!("{}", (*raw_mut_b).nums);
        *raw_mut_b = Foo { nums: 789 };
        println!("{}", (*raw_mut_b).nums);
    }
    let c = Box::new(Foo { nums: 1000 });
    let raw_mut_c = Box::into_raw(c);
    unsafe {
        println!("{}", (*raw_mut_c).nums);
        drop(Box::from_raw(raw_mut_c));
        // drop(raw_mut_c);  NG
        // std::ptr::drop_in_place(raw_mut_c);  OK
    }
}
</pre>
<pre>
123
456
drop foo 456
789
1000
drop foo 1000
drop foo 789
drop foo 123
</pre>
<ul>
  <li>このほかにもモジュール <a href="https://doc.rust-lang.org/std/ptr/">std::ptr</a> には生ポインタ用の関数がいくつか用意されている</li>
</ul>
<h4 id="abc48">●マクロの基本</h4>
<ul>
  <li>Rust のマクロは Scheme の「健全なマクロ (hygienic macro)」と同様の機能である</li>
  <li>マクロは Rust のプログラムにコンパイルされ、それがソースコード中に展開される</li>
  <li>それを再度コンパイルすることで実行ファイルを生成する</li>
  <li>Rust のマクロは macro_rules! というマクロを使って記述する</li>
  <li>マクロの記述には独自のパターン言語を使う</li>
<pre class="item">
macro_rules! マクロ名 {
    (pattern1) =&gt; (template1);
    (pattern2) =&gt; (template2);
        ...,
    (patternN) =&gt; (templateN);
}
</pre>
  <li>pattern はマクロの入力パターン (引数) を表す (Rust ではマッチャーと呼ぶようだ)</li>
  <li>引数がパターンとマッチングする場合、それに対応するテンプレート template に変換する</li>
  <li>パターンの基本は $名前:識別子 で、$名前 はパターン変数を表す</li>
  <li>識別子はマッチさせるデータ型を表す</li>
    <ul>
      <li>block, expr, ident, item, pat, path, stmt, tt, ty</li>
    </ul>
  <li>マッチングしたデータはパターン変数に格納され、テンプレートで使用することができる</li>
</ul>
<pre class="list">
リスト : マクロの簡単な使用例 (1)

macro_rules! foo {
    ($a:expr) =&gt; (println!("{:?} = {:?}", stringify!($a), $a));
}

macro_rules! bar {
    () =&gt; (println!("[]"));
    ($a:expr) =&gt; (println!("{:?}", [$a]));
    ($a:expr, $b:expr) =&gt; (println!("{:?}", [$a, $b]));
    ($a:expr, $b:expr, $c:expr) =&gt; (println!("{:?}", [$a, $b, $c]));
}

fn main() {
    foo!(1 + 2);
    foo![11 * 12];
    foo!{100 - 200};
    // foo!(); コンパイルエラー
    bar!();
    bar!(1);
    bar!(1,2);
    bar!(1,2,3);
}
</pre>
<pre>
"1 + 2" = 3
"11 * 12" = 132
"100 - 200" = -100
[]
[1]
[1, 2]
[1, 2, 3]
</pre>
<ul>
  <li>expr は式を指定する識別子</li>
  <li>foo! の引数 (式) はパターン変数 $a に格納される</li>
  <li>stringify! は引数を文字列に変換するマクロ</li>
  <li>foo! は println!() に展開され、そのあとコンパイルされる</li>
  <li>マクロの呼び出しは () だけではなく、[] でも {} でもよい</li>
  <li>パターン言語で使用する識別子や記号などを除いて、任意の文字列はそれ自身とマッチングする</li>
  <li>たとえば、bar! のパターンはカンマで区切られているので、カンマとマッチングする</li>
  <li>カンマ以外のトークンで区切ることもできるが、識別子によって次に受け付けるトークンにルールがある</li>
    <ul>
      <li>たとえば expr の場合、, ; =&gt; のどれかひとつだけが許される</li>
    </ul>
</ul>
<ul>
  <li>1 回以上の繰り返しは $(...),+ で、0 回以上の繰り返しは $(...),+ で表すことができる </li>
  <li>カンマは区切り文字</li>
  <li>繰り返しはパターンとテンプレートの両方で使用する</li>
  <li>繰り返しを入れ子にすることもできる</li>
</ul>
<pre class="list">
リスト : マクロの簡単な使用例 (2)

macro_rules! sum {
    () => (0);
    ($($x:expr),+) => ({
        let mut acc = 0;
        $( acc += $x; )+
        acc
    });
}

fn main() {
    println!("{}", sum!());
    println!("{}", sum!(1));
    println!("{}", sum!(1, 2, 3, 4, 5));
}
</pre>
<pre>
0
1
15
</pre>
<ul>
  <li>このほかにも、再帰的なマクロや健全性などの話があるが、本稿では立ち入らない</li>
  <li>最後に、マクロの簡単な例題として遅延評価のプログラムを示す</li>
  <li>遅延評価の説明は拙作のページ <a href="rust06.html">遅延評価</a> を参照</li>
</ul>
<pre class="list">
リスト : マクロの簡単な例題

use std::cell::RefCell;

// 遅延評価
struct Delay&lt;'a, T: 'a&gt; {
    value: RefCell&lt;Option&lt;T&gt;&gt;,
    func: Box&lt;Fn() -&gt; T + 'a&gt;
}

impl&lt;'a, T: 'a&gt; Delay&lt;'a, T&gt; {
    fn new&lt;F: 'a&gt;(f: F) -&gt; Delay&lt;'a, T&gt; where F: Fn() -&gt; T {
        Delay { func: Box::new(f), value: RefCell::new(None) }
    }
    fn force(&amp;self) -&gt; &amp;T {
        let mut val = self.value.borrow_mut();
        if val.is_none() {
            *val = Some((self.func)());
        }
        match unsafe { self.value.as_ptr().as_ref().unwrap() } {
            &amp;Some(ref x) =&gt; x,
            _ =&gt; unreachable!()
        }
    }
}

// Delay を生成するマクロ
// delay! を定義することで使いやすくなる
macro_rules! delay {
    ($e:expr) => (Delay::new(move || $e));
}

// たらいまわし関数
fn tarai(x: i32, y: i32, z: Delay&lt;i32&gt;) -&gt; i32 {
    if x &lt;= y {
        y
    } else {
        let zz = *z.force();
        tarai(tarai(x - 1, y, z),
              tarai(y - 1, zz, delay!(x)),
              delay!(tarai(zz - 1, x, delay!(y))))
    }
}

fn main() {
    let a = delay!({println!("oops"); 1 + 2});  // ブロックも式
    println!("{}", a.force()); 
    println!("{}", a.force());
    println!("{}", tarai(14, 7, delay!(0)));
    println!("{}", tarai(140, 70, delay!(0)));
}
</pre>
<pre>
oops
3
3
14
140
</pre>
<h4 id="abc49">●ライフタイム境界</h4>
<ul>
  <li>Rust は型パラメータの境界にライフタイムを指定することができる</li>
  <li>Rust では「ライフタイム境界」と呼んでいるようだ</li>
  <ol>
    <li>T: 'a<br>T 内の全ての参照は 'a よりも長生きでなくてはならない</li>
    <li>T: Trait + 'a<br>1 に加えてTはTraitという名のトレイトを実装してなくてはならない</li>
  </ol>
</ul>

<pre class="list">
リスト : ライフタイム境界の簡単な例 (1)

struct Foo&lt;'a, T: 'a&gt; {
    value: &amp;'a T
}

impl&lt;'a, T&gt; Foo&lt;'a, T&gt; {
    fn new(val: &amp;'a T) -> Foo&lt;'a, T&gt; {
        Foo { value: val }
    }
}

fn main() {
    let x = 10;
    let a = Foo::new(&amp;x);
    println!("{}", a.value);

    //let b: Foo&lt;i32&gt;;
    //{
    //    let y = 20;  コンパイルエラー `y` does not live long enough
    //    b = Foo::new(&amp;y);
    //}
}
</pre>
<pre>
10
</pre>
<ul>
  <li>構造体 Foo のフィールド value は参照を格納するのでライフタイムパラメータ 'a の指定が必要</li>
  <li>value の参照先 (T の値) が Foo よりも先に解放されてはいけない</li>
  <li>つまり、T の参照 (&amp;T) のライフタイムは Foo よりも短くなることはない</li>
  <li>この条件を T の境界にライフタイムパラメータ 'a を指定することで表す</li>
  <li>Foo にライフタイムパラメータが必要なので、impl でもライフタイムパラメータを指定する</li>
  <li>変数 b は変数 y よりもライフタイムが長い</li>
  <li>したがって、y の参照を格納した Foo を変数 b にセットすることはできない (コンパイルエラー)</li>
</ul>
<pre class="list">
リスト : ライフタイム境界の簡単な例 (2)

use std::cell::RefCell;

// 遅延評価
struct Delay&lt;'a, T: 'a&gt; {
    value: RefCell&lt;Option&lt;T&gt;&gt;,
    func: Box&lt;Fn() -&gt; T + 'a&gt;
}

impl&lt;'a, T: 'a&gt; Delay&lt;'a, T&gt; {
    fn new&lt;F: 'a&gt;(f: F) -&gt; Delay&lt;'a, T&gt; where F: Fn() -&gt; T {
        Delay { func: Box::new(f), value: RefCell::new(None) }
    }
    fn force(&amp;self) -&gt; &amp;T {
        let mut val = self.value.borrow_mut();
        if val.is_none() {
            *val = Some((self.func)());
        }
        match unsafe { self.value.as_ptr().as_ref().unwrap() } {
            &amp;Some(ref x) =&gt; x,
            _ =&amp; unreachable!()
        }
    }
}
</pre>
<ul>
  <li>Delay のメソッド new() はクロージャ F を Box に包んで func にセットする</li>
  <li>F は Delay よりも先に解放されてはいけない</li>
  <li>F のライフタイムが Delay より短くないことを表すため、Delay にライフタイムパラメータ 'a を指定する</li>
  <li>そして、メソッド new() の型パラメータ F の境界に 'a を指定する</li>
  <li>なお、Delay&lt;'a, T: 'a&gt; とするだけではコンパイルエラー (parameter `'a` is never used) になる</li>
  <li>クロージャの型を Fn() -&gt; T + 'a とするとコンパイルが通る</li>
</ul>
<h4 id="abc50">●Copy と Clone</h4>
<ul>
  <li>構造体に Copy トレイトを実装すると、他の変数 (引数) に代入するとき値がコピーされる</li>
  <li>このとき「所有権」は移動しない</li>
  <li>実際には、Clone トレイトのメソッド clone() でコピーが行われる</li>
  <li>したがって、Copy だけではなく Clone トレイトの実装も必要になる</li>
  <li>Copy, Clone トレイトは derive を使うと簡単に実装できる</li>
</ul>
<pre class="list">
リスト : Copy と Clone トレイト

#[derive(Debug)]
struct Foo {
    num: i32
}

#[derive(Debug, Copy, Clone)]
struct Bar {
    num: i32
}

#[derive(Debug, Copy, Clone)]
struct Baz&lt;T&gt; {
    item: T
}

fn main() {
    let a = Foo { num: 123 };
    let mut b = a;            // 所有権の移動
    b.num += 1000;
    // println!("{:?}", a);      コンパイルエラー
    println!("{:?}", b);
    let c = Bar { num: 456 };
    let mut d = c;            // コピー
    d.num += 1000; 
    println!("{:?}", c);      // 所有権は移動しないのでアクセスできる
    println!("{:?}", d);

    let e = Baz { item: Foo { num: 123 } };
    let f = e;      // 所有権の移動
    // println!("{:?}", e);   コンパイルエラー
    println!("{:?}", f);

    let g = Baz { item: Bar { num: 456 } };
    let h = g;      // コピー
    println!("{:?}", g);
    println!("{:?}", h);}
</pre>
<pre>
Foo { num: 1123 }
Bar { num: 456 }
Bar { num: 1456 }
Baz { item: Foo { num: 123 } }
Baz { item: Bar { num: 456 } }
Baz { item: Bar { num: 456 } }
</pre>
<ul>
  <li>derive はトレイトの実装に必ず成功するわけではない</li>
  <li>Baz&lt;T&gt; の場合、型 T に Copy トレイトが実装されていないと、値はコピーされずに所有権が移動することになる</li>
  <li>必ずコピーしたい場合は、型パラメータ T の境界に Copy を指定するとよい</li>
  <li>T に Copy が実装されていないとコンパイルエラー</li>
</ul>
<h4 id="abc51">●トランスミュート (transmute)</h4>
<ul>
  <li>関数 std::mem::taransumute() は unsafe な型変換を行う</li>
<pre class="item">
pub unsafe extern "rust-intrinsic" fn transmute&lt;T, U&gt;(e: T) -&gt; U
</pre>
  <li>引数 e (型 T) を型 U に変換する</li>
  <li>双方の型がサイズとメモリ上への配置の仕方において同じであること</li>
  <li>整数と浮動小数点数の変換もできるが、値ではなくビットパターンでの変換になる</li>
  <li>サイズが合わないとコンパイルエラー</li>
</ul>
<pre class="list">
リスト : transmute() の簡単な使用例

use std::mem::transmute;

fn main() {
    unsafe {
        // transmute() はビットパターンでの変換になる
        println!("{:X}", transmute::&lt;f64, u64&gt;(1.2345));
        println!("{:X}", transmute::&lt;f32, u32&gt;(1.2345));

        // u8 の配列を数値に変換するときはエンディアンに注意
        let a: [u8; 4] = [0x19, 0x04, 0x9e, 0x3f];
        println!("{:X}", transmute::&lt;[u8; 4], u32&gt;(a));
        println!("{}", transmute::&lt;[u8; 4], f32&gt;(a));
        println!("{:?}", transmute::&lt;i32, [u8; 4]&gt;(0x12345678));
    }
}
</pre>
<pre>
3FF3C083126E978D
3F9E0419
3F9E0419
1.2345
[120, 86, 52, 18]
</pre>
<ul>
  <li>transmute() はライフタイムも変換することができるようだ</li>
  <li>詳細は <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">Function std::mem::transmute</a> を参照</li>
</ul>
<h4 id="abc52">●Hash</h4>
<ul>
  <li>構造体を HashMap (HashSet) のキーとして使用する場合は Hash トレイトを実装する</li>
  <li>Hash トレイトは derive を使うと簡単に実装できる</li>
  <li>実際には PartialEq と Eq の実装も必要になる</li>
  <li>Rust の場合、ハッシュ値の計算は Hasher トレイトを実装したオブジェクトで行う</li>
  <li>Hash のメソッド hash() は Hasher にデータを渡すだけ</li>
<pre class="item">
fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher,
</pre>
  <li>hash() を何度も呼び出すことで複数のデータを渡すこともできる</li>
  <li>Hasher のメソッド finish() でハッシュ値を求める (返り値は u64)</li>
  <li>std::collections::hash_map::DefaultHasher にデフォルトの Hasher が用意されている</li>
</ul>
<pre class="list">
リスト : トレイト Hash の簡単な使用例

use std::collections::HashSet;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

#[derive(Hash, PartialEq, Eq)]
struct Foo {
    num: i32
}

fn main() {
    let mut h: HashSet&lt;Foo&gt; = HashSet::new();
    for i in 0 .. 10 {
        h.insert(Foo { num: i });
    }
    println!("{}", h.contains(&amp;Foo { num: 0 }));
    println!("{}", h.contains(&amp;Foo { num: 9 }));
    println!("{}", h.contains(&amp;Foo { num: 10 }));

    for i in 0 .. 10 {
        let mut hasher: DefaultHasher = DefaultHasher::new();
        let a = Foo { num: i };
        a.hash(&amp;mut hasher);
        println!("{}", hasher.finish());
    }
}
</pre>
<pre>
true
true
false
14709398186846620400
1742378985846435984
16336925911988107921
568126464209439262
15565210526001683492
14828406784900857967
2748490571820495779
13916993215237271530
17499417595158719687
16856616568243533183
</pre>
<h4 id="abc53">●Default</h4>
<ul>
  <li>Default はデータ型のデフォルト値を規定するトレイト</li>
<pre class="item">
pub trait Default {
    fn default() -> Self;
}
</pre>
  <li>Default::default() でデータ型のデフォルト値を取得することができる</li>
  <li>Default トレイトは derive で簡単に実装できる</li>
  <li>この場合、Rust で標準的なデフォルト値になる</li>
  <li>独自のデフォルト値を指定したい場合はメソッド default() を実装する</li>
</ul>
<pre class="list">
リスト : Default トレイトの簡単な使用例

#[derive(Debug, Default)]
struct Foo {
    x: i32,
    y: f64
}

#[derive(Debug)]
struct Bar {
    x: i32,
    y: f64
}

impl Default for Bar {
    fn default() -&gt; Bar {
        Bar { x: 12345, y: 1.2345}
    }
}

fn main() {
    let a: i32 = Default::default();
    let b: f64 = Default::default();
    let c: Foo = Default::default();
    let d: Bar = Default::default();
    println!("{}", a);
    println!("{}", b);
    println!("{:?}", c);
    println!("{:?}", d);
}
</pre>
<pre>
0
0
Foo { x: 0, y: 0 }
Bar { x: 12345, y: 1.2345 }
</pre>
<h4 id="abc54">●UnsafeCell&lt;T&gt;</h4>
<ul>
  <li>UnsafeCell&lt;T&gt; は Cell&lt;T&gt; や RefCell&lt;T&gt; と同様のデータ構造だが、生ポインタを使ってデータを操作するところが異なる</li>
  <li>UnsafeCell の生成はメソッド new() で行う</li>
<pre class="item">
fn new(value: T) -&gt; UnsafeCell&lt;T&gt;
</pre>
  <li>生ポインタの取得はメソッド get() を使う</li>
<pre class="item">
fn get(&amp;self) -&gt; *mut T
</pre>
  <li>データを取り出す (move する) ときはメソッド into_inner() を使う</li>
<pre class="item">
unsafe fn into_inner(self) -&gt; T
</pre>
</ul>
<pre class="list">
リスト : UnsafeCell の簡単な使用例

use std::cell::UnsafeCell;

#[derive(Debug)]
struct Foo {
    x: i32, y: i32
}

fn main() {
    let a = UnsafeCell::new(123);
    let p = a.get();
    unsafe {
        println!("{}", *p);
        *p = 456;
        println!("{}", *p);
    }

    let b = UnsafeCell::new(Foo { x: 10, y: 20 });
    let q = b.get();
    unsafe {
        println!("{}", (*q).x);
        println!("{}", (*q).y);
        (*q).x = 123;
        (*q).y = 456;
        println!("{}", (*q).x);
        println!("{}", (*q).y);
        let b1 = b.into_inner();
        println!("{:?}", b1);
    }

    let c = UnsafeCell::new(Box::new(Foo { x: 10, y: 20 }));
    let r = c.get();
    unsafe {
        println!("{}", (*r).x);
        println!("{}", (*r).y);
        (*r).x = 123;
        (*r).y = 456;
        println!("{}", (*r).x);
        println!("{}", (*r).y);
        let c1 = c.into_inner();
        println!("{:?}", c1);
    }
}
</pre>
<pre>
123
456
10
20
123
456
Foo { x: 123, y: 456 }
10
20
123
456
Foo { x: 123, y: 456 }
</pre>
<h4 id="abc55">●Ref&lt;T&gt; と RefMut&lt;T&gt;</h4>
<ul>
  <li><a href="rustabc03.html#abc36">RefCell&lt;T&gt;</a> のメソッド borrow() は Ref&lt;T&gt; を返す</li>
  <li>メソッド borrow_mut() は RefMut&lt;T&gt; を返す</li>
  <li>Ref と RefMut にはメソッド Ref::map(), RefMut::map() が用意されている</li>    
<pre class="item">
fn map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt; 
where
    F: FnOnce(&amp;T) -&gt; &amp;U,
    U: ?Sized, 
</pre>
<pre class="item">
fn map&lt;U, F&gt;(orig: RefMut&lt;'b, T&gt;, f: F) -&gt; RefMut&lt;'b, U&gt; 
where
    F: FnOnce(&amp;mut T) -&gt; &amp;mut U,
    U: ?Sized, 
</pre>
  <li>map() は RefCell に格納されているデータ構造 (構造体やタプルなど) の要素の参照を取得するのに便利</li>
  <li>このほかに、Ref にはメソッド Ref::clone() がある (RefMut にはない)</li>
<pre class="item">
fn clone(orig: &amp;Ref&lt;'b, T&gt;) -&gt; Ref&lt;'b, T&gt;
</pre>
</ul>
<pre class="list">
リスト : Ref と RefMut の簡単な使用例

use std::cell::{RefCell, Ref, RefMut};

#[derive(Debug)]
struct Foo {
    x: i32, y: f64
}

fn main() {
    let a = RefCell::new(Foo { x: 100, y: 1.2345 });
    {
        let p = Ref::map(a.borrow(), |foo| &amp;foo.x);
        let q = Ref::clone(&amp;p);
        println!("{}", *p);
        println!("{}", *q);
    }
    {
        let mut r = RefMut::map(a.borrow_mut(), |foo| &amp;mut foo.y);
        *r *= 10.0;
    }
    println!("{:?}", a); 
}
</pre>
<pre>
100
100
RefCell { value: Foo { x: 100, y: 12.344999999999999 } }
</pre>
<h4 id="abc56">●BinaryHeap&lt;T&gt;</h4>
<ul>
  <li>BinaryHeap&lt;T&gt; は「二分ヒープ (binary heap)」を使ったプライオリティキュー</li>
  <li>データ型 T はトレイト Ord を実装していること</li>
  <li>BinaryHeap&lt;T&gt; は大きな値ほど優先順位が高い</li>
  <li>これを「最大ヒープ (max heap)」という</li>
  <li>逆に、小さな値ほど優先順位が高いヒープを「最小ヒープ (min heap)」という</li>
  <li>自分で Ord を定義することで最小ヒープを実現することができる</li>
  <li>主なメソッド</li>
    <ul>
      <li>fn new() -&gt; BinaryHeap&lt;T&gt;, BinaryHeap の生成</li>
      <li>fn peek(&amp;self) -> Option&lt;&amp;T&gt;, 最大要素の参照を取得</li>
      <li>fn pop(&amp;mut self) -&gt; Option&lt;T&gt;, 最大要素の取得</li>
      <li>fn push(&amp;mut self, item: T), 要素の追加</li>
      <li>fn len(&amp;self) -&gt; usize, 要素数を返す</li>
      <li>fn is_empty(&amp;self) -&gt; bool, ヒープが空ならば true を返す</li>
      <li>fn clear(&amp;mut self), ヒープを空にする</li>
    </ul>
</ul>
<pre class="list">
リスト : BinaryHeap の簡単な使用例

use std::collections::BinaryHeap;
use std::cmp::Ordering;

#[derive(Debug, PartialEq, Eq)]
struct Foo {
    num: i32
}

impl Ord for Foo {
    fn cmp(&amp;self, other: &amp;Foo) -&gt; Ordering {
        self.num.cmp(&amp;other.num).reverse()
    }
}

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Foo) -> Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

fn main() {
    let a = [5,6,4,3,7,8,2,1,9];
    let mut q1 = BinaryHeap::new();
    let mut q2 = BinaryHeap::new();
    for x in &amp;a {
        q1.push(*x);
        q2.push( Foo { num: *x });
    }
    while !q1.is_empty() {
        println!("{:?}", q1.pop());
    }
    while !q2.is_empty() {
        println!("{:?}", q2.pop());
    }
}
</pre>
<pre>
Some(9)
Some(8)
Some(7)
Some(6)
Some(5)
Some(4)
Some(3)
Some(2)
Some(1)
Some(Foo { num: 1 })
Some(Foo { num: 2 })
Some(Foo { num: 3 })
Some(Foo { num: 4 })
Some(Foo { num: 5 })
Some(Foo { num: 6 })
Some(Foo { num: 7 })
Some(Foo { num: 8 })
Some(Foo { num: 9 })
</pre>
<ul>
  <li>Ord を定義するときは PartialOrd の定義も必要になる</li>
  <li>PartialOrd を定義するときは Eq の定義も必要になる</li>
  <li>Eq を定義するときは PartialEq の定義も必要になる</li>
  <li>けっきょく、Ord, PartialOrd, Eq, PartialEq の 4 つを定義しないとダメ</li>
  <li>等値関係が標準のままでよければ、Eq と PartialEq は derive で OK</li>
  <li>Ord で必要なメソッドは cmp() だけ</li>
<pre class="item">
fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering
</pre>
  <li>std::cmp::Ordering は次のように定義されている</li>
<pre class="item">
pub enum Ordering { Less, Equal, Greater }
</pre>
  <li>メソッド reverse() は Less を Greater に、Greater を Less に変換する</li>
  <li>Foo の場合、フィールド変数 num (整数値) を cmp() で比較し、結果を reverse() で変換すれば最小ヒープになる</li>
  <li>PartialOrd で必要なメソッドは partial_cmp() だけ</li>
<pre class="item">
fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;
</pre>
  <li>partial_cmp() は Ord のメソッド cmp() の返り値を Some() に包んで返すだけ</li>
</pre>
</ul>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>