<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881816</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>簡単なプログラム</h3>
<h4 id="chap19">●乱数</h4>
<p> 「線形合同法」による簡単な疑似乱数生成器です。アルゴリズムの詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo18.html">乱数</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : 乱数 (線形合同法)

// 乱数生成器
struct Rand {
    seed: u32
}

// 乱数の最大値
const RAND_MAX: u32 = 0xffff_ffff;

// メソッドの実装
impl Rand {
    // 生成
    fn new(x: u32) -&gt; Rand {
        Rand { seed: x }
    }

    // 整数 (0 - RAND_MAX) の一様乱数
    fn rand(&amp;mut self) -&gt; u32 {
        let x = self.seed as u64;
        self.seed = ((69069 * x + 1) &amp; RAND_MAX as u64) as u32;
        self.seed
    }

    // 実数 (0.0 以上 1.0 未満) の一様乱数
    fn random(&amp;mut self) -&gt; f64 {
        (1.0 / (RAND_MAX as f64 + 1.0)) * self.rand() as f64

    }

    // 配列をシャッフルする (Fisher-Yates shuffle アルゴリズム)
    fn shuffle&lt;T&gt;(&amp;mut self, buff: &amp;mut [T]) {
        for i in 0 .. buff.len() {
            let j = (self.random() * buff.len() as f64) as usize;
            buff.swap(i, j);
        }
    }
}

fn main() {
    let mut rng = Rand::new(1);
    for _ in 0..8 {
        println!("{}", rng.rand());
    }
    for _ in 0..8 {
        println!("{}", rng.random());
    }
    let mut buff = [0,1,2,3,4,5,6,7,8, 9];
    rng.shuffle(&amp;mut buff);
    println!("{:?}", buff);
    rng.shuffle(&amp;mut buff);
    println!("{:?}", buff);
    rng.shuffle(&amp;mut buff);
    println!("{:?}", buff);
}
</pre>
<ul>
  <li>配列やベクタの要素はメソッド swap() で交換できる</li>
</ul>
<pre>
69070
475628535
3277404108
772999773
3877832058
3821835443
1662200408
2044158073
0.8821929632686079
0.1857799997087568
0.6387998843565583
0.2692126233596355
0.24668282689526677
0.1361708294134587
0.18301675841212273
0.7844867671374232
[8, 0, 6, 3, 5, 9, 7, 2, 1, 4]
[7, 8, 4, 6, 5, 1, 2, 3, 0, 9]
[1, 3, 8, 7, 6, 4, 9, 0, 5, 2]
</pre>
<h4 id="chap20">●ソート</h4>
<p> 簡単なソート (バブルソート、選択ソート、挿入ソート) です。アルゴリズムの詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo06.html">整列 [1]</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : 簡単なソート (遅いソート)

// バブルソート
fn buble_sort&lt;T: Ord&gt;(buff: &amp;mut [T]) {
    for i in 0..buff.len() {
        let mut j = buff.len() - 1;
        while j &gt; i {
            if buff[j] &lt; buff[j - 1] {
                buff.swap(j, j - 1);
            }
            j -= 1;
        }
    }
}

// 選択ソート
fn select_sort&lt;T: Ord&gt;(buff: &amp;mut [T]) {
    for i in 0 .. buff.len() - 1 {
        let mut n = i;
        for j in i + 1 .. buff.len() {
            if buff[j] &lt; buff[n] {
                n = j;
            }
        }
        buff.swap(i, n);
    }
}
</pre>
<ul>
  <li>トレイト Ord を実装したデータ型は等値演算子と比較演算子を使用することができる</li>
</ul>
<pre class="list">
リスト : 単純挿入ソート

fn insert_sort&lt;T: Ord&gt;(buff: &amp;mut [T]) {
    for i in 1 .. buff.len() {
        let mut j = i;
        while j &gt; 0 &amp;&amp; buff[j] &lt; buff[j - 1] {
            buff.swap(j, j - 1);    // ちょっと遅くなる
            j -= 1;
        }
    }
}

fn insert_sort1&lt;T: Ord + Copy&gt;(buff: &amp;mut [T]) {
    for i in 1 .. buff.len() {
        let mut j = i;
        let temp = buff[i];
        while j &gt; 0 &amp;&amp; temp &lt; buff[j - 1] {
            buff[j] = buff[j - 1];  // このほうが速くなるが Copy が必要になる
            j -= 1;
        }
        buff[j] = temp;
    }
}
</pre>
<ul>
  <li>Rust の場合、配列の添え字は usize になるので、添え字 &gt;= 0 は意味がない</li>
  <li>単純挿入ソートの場合、swap() で要素を交換するよりも、後ろに移動させるほうが少し速くなる</li>
  <li>ただし、型パラメータ T の制約に Copy トレイトが必要になる</li>
</ul>
<pre class="list">
リスト : 簡単なテスト

fn test(func: fn(&amp;mut [i32]) -&gt; (), rng: &amp;mut Rand) {
    let mut buff: [i32; 20] = [0; 20];
    for i in 0 .. 20 { buff[i] = i as i32; }
    rng.shuffle(&amp;mut buff);
    println!("{:?}", buff);
    func(&amp;mut buff);
    println!("{:?}", buff);
    buff.reverse();
    println!("{:?}", buff);
    func(&amp;mut buff);
    println!("{:?}", buff);
    func(&amp;mut buff);
    println!("{:?}", buff);
}

fn main() {
    let mut rng = Rand::new(1);
    println!("----- buble sort -----");
    test(buble_sort, &amp;mut rng);
    println!("----- select sort -----");
    test(select_sort, &amp;mut rng);
    println!("----- insert sort -----");
    test(insert_sort, &amp;mut rng);
    test(insert_sort1, &amp;mut rng);
}
</pre>
<pre>
----- buble sort -----
[0, 2, 13, 14, 10, 8, 7, 19, 5, 3, 12, 17, 4, 15, 16, 1, 6, 11, 18, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
----- select sort -----
[4, 13, 11, 6, 18, 0, 12, 16, 19, 2, 14, 8, 15, 9, 3, 17, 5, 10, 1, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
----- insert sort -----
[14, 11, 6, 4, 7, 8, 15, 9, 13, 5, 2, 19, 17, 12, 18, 16, 10, 3, 0, 1]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 6, 16, 15, 7, 4, 8, 10, 14, 18, 2, 12, 17, 9, 5, 13, 19, 11, 3]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</pre>
<h4 id="chap21">●クイックソート</h4>
<p> 単純なクイックソートです。アルゴリズムの詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo06.html">整列 [1]</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : クイックソート

fn quick_sort&lt;T: Ord + Copy&gt;(buff: &amp;mut[T]) {
    if buff.len() &lt; 2 { return; }
    let pivot = buff[buff.len() / 2];
    let mut i = 0;
    let mut j = buff.len() - 1;
    loop {
        while pivot &gt; buff[i] { i += 1; }
        while pivot &lt; buff[j] { j -= 1; }
        if i &gt;= j { break; }
        buff.swap(i, j);
        i += 1;
        j -= 1;
    }
    if i &gt; 0 { quick_sort(&amp;mut buff[.. i]); }
    if j &lt; buff.len() - 1 { quick_sort(&amp;mut buff[j + 1 ..]); }
}

fn main() {
    let mut rng = Rand::new(1);
    //
    // 省略
    //
    println!("----- quick sort -----");
    test(quick_sort, &amp;mut rng);
}
</pre>
<pre>
----- quick sort -----
[1, 2, 12, 13, 16, 18, 3, 14, 0, 7, 19, 4, 17, 6, 11, 10, 8, 9, 5, 15]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</pre>
<h4 id="chap22">●クイックソート (改)</h4>
<p> クイックソートの実行時間は、データ数を N とすると平均して N * log<sub>2</sub> N に比例します。ところが、枢軸の選び方によっては、最悪で N の 2 乗に比例するところまで劣化します。つまり、バブルソートや挿入ソートと同じくらい遅くなってしまうのです。たとえば、配列の先頭要素を枢軸として選ぶ場合、配列の要素が昇順または降順に並んでいると最悪の結果になります。
</p>
<p> このため、クイックソートをプログラムする場合、枢軸の選び方を工夫するのが一般的です。たとえば、データの中からいくつかの要素を選び、その中で中間の値を持つ要素を枢軸に選びます。たくさんの要素を選ぶとそれだけ最悪の枢軸を選ぶ危険性は減少しますが、中間の値を選ぶのに時間がかかってしまいます。実際には、3 つから 5 つの要素を選んで、その中で中間の値を枢軸とする場合が多いようです。
</p>
<p> 最後に、要素数が少なくなったらクイックソートから挿入ソートに切り替えます。データ数が少ない場合は、クイックソートよりも単純なソートアルゴリズムの方が高速です。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : クイックソート (改)

const LIMIT: usize = 16;

// 枢軸の選択
fn select_pivot&lt;T: Ord + Copy&gt;(buff: &amp;[T]) -&gt; T {
    let a = buff[0];
    let b = buff[buff.len() / 2];
    let c = buff[buff.len() - 1];
    if a &lt; b {
        if b &lt; c {
            b    // a &lt; b &lt; c
        } else if a &lt; c {
            c    // a &lt; c &lt; b
        } else {
            a    // c &lt; a &lt; b
        }
    } else {
        if a &lt; c {
            a    // b &lt; a &lt; c
        } else if b &lt; c {
            c    // b &lt; c &lt; a
        } else {
            b    // c &lt; b &lt; a
        }
    }
}

// クイックソートの改良
fn quick_sort1&lt;T: Ord + Copy&gt;(buff: &amp;mut[T]) {
    if buff.len() &lt;= LIMIT {
        insert_sort1(buff);
        return;
    }
    let pivot = select_pivot(buff);
    let mut i = 0;
    let mut j = buff.len() - 1;
    loop {
        while pivot &gt; buff[i] { i += 1; }
        while pivot &lt; buff[j] { j -= 1; }
        if i &gt;= j { break; }
        buff.swap(i, j);
        i += 1;
        j -= 1;
    }
    if i &gt; 0 { quick_sort1(&amp;mut buff[.. i]); }
    if j &lt; buff.len() - 1 { quick_sort1(&amp;mut buff[j + 1 ..]); }
}
</pre>
<pre class="list">
リスト : 簡単なテスト

fn is_sorted(buff: &amp;[i32]) -&gt; bool {
    for i in 1 .. buff.len() {
        if buff[i] &lt; buff[i - 1] { return false; }
    }
    true
}

fn test1(func: fn(&amp;mut [i32]) -&gt; (), rng: &amp;mut Rand) {
    let mut buff: [i32; 10000] = [0; 10000];
    for i in 0 .. 10000 { buff[i] = i as i32; }
    rng.shuffle(&amp;mut buff);
    func(&amp;mut buff);
    println!("{}", is_sorted(&amp;buff));
    buff.reverse();
    func(&amp;mut buff);
    println!("{}", is_sorted(&amp;buff));
    func(&amp;mut buff);
    println!("{}", is_sorted(&amp;buff));
}

fn main() {
    let mut rng = Rand::new(1);
    //
    // 省略
    //
    println!("----- quick sort1 -----");
    test(quick_sort1, &amp;mut rng);
    test1(quick_sort1, &amp;mut rng);
}
</pre>
<pre>
----- quick sort1 -----
[3, 6, 10, 0, 7, 19, 2, 11, 18, 5, 17, 13, 9, 12, 8, 4, 1, 14, 15, 16]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
true
true
true
</pre>
<h4 id="chap23">●マージソート</h4>
<p> 単純なマージソートです。アルゴリズムの詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo07.html">整列 [2]</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : マージソート

fn merge_sort&lt;T: Ord + Copy&gt;(buff: &amp;mut [T]) {
    if buff.len() &lt; 2 {
         return;
    } else if buff.len() == 2 {
        if buff[0] &gt; buff[1] { buff.swap(0, 1); }
    } else {
        let mid = buff.len() / 2;
        merge_sort(&amp;mut buff[.. mid]);
        merge_sort(&amp;mut buff[mid ..]);
        // 前半部分を work に退避
        let mut work: Vec&lt;T&gt; = Vec::with_capacity(mid);
        for i in 0 .. mid { work.push(buff[i]); }
        let mut i = 0;
        let mut j = mid;
        let mut k = 0;
        while i &lt; mid &amp;&amp; j &lt; buff.len() {
            if work[i] &lt;= buff[j] {
                buff[k] = work[i];
                i += 1;
            } else {
                buff[k] = buff[j];
                j += 1;
            }
            k += 1;
        }
        while i &lt; mid {
            buff[k] = work[i];
            i += 1;
            k += 1;            
        }
    }
}

// 簡単なテスト
fn main() {
    let mut rng = Rand::new(1);
    //
    // 省略
    //
    println!("----- merge sort -----");
    test(merge_sort, &amp;mut rng);
    test1(merge_sort, &amp;mut rng);
}
</pre>
<pre>
----- merge sort -----
[9, 4, 0, 19, 5, 8, 16, 14, 18, 3, 10, 17, 15, 2, 11, 6, 7, 1, 13, 12]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
true
true
true
</pre>
<h4 id="chap24">●プライオリティキュー</h4>
<p> 簡単な例題として、「ヒープ (heap)」を使って「優先度つき待ち行列 (priority queue)」を作ってみましょう。この場合のヒープは「半順序木 (partial ordered tree)」を配列で実現したデータ構造です。詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo03.html">二分木とヒープ</a> をお読みください。
</p>
<p> 一般に、キューは先入れ先出し (FIFO : first-in, first-out) のデータ構造です。キューからデータを取り出すときは、先に挿入されたデータから取り出されます。これに対し、優先度つき待ち行列は、データに優先度をつけておいて、優先度の高いデータから取り出していきます。優先度つき待ち行列は、優先度を基準にヒープを構築することで実現できます。
</p>
<p> なお、Rust の標準ライブラリには BinaryHeap が用意されているので、私たちがプライオリティキューを自作する必要はありませんが、Rust のお勉強ということで簡単なプログラムを作ってみましょう。
</p>
<pre class="list">
リスト : プライオリティキュー

struct PriorityQueue&lt;T&gt; {
    buff: Vec&lt;T&gt;
}

impl &lt;T: Ord&gt; PriorityQueue&lt;T&gt; {
    // 生成
    fn new() -&gt; PriorityQueue&lt;T&gt; {
        PriorityQueue { buff: vec![] }
    }

    // 挿入
    fn push(&amp;mut self, x: T) {
        self.buff.push(x);
        let mut n = self.buff.len() - 1;
        loop {
            if n == 0 { break; }
            let p = (n - 1) / 2;
            if self.buff[p] &lt;= self.buff[n] { break; }
            self.buff.swap(p, n);
            n = p;
        }
    }

    // 取得
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.buff.len() == 0 { return None; }
        let k = self.buff.len() - 1;
        let mut n = 0;
        self.buff.swap(n, k);   // 先頭要素を最後尾に移動
        loop {
            let mut c = 2 * n + 1;
            if c &gt;= k { break; }
            if c + 1 &lt; k {
                if self.buff[c] &gt; self.buff[c + 1] { c += 1; }
            }
            if self.buff[n] &lt;= self.buff[c] { break; }
            self.buff.swap(n, c);
            n = c;
        }
        self.buff.pop()
    }

    // 先頭データを参照
    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.buff.len() &gt; 0 {
            Some(&amp;self.buff[0])
        } else {
            None
        }
    }

    // 空か？
    fn is_empty(&amp;self) -&gt; bool {
        self.buff.len() == 0
    }
}

fn main() {
    let mut q = PriorityQueue::new();
    for x in vec![5,6,4,7,3,8,2,9,1,0] {
        q.push(x);
    }
    while !q.is_empty() {
        println!("{}", q.peek().unwrap());
        q.pop();
    }
}
</pre>
<ul>
  <li>Option のメソッド unwrap() は Some() の値を取り出す</li>
  <li>None の場合はエラーを送出する</li>
</ul>
<pre>
0
1
2
3
4
5
6
7
8
9
</pre>
<h4 id="chap25">●ヒープソート</h4>
<p> ヒープを使ったソートも優秀なアルゴリズムの一つです。実行時間は N * log<sub>2</sub> N に比例しますが、平均するとクイックソートよりも遅くなります。しかし、クイックソートとは違って、データの種類によって性能が劣化することはありません。アルゴリズムの詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo07.html">整列 [2]</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : ヒープソート

fn heap_sort&lt;T: Ord + Copy&gt;(buff: &amp;mut [T]) {
    // ヒープの構成
    let mut i = buff.len() / 2;
    while i &gt; 0 {
        let mut n = i - 1;
        let x = buff[n];
        loop {
            let mut c = 2 * n + 1;
            if c &gt;= buff.len() { break; }
            if c + 1 &lt; buff.len() &amp;&amp; buff[c] &lt; buff[c + 1] { c += 1; }
            if x &gt;= buff[c] { break; }
            buff[n] = buff[c];
            n = c;
        }
        buff[n] = x;
        i -= 1;
    }
    // 最大値を取り出す
    i = buff.len();
    while i &gt; 0 {
        let x = buff[i - 1];
        buff[i - 1] = buff[0];
        let mut n = 0;
        loop {
            let mut c = 2 * n + 1;
            if c &gt;= i - 1 { break; }
            if c + 1 &lt; i - 1 &amp;&amp; buff[c] &lt; buff[c + 1] { c += 1; }
            if x &gt;= buff[c] { break; }
            buff[n] = buff[c];
            n = c;
        }
        buff[n] = x;
        i -= 1;
    }
}

fn main() {
    let mut rng = Rand::new(1);
    //
    // 省略
    //
    println!("----- heap sort -----");
    test(heap_sort, &amp;mut rng);
    test1(heap_sort, &amp;mut rng);
}
</pre>
<p> 前半部分でヒープを構築します。親子関係がプライオリティキューと逆になっていることに注意してください。つまり、親が子より大きいという関係を満たすようにヒープを構築します。したがって、配列の先頭 (buff[0]) が最大値になります。
</p>
<p> 後半部分で、最大値を取り出してヒープを再構築します。配列の先頭には最大値がセットされているので、これを配列の最後尾のデータと交換します。あとは、そのデータを除いた範囲でヒープを再構築すれば、その次に大きいデータを求めることができます。これを繰り返すことで、大きいデータが配列の後ろから整列していくことになります。
</p>
<pre>
----- heap sort -----
[12, 15, 7, 11, 18, 3, 16, 9, 0, 8, 4, 6, 14, 19, 1, 17, 5, 13, 10, 2]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
true
true
true
</pre>
<h4 id="chap26">●フィボナッチ数</h4>
<p> フィボナッチ数を生成するイテレータです。フィボナッチ数の性質は拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/fibo.html">フィボナッチ数</a> で簡単に説明しています。興味のある方はお読みくださいませ。
</p>
<pre class="list">
リスト : フィボナッチ数

struct Fibonacci {
    a: i64, b: i64
}

// 生成
impl Fibonacci {
    fn new() -&gt; Fibonacci {
        Fibonacci { a: 0, b: 1 }
    }
}

// イテレータの実装
impl Iterator for Fibonacci {
    type Item = i64;
    fn next(&amp;mut self) -&gt; Option&lt;i64&gt; {
        let x = self.a;
        self.a = self.b;
        self.b += x;
        Some(x)
    }
}

fn main() {
    let mut fibo = Fibonacci::new();
    // F40 から 10 個のフィボナッチ数を求める
    let xs: Vec&lt;i64&gt; = fibo.skip(40).take(10).collect();
    println!("{:?}", xs);
    fibo = Fibonacci::new();
    // 300,000,000 未満で最も大きいフィボナッチ数 Fn を求める
    println!("{}", fibo.take_while(|&amp;x| x &lt; 300_000_000).last().unwrap());
    // 300,000,000 未満のフィボナッチ数の総和を求める
    fibo = Fibonacci::new();
    let a: i64 = fibo.take_while(|&amp;x| x &lt; 300_000_000).sum();
    println!("{}", a);
    // 300,000,000 未満のフィボナッチ数の偶数項の総和を求める
    fibo = Fibonacci::new();
    let b: i64 = fibo.filter(|&amp;x| x % 2 == 0).take_while(|&amp;x| x &lt; 300_000_000).sum();
    println!("{}", b);
}
</pre>
<ul>
  <li>skip(n) はイテレータから n 個の要素を取り除く</li>
  <li>take(n) はイテレータから n 個の要素を取り出す</li>
  <li>skip_while(pred) は述語 pred が真を返す要素が続く間、それらを取り除く</li>
  <li>take_while(pred) は述語 pred が真を返す要素が続く間、それらを取り出す</li>
    <ul>
      <li>述語 pred(x) の引数 x には要素への参照が渡される</li>
      <li>ラムダの仮引数 |&amp;x| ではパターンマッチで要素の値を x にセットしている</li>
    </ul>
  <li>last() はイテレータの最後の要素を Option に格納して返す</li>
  <li>sum() はイテレータの要素の合計値を求める</li>
</ul>
<pre>
[102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]
267914296
701408732
350704366
</pre>
<h4 id="chap27">●ハミング数</h4>
<p> 簡単な例題として「ハミングの問題」を解いてみましょう。
</p>
<div class="question">
<b>[ハミングの問題]</b>
<p> 7 以上の素数で割り切れない正の整数を小さい順に N 個求めよ
</p>
参考文献 : 奥村晴彦,『Ｃ言語による最新アルゴリズム事典』, 技術評論社, 1991 (361 ページより引用)
</div>
<p> 7 以上の素数で割り切れない正の整数は、素因子が 2, 3, 5 しかない自然数のことです。これを「ハミング数 (Hamming Numbers)」といいます。ハミング数は素因数分解したとき、2<sup>i</sup> * 3<sup>j</sup> * 5<sup>k</sup> (i, j, k &gt;= 0) の形式になります。たとえば、100 以下のハミング数は次のようになります。
</p>
<pre class="item">
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 
54, 60, 64, 72, 75, 80, 81, 90, 96, 100
</pre>
<p> 参考文献のプログラムを Rust のイテレータを使って書き換えると次のようになります。
</p>
<pre class="list">
リスト : ハミング数

// ハミング数
struct HammingNumbers {
    buff: Vec&lt;i64&gt;,
    m2: i64, m3: i64, m5: i64,
    i2: usize, i3: usize, i5: usize
}

// 生成
impl HammingNumbers {
    fn new() -&gt; HammingNumbers {
        HammingNumbers {
            buff: vec![],
            m2: 1, m3: 1, m5: 1,
            i2: 0, i3: 0, i5: 0
        }
    }
}

// イテレータの実装
impl Iterator for HammingNumbers {
    type Item = i64;
    fn next(&amp;mut self) -&gt; Option&lt;i64&gt; {
        let m = std::cmp::min(std::cmp::min(self.m2, self.m3), self.m5);
        self.buff.push(m);
        while self.m2 &lt;= m {
            self.m2 = self.buff[self.i2] * 2;
            self.i2 += 1;
        }
        while self.m3 &lt;= m {
            self.m3 = self.buff[self.i3] * 3;
            self.i3 += 1;
        }
        while self.m5 &lt;= m {
            self.m5 = self.buff[self.i5] * 5;
            self.i5 += 1;
        }
        Some(m)
    }
}

fn main() {
    // ハミング数
    let hs = HammingNumbers::new();
    println!("{:?}", hs.take(100).collect::&lt;Vec&lt;i64&gt;&gt;());
}
</pre>
<pre>
[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 
96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 
324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 
800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536]
</pre>
<h4 id="chap28">●エラトステネスの篩</h4>
<p> 「エラトステネスの篩」で素数を求めるプログラムです。アルゴリズムの説明は拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/prime.html">素数</a> をお読みください。
</p>
<pre class="list">
リスト : エラトステネスの篩

fn sieve(n: usize) -&gt; Vec&lt;usize&gt; {
    let mut ps: Vec&lt;usize&gt; = vec![2];
    let mut xs: Vec&lt;bool&gt; = vec![true; n / 2];
    let mut x = 3;
    while x * x &lt;= n {
        let mut y = (x - 3) / 2;
        if xs[y] {
            ps.push(x);
            y += x;
            while y &lt; xs.len() {
                xs[y] = false;
                y += x;
            }
        }
        x += 2;
    }
    while x &lt;= n {
        if xs[(x - 3) / 2] { ps.push(x); }
        x += 2;
    }
    ps
}

// その２ (速度は sieve() よりも遅い)
fn sieve2(n: i32) -&gt; Vec&lt;i32&gt; {
    let mut buff: Vec&lt;i32&gt; = (2.. n + 1).collect();
    let mut ps: Vec&lt;i32&gt; = vec![];
    loop  {
        let p = buff[0];
        ps.push(p);
        if p * p &gt; n { break; }
        buff = buff.into_iter().filter(|x| x % p != 0).collect();
    }
    ps.append(&amp;mut buff);
    ps
}

fn main() {
    // 素数
    println!("{:?}", sieve(100));
    println!("{:?}", sieve(1000));
    // println!("{:?}", sieve2(100));
    // println!("{:?}", sieve2(1000));
}
</pre>
<pre>
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 
127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 
257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 
401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 
563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 
709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 
877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
</pre>

<h4 id="chap29">●素数 (イテレータ)</h4>
<p> 素数列を生成するイテレータです。
</p>
<pre class="list">
リスト : 素数のイテレータ

struct Primes {
    primes: Vec&lt;i32&gt;,
    idx: usize
}

// メソッド
impl Primes {
    fn new() -&gt; Primes {
        Primes { primes: vec![2, 3], idx: 0 }
    }
    // 素数列をリセットする
    fn reset(&amp;mut self) { self.idx = 0; }
}

// 素数列を生成するイテレータ
impl Iterator for Primes {
    type Item = i32;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.idx &lt; self.primes.len() {
            self.idx += 1;
            Some(self.primes[self.idx - 1])
        } else {
            let mut n = self.primes[self.primes.len() - 1] + 2;
            loop {
                if self.primes.iter().take_while(|&amp;&amp;x| x * x &lt;= n).all(|&amp;x| n % x != 0) {
                    self.primes.push(n);
                    self.idx += 1;
                    return Some(n);
                }
                n += 2;
            }
        }
    }
}

fn main() {
   let mut ps = Primes::new();
    for _ in 0 .. 25 {
        print!("{} ", ps.next().unwrap());
    }
    println!("");
    ps.reset();
    for _ in 0 .. 100 {
        print!("{} ", ps.next().unwrap());
    }
    println!("");
}
</pre>
<ul>
  <li>メソッド all(pred) はイテレータの要素を述語 pred に適用し、すべて真ならば真を返す</li>
  <li>メソッド any(pred) はイテレータの要素を述語 pred に適用し、すべて偽ならば偽を返す</li>
</ul>
<pre>
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157
163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331
337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 
521 523 541
</pre>
<h4 id="chap30">●双子素数 (イテレータ)</h4>
<p> 差が 2 である素数の組を「双子素数 (twin prime)」といいます。Primes を使うと、双子素数を出力するイテレータを簡単に作ることができます。
</p>
<pre class="list">
リスト : 双子素数

struct TwinPrimes {
    ps: Primes,
    prev: i32
}

// メソッド
impl TwinPrimes {
    fn new() -&gt; TwinPrimes {
        TwinPrimes { ps: Primes::new(), prev: 1 }
    }
    fn reset(&amp;mut self) {
        self.ps.reset();
        self.prev = 1;
    }
}

// イテレータの実装
impl Iterator for TwinPrimes {
    type Item = (i32, i32);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            let p = self.ps.next().unwrap();
            if p - self.prev == 2 {
                let q = self.prev;
                self.prev = p;
                return Some((q, p));
            }
            self.prev = p;
        }
    }
}

fn main() {
    let mut twinps = TwinPrimes::new();
    for _ in 0 .. 100 {
        print!("{:?}", twinps.next().unwrap());
    }
    println!("");
    twinps.reset();
    // 3,000,000 以下で最大の双子素数を求める
    println!("{:?}", twinps.take_while(|x| x.1 &lt; 3_000_000).last().unwrap());
}
</pre>
<pre>
(3, 5)(5, 7)(11, 13)(17, 19)(29, 31)(41, 43)(59, 61)(71, 73)(101, 103)(107, 109)(137, 139)(149, 151)(179, 181)(191, 193)
(197, 199)(227, 229)(239, 241)(269, 271)(281, 283)(311, 313)(347, 349)(419, 421)(431, 433)(461, 463)(521, 523)(569, 571)
(599, 601)(617, 619)(641, 643)(659, 661)(809, 811)(821, 823)(827, 829)(857, 859)(881, 883)(1019, 1021)(1031, 1033)
(1049, 1051)(1061, 1063)(1091, 1093)(1151, 1153)(1229, 1231)(1277, 1279)(1289, 1291)(1301, 1303)(1319, 1321)(1427, 1429)
(1451, 1453)(1481, 1483)(1487, 1489)(1607, 1609)(1619, 1621)(1667, 1669)(1697, 1699)(1721, 1723)(1787, 1789)(1871, 1873)
(1877, 1879)(1931, 1933)(1949, 1951)(1997, 1999)(2027, 2029)(2081, 2083)(2087, 2089)(2111, 2113)(2129, 2131)(2141, 2143)
(2237, 2239)(2267, 2269)(2309, 2311)(2339, 2341)(2381, 2383)(2549, 2551)(2591, 2593)(2657, 2659)(2687, 2689)(2711, 2713)
(2729, 2731)(2789, 2791)(2801, 2803)(2969, 2971)(2999, 3001)(3119, 3121)(3167, 3169)(3251, 3253)(3257, 3259)(3299, 3301)
(3329, 3331)(3359, 3361)(3371, 3373)(3389, 3391)(3461, 3463)(3467, 3469)(3527, 3529)(3539, 3541)(3557, 3559)(3581, 3583)
(3671, 3673)(3767, 3769)(3821, 3823)
(2999831, 2999833)
</pre>
<h4 id="chap31">●head と tail</h4>
<p> ファイルの先頭 10 行を表示するプログラムと、ファイルの末尾 10 行を表示するプログラムを作ります。コマンドラインでファイル名が省略された場合は標準入力を使います。なお、Unix 系 OS には同等以上の機能を持つコマンド head と tail があります。
</p>
<pre class="list">
リスト : ファイルの先頭 10 行を表示 (head0.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn head&lt;R: Read&gt;(reader: BufReader&lt;R&gt;) {
    for xs in reader.lines().take(10) {
        println!("{}", xs.unwrap());
    }
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() == 1 {
        head(BufReader::new(io::stdin()));
    } else {
        match File::open(&amp;args[1]) {
            Ok(file) =&gt; head(BufReader::new(file)),
            Err(_) =&gt; println!("{} not found", &amp;args[1])
        }
    }
}
</pre>
<pre class="list">
リスト : ファイルの末尾 10 行を表示 (tail0.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};
use std::collections::VecDeque;

fn tail&lt;R: Read&gt;(reader: BufReader&lt;R&gt;) {
    let mut que: VecDeque&lt;String&gt; = VecDeque::new();
    for xs in reader.lines() {
        if que.len() == 10 { que.pop_front(); }
        que.push_back(xs.unwrap());
    }
    for xs in que.iter() {
        println!("{}", xs);
    }
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() == 1 {
        tail(BufReader::new(io::stdin()));
    } else {
        match File::open(&amp;args[1]) {
            Ok(file) =&gt; tail(BufReader::new(file)),
            Err(_) =&gt; println!("{} not found", &amp;args[1])
        }
    }
}
</pre>
<ul>
  <li>std::collections::VecDeque は「両端キュー (double ended queue: deque)」</li>
  <li>メソッド push_back() で末尾にデータを追加する</li>
  <li>メソッド push_front() で先頭にデータを追加する</li>
  <li>メソッド pop_back() で末尾からデータを取り出す</li>
  <li>メソッド pop_front() で先頭からデータを取り出す</li>
  <li>push_back() と pop_front() を使うとキューとして動作する</li>
  <li>同様のデータ構造に std::collections::LinkedList がある</li>
  <li>Rust の LinkedList は双方向の連結リスト、deque として使用できる</li>
</ul>

<h4 id="chap32">●単語のカウント</h4>
<p> ファイルの文字数 (ファイルサイズ) と行数と単語をカウントするプログラムを作ります。単語は空白文字で区切られた文字列とします。コマンドラインでファイル名が省略された場合は標準入力を使います。なお、Unix 系 OS には同等の機能を持つコマンド wc があります。
</p>
    <pre class="list">
リスト : 単語のカウント (wc0.rc)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn wc&lt;R: Read&gt;(reader: BufReader&lt;R&gt;) {
    let mut word = 0;    // 単語数
    let mut line = 0;    // 行数
    let mut size = 0;    // 文字数
    let mut inword = false;
    for c in reader.bytes() {
        let code = c.unwrap() as char;
        if code.is_whitespace() {
            inword = false;
            if code == '\n' { line += 1; }
        } else if !inword {
            inword = true;
            word += 1;
        }
        size += 1;
    }
    println!("lines: {}, words: {}, chars: {}", line, word, size);
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        wc(BufReader::new(io::stdin()));
    } else {
        match File::open(&amp;args[1]) {
            Ok(file) =&gt; wc(BufReader::new(file)),
            Err(_) =&gt; println!("{} not found", &amp;args[1])
        }
    }
}
</pre>
<ul>
  <li>空白文字のチェックは char のメソッド is_whitespace() を使う</li>
  <li>改行文字までを 1 行とカウントしているので、最後が改行文字で終わっていないと、行数が 1 つ少なくなる</li>
  <li>「仕様」ということにさせてください</li>
  <li>それは許さん！ という方は次のプログラムをお試しください</li>
</ul>
<pre class="list">
リスト : 単語のカウント (wc1.rc)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn wc&lt;R: Read&gt;(mut reader: BufReader&lt;R&gt;) {
    let mut word = 0;    // 単語数
    let mut line = 0;    // 行数
    let mut size = 0;    // 文字数
    let mut buff = String::new();   // バッファ
    loop {
        let n = reader.read_line(&amp;mut buff).unwrap();
        if n == 0 { break; }
        line += 1;
        size += n;
        word += buff.split_whitespace().count();
        buff.clear();
    }
    println!("lines: {}, words: {}, chars: {}", line, word, size);
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        wc(BufReader::new(io::stdin()));
    } else {
        match File::open(&amp;args[1]) {
            Ok(file) =&gt; wc(BufReader::new(file)),
            Err(_) =&gt; println!("{} not found", &amp;args[1])
        }
    }
}
</pre>
<ul>
  <li>BufRead の read_line() は改行文字もバッファ buff に格納する</li>
  <li>String の split_whitespace() は文字列を空白文字で分離する</li>
  <li>返り値は分離した文字列を返すイテレータ</li>
  <li>clear() はバッファ buff を空にする (このときバッファの容量は変化しない)</li>
</ul>
<h4 id="chap33">●文字列の検索</h4>
<p> ファイルから文字列を探索し、見つけたらその行を出力するプログラムを作ります。コマンドラインでファイル名が省略された場合は標準入力を使うものとします。なお、Unix 系 OS には正規表現を使って文字列を検索するコマンド grep があります。
</p>
<pre class="list">
リスト : 文字列の検索 (find0.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn find_string&lt;R: Read&gt;(reader: BufReader&lt;R&gt;, key: &amp;String) {
    let mut n = 1;
    for xs in reader.lines() {
        let s = xs.unwrap();
        match s.find(key) {
            Some(_) =&gt; println!("{}: {}", n, s),
            None =&gt; ()
        }
        n += 1;
    }
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        println!("usage: find0 keyword [file_name]");
    } else if args.len() &lt; 3 {
        find_string(BufReader::new(io::stdin()), &amp;args[1]);
    } else {
        match File::open(&amp;args[2]) {
            Ok(file) =&gt; find_string(BufReader::new(file), &amp;args[1]),
            Err(_) =&gt; println!("{} not found", &amp;args[1])
        }
    }
}
</pre>
<ul>
  <li>文字列や String からキーワード (文字列) を検索する場合はメソッド find(pat) を使う</li>
  <li>引数 pat は文字列や String だけではなく、文字や関数 (ラムダ) も指定できる</li>
  <li>find() は先頭から文字列を検索し、見つけた位置を Option に格納して返す</li>
  <li>末尾から探索する場合は rfind() を使う</li>
</ul>
<h4 id="chap34">●文字の置換</h4>
<p> ファイルを読み込んで、ある特定の文字を他の文字で置換するプログラムを作ります。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。
</p>
<p> コマンドラインの第 1 引数が置換対象となる文字、第 2 引数が置き換える文字とします。これらの引数は文字列で指定することができ、たとえば tr0 abc ABC とすると、a -&gt; A, b -&gt; B, c -&gt; C と置換します。引数の長さが異なる場合は終了するものとします。なお、Unix 系 OS にはもっと多くの機能を持つコマンド tr があります。
</p>
<pre class="list">
リスト : 文字の置換 (tr0.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn tr&lt;R: Read&gt;(reader: BufReader&lt;R&gt;, src: &amp;String, dst: &amp;String) {
    let tbl: Vec&lt;_&gt; = dst.chars().collect();
    for xs in reader.bytes() {
        let c = xs.unwrap() as char;
        match src.find(c) {
            Some(n) =&gt; print!("{}", tbl[n]),
            None =&gt; print!("{}",  c)
        }
    }
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: tr0 old_chars new_chars [file_name]");
    } else if args.len() &lt; 5 {
        if args[1].len() != args[2].len() {
            println!("{} と {} の長さが違います", &amp;args[1], &amp;args[2]);
        } else if args.len() == 3 {
            tr(BufReader::new(io::stdin()), &amp;args[1], &amp;args[2]);
        } else {
            match File::open(&amp;args[3]) {
                Ok(file) =&gt; tr(BufReader::new(file), &amp;args[1], &amp;args[2]),
                Err(_) =&gt; println!("{} not found", &amp;args[3])
            }
        }
    }
}
</pre>
<ul>
  <li>文字列や String は角カッコと添え字で文字にアクセスすることはできない</li>
  <li>文字列や String をベクタに変換するためメソッド chars() を使う</li>
  <li>chars() は要素が char のイテレータを生成する</li>
  <li>イテレータから要素を collect() で集めてベクタにセットする</li>
</ul>

<h4 id="chap35">●文字列の置換</h4>
<p> ファイルを読み込んで、第 1 引数で指定した文字列を、第 2 引数で指定した文字列に置換するプログラムを作ります。コマンドラインでファイル名が省略された場合は標準入出力を使うものとします。なお、Unix 系 OS ではコマンド sed で文字列の置換を行うことができます。
</p>
<pre class="list">
リスト : 文字列の置換 (replace.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufReader};

fn replace_string&lt;R: Read&gt;(reader: BufReader&lt;R&gt;, src: &amp;String, dst: &amp;String) {
    for xs in reader.lines() {
        println!("{}", xs.unwrap().replace(src, dst));
    }
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: replace old_string new_string [file_name]");
    } else if args.len() &lt; 4 {
        replace_string(BufReader::new(io::stdin()), &amp;args[1], &amp;args[2]);
    } else {
        match File::open(&amp;args[3]) {
            Ok(file) =&gt; replace_string(BufReader::new(file), &amp;args[1], &amp;args[2]),
            Err(_) =&gt; println!("{} not found", &amp;args[3])
        }
    }
}
</pre>
<ul>
  <li>メソッド replace(old, new) は old を new にすべて置き換える</li>
  <li>replace() は新しい String を返すことに注意</li>
  <li>置換回数を指定したい場合は replacen(old, new, n) を使う</li>
  <li>n に 1 を指定すると、先頭の old だけが new に置き換えられる</li>
</ul>
<h4 id="chap36">●ファイルの連結</h4>
<p> 簡単な例題として、ファイルを行単位で連結するプログラムを作りましょう。Unix 系 OS には paste というコマンドがありますが、今回作成するプログラムは paste の簡易バージョンで、空白文字を挟んで連結することにします。動作例を図に示します。
</p>
<pre>
$ cat file1.txt
abcde
fghij
klmno
$ cat file2.txt
ABCDE
FGHIJ
KLMNO
12345
$ ./paste0 file1.txt file2.txt
abcde ABCDE
fghij FGHIJ
klmno KLMNO
12345
</pre>
<p> paste0.rs は 2 つのファイル file1.txt と file2.txt の各行を連結して標準出力へ出力します。この場合、2 つのファイルを同時にオープンしなければいけませんが、近代的なプログラミング言語であれば特別なことをしなくても複数のファイルを扱うことができます。
</p>
<pre class="list">
リスト : ファイルを行単位で連結する (paste0.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::error::Error;

// 行の連結
fn paste(fname1: &amp;String, fname2: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd1 = BufReader::new(File::open(fname1)?).lines();
    let mut rd2 = BufReader::new(File::open(fname2)?).lines();
    loop {
        match (rd1.next(), rd2.next()) {
            (Some(xs), Some(ys)) =&gt; println!("{} {}", xs?, ys?),
            (Some(xs), None) =&gt; {
                println!("{}", xs?);
                for ls in rd1 { println!("{}", ls?); };
                break;
            },
            (None, Some(ys)) =&gt; {
                println!("{}", ys?);
                for ls in rd2 { println!("{}", ls?); };
                break;
            },
            (None, None) =&gt; break
        }
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: paste0 file_name1 file_name2");
    } else if args.len() &lt; 4 {
        match paste(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<h4 id="chap37">●ファイルのエントロピー</h4>
<p> ファイルのエントロピーを計算するプログラムです。エントロピーについては拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo31.html">シャノン・ファノ符号とハフマン符号</a> で詳しく説明しています。興味のある方はお読みくださいませ。
</p>
<pre class="list">
リスト : ファイルのエントロピー (entoropy.rs)

use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::error::Error;

// エントロピーの計算
fn entoropy(fname: &amp;String) -&gt; std::io::Result&lt;(f64, f64)&gt; {
    let reader = BufReader::new(File::open(fname)?);
    let mut table: [usize; 256] = [0; 256];
    for c in reader.bytes() {
        table[c? as usize] += 1;
    }
    let total = table.iter().sum::&lt;usize&gt;() as f64;
    let mut e = 0.0;
    for &amp;x in table.iter() {
        if x == 0 { continue; }
        let p = x as f64 / total;
        e += - p * p.log2();
    }
    // エントロピーとファイルサイズの下限値を返す
    Ok((e, e * total / 8.0))
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 2 {
        println!("usage: entoropy file_name");
    } else {
        match entoropy(&amp;args[1]) {
            Ok((e, s)) =&gt; println!("{}, {} bytes", e, s),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<ul>
  <li>p.log2() は log<sub>2</sub> p を計算する</li>
  <li>p.log10() は log<sub>10</sub> p を計算する</li>
  <li>p.ln() は log<sub>e</sub> p を計算する</li>
  <li>p.log(b: f64) は log<sub>b</sub> p を計算する</li>
</ul>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html><!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>