<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881816</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>簡単なプログラム</h3>
<h4 id="chap59">●二分木のイテレータ</h4>
<p> 次は二分木 Tree&lt;T&gt; にイテレータを実装しましょう。値を書き換えることを許すと、大小関係が崩れる場合があるので、mutable な参照を返す iter_mut() は実装しません。immutable な参照を返す iter() と所有権を移動する into_iter() を実装します。
</p>
<p> 最初に immutable な参照を返すイテレータを作ります。次のリストを見てください。
</p>
<pre class="list">
リスト : イテレータの実装 (1)

struct IterTree&lt;'a, T: 'a + Ord&gt; {
    next: Vec&lt;&amp;'a Node&lt;T&gt;&gt;
}

fn next_node&lt;'a, T: Ord&gt;(node: &amp;'a Node&lt;T&gt;, buff: &amp;mut Vec&lt;&amp;'a Node&lt;T&gt;&gt;) {
    buff.push(node);
    node.left.as_ref().map(|node| next_node(node, buff));
}

impl&lt;'a, T: Ord&gt; Iterator for IterTree&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {
        if self.next.len() == 0 {
            None
        } else {
            let node = self.next.pop().unwrap();
            node.right.as_ref().map(|node| {
                next_node(node, &amp;mut self.next);
                &amp;node.item
            })
        }
    }
}
</pre>
<p> イテレータは Node のメソッド foreach() をループに展開することで実現することができます。この場合、自分でスタックを管理する必要があります。スタック (Vec 型) は IntoIterTree のフィールド変数 next に用意します。
</p>
<p> 考え方は簡単です。左部分木をたどるとき、その節をスタックに積んでいきます。左部分木が空の木であれば処理を終了します。このとき、スタックトップの節が、イテレータが指し示す節になります。この処理を関数 next_node() で行っています。
</p>
<p> 次の節に移動するとき、スタックから節を取り出して、その節の右部分木を同様にたどればいいわけです。右部分木が空の場合は、一つ前の節に戻ることになります。これをイテレータのメソッド next() で行います。
</p>
<p> next() の処理は簡単です。スタック next が空の場合は None を返します。そうでなければ、pop() で節を取り出して変数 node にセットします。そして、右部分木をたどるため、node.right に as_ref() と map() を適用して節の参照を取り出し、それとスタックを next_node() に渡して実行します。あとは &amp;node.item を返すだけです。
</p>
<p> 次は所有権を移動するイテレータを作ります。
</p>
<pre class="list">
リスト : イテレータの実装 (2)

struct IterIntoTree&lt;T: Ord&gt; {
    tree: Tree&lt;T&gt;
}

impl&lt;T: Ord&gt; Iterator for IterIntoTree&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tree.remove_min()
    }
}
</pre>
<p> イテレータのフィールド変数 tree に二分木を move します。あとは、next() で remove_min() を呼び出して、格納されているデータを順番に取り出していくだけです。
</p>
<p> 最後にイテレータを生成するメソッドを作ります。
</p>
<pre class="list">
リスト : イテレータの生成

impl&lt;T: Ord&gt; Tree&lt;T&gt; {
    fn iter(&amp;self) -&gt; IterTree&lt;T&gt; {
        let mut buff: Vec&lt;&amp;Node&lt;T&gt;&gt; = vec![];
        self.root.as_ref().map(|node| next_node(node, &amp;mut buff));
        IterTree { next: buff }
    }

    fn into_iter(self) -&gt; IterIntoTree&lt;T&gt; {
        IterIntoTree { tree: self }
    }
}
</pre>
<p> iter() はスタック buff を用意して、next_node() で一番左側の節 (先頭のデータ) までたどり、それを IntoTree の next にセットします。into_iter() は self を IterIntoTree の tree にセットするだけです。
</p>
<p> プログラムはこれで完成です。それでは実行してみましょう。
</p>
<pre class="list">
リスト : 簡単なテスト

fn main() {
    let mut a: Tree&lt;i32&gt; = Tree::new();
    println!("{}", a.is_empty());
    for x in vec![5, 3, 2, 4, 1, 7, 6, 8, 9] {
        a.insert(x);
    }
    println!("{}", a.is_empty());
    for x in 0 .. 11 {
        println!("{}, {}", x, a.contains(x));
    }
    a.foreach(&amp;|x| print!("{} ", x));
    println!("");
    for x in a.iter() {
        print!("{}", x);
    }
    println!("");
    println!("{:?}", a.min());
    println!("{:?}", a.max());
    for x in 1 .. 10 {
        a.remove(x);
        a.foreach(&amp;|x| print!("{} ", x));
        println!("");
    }
    println!("{}", a.is_empty());
    for x in vec![5, 7, 6, 8, 9, 3, 2, 4, 1] {
        a.insert(x);
    }
    while !a.is_empty() {
        println!("{:?}", a.remove_min());
    }
    for x in vec![5, 6, 7, 8, 9, 1, 2, 3, 4] {
        a.insert(x);
    }
    while !a.is_empty() {
        println!("{:?}", a.remove_max());
    }
    for x in vec![9, 8, 7, 6, 5, 4, 3, 2, 1] {
        a.insert(x);
    }
    let b: Vec&lt;i32&gt; = a.into_iter().collect();
    println!("{:?}", b);
}
</pre>
<pre>
true
false
0, false
1, true
2, true
3, true
4, true
5, true
6, true
7, true
8, true
9, true
10, false
1 2 3 4 5 6 7 8 9
123456789
Some(1)
Some(9)
2 3 4 5 6 7 8 9
3 4 5 6 7 8 9
4 5 6 7 8 9
5 6 7 8 9
6 7 8 9
7 8 9
8 9
9

true
Some(1)
Some(2)
Some(3)
Some(4)
Some(5)
Some(6)
Some(7)
Some(8)
Some(9)
Some(9)
Some(8)
Some(7)
Some(6)
Some(5)
Some(4)
Some(3)
Some(2)
Some(1)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
<p> 正常に動作しているようです。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="listb">●プログラムリスト</h4>
<pre class="list">
//
// tree1.rs: 単純な二分木 (Option 版)
//
//           Copyright (C) 2017 Makoto Hiroi
//

// 節
#[derive(Debug)]
struct Node&lt;T : Ord&gt; {
    item:  T,
    left:  Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
    right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

// x と等しい節を探す
fn search_node&lt;T: Ord&gt;(xs: &amp;mut Link&lt;T&gt;, x: T) -&gt; &amp;mut Link&lt;T&gt; {
    match xs {
        &amp;mut Some(ref mut ys) if x != ys.item =&gt; {
            if x &lt; ys.item {
                search_node(&amp;mut ys.left, x)
            } else {
                search_node(&amp;mut ys.right, x)
            }
        },
        _ =&gt; xs
    }
}

// 最小値の節を求める
fn search_min_node&lt;T: Ord&gt;(xs: &amp;mut Link&lt;T&gt;) -&gt; &amp;mut Link&lt;T&gt; {
    match xs {
        &amp;mut Some(ref mut node) if node.left.is_some() =&gt; search_min_node(&amp;mut node.left), 
        _ =&gt; xs
    }
}

// 最大値の節を求める
fn search_max_node&lt;T: Ord&gt;(xs: &amp;mut Link&lt;T&gt;) -&gt; &amp;mut Link&lt;T&gt; {
    match xs {
        &amp;mut Some(ref mut node) if node.right.is_some() =&gt; search_max_node(&amp;mut node.right), 
        _ =&gt; xs,
    }
}

// 節の削除
fn remove_node&lt;T: Ord&gt;(xs: &amp;mut Link&lt;T&gt;) -&gt; Option&lt;T&gt; {
    if let Some(mut boxed_node) = xs.take() {
        match (boxed_node.left.take(), boxed_node.right.take()) {
            (None, None) =&gt; Some(boxed_node.item), 
            (leaf @ Some(_), None) | (None, leaf @ Some(_)) =&gt; {
                *xs = leaf;
                Some(boxed_node.item)
            },
            (left, right) =&gt; {
                boxed_node.left = left;   // 元に戻す
                boxed_node.right = right;
                let result;
                {
                    let node = &amp;mut *boxed_node;
                    let min_node = search_min_node(&amp;mut node.right);
                    std::mem::swap(&amp;mut node.item, &amp;mut min_node.as_mut().unwrap().item);
                    result = remove_node(min_node);
                }
                *xs = Some(boxed_node);
                result
            }
        }
    } else {
        None
    }
}

// 節のメソッド
impl&lt;T: Ord&gt; Node&lt;T&gt; {
    fn new(x: T) -&gt; Node&lt;T&gt; {
        Node { item: x, left: None, right: None }
    }

    // データの挿入
    fn insert(&amp;mut self, x: T) {
        if x == self.item { return; }
        let node = if x &lt; self.item { &amp;mut self.left } else { &amp;mut self.right };
        match node {
            &amp;mut Some(ref mut node1) =&gt; node1.insert(x),
            &amp;mut None =&gt; {
                *node = Some(Box::new(Node::new(x)))
            }
        }
    }

    // データの探索
    fn contains(&amp;self, x: T) -&gt; bool {
        if x == self.item { return true; }
        let node = if x &lt; self.item { &amp;self.left } else { &amp;self.right };
        match node {
            &amp;Some(ref node1) =&gt; node1.contains(x),
            &amp;None =&gt; false
        }
    }

    // 最小値を求める
    fn min(&amp;self) -&gt; &amp;T {
        match self.left {
            None =&gt; &amp;self.item,
            Some(ref node) =&gt; node.min()
        }
    }

    // 最大値を求める
    fn max(&amp;self) -&gt; &amp;T {
        match self.right {
            None =&gt; &amp;self.item,
            Some(ref node) =&gt; node.max()
        }
    }

    // 巡回
    fn foreach(&amp;self, func: &amp;Fn(&amp;T) -&gt; ()) {
        self.left.as_ref().map(|node| node.foreach(func));
        func(&amp;self.item);
        self.right.as_ref().map(|node| node.foreach(func));
    }
}

// 二分木
#[derive(Debug)]
struct Tree&lt;T: Ord&gt; {
    root: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;
}

// イテレータ
struct IterTree&lt;'a, T: 'a + Ord&gt; {
    next: Vec&lt;&amp;'a Node&lt;T&gt;&gt;
}

fn next_node&lt;'a, T: Ord&gt;(node: &amp;'a Node&lt;T&gt;, buff: &amp;mut Vec&lt;&amp;'a Node&lt;T&gt;&gt;) {
    buff.push(node);
    node.left.as_ref().map(|node| next_node(node, buff));
}

impl&lt;'a, T: Ord&gt; Iterator for IterTree&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {
        if self.next.len() == 0 {
            None
        } else {
            let node = self.next.pop().unwrap();
            node.right.as_ref().map(|node| {
                next_node(node, &amp;mut self.next);
                &amp;node.item
            })
        }
    }
}

struct IterIntoTree&lt;T: Ord&gt; {
    tree: Tree&lt;T&gt;
}

impl&lt;T: Ord&gt; Iterator for IterIntoTree&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tree.remove_min()
    }
}

// 二分木のメソッド
impl&lt;T: Ord&gt; Tree&lt;T&gt; {
    fn new() -&gt; Tree&lt;T&gt;{
        Tree { root: None }
    }

    fn insert(&amp;mut self, x: T) {
        if self.root.is_none() {
            self.root = Some(Box::new(Node::new(x)));
        } else {
            self.root.as_mut().map(|node| node.insert(x));
        }
    }

    fn contains(&amp;self, x: T) -&gt; bool {
        self.root.as_ref().map_or_else(|| false, |node| node.contains(x))
    }

    fn min(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.root.as_ref().map(|node| node.min())
    }

    fn max(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.root.as_ref().map(|node| node.max())
    }

    fn remove_min(&amp;mut self) -&gt; Option&lt;T&gt; {
        remove_node(search_min_node(&amp;mut self.root))
    }
    
    fn remove_max(&amp;mut self) -&gt; Option&lt;T&gt; {
        remove_node(search_max_node(&amp;mut self.root))
    }
    
    fn remove(&amp;mut self, x: T) -&gt; Option&lt;T&gt; {
        remove_node(search_node(&amp;mut self.root, x))
    }
    
    fn foreach(&amp;self, func: &amp;Fn(&amp;T) -&gt;()) {
        self.root.as_ref().map(|node| node.foreach(func));
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.root.is_none()
    }

    fn iter(&amp;self) -&gt; IterTree&lt;T&gt; {
        let mut buff: Vec&lt;&amp;Node&lt;T&gt;&gt; = vec![];
        self.root.as_ref().map(|node| next_node(node, &amp;mut buff));
        IterTree { next: buff }
    }

    fn into_iter(self) -&gt; IterIntoTree&lt;T&gt; {
        IterIntoTree { tree: self }
    }
}

// 簡単なテスト
fn main() {
    let mut a: Tree&lt;i32&gt; = Tree::new();
    println!("{}", a.is_empty());
    for x in vec![5, 3, 2, 4, 1, 7, 6, 8, 9] {
        a.insert(x);
    }
    println!("{}", a.is_empty());
    for x in 0 .. 11 {
        println!("{}, {}", x, a.contains(x));
    }
    a.foreach(&amp;|x| print!("{} ", x));
    println!("");
    for x in a.iter() {
        print!("{}", x);
    }
    println!("");
    println!("{:?}", a.min());
    println!("{:?}", a.max());
    for x in 1 .. 10 {
        a.remove(x);
        a.foreach(&amp;|x| print!("{} ", x));
        println!("");
    }
    println!("{}", a.is_empty());
    for x in vec![5, 7, 6, 8, 9, 3, 2, 4, 1] {
        a.insert(x);
    }
    while !a.is_empty() {
        println!("{:?}", a.remove_min());
    }
    for x in vec![5, 6, 7, 8, 9, 1, 2, 3, 4] {
        a.insert(x);
    }
    while !a.is_empty() {
        println!("{:?}", a.remove_max());
    }
    for x in vec![9, 8, 7, 6, 5, 4, 3, 2, 1] {
        a.insert(x);
    }
    let b: Vec&lt;i32&gt; = a.into_iter().collect();
    println!("{:?}", b);
}
</pre>
<hr>
<h4 id="chap60">●カッコ列と二分木</h4>
<p> バランスの取れたカッコ列と二分木は 1 対 1 に対応します。二分木を行きがけ順で巡回するとき、途中の節では左カッコ ( を出力して左右の枝をたどり、葉に到達したら右カッコ ) を出力すると、カッコ列を生成することができます。
</p>
<pre class="list">
リスト : カッコ列と二分木

#[derive(Debug)]
enum Tree {
    Leaf,
    Node(Box&lt;Tree&gt;, Box&lt;Tree&gt;)
}

// カッコ列を二分木に変換
fn kakko_to_tree(ks: &amp;str) -&gt; Tree {
    fn kakko_sub(i: usize, ks: &amp;Vec&lt;char&gt;) -&gt; (Tree, usize) {
        if ks.len() == i {
            (Tree::Leaf, i)
        } else if ks[i] == ')' {
            (Tree::Leaf, i + 1)
        } else {
            let (left, j) = kakko_sub(i + 1, ks);
            let (right, k) = kakko_sub(j, ks);
            (Tree::Node(Box::new(left), Box::new(right)), k)
        }
    }
    let xs: Vec&lt;char&gt; = ks.chars().collect();
    kakko_sub(0, &amp;xs).0
}

// 二分木をカッコ列に変換
fn tree_to_kakko(tree: &amp;Tree) -&gt; String {
    fn tree_sub(tree: &amp;Tree, a: &amp;mut String) {
        match tree {
            &amp;Tree::Leaf =&gt; a.push(')'),
            &amp;Tree::Node(ref left, ref right) =&gt; {
                a.push('(');
                tree_sub(left, a);
                tree_sub(right, a);
            }
        }
    }
    let mut a = String::new();
    tree_sub(tree, &amp;mut a);
    a.pop();
    a
}

fn main() {
    for s in vec!["((()))", "(())()",  "()()()", "()(())", "(()())"] {
        let tree = kakko_to_tree(s);
        print!("{} =&gt; ", s);
        print!("{:?} =&gt; ", tree);
        println!("{}", tree_to_kakko(&amp;tree));
    }
}
</pre>
<pre>
((())) =&gt; Node(Node(Node(Leaf, Leaf), Leaf), Leaf) =&gt; ((()))
(())() =&gt; Node(Node(Leaf, Leaf), Node(Leaf, Leaf)) =&gt; (())()
()()() =&gt; Node(Leaf, Node(Leaf, Node(Leaf, Leaf))) =&gt; ()()()
()(()) =&gt; Node(Leaf, Node(Node(Leaf, Leaf), Leaf)) =&gt; ()(())
(()()) =&gt; Node(Node(Leaf, Node(Leaf, Leaf)), Leaf) =&gt; (()())
</pre>
<p> 関数 tree_to_kakko() の実際の処理は局所関数 tree_sub() で行います。引数が葉 (Leaf) の場合、累積変数 a に右カッコを追加します。引数が節 (Node) の場合、累積変数 a に左カッコを追加します。そして、tree_sub() を再帰呼び出しして左部分木 left をたどり、それから右部分木 right をたどります。ただし、最後に余分な右カッコが付いてくるので、最後の文字を pop() で削除します。
</p>
<p> 二分木の場合、葉 (Leaf) の個数を n とすると、節 (Node) の個数は n - 1 になります。カッコ列と違って Leaf の個数が一つ多くなることに注意してください。
</p>
<p> 関数 kakko_to_tree() も局所関数 kakko_sub() で変換処理を行います。カッコ列 (文字列) はベクタに変換して引数 ks に渡します。ks の i 番目の要素が右カッコの場合は (Leaf, i + 1) を返します。左カッコの場合は、kakko_sub() を再帰呼び出しして左部分木 left を生成し、それから右部分木 right を生成します。あとは Node を生成して k といっしょに返すだけです。ただし、葉に対応する右カッコがひとつ少ないので、引数 i がベクタの終端に到達した場合は Leaf を返すようにします。
</p>
<hr>
<h4 id="chap61">●Four Fours</h4>
<p> Four Four は数字を使ったパズルです。いろいろなルールがあるのですが、今回は簡易ルールで行きましょう。それでは問題です。
</p>
<div class="question">
<b>[問題]</b> Four Fours<br>
<p> 数字 4 を 4 つと＋, －, ×, ÷, （, ） を使って、答えが 1 から 10 になる式を作りなさい。数字は 4 だけではなく、44 や 444 のように合体させてもよい。また、－を符号として使うことは禁止する。
</p>
</div>

<h4>●数式のパターン</h4>
<p> 基本的には、数式を生成して答えをチェックするだけです。Four Fours の場合、4 つの数値に 3 つの演算子しかありませんから、数式のパターンは簡単に求めることができます。数式を二分木で表すと、次に示す 5 つのパターンになります。
</p>
<pre class="fig">
            Ｘ                Ｘ                          Ｘ
          ／  ＼            ／  ＼                      ／  ＼
        ／      ＼        ４      Ｙ                  Ｙ      ４  
      Ｙ          Ｚ            ／  ＼              ／  ＼
    ／  ＼      ／  ＼        ４      Ｚ          Ｚ      ４
  ４     ４   ４      ４            ／  ＼      ／  ＼
                                  ４      ４  ４      ４
          （１）             （２）                    （３）

      Ｘ                   Ｘ
    ／  ＼               ／  ＼
  ４      Ｙ           Ｙ      ４
        ／  ＼       ／  ＼
      Ｚ      ４   ４      Ｚ
    ／  ＼               ／  ＼
  ４      ４           ４      ４
    （４）               （５）

                図：数式のパターン（二分木）
</pre>
<p> X, Y, Z が演算子を表します。これを式で表すと、次のようになります。
</p>
<ol>
  <li>(4 Y 4) X (4 Z 4)</li>
  <li>4 X (4 Y (4 Z 4))</li>
  <li>((4 Z 4) Y 4) X 4</li>
  <li>4 X ((4 Z 4) Y 4)</li>
  <li>(4 Y (4 Z 4)) X 4</li>
</ol>
<p> あとは、X, Y, Z に演算子 +, -, *, / を入れて数式を計算すればいいわけです。Four Fours は数字を合体できるので、数字が 3 つで演算子が 2 つ、数字が 2 つで演算子が 1 つ、というパターンもあります。演算子が 1 つの場合は簡単ですね。演算子が 2 つの場合は、次の式になります。
</p>
<ol>
  <li>(a Y b) X c</li>
  <li>a X (b Y c)</li>
</ol>
<p>a, b, c が数字で X, Y が演算子を表しています。数字は 4 か 44 になります。この場合、a, b, c の組み合わせを生成する必要があります。組み合わせを (a, b, c) で表すと、(4, 4, 44), (4, 44, 4), (44, 4, 4) の 3 通りとなります。これと演算子の組み合わせにより数式を生成して、答えを求めてチェックします。
</p>
<h4>●プログラムの作成</h4>
<p> それではプログラムを作りましょう。今回は浮動小数点数ではなく、以前作成した <a href="rust03.html#chap41">有理数</a> を使います。ratio.rs をライブラリ (クレート) として使用できるように修正します。具体的には公開する名前 (構造体とかメソッドなど) に pub を付けるだけです。詳細は <a href="rust05.html#list60a">プログラムリスト</a> をお読みくださいませ。
</p>
<p> まずは最初に、数式を表す二分木を定義します。
</p>
<pre class="list">
リスト : 数式を表す二分木 (演算子は char で表す)

enum Expr {
    Leaf(Ratio),
    Node(char, Box&lt;Expr&gt;, Box&lt;Expr&gt;)
}

use Expr::*;
</pre>
<p> 数式は列挙型 Expr で表します。Leaf に数値を格納し、Node が節を表します。演算子は文字 '+', '*', '-', '/' で定義します。
</p>
<p> 次は式を計算する関数 calc_expr() を作ります。
</p>
<pre class="list">
リスト : 式の計算

fn calc_expr(expr: &amp;Expr) -&gt; Result&lt;Ratio, ()&gt; {
    match expr {
        &amp;Leaf(n) =&gt; Ok(n),
        &amp;Node(op, ref left, ref right) =&gt; {
            let lv = calc_expr(left)?;
            let rv = calc_expr(right)?;
            match op {
                '+' =&gt; Ok(lv + rv),
                '-' =&gt; Ok(lv - rv),
                '*' =&gt; Ok(lv * rv),
                '/' =&gt; {
                    if rv.numer() == 0 {
                        Err(())
                    } else {
                        Ok(lv / rv)
                    }
                },
                _ =&gt; Err(())
            }
        }
    }
}
</pre>
<p> calc_expr() の返り値の型は Result&lt;Ratio, ()&gt; です。Leaf の場合は数値を Ok に包んで返します。Node の場合、左辺式 left と右辺式 right を calc_expr() で計算して、値を変数 lv, rv にセットします。あとは、演算子 op に従って計算するだけです。徐算の場合、右辺値が 0 であれば Err(()) を返すことに注意してください。。
</p>
<p> 次は式を表示する関数 print_expr() を作ります。
</p>
<pre class="list">
リスト : 式の表示

fn print_expr(expr: &amp;Expr) {
    match expr {
        &amp;Leaf(n) =&gt; print!("{}", n),
        &amp;Node(op, ref left, ref right) =&gt; {
            print!("(");
            print_expr(left);
            print!(" {} ", op);
            print_expr(right);
            print!(")");
        }
    }
}
</pre>
<p> 式の表示は簡単です。Leaf の場合は格納されている数値を表示します。Node の場合、左カッコを表示して、二分木を通りがけ順で巡回して、右カッコを表示するだけです。
</p>
<p> 次は式を生成する関数を作ります。
</p>
<pre class="list">
リスト : 式の生成

fn make_node(op: char, left: Expr, right: Expr) -&gt; Expr {
    Node(op, Box::new(left), Box::new(right))
}

fn make_expr(op1: char, op2: char, op3: char) -&gt; Vec&lt;Expr&gt; {
    let n = Ratio::from_integer(4);
    vec![make_node(op1, make_node(op2, make_node(op3, Leaf(n), Leaf(n)), Leaf(n)), Leaf(n)),
         make_node(op1, make_node(op2, Leaf(n), Leaf(n)), make_node(op3, Leaf(n), Leaf(n))),
         make_node(op1, Leaf(n), make_node(op2, Leaf(n), make_node(op3, Leaf(n), Leaf(n)))),
         make_node(op1, Leaf(n), make_node(op2, make_node(op3, Leaf(n), Leaf(n)), Leaf(n))),
         make_node(op1, make_node(op2, Leaf(n), make_node(op3, Leaf(n), Leaf(n))), Leaf(n))]
}
</pre>
<p> 関数 make_node() は Node を生成します。あとは、make_node() を使って式を二分木として提議するだけです。make_expr() は 3 つの演算子と 4 つの数値、make_expr2() は 2 つの演算子と 3 つの数値、make_expr3() は 1 つの演算子と 2 つの数値の式をベクタに格納して返します。プログラムは簡単なので説明は省略します。詳細は <a href="rust05.html#list60b">プログラムリスト</a> をお読みくださいませ。</p>
<p> 次は式を計算して結果を表示する関数 exec_expr() を作ります。
</p>
<pre class="list">
リスト : 式の評価

fn exec_expr(expr: &amp;Expr) {
    match calc_expr(&amp;expr) {
        Ok(n) =&gt; {
            if n.is_integer() {
                let m = n.to_integer();
                if m &gt; 0 &amp;&amp; m &lt;= 10 {
                    print_expr(&amp;expr);
                    println!(" = {}", m);
                }
            }
        },
        _ =&gt; ()
    }
}
</pre>
<p> calc_expr() で式 expr を計算して、結果が Ok(n) の場合、n が整数で範囲内 (0 &lt; n &lt;= 10) であることを確認します。あとは print_expr() で式を表示するだけです。Err() の場合は何もしません。
</p>
<p> 最後に main() を作ります。
</p>
<pre class="list">
リスト : メイン関数

fn main() {
    let ops = vec!['+', '-', '*', '/'];
    for op1 in &amp;ops {
        for op2 in &amp;ops {
            for op3 in &amp;ops {
                for expr in make_expr(*op1, *op2, *op3) {
                    exec_expr(&amp;expr);
                }
            }
        }
    }
    for op1 in &amp;ops {
        for op2 in &amp;ops {
            for expr in make_expr2(*op1, *op2) {
                exec_expr(&amp;expr);
            }
        }
    }
    for op1 in &amp;ops {
        for expr in make_expr3(*op1) {
            exec_expr(&amp;expr);
        }
    }
}
</pre>
<p> main() は演算子の組み合わせを生成して数式を作り、それを exec_expr() に渡して評価するだけです。
</p>
<h4>●実行結果</h4>
<p> これでプログラムは完成です。さっそく実行してみたところ、全部で 100 通りの式が出力されました。このプログラムは重複解のチェックを行っていないので、多数の式が出力されることに注意してください。実行結果の一部を示します。
</p>
<pre class="item">
((4 - 4) + (4 / 4)) = 1
((4 / 4) + (4 / 4)) = 2
(((4 + 4) + 4) / 4) = 3
(4 + (4 * (4 - 4))) = 4
(((4 * 4) + 4) / 4) = 5
(((4 + 4) / 4) + 4) = 6
(4 + (4 - (4 / 4))) = 7
((4 + 4) + (4 - 4)) = 8
((4 + 4) + (4 / 4)) = 9
((44 - 4) / 4) = 10
</pre>
<p> この中で、10 になる式は (44 - 4) / 4 しかありません。数字 4 を 4 つと＋, －, ×, ÷, ( , ) だけでは、10 になる式を作ることはできないのですね。
</p>
<hr>
<h4 id="list60a">●プログラムリストA</h4>
<pre class="list">
//
// ratio.rs : 簡単な有理数
//
//            Copyright (C) 2017 Makoto Hiroi
//
use std::ops::{Add, Div, Mul, Sub};
use std::fmt;

#[derive(PartialEq, Debug, Copy, Clone)]
pub struct Ratio {
    numerator: i64,   // 分子
    denominator: i64  // 分母
}

// ユークリッドの互除法
fn gcd(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

impl fmt::Display for Ratio {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.denominator == 1 {
            write!(f, "{}", self.numerator)
        } else {
            write!(f, "{}/{}", self.numerator, self.denominator)
        }
    }
}

impl Ratio {
    pub fn new(p: i64, q: i64) -&gt; Ratio {
        if q == 0 { panic!("Ratio: divide by zero"); }
        let g = gcd(p.abs(), q.abs());
        let s = if q &lt; 0 { -1 } else { 1 };
        Ratio { numerator: s * p / g, denominator: s * q / g}
    }

    pub fn from_integer(n: i64) -&gt; Ratio {
        Ratio { numerator: n, denominator: 1 }
    }

    pub fn to_integer(&amp;self) -&gt; i64 {
        self.numerator / self.denominator
    }
    pub fn to_float(&amp;self) -&gt; f64 {
        self.numerator as f64 / self.denominator as f64
    }

    pub fn numer(&amp;self) -&gt; i64 { self.numerator }
    pub fn denom(&amp;self) -&gt; i64 { self.denominator }

    pub fn is_integer(&amp;self) -&gt; bool {
        self.denominator == 1
    }
}

impl Add for Ratio {
    type Output = Ratio;
    fn add(self, other: Ratio) -&gt; Ratio {
        let p = self.numerator * other.denominator + other.numerator * self.denominator;
        let q = self.denominator * other.denominator;
        Ratio::new(p, q)
    }
}

impl Sub for Ratio {
    type Output = Ratio;
    fn sub(self, other: Ratio) -&gt; Ratio {
        let p = self.numerator * other.denominator - other.numerator * self.denominator;
        let q = self.denominator * other.denominator;
        Ratio::new(p, q)
    }
}

impl Mul for Ratio {
    type Output = Ratio;
    fn mul(self, other: Ratio) -&gt; Ratio {
        let p = self.numerator * other.numerator;
        let q = self.denominator * other.denominator;
        Ratio::new(p, q)
    }
}

impl Div for Ratio {
    type Output = Ratio;
    fn div(self, other: Ratio) -&gt; Ratio {
        let p = self.numerator * other.denominator;
        let q = self.denominator * other.numerator;
        Ratio::new(p, q)
    }
}
</pre>
<hr>
<h4 id="list60b">●プログラムリストB</h4>
<pre class="list">
//
// fours.rs : Four Fours
//
//            Copyright (C) 2017 Makoto Hiroi
//
extern crate ratio;
use ratio::Ratio;

// 数式を表す二分木 (演算子は char で表す)
enum Expr {
    Leaf(Ratio),
    Node(char, Box&lt;Expr&gt;, Box&lt;Expr&gt;)
}

use Expr::*;

// 式の計算
fn calc_expr(expr: &amp;Expr) -&gt; Result&lt;Ratio, ()&gt; {
    match expr {
        &amp;Leaf(n) =&gt; Ok(n),
        &amp;Node(op, ref left, ref right) =&gt; {
            let lv = calc_expr(left)?;
            let rv = calc_expr(right)?;
            match op {
                '+' =&gt; Ok(lv + rv),
                '-' =&gt; Ok(lv - rv),
                '*' =&gt; Ok(lv * rv),
                '/' =&gt; {
                    if rv.numer() == 0 {
                        Err(())
                    } else {
                        Ok(lv / rv)
                    }
                },
                _ =&gt; Err(())
            }
        }
    }
}

// 式の表示
fn print_expr(expr: &amp;Expr) {
    match expr {
        &amp;Leaf(n) =&gt; print!("{}", n),
        &amp;Node(op, ref left, ref right) =&gt; {
            print!("(");
            print_expr(left);
            print!(" {} ", op);
            print_expr(right);
            print!(")");
        }
    }
}

// 式の生成
fn make_node(op: char, left: Expr, right: Expr) -&gt; Expr {
    Node(op, Box::new(left), Box::new(right))
}

fn make_expr(op1: char, op2: char, op3: char) -&gt; Vec&lt;Expr&gt; {
    let n = Ratio::from_integer(4);
    vec![make_node(op1, make_node(op2, make_node(op3, Leaf(n), Leaf(n)), Leaf(n)), Leaf(n)),
         make_node(op1, make_node(op2, Leaf(n), Leaf(n)), make_node(op3, Leaf(n), Leaf(n))),
         make_node(op1, Leaf(n), make_node(op2, Leaf(n), make_node(op3, Leaf(n), Leaf(n)))),
         make_node(op1, Leaf(n), make_node(op2, make_node(op3, Leaf(n), Leaf(n)), Leaf(n))),
         make_node(op1, make_node(op2, Leaf(n), make_node(op3, Leaf(n), Leaf(n))), Leaf(n))]
}

fn make_expr2(op1: char, op2: char) -&gt; Vec&lt;Expr&gt; {
    let n = Ratio::from_integer(44);
    let m = Ratio::from_integer(4);
    vec![make_node(op1, make_node(op2, Leaf(n), Leaf(m)), Leaf(m)),
         make_node(op1, Leaf(n), make_node(op2, Leaf(m), Leaf(m))),
         make_node(op1, make_node(op2, Leaf(m), Leaf(n)), Leaf(m)),
         make_node(op1, Leaf(m), make_node(op2, Leaf(n), Leaf(m))),
         make_node(op1, make_node(op2, Leaf(m), Leaf(m)), Leaf(n)),
         make_node(op1, Leaf(m), make_node(op2, Leaf(m), Leaf(n)))]
}

fn make_expr3(op: char) -&gt; Vec&lt;Expr&gt; {
    let i = Ratio::from_integer(444);
    let j = Ratio::from_integer(44);
    let k = Ratio::from_integer(4);
    vec![make_node(op, Leaf(i), Leaf(k)),
         make_node(op, Leaf(k), Leaf(i)),
         make_node(op, Leaf(j), Leaf(j))]
}

// 式の評価
fn exec_expr(expr: &amp;Expr) {
    match calc_expr(&amp;expr) {
        Ok(n) =&gt; {
            if n.is_integer() {
                let m = n.to_integer();
                if m &gt; 0 &amp;&amp; m &lt;= 10 {
                    print_expr(&amp;expr);
                    println!(" = {}", m);
                }
            }
        },
        _ =&gt; ()
    }
}

fn main() {
    let ops = vec!['+', '-', '*', '/'];
    for op1 in &amp;ops {
        for op2 in &amp;ops {
            for op3 in &amp;ops {
                for expr in make_expr(*op1, *op2, *op3) {
                    exec_expr(&amp;expr);
                }
            }
        }
    }
    for op1 in &amp;ops {
        for op2 in &amp;ops {
            for expr in make_expr2(*op1, *op2) {
                exec_expr(&amp;expr);
            }
        }
    }
    for op1 in &amp;ops {
        for expr in make_expr3(*op1) {
            exec_expr(&amp;expr);
        }
    }
}
</pre>
<hr>
<h4 id="chap62">●テンパズル</h4>
<p> 「テンパズル」は 4 桁の数字を 1 桁ずつに分解し、それに四則演算とカッコを使って 10 を作るパズルです。「メイク１０」とか「切符番号の問題」と呼ばれることもあります。一般的なルールの場合、数字の順番を入れ替えてもよいのですが、数字を結合させることはできません。
</p>
<p> 今回はテンパズルを解くプログラムを作ります。four fours のプログラムを改造すれば簡単に作成することができます。詳細はプログラムリストをお読みください。
</p>
<pre class="list">
//
// make10.rs : テンパズル
//
//             Copyright (C) 2017 Makoto Hiroi
//
extern crate ratio;
use ratio::Ratio;

// 順列の生成
fn permutations(n: usize, buff: &amp;mut Vec&lt;i64&gt;, func: fn(&amp;Vec&lt;i64&gt;) -&gt; ()) {
    if n == buff.len() {
        func(buff)
    } else {
        for i in n .. buff.len() {
            buff.swap(n, i);
            permutations(n + 1, buff, func);
            buff.swap(n, i);
        }
    }
}

//
// 数式を表す二分木 (演算子は char で表す)
//
enum Expr {
    Leaf(Ratio),
    Node(char, Box&lt;Expr&gt;, Box&lt;Expr&gt;)
}

use Expr::*;

// 式の計算
fn calc_expr(expr: &amp;Expr) -&gt; Result&lt;Ratio, ()&gt; {
    match expr {
        &amp;Leaf(n) =&gt; Ok(n),
        &amp;Node(op, ref left, ref right) =&gt; {
            let lv = calc_expr(left)?;
            let rv = calc_expr(right)?;
            match op {
                '+' =&gt; Ok(lv + rv),
                '-' =&gt; Ok(lv - rv),
                '*' =&gt; Ok(lv * rv),
                '/' =&gt; {
                    if rv.numer() == 0 {
                        Err(())
                    } else {
                        Ok(lv / rv)
                    }
                },
                _ =&gt; Err(())
            }
        }
    }
}

// 式の表示
fn print_expr(expr: &amp;Expr) {
    match expr {
        &amp;Leaf(n) =&gt; print!("{}", n),
        &amp;Node(op, ref left, ref right) =&gt; {
            print!("(");
            print_expr(left);
            print!(" {} ", op);
            print_expr(right);
            print!(")");
        }
    }
}

// 式の生成
fn make_node(op: char, left: Expr, right: Expr) -&gt; Expr {
    Node(op, Box::new(left), Box::new(right))
}

fn make_expr(op1: char, op2: char, op3: char, nums: &amp;Vec&lt;i64&gt;) -&gt; Vec&lt;Expr&gt; {
    let a = Ratio::from_integer(nums[0]);
    let b = Ratio::from_integer(nums[1]);
    let c = Ratio::from_integer(nums[2]);
    let d = Ratio::from_integer(nums[3]);
    vec![make_node(op1, make_node(op2, make_node(op3, Leaf(a), Leaf(b)), Leaf(c)), Leaf(d)),
         make_node(op1, make_node(op2, Leaf(a), Leaf(b)), make_node(op3, Leaf(c), Leaf(d))),
         make_node(op1, Leaf(a), make_node(op2, Leaf(b), make_node(op3, Leaf(c), Leaf(d)))),
         make_node(op1, Leaf(a), make_node(op2, make_node(op3, Leaf(b), Leaf(c)), Leaf(d))),
         make_node(op1, make_node(op2, Leaf(a), make_node(op3, Leaf(b), Leaf(c))), Leaf(d))]
}

// チェック
fn check10(nums: &amp;Vec&lt;i64&gt;) {
    let ops = vec!['+', '*', '-', '/'];
    for op1 in &amp;ops {
        for op2 in &amp;ops {
            for op3 in &amp;ops {
                for expr in make_expr(*op1, *op2, *op3, nums) {
                    match calc_expr(&amp;expr) {
                        Ok(n) if n.is_integer() &amp;&amp; n.numer() == 10 =&gt; {
                            print_expr(&amp;expr);
                            println!(" = 10");
                        },
                        _ =&gt; ()
                    }
                }
            }
        }
    }
}

fn main() {
    permutations(0, &amp;mut vec![1,1,9,9], check10);
}
</pre>
<pre>
((1 + (1 / 9)) * 9) = 10
((1 + (1 / 9)) * 9) = 10
(((1 / 9) + 1) * 9) = 10
(((1 / 9) + 1) * 9) = 10
((1 + (1 / 9)) * 9) = 10
((1 + (1 / 9)) * 9) = 10
(((1 / 9) + 1) * 9) = 10
(((1 / 9) + 1) * 9) = 10
(9 * (1 + (1 / 9))) = 10
(9 * ((1 / 9) + 1)) = 10
(9 * (1 + (1 / 9))) = 10
(9 * ((1 / 9) + 1)) = 10
(9 * ((1 / 9) + 1)) = 10
(9 * (1 + (1 / 9))) = 10
(9 * ((1 / 9) + 1)) = 10
(9 * (1 + (1 / 9))) = 10
</pre>
<p> このプログラムは重複解のチェックを行っていないので、多数の式が出力されます。興味のある方はプログラムを改造して、いろいろ試してみてください。
</p>
<hr>
<h4 id="chap63">●整数の分割と分割数</h4>
<p> 整数 n を 1 以上の自然数の和で表すことを考えます。これを「整数の分割」といいます。整数を分割するとき、同じ自然数を何回使ってもかまいませんが、並べる順序が違うだけのものは同じ分割とします。簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
─┬─ 6                           : 6
  │
  ├─ 5 ─ 1                      : 5 + 1
  │
  ├─ 4 ┬ 2                      : 4 + 2
  │     │
  │     └ 1 ─ 1                 : 4 + 1 + 1
  │
  ├─ 3 ┬ 3                      : 3 + 3
  │     │
  │     ├ 2 ─ 1                 : 3 + 2 + 1
  │     │
  │     └ 1 ─ 1 ─ 1            : 3 + 1 + 1 + 1
  │
  ├─ 2 ┬ 2 ┬ 2                 : 2 + 2 + 2
  │     │   │
  │     │   └ 1 ─ 1            : 2 + 2 + 1 + 1
  │     │
  │     └ 1 ─ 1 ─ 1 ─ 1       : 2 + 1 + 1 + 1 + 1
  │
  └─ 1 ─ 1 ─ 1 ─ 1 ─ 1 ─ 1  : 1 + 1 + 1 + 1 + 1 + 1

                    図 : 整数 6 の分割
</pre>
<p> 6 の場合、分割の仕方は上図のように 11 通りあります。この数を「分割数」といいます。今回は整数の分割の仕方を列挙するプログラムと分割数を求めるプログラムを作ります。詳しい説明は拙作のページ <a href="../puzzle/index.html">Puzzle DE Programming</a> <a href="../puzzle/partition.html">分割数</a> をお読みくださいませ。
</p>
<pre class="list">
リスト : 分割数

// 整数の分割
fn partition_of_integer(n: i32) {
    fn part_int(n: i32, k: i32, a: &amp;mut Vec&lt;i32&gt;) {
        if n == 0 {
            println!("{:?}", a);
        } else if n == 1 {
            a.push(1);
            println!("{:?}", a);
            a.pop();
        } else if k == 1 {
            for _ in 0 .. n { a.push(1); }
            println!("{:?}", a);
            for _ in 0 .. n { a.pop(); }
        } else {
            if n &gt;= k {
                a.push(k);
                part_int(n - k, k, a);
                a.pop();
            }
            part_int(n, k - 1, a);
        }
    }
    part_int(n, n, &amp;mut vec![]);
}

// 分割数 (二重再帰なのでとても遅い)
fn partition_number(n: i64) -&gt; i64 {
    fn part_num(n: i64, k: i64) -&gt; i64 {
        if n == 1 || k == 1 {
            1
        } else if n &lt; 0 || k &lt; 1 {
            0
        } else {
            part_num(n - k, k) + part_num(n, k - 1)
        }
    }
    part_num(n, n)
}

// 動的計画法による高速化
fn partition_number_fast(n: usize) -&gt; usize {
    let mut table = vec![1; n + 1];
    for k in 2 .. n + 1 {
        for m in k .. n + 1 {
            table[m] += table[m - k];
        }
    }
    table[n]
}

fn main() {
    partition_of_integer(5);
    partition_of_integer(6);
    for i in 0 .. 11 {
        println!("{}", partition_number(i));
    }
    println!("{}", partition_number(40));
    println!("{}", partition_number(60));
    // println!("{}", partition_number(80));
    println!("{}", partition_number_fast(80));
    println!("{}", partition_number_fast(100));
    println!("{}", partition_number_fast(200));
}
</pre>
<pre>
[5]
[4, 1]
[3, 2]
[3, 1, 1]
[2, 2, 1]
[2, 1, 1, 1]
[1, 1, 1, 1, 1]
[6]
[5, 1]
[4, 2]
[4, 1, 1]
[3, 3]
[3, 2, 1]
[3, 1, 1, 1]
[2, 2, 2]
[2, 2, 1, 1]
[2, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1]
0
1
2
3
5
7
11
15
22
30
42
37338
966467
15796476
190569292
3972999029388
</pre>
<h4 id="chap64">●集合の分割</h4>
<p> 配列で表した集合 ls を分割することを考えます。たとえば、集合 [1, 2, 3] は次のように分割することができます。
</p>
<pre class="item">
1 分割 : [[1, 2, 3]]
2 分割 : [[1, 2], [3]], [[1, 3], [2]], [[1], [2, 3]]
3 分割 ; [[1], [2], [3]]
</pre>
<p> このように、分割した集合 xs は元の集合 ls の部分集合になります。分割した部分集合の積は空集合になり、分割した部分集合のすべての和を求めると元の集合になります。今回は分割の仕方をすべて求める関数 parititon_of_set() を作ります。
</p>
<pre class="list">
リスト : 集合の分割

fn partition_of_set(ls: &amp;[i32]) {
    fn part_set(ls: &amp;[i32], a: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {
        if ls.len() == 0 {
            println!("{:?}", a);
        } else {
            for i in 0 .. a.len() {
                a[i].push(ls[0]);
                part_set(&amp;ls[1..], a);
                a[i].pop();
            }
            a.push(vec![ls[0]]);
            part_set(&amp;ls[1..], a);
            a.pop();
        }
    }
    part_set(&amp;ls[1..], &amp;mut vec![vec![ls[0]]]);
}

fn main() {
    partition_of_set(&amp;[1, 2, 3]);
    partition_of_set(&amp;[1, 2, 3, 4]);
}
</pre>
<pre>
[[1, 2, 3]]
[[1, 2], [3]]
[[1, 3], [2]]
[[1], [2, 3]]
[[1], [2], [3]]
[[1, 2, 3, 4]]
[[1, 2, 3], [4]]
[[1, 2, 4], [3]]
[[1, 2], [3, 4]]
[[1, 2], [3], [4]]
[[1, 3, 4], [2]]
[[1, 3], [2, 4]]
[[1, 3], [2], [4]]
[[1, 4], [2, 3]]
[[1], [2, 3, 4]]
[[1], [2, 3], [4]]
[[1, 4], [2], [3]]
[[1], [2, 4], [3]]
[[1], [2], [3, 4]]
[[1], [2], [3], [4]]
</pre>

<h4 id="chap65">●ベル数</h4>
<p> 集合を分割する方法の総数を「ベル数 (Bell Number)」といい、次の漸化式で求めることができます。
</p>
<pre class="fig">
B(0) = 1
          n
B(n+1) =  Σ nＣk * B(k)    ; n &gt;= 1
          k=0
</pre>
<p> 今回はベル数を求める関数 bell_number() を作ります。
</p>
<pre class="list">
リスト : ベル数

// 組み合わせの数
fn combination_number(n: usize, r: usize) -> usize {
    if n == r || r == 0 {
        1
    } else {
        combination_number(n, r - 1) * (n - r + 1) / r
    }
}

// ベル数
fn bell_number(n: usize) -> usize {
    let mut bs = vec![1];
    for i in 0 .. n {
        let mut a = 0;
        for j in 0 .. bs.len() {
            a += combination_number(i, j) * bs[j];
        }
        bs.push(a);
    }
    bs[bs.len() - 1]
}

fn main() {
    for i in 0 .. 11 {
        println!("{}", bell_number(i));
    }
    println!("{}", bell_number(20));
    println!("{}", bell_number(25));
}
</pre>
<p> bell_number() は公式をそのままプログラムするだけです。変数 bs のベクタにベル数を格納します。<sub>n</sub>Ｃ<sub>k</sub> は関数 combination_number() で求めます。次の for ループで <sub>n</sub>Ｃ<sub>k</sub> * B(k) の総和を計算します。あとは、その値を push() で bs に追加するだけです。
</p>
<pre>
1
1
2
5
15
52
203
877
4140
21147
115975
51724158235372
4638590332229999353
</pre>
<h4 id="chap66">●集合のグループ分け</h4>
<p> k 個の要素をもつ集合 ls を要素数が等しい m 個の部分集合に分割することを考えます。部分集合の要素数 n は k / m になります。分割の仕方をすべて出力する関数 group() を作ります。
</p>
<pre class="list">
リスト : 集合のグループ分け

fn group(ls: &amp;[i32], n: usize, m: usize) {
    fn group_sub(ls: &amp;[i32], n: usize, m: usize, a: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {
        if ls.len() == 0 {
            println!("{:?}", a);
        } else {
            for i in 0 .. a.len() {
                if a[i].len() &lt; n {
                    a[i].push(ls[0]);
                    group_sub(&amp;ls[1..], n, m, a);
                    a[i].pop();
                }
            }
            if a.len() &lt; m {
                a.push(vec![ls[0]]);
                group_sub(&amp;ls[1..], n, m, a);
                a.pop();
            }
        }
    }
    group_sub(&amp;ls[1..], n, m, &amp;mut vec![vec![ls[0]]]);
}

fn main() {
    group(&amp;[1,2,3,4], 2, 2);
    group(&amp;[1,2,3,4,5,6], 2, 3);
    group(&amp;[1,2,3,4,5,6], 3, 2);
}
</pre>
<p> group() は partition_of_set() を改造するだけで簡単に作成することができます。生成する部分集合の大きさを n に、部分集合の個数を m に制限するだけです。i 番目の部分集合に要素を追加する場合、a[i].len() が n 未満であることをチェックします。新しい部分集合を追加する場合、a.len() が m 未満であることをチェックします。これで集合をグループに分けることができます。
</p>
<pre>
[[1, 2], [3, 4]]
[[1, 3], [2, 4]]
[[1, 4], [2, 3]]
[[1, 2], [3, 4], [5, 6]]
[[1, 2], [3, 5], [4, 6]]
[[1, 2], [3, 6], [4, 5]]
[[1, 3], [2, 4], [5, 6]]
[[1, 3], [2, 5], [4, 6]]
[[1, 3], [2, 6], [4, 5]]
[[1, 4], [2, 3], [5, 6]]
[[1, 5], [2, 3], [4, 6]]
[[1, 6], [2, 3], [4, 5]]
[[1, 4], [2, 5], [3, 6]]
[[1, 4], [2, 6], [3, 5]]
[[1, 5], [2, 4], [3, 6]]
[[1, 6], [2, 4], [3, 5]]
[[1, 5], [2, 6], [3, 4]]
[[1, 6], [2, 5], [3, 4]]
[[1, 2, 3], [4, 5, 6]]
[[1, 2, 4], [3, 5, 6]]
[[1, 2, 5], [3, 4, 6]]
[[1, 2, 6], [3, 4, 5]]
[[1, 3, 4], [2, 5, 6]]
[[1, 3, 5], [2, 4, 6]]
[[1, 3, 6], [2, 4, 5]]
[[1, 4, 5], [2, 3, 6]]
[[1, 4, 6], [2, 3, 5]]
[[1, 5, 6], [2, 3, 4]]
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html><!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>