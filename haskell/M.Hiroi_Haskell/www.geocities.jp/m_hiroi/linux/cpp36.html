<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881813</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp35.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>多重継承</h3>
<p> 今回は「多重継承」について説明します。実をいうと、M.Hiroi は多重継承に対してあまりいいイメージを持っていません。私見ですが、多重継承はメリットよりもプログラムを複雑にするデメリットの方が大きいのではないか、と思っています。とくに、下図のクラス A, B, C, E のような菱形の関係をＣ++でプログラムする場合、複雑な問題を引き起こすことが知られています。
</p>
<pre class="fig">
      Ａ
    ／  ＼
  ／      ＼
Ｂ          Ｃ  
  ＼      ／
    ＼  ／
      Ｄ

図 : 菱形継承
</pre>
<p> 多重継承は強力な機能ですが万能ではありません。多重継承は慎重に扱うべきだと思っています。それでは最初に、多重継承の基本的な使い方について簡単に説明します。
</p>
<h4>●多重継承の使い方</h4>
<p> 多重継承は次に示すように class 文で基底クラスを複数指定するだけです。
</p>
<pre class="item">
class name : public super_class_name1,
             public super_class_name2,
             ...
             public super_class_nameN {
  ...
}
</pre>
<p> 単一継承と同じく、継承修飾子には public を指定してください。なお、同じクラスを複数指定することはできません。
</p>
<p> 簡単な例題として、Foo と Bar の 2 つのクラスを継承するクラス Baz を考えてみましょう。次の図を見てください。
</p>
<pre class="fig">
     class
 ┌─ Foo  ─┐          ┌─ instance ─┐
 ├─────┤          ├───────┤
 │  変数 a  │────→│    変数 a    │
 └─────┘          └───────┘
method : get_a(), put_a()
      │
     継承
      │
      │         class
      │     ┌─ Bar  ─┐        ┌─ instance ─┐
      │     ├─────┤        ├───────┤
      │     │  変数 b  │───→│    変数 b    │
      │     └─────┘        └───────┘
      │  method : get_b(), put_b()
      │        │
      │       継承
      ↓        ↓
 ┌─── Baz  ───┐          ┌─ instance ─┐
 ├─────────┤────→├───────┤
 │      変数 c      │          │    変数 a    │: Foo から継承
 └─────────┘          ├───────┤
method : get_c(), put_c()        │    変数 b    │: Bar から継承
                                 ├───────┤
                                 │    変数 c    │: Baz 固有の領域
                                 └───────┘

                図 : 多重継承
</pre>
<p> クラス Foo にはメンバ変数 a とメンバ関数 get_a(), put_a() が定義されています。同様に、クラス Bar にはメンバ変数 b とメンバ関数 get_b(), put_b() が定義されています。次に、Foo と Bar を多重継承したクラス Baz を定義します。Baz にはメンバ変数 c とメンバ関数 get_c(), put_c() を定義します。Foo, Bar, Baz のインスタンスを生成すると、上図に示したように、Baz のインスタンスには Foo と Bar で定義された変数 a, b も含まれます。このように、複数の基底クラスのメンバ変数が Baz に継承されます。
</p>

<p> クラス Baz にはメンバ関数 get_c(), put_c() しか定義されていませんが、クラス Foo と Bar を継承することにより、get_a(), put_a(), get_b(), put_b() を呼び出すことができます。Baz のインスタンスに対して get_a() を呼び出すと、クラス Baz には get_a() が定義されていないのでスーパークラス Foo を調べ、そこで定義されている get_a() が呼び出されます。もちろん、取り出される値は Baz のインスタンスにある変数 a の値です。同様に、メンバ関数 get_b() も呼び出すことができます。このように、Foo と Bar のメンバ関数が Baz に継承されます。
</p>
<p> これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 多重継承の使用例

#include &lt;iostream&gt;
using namespace std;

class Foo {
  int a;
public:
  Foo() : a(0) {}
  Foo(int x) : a(x) {}
  int get_a() const { return a; }
  void put_a(int x) { a = x; }
};

class Bar {
  int b;
public:
  Bar() : b(0) {}
  Bar(int x) : b(x) {}
  int get_b() const { return b; }
  void put_b(int x) { b = x; }
};

class Baz : public Foo, public Bar {
  int c;
public:
  Baz(int x, int y, int z) : Foo(x), Bar(y), c(z) { }
  int get_c() const { return c; }
  void put_c(int x) { c = x; }
};

int main()
{
  Baz* a = new Baz(1, 2, 3);
  cout &lt;&lt; a-&gt;get_a() &lt;&lt; endl;
  cout &lt;&lt; a-&gt;get_b() &lt;&lt; endl;
  cout &lt;&lt; a-&gt;get_c() &lt;&lt; endl;  
  a-&gt;put_a(10);
  a-&gt;put_b(20);
  a-&gt;put_c(30);
  cout &lt;&lt; a-&gt;get_a() &lt;&lt; endl;
  cout &lt;&lt; a-&gt;get_b() &lt;&lt; endl;
  cout &lt;&lt; a-&gt;get_c() &lt;&lt; endl;
  Foo* b = a;
  b-&gt;put_a(100);
  cout &lt;&lt; b-&gt;get_a() &lt;&lt; endl;
  Bar* c = a;
  c-&gt;put_b(200);
  cout &lt;&lt; c-&gt;get_b() &lt;&lt; endl;
}
</pre>
<p> クラス Baz の定義で、コロンの後ろに public Foo と public Bar を指定します。これで Foo と Bar を継承することができます。Baz のコンストラクタでは、初期化リストでスーパークラスの Foo と Bar のコンストラクタを呼び出します。さっそく実行してみましょう。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
1
2
3
10
20
30
100
200
</pre>
<p> 継承したメンバ関数 get_a(), put_a(), get_b(), put_b() を呼び出すことができるのは当然です。それから、Baz のインスタンスは基底クラス Foo* 型の変数 b や Bar* 型の変数 c にセットすることができます。この場合、インスタンスのデータ型は Foo* (または Bar*) になるので、変数 b から呼び出せるメンバ関数は get_a(), put_a() だけ、変数 c から呼び出せるメンバ関数 get_b(), put_b() だけになります。
</p>
<h4>●メンバ変数の衝突</h4>
<p> クラスを多重継承する場合、異なる基底クラスで同じ名前のメンバ変数やメンバ関数が定義されていることがあります。Ｃ++の場合、基底クラスに同じ名前のメンバ変数があっても、それを一つにまとめることはしません。たとえば、Foo と Bar にメンバ変数 a があり、それを多重継承してクラス Baz を作成すると、インスタンスには Foo に対応するメンバ変数 a と Bar に対応するメンバ変数 a の領域が確保されます。次の図を見てください。

<pre class="fig">
     class
 ┌─ Foo  ─┐          ┌─ instance ─┐
 ├─────┤          ├───────┤
 │  変数 a  │────→│    変数 a    │
 └─────┘          └───────┘
      │
     継承
      │
      │         class
      │     ┌─ Bar  ─┐        ┌─ instance ─┐
      │     ├─────┤        ├───────┤
      │     │  変数 a  │───→│    変数 a    │
      │     └─────┘        └───────┘
      │        │
      │       継承
      ↓        ↓
 ┌─── Baz  ───┐          ┌─ instance ─┐
 ├─────────┤────→├───────┤
 │      変数 c      │          │    変数 a    │: Foo から継承
 └─────────┘          ├───────┤
                                 │    変数 a    │: Bar から継承
                                 ├───────┤
                                 │    変数 c    │: Baz 固有の領域
                                 └───────┘

                図 : メンバ変数の衝突
</pre>
<p> 上図のように、Bar のインスタンスには変数 a の領域が 2 つあります。変数 a にアクセスする場合、変数名 a だけではどちらの領域にアクセスしたらよいのかコンパイラが判断できずにエラーとなります。他のオブジェクト指向言語、たとえば CLOS (Common Lisp Object Sysytem) や Python などでは、同じ名前のメンバ変数はインスタンスに一つしか存在しないので、曖昧さを生じることはありません。ただし、そのことで他の問題が発生することがあります。
</p>
<p> たとえば、クラス Foo にはメンバ関数 method_a() があり、クラス Bar にはメンバ関数 method_b() があるとしましょう。この 2 つのメンバ関数はまったく異なる働きをします。ここで、メソッド method_a() はメンバ変数 x を使っていて、method_b() もメンバ変数 x を使っていると、CLOS や Python などの多重継承では問題が発生します。
</p>
<p> クラス Foo と Bar を多重継承してクラス Baz を作成した場合、クラス Baz のインスタンスにはメンバ変数 x がひとつしかありません。method_a() と method_b() はひとつしかないメンバ変数 x を使うことになります。この場合、どちらかのメソッドは正常に動作しないでしょう。これでは多重継承する意味がありませんね。
</p>
<p> Ｃ++の場合、同じ名前のメンバ変数があっても、基底クラスごとにメンバ変数のメモリ領域が確保されるので、このような問題が発生することはありません。ただし、メンバ変数にアクセスする場合は、スコープ解決演算子 (::) を使って曖昧さを解決する必要があります。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : メンバ変数の衝突

#include &lt;iostream&gt;
using namespace std;

struct Foo {
  int a;
  Foo(int x) : a(x) {}
};

struct Bar {
  int a;
  Bar(int x) : a(x) {}
};

struct Baz : public Foo, public Bar {
  Baz(int x, int y) : Foo(x), Bar(y) {}
};

int main()
{
  Baz a(10, 20);
  cout &lt;&lt; a.Foo::a &lt;&lt; endl;
  cout &lt;&lt; a.Bar::a &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
10
20
</pre>
<p> メンバ変数名の前に クラス名:: を付加すれば、そのクラスのメンバ変数にアクセスすることができます。
</p>

<h4>●メンバ関数の衝突</h4>
<p> 多重継承する基底クラスで同じ名前のメンバ関数が定義されている場合、メンバ変数と同じように、どのクラスのメンバ関数を呼び出すか明示しないとコンパイルエラーになります。CLOS や Python などでは、継承関係からメンバ関数 (メソッド) の優先順位を決定することができるので、Ｃ++のような曖昧さが生じることはありません。ただし、優先順位を決定するアルゴリズムはちょっと複雑です。拙作のページ <a href="../light/python06.html">Python 入門第 6 回</a> や <a href="../clisp/clisp05.html">CLOS 入門: 多重継承</a> で簡単に説明しているので、興味のある方はお読みくださいませ。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : メンバ関数の衝突

#include &lt;iostream&gt;
using namespace std;

struct Foo {
  int a;
  Foo(int x) : a(x) {}
  void print() { cout &lt;&lt; "Foo " &lt;&lt; a &lt;&lt; endl; }
};

struct Bar {
  int a;
  Bar(int x) : a(x) {}
  void print() { cout &lt;&lt; "Bar " &lt;&lt; a &lt;&lt; endl; }  
};

struct Baz : public Foo, public Bar {
  Baz(int x, int y) : Foo(x), Bar(y) {}
};

int main()
{
  Baz a(10, 20);
  a.Foo::print();
  a.Bar::print();
  // a.print();  // コンパイルエラー
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Foo 10
Bar 20
</pre>
<p> クラス Foo と Bar には同じ名前のメンバ関数 print() が定義されています。Baz のインスタンスから print() を呼び出す場合、どちらのクラスのメンバ関数を呼び出すか、スコープ解決演算子を使って指定します。
</p>
<p> もちろん、クラス Baz でメンバ関数 print() をオーバーライドすることもできます。このとき、print() を仮想関数にすると、ポリモーフィズムを働かせることができます。次の例を見てください。
</p>
<pre class="list">
リスト : メンバ関数のオーバーライド

#include &lt;iostream&gt;
using namespace std;

struct Foo {
  int a;
  Foo(int x) : a(x) {}
  virtual void print() { cout &lt;&lt; "Foo " &lt;&lt; a &lt;&lt; endl; }
};

struct Bar {
  int a;
  Bar(int x) : a(x) {}
  virtual void print() { cout &lt;&lt; "Bar " &lt;&lt; a &lt;&lt; endl; }  
};

struct Baz : public Foo, public Bar {
  Baz(int x, int y) : Foo(x), Bar(y) {}
  void print() {
    Foo::print();
    Bar::print();
  }
};

int main()
{
  Baz* a = new Baz(10, 20);
  a-&gt;print();
  Foo* b = a;
  b-&gt;print();
  Bar* c = a;
  c-&gt;print();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Foo 10
Bar 20
Foo 10
Bar 20
Foo 10
Bar 20
</pre>
<p> Baz のインスタンスは Foo* 型や Bar* 型の変数 b, c にセットすることができます。そして、print() が仮想関数なので、b や c から print() を呼び出すと、Baz でオーバーライドした print() が実行されます。
</p>
<h4>●仮想基底クラス</h4>
<p> 次は同じ基底クラス Foo を継承しているクラス Bar1 と Bar2 を多重継承することを考えてみましょう。下図を見てください。
</p>
<pre class="fig">
     class
 ┌─ Foo  ─┐
 ├─────┤
 │  変数 a  │
 └─────┘
      │
     継承
      │
      ├───────┐
      │              │
      ↓              ↓
     class          class
 ┌─ Bar1 ─┐ ┌─ Bar2 ─┐
 ├─────┤ ├─────┤
 │  変数 b  │ │  変数 c  │
 └─────┘ └─────┘
      │              │
     継承            継承
      ↓    class     ↓
    ┌─── Baz  ───┐          ┌─ instance ─┐
    ├─────────┤────→├───────┤──
    │      変数 d      │          │    変数 a    │   ↑  Foo から継承
    └─────────┘          ├───────┤  Bar1 の領域
                                    │    変数 b    │   ↓
                                    ├───────┤──
                                    │    変数 a    │   ↑  Foo から継承
                                    ├───────┤  Bar2 の領域
                                    │    変数 c    │   ↓
                                    ├───────┤──
                                    │    変数 d    │  Baz 固有の領域
                                    └───────┘──

              図 : 同じクラスを間接的に継承する
</pre>
<p> Bar1 と Bar2 は Foo を単一継承しています。Baz は Bar1 と Bar2 を多重継承します。この場合、Ｃ++ではクラス Foo を 2 つ継承することになります。実際、上図のように Baz のインスタンスには Foo のメンバ変数 a のメモリ領域が 2 つ確保されます。Foo のメンバ変数 a にアクセスするときは、Bar1 と Bar2 のどちらのメンバ変数なのか明示する必要があります。なお CLOS や Python では、このような場合でも Baz のインスタンスに確保されるメンバ変数 a の領域は一つしかありません。
</p>
<p> これをプログラムすると次のようになります。
</p>
<pre class="list">
リスト : 同じクラスを間接的に継承する

#include &lt;iostream&gt;
using namespace std;

struct Foo {
  int a;
  Foo(int x) : a(x) {}
};

struct Bar1 : public Foo {
  int b;
  Bar1(int x, int y) : Foo(x), b(y) {}
};

struct Bar2 : public Foo {
  int c;
  Bar2(int x, int y) : Foo(x), c(y) {}
};

struct Baz : public Bar1, public Bar2 {
  int d;
  Baz(int x, int y, int z) : Bar1(x, y), Bar2(y, z), d(z) {}
};

int main()
{
  Baz a(10, 20, 30);
  cout &lt;&lt; a.Bar1::a &lt;&lt; endl;
  cout &lt;&lt; a.Bar2::a &lt;&lt; endl;
  cout &lt;&lt; a.b &lt;&lt; endl;
  cout &lt;&lt; a.c &lt;&lt; endl;
  cout &lt;&lt; a.d &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
10
20
20
30
30
</pre>
<p> Bar1::a とすると、Bar1 が継承した Foo のメンバ変数 a に、Bar2::a とすると、Bar2 が継承した Foo のメンバ変数 a にアクセスすることができます。なお、Foo のメンバ関数の呼び出しも同様です。
</p>
<p> クラス Baz からみると、基底クラス Foo は Bar1 と Bar2 のどちらかひとつあれば機能するはずです。また、そのようにクラスを一つにまとめたほうが曖昧さがなくなるので便利です。Ｃ++の場合、クラスを継承するときに virtual を指定すると、同じ基底クラスを一つにまとめてくれます。これを「仮想基底クラス」といいます。
</p>
<pre class="item">
class Foo { ... };
class Bar1 : virtual public Foo { ... };
class Bar2 : virtual public Foo { ... };
class Baz : public Bar1, public Bar2 { ... };
</pre>
<p> これで Baz のインスタンスで確保されるメンバ変数 a の領域は一つになり、クラス Foo, Bar1, Bar2, Baz は菱形の継承関係になります。
</p>
<p> ここで、仮想基底クラスのコンストラクタは今までの方法とは異なり、一番下の派生クラスのコンストラクタの初期化リスト、この場合は Baz のコンストラクタにおいて、一番最初に呼び出されることに注意してください。Baz で Foo のコンストラクタの呼び出しが明示されていない場合はデフォルトコンストラクタが呼び出されます。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 仮想基底クラスの使用例

#include &lt;iostream&gt;
using namespace std;

struct Foo {
  int a;
  Foo() : a(0) { cout &lt;&lt; "Foo " &lt;&lt; a &lt;&lt; endl; }
  Foo(int x) : a(x) { cout &lt;&lt; "Foo " &lt;&lt; a &lt;&lt; endl; }
};

struct Bar1 : virtual public Foo {
  int b;
  Bar1(int x, int y) : Foo(x), b(y) { cout &lt;&lt; "Bar1 "&lt;&lt; b &lt;&lt; endl; }
};

struct Bar2 : virtual public Foo {
  int c;
  Bar2(int x, int y) : Foo(x), c(y) { cout &lt;&lt; "Bar2 " &lt;&lt; c &lt;&lt; endl; }
};

struct Baz : public Bar1, public Bar2 {
  int d;
  Baz(int x, int y, int z) : Bar1(x, y), Bar2(y, z), d(z) {
    cout &lt;&lt; "Baz " &lt;&lt; d &lt;&lt; endl;
  }
};

int main()
{
  Baz a(10, 20, 30);
  cout &lt;&lt; a.a &lt;&lt; endl;
  cout &lt;&lt; a.b &lt;&lt; endl;
  cout &lt;&lt; a.c &lt;&lt; endl;
  cout &lt;&lt; a.d &lt;&lt; endl;
  Bar1 b(1, 2);
  cout &lt;&lt; b.a &lt;&lt; endl;
  cout &lt;&lt; b.b &lt;&lt; endl;
  Bar2 c(3, 4);
  cout &lt;&lt; c.a &lt;&lt; endl;
  cout &lt;&lt; c.c &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Foo 0
Bar1 20
Bar2 30
Baz 30
0
20
30
30
Foo 1
Bar1 2
1
2
Foo 3
Bar2 4
3
4
</pre>
<p> Baz のコンストラクタの初期化リストで Foo のコンストラクタを呼び出していないので、デフォルトコンストラクタが一番最初に呼び出されていることがわかります。Bar1 と Bar2 のコンストラクタから Foo のコンストラクタが呼び出されることはありません。Bar1 と Bar2 のインスタンスを生成するときは、今までと同様の方法でコンストラクタが呼び出されます。
</p>

<p> もしも、Baz を継承して新しいクラスを定義する場合、Foo のコンストラクタは新しいクラスのコンストラクタから呼び出されることになります。このように、継承関係によって仮想基底クラスの初期化のタイミングが異なるので、仮想基底クラスは引数無しのコンストラクタで初期化する、もしくは、仮想基底クラスではメンバ変数を定義しないほうがよいとされています。
</p>
<h4>●菱形継承とメンバ関数</h4>
<p> このように、仮想基底クラスのコンストラクタは、最初に 1 回だけ呼び出されることがＣ++の仕様で保証されていますが、同様なことを他のメンバ関数で行うことは簡単ではありません。次の例を見てください。
</p>
<pre class="list">
リスト : 仮想基底クラスのメンバ関数を呼び出す

#include &lt;iostream&gt;
using namespace std;

class Foo {
public:
  virtual void method_a() { cout &lt;&lt; "Foo::method_a\n"; }
};

class Bar1 : virtual public Foo {
public:
  void method_a() {
    Foo::method_a();
    cout &lt;&lt; "Bar1::method_a\n";
  }
};

class Bar2 : virtual public Foo {
public:
  void method_a() {
    Foo::method_a();
    cout &lt;&lt; "Bar2::method_a\n";
  }
};

class Baz : public Bar1, public Bar2 {
public:
  void method_a() {
    Bar1::method_a();
    Bar2::method_a();
  }
};

int main()
{
  Baz a;
  a.method_a();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Foo::method_a
Bar1::method_a
Foo::method_a
Bar2::method_a
</pre>
<p> メンバ関数 method_a() は、呼び出すとき最初に 1 回だけ Foo のメンバ関数 method_a() を実行しなければならないものとします。Bar1, Bar2 の場合は簡単です。method_a() の中で Foo の method_a() を最初に呼び出すだけです。ところが Baz の場合、Bar1, Bar2 のメソッドを順番に呼び出すと、Foo の method_a() を 2 回呼び出してしまいます。
</p>
<p> 他のプログラミング言語、たとえば CLOS や Python ではメソッドの優先順位を決定することができます。CLOS の場合は Baz -&gt; Bar1 -&gt; Bar2 -&gt; Foo となります。そして、CLOS では優先順位に従って基底クラスのメソッドを簡単に呼び出すことができるようになっています。CLOS の場合、関数 call-next-method を使います。なお、メソッド名の前に super を指定するプログラミング言語もあります。
</p>
<p> Baz::method_a() で call-next-method を呼び出すと Bar1::method_a() が呼び出されます。その中で call-next-method を呼び出すと Bar2::method_a() が呼び出され、さらにその中で call-next-method を呼び出すと Foo::method_a() が呼び出されます。このように、CLOS では基底クラスのメンバ関数を簡単に呼び出すことができます。
</p>
<p> Ｃ++の場合、メンバ関数の呼び出しに優先順位はなく、プログラマが指定しなくてはなりません。最初に 1 回だけ Foo::method_a() を呼び出したいならば、Bar1, Bar2 固有の処理を行うメンバ関数を用意して、Foo の method_a() を呼び出す処理と分離する必要があります。次のリストを見てください。
</p>
<pre class="list">
リスト : 仮想基底クラスのメンバ関数を呼び出す (2)

#include &lt;iostream&gt;
using namespace std;

class Foo {
public:
  virtual void method_a() { cout &lt;&lt; "Foo::method_a\n"; }
};

class Bar1 : virtual public Foo {
public:
  void method_owner_a() {
    cout &lt;&lt; "Bar1::method_a\n";
  }
  void method_a() {
    Foo::method_a();
    method_owner_a();
  }
};

class Bar2 : virtual public Foo {
public:
  void method_owner_a() {
    cout &lt;&lt; "Bar2::method_a\n";
  }
  void method_a() {
    Foo::method_a();
    method_owner_a();
  }
};

class Baz : public Bar1, public Bar2 {
public:
  void method_a() {
    Foo::method_a();
    Bar1::method_owner_a();
    Bar2::method_owner_a();
  }
};

int main()
{
  Baz a;
  a.method_a();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Foo::method_a
Bar1::method_a
Bar2::method_a
</pre>
<p> Bar1, Bar2 にメンバ関数 method_owner_a() を用意します。Baz の method_a() では最初に Foo::method_a() を呼び出して、それから Bar1::method_owner_a() と Bar2::method_owner_a() を呼び出します。これで仮想基底クラス Foo の method_a() を最初に 1 回だけ呼び出すことができます。
</p>

<h4>●菱形継承におけるメンバ関数の曖昧さ</h4>
<p> 菱形継承にすると、曖昧だったメンバ関数の呼び出しが、そうでなくなる場合があります。次のリストを見てください。
</p>
<pre class="list">
リスト : 菱形継承でのメンバ関数の呼び出し

#include &lt;iostream&gt;
using namespace std;

class Foo {
public:
  virtual void method_a() { cout &lt;&lt; "Foo::method_a\n"; }
};

class Bar1 : virtual public Foo {
public:
  void method_a() { cout &lt;&lt; "Bar1::method_a\n"; }
};

class Bar2 : virtual public Foo { };

class Baz : public Bar1, public Bar2 { };

int main()
{
  Baz a;
  a.method_a();
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
Bar1::method_a
</pre>
<p> Baz から見ると、method_a() は Bar1 のそれと、Bar2 を経由して Foo1 の method_a() の 2 つがあります。この場合、method_a() の呼び出しは曖昧になると思われるでしょうが、実は Bar1 の method_a() が呼び出されます。
</p>
<p> 菱形継承にしない場合、method_a() の呼び出しは Foo と Bar1 の二つがあるので曖昧になるのですが、菱形継承にすると Bar1 と Bar2 の基底クラス Foo は同じものになります。この場合、Foo の method_a() は Bar1 でオーバーライドしているので、Baz から method_a() を呼び出すと、オーバーライドした Bar1 の method_a() が実行されます。
</p>
<p> CLOS などメソッドに優先順位をつけるプログラミング言語を経験したことがあると、これは当然の動作のように思うのですが、メンバ関数に優先順位をつけないＣ++では、仕様に反しているように思えて、なかなか理解できないかもしれません。
</p>
<h4>●Mix-in</h4>
<p> 今まで説明したように、Ｃ++の多重継承は複雑で難解です。もっとも、多重継承が複雑になるのはＣ++に限った話ではなく、他のプログラミング言語でも似たような状況になりがちです。たとえば、単一継承の場合、クラスの階層は木構造になりますが、多重継承ではグラフになります。木構造の場合、クラスの優先順位は簡単にわかりますが、グラフになると優先順位を理解するのは難しくなります。
</p>
<p> これを軽減するために、メンバ変数 (属性) を継承する基底クラスはひとつだけに限定して、あとの基底クラスはメソッド (実装) だけを継承するという方法があります。この方法を Mix-in といいます。
</p>
<p> 具体的には、メンバ変数を定義せずにメソッドだけを記述したクラスを用意します。属性の継承は単一継承になりますが、実装のみを記述したクラスはいくつ継承してかまいません。ひとつのクラスに複数の実装を混ぜることから Mix-in と呼ばれています。
</p>
<p> なお、Mix-in は特別な機能ではなく、多重継承を使いこなすための方法論にすぎません。多重継承を扱うことができるプログラミング言語であれば Mix-in を行うことが可能です。ちなみに、この Mix-in という方法を言語仕様に取り込んだのが Ruby です。
</p>
<p> Mix-in のイメージを下図に示します。
</p>

<pre class="fig">
                Ａ
              ／
            Ｂ
 Mixin A  ／  ＼    Mixin B
    ＼  ／      ＼  ／
      Ｃ          Ｄ

      図 : Mix-in
</pre>

<p> クラス C はクラス B を継承していて、そこにクラス Mixin A が Mix-in されています。クラス D もクラス B を継承していますが、Mix-in されているクラスは Mixin B となります。
</p>
<p> 多重継承の問題点は Mix-in ですべて解決できるわけではありませんが、クラスの階層構造がすっきりとしてわかりやすくなることは間違いありません。Mix-in は多重継承を使いこなす優れた方法ではないかと思っています。
</p>

<h4>●Enumerable</h4>
<p> それでは Mix-in の例題として、クラス Enumerable を作ってみましょう。Enumerable はコンテナクラスに高階関数を Mix-in します。これは Ruby のモジュール (Mix-in 用のクラス) Enumerable を参考にしました。追加するメンバ関数を下表に示します。
</p>
<table border=1>
<caption>表 : Enumerable&lt;T&gt; のメンバ関数</caption>
<thead>
  <tr><th>名前</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>bool member(F func)</td><td>func が真となる要素を探す</td></tr>
  <tr><td>int position(F func)</td><td>func が真となる要素の位置を返す</td></tr>
  <tr><td>int count(F func)</td><td>func が真となる要素の個数を返す</td></tr>
  <tr><td>vector&lt;T&gt; mapcar(F func)</td><td>要素に func を適用した結果を vector に格納して返す</td></tr>
  <tr><td>vector&lt;T&gt; filter(F func)</td><td>func が真となる要素を vector に格納して返す</td></tr>
  <tr><td>U fold(F func, U init)</td><td>すべての要素を func を用いて結合した結果を返す</td></tr>
</tbody>
</table>
<p> これらのメンバ関数はすべて関数テンプレートで定義します。T は Enumerable のテンプレート仮引数で、コンテナクラスが保持している要素のデータ型を表します。F は関数オブジェクトを表すテンプレート仮引数で、U は T 以外のデータ型を表すテンプレート仮引数です。Ｃ++の場合、クラステンプレートの中でも関数テンプレートを定義することができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : Mix-in 用のクラス Enumerable

template&lt;class T&gt;
class Enumerable {
public:
  virtual bool enum_empty() = 0;
  virtual T&amp; enum_get() = 0;
  virtual void enum_next() = 0;
  virtual void enum_init() = 0;

  template&lt;class F&gt;
  bool member(F func) {
    enum_init();
    while (!enum_empty()) {
      if (func(enum_get())) return true;
      enum_next();
    }
    return false;
  }

  template&lt;class F&gt;
  int position(F func) {
    int i = 0;
    enum_init();
    while (!enum_empty()) {
      if (func(enum_get())) return i;
      i++;
      enum_next();
    }
    return -1;
  }

  template&lt;class F&gt;
  int count(F func) {
    int c = 0;
    enum_init();
    while (!enum_empty()) {
      if (func(enum_get())) c++;
      enum_next();
    }
    return c;
  }

  template&lt;class F&gt;
  vector&lt;T&gt; mapcar(F func) {
    vector&lt;T&gt; a;
    enum_init();
    while (!enum_empty()) {
      a.push_back(func(enum_get()));
      enum_next();
    }
    return a;
  }

  template&lt;class F&gt;
  vector&lt;T&gt; filter(F func) {
    vector&lt;T&gt; a;
    enum_init();
    while (!enum_empty()) {
      if (func(enum_get())) a.push_back(enum_get());
      enum_next();
    }
    return a;
  }

  template&lt;class F, class U&gt;
  U fold(F func, U init) {
    U a = init;
    enum_init();
    while (!enum_empty()) {
      a = func(a, enum_get());
      enum_next();
    }
    return a;
  }
};
</pre>
<p> クラス Enumerable は Mix-in を前提としているのでメンバ変数の定義は不要です。コンテナクラスの要素は純粋仮想関数 enum_init(), enum_get(), enum_next(), enum_empty() を使ってアクセスします。enum_init() はイテレータの begin() に、enum_get() は * 演算子、enum_next() は ++ 演算子に相当します。enum_empty() は取り出す要素がなくなったら真を返します。
</p>
<p> これらの関数は Mix-in するクラスで定義するものとします。つまり、4 つの関数を定義さえすれば、どんなクラスでも Enumberable を Mix-in することができるわけです。たとえば、vector に Enumerable を Mix-in してみましょう。次のリストを見てください。
</p>

<pre class="list">
リスト : Mix-in の例題

template&lt;class T&gt;
class EnumVec : public vector&lt;T&gt;, public Enumerable&lt;T&gt; {
  typename vector&lt;T&gt;::iterator iter;
public:
  void enum_init() { iter = this-&gt;begin(); }
  T&amp; enum_get() { return *iter; }
  void enum_next() { ++iter; }
  bool enum_empty() { return iter == this-&gt;end(); }
};
</pre>
<p> 今回は簡単な例題なので、デフォルトコンストラクタ以外のコンストラクタは省略します。メンバ変数 iter は継承した vector のイテレータを保持します。typename は vector&lt;T&gt;::iterator がデータ型であることをコンパイラに認識させるために必要です。typename を省略するとコンパイルエラーになります。
</p>
<p> enum_init() は this-&gt;begin() の返り値を iter にセットします。これで iter は vector の先頭要素を指し示します。enum_get() は return で *iter を返すだけです。enum_next() は ++ 演算子で iter を一つ進めます。enum_empty() は iter と this-&gt;end() を比較するだけです。
</p>
<p> それでは実際に動かしてみましょう。次に示す簡単なテストを行ってみました。
</p>
<pre class="list">
リスト : 簡単なテスト

int main()
{
  EnumVec&lt;int&gt; a;
  for (int i = 0; i &lt; 8; i++) a.push_back(i);
  cout &lt;&lt; a.member([](int x) { return x == 0; }) &lt;&lt; endl;
  cout &lt;&lt; a.member([](int x) { return x == 7; }) &lt;&lt; endl;
  cout &lt;&lt; a.member([](int x) { return x == 8; }) &lt;&lt; endl;
  cout &lt;&lt; a.position([](int x) { return x == 0; }) &lt;&lt; endl;
  cout &lt;&lt; a.position([](int x) { return x == 7; }) &lt;&lt; endl;
  cout &lt;&lt; a.position([](int x) { return x == 8; }) &lt;&lt; endl;
  cout &lt;&lt; a.count([](int x) { return x == 0; }) &lt;&lt; endl;
  cout &lt;&lt; a.count([](int x) { return x == 7; }) &lt;&lt; endl;
  cout &lt;&lt; a.count([](int x) { return x == 8; }) &lt;&lt; endl;
  vector&lt;int&gt; b = a.mapcar([](int x) { return x * x; });
  for (int x : b) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  vector&lt;int&gt; c = a.filter([](int x) { return x % 2 == 0; });
  for (int x : c) cout &lt;&lt; x &lt;&lt; " ";
  cout &lt;&lt; endl;
  cout &lt;&lt; a.fold([](int a, int x) { return a + x;}, 0) &lt;&lt; endl;
};
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
1
1
0
0
7
-1
1
1
0
0 1 4 9 16 25 36 49 
0 2 4 6 
28
</pre>
<p> 正常に動作していますね。複数のクラスで共通の操作 (メンバ関数) を定義したい場合、Mix-in はとても役に立ちます。
</p>
<p> ところで、Ｃ++は高機能なプログラミング言語なので、このほかにも Mix-in を実現する方法があるようです。興味のある方は <a href="cpp36.html#cite">参考 URL</a> をお読みくださいませ。
</p>
<h4 id="cite">●参考 URL</h4>
<ol>
  <li><a href="http://d.hatena.ne.jp/minekoa/20070810/1186752546">C++ で ruby 風 Mix-in</a>, (みねこあさん)
</ol>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp35.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>