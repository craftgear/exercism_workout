<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ++プログラミング超入門</title>
  <meta name="description" content="Ｃ++,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881811</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ++プログラミング超入門</h2>
<div class="small">
[ <a href="cpp06.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp08.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Ｃ++のメモリアロケーション</h3>
<p> 今回はＣ++の「メモリアロケーション (メモリ確保, メモリ割り当て)」について説明します。今までは大域変数や局所変数を宣言することでメモリ領域を確保しました。大域変数はプログラムを実行するとき、あるメモリ領域 (データ領域) に確保されます。これを「静的メモリ割り当て」といいます。局所変数や関数の引数は「スタック領域」に確保されます。これを「自動メモリ割り当て」といいます。
</p>
<p> 最後に、「ヒープ領域」<sup><a href="cpp07.html#note1">[*1]</a></sup> からメモリを割り当てる方法があります。これを「動的メモリ割り当て」<sup><a href="cpp07.html#note2">[*2]</a></sup> といいます。Ｃ++では new 演算子でメモリを取得します。new で割り当てたメモリ領域は局所変数や関数の引数のように自動的に解放されません。Ｃ++でメモリを解放するのが delete 演算子です。new や delete を使いこなせるようになると、プログラミングの幅はぐーんと広がります。少々難しい話になりますが、恐れずにチャレンジしましょう。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 最近では「自由記憶領域 (free store)」と呼ばれることもあります。本稿ではヒープ領域と呼ぶことにします。<br>
<a name="note2">[*2]</a> Ｃ言語の場合、標準ライブラリ関数 malloc と free を使います。Ｃ++でも malloc や free を使用することはできますが、new で取得したメモリを free で解放する、逆に malloc で取得したメモリを delete で解放してはいけません。Ｃ++では new と delete を使うようにしてください。
</div>
<h4>●スタックとは？</h4>
<p> 一般的なＣ/Ｃ++コンパイラの実装では、引数を「スタック (stack)」というメモリ領域に格納してから関数を呼び出します。また、局所変数もスタック上に確保されます。では、スタックとはどのようなものなのでしょうか。よく例に取り上げられるのが「バネ付きのトレイ」です。下図を見てください。
</p>
<pre class="fig">
    |-----|   |[ A ]|   |[ B ]|   |[ A ]|   |-----|
    |  |  |   |-----|   |[ A ]|   |-----|   |  |  |
    |  |  |   |  |  |   |-----|   |  |  |   |  |  |
    |  |  |   |  |  |   |  |  |   |  |  |   |  |  |
    |  |  |   |  |  |   |  |  |   |  |  |   |  |  |
    +-----+   +-----+   +-----+   +-----+   +-----+
  1. 空の状態 2.PUSH    3.PUSH    4.POP     5.POP
                 A         B         B         A

               図 : スタックの動作例
</pre>
<p> 初めは空の状態です。ここにトレイを上から入れると、重さによってバネを圧縮し、次のトレイを追加できるようになります。さらにもうひとつトレイを乗せると、さらにバネを圧縮し次のトレイを追加できるようになります。バネが限界まで圧縮されるとトレイは追加できなくなります。トレイを取り出す場合は、上にあるトレイから取り出します。ひとつ取り出すと、その分バネが伸びて下にあるトレイが上に出てくるので、次のトレイを取り出すことができます。
</p>
<p> このトレイをデータに見立ててみましょう。データ A をスタックに追加し (2)、次にデータ B を追加します (3)。データを取り出す場合、後から入れたデータ B が先に取り出され (4)、その次にデータ A が取り出されてスタックは空になります (5)。スタックにデータを追加することを「プッシュ (PUSH)」といい、スタックからデータを取り出すことを「ポップ (POP)」といいます。
</p>
<p> コンピュータではメモリを使ってこのスタックを実装することになります。一般に、バネの代わりに「スタックポインタ (SP)」を使ってスタックを管理します。下図を見てください。
</p>
<pre class="fig">
  アドレス Low        High  SP
             A B C D E
           [           ]    E   スタックは空
           [       3   ]    D   PUSH 3
           [     2 3   ]    C   PUSH 2
           [   1 2 3   ]    B   PUSH 1
           [     2 3   ]    C   POP =&gt; 1 が取り出される
           [       3   ]    D   POP =&gt; 2 が取り出される
           [           ]    E   POP =&gt; 3 が取り出される
                                スタックが空になる

           図 : メモリ上でのスタックの実現
</pre>
<p> 便宜上アドレスを A から E までのアルファベットで表すことにします。スタックが空の場合 SP は E を指示しています。データをプッシュする場合、SP を E から D にひとつ減らし <sup><a href="cpp07.html#note3">[*3]</a></sup> D にデータをセットします。データをプッシュしていくと SP は Low アドレスに向かっていきます。つまりデータは High アドレスから Low アドレスに向かってスタックに積まれていきます。<sup><a href="cpp07.html#note4">[*4]</a></sup>
</p>
<p> データをポップする場合、SP が B を指示しているならば、B にあるデータ 1 を取り出してから SP をひとつ増やして C に移します。データを次々とポップしていくと SP の値は E になり、スタックは空の状態になります。
</p>
<p> これが何の役に立つんだと思ってはいけません。近代的なプログラミング言語は、スタックを使って関数呼び出しを実装しているからです。関数の呼び出しや局所変数の確保に使われるスタックを「システムスタック」とか「コールスタック」といいます。
</p>
<div class="note">
-- note --------<br>
<a name="note3">[*3]</a> 実際にはスタックに積むデータサイズによって SP の増減幅が決まります。たとえば、データが int ならば 4 バイトの大きさなので、スタックに積むと SP の示すアドレスは 4 減少します。ここでいう 1 つは 1 データサイズ分と考えてください。
<br>
<a name="note4">[*4]</a> これは一般的な処理系のコールスタックの場合で、スタックの伸びる方向が逆の処理系があってもかまいません。
</div>
<h4>●関数呼び出しとスタックの関係</h4>
<p> それでは、関数が呼び出されるときのスタックの様子を見てみましょう。階乗の計算を行う関数 fact(4) から fact(3) を呼び出す場合を考えてみます。次の図を見てください。
</p>
<pre class="list">
リスト : 階乗

int fact(int n)
{
  if (n == 0)
    return 1;
  else
    return n * fact(n - 1);
}
</pre>
<pre class="fig">
                  &lt;---- 4 byte ----&gt;
  アドレス Low  A [                ]
                B [リターンアドレス]   &lt;= SP (5)
                C [引数 n : 0      ]
                D [リターンアドレス]   &lt;= SP (4)
                E [引数 n : 1      ]
                F [リターンアドレス]   &lt;= SP (3)
                G [引数 n : 2      ]
                H [リターンアドレス]   &lt;= SP (2)
                I [引数 n : 3      ]
          High  J [                ]   &lt;= SP (1)

           図 : 引数をスタックに積む
</pre>
<p> fact(4) が実行されているときのスタックポインタは (1) の状態であったとしましょう。アドレスを便宜上 A から J までのアルファベットで表すことにすると、SP は J を示しています。
</p>
<p> まず引数 n の値 3 がスタックに積まれます。SP はひとつ減りアドレス I を指し示し、そこに n の値 3 が格納されます。fact の引数はひとつなので、次に fact の関数呼び出しが行われます。関数を呼び出す場合、呼び出された関数から呼び出し元の関数に戻るための情報（リターンアドレス）をスタックにプッシュします。
</p>
<p> fact(3) が実行されるときの SP は (2) の状態です。呼び出された関数では、スタックポインタの位置から引数がスタックのどの位置に積まれたかわかるので引数を取り出すことができます。同様にして fact(2) が呼び出されるときは、アドレス G の位置に引数 n の値 2 が格納されます。このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていくことがわかると思います。これが「値呼び」の仕組みです。
</p>
<p> 関数の実行が終了すると、スタックからリターンアドレスを取り出して呼び出し側に戻ります。このままではスタックに引数を積んだままの状態なので、呼び出し側の関数でスタックから引数を削除する処理を行います。なお、スタックに積んだ引数を削除するタイミングは、プログラミング言語によって異なります。
</p>
<p> fact は引数がひとつしかなかったので、今度は引数が複数ある関数を呼び出す場合を考えてみましょう。
</p>
<pre class="list">
リスト : 引数が複数ある場合の例

int foo(int a, int b, int c)
{
  return a * a + 2 * b + c;
}
</pre>
<pre class="fig">
   foo(1, 2, 3); と呼び出した場合

  アドレス Low [   ]       [   ]       [   ]       [   ]
               [   ]       [   ]       [   ]       [ 1 ] &lt;= SP
               [   ]       [   ]       [ 2 ] &lt;= SP [ 2 ]
               [   ]       [ 3 ] &lt;= SP [ 3 ]       [ 3 ]
          High [   ] &lt;= SP [   ]       [   ]       [   ]

             図 : 引数をスタックに積む順序
</pre>
<p> CPU が x86 の場合、実引数は右側から順番にスタックに積まれていくことに注意してください。ただし、引数を評価する順序は規定 <sup><a href="cpp07.html#note5">[*5]</a></sup> されていないので、左側の引数から評価する処理系があってもかまいません。その場合でも、実引数をスタックに積む順番は変わりません。
</p>
<p> たとえば、a = 10, b = 20, c = 30 として、foo(a, b, c) を呼び出す場合、変数から値を取り出す順番が a -&gt; b -&gt; c になるのか c -&gt; b -&gt; a になるのかは処理系に依存しますが、スタックに格納される実引数はどちらの方法でも Low [10 20 30] High になるということです。
</p>
<p> 簡単な例を示しましょう。次のプログラムは clang++ と g++ で実行結果が異なります。
</p>
<pre class="list">
リスト : 引数の評価順序 (sample70.cpp)

#include &lt;iostream&gt;
using namespace std;

int foo(string mes, int n)
{
  cout &lt;&lt; mes &lt;&lt; endl;
  return n * n;
}

void bar(int a, int b, int c)
{
  cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;
}

int main()
{
  int a = 10, b = 20, c = 30;
  bar(foo("foo", a), foo("bar", b), foo("baz", c));
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ clang++ sample70.cpp
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
foo
bar
baz
100 400 900
mhiroi@mhiroi-VirtualBox:~/cpp$ g++ sample70.cpp
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out 
baz
bar
foo
100 400 900
</pre>
<p> Clang++ の場合は左側の引数から評価され、g++ の場合は右側の引数から評価されていることがわかります。
</p>
<div class="note">
-- note --------<br>
<a name="note5">[*5]</a> 関数を呼び出すときの規則は、CPU によっては標準的な方法が定められており、これを「関数呼び出し規約」といいます。x86 の場合、デフォルトで用いられる規約に cdecl があります。
</div>

<h4>●局所変数とスタックの関係</h4>
<p> 引数と同様に、局所変数もスタック上に確保されます。なお、これから説明することは単純化した一般論であり、コンパイラの最適化によっては結果が異なる場合もあります。ご注意ください。
</p>
<pre class="list">
リスト : 局所変数の例

void foo(int n, int m)
{
  int a = n / m;
  int b = n % m;
  cout &lt;&lt; "n / m = " &lt;&lt; a &lt;&lt; ", n % m = " &lt;&lt; b &lt;&lt; endl;
}
</pre>
<p> 関数 foo は引数の商と剰余を求めて表示します。局所変数 a と b  はスタック上に確保されます。
</p>
<pre class="fig">
                スタック
  アドレス Low
              [    b           ] + &lt;= SP(3)
              [    a           ] +
              [ OLD FP         ] &lt;= SP(2) &lt;= FP(2)
              [リターンアドレス] &lt;= SP(1)
              [    n           ]
              [    m           ]
              [    x           ] + 呼び出し元関数の局所変数
              [    y           ] +
              [ OLD FP         ] &lt;= FP(1)
              [リターンアドレス]
         High [                ]

          図 : 局所変数の確保
</pre>
<p> 関数 foo が呼び出されたときのスタックポインタの位置は (1) です。局所変数をスタック上に確保するには、必要なサイズだけスタックポインタを Low アドレスに向かって移動させるだけです。ただし、単純に移動させると、リターンアドレスの位置がわからなくなるので、「フレームポインタ (FP)」を使ってスタックポインタを管理します。
</p>
<p> 局所変数を作る場合、まず FP の値をスタックに積みます。FP には呼び出し元関数のフレームポインタがセットされているので、その値をスタックに退避しないといけません。SP は (2) の位置に移動します。その値を FP にセットしてから局所変数のサイズだけ SP を移動させると (3)、局所変数 a, b の領域を確保することができます。
</p>
<p> 必要な局所変数のサイズはコンパイルした時点で決めることができます。また、フレームポインタを基準にすれば局所変数にアクセスすることも簡単にできます。この場合、引数のアクセスもスタックポインタではなくフレームポインタを使った方が簡単になります。
</p>
<p> 呼び出し元関数に戻るときは、まず FP の値を SP に戻します。すると SP は (2) の位置に戻るので、そこに積まれている値を POP して FP にセットします。これで呼び出し元関数のフレームポインタを元に戻すことができます。すると SP は (1) の位置にもどり、そこにはリターンアドレスが積まれているので、そのアドレスを取り出して呼び出し元関数に戻ることができます。
</p>
<p> 以上のことから、局所変数は関数の実行が終了した時点で解放されることもわかります。今まで局所変数として使っていた領域は、ほかの関数が実行されると、その局所変数もしくは引数を渡すための領域として使用されることになります。なお、コンパイラの最適化によっては、局所変数 a, b はスタック上に確保されるのではなく、レジスタに割り当てられる場合があります。
</p>
<p> レジスタは CPU 内部にある一時記憶メモリのことで、CPU の外部に接続されているメモリ（主記憶メモリ）とは異なります。一般に、レジスタはメモリよりも高速にアクセスすることができるので、局所変数をスタック上に作るよりもレジスタに割り当てたほうが、プログラムを高速に実行することができます。
</p>

<p> ところで、前々回説明した局所変数の値を交換するプログラム swap の動作も、スタックについて理解していれば当然な結果であると納得していただけると思います。
</p>

<pre class="list">
リスト : 値の交換（間違い）

#include &lt;iostream&gt;
using namespace std;

void swap(int a, int b)
{
  int tmp = a;
  a = b;
  b = tmp;
}

int main()
{
  int x = 10;
  int y = 20;
  swap(x, y);
  cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl;
  cout &lt;&lt; "y = " &lt;&lt; y &lt;&lt; endl;
}
</pre>
<p> swap が呼ばれた時点でのスタックの様子を下図に示します。
</p>
<pre class="fig">
  アドレス Low
           A  [   tmp          ] &lt;= SP
           B  [フレームポインタ]
           C  [リターンアドレス]
           D  [  a: 10         ] swap  の引数 &lt;-- ここの値を書き替え
           E  [  b: 20         ]              &lt;-- ることになる
           F  [  x: 10         ] main  の局所変数
           G  [  y: 20         ]
           H  [フレームポインタ]
         High

         図 : swap を呼び出したときのスタック（その１）
</pre>
<p> main の局所変数 x, y の値がスタック上にコピーされて swap に渡され、swap はこの領域の値を書き替えるので、x と y の値は変更されないことがわかります。
</p>
<p> Ｃ++で値を交換したい場合は参照を使います。
</p>
<pre class="list">
#include &lt;iostream&gt;
using namespace std;

void swap(int&amp; a, int&amp; b)
{
  int tmp = a;
  a = b;
  b = tmp;
}

int main()
{
  int x = 10;
  int y = 20;
  swap(x, y);
  cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl;
  cout &lt;&lt; "y = " &lt;&lt; y &lt;&lt; endl;
}
</pre>
<p> swap の引数は参照として宣言します。swap を呼び出したときのスタックは次のようになります。
</p>
<pre class="fig">
  アドレス Low
           A  [   tmp          ] &lt;= SP
           B  [フレームポインタ]
           C  [リターンアドレス]
           D  [ a: アドレス F  ] swap  の引数
           E  [ b: アドレス G  ]
           F  [  x: 10         ] main  の局所変数
           G  [  y: 20         ]
           H  [フレームポインタ]
         High

         図 : swap を呼び出したときのスタック（その２）
</pre>
<p> 前回の <a href="cpp06.html#appendix">Appendix</a> で説明したように、引数 a にはアドレス F が入っているので、main で定義した局所変数 x にアクセスすることができます。引数 b も同様です。
</p>
<h4>●スタック領域について</h4>
<p> いままでスタックについて説明してきましたが、それでは実際にはメモリのどこに割り当てられているのでしょうか。これは OS などの処理系に依存しますが、ここでは下図に示すようにスタック領域はプログラム本体の後ろに確保されると考えてください。
</p>
<pre class="fig">
アドレス Low  +-----------------+
              |                 |
              | プログラム領域  |
              |                 |
              +-----------------+
              |                 |
              | データ領域      |
              |                 |
              +-----------------+
              |                 |
              | ヒープ領域      |
              |                 |
              +-----------------+
              :       ↓        :
              :                 :
              :                 :
              :       ↑        :
              +-----------------+
              |                 |
              | スタック領域    |
              |                 |
        High  +-----------------+

              図 : メモリの配置
</pre>

<p> 外部変数はデータ領域に確保されます。ヒープ領域は「動的メモリ確保」で使用します。これはあとで説明します。スタックは高位アドレスから低位に向かって伸びていくので、再帰呼び出しの回数が多くなると (深くなるともいう) スタック領域が足りなくなって、他の領域を侵したときに Segmentation fault (コアダンプ) が発生します。簡単な例を示します。
</p>

<pre class="list">
リスト : スタックオーバーフロー (sample71.c)

#include &lt;iostream&gt;
using namespace std;

int sum(int n, int m)
{
  if (n == m)
    return n;
  else
    return n + sum(n + 1, m);
}

int main(void)
{
  for (int i = 100; i &lt; 10000000; i *= 10)
    cout &lt;&lt; i &lt;&lt; ", " &lt;&lt; sum(1, i) &lt;&lt; endl;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out
100, 5050
1000, 500500
10000, 50005000
100000, 705082704
Segmentation fault (コアダンプ)
</pre>
<p> 関数 sum は再帰呼び出しが深くなるとスタック領域をはみ出して他の領域を侵すことになるので、Segmentation fault (コアダンプ) が発生します。ちなみに、デフォルトのスタックサイズはコマンド ulimit で調べることができます。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 3806
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3806
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</pre>
<p> M.Hiroi の環境では 8192 kbyte でした。
</p>
<h4>●動的メモリ割り当て</h4>
<p> 今までは、変数を宣言することでメモリの確保を行なっていました。局所変数はスタック上に割り当てられ、大域変数はデータ領域に確保されます。どちらの変数もコンパイル時にその大きさが決定されるので、プログラムを実行している途中でサイズを変更することはできません。あらかじめ決められたサイズ以上にデータを書き込めば、ほかのデータを破壊し、最悪の場合、プログラムは暴走することになります。
</p>
<p> たとえば、テキストファイルを行単位で処理する場合、1 行の長さは不定長ですので、文字列長は実際に読み込んでみないとわかりません。このような場合、あらかじめ大域変数としてバッファを用意すると、そのバッファサイズより長い行が含まれているテキストファイルは処理できないことになります。
</p>
<p> また、余裕をもって大きいサイズのバッファを用意すると、メモリの無駄使いになってしまいます。最近のように、メインメモリが大量に搭載されていれば、あまり問題にならないかもしれませんが、使用できるメモリが少ない環境では、プログラムを実行することができないかもしれません。
</p>
<p> このような場合、プログラムの実行中に必要なサイズが判明した時点で、その大きさのメモリを、どこからか確保できるような手段が必要になります。このことを「動的メモリ割り当て」といいます。

<h4>●new と delete</h4>
<p> Ｃ++でメモリを動的に割り当てるには new 演算子を使います。new はヒープ領域から必要なメモリ領域を確保します。なお、本稿ではヒープ領域の位置はデータ領域の後ろにあるものとして説明します。
</p>
<pre class="fig">
Low アドレス +--------------+ ----
             |プログラム領域|  ↑
             +--------------+  │
             |              |  │
             |  データ領域  | プロセスで使う
             |              | スタック以外のメモリ
             +--------------+  │
             |  ヒープ領域  |  │ ===&gt; メモリを割り当てる
             |              |  │      new
             +--------------+  │
                    │         │ &lt;=== メモリを返還する
                 拡張する      │      delete 
                    ↓         │
             |              |  ↓
High アドレス+--------------+ ----

                    図 : ヒープ領域
</pre>
<p> 一般に、Ｃ/Ｃ++の標準ライブラリではヒープ領域が足りなくなると、空きメモリがあれば自動的に拡張されます。上図に示すように、高位アドレスに向かって拡張されます。
</p>
<p> new 演算子の書式を示します。
</p>
<pre class="item">
データ型* 変数 = new データ型
</pre>
<p> new は指定したデータ型を格納するメモリをヒープ領域から取得し、その先頭アドレス (ポインタ) を返します。確保したメモリは、領域の範囲内で使用するように注意して下さい。
</p>
<p> 使い終わったメモリは解放しないといけません。ヒープ領域が自動的に拡張されるからといって使ったまま放置したのでは、いつかはメモリ不足になってしまいます。メモリの解放には delete 演算子を使います。
</p>
<pre class="item">
delete newが返したポインタ
</pre>
<p> delete には new が返したポインタ (アドレス) を渡してください。delete に 0 を渡すこともできますが、その場合は何も起こりません。
</p>
<h4>●簡単な使用例</h4>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 動的メモリ割り当て (sample72.c)

#include &lt;iostream&gt;
using namespace std;

int main()
{
  int* p = new int;
  double* q = new double;
  int* a = new int[8];
  cout &lt;&lt; p &lt;&lt; endl;
  cout &lt;&lt; *p &lt;&lt; endl;
  cout &lt;&lt; q &lt;&lt; endl;
  cout &lt;&lt; *q &lt;&lt; endl;
  cout &lt;&lt; a &lt;&lt; endl;
  for (int i = 0; i &lt; 8; i++) cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
  *p = 100;
  *q = 1.2345;
  a[0] = 10;
  a[7] = 80;
  cout &lt;&lt; *p &lt;&lt; endl;
  cout &lt;&lt; *q &lt;&lt; endl;
  for (int i = 0; i &lt; 8; i++) cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;;
  // メモリの解放 (省略してもよい)
  delete p;
  delete q;
  delete[] a;
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/cpp$ ./a.out
0x9c04008
0
0x9c04018
0
0x9c04028
0 0 0 0 0 0 0 0 
100
1.2345
10 0 0 0 0 0 0 80 
</pre>
<p> new int で int 型に必要なメモリを、new double で double 型に必要なメモリを取得することできます。また、配列を確保することもできます。int a[8] と同じ大きさのメモリを取得するには、new int[8] とします。これで配列に必要な 32 バイトのメモリを確保することができます。この場合、メモリの解放は演算子 delete[] で行います。あとは、new の返り値をポインタにセットして、そのメモリ領域にアクセスすればいいわけです。
</p>

<P> ところで、取得したメモリ領域は使い終わったら元に戻す処理が必要になります。最近は、不要になったメモリ領域を自動的に回収する「ガベージコレクション (garbage collection, GC)」という機能を持つプログラミング言語が多くなりました。Ｃ/Ｃ++の場合、標準では GC をサポートしていないので、不要になったメモリ領域は自動的に回収されません。不要なメモリ領域は delete で解放することを忘れないでください。
</p>

<p> ただし、ほとんどの処理系ではプログラムの終了時に new で取得したメモリを delete で解放する必要はありません。プログラムで使用したメモリは実行終了時に解放されますが、このとき new で割り当てたメモリも解放されるようになっているからです。もちろん、例外的な処理系もあるでしょうが、一般的には new で取得したメモリを最後まで使うのであれば、delete を省略できると考えてもいいでしょう。
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="cpp06.html">PrevPage</a> | <a href="cpp.html">Ｃ++</a> | <a href="cpp08.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>