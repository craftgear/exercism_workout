<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 SQLite 超入門</title>
  <meta name="description" content="SQLite,入門">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881815</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 SQLite 超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="sqlite.html">SQLite</a> ]
<hr>
</div>
<section class="contents">
<h3>SQLite の基礎知識</h3>
<h4 id="abc11">●重複データの除外</h4>
<p> select 文で distinct を指定すると、重複データを除外することができます。
</p>
<pre class="item">
select distinct カラム名, ... from テーブル名 where 条件式;
</pre>
<p> 指定したカラムが 1 つの場合、カラムの値が等しければ重複データとみなします。簡単な例を示しましょう。
</p>
<pre>
sqllite&gt; select distinct class from girls_height;
class     
----------
A         
B         
C         
D         
sqlite&gt; select distinct class from girls_height where height &lt; 140;
class     
----------
C         
D         
sqlite&gt; select distinct class from girls_height where height &gt; 155;
class     
----------
D         
</pre>
<p> 複数のカラムを指定することもできます。この場合、各々のカラムの値が等しいとき、重複データとみなします。たとえば、item1, item2 と指定した場合、1, 2 と 1, 2 は等しいデータですが、1, 2 と 2, 1 は異なるデータになります。
</p>
<pre>
sqlite&gt; create table sample (item1, item2);
sqlite&gt; insert into sample (item1, item2) values
   ...&gt; (1, 1), (2, 2), (1, 3), (2, 1), (1, 2), (2, 3), (1, 1), (2, 2);
sqlite&gt; select * from sample;
item1       item2     
----------  ----------
1           1         
2           2         
1           3         
2           1         
1           2         
2           3         
1           1         
2           2         
sqlite&gt; select distinct item1, item2  from sample;
item1       item2     
----------  ----------
1           1         
2           2         
1           3         
2           1         
1           2         
2           3         
</pre>

<h4 id="abc12">●カラムに別名を付ける</h4>
<p> SQLite は as を使ってカラムに別名を付けることができます。
</p>
<pre class="item">
カラム名 as 別名, ...
</pre>
<p> たとえば、クラスの平均身長を求める場合、avg(height) を指定するとカラム名は avg(height) になりますが、as を使ってわかりやすい名前を付けることができます。
<pre>
sqlite&gt; select class, avg(height) from girls_height group by class;
class       avg(height)     
----------  ----------------
A           150.366666666667
B           150.133333333333
C           142.166666666667
D           151.9           
sqlite&gt; select class, avg(height) as average from girls_height group by class;
class       average         
----------  ----------------
A           150.366666666667
B           150.133333333333
C           142.166666666667
D           151.9           
</pre>
<p> もちろん、where や having の中でも別名を使うことができます
</p>
<pre>
sqlite&gt; select class, avg(height) as average from girls_height group by class having average &lt; 150;
class       average         
----------  ----------------
C           142.166666666667
</pre>
<h4 id="abc13">●カラムの四則演算</h4>
<p> SQLite はカラムの値で四則演算や他の計算を行うことができます。たとえば、平均身長との差分は次のように求めることができます。
</p>
<pre>
sqlite&gt; select avg(height) from girls_height;
148.641666666667
sqlite&gt; .mode column
sqlite&gt; .headers on
sqlite&gt; select name, height, height - 148.6 from girls_height;
name        height      height - 148.6    
----------  ----------  ------------------
Ada         148.7       0.0999999999999943
Alice       149.5       0.900000000000006 
Carey       133.7       -14.9             
Ellen       157.9       9.30000000000001  
Hanna       154.2       5.59999999999999  
Janet       147.8       -0.799999999999983
Linda       154.6       6.0               
Maria       159.1       10.5              
Miranda     148.2       -0.400000000000006
Sara        153.1       4.5               
Tracy       138.2       -10.4             
Violet      138.7       -9.90000000000001 
</pre>
<p> 関数 round(n, m) を使うと、小数以下 m 桁で数値 n を四捨五入することができます。
</p>
<pre>
sqlite&gt; select name, height, round(height - 148.6, 1) from girls_height;
name        height      round(height - 148.6, 1)
----------  ----------  ------------------------
Ada         148.7       0.1  
Alice       149.5       0.9  
Carey       133.7       -14.9
Ellen       157.9       9.3  
Hanna       154.2       5.6  
Janet       147.8       -0.8 
Linda       154.6       6.0  
Maria       159.1       10.5 
Miranda     148.2       -0.4 
Sara        153.1       4.5  
Tracy       138.2       -10.4
Violet      138.7       -9.9 
</pre>
<p> 複数のカラムの値を使って計算することもできます。簡単な例を示しましょう。
</p>
<pre>
sqlite&gt; create table sample1 (name text, price integer, num integer);
sqlite&gt; insert into sample1 (name, price, num)
   ...&gt; values ('apple', 128, 5),
   ...&gt; ('grape', 1900, 7),
   ...&gt; ('orange', 98, 10);
sqlite&gt; select *, price * num from sample1;
name        price       num         price * num
----------  ----------  ----------  -----------
apple       128         5           640        
grape       1900        7           13300      
orange      98          10          980        
sqlite&gt; select sum(price * num) from sample1;
sum(price * num)
----------------
14920           
</pre>

<h4 id="abc14">●VIEW の作成</h4>
<p> SQLite はテーブルからデータを抽出して新たなテーブルを作成することができます。これを VIEW といいます。VIEW は create view 文で作成します。
</p>
<pre class="item">
create view テーブル名 as select 文;
</pre>
<p> たとえば、クラスの平均身長を格納したテーブル class_average は次のように作成することができます。
</p>
<pre>
sqlite&gt; create view class_average as select class, avg(height) as average from girls_height group by class;
sqlite&gt; .table
class_average  girls_height   person         person1      
</pre>
<p> .table コマンドを実行すると、テーブル class_average が作成されていることがわかります。このテーブルを使って、データを抽出することができます。
</p>
<pre>
sqlite&gt; select * from class_average;
class       average         
----------  ----------------
A           150.366666666667
B           150.133333333333
C           142.166666666667
D           151.9           
sqlite&gt; select count(*) from class_average;
count(*)  
----------
4         
sqlite&gt; select class, max(average) from class_average;
class       max(average)
----------  ------------
D           151.9       
sqlite&gt; select class, min(average) from class_average;
class       min(average)    
----------  ----------------
C           142.166666666667
sqlite&gt; select avg(average) from class_average;
avg(average)    
----------------
148.641666666667
sqlite&gt; select * from class_average order by average;
class       average         
----------  ----------------
C           142.166666666667
B           150.133333333333
A           150.366666666667
D           151.9           
</pre>
<p> VIEW は実際にデータを保持しているわけではなく、select 文を実行するたびに、元のテーブルから必要なデータを抽出します。したがって、元のテーブルの値が書き換えられると、select 文の実行結果が異なることがあります。それから、VIEW に対してデータを追加したり削除することはできません。ご注意くださいませ。
</p>
<p> VIEW の削除は drop view 文で行います。
</p>
<pre class="item">
drop view テーブル名;
</pre>
<p> それでは実際に削除してみましょう。
</p>
<pre>
sqlite&gt; drop view class_average;
sqlite&gt; .table
girls_height  person        person1 
</pre>
<p> VIEW を削除しても、元のテーブルに影響を与えることはありません。
</p>
<h4 id="abc15">●インデックスの作成</h4>
<p> 一般に、データベースに格納されているデータが多くなると、検索に時間がかかるようになります。このような場合、あらかじめ「インデックス (index, 索引)」を作成しておくと、処理時間を短縮することができます。
</p>
<p> インデックスは create index 文で作成します。
</p>
<pre class="item">
create index インデックス名 on テーブル名(カラム名, ...);
</pre>
<p> インデックスはテーブル内のカラムが対象になります。指定するカラムは一つでも複数でもかまいません。また、同じテーブルでインデックスを複数設定することもできます。
</p>
<p> 簡単な例として、テーブル girls_height の name にインデックスを設定してみましょう。
</p>
<pre>
sqlite&gt; create index name_index on girls_height(name);
sqlite&gt; select * from girls_height where name = 'Sara';
id          name        height      class     
----------  ----------  ----------  ----------
10          Sara        153.1       B         
</pre>
<p> インデックスを生成しても、select 文は今までと同じように使うことができます。もちろん、insert into 文でデータを挿入することもできます。
</p>
<p> 作成したインデックスは .indices コマンドで確認することができます。
</p>
<pre class="item">
.indices [テーブル名]
</pre>
<pre>
sqlite&gt; .indices
name_index
sqlite&gt; .indices girls_height
name_index
</pre>
<p> インデックスは drop index 文で削除することができます。
</p>
<pre class="item">
drop index インデックス名;
</pre>
<p> それでは実際に削除してみましょう。
</p>
<pre>
sqlite&gt; drop index name_index;
sqlite&gt; .indices
sqlite&gt; 
</pre>
<h4>●ユニークインデックス</h4>
<p> インデックスの対象となるカラムは重複データがあってもかまいませんが、重複データを許可しないように制約をかけることができます。これを「ユニークインデックス」といいます。設定は簡単で、create index でインデックスを生成するとき、index の前に unique を指定するだけです。
</p>
<pre class="item">
create unique index on テーブル名(カラム名, ...);
</pre>
<p> テーブル girls_height のカラム name は重複データがないので、ユニークインデックスを作成することができます。
</p>
<pre>
sqlite&gt; select * from girls_height where name = 'Violet';
id          name        height      class     
----------  ----------  ----------  ----------
12          Violet      138.7       D         
sqlite&gt; insert into girls_height (id, name, height, class)
   ...&gt; values (13, 'Alice', 145.0, 'A');
Error: UNIQUE constraint failed: girls_height.name
</pre>
<p> このように、重複したデータを挿入しようとするとエラーになります。
</p>
<h4 id="abc16">●.dump と .read</h4>
<p> .dump コマンドはデータベースの内容を SQL 文の形式で出力 (ダンプ) します。
</p>
<pre class="item">
.dump [テーブル名]
</pre>
<p> テーブル名を省略すると、データベースの全ての内容がダンプされます。girls_height の内容をダンプすると次のように表示されます。
</p>
<pre>
sqlite&gt; .dump girls_height
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE girls_height (id integer, name text, height real, class text);
INSERT INTO "girls_height" VALUES(1,'Ada',148.7,'A');
INSERT INTO "girls_height" VALUES(2,'Alice',149.5,'B');
INSERT INTO "girls_height" VALUES(3,'Carey',133.7,'C');
INSERT INTO "girls_height" VALUES(4,'Ellen',157.9,'D');
INSERT INTO "girls_height" VALUES(5,'Hanna',154.2,'A');
INSERT INTO "girls_height" VALUES(6,'Janet',147.8,'B');
INSERT INTO "girls_height" VALUES(7,'Linda',154.6,'C');
INSERT INTO "girls_height" VALUES(8,'Maria',159.1,'D');
INSERT INTO "girls_height" VALUES(9,'Miranda',148.2,'A');
INSERT INTO "girls_height" VALUES(10,'Sara',153.1,'B');
INSERT INTO "girls_height" VALUES(11,'Tracy',138.2,'C');
INSERT INTO "girls_height" VALUES(12,'Violet',138.7,'D');
CREATE UNIQUE INDEX unique_name on girls_height(name);
COMMIT;
</pre>
<p> .output コマンドを使うと、画面に出力された情報をファイルに保存することができます。
</p>
<pre class="item">
.output ファイル名
</pre>
<p> .output のデフォルト値は標準出力 (stdout) になっています。.output で出力先をファイルに切り替えたあと、.output stdout を実行すれば、出力先は元の画面に戻ります。
</p>
<p> それでは実際に試してみましょう。
</p>
<pre>
sqlite&gt; .output ./girls_height.txt
sqlite&gt; .dump girls_height
sqlite&gt; .output stdout
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/sqlite$ cat girls_height.txt
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE girls_height (id integer, name text, height real, class text);
INSERT INTO "girls_height" VALUES(1,'Ada',148.7,'A');
INSERT INTO "girls_height" VALUES(2,'Alice',149.5,'B');
INSERT INTO "girls_height" VALUES(3,'Carey',133.7,'C');
INSERT INTO "girls_height" VALUES(4,'Ellen',157.9,'D');
INSERT INTO "girls_height" VALUES(5,'Hanna',154.2,'A');
INSERT INTO "girls_height" VALUES(6,'Janet',147.8,'B');
INSERT INTO "girls_height" VALUES(7,'Linda',154.6,'C');
INSERT INTO "girls_height" VALUES(8,'Maria',159.1,'D');
INSERT INTO "girls_height" VALUES(9,'Miranda',148.2,'A');
INSERT INTO "girls_height" VALUES(10,'Sara',153.1,'B');
INSERT INTO "girls_height" VALUES(11,'Tracy',138.2,'C');
INSERT INTO "girls_height" VALUES(12,'Violet',138.7,'D');
CREATE UNIQUE INDEX unique_name on girls_height(name);
COMMIT;
</pre>
<p> ダンプしたデータは .read コマンドで読み込むことができます。
</p>
<pre class="item">
.read ファイル名
</pre>
<p> それでは girls_height.txt を .read で読み込んでみましょう。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/sqlite$ sqlite3 sample02.sqlite
SQLite version 3.11.0 2016-02-15 17:29:24
Enter ".help" for usage hints.
sqlite&gt; .table
sqlite&gt; .read ./girls_height.txt

sqlite&gt; .table
girls_height
sqlite&gt; .schema
CREATE TABLE girls_height (id integer, name text, height real, class text);
CREATE UNIQUE INDEX unique_name on girls_height(name);
sqlite&gt; select * from girls_height;
1|Ada|148.7|A
2|Alice|149.5|B
3|Carey|133.7|C
4|Ellen|157.9|D
5|Hanna|154.2|A
6|Janet|147.8|B
7|Linda|154.6|C
8|Maria|159.1|D
9|Miranda|148.2|A
10|Sara|153.1|B
11|Tracy|138.2|C
12|Violet|138.7|D
</pre>
<p> データベース sample02.sqlite は空なので、テーブルは何もありません。次に、.read コマンドで girls_height.txt を読み込みます。すると、テーブル girls_height が作成され、データも読み込まれていることがわかります。
</p>

<h4 id="abc17">●トリガーの作成</h4>
<p> あるテーブルのデータを更新したとき、同時に別のテーブルのデータも更新できると便利な場合があります。このような場合、役に立つ機能が「トリガー (trigger)」です。トリガーを使うと、insert や update などのイベントが発生したときに、指定した SQL 文を実行させることができます。なお、トリガーの書式はけっこう複雑なので、本稿では基本的なことのみを説明します。詳しい説明は <a href="sqlite.html#cite">参考 URL 3</a> をお読みください。
</p>
<p> トリガーは create trigger 文で作成します。データの挿入 (insert), 削除 (delete), 更新 (update) したときのトリガーは次のように定義します。
</p>
<pre class="item">
create trigger トリガー名 insert on テーブル名
  begin
    SQL 文;
    ...
  end;

create trigger トリガー名 delete on テーブル名
  begin
    SQL 文;
    ...
  end;

create trigger トリガー名 update of カラム名 on テーブル名
  begin
    SQL 文;
    ...
  end;
</pre>
<p> これでテーブルを操作 (insert, delete, update) したとき、begin ... end の中の SQL 文が実行されます。この中で更新前後のカラムの値を次の文で取得することができます。
</p>
<pre class="item">
old.カラム名 : 更新前の値 (delete, update のとき有効)
new.カラム名 : 更新後の値 (insert, update のとき有効)
</pre>
<p> 簡単な例を示しましょう。名前 (name) と値 (val) を格納するテーブル test と値の更新記録を格納するテーブル change を作ります。change には名前 (name), 更新前の値 (old_val), 更新後の値 (new_val) を記録します。これはトリガーを使うと簡単に実現することができます。
</p>
<pre>
sqlite&gt; create table test (name text, val integer);
sqlite&gt; create table change (name text, old_val integer, new_val);
sqlite&gt; create trigger test_trigger update of val on test
   ...&gt; begin
   ...&gt; insert into change (name, old_val, new_val) values
   ...&gt; (old.name, old.val, new.val);
   ...&gt; end;
sqlite&gt; .schema
CREATE TABLE test (name text, val integer);
CREATE TABLE change (name text, old_val integer, new_val);
CREATE TRIGGER test_trigger update of val on test
begin
insert into change (name, old_val, new_val) values
(old.name, old.val, new.val);
end;
</pre>
<p> テーブル test のカラム val の値を update で更新するときにトリガーを指定します。begin 文の中では、old.name, old.val, new.val で名前と更新前後の値を取り出して、insert into 文でテーブル change に挿入します。なお、トリガーの定義はコマンド .schema で確認することができます。
</p>
<p> 次にテーブル test にデータを挿入します。
</p>
<pre>
sqlite&gt; .mode column
sqlite&gt; .headers on
sqlite&gt; insert into test (name, val) values
   ...&gt; ('foo', 1), ('bar', 2), ('baz', 3);
sqlite&gt; select * from test;
name        val
----------  ----------
foo         1
bar         2
baz         3
</pre>
<p> 今回定義したトリガーは update なので、insert では起動しません。それでは、update で val の値を更新してみましょう。
</p>
<pre>
sqlite&gt; update test set val = 10 where name = 'foo';
sqlite&gt; select * from test;
name        val       
----------  ----------
foo         10        
bar         2         
baz         3         
sqlite&gt; select * from change;
name        old_val     new_val   
----------  ----------  ----------
foo         1           10        
sqlite&gt; update test set val = 20 where name = 'bar';
sqlite&gt; update test set val = 30 where name = 'baz';
sqlite&gt; select * from change;
name        old_val     new_val
----------  ----------  ----------
foo         1           10
bar         2           20
baz         3           30
</pre>
<p> 値を更新すると、テーブル change にその記録が保存されていることがわかります。
</p>
<p> 次は、delete 文で test からデータを削除したとき、change からもデータを同時に削除してみましょう。
</p>
<pre>
sqlite&gt; create trigger test_del_trigger delete on test
   ...&gt; begin
   ...&gt; delete from change where name = old.name;
   ...&gt; end;
</pre>
<p> トリガーの定義は簡単ですね。削除したデータの名前は old.name からわかるので、それと同じ名前を change から全て削除するだけです。それでは実際に試してみましょう。
</p>
<pre>
sqlite&gt; update test set val = 100 where name = 'foo';
sqlite&gt; select * from change;
name        old_val     new_val   
----------  ----------  ----------
foo         1           10        
bar         2           20        
baz         3           30        
foo         10          100       
sqlite&gt; delete from test where name = 'foo';
sqlite&gt; select * from test;
name        val       
----------  ----------
bar         20        
baz         30        
sqlite&gt; select * from change;
name        old_val     new_val   
----------  ----------  ----------
bar         2           20        
baz         3           30        
</pre>
<p> このように、test から foo を削除すると、同時に change からも foo を削除することができます。
</p>
<p> トリガーの削除は drop trigger 文で行います。
</p>
<pre class="item">
drop trigger トリガー名;
</pre>
<p> それでは実際にトリガーを削除してみましょう。
</p>
<pre>
sqlite&gt; .schema
CREATE TABLE test (name text, val integer);
CREATE TABLE change (name text, old_val integer, new_val);
CREATE TRIGGER test_trigger update of val on test
begin
insert into change (name, old_val, new_val) values
(old.name, old.val, new.val);
end;
CREATE TRIGGER test_del_trigger delete on test
begin
delete from change where name = old.name;
end;
sqlite&gt; drop trigger test_del_trigger;
sqlite&gt; .schema
CREATE TABLE test (name text, val integer);
CREATE TABLE change (name text, old_val integer, new_val);
CREATE TRIGGER test_trigger update of val on test
begin
insert into change (name, old_val, new_val) values
(old.name, old.val, new.val);
end;
</pre>
<p> drop trigger test_del_trigger でトリガー test_del_trigger が削除されていることがわかります。
</p>
<h4 id="abc18">●テーブルの結合</h4>
<p> RDBMS は複数のテーブルを結合してデータを取得することができます。これを「テーブルの結合」とか「表結合」といいます。SQLite でもテーブルの結合はサポートされています。本稿では表結合の基本的な機能を簡単に説明します。
</p>
<h4>●内部結合</h4>
<p> 「内部結合 (inner join)」は指定したカラムの値が一致するデータだけを取り出す方法です。以下に書式を示します。
</p>
<pre class="item">
select テーブル.カラム, ... from テーブル1
inner join テーブル2 on テーブル1.カラムa = テーブル2.カラムb
</pre>
<p> テーブル 1 のカラム a とテーブル 2 のカラム b を比較して、同じ値のデータをテーブル 2 から取り出してテーブル 1 に結合します。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
sqlite&gt; create table person (id integer, name text);
sqlite&gt; insert into person (id, name) values
   ...> (1, 'foo'), (2, 'bar'), (3, 'baz'), (4, 'oops');
sqlite&gt; create table color_table (id integer, color text);
sqlite&gt; insert into color_table (id, color) values
   ...> (1, 'red'), (2, 'blue'), (3, 'green'),
   ...> (3, 'red'), (1, 'blue'), (2, 'green'), (1, 'pink');
sqlite&gt; .mode column
sqlite&gt; .headers on
sqlite&gt; select * from person;
id          name      
----------  ----------
1           foo       
2           bar       
3           baz       
4           oops      
sqlite&gt; select * from color_table;
id          color     
----------  ----------
1           red       
2           blue      
3           green     
3           red       
1           blue      
2           green     
1           pink      
</pre>
<p> テーブル person は id と name を保持し、テーブル color_table では id と color を保持しています。内部結合を使うと、name と color の関係を簡単に求めることができます。
</p>
<pre>
sqlite&gt; select * from person inner join color_table on person.id = color_table.id;
id          name        id          color
----------  ----------  ----------  ----------
1           foo         1           blue 
1           foo         1           pink 
1           foo         1           red  
2           bar         2           blue 
2           bar         2           green
3           baz         3           green
3           baz         3           red  
</pre>
<p> 同じデータが複数ある場合、その数だけテーブル結合が行われます。person.id と color_table.id が等しいデータを取り出して結合するので、foo には 3 つの色 (bule, pink, red)、bar には 2 つの色 (blue, green), baz には 2 つの色 (green, red) があることがわかります。oops の id は 4 ですが、color_table の id に 4 はないので、id = 4 のデータが取り出されることはありません。
</p>
<h4>●外部結合</h4>
<p> 「外部結合 (outer join)」は指定したカラムの値が一致するデータだけではなく、どちらかのテーブルにデータが存在すれば、それもいっしょに取り出す方法です。以下に書式を示します。
</p>
<pre class="item">
select テーブル.カラム, ... from テーブル1
left outer join テーブル2 on テーブル1.カラムa = テーブル2.カラムb
</pre>
<p> left outer join は条件式 テーブル1.カラムa = テーブル2.カラムb を満たさない場合でも、テーブル 1 (左側) のデータを取り出します。SQL では left のほかに right や full を指定することができますが、SQLite では left のみをサポートしています。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
sqlite&gt; select * from person left outer join color_table on person.id = color_table.id;
id          name        id          color     
----------  ----------  ----------  ----------
1           foo         1           blue      
1           foo         1           pink      
1           foo         1           red       
2           bar         2           blue      
2           bar         2           green     
3           baz         3           green     
3           baz         3           red       
4           oops       
</pre>
<p> id が 4 のデータは person にはありますが color_table にはありません。そのような場合でも、外部結合すると person の id = 4 のデータを取り出すことができます。
</p>
<h4>●交差結合</h4>
<p> 「交差結合 (cross join)」は 2 つのテーブルのデータの全ての組み合わせを取得する方法です。プログラミング言語でいえば、2 つの集合の「直積集合」を求める処理といえるでしょう。以下に書式を示します。
</p>
<pre class="item">
select テーブル.カラム, ... from テーブル1 closs join テーブル2 [on 結合条件];
</pre>
<p> 交差結合の場合、on 結合条件 を省略することが多いようです。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
sqlite&gt; select * from person;
id          name      
----------  ----------
1           foo       
2           bar       
3           baz       
4           oops      
sqlite&gt; create table sports (id integer, name text);
sqlite&gt; insert into sports (id, name) values
   ...> (1, 'baseball'), (2, 'tennis'), (3, 'basketball');
sqlite&gt; select * from sports;
id          name      
----------  ----------
1           baseball  
2           tennis    
3           basketball
sqlite&gt; select * from person cross join sports;
id          name        id          name      
----------  ----------  ----------  ----------
1           foo         1           baseball  
1           foo         2           tennis    
1           foo         3           basketball
2           bar         1           baseball  
2           bar         2           tennis    
2           bar         3           basketball
3           baz         1           baseball  
3           baz         2           tennis    
3           baz         3           basketball
4           oops        1           baseball  
4           oops        2           tennis    
4           oops        3           basketball
</pre>
<p> テーブル sports にスポーツの種類 (baseball, tennis, basketball) を格納します。そして、person と sports の交差結合を求めると、テーブル person のデータひとつひとつに対して sports テーブルのデータをひとつずつ結合したデータを取得することができます。
</p>
<h4>●自然結合</h4>
<p> natural というキーワードを指定すると、2 つのテーブルで同じカラム名のデータを比較します。これを「自然結合」といいます。この場合、on 結合条件の指定は必要ありません。
</p>
<pre class="item">
select テーブル.カラム, ... from テーブル1 natural inner join テーブル2
select テーブル.カラム, ... from テーブル1 natural left outer join テーブル2
</pre>
<p> ただし、同じ名前のカラムがなかったり、同じ名前のカラムが複数存在する場合、自然結合を使用することはできません。
</p>
<p> 簡単な例を示しましょう。
</p>
<pre>
sqlite&gt; select * from person natural inner join color_table;
id          name        color     
----------  ----------  ----------
1           foo         blue      
1           foo         pink      
1           foo         red       
2           bar         blue      
2           bar         green     
3           baz         green     
3           baz         red       
sqlite&gt; select * from person natural left outer join color_table;
id          name        color     
----------  ----------  ----------
1           foo         blue      
1           foo         pink      
1           foo         red       
2           bar         blue      
2           bar         green     
3           baz         green     
3           baz         red       
4           oops                  
</pre>
<p> 自然結合の場合、同名のカラムはひとつだけしか表示しません。
</p>
<h4>●自己結合</h4>
<p> テーブル結合は自分自身に対しても行うことができます。これを「自己結合」といいます。自己結合するときはテーブル名の後ろに別名を定義します。
</p>
<pre class="item">
select 別名1.カラム名, 別名2.カラム名, ... from テーブル名 別名1
[inner join | left outer join | cross join] テーブル名 別名2 on 結合条件;
</pre>
<p> 簡単な例として、テーブル内のデータの直積集合を求めてみましょう。最初にテーブルを定義します。
</p>
<pre>
sqlite&gt; create table colors (id integer, color text);
sqlite&gt; insert into colors (id, color) values
   ...> (1, 'red'), (2, 'blue'), (3, 'yellow'), (4, 'green');
sqlite&gt; .headers on
sqlite&gt; .mode column
sqlite&gt; select * from colors;
id          color     
----------  ----------
1           red       
2           blue      
3           yellow    
4           green     
</pre>
<p> テーブル colors には 4 つの色が登録されています。色の直積集合を求める場合、自己結合を使うと簡単です。
</p>
<pre>
sqlite&gt; select c1.color, c2.color from colors c1 cross join colors c2; 
color       color     
----------  ----------
red         red       
red         blue      
red         yellow    
red         green     
blue        red       
blue        blue      
blue        yellow    
blue        green     
yellow      red       
yellow      blue      
yellow      yellow    
yellow      green     
green       red       
green       blue      
green       yellow    
green       green     
</pre>
<p> colors の別名に c1 と c2 を使います。select 文で取り出すデータを c1.color, c2.color とすると、color の直積集合を求めることができます。同じ色を省きたい場合は、where で条件 c1.color != c2.color を追加するだけです。この場合、4 色から 2 色を選ぶ順列を求めることになります。
</p>
<pre>
sqlite&gt; select c1.color, c2.color from colors c1 cross join colors c2 where c1.color != c2.color; 
color       color     
----------  ----------
red         blue      
red         yellow    
red         green     
blue        red       
blue        yellow    
blue        green     
yellow      red       
yellow      blue      
yellow      green     
green       red       
green       blue      
green       yellow    
</pre>
<p> 組み合わせを求めたい場合は where の条件を c1.color &lt c2.color に変更するだけです。
</p>
<pre>
sqlite&gt; select c1.color, c2.color from colors c1 cross join colors c2 where c1.color &lt; c2.color; 
color       color     
----------  ----------
red         yellow    
blue        red       
blue        yellow    
blue        green     
green       red       
green       yellow    
</pre>
<p> この他にも、自己結合には便利な使い方があります。興味のある方は <a href="sqlite.html#cite">参考 URL 3</a> をお読みくださいませ。
</p>
</section>
<hr>
<div align="center">
<b>Copyright (C) 2016 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="sqlite.html">SQLite</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>