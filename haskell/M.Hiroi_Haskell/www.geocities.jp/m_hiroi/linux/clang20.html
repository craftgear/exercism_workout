<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881809</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang19.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang21.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>ハッシュ法</h3>
<p> 今回は高速な探索アルゴリズムである「ハッシュ法 (hashing) 」を取り上げます。ハッシュ法は、コンパイラやインタプリタなどで予約語、関数名、変数名などの管理に使われている方法です。また、Perl, Python, Ruby など連想配列をサポートしているスクリプト言語では、その実装にハッシュ法が使われています。
</p>
<p> ハッシュ法は、設計をうまく行えば 1 回の比較でデータを見つけることができます。実際、コンパイラの予約語のように探索するデータが固定されている場合は、そのように設計することが可能です。不特定多数のデータが探索対象になる場合は、すべてのデータを 1 回の比較で見つけることはできませんが、数回程度の比較で見つけるように設計することは可能です。 今回はＣ言語でハッシュ法のプログラムを作ってみましょう。
</p>

<h4>●ハッシュ法の仕組み</h4>
<p> ハッシュ法は「ハッシュ表 (hash table) 」と呼ばれるデータを格納する配列と、データを数値に変換する「ハッシュ関数 (hash function) 」を用意します。たとえば、ハッシュ表の大きさを M とすると、ハッシュ関数はデータを 0 から M - 1 までの整数値に変換します。この値を「ハッシュ値 (hash value) 」と呼びます。ハッシュ値はハッシュ表の添字に対応し、この位置にデータを格納します。つまり、ハッシュ関数によってデータを格納する位置を決める探索方法がハッシュ法なのです。
</p>
<p> ハッシュ法で不特定多数のデータを扱う場合、異なるデータでも同じハッシュ値が生成される可能性があります。これをハッシュ値の「衝突 (collision) 」といいます。つまり、データをハッシュ表に登録しようとしても、すでに先客が居座っているわけです。この場合、2 種類の解決方法があります。
</p>
<p> 第 1 の方法はハッシュ表に複数のデータを格納することです。配列には一つのデータしか格納できないので、複数個のデータをまとめて格納する工夫が必要になります。このときよく利用されるデータ構造が「連結リスト (linked list) 」です。ハッシュ表からデータを探索する場合、まずハッシュ値を求め、そこに格納されている連結リストの中からデータを探索します。これを「チェイン法 (chaining) 」といいます。連結リストのほかに二分木を使う方法もあります。
</p>
<p> 第 2 の方法は空いている場所を探して、そこにデータを入れる方法です。この場合、最初とは違うハッシュ関数を用意して、新しくハッシュ値を計算させて場所を決めます。この処理を空いている場所が見つかるまで繰り返します。空き場所が見つからない場合、つまりハッシュ表が満杯の場合はデータを挿入することはできません。この方法を「オープンアドレス法 (open addressing) 」といいます。
</p>
<h4>●チェイン法</h4>
<p> それでは、チェイン法から説明します。チェイン法の場合、ハッシュ表にはデータをそのまま格納しないで、連結リストへのポインタを格納します。ハッシュ表からデータを探索する場合、まずハッシュ値を求め、そこに格納されている連結リストの中からデータを探索します。
</p>
<p> 簡単な例を示しましょう。次の図を見てください。
</p>
<pre class="fig">
     ハッシュ値 0 1 2 3 4 5 6
    --------------------------
                A B C D E F G
                H I J K L M N
                O P Q R S T U
                V W X Y Z

HASH TABLE 0 [        ] -&gt; [O] -&gt; [H] -&gt; [A] -&gt; NULL
           1 [        ] -&gt; [B] -&gt; NULL
           2 [  NULL  ]
           3 [        ] -&gt; [Y] -&gt; [D] -&gt; NULL
           4 [  NULL  ]
           5 [        ] -&gt; [M] -&gt; [F] -&gt; NULL
           6 [        ] -&gt; [G] -&gt; NULL

                図 : チェイン法
</pre>
<p> たとえば、上図のようにハッシュ関数とハッシュ表が構成されているとします。データ A の場合、ハッシュ値は 0 なのでハッシュ表の 0 の位置に格納されている連結リストを探索します。A は連結リストの中に登録されているので探索は成功です。データ C の場合、ハッシュ値は 2 ですが、ハッシュ表に連結リストがないので探索は失敗です。データ U の場合、ハッシュ値は 6 ですが、連結リストの中に U が登録されていないので探索は失敗です。
</p>
<p> ところで、チェイン法はハッシュ値の衝突が頻繁に発生すると、データを格納する連結リストが長くなるので、探索に時間がかかることになります。効率良く探索するには、うまくハッシュ値を分散させることが必要になります。
</p>
<h4>●ハッシュ表と操作関数</h4>
<p> それでは、チェイン法のプログラムを作りましょう。プログラムを簡単にするため、今回はキーを文字列、値を整数 (int) に限定します。最初にデータ構造を定義します。次のリストを見てください。
</p>
<pre class="list">
リスト : ハッシュ表の定義

// 連結リスト
typedef struct cell {
  char *key;
  int  value;
  struct cell *next;
} Cell;

// ハッシュ表
typedef struct {
  int size, count;
  Cell **table;
} HashTable;

</pre>
<p> 構造体 Cell が連結リストのセルを表します。メンバ変数 key がキーを、value が値を格納します。next が次のセルへのポインタです。連結リストの終端は NULL で表します。構造体 HashTable がハッシュ表を表します。メンバ変数 size がハッシュ表の大きさ、count がデータ数、table がハッシュ表の本体になります。table はセルへのポインタを格納する配列になるので、データ型は Cell ** になります。
</p>
<p> 次はハッシュ表の操作関数を説明します。下表を見てください。
</p>
<table border=1>
<caption>表 : ハッシュ表の操作関数</caption>
<thead>
  <tr><th>関数名</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>HashTable *make_hash_table(int size);</td><td>大きさが size のハッシュ表を作成する</td></tr>
  <tr><td>int search_hash(HashTable *ht, const char *key, bool *err);</td><td>ハッシュ表 ht からキー key を探索してその値を返す。<br>見つからない場合は *err に false をセットして 0 を返す。</td></tr>
  <tr><td>bool insert_hash(HashTable *ht, const char *key, int val);</td><td>ハッシュ表 ht にキー key と値 val を追加する。<br>既存のキーは値を書き換えて false を返す。新しいキーは true を返す。</td></tr>
  <tr><td>bool delete_hash(HashTable *ht, const char *key);</td><td>ハッシュ表 ht からキー key とその値を削除する。<br>削除できた場合は true を返す。キーが見つからない場合は false を返す。</td></tr>
  <tr><td>void foreach_hash(void (*f)(const char *, int), HashTable *ht);</td><td>ハッシュ表 ht に格納されているキーと値を関数 f に渡して呼び出す。</td></tr>
  <tr><td>bool is_empy_hash(HashTable *ht);</td><td>ハッシュ表 ht が空ならば true を返す。</td></tr>
  <tr><td>int length_hash(HashTable *ht);</td><td>ハッシュ表 ht に格納されているデータ数を返す。</td></tr>
  <tr><td>void clear_hash(HashTable *ht);</td><td>ハッシュ表 ht を空にする。</td></tr>
</tbody>
</table>
<p> 関数 search_hash は key を見つけたら *err に true を、そうでなければ false をセットします。関数 insert_hash は、引数 key と同じキーを見つけた場合は、その値を引数 val に書き換えて false を返します。新規のキーであれば、key と val をハッシュ表に追加して true を返します。関数 delete_hash はキーを削除できた場合は true を、キーが見つからない場合は false を返します。あとは特に難しいところはないと思います。
</p>
<h4>●セルの生成と廃棄</h4>
<p> 次は、セルの生成と廃棄を行う関数 make_cell と delete_cell を作ります。
</p>
<pre class="list">
リスト : セルの生成と廃棄

// セルの生成
Cell *make_cell(const char *key, int val, Cell *next)
{
  Cell *cp = malloc(sizeof(Cell));
  if (cp != NULL) {
    cp-&gt;key = malloc(strlen(key) + 1);
    if (cp-&gt;key == NULL) {
      free(cp);
      return NULL;
    }
    strcpy(cp-&gt;key, key);
    cp-&gt;value = val;
    cp-&gt;next = next;
  }
  return cp;
}

// セルの廃棄
void delete_cell(Cell *cp)
{
  while (cp != NULL) {
    Cell *xs = cp-&gt;next;
    free(cp-&gt;key);
    free(cp);
    cp = xs;
  }
}
</pre>
<p> 最初に malloc で Cell 本体の領域を取得します。次に、文字列 key の領域を取得して、関数 strcpy でコピーします。あとは、メンバ変数 value と next に引数の値をセットして、return でセルを返します。セルの廃棄も簡単です。while ループでセルをたどり、文字列の領域を free(key) で解放してから、セル本体を free(cp) で解放します。
</p>
<h4>●ハッシュ表の生成と廃棄</h4>
<p> 次はハッシュ表を生成する関数 make_hash_table と廃棄する関数 delete_hash_table を作ります。
</p>
<pre class="list">
リスト : ハッシュ表の生成と廃棄

// ハッシュ表の生成
HashTable *make_hash_table(int size)
{
  HashTable *ht = malloc(sizeof(HashTable));
  if (ht != NULL) {
    ht-&gt;size = size;
    ht-&gt;table = malloc(sizeof(Cell *) * size);
    if (ht-&gt;table == NULL) {
      free(ht);
      return NULL;
    }
    // 初期化
    for (int i = 0; i &lt; size; i++) ht-&gt;table[i] = NULL;
  }
  return ht;
}

// ハッシュ表の廃棄
void delete_hash_table(HashTable *ht)
{
  for (int i = 0; i &lt; ht-&gt;size; i++)
    delete_cell(ht-&gt;table[i]);
  free(ht);
}
</pre>
<p> 最初に malloc で HashTable 本体の領域を取得します。次に、ハッシュ表 (table) の領域を取得します。大きさは sizeof(Cell *) * size になります。Cell ではなく Cell  * を指定することに注意してください。table は NULL で初期化します。HashTable を廃棄する delete_hash_table も簡単です。delete_cell で table に格納されている連結リストを廃棄してから、free(ht) で HashTable 本体を解放します。
</p>
<h4>●ハッシュ関数の作成</h4>
<p> 次は、ハッシュ値を計算する関数 hash_func を作ります。
</p>
<pre class="list">
リスト : ハッシュ関数

int hash_func(HashTable *ht, const char *key)
{
  unsigned int value = 0;
  for (; *key != '\0'; key++)
    value = (value &lt;&lt; 3) + *key;
  return value % ht-&gt;size;
}
</pre>
<p> value を 3 ビット左シフトして、そこに *key を加算していきます。最後に、value % ht-&gt;size を返します。適当な関数ですが、これでもハッシュ法は十分に機能します。ところで、<A href="clang.html#cite">参考文献 3</A> ではハッシュ表の大きさを M とすると、<CITE>『M を素数にしておくと安心である』</CITE> とのことです。
</p>
<h4>●データの探索</h4>
<p> 次は、データの探索と挿入を行う関数 search_hash を作ります。
</p>
<pre class="list">
リスト : データの探索

// 作業用関数
Cell *search_cell(HashTable *ht, const char *key, int hval)
{
  Cell *cp = ht-&gt;table[hval];
  for (; cp != NULL; cp = cp-&gt;next) {
    if (strcmp(cp-&gt;key, key) == 0) {
      return cp;
    }
  }
  return NULL;
}

int search_hash(HashTable *ht, const char *key, bool *err)
{
  Cell *cp = search_cell(ht, key, hash_func(ht, key));
  if (cp != NULL) {
    *err = true;
    return cp-&gt;value;
  }
  *err = false;
  return 0;
}
</pre>
<p> 関数 serach_cell は作業用の関数で、ハッシュ表 ht->table[hval] からキー key と等しいセルを線形探索します。見つからなければ NULL を返します。関数 search_hash は hash_func でハッシュ値を求め、それを search_cell に渡してセルを求めます。見つけた場合は *err に true をセットして、値 value を返します。見つからない場合は *err に false をセットして 0 を返します。
</p>
<h4>●データの挿入</h4>
<p> 次はデータを挿入する関数 insert_hash を作ります。
</p>
<pre class="list">
リスト : データの挿入

bool insert_hash(HashTable *ht, const char *key, int val)
{
  int hval = hash_func(ht, key);
  Cell *cp = search_cell(ht, key, hval);
  if (cp == NULL) {
    // 先頭に追加
    ht-&gt;table[hval] = make_cell(key, val, ht-&gt;table[hval]);
    ht-&gt;count++;
    return true;
  } else {
    // 値を書き換える
    cp-&gt;value = val;
    return false;
  }
}
</pre>
<p> insert_hash は search_cell で key と等しいセルを求めます。見つからない場合は新しいセルを作って連結リストの先頭に追加します。それから、count を +1 して true を返します。セルを見つけたならば、その値を引数 val に書き換えて false を返します。
</p>

<h4>●データの削除</h4>
<p> データを削除する関数 delete はちょっとだけ複雑です。次のリストを見てください。
</p>
<pre class="list">
リスト : データの削除

bool delete_hash(HashTable *ht, const char *key)
{
  int hval = hash_func(ht, key);
  Cell *cp = ht-&gt;table[hval];
  if (cp != NULL) {
    if (strcmp(cp-&gt;key, key) == 0) {
      // 先頭データを削除
      ht-&gt;table[hval] = cp-&gt;next;
      ht-&gt;count--;
      free(cp-&gt;key);
      free(cp);
      return true;
    } else {
      // リストの途中から削除
      for (; cp-&gt;next != NULL; cp = cp-&gt;next) {
        if (strcmp(cp-&gt;next-&gt;key, key) == 0) {
          Cell *del = cp-&gt;next;
          cp-&gt;next = cp-&gt;next-&gt;next;
          ht-&gt;count--;
          free(del-&gt;key);
          free(del);
          return true;
        }
      }
    }
  }
  return false;
}
</pre>
<p> まず、hash_func でハッシュ値を求め、ハッシュ表 hash_table から先頭のセルを取り出します。cp が NULL の場合は空リストなので false を返します。そうでなければ、key を線形探索します。cp-&gt;key と key が等しい場合は、先頭のセルを削除します。これは hash_table[hval] の値を cp-&gt;next に書き換えるだけです。そうでなければ、連結リストをたどって key を探索します。見つけた場合は、cp-&gt;next の値を cp-&gt;next-&gt;next に書き換えてセルを削除します。削除したセルは free で解放することをお忘れなく。
</p>
<p> あとのプログラムは簡単なので説明を割愛いたします。詳細は <a href="clang20.html#list1">プログラムリスト１</a> をお読みください。
</p>
<h4>●実行例１</h4>
<p> それでは実際に実行してみましょう。次に示す簡単なテストを行ってみました。
</p>
<pre class="list">
リスト : 簡単なテスト

void test1(void)
{
  char buff[8][12];
  HashTable *ht = make_hash_table(5);
  bool err;
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("----- insert -----\n");
  for (int i = 0; i &lt; 8; i++) {
    sprintf(buff[i], "%d", rand());
    printf("%s, %d\n", buff[i], insert_hash(ht, buff[i], i));
  }
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("------ search ------\n");
  for (int i = 0; i &lt; 8; i++) 
    printf("%s, %d\n", buff[i], search_hash(ht, buff[i], &err)); 
  printf("------ delete ------\n");
  for (int i = 0; i &lt; 8; i++) {
    printf("%s %d\n", buff[i], delete_hash(ht, buff[i]));
    int x = search_hash(ht, buff[i], &err);
    printf("%s, %d, %d\n", buff[i], x, err);
  } 
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("----- delete hash -----\n");
  delete_hash_table(ht);
}
</pre>
<p> 実行結果を示します。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./hash
-- 1, 0 --
----- insert -----
1804289383, 1
846930886, 1
1681692777, 1
1714636915, 1
1957747793, 1
424238335, 1
719885386, 1
1649760492, 1
-- 0, 8 --
------ search ------
1804289383, 0
846930886, 1
1681692777, 2
1714636915, 3
1957747793, 4
424238335, 5
719885386, 6
1649760492, 7
------ delete ------
1804289383 1
1804289383, 0, 0
846930886 1
846930886, 0, 0
1681692777 1
1681692777, 0, 0
1714636915 1
1714636915, 0, 0
1957747793 1
1957747793, 0, 0
424238335 1
424238335, 0, 0
719885386 1
719885386, 0, 0
1649760492 1
1649760492, 0, 0
-- 1, 0 --
----- delete hash -----
</pre>
<p> ところで、ハッシュ法はハッシュ関数やハッシュ表の大きさによって、性能が大きく左右されます。興味のある方はいろいろ試してみてください。
</p>
<h4>●実行例２</h4>
<p> もう一つ簡単な例題として、乱数で異なるキーを N 個生成する処理を作ってみましょう。生成するキーの個数が少なければ、ハッシュ法を使わなくても線形探索で十分です。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 乱数による異なるキーの生成 (1)

#define N 20000
char data[N][12];

// 線形探索
bool liner_search(const char *key, int size)
{
  for (int i = 0; i &lt; size; i++) {
    if (strcmp(key, data[i]) == 0) return true;
  }
  return false;
}

void test2(int size)
{
  int i = 0;
  while (i &lt; size) {
    sprintf(data[i], "%d", rand());
    if (!liner_search(data[i], i)) i++;
  }
}

int main(void)
{
  for (int i = 2500; i &lt;= N; i *= 2) {
    clock_t s = clock();
    test2(i);
    printf("%d, %.3f\n", i, (double)(clock() - s) / CLOCKS_PER_SEC);
  }
  return 0;
}
</pre>
<p> 生成したキーは配列 data に格納します。関数 test2 は乱数でキーを一つ生成し、それが今まで生成したキーと異なることを関数 liner_search でチェックします。同じキーがなければ data に追加ます。liner_search は線形探索なので、個数が増えると時間がかかるようになります。実際に 2500, 5000, 10000, 20000 個のキーを作ったときの実行時間を示します。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./hash
2500, 0.049
5000, 0.116
10000, 0.474
20000, 1.939
</pre>
<p> キーの個数が増えると実行時間が大幅に増加することがわかります。それでは線形探索の代わりにハッシュ法を使ってみましょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 乱数によるキーの生成 (2)

void test3(int size)
{
  HashTable *ht = make_hash_table(10007);
  bool err;
  char buff[12];
  while (length_hash(ht) &lt; size) {
    sprintf(buff, "%d", rand());
    search_hash(ht, buff, &err);
    if (!err) insert_hash(ht, buff, 1);
  }
  delete_hash_table(ht);
}
</pre>
<p> ハッシュ表の大きさは 10007 (素数) としました。実行結果は次のようになります。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./hash
2500, 0.005
5000, 0.006
10000, 0.007
20000, 0.011
</pre>
<p> ハッシュ法の方が断然速いですね。簡単なハッシュ関数を使いましたが、ハッシュ法の効果は十分に出ています。
</p>
<h4>●実行例３</h4>
<p> 次は二分探索木と比較してみましょう。二分探索木のプログラムを示します。
</p>
<pre class="list">
リスト :  二分探索木

// 節の定義
typedef struct node {
  char *key;
  int value;
  struct node *left;
  struct node *right;
} Node;

// 節の生成
Node *make_node(const char *key, int val)
{
  Node *node = malloc(sizeof(Node));
  if (node != NULL) {
    node-&gt;key = malloc(strlen(key) + 1);
    if (node-&gt;key == NULL) {
      free(node);
      return NULL;
    }
    strcpy(node-&gt;key, key);
    node-&gt;value = val;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
  }
  return node;
}

// 探索
int search_node(const char *key, Node *node, bool *err)
{
  while (node != NULL) {
    int r = strcmp(key, node-&gt;key);
    if (r == 0) {
      *err = true;
      return node-&gt;value;
    } else if (r &lt; 0)
      node = node-&gt;left;
    else
      node = node-&gt;right;
  }
  *err = false;
  return 0;
}

// 挿入
Node *insert_node(const char *key, int val, Node *node)
{
  if (node == NULL)
    return make_node(key, val);
  else {
    int r = strcmp(key, node-&gt;key);
    if (r &lt; 0)
      node-&gt;left = insert_node(key, val, node-&gt;left);
    else if (r &gt; 0)
      node-&gt;right = insert_node(key, val, node-&gt;right);
    return node;
  }
}
</pre>
<p> 節にキー key と値 value を格納します。あとは特に難しいところはないと思います。
</p>
<p> テストプログラムは次のようになります。
</p>
<pre class="list">
リスト : 二分探索木のテスト

void test4(int size)
{
  Node *root = NULL;
  int i = 0;
  char buff[12];
  bool err;
  while (i &lt; size) {
    sprintf(buff, "%d", rand());
    search_node(buff, root, &err);
    if (!err) {
      root = insert_node(buff, i, root);
      i++;
    }
  }
}
</pre>
<p> キーの個数は 100000, 200000, 400000, 800000 とし、ハッシュ表のサイズは 99991 に増やしました。実行結果を示します。
<pre>
  表 : 実行結果 (単位 : 秒)

 個数  : Hash  : Tree
-------+-------+-------
100000 : 0.066 : 0.128
200000 : 0.089 : 0.230
400000 : 0.232 : 0.544
800000 : 0.692 : 1.263
</pre>
<p> ハッシュ法のほうが高速ですね。二分木の場合、平衡木を使うと探索はもう少し速くなると思います。興味のある方は試してみてください。
</p>
<p> 今回はここまでです。次回はオープンアドレス法について説明します。
</p>
<hr>
<h4 id="list1">●プログラムリスト１</h4>
<pre class="list">
//
// hash.c : ハッシュ法 (チェイン法)
//
//          Copyright (C) 2015 Makoto Hiroi
//
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;time.h&gt;

// 連結リスト
typedef struct cell {
  char *key;
  int  value;
  struct cell *next;
} Cell;

// ハッシュ表
typedef struct {
  int size, count;
  Cell **table;
} HashTable;

// セルの生成
Cell *make_cell(const char *key, int val, Cell *next)
{
  Cell *cp = malloc(sizeof(Cell));
  if (cp != NULL) {
    cp-&gt;key = malloc(strlen(key) + 1);
    if (cp-&gt;key == NULL) {
      free(cp);
      return NULL;
    }
    strcpy(cp-&gt;key, key);
    cp-&gt;value = val;
    cp-&gt;next = next;
  }
  return cp;
}

// セルの廃棄
void delete_cell(Cell *cp)
{
  while (cp != NULL) {
    Cell *xs = cp-&gt;next;
    free(cp-&gt;key);
    free(cp);
    cp = xs;
  }
}

// ハッシュ表の生成
HashTable *make_hash_table(int size)
{
  HashTable *ht = malloc(sizeof(HashTable));
  if (ht != NULL) {
    ht-&gt;size = size;
    ht-&gt;count = 0;
    ht-&gt;table = malloc(sizeof(Cell *) * size);
    if (ht-&gt;table == NULL) {
      free(ht);
      return NULL;
    }
    // 初期化
    for (int i = 0; i &lt; size; i++) ht-&gt;table[i] = NULL;
  }
  return ht;
}

// ハッシュ表の廃棄
void delete_hash_table(HashTable *ht)
{
  for (int i = 0; i &lt; ht-&gt;size; i++)
    delete_cell(ht-&gt;table[i]);
  free(ht);
}

// ハッシュ関数
int hash_func(HashTable *ht, const char *key)
{
  unsigned int value = 0;
  for (; *key != '\0'; key++)
    value = (value &lt;&lt; 3) + *key;
  return value % ht-&gt;size;
}

// 作業用関数
Cell *search_cell(HashTable *ht, const char *key, int hval)
{
  Cell *cp = ht-&gt;table[hval];
  for (; cp != NULL; cp = cp-&gt;next) {
    if (strcmp(cp-&gt;key, key) == 0) {
      return cp;
    }
  }
  return NULL;
}

// 探索
int search_hash(HashTable *ht, const char *key, bool *err)
{
  Cell *cp = search_cell(ht, key, hash_func(ht, key));
  if (cp != NULL) {
    *err = true;
    return cp-&gt;value;
  }
  *err = false;
  return 0;
}

// 挿入
bool insert_hash(HashTable *ht, const char *key, int val)
{
  int hval = hash_func(ht, key);
  Cell *cp = search_cell(ht, key, hval);
  if (cp == NULL) {
    // 先頭に追加
    ht-&gt;table[hval] = make_cell(key, val, ht-&gt;table[hval]);
    ht-&gt;count++;
    return true;
  } else {
    // 値を書き換える
    cp-&gt;value = val;
    return false;
  }
}

// 削除
bool delete_hash(HashTable *ht, const char *key)
{
  int hval = hash_func(ht, key);
  Cell *cp = ht-&gt;table[hval];
  if (cp != NULL) {
    if (strcmp(cp-&gt;key, key) == 0) {
      // 先頭データを削除
      ht-&gt;table[hval] = cp-&gt;next;
      ht-&gt;count--;
      free(cp-&gt;key);
      free(cp);
      return true;
    } else {
      // リストの途中から削除
      for (; cp-&gt;next != NULL; cp = cp-&gt;next) {
        if (strcmp(cp-&gt;next-&gt;key, key) == 0) {
          Cell *del = cp-&gt;next;
          cp-&gt;next = cp-&gt;next-&gt;next;
          ht-&gt;count--;
          free(del-&gt;key);
          free(del);
          return true;
        }
      }
    }
  }
  return false;
}

// 巡回
void foreach_hash(void (*func)(const char *, int), HashTable *ht)
{
  for (int i = 0; i &lt; ht-&gt;size; i++) {
    for (Cell *cp = ht-&gt;table[i]; cp != NULL; cp = cp-&gt;next)
      func(cp-&gt;key, cp-&gt;value);
  }
}

// ハッシュは空か
bool is_empty_hash(HashTable *ht)
{
  return ht-&gt;count == 0;
}

// 要素数を返す
int length_hash(HashTable *ht)
{
  return ht-&gt;count;
}

// ハッシュを空にする
void clear_hash(HashTable *ht)
{
  ht-&gt;count =0;
  for (int i = 0; i &lt; ht-&gt;size; i++) {
    delete_cell(ht-&gt;table[i]);
    ht-&gt;table[i] = NULL;
  }
}

//
// 二分探索木
//

// 節の定義
typedef struct node {
  char *key;
  int value;
  struct node *left;
  struct node *right;
} Node;

// 節の生成
Node *make_node(const char *key, int val)
{
  Node *node = malloc(sizeof(Node));
  if (node != NULL) {
    node-&gt;key = malloc(strlen(key) + 1);
    if (node-&gt;key == NULL) {
      free(node);
      return NULL;
    }
    strcpy(node-&gt;key, key);
    node-&gt;value = val;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
  }
  return node;
}

// 探索
int search_node(const char *key, Node *node, bool *err)
{
  while (node != NULL) {
    int r = strcmp(key, node-&gt;key);
    if (r == 0) {
      *err = true;
      return node-&gt;value;
    } else if (r &lt; 0)
      node = node-&gt;left;
    else
      node = node-&gt;right;
  }
  *err = false;
  return 0;
}

// 挿入
Node *insert_node(const char *key, int val, Node *node)
{
  if (node == NULL)
    return make_node(key, val);
  else {
    int r = strcmp(key, node-&gt;key);
    if (r &lt; 0)
      node-&gt;left = insert_node(key, val, node-&gt;left);
    else if (r &gt; 0)
      node-&gt;right = insert_node(key, val, node-&gt;right);
    return node;
  }
}

// 簡単なテスト
void test1(void)
{
  char buff[8][12];
  HashTable *ht = make_hash_table(5);
  bool err;
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("----- insert -----\n");
  for (int i = 0; i &lt; 8; i++) {
    sprintf(buff[i], "%d", rand());
    printf("%s, %d\n", buff[i], insert_hash(ht, buff[i], i));
  }
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("------ search ------\n");
  for (int i = 0; i &lt; 8; i++) 
    printf("%s, %d\n", buff[i], search_hash(ht, buff[i], &err)); 
  printf("------ delete ------\n");
  for (int i = 0; i &lt; 8; i++) {
    printf("%s %d\n", buff[i], delete_hash(ht, buff[i]));
    int x = search_hash(ht, buff[i], &err);
    printf("%s, %d, %d\n", buff[i], x, err);
  } 
  printf("-- %d, %d --\n", is_empty_hash(ht), length_hash(ht));
  printf("----- delete hash -----\n");
  delete_hash_table(ht);
}

#define N 2500
char data[N][12];

// 線形探索
bool liner_search(const char *key, int size)
{
  for (int i = 0; i &lt; size; i++) {
    if (strcmp(key, data[i]) == 0) return true;
  }
  return false;
}

void test2(int size)
{
  int i = 0;
  while (i &lt; size) {
    sprintf(data[i], "%d", rand());
    if (!liner_search(data[i], i)) i++;
  }
}

// ハッシュ
void test3(int size)
{
  HashTable *ht = make_hash_table(99991);  // 10007 から変更
  bool err;
  char buff[12];
  while (length_hash(ht) &lt; size) {
    sprintf(buff, "%d", rand());
    search_hash(ht, buff, &err);
    if (!err) insert_hash(ht, buff, 1);
  }
  delete_hash_table(ht);
}

// 二分探索木
void test4(int size)
{
  Node *root = NULL;
  int i = 0;
  char buff[12];
  bool err;
  while (i &lt; size) {
    sprintf(buff, "%d", rand());
    search_node(buff, root, &err);
    if (!err) {
      root = insert_node(buff, i, root);
      i++;
    }
  }
}

int main(void)
{
  test1();
  /*
  for (int i = 100000; i &lt;= N; i *= 2) {
    clock_t s = clock();
    test3(i);
    printf("%d, %.3f\n", i, (double)(clock() - s) / CLOCKS_PER_SEC);
  }
  */
  return 0;
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang19.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang21.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>