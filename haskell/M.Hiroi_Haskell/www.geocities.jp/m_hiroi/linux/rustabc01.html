<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881816</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>Rust の基礎知識</h3>
<h4 id="abc01">●Hello, Rust!</h4>
<ul>
  <li>Hello, Rust! と表示するプログラム (拡張子は .rs)</li>
<pre class="list">
リスト : Hello, Rust! (hello.rs)

// コメント
fn main() {
    println!("Hello, Rust!");
}
</pre>
  <li>fn main() { ... } は main 関数</li>
  <li>C/C++ と同じく、Rust は main 関数からプログラムの実行を開始する</li>
  <li>Rust は // から行末までがコメントになる (行コメント)</li>
  <li>println!() はＣ言語の関数 printf() と同様の機能を持つ</li>
  <li>println!() は関数ではなく「マクロ」 (マクロはあとで説明する)</li>
  <li>マクロは名前の末尾に ! を付ける</li>
  <li>プログラムのコンパイルは rustc を使う</li>
<pre>
$ rustc hello.rs
$ ./hello
Hello, Rust!
</pre>
  <li>rustc hello.rs で実行ファイルが生成される (Linux では hello, Windows では hello.exe)</li>
  <li>rustc --help でヘルプを表示する</li>
  <li>オプション -O を付けると最適化が行われる (-C opt-level=2 と同じ)</li>
</ul>
<h4 id="abc02">●基本的なデータ型</h4>
<ul>
  <li>整数</li>
    <ul>
      <li>符号付き整数 (i8, i16, i32, i64, isize)</li>
      <li>無符号整数 (u8, u16, u32, u64, usize)</li>
      <li>数値はビットを表す</li>
      <li>isize, usize の大きさは処理系のポインタサイズに依存する</li>
      <li>接頭辞に 0x、0o、0b を指定すると、16 進数、8 進数、2 進数になる</li>
    </ul>
  <li>浮動小数点数</li>
    <ul>
      <li>単精度 (f32)</li>
      <li>倍精度 (f64)</li>
    </ul>
  <li>文字 (char, ユニコード), 'a', 'あ' など</li>
  <li>真偽値 (bool), true, false</li>
  <li>タプル</li>
    <ul>
      <li>タプルは複数の要素を格納した immutable なデータ構造</li>
      <li>データ型は (T, U, V, ...), T, U, V, ... は要素のデータ型</li>
      <li>タプルは丸カッコ (item1, item2, ...) で生成する</li>
      <li>要素が一つのタプルを生成するときは (item1,) のようにカンマを付ける</li>
      <li>要素のアクセスは 変数名.添字 とする (添字は 0 から始まる)</li>
      <li>タプルはパターンマッチや関数で多値を返すときにも使える</li>
    </ul>
  <li>配列</li>
    <ul>
      <li>Rust の配列は固定長</li>
      <li>可変長配列は標準ライブラリの Vec&lt;T&gt; を使う</li>
      <li>要素の型を T とすると、配列の型は [T; size] となる</li>
      <li>size は配列の大きさ (データ型は usize)</li>
      <li>配列の宣言</li>
        <ol>
          <li>let 変数名: 配列の型 = [初期値; 大きさ];</li>
          <li>let 変数名: 配列の型 = [要素1, 要素2, ...];</li>
        </ol>
      <li>Rust には型推論があるので、左辺の配列の型は省略することができる</li>
      <li>Rust の場合、immutable で宣言された配列は要素の値を書き換えることができない</li>
      <li>要素の値を書き換えたい場合は let mut で宣言する</li>
      <li>要素のアクセスには角カッコ [ ] を使う</li>
      <li>添字は 0 から始まる</li>
      <li>配列の大きさは 変数名.len() で取得できる</li>
      <li>二次元配列のデータ型は [[T; row]; column] となる</li>
      <li>要素のアクセスは mat[x][y] のよう角カッコを 2 つ使う</li>
      <li>多次元配列も同じ方法で定義できる</li>
    </ul>
  <li>ユニット (unit), () が唯一の値 (値が無いことを表す)</li>
  <li>基本的なデータ型の場合、他の変数に代入するときや関数の引数に渡すとき値がコピーされる</li>
</ul>
<h4 id="abc03">●変数</h4>
<ul>
  <li>関数型言語では変数に値を割り当てることを「束縛 (binding)」という</li>
  <li>Rust では「変数束縛」という</li>
  <li>局所変数は let で宣言する</li>
  <li>局所変数はスタック (システムスタックとかコールスタックと呼ばれる) に割り当てられる</li>
<pre class="item">
let 名前: データ型;    // 宣言だけする場合
let 名前 = 式;
</pre>
  <li>Rust には型推論があるので、右辺式 (初期値) が指定されていれば、データ型を省略できる</li>
  <li>let で宣言された変数は immutable なので、値を書き換えることはできない</li>
  <li>let の後ろに mut を付けると mutable になるので、値を書き換えることができる</li>
  <li>変数は使用する前に必ず初期化すること</li>
  <li>let で宣言された変数の有効範囲 (スコープ) はブロック { ... } の中だけ</li>
  <li>ブロックが入れ子の場合、内側のブロックで外側のブロックと同名の変数を宣言することができる</li>
  <li>この場合、外側の変数は「隠蔽 (shadowing)」される (関数型言語と同じ)</li>
  <li>定数は const で定義する</li>
<pre class="item">
const 変数名: データ型 = 値;
</pre>
  <li>大域変数 (グローバル変数) の定義は static で行う</li>
<pre class="item">
static 変数名: データ型 = 値;
static mut 変数名: データ型 = 値;
</pre>
  <li>const, static はデータ型を省略することはできない</li>
  <li>右辺の値は定数式であること</li>
  <li>static な変数は静的なデータ領域に割り当てられ、プログラムが終了するまで存在する</li>
  <li>const, static はブロックの中でも定義できる</li>
  <li>その場合、ブロックの外側からその変数を参照することはできない</li>
  <li>mutable な大域変数のアクセスは安全ではないので unsafe { ... } の中で行う</li>
</ul>
<h4 id="abc04">●基本的な演算子</h4>
<ul>
  <li>基本的な演算子はＣ言語とほぼ同じ</li>
  <li>算術演算子 (+, -, *, /, %)</li>
  <li>比較演算子 (==, !=, &lt;, &gt;, &lt;=, &gt;=)</li>
  <li>論理演算子 (!, &amp;&amp;, ||)</li>
  <li>ビット演算子 (!, &amp;, |, ^, &lt;&lt;, &gt;&gt;)</li>
    <ul>
      <li>ビットの反転は ! を使う (Ｃ言語の ~ と同じ)</li>
    </ul>
  <li>代入演算子 (=, +=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=)</li>
  <li>インクリメント (++), デクリメント (--) は存在しない</li>
</ul>
<pre class="list">
リスト : 基本的なデータ型と演算子の使用例

fn main() {
    let a = 10;      // 通常の 10 進数は i32
    let b = 20;      // データ型の指定は 20i32 のように数字の後ろにつけてもよい
    let c = 1.234;   // 通常の小数点数は f64
    let d = 5.678;
    println!("{}", a + b);    // 文字列中の {} は引数の値を文字列に変換して出力 
    println!("{}", a - b);
    println!("{}", c * d);
    println!("{}", c / d);

    println!("{}", true &amp;&amp; false);
    println!("{}", false || true);
    println!("{}", !true);

    let x = (100, 9.999, 'あ');    // タプル, 型は (u32, f64, char)
    println!("{}", x.0);
    println!("{}", x.1);
    println!("{}", x.2);
}
</pre>
<pre>
30
-10
7.006652
0.2173300457907714
false
true
false
100
9.999
あ
</pre>
<h4 id="abc05">●基本的な制御構造</h4>
<ul>
  <li>if test1 { then節; ... } else if test2 { then節2; ... } else { else節; ... }</li>
    <ul>
      <li>if の条件式は括弧で囲む必要はない</li>
      <li>Rust の if は式なので値を返すことができる</li>
      <li>ブロックの最後の処理でセミコロンを付けない場合、その結果を返す</li>
      <li>最後の処理にセミコロンを付けるとユニットを返す</li>
      <li>返り値のデータ型は同じでなければならない (関数型言語と同じ)</li>
    </ul>
  <li>while test { 処理; ... }</li>
  <li>for 変数 in expression { ... }</li>
    <ul>
      <li>expression はイテレータに変換可能なアイテムであること</li>
      <li>for はイテレータから要素を順番に取り出して変数にセットする</li>
        <ul>
          <li>正確にいうと変数ではなくパターンになる</li>
        </ul>
      <li>配列や範囲 (range) はイテレータに変換できる</li>
    </ul>
  <li>loop { ... }  // 無限ループ</li>
  <li>繰り返しの制御に break と continue が使える</li>
  <li>break と continue にはラベル (label) を渡すことができる</li>
  <li>多重ループの内側から一気に脱出することもできる</li>
</ul>
<pre class="list">
リスト : FizzBuzz 問題

fn main() {
    for n in 1..101 {
        if n % 15 == 0 {
            print!("FizzBuzz ");
        } else if n % 3 == 0 {
            print!("Fizz ");
        } else if n % 5 == 0 {
            print!("Buzz");
        } else {
            print!("{} ", n);
        }
    }
}
</pre>
<pre>
1 2 Fizz 4 BuzzFizz 7 8 Fizz Buzz11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 BuzzFizz 22 23 Fizz Buzz26 Fizz 28 29 FizzBuzz 31
32 Fizz 34 BuzzFizz 37 38 Fizz Buzz41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 BuzzFizz 52 53 Fizz Buzz56 Fizz 58 59 FizzBuzz
61 62 Fizz 64 BuzzFizz 67 68 Fizz Buzz71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 BuzzFizz 82 83 Fizz Buzz86 Fizz 88 89 
FizzBuzz 91 92 Fizz 94 BuzzFizz 97 98 Fizz Buzz
</pre>
<pre class="list">
リスト : 数値積分 (円周率を求める)

fn main() {
    let n = 1000000;
    let w = 1.0 / n as f64;    // n を f64 にキャスト (Rust は as を使う)
    let mut s = 0.0;
    for i in 1 .. n + 1 {
        let x = (i as f64 - 0.5) * w;
        s += 4.0 / (1.0 + x * x);
    }
    println!("{}", s * w);
}
</pre>
<pre>
3.1415926535897643
</pre>
<h4 id="abc06">●所有権</h4>
<ul>
  <li>Rust は変数束縛するとき、変数がデータの「所有権」を持つ</li>
  <li>データの所有権を持つ変数は一つしかない</li>
  <li>所有権を持つ変数が廃棄されるとき、そのデータもいっしょに廃棄される</li>
  <li>Rust は他の変数にデータを代入するとき、所有権が移動する</li>
  <li>これを「ムーブセマンティクス (Move Semantics)」という</li>
  <li>基本的なデータ型の場合、所有権は移動せずに値がコピーされる</li>
  <li>所有権が移動したあと、移動元の変数にアクセスするとコンパイルエラー</li>
</ul>
<pre class="list">
リスト : 所有権の移動

fn main() {
    let a = vec![1,2,3,4,5]; // vec! はベクタを生成するマクロ
    println!("{:?}", a);
    let b = a;               // a から b に move
    println!("{:?}", b);
    // println!("{:?}", a);  コンパイルエラー
    let c: Vec&lt;i32&gt;;
    {
        let d = b;           // b から d に move
        // println!("{:?}", b);  コンパイルエラー
        println!("{:?}", d);
        c = d;               // d から c に move
                             // move しないと d が廃棄されるときにベクタも廃棄される
    }
    println!("{:?}", c);
}
</pre>
<pre>
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
</pre>
<h4 id="abc07">●参照と借用</h4>
<ul>
  <li>Rust には C++ と同様の「参照 (reference)」がある</li>
  <li>データ型 T とすると、immutable な参照は &amp; を使う (データ型は &amp;T)</li>
  <li>mutable の参照は &amp;mut を使う (データ型は &amp;mut T)</li>
  <li>データを参照しても「所有権」は移動しない</li>
  <li>Rust では所有権の「借用」という</li>
  <li>immutable な参照はいくつでも作ることができる</li>
  <li>mutable な参照は一つしか作ることができない</li>
  <li>このとき、参照元のデータをアクセスするとコンパイルエラー</li>
  <li>immutable と mutable な参照を同時に使うことはできない</li>
  <li>参照外し (デリファレンス) は変数名の前に * を付ける</li>
  <li>Rust の場合、演算子は多重定義できるので、基本的な演算子は参照も受け付けるようだ</li>
  <li>マクロ println!() なども参照を受け付ける</li>
  <li>mutable な参照で値を書き換える場合は * を付けること</li>
  <li>参照元のデータが廃棄されたあと、その参照が残っていてはいけない</li>
  <li>これをチェックするため Rust には「ライフタイム」という機能がある</li>
  <li>ライフタイムは難しいので、あとで <a href="rustabc02.html#abc24">説明</a> する</li>
</ul>
<pre class="list">
リスト : 参照と借用

fn main() {
    let a = 123;
    let ra = &amp;a;
    let a1 = ra * 10;
    println!("{}", ra);
    println!("{}", a1);

    let mut b = 456;
    println!("{}", b);
    {
        let mut rb = &amp;mut b;
        // let rb1 = &amp;b;      コンパイルエラー
        // println!("{}", b); コンパイルエラー
        println!("{}", rb);
        *rb = 1000;
    }
    println!("{}", b);
}
</pre>
<pre>
1230
123
456
456
1000
</pre>
<h4 id="abc08">●スライス</h4>
<ul>
  <li>スライスは配列への「参照」のこと</li>
  <li>配列のスライスのデータ型は &amp;[要素のデータ型] となる</li>
  <li>スライスは &amp;配列名[範囲]、または &amp;配列名 で取得する
  <li>範囲 (range) は start .. end で表す</li>
  <li>start から end - 1 までの要素がスライスの要素となる</li>
  <li>start を省略すると 0 から、end を省略すると配列の大きさになる</li>
</ul>
<pre class="list">
リスト : 配列とスライスの簡単な使用例

fn main() {
    let a = [1,2,3,4,5,6,7,8];
    println!("{}", a[0]);
    println!("{}", a.len());
    let a1 = a;               // 基本的なデータ型は代入演算子でコピーされる
    println!("{:?}", a);
    println!("{:?}", a1);

    let mut b = [0; 5];
    b[0] = 10;
    println!("{}", b[0]);
    let mut b1 = b;           // mutable な配列もコピーされる
    b1[0] = 20;
    println!("{:?}", b);
    println!("{:?}", b1);
    
    let c = &amp;a[2..5];         // immutable のスライス (参照) はいくつでも作れる
                              // 配列自体はコピーされない
    println!("{:?}", c);
    println!("{}", c.len());

    let d = &amp;a[3..];
    println!("{:?}", d);
    println!("{}", d.len());

    {
        let mut e = &amp;mut b[..];   // mutable な参照はひとつだけ
        e[1] = 20;
        println!("{}", e[1]);
        // b[1] = 30;   コンパイルエラー
    }
    b[1] = 30;                   // e が破棄されたので b にアクセスできる
    println!("{}", b[1]);
}
</pre>
<pre>
1
8
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 2, 3, 4, 5, 6, 7, 8]
10
[10, 0, 0, 0, 0]
[20, 0, 0, 0, 0]
[3, 4, 5]
3
[4, 5, 6, 7, 8]
5
20
30
</pre>
<h4 id="abc09">●文字列</h4>
<ul>
  <li>Rust の文字列は utf-8 のバイトシーケンス</li>
  <li>文字列リテラルは " で囲む</li>
  <li>データ型は &amp;str になる (正確には &amp;'static str)</li>
  <li>これを「文字列スライス」という</li>
  <li>文字列スライスは immutable で固定長</li>
  <li>mutable で可変長な文字列には String がある</li>
  <li>文字列スライスはメソッド to_string() で String に変換できる</li>
  <li>String はメソッド push_str() で文字列を追加することができる</li>
  <li>文字の追加は push() を使う</li>
  <li>末尾から文字を取り除くには pop() を使う</li>
  <li>演算子 + で String と文字列スライスを連結することができる</li>
  <li>この場合、新しい String が生成される</li>
</ul>
<pre class="list">
リスト : 文字列の簡単な使用例

fn main() {
    let mut a = "hello, ".to_string();
    println!("{}", a);
    a.push_str("world");
    println!("{}", a);
    let b = a + ", oops!";
    println!("{}", b);
}
</pre>
<pre>
hello,
hello, world
hello, world, oops!
</pre>
<h4 id="abc10">●関数</h4>
<ul>
  <li>関数はキーワード fn を使って定義する</li>
<pre class="item">
fn 関数名(仮引数: データ型, ...) -&gt; データ型 { ... }
</pre>
  <li>Rust の場合、関数の仮引数は immutable</li>
    <ul>
      <li>仮引数の前に mut を付けると mutable になる (let と同じ)</li>
    </ul>
  <li>仮引数のデータ型は省略することができない</li>
  <li>返り値のデータ型は -&gt; の後ろに記述する</li>
  <li>返り値がユニットの場合はデータ型を省略できる</li>
  <li>関数はブロック最後の処理結果を返す</li>
  <li>このときセミコロンを付けてはいけない</li>
  <li>処理の途中で値を返すときは return を使う</li>
  <li>局所関数も定義できる</li>
  <li>関数のデータ型は fn(データ型, ...) -&gt; データ型 で表す</li>
  <li>クロージャ (ラムダ式) もあるが、ジェネリクスと関連するので、あとで <a href="rustabc02.html#abc21">説明</a> する</li>
</ul>
<pre class="list">
リスト : 関数の簡単な使用例

// 階乗 (再帰)
fn fact(n: i64) -&gt; i64 {
    if n == 0 {
        1
    } else {
        n * fact(n - 1)
    }
}

// フィボナッチ数
fn fibo(n: i64) -&gt; i64 {
    // 末尾再帰 (最適化は保証されていないようだ)
    fn fiboiter(n: i64, a: i64, b: i64) -&gt; i64 {
        if n == 0 {
            a
        } else {
            fiboiter(n - 1, b, a + b)
        }
    }
    fiboiter(n, 0, 1)
}

// 配列の合計値を求める
fn sum_of(func: fn(i32) -&gt; i32, seq: &amp;[i32]) -&gt; i32 {
    let mut acc: i32 = 0;
    for i in 0 .. seq.len() {
        acc += func(seq[i]);
    }
    acc
}

fn main() {
    for n in 10 .. 20 {
        println!("{}", fact(n));
    }
    for n in 40 .. 50 {
        println!("{}", fibo(n));
    }

    // 局所関数
    fn identity(x: i32) -&gt; i32 { x }
    fn square(x: i32) -&gt; i32 { x * x }
    fn cube(x: i32) -&gt; i32 { x * x * x }

    let seq: [i32; 10] = [1,2,3,4,5,6,7,8,9,10];
    println!("{}", sum_of(identity, &amp;seq));
    println!("{}", sum_of(square, &amp;seq));
    println!("{}", sum_of(cube, &amp;seq));
}
</pre>
<pre>
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
102334155
165580141
267914296
433494437
701408733
1134903170
1836311903
2971215073
4807526976
7778742049
55
385
3025
</pre>
<h4 id="abc11">●パターンマッチ</h4>
<ul>
  <li>Rust は match を使ってパターンマッチを行うことができる</li>
  <li>Rust のパターンマッチは関数型言語のそれとよく似ている</li>
<pre class="item">
match expression {
  pattern1 =&gt; expression1, 
  pattern2 =&gt; expression2, 
    ...
  patternN =&gt; expressionN 
}
</pre>
  <li>match は式 expression の値とパターン (pattern1, ..., patternN) を順番に比較する
  </li>
  <li>マッチングに成功したらその節を選択し、=&gt; 以降の式を実行する</li>
  <li>match は式なので expression1 から expressionN の結果は同じデータ型でなければならない</li>
<pre class="list">
リスト : 階乗 (パターンマッチ版)

fn fact(n: i64) -&gt; i64 {
    match n {
        0 =&gt; 1,
        x =&gt; x * fact(x - 1)
    }
}
</pre>
  <li>パターンが定数の場合、同じ値とマッチングする</li>
  <li>最初のパターンは 0 なので、n が 0 の場合にマッチングする</li>
  <li>これは if n = 0 { 1 } と同じ処理になる</li>
  <li>パターンが変数の場合はどんな値とでもマッチングする</li>
  <li>変数はその値に束縛される</li>
  <li>したがって、n が 0 以外の場合は 2 番目のパターンと一致し、変数 x の値は n になる</li>
  <li>変数 x は n と同じ値なので、パターンにワイルドカード ( _ ) を使って次のように定義することもできる</li>
<pre class="item">
_ =&gt; n * fact(n - 1)
</pre>
  <li>複数のパターンにマッチさせたい場合は | を使う</li>
<pre class="list">
リスト : フィボナッチ数 (二重再帰)

fn fibo(n: i64) -&gt; i64 {
    match n {
        0 | 1 =&gt; n,  // 0 と 1 にマッチする
        _ =&gt; fibo(n - 1) + fibo(n - 2)
    }
}
</pre>
  <li>定数ではなく範囲で場合分けしたいときは「ガード (guard)」を使うと便利</li>
<pre class="item">
pattern if 条件式 =&gt; expression,
</pre>
  <li>pattern がマッチングしてかつ条件式が真を返すとき、その節が選択される</li>
  <li>... は範囲を表すパターン</li>
  <li>s ... e は s 以上 e 以下の値とマッチングする</li>
  <li>マッチングの結果を変数に束縛するときは @ を使う</li>
<pre class="item">
変数 @ pattern =&gt; expression,
</pre>
  <li>@ はパターンの中でも使うことができる</li>
  <li>タプルやあとで説明する構造体や列挙型もパターンとして使用できる</li>
  <li>このとき、「分配束縛 (destructuring)」が行われる</li>
  <li>Common Lisp の「分配」や JavaScript の「分割代入」と同様な機能</li>
  <li>パターンマッチを使ってデータ構造の要素を取り出すことができる</li>
  <li>パターンは let や for, 関数の仮引数でも使うことができる</li>
</ul>
<pre class="item">
let (a, b) = (1, 2);           // a = 1, b = 2
let (c, d) = ((3, 4), 5);      // c = (3, 4), d = 5
let (e, (f, g)) = (6, (7, 8)); // e = 6, f = 7, g = 8

        図 : タプルの分配束縛の例
</pre>
<ul>
  <li>パターンの中で参照を扱うには &amp;, ref, ref mut を使う</li>
  <li>&amp; は参照とマッチングする</li>
  <li>ref は immutable な参照を、ref mut は mutable な参照を生成する</li>
</ul>
<pre class="list">
リスト : &amp;, ref , ref mut の使用例

fn main() {
    let ref x = 100;     // x の型は &amp;i32, let x = &amp;100; と同じ
    match x {
        &amp;y =&gt; println!("{}", y)  // 参照と参照のマッチング (y の型は i32)
    }
    match *x {                   // デリファレンスしてもよい
        y =&gt; println!("{}", y)
    }
    let mut z = 200;
    match z {
        ref mut y =&gt; {           // y の型は &amp;mut i32
            *y = 300;            // 値を書き換える
            println!("{}", y)
        }
    }
}
</pre>
<pre>
100
100
300
</pre>
<pre class="list">
リスト : 簡単な連想リスト

// 探索
fn assoc(key: &amp;str, data: &amp;[(&amp;str, i32)]) -&gt; i32 {
    for &amp;(x, v) in data {
        if x == key { return v; }
    }
    -1    
}

fn main() {
    let data = [("foo", 10), ("bar", 20), ("baz", 30)];
    println!("{}", assoc("foo", &amp;data));
    println!("{}", assoc("bar", &amp;data));
    println!("{}", assoc("baz", &amp;data));
    println!("{}", assoc("oops", &amp;data));
}
</pre>
<pre>
10
20
30
-1
</pre>
<ul>
  <li>assoc() の for は、&amp;(&amp;str, i32) と &amp;(x, v) をマッチングする</li>
  <li>(x, v) とすると、タプルの参照ではなくなるのでコンパイルエラー</li>
  <li>タプルの参照同士でマッチングし、タプルの要素と x, v がマッチングする</li>
  <li>その結果、x にはキーとなる文字列、v には整数値がセットされる</li>
  <li>関数の仮引数でも同様にパターンマッチを使用できる</li>
</ul>
<pre class="list">
リスト : 関数の仮引数でパターンマッチを使用する

fn foo(&amp;(a, b): &amp;(i32, i32)) {
    println!("{},{}", a, b);
}

fn main() {
    let x = (1, 2);
    foo(&amp;x);
}
</pre>
<pre>
1,2
</pre>
<ul>
  <li>あとで説明する「クロージャ」では仮引数のデータ型を推論してくれるので、パターンマッチを簡単に利用できる</li>
</ul>
<h4 id="abc12">●構造体</h4>
<ul>
  <li>構造体はキーワード struct で定義する</li>
<pre class="item">
struct 名前 { フィールド名: データ型, ... }
</pre>
  <li>構造体は新しいデータ型を作る (名前がデータ型になる)</li>
  <li>値の生成は let 変数名 = 名前 { フィールド名: 初期値, ... };</li>
  <li>フィールドのアクセスは 変数名.フィールド名 で行う</li>
  <li>Rust の場合、構造体のフィールドは immutable</li>
  <li>let mut とすると mutable になる</li>
  <li>フィールド単位で mutable を指定する方法はない</li>
  <li>構造体の初期化時に .. を使って他の構造体から値を取得することができる</li>
<pre class="item">
struct Point3D { x: f64, y: f64, z: f64 }
let p1 = Point3D { x: 0.0, y: 1.0, z: 2.0 };
let p2 = Point3D { y: 2.0, .. p1 };    // x, z は p1 の値を使う 
</pre>
  <li>タプル構造体はタプルに名前を付けたもの</li>
<pre class="item">
struct 名前(データ型, ...);
</pre>
  <li>フィールド名はない</li>
  <li>Unit-like 構造体はフィールドがない構造体
<pre class="item">
struct 名前;
</pre>
  <li>構造体もパターンになる</li>
<pre class="item">
struct Point {x: f64, y: f64}
let Point {x: a, y: b} = Point {x: 1.0, y: 2.0};  // a = 1.0, b = 2.0
</pre>
</ul>
<pre class="list">
リスト : 構造体の簡単な使用例

// 三次元の点
struct Point3D {
    x: f64, y: f64, z: f64
}

// 距離を求める
fn distance(p1: &amp;Point3D, p2: &amp;Point3D) -&gt; f64 {
    let dx = p1.x - p2.x;    // 参照の場合でも 変数名.フィールド名 でアクセスできる
    let dy = p1.y - p2.y;    // (*変数名).フィールド名 と同じ
    let dz = p1.z - p2.z;
    (dx * dx + dy * dy + dz * dz).sqrt()
}

fn main() {
    let p1 = Point3D {x:0.0, y:0.0, z:0.0};
    let p2 = Point3D {x:10.0, y:10.0, z:10.0};
    println!("{}", distance(&amp;p1, &amp;p2));
}
</pre>
<pre>
17.320508075688775
</pre>
<h4 id="abc13">●列挙型</h4>
<ul>
  <li>列挙型はキーワード enum で定義する</li>
<pre class="item">
enum 名前 { 構造体, ... }
</pre>
  <li>enum は新しいデータ型を定義する (名前がデータ型になる)</li>
  <li>enum の中で定義できるデータ型は構造体 (タプル構造体, Unit-like 構造体を含む) だけ</li>
  <li>enum で定義したデータ型は、中で定義されたデータ型のどれか一つを表す (直和型)</li>
  <li>関数型言語の代数的データ構造と似ている</li>
<pre class="list">
リスト : 列挙型

enum Fruit { Apple, Orange, Grape }
</pre>
  <li>Fruit というデータ型は、Apple, Orange, Grape というデータ型の集合を表す</li>
  <li>要素のアクセスは Fruit::Apple のように :: を使う</li>
  <li>この場合、Ｃ言語の enum のように数値を割り当てることができる</li>
  <li>数値を指定しない場合は 0 から順番に割り当てられる</li>
  <li>数値に変換するときはキャスト (as 演算子) を使用する</li>
  <li>列挙型でデータ型を判別するときはパターンマッチを使うと便利</li>
</ul>
<pre class="list">
リスト : 列挙型の簡単な使用例

// 果物を表すデータ型
enum Fruit {
    Apple, Banana, Grape, Orange
}

use Fruit::*;    // これで Fruit:: を省略できる

// 果物の価格
fn get_price(fruit: &amp;Fruit) -&gt; i32 {
    match *fruit {
        Apple =&gt; 200,
        Banana =&gt; 150,
        Grape =&gt; 300,
        Orange =&gt; 100
    }
}

fn main() {
    println!("{}", get_price(&amp;Apple));
    println!("{}", get_price(&amp;Banana));
    println!("{}", get_price(&amp;Grape));
    println!("{}", get_price(&amp;Orange));
}
</pre>
<pre>
200
150
300
100
</pre>
<h4 id="abc14">●メソッド</h4>
<ul>
  <li>メソッドはオブジェクトに関連付けられた関数</li>
  <li>Rust の場合、オブジェクトは Rust で扱うことができるデータのこと</li>
  <li>メソッドはキーワード impl で定義する</li>
<pre class="item">
impl データ型名 {
  fn メソッド名(self, 仮引数: データ型, ...) -&gt; データ型 { ... }
  ...
}
</pre>
  <li>メソッドの第 1 引数 self は特別で、self, &amp;self, &amp;mut self の 3 つがある</li>
    <ul>
      <li>self : オブジェクト自身 (所有権の移動がおこる)</li>
      <li>&amp;self : オブジェクトへの immutable な参照</li>
      <li>&amp;mut self : オブジェクトへの mutable な参照</li>
        <ul>
          <li>self は self: Self, &amp;self は self: &amp;Self, &amp;mut self は self: &amp;mut Self の糖衣構文</li>
          <li>Self は呼び出し元オブジェクトのデータ型を表す</li>
        </ul>
    </ul>
  <li>メソッドは オブジェクト.メソッド名(...) で呼び出す</li>
  <li>このとき、オブジェクトが self に渡される</li>
  <li>第 1 引数が self 以外の場合は「静的メソッド」になる (他の言語でいうとクラスメソッド)</li>
  <li>静的メソッドは データ型名::メソッド名(...) で呼び出す</li>
</ul>
<pre class="list">
リスト : メソッドの簡単な使用例

// 点
struct Point {
    x: f64, y: f64
}

// メソッドの定義
impl Point {
    fn new(x1: f64, y1: f64) -&gt; Point {
        Point {x: x1, y: y1}
    }

    fn distance(&amp;self, p: &amp;Point) -&gt; f64 {
        let dx = self.x - p.x;
        let dy = self.y - p.y;
        (dx * dx + dy * dy).sqrt()
    }
}

fn main() {
    let p1 = Point::new(0.0, 0.0);
    let p2 = Point::new(10.0, 10.0);
    let p3 = &amp;p1;
    println!("{}", p1.distance(&amp;p2));  // distance には p1 の参照が渡される
    println!("{}", p3.distance(&amp;p2));  // 参照でも呼び出すことができる
}
</pre>
<pre>
14.142135623730951
14.142135623730951
</pre>
<h4 id="abc15">●トレイトの基本</h4>
<ul>
  <li>Rust の「トレイト (trait)」はメソッドの仕様を定義したもの</li>
  <li>トレイトは「データ型の振る舞い (機能)」に名前を付けたものと考えることができる</li>
  <li>データ型 A, B がトレイト X を実装していたらならば、A, B を同じデータ型として扱うことができる</li>
  <li>これを「トレイトオブジェクト」という (あとで <a href="rustabc02.html#abc20">説明</a> する)</li>
  <li>トレイトは「ジェネリクス」で境界条件を設定するときにも使用する (あとで <a href="rustabc01.html#abc17">説明</a> する)</li>
  <li>トレイトはキーワード trait で定義する</li>
<pre class="item">
trait 名前 {
  fn メソッド名(仮引数: データ型, ...) -&gt; データ型;
  ...
}
</pre>
  <li>trait の中でメソッドの実装も定義できる (デフォルトメソッド)</li>
  <li>メソッドの実装は impl で行う</li>
<pre class="item">
impl トレイト名 for データ型名 {
  fn  メソッド名(仮引数: データ型, ...) -&gt; データ型 { ... }
  ...
}
</pre>
  <li>impl X for A { ... } とすると、データ型 A にトレイト X のメソッドを定義することになる</li>
</ul>
<pre class="list">
リスト : トレイトの簡単な使用例

// 距離を求める
trait Distance {
    fn distance(&amp;self, p: &amp;Self) -&gt; f64;
}

// 二次元の点
struct Point {
    x: f64, y: f64
}

impl Point {
    fn new(x1: f64, y1: f64) -&gt; Point {
        Point {x: x1, y: y1}
    }
}

// Distance の実装
impl Distance for Point {
    fn distance(&amp;self, p: &amp;Point) -&gt; f64 {
        let dx = self.x - p.x;
        let dy = self.y - p.y;
        (dx * dx + dy * dy).sqrt()
    }
}

// 三次元の点
struct Point3D {
    x: f64, y: f64, z: f64
}

impl Point3D {
    fn new(x1: f64, y1: f64, z1: f64) -&gt; Point3D {
        Point3D { x: x1, y: y1, z: z1 }
    }
}

// Distance の実装
impl Distance for Point3D {
    fn distance(&amp;self, p: &amp;Point3D) -&gt; f64 {
        let dx = self.x - p.x;
        let dy = self.y - p.y;
        let dz = self.z - p.z;
        (dx * dx + dy * dy + dz * dz).sqrt()
    }
}

fn main() {
    let p1 = Point::new(0.0, 0.0);
    let p2 = Point::new(10.0, 10.0);
    let p3 = Point3D::new(0.0, 0.0, 0.0);
    let p4 = Point3D::new(10.0, 10.0, 10.0);
    println!("{}", p1.distance(&amp;p2));
    println!("{}", p3.distance(&amp;p4));    
}
</pre>
<pre>
14.142135623730951
17.320508075688775
</pre>
<h4 id="abc15a">●トレイトの継承</h4>
<ul>
  <li>トレイトは他のトレイトを継承することができる</li>
<pre class="item">
trait A : B { ... }
</pre>
  <li>トレイト A を実装するとき、トレイト B も実装しないとコンパイルエラーになる</li>
  <li>たとえば、struct C にトレイト A を実装する場合、impl A for C { ... } だけではなく、impl B for C { ... } も必要になる</li>
</ul>
<pre class="list">
リスト : トレイトの継承

trait Foo {
    fn method_a(&amp;self);
}

trait Bar : Foo {
    fn method_b(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn method_a(&amp;self) {
        println!("method_a!");
    }
}

impl Bar for Baz {
    fn method_b(&amp;self) {
        println!("method_b!");
    }
}

fn main() {
    let a = Baz;
    a.method_a();
    a.method_b();
}
</pre>
<pre>
method_a!
method_b!
</pre>
<h4 id="abc16">●Derive</h4>
<ul>
  <li>Rust は #[derive()] というアトリビュートを使って、特定のトレイトの標準的な機能を実装することができる</li>
  <li>カッコの中にトレイトを指定する</li>
  <li>Derive できるトレイト
    <ul>
      <li>Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd</li>
    </ul>
  <li>Debug トレイトを実装すると書式文字列 {:?} で値を表示することができる</li>
  <li>PartialEq トレイトを実装すると演算子 ==, != で等値を判定することができる</li>
  <li>Copy トレイトを実装すると、変数に代入するとき値がコピーされる (所有権の移動は行われない)</li>
  <li>これらのトレイトを自分で実装することもできる</li>
</ul>
<pre class="list">
リスト : Derive の簡単な使用例

#[derive(Debug)]
struct Point {
    x: f64, y: f64
}

impl Point {
    fn new(x1: f64, y1: f64) -&gt; Point {
        Point {x: x1, y: y1}
    }
}

#[derive(Debug, PartialEq)]
struct Point3D {
    x: f64, y: f64, z: f64
}

impl Point3D {
    fn new(x1: f64, y1: f64, z1: f64) -&gt; Point3D {
        Point3D { x: x1, y: y1, z: z1 }
    }
}

fn main() {
    let p1 = Point::new(0.0, 0.0);
    let p2 = Point::new(10.0, 10.0);
    let p3 = Point3D::new(0.0, 0.0, 0.0);
    let p4 = Point3D::new(10.0, 10.0, 10.0);
    println!("{:?}", p1);
    println!("{:?}", p3);
    println!("{}", p3 == p4);
    println!("{}", p3 != p4);
    println!("{}", p4 == p4);    
    println!("{}", p4 != p4);
}
</pre>
<pre>
Point { x: 0, y: 0 }
Point3D { x: 0, y: 0, z: 0 }
false
true
true
false
</pre>
<h4 id="abc17">●ジェネリクスの基本</h4>
<ul>
  <li>ジェネリクス (generics) はデータ型をパラメータ化する機能のこと</li>
  <li>型パラメータ (型引数) は &lt;T, U, V, ...&gt; のように &lt; &gt; の中で指定する</li>
  <li>ジェネリクスを使って関数、メソッド、構造体、列挙型、トレイトを定義できる</li>
    <ul>
      <li>fn 名前&lt;T, ...&gt;(仮引数, ...) -&gt; データ型 { ... }</li>
      <li>struct 名前&lt;T, ...&gt; { ... }</li>
      <li>enum 名前&lt;T, ...&gt; { ... }</li>
      <li>trait 名前&lt;T, ...&gt; { ... }</li>
      <li>impl &lt;T, ...&gt; 名前&lt;T, ...&gt; { ... }</li>
      <li>impl &lt;T, ...&gt; トレイト名&lt;T, ...&gt; for データ型名&lt;T, ...&gt; { ... }</li>
    </ul>
  <li>構造体や列挙型のデータ型は 名前&lt;データ型, ...&gt; になる</li>
</ul>
<ul>
  <li>簡単な例題として、関数型言語でよく用いられる Option というデータ型を取り上げる</li>
  <li>Rust では次のように定義されている</li>
<pre class="item">
enum Option&lt;T&gt; { None, Some(T) }
</pre>
  <li>Option はデータの有無を表す型で、データが無い場合は None を、データが有る場合は Some を使う</li>
  <li>Some のデータ型は T なので、どのデータ型でも Option に格納することができる</li>
  <li>データを取り出すときはパターンマッチングを使うと簡単</li>
</ul>
<pre class="list">
リスト : ジェネリクスの簡単な使用例

// 配列からデータを探す
fn find_if&lt;T&gt;(pred: fn(&amp;T) -&gt; bool, table: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
    for x in table {
        if pred(x) { return Some(x); }
    }
    None
}

fn main() {
    fn evenp(x: &amp;i32) -&gt; bool { x % 2 == 0 }
    fn oddp(x: &amp;i32) -&gt; bool { x % 2 != 0 }
    let a = [2, 4, 6, 8, 10];
    match find_if(evenp, &amp;a) {
        Some(v) =&gt; println!("{}", v),
        None =&gt; println!("None")
    }
    match find_if(oddp, &amp;a) {
        Some(v) =&gt; println!("{}", v),
        None =&gt; println!("None")
    }
}
</pre>
<pre>
2
None
</pre>
<ul>
  <li>match 式の代わりに if let を使うことができる</li>
<pre class="item">
if let パターン = 式 { ... } else { ... }
</pre>
  <li>パターンマッチに成功したら then 節を、失敗したら else 節を実行する</li>
  <li>Option と類似のデータ型に Result がある</li>
<pre class="item">
enum Result&lt;T, E&gt; { Ok(T), Err(E) }
</pre>
  <li>Result は計算結果を返すために使用する</li>
  <li>エラーが発生した場合は、Err にエラー情報をセットして返す</li>
</ul>
<pre class="list">
リスト : ジェネリクスの簡単な使用例 (2)

// 組
#[derive(Debug, PartialEq)]
struct Pair&lt;T, U&gt; {
    fst: T, snd: U
}

impl &lt;T, U&gt; Pair&lt;T, U&gt; {
    fn new(a: T, b: U) -&gt; Pair&lt;T, U&gt; {
        Pair { fst: a, snd: b }
    }
}

fn main() {
    let p1 = Pair::new(1, 2.0);
    let p2 = Pair::new(1, 3.0);
    let p3 = Pair::new("foo", 100);
    println!("{:?}", p1);
    println!("{:?}", p2);
    println!("{:?}", p3);
    println!("{}", p1 == p2);
    println!("{}", p3 == p3);
}
</pre>
<pre>
Pair { fst: 1, snd: 2 }
Pair { fst: 1, snd: 3 }
Pair { fst: "foo", snd: 100 }
false
true
</pre>
<h4 id="abc18">●型パラメータの境界</h4>
<ul>
  <li>ジェネリクスの型パラメータには「境界」を設定することができる</li>
  <li>Rust では「トレイト境界」とか「ジェネリック境界」と呼ばれているようだ</li>
  <li>&lt;T: U&gt; とした場合、T はトレイト U を実装しているデータ型に制限される</li>
  <li>複数のトレイトを境界に指定したい場合は &lt;T: U + V&gt; のように + でつなげる</li>
  <li>境界は where 句 (where T: U, ...) を使って設定することもできる</li>
  <li>where 句は本体 {...} の直前に挿入する</li>
</ul>
<pre class="list">
リスト : 境界条件の設定

//
// Distance, Point, Point3D の定義は省略
//

// ２点間の距離を表示する
// T は Distance を実装しているデータ型に限定される
fn print_distance&lt;T: Distance&gt;(p1: &amp;T, p2: &amp;T) {
    println!("{:.8}", p1.distance(p2));
}

fn main() {
    let p1 = Point::new(0.0, 0.0);
    let p2 = Point::new(10.0, 10.0);
    let p3 = Point3D::new(0.0, 0.0, 0.0);
    let p4 = Point3D::new(10.0, 10.0, 10.0);
    print_distance(&amp;p1, &amp;p2);
    print_distance(&amp;p3, &amp;p4);
}
</pre>
<pre>
14.14213562
17.32050808
</pre>
<pre class="list">
リスト : 配列と連想リストの探索

// 配列の探索
fn find&lt;T: PartialEq + Copy&gt;(key: T, data: &amp;[T]) -&gt; bool {
    for &amp;x in data {
        if key == x { return true; }
    }
    false
}

// 連想リストの探索
fn assoc&lt;T: PartialEq + Copy, U&gt;(key: T, data: &amp;[(T, U)]) -&gt; Option&lt;&amp;U&gt; {
    for &amp;(x, ref v) in data {
        if key == x { return Some(v); }
    }
    None
}

fn main() {
    let data = [1,2,3,4,5,6,7,8];
    println!("{}", find(8, &amp;data));
    println!("{}", find(0, &amp;data));

    let data1 = ["foo", "bar", "baz"];
    println!("{}", find("baz", &amp;data1));
    println!("{}", find("oops", &amp;data1));

    let data2 = [("foo", 100), ("bar", 200), ("baz", 300)];
    match assoc("baz", &amp;data2) {
        Some(v) =&gt; println!("{}", v),
        None =&gt; println!("None")
    }
    match assoc("oops", &amp;data2) {
        Some(v) =&gt; println!("{}", v),
        None =&gt; println!("None")
    }
}
</pre>
<pre>
true
false
true
false
300
None
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2017 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>