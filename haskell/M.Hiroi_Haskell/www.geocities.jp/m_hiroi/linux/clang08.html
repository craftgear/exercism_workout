<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881808</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang07.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang09.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Ｃ言語のメモリアロケーション</h3>
<p> 今回はＣ言語の「メモリアロケーション (メモリ確保, メモリ割り当て) 」について説明します。今までは外部変数や局所変数を宣言することでメモリ領域を確保しました。外部変数はプログラムを実行するとき、あるメモリ領域 (データ領域) に確保されます。これを「静的メモリ割り当て」といいます。局所変数や関数の引数は「スタック領域」に確保されます。これを「自動メモリ割り当て」といいます。
</p>
<p> 最後に、「ヒープ領域」からメモリを割り当てる方法があります。これを「動的メモリ割り当て」といいます。Ｃ言語の場合、ヒープ領域からメモリを取得する関数 malloc が標準ライブラリに用意されています。malloc で割り当てたメモリ領域は、局所変数や引数のように自動的に解放されません。メモリを解放するための関数が free です。malloc や free を使いこなせるようになると、プログラミングの幅はぐーんと広がります。少々難しい話になりますが、恐れずにチャレンジしましょう。
</p>
<h4>●スタックとは？</h4>
<p> 一般的なＣコンパイラの実装では、引数を「スタック (stack) 」というメモリ領域に格納してから関数を呼び出します。また、局所変数もスタック上に確保されます。では、スタックとはどのようなものなのでしょうか。よく例に取り上げられるのが「バネ付きのトレイ」です。下図を見てください。
</p>
<pre class="fig">
    |-----|   |[ A ]|   |[ B ]|   |[ A ]|   |-----|
    |  |  |   |-----|   |[ A ]|   |-----|   |  |  |
    |  |  |   |  |  |   |-----|   |  |  |   |  |  |
    |  |  |   |  |  |   |  |  |   |  |  |   |  |  |
    |  |  |   |  |  |   |  |  |   |  |  |   |  |  |
    +-----+   +-----+   +-----+   +-----+   +-----+
  1. 空の状態 2.PUSH    3.PUSH    4.POP     5.POP
                 A         B         B         A

               図 : スタックの動作例
</pre>
<p> 初めは空の状態です。ここにトレイを上から入れると、重さによってバネを圧縮し、次のトレイを追加できるようになります。さらにもうひとつトレイを乗せると、さらにバネを圧縮し次のトレイを追加できるようになります。バネが限界まで圧縮されるとトレイは追加できなくなります。トレイを取り出す場合は、上にあるトレイから取り出します。ひとつ取り出すと、その分バネが伸びて下にあるトレイが上に出てくるので、次のトレイを取り出すことができます。
</p>
<p> このトレイをデータに見立ててみましょう。データ A をスタックに追加し (2)、次にデータ B を追加します (3)。データを取り出す場合、後から入れたデータ B が先に取り出され (4)、その次にデータ A が取り出されてスタックは空になります (5)。スタックにデータを追加することを「プッシュ (PUSH) 」といい、スタックからデータを取り出すことを「ポップ (POP) 」といいます。
</p>
<p> コンピュータではメモリを使ってこのスタックを実装することになります。一般に、バネの代わりに「スタックポインタ (SP) 」を使ってスタックを管理します。下図を見てください。
</p>
<pre class="fig">
  アドレス Low        High  SP
             A B C D E
           [           ]    E   スタックは空
           [       3   ]    D   PUSH 3
           [     2 3   ]    C   PUSH 2
           [   1 2 3   ]    B   PUSH 1
           [     2 3   ]    C   POP =&gt; 1 が取り出される
           [       3   ]    D   POP =&gt; 2 が取り出される
           [           ]    E   POP =&gt; 3 が取り出される
                                スタックが空になる

           図 : メモリ上でのスタックの実現
</pre>
<p> 便宜上アドレスを A から E までのアルファベットで表すことにします。スタックが空の場合 SP は E を指示しています。データをプッシュする場合、SP を E から D にひとつ減らし <sup><a href="clang08.html#note1">[*1]</a></sup> D にデータをセットします。データをプッシュしていくと SP は Low アドレスに向かっていきます。つまりデータは High アドレスから Low アドレスに向かってスタックに積まれていきます。<sup><a href="clang08.html#note2">[*2]</a></sup>
</p>
<p> データをポップする場合、SP が B を指示しているならば、B にあるデータ 1 を取り出してから SP をひとつ増やして C に移します。データを次々とポップしていくと SP の値は E になり、スタックは空の状態になります。
</p>
<p> これが何の役に立つんだと思ってはいけません。近代的なプログラミング言語は、スタックを使って関数呼び出しを実装しているからです。関数の呼び出しや局所変数の確保に使われるスタックを「システムスタック」とか「コールスタック」といいます。
</p>
<div class="note">
-- note --------<br>
<a name="note1">[*1]</a> 実際にはスタックに積むデータサイズによって SP の増減幅が決まります。たとえば、データが int ならば 4 バイトの大きさなので、スタックに積むと SP の示すアドレスは 4 減少します。ここでいう 1 つは 1 データサイズ分と考えてください。
<br><br>
<a name="note2">[*2]</a> これは一般的な処理系のコールスタックの場合で、スタックの伸びる方向が逆の処理系があってもかまいません。
</div>
<h4>●関数呼び出しとスタックの関係</h4>
<p> それでは、関数が呼び出されるときのスタックの様子を見てみましょう。階乗の計算を行う関数 fact(4) から fact(3) を呼び出す場合を考えてみます。次の図を見てください。
</p>
<pre class="list">
リスト : 階乗

int fact(int n)
{
  if (n == 0)
    return 1;
  else
    return n * fact(n - 1);
}
</pre>
<pre class="fig">
                  &lt;---- 4 byte ----&gt;
  アドレス Low  A [                ]
                B [リターンアドレス]   &lt;= SP (5)
                C [引数 n : 0      ]
                D [リターンアドレス]   &lt;= SP (4)
                E [引数 n : 1      ]
                F [リターンアドレス]   &lt;= SP (3)
                G [引数 n : 2      ]
                H [リターンアドレス]   &lt;= SP (2)
                I [引数 n : 3      ]
          High  J [                ]   &lt;= SP (1)

           図 : 引数をスタックに積む
</pre>
<p> fact(4) が実行されているときのスタックポインタは (1) の状態であったとしましょう。アドレスを便宜上 A から J までのアルファベットで表すことにすると、SP は J を示しています。
</p>
<p> まず引数 n の値 3 がスタックに積まれます。SP はひとつ減りアドレス I を指し示し、そこに n の値 3 が格納されます。fact の引数はひとつなので、次に fact の関数呼び出しが行われます。関数を呼び出す場合、呼び出された関数から呼び出し元の関数に戻るための情報（リターンアドレス）をスタックにプッシュします。
</p>
<p> fact(3) が実行されるときの SP は (2) の状態です。呼び出された関数では、スタックポインタの位置から引数がスタックのどの位置に積まれたかわかるので引数を取り出すことができます。同様にして fact(2) が呼び出されるときは、アドレス G の位置に引数 n の値 2 が格納されます。このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていくことがわかると思います。これが「値呼び」の仕組みです。
</p>
<p> 関数の実行が終了すると、スタックからリターンアドレスを取り出して呼び出し側に戻ります。このままではスタックに引数を積んだままの状態なので、呼び出し側の関数でスタックから引数を削除する処理を行います。なお、スタックに積んだ引数を削除するタイミングは、プログラミング言語によって異なります。
</p>
<p> fact は引数がひとつしかなかったので、今度は引数が複数ある関数を呼び出す場合を考えてみましょう。
</p>
<pre class="list">
リスト : 引数が複数ある場合の例

int foo(int a, int b, int c)
{
  return a * a + 2 * b + c;
}
</pre>
<pre class="fig">
   foo(1, 2, 3); と呼び出した場合

  アドレス Low [   ]       [   ]       [   ]       [   ]
               [   ]       [   ]       [   ]       [ 1 ] &lt;= SP
               [   ]       [   ]       [ 2 ] &lt;= SP [ 2 ]
               [   ]       [ 3 ] &lt;= SP [ 3 ]       [ 3 ]
          High [   ] &lt;= SP [   ]       [   ]       [   ]

             図 : 引数をスタックに積む順序
</pre>
<p> CPU が x86 の場合、実引数は右側から順番にスタックに積まれていくことに注意してください。ただし、引数を評価する順序は規定 <sup><a href="clang08.html#note3">[*3]</a></sup> されていないので、左側の引数から評価する処理系があってもかまいません。その場合でも、実引数をスタックに積む順番は変わりません。
</p>
<p> たとえば、a = 10, b = 20, c = 30 として、foo(a, b, c) を呼び出す場合、変数から値を取り出す順番が a -&gt; b -&gt; c になるのか c -&gt; b -&gt; a になるのかは処理系に依存しますが、スタックに格納される実引数はどちらの方法でも Low [10 20 30] High になるということです。
</p>
<p> 簡単な例を示しましょう。次のプログラムは clang と gcc で実行結果が異なります。
</p>
<pre class="list">
リスト : 引数の評価順序 (sample70.c)

#include &lt;stdio.h&gt;

int foo(char *mes, int n)
{
  printf("%s\n", mes);
  return n * n;
}

int main(void)
{
  int a = 10, b = 20, c = 30;
  printf("%d %d %d\n", foo("foo", a), foo("bar", b), foo("baz", c));
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ clang -o sample70 sample70.c
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample70
foo
bar
baz
100 400 900
mhiroi@mhiroi-VirtualBox:~/clang$ gcc -o sample70g sample70.c
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample70g
baz
bar
foo
100 400 900
</pre>
<p> Clang の場合は左側の引数から評価され、GCC の場合は右側の引数から評価されていることがわかります。
</p>
<div class="note">
-- note --------<br>
<a name="note3">[*3]</a> 関数を呼び出すときの規則は、CPU によっては標準的な方法が定められており、これを「関数呼び出し規約」といいます。x86 の場合、デフォルトで用いられる規約に cdecl があります。
</div>

<h4>●局所変数とスタックの関係</h4>
<p> 引数と同様に、局所変数もスタック上に確保されます。なお、これから説明することは単純化した一般論であり、コンパイラの最適化によっては結果が異なる場合もあります。ご注意ください。
</p>
<pre class="list">
リスト : 局所変数の例

void foo(int n, int m)
{
  int a = n / m;
  int b = n % m;
  printf("n / m = %d n % m = %d\n", a, b );
}
</pre>
<p> 関数 foo は引数の商と剰余を求めて表示します。局所変数 a と b  はスタック上に確保されます。
</p>
<pre class="fig">
                スタック
  アドレス Low
              [    b           ] + &lt;= SP(3)
              [    a           ] +
              [ OLD FP         ] &lt;= SP(2) &lt;= FP(2)
              [リターンアドレス] &lt;= SP(1)
              [    n           ]
              [    m           ]
              [    x           ] + 呼び出し元関数の局所変数
              [    y           ] +
              [ OLD FP         ] &lt;= FP(1)
              [リターンアドレス]
         High [                ]

          図 : 局所変数の確保
</pre>
<p> 関数 foo が呼び出されたときのスタックポインタの位置は (1) です。局所変数をスタック上に確保するには、必要なサイズだけスタックポインタを Low アドレスに向かって移動させるだけです。ただし、単純に移動させると、リターンアドレスの位置がわからなくなるので、「フレームポインタ (FP) 」を使ってスタックポインタを管理します。
</p>
<p> 局所変数を作る場合、まず FP の値をスタックに積みます。FP には呼び出し元関数のフレームポインタがセットされているので、その値をスタックに退避しないといけません。SP は (2) の位置に移動します。その値を FP にセットしてから局所変数のサイズだけ SP を移動させると (3)、局所変数 a, b の領域を確保することができます。
</p>
<p> 必要な局所変数のサイズはコンパイルした時点で決めることができます。また、フレームポインタを基準にすれば局所変数にアクセスすることも簡単にできます。この場合、引数のアクセスもスタックポインタではなくフレームポインタを使った方が簡単になります。
</p>
<p> 呼び出し元関数に戻るときは、まず FP の値を SP に戻します。すると SP は (2) の位置に戻るので、そこに積まれている値を POP して FP にセットします。これで呼び出し元関数のフレームポインタを元に戻すことができます。すると SP は (1) の位置にもどり、そこにはリターンアドレスが積まれているので、そのアドレスを取り出して呼び出し元関数に戻ることができます。
</p>
<p> 以上のことから、局所変数は関数の実行が終了した時点で解放されることもわかります。今まで局所変数として使っていた領域は、ほかの関数が実行されると、その局所変数もしくは引数を渡すための領域として使用されることになります。なお、コンパイラの最適化によっては、局所変数 a, b はスタック上に確保されるのではなく、レジスタに割り当てられる場合があります。
</p>
<p> レジスタは CPU 内部にある一時記憶メモリのことで、CPU の外部に接続されているメモリ（主記憶メモリ）とは異なります。一般に、レジスタはメモリよりも高速にアクセスすることができるので、局所変数をスタック上に作るよりもレジスタに割り当てたほうが、プログラムを高速に実行することができます。
</p>

<p> ところで、前々回説明した局所変数の値を交換するプログラム swap の動作も、スタックについて理解していれば当然な結果であると納得していただけると思います。
</p>

<pre class="list">
リスト : 値の交換（間違い）

#include &lt;stdio.h&gt;

void swap(int a, int b)
{
  int tmp = a;
  a = b;
  b = tmp;
}

int main(void)
{
  int x = 10;
  int y = 20;
  swap(x, y);
  printf("x = %d\ny = %d\n", x, y);
  return 0;
}
</pre>
<p> swap が呼ばれた時点でのスタックの様子を下図に示します。
</p>
<pre class="fig">
  アドレス Low
           A  [   tmp          ] &lt;= SP
           B  [フレームポインタ]
           C  [リターンアドレス]
           D  [  a: 10         ] swap  の引数 &lt;-- ここの値を書き替え
           E  [  b: 20         ]              &lt;-- ることになる
           F  [  x: 10         ] main  の局所変数
           G  [  y: 20         ]
           H  [フレームポインタ]
         High

         図 : swap を呼び出したときのスタック（その１）
</pre>
<p> main の局所変数 x, y の値がスタック上にコピーされて swap に渡され、swap はこの領域の値を書き替えるので、x と y の値は変更されないことがわかります。
</p>
<p> 値を交換したい場合はポインタを使います。
</p>
<PRE class="list">
リスト : 値の交換（正解）

#include &lt;stdio.h&gt;

void swap(int *a, int *b)
{
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main(void)
{
  int x = 10;
  int y = 20;
  swap(&amp;x, &amp;y);
  printf("x = %d\ny = %d\n", x, y);
  return 0;
}
</pre>
<p> swap の引数はポインタとして宣言し、swap を呼び出す場合は、&amp; 演算子を使ってその変数のアドレスを渡します。swap を呼び出したときのスタックは次のようになります。
</p>
<pre class="fig">
  アドレス Low
           A  [   tmp          ] &lt;= SP
           B  [フレームポインタ]
           C  [リターンアドレス]
           D  [ a: アドレス F  ] swap  の引数
           E  [ b: アドレス G  ]
           F  [  x: 10         ] main  の局所変数
           G  [  y: 20         ]
           H  [フレームポインタ]
         High

         図 : swap を呼び出したときのスタック（その２）
</PRE>
<p> 引数 a にはアドレス F が入っているので、*a とすることで main で定義した局所変数 x にアクセスすることができます。引数 b も同様です。
</p>
<h4>●スタック領域について</h4>
<p> いままでスタックについて説明してきましたが、それでは実際にはメモリのどこに割り当てられているのでしょうか。これは OS などの処理系に依存しますが、ここでは下図に示すようにスタック領域はプログラム本体の後ろに確保されると考えてください。
</p>
<pre class="fig">
アドレス Low  +-----------------+
              |                 |
              | プログラム領域  |
              |                 |
              +-----------------+
              |                 |
              | データ領域      |
              |                 |
              +-----------------+
              |                 |
              | ヒープ領域      |
              |                 |
              +-----------------+
              :       ↓        :
              :                 :
              :                 :
              :       ↑        :
              +-----------------+
              |                 |
              | スタック領域    |
              |                 |
        High  +-----------------+

              図 : メモリの配置
</pre>

<p> 外部変数はデータ領域に確保されます。ヒープ領域は「動的メモリ確保」で使用します。これはあとで説明します。スタックは高位アドレスから低位に向かって伸びていくので、再帰呼び出しの回数が多くなると (深くなるともいう) スタック領域が足りなくなって、他の領域を侵したときに Segmentation fault (コアダンプ) が発生します。簡単な例を示します。
</p>

<pre class="list">
リスト : スタックオーバーフロー (sample71.c)

#include &lt;stdio.h&gt;

int sum(int n, int m)
{
  if (n == m)
    return n;
  else
    return n + sum(n + 1, m);
}

int main(void)
{
  for (int i = 100; i &lt; 10000000; i *= 10)
    printf("sum(1 ,%d) = %d\n", i, sum(1, i));
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample71
sum(1 ,100) = 5050
sum(1 ,1000) = 500500
sum(1 ,10000) = 50005000
sum(1 ,100000) = 705082704
Segmentation fault (コアダンプ)
</pre>
<p> 関数 sum は再帰呼び出しが深くなるとスタック領域をはみ出して他の領域を侵すことになるので、Segmentation fault (コアダンプ) が発生します。ちなみに、デフォルトのスタックサイズはコマンド ulimit で調べることができます。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 3806
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3806
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</pre>
<p> M.Hiroi の環境では 8192 kbyte でした。
</p>
<h4>●動的メモリ割り当て</h4>
<p> 今までは、変数を宣言することでメモリの確保を行なっていました。局所変数はスタック上に割り当てられ、外部変数はデータ領域に確保されます。どちらの変数もコンパイル時にその大きさが決定されるので、プログラムを実行している途中でサイズを変更することはできません。あらかじめ決められたサイズ以上にデータを書き込めば、ほかのデータを破壊し、最悪の場合、プログラムは暴走することになります。
</p>
<p> たとえば、テキストファイルを行単位で処理する場合、1 行の長さは不定長ですので、文字列長は実際に読み込んでみないとわかりません。このような場合、あらかじめ外部変数としてバッファを用意すると、そのバッファサイズより長い行が含まれているテキストファイルは処理できないことになります。
</p>
<p> また、余裕をもって大きいサイズのバッファを用意すると、メモリの無駄使いになってしまいます。最近のように、メインメモリが大量に搭載されていれば、あまり問題にならないかもしれませんが、使用できるメモリが少ない環境では、プログラムを実行することができないかもしれません。
</p>
<p> このような場合、プログラムの実行中に必要なサイズが判明した時点で、その大きさのメモリを、どこからか確保できるような手段が必要になります。このことを「動的メモリ割り当て」といいます。

<h4>●関数 malloc</h4>
<p> Ｃ言語でメモリを動的に割り当てる場合、標準ライブラリに用意されている関数 malloc を使います。
</p>
<table border=1>
<caption>表 : malloc の仕様</caption>
<tbody>
  <tr><td>ヘッダ</td><td>stdlib.h</td></tr>
  <tr><td>書式</td><td>void *malloc(size_t size);</td></tr>
  <tr><td>引数</td><td>size : 確保するメモリサイズ(byte 単位)</td></tr>
  <tr><td>機能</td><td>ヒープ領域よりメモリを size バイト割り付ける</td></tr>
  <tr><td>返り値</td><td>成功 : メモリ領域へのポインタ, 失敗 : NULL</td></tr>
</tbody>
</table>
<p> malloc はヒープ領域から必要なメモリ領域を確保します。なお、本稿ではヒープ領域の位置はデータ領域の後ろにあるものとして説明します。
</p>
<pre class="fig">
Low アドレス +--------------+ ----
             |プログラム領域|  ↑
             +--------------+  │
             |              |  │
             |  データ領域  | プロセスで使う
             |              | スタック以外のメモリ
             +--------------+  │
             |  ヒープ領域  |  │ ===&gt; メモリを割り当てる
             |              |  │      malloc, calloc, realloc 
             +--------------+  │
                    │         │ &lt;=== メモリを返還する
                 拡張する      │      free 
                    ↓         │
             |              |  ↓
High アドレス+--------------+ ----

                    図 : ヒープ領域
</PRE>
<p> 一般に、Ｃ言語の標準ライブラリではヒープ領域が足りなくなると、空きメモリがあれば自動的に拡張されます。上図に示すように、高位アドレスに向かって拡張されます。
</p>
<p> メモリを割り当てる関数は malloc と calloc、それから realloc があります。前者は新しくメモリを割り当てる場合に使い、後者はすでに獲得したメモリ領域のサイズを変更する場合に使います。
</p>
<pre class="fig">
    ヒープ領域
 |               |      Header : ヒープの管理領域
 +---------------+
 |    Header     |
 +---------------+ ----  ==&gt; このアドレスが malloc の返り値
 |               |  ↑
 |               | ユーザーの使用
    ・・・・・     可能領域
 |               |  ↓
 +---------------+ ----
 |    Header     |
    ・・・・・

                 図 : メモリの割り付け
</pre>
<p> ヒープ領域はライブラリが管理しているメモリ領域です。malloc によってメモリの要求が行なわれると、ヒープ領域の中から空き領域を探します。ユーザーが要求したサイズだけ割り当てられるのではなく、ヒープ領域を管理するための情報が必要です。上図に示すように、Header が管理領域で、この中に領域が使用中で大きさがいくつであるか、といった情報が書き込まれます。malloc の返り値は、ユーザーが使える領域の先頭アドレスが返されます。
</p>
<p> 確保したメモリは、領域の範囲内で使用するように注意して下さい。領域の前後をはみ出せば、自分の管理領域やほかの管理領域、もしくはほかの領域の中身を破壊することになります。これは、普通の変数の場合と同じですね。Ｃ言語の場合、ほかの領域を破壊しても無頓着ですから、次のメモリを要求したときや、壊された領域の中身をアクセスしたときに、ひどい目に合うことになるのです。
</p>
<p> calloc は、malloc と同様にメモリをヒープ領域から確保しますが、領域を 0 に初期化する点が異なります。malloc の場合、領域の中身は不定です。
</p>
<h4>●関数 realloc</h4>
<p> realloc は領域のサイズを変更する場合に使われます。
</p>
<table border=1>
<caption>表 : realloc の仕様</caption>
<tbody>
  <tr><td>ヘッダ</td><td>stdlib.h</td></tr>
  <tr><td>書式</td><td>void *realloc(void *ptr, size_t size);</td></tr>
  <tr><td>引数</td><td>ptr  : 変更するメモリ領域へのポインタ<br>
                       size : 変更するメモリサイズ(byte 単位)</td></tr>
  <tr><td>機能</td><td>ptr の示すメモリ領域のサイズを size バイトに変更する</td></tr>
  <tr><td>返り値</td><td>成功 : メモリ領域へのポインタ, 失敗 : NULL</td></tr>
</tbody>
</table>
<p> サイズを変更する場合は、大きくする場合と小さくする場合があります。サイズを小さくする場合は簡単です。
</p>
<pre class="fig">
      ヒープ領域
    |             |
    +-------------+
    |   Header    |
    +-------------+ ----  ===&gt; realloc  の返り値
    |             |  ↑
    |             | 新しい領域
    |             |
    |             |  ↓
    | ----------- | ----
    |             |  ↑
    |             | 解放される領域
    |             |  ↓
    +-------------+ ----
    |   Header    |
      ・・・・・

               図 : メモリの再割り付け (その１)
</PRE>
<p> サイズを小さくする場合は、余分な領域を解放するだけですみます。この場合、realloc の返り値は、以前確保したアドレスと同じです。領域を大きくしたい場合は、ちょっと面倒です。
</p>
<pre class="fig">
      ヒープ領域
    |             |
    +-------------+
    |   Header    |
    +-------------+ ----
    |             |  ↑  今までの領域   ==&gt; 解放される
    |             |  ↓
    +-------------+ ----
    |             |
      ・・・・・
    |             |
    +-------------+
    |   Header    |
    +-------------+ ---- ==&gt; realloc  の返り値
    | 旧領域より  |  ↑
    | コピー      |
    | ----------- | 新しい領域
    |             |
    |             |  ↓
    +-------------+ ----
    |             |

               図 : メモリの再割り付け (その２)
</pre>
<p> まず、要求されたサイズを満たす領域を新しく確保し、旧領域より内容をコピーします。そして、旧領域はライブラリによって解放されます。realloc の返り値は、新しい領域のアドレスです。以前確保した領域とは違うアドレスであることと、新しく増えた領域の値は不定であることに注意してください。また、旧領域からコピーする作業が増えるので、メモリを割り当てるのに malloc よりもちょっとだけ時間がかかります。
</p>
<h4>●関数 free</h4>
<p> 使い終わったメモリは解放しないといけません。ヒープ領域が自動的に拡張されるからといって使ったまま放置したのでは、いつかはメモリ不足になってしまいます。メモリの解放には free を使います。
<table border=1>
<caption>表 : free の仕様</caption>
<tbody>
  <tr><td>ヘッダ</td><td>stdlib.h</td></tr>
  <tr><td>書式</td><td>void free(void *ptr);</td></tr>
  <tr><td>引数</td><td>ptr : 解放するメモリ領域へのポインタ</td></tr>
  <tr><td>機能</td><td>メモリ領域を解放し、ヒープ領域に返却する</td></tr>
  <tr><td>返り値</td><td>無し</td></tr>
</tbody>
</table>
<p> free の引数は、malloc などの返り値を与えなければならないことに注意してください。
</p>
<pre class="fig">
            ヒープ領域
         |               |
    ---- +---------------+
    ↑   |    Header     |
    ひ   +---------------+
    と   |   空き領域    |
    つ   |               |
    の   +---------------+
    領   |    Header     |
    域   +---------------+ ----  &lt;== このアドレスを free に渡す。
    に   |               |  ↑
    ま   |               | 解放する領域
    と      ・・・・・
    め   |               |  ↓
    る   +---------------+ ----
         |    Header     |
         +---------------+
    ↓   |   空き領域    |
    ---- +---------------+
         |               |
            ・・・・・

                       図 : メモリの解放
</pre>
<p> メモリを解放する場合、与えられたアドレスから管理領域を求めて、上下のエリアが空き領域であれば、ひとつの空き領域にまとめる処理を行ないます。これは、小さな空き領域ばかりに分割されると、大きな領域を割り当てるには、新しいメモリを取得するしかなくなり、メモリを浪費することになるからです。
</p>
<p> 与えられたアドレスのすぐ上に管理領域があることを前提として動作するので、ほかのアドレスを与えた場合の動作は不定です。試したことがないのでわかりませんが、プログラムはたぶん暴走するのではないでしょうか。
</p>
<h4>●簡単な使用例</h4>
<p> 簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 動的メモリ割り当て (sample72.c)

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  int *p = malloc(sizeof(int));
  double *q = malloc(sizeof(double));
  int *a = malloc(sizeof(int) * 8);
  if (p == NULL || q == NULL || a == NULL) return 1; // 異常終了
  printf("%p\n", p);
  printf("%d\n", *p);
  printf("%p\n", q);
  printf("%f\n", *q);
  printf("%p\n", a);
  for (int i = 0; i &lt; 8; i++) printf("%d ", a[i]);
  printf("\n");
  *p = 100;
  *q = 1.2345;
  a[0] = 10;
  a[7] = 80;
  printf("%d\n", *p);
  printf("%f\n", *q);
  for (int i = 0; i &lt; 8; i++) printf("%d ", a[i]);
  printf("\n");
  // メモリの解放 (省略してもよい)
  free(p);
  free(q);
  free(a);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample72
0x9cea008
0
0x9cea018
0.000000
0x9cea028
0 0 0 0 0 0 0 0 
100
1.234500
10 0 0 0 0 0 0 80 
</pre>
<p> データ型の大きさは sizeof 演算子で求めることができます。たとえば、sizeof(int) は 4 になり、sizeof(double) は 8 になります。malloc(sizeof(int)) とすると、int を格納するメモリ領域が確保され、そのポインタが返されます。同様に、malloc(sizeof(double)) とすると、double を格納するメモリ領域が確保されます。
</p>
<p> 配列を確保することもできます。int a[8] と同じ大きさのメモリを取得するには、malloc(sizeof(int) * 8) とします。これで配列に必要な 32 バイトのメモリを確保することができます。あとは、malloc の返り値をポインタにセットして、そのメモリ領域にアクセスすればいいわけです。
</p>
<p> ところで、malloc を呼び出すときは返り値が NULL でないことをチェックしてください。メモリをたくさん積んでいるから大丈夫だろうといって省略すると、痛い目にあうかもしれません。ご注意くださいませ。
</p>

<P> ところで、取得したメモリ領域は使い終わったら元に戻す処理が必要になります。最近は、不要になったメモリ領域を自動的に回収する「ガベージコレクション (garbage collection, GC) 」という機能を持つプログラミング言語が多くなりました。Ｃ言語の場合、標準では GC をサポートしていないので、不要になったメモリ領域は自動的に回収されません。不要なメモリ領域は free で解放することを忘れないでください。
</p>

<p> ただし、ほとんどの処理系ではプログラムの終了時に malloc で取得したメモリを free で解放する必要はありません。プログラムで使用したメモリは実行終了時に解放されますが、このとき malloc で割り当てたメモリも解放されるようになっているからです。もちろん、例外的な処理系もあるでしょうが、一般的には malloc で取得したメモリを最後まで使うのであれば、free を省略できると考えてもいいでしょう。
</p>
<p> 今回はここまでです。次回は「構造体」について説明します。構造体と malloc を使うと、連結リストや二分木といった複雑なデータ構造を簡単に構築できるようになります。
</p>

</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang07.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang09.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>