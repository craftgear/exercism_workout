<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽Ｃ言語プログラミング超入門</title>
  <meta name="description" content="Ｃ言語,Ｃ言語入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881807</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽Ｃ言語プログラミング超入門</h2>
<div class="small">
[ <a href="clang01.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang03.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3>Ｃ言語の基礎知識 (2)</h3>
<p> 前回はＣ言語の基本として、数、if 文, while 文について説明しました。今回は配列と for 文、switch 文について説明します。
</pre>
<h4>●配列</h4>
<p> 「配列 (array) 」は複数個のデータを格納することができる基本的なデータ構造です。配列に格納されたデータを「要素」といいます。配列はホテルやマンションの部屋にたとえるとわかりやすいと思います。ホテル全体を配列とすると、各部屋がデータを格納する変数と考えることができます。ホテルでは、ルームナンバーによって部屋を指定しますね。配列の場合も、整数値によってデータを格納する変数を指定することができます。この整数値を「添字 (ソエジ : subscripts) 」といいます。
</p>
<pre class="fig">
添字    ０  １  ２  ３  ４  ５  ６  ７  ８  ９
      ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
配列  │  │  │  │  │  │  │  │  │  │  │
      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

                図 : 配列の構造
</PRE>

<p> たとえば、10 個のデータを格納する配列を考えてみます。これは、平屋建てのホテルで、部屋が 10 室あると考えてください。この場合は上図に示すように、データを格納する変数が並んでいて、それぞれ 0 から 9 までの添字で指定することができます。Ｃ言語の場合、添字は 0 から順番に数えます。
</p>
<p> 配列は次のように宣言します。
</p>
<PRE class="item">
データ型 配列名[大きさ];
データ型 配列名[大きさ] = {値1, ..., 値N};
データ型 配列名 [] = {値1, ..., 値N};
</PRE>
<p> データ型は配列に格納する要素のデータ型を指定します。次に配列名を指定して、その後ろの [ ] に配列の大きさを整数値で指定します。最近の規格 (C99) では、整数値を格納した変数で指定することもできます。
</p>

<p> 一般に、スクリプト言語の多くは配列の大きさを自由に変えることができる「可変長配列」をサポートしています。ところが、Ｃ言語の配列はあとから大きさを変更することはできません。ご注意くださいませ。
</p>
<p> 初期値を設定したい場合は {値1, ..., 値N} で要素の値を設定します。このとき、配列の大きさを省略して [ ] とすると、初期値の要素数が配列の大きさになります。初期値の要素数が配列の大きさよりも少ない場合、配列の残りの要素は 0 (float, double 型の場合は 0.0) に初期化されます。
</p>
<p> 初期値を指定しない場合、関数の外側で配列を定義すると、配列は 0 に初期化されます。関数の中で配列を定義すると、初期化は行われず、要素の値は不定になります。0 に初期化されないので注意してください。配列の要素をすべて 0 に初期化したい場合は {0} または {} を指定してください。
</p>
<p> 簡単な例を示しましょう。</p>

<pre class="list">
リスト : 配列の使用例 (sample20.c)

#include &lt;stdio.h&gt;

int a[4];
int b[] = {1, 2, 3, 4, 5, 6, 7, 8};

int main(void) {
  int c[4];
  printf("%d\n", a[0]);
  printf("%d\n", b[1]);
  printf("%d\n", c[2]);
  a[0] = 10;
  b[1] = 20;
  c[2] = 30;
  printf("%d\n", a[0]);
  printf("%d\n", b[1]);
  printf("%d\n", c[2]);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample20
0
2
-1216700416
10
20
30
</PRE>

<p> 配列の要素は角カッコ [ ] を使ってアクセスします。配列の要素を取り出して変数に代入することも、配列の要素を書き換えることもできます。配列 a は関数の外側で定義しているので、要素は 0 に初期化されます。配列 c は関数の中で定義しているので、要素の値は定まらず、適当な値が表示されます。
</p>

<p> 配列は入れ子にすることができます。つまり、配列の要素に配列を入れてもかまいません。これで多次元配列を表すことができます。簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 2 次元配列 (sample21.c)

#include &lt;stdio.h&gt;

int a[3][3];
int b[3][3] = {{1, 2, 3},  {4, 5, 6}, {7, 8, 9}};

int main(void)
{
  printf("%d\n", a[0][0]);
  printf("%d\n", b[2][2]);
  a[0][0] = 10;
  b[2][2] = 20;
  printf("%d\n", a[0][0]);
  printf("%d\n", b[2][2]);
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample21
0
9
10
20
</pre>

<p> 多次元配列は [ ] を複数付けることで宣言します。2 次元配列の場合、int a[3][3] のように [ ] を 2 つ付けて、その中に大きさを指定します。これで配列 a の大きさは 3 で、その要素は大きさ 3 の配列になります。また、初期値を指定する場合は、{ } の中で {1, 2, 3} のように初期値付きで要素を指定します。これで 2 次元配列を初期化することができます。
</p>
<p> 要素のアクセスは簡単で、最初の [ ] で配列に格納されている配列を取り出し、次の [ ] で取り出した配列の要素を指定します。たとえば、b[2][2] は b[2] に格納されている配列 {7, 8, 9} を取り出し、次の [2] でその配列の 2 番目の要素を指定します。したがって、b[2][2] の値は 9 になります。b[2][2] = 20; とすると 9 が書き換えられて 20 になります。
</p>
<h4>●配列の指示初期化子</h4>
<p> 最近の規格 (C99) では、添字を指定して配列の要素を初期化できるようになりました。{ ... } の中で [n] = 値 のように指定します。[n] を「指示初期化子」といいます。これで n 番目の要素を指定した値で初期化することができます。二次元配列の場合は [n][m] = 値 と指定します。指示初期化子で初期値を指定する場合、それ以外の要素は局所変数であっても 0 (浮動小数点数であれば 0.0) に初期化されます。
</p>
<p> また、{ [n] = x, y } のように、指示初期化子のあとに初期値 y を続けて指定すると、n + 1 番目の要素の初期値が y となります。配列の大きさを指定しない場合、たとえば int a[] = { [9] = 100 } と宣言すると、配列の大きさは 10 になり、9 番目の要素が 100 で、それ以外の要素が 0 に初期化されます。int a[] = { [9] = 100, 200 } と宣言すると、配列の大きさは 11 になり、9 番目の要素が 100, 10 番目の要素が 200 に初期化され、それ以外の要素は 0 に初期化されます。これは配列 a が外部変数でも局所変数でも同じです。
</p>

<h4>●for 文</h4>
<p> for 文は while 文と同じく処理を繰り返すときに使います。
</p>
<pre class="item">
for (初期化; 条件部; 更新処理) { 処理A; ...; 処理Z; }
</pre>
<pre class="fig">
                ↓
          ┌─────┐
          │  初期化  │
          └─────┘
                ├←─────┐
    false ┌─────┐      │
  ┌───│  条件部  │      │
  │      └─────┘      │
  │            ↓true        │
  │      ┌─────┐      │
  │      │  処理Ａ  │      │
  │      └─────┘      │
  │            ・            │
  │            ・            │
  │      ┌─────┐      │
  │      │  処理Ｚ  │      │
  │      └─────┘      │
  │            ↓            │
  │      ┌─────┐      │
  │      │ 更新処理 │      │
  │      └─────┘      │
  │            └──────┘
  └──────┐
                ↓

        図 : for 文の処理
</pre>

<p> for 文の特徴は、いちばん最初に行われる初期化と、繰り返すたびに行われる更新処理があることです。上図を見ればおわかりのように、初期化はただ一度しか行われず、更新処理はブロックの処理を実行してから行われます。繰り返す処理が一つしかない場合は { } を省略することができます。初期化と更新処理は、カンマ ( <b>,</b> ) で区切って複数の式を記述することができます。
</p>
<p> 簡単な使用例を示しましょう。
</p>
<pre class="list">
リスト : for 文の使用例 (sample22.c)

#include &lt;stdio.h&gt;

int main(void)
{
  for (int i = 0; i &lt; 10; i++) {
    printf("hello, world\n");
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample22
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
</pre>
<p> 古い規格のＣ言語では、for 文の初期化で変数を宣言することはできません。局所変数はブロックの先頭でしか宣言できない、という制限があったのです。最近の規格 (C99) では、Ｃ++と同じように局所変数は関数内のどの場所でも宣言することができます。gcc をお使いの方はオプション -std=c99 を指定してコンパイルしてください。
</p>
<p> まず、int i = 0; で変数 i を 0 に初期化します。この処理は for 文が始まるときに一度だけ実行されます。次に条件部 i &lt; 10 がチェックされます。i は 0 ですから条件を満たしますね。そこで、ブロックの処理が行われ、printf により hello, world が表示されます。
</p>
<p> 次に、更新処理 i++ が行われます。変数 i の値を +1 したら、条件部のチェックを行います。あとは、while と同様に条件部が成立しているあいだは、ブロックの処理と更新処理を繰り返します。結局、i の値は 10 になるので、条件部が不成立となり繰り返しを終了します。したがって、このプログラムを実行すると hello, world が 10 回表示されます。
</p>
<p> もう一つ簡単な例題として、配列に格納された値の平均値を求めるプログラムを作ってみましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : 身長の平均値を求める (sample23.c)

#include &lt;stdio.h&gt;

#define N 100

// 身長のデータ (乱数で生成)
double height[N] = {
  148.7, 149.5, 133.7, 157.9, 154.2, 147.8, 154.6, 159.1, 148.2, 153.1,
  138.2, 138.7, 143.5, 153.2, 150.2, 157.3, 145.1, 157.2, 152.3, 148.3,
  152.0, 146.0, 151.5, 139.4, 158.8, 147.6, 144.0, 145.8, 155.4, 155.5,
  153.6, 138.5, 147.1, 149.6, 160.9, 148.9, 157.5, 155.1, 138.9, 153.0,
  153.9, 150.9, 144.4, 160.3, 153.4, 163.0, 150.9, 153.3, 146.6, 153.3,
  152.3, 153.3, 142.8, 149.0, 149.4, 156.5, 141.7, 146.2, 151.0, 156.5,
  150.8, 141.0, 149.0, 163.2, 144.1, 147.1, 167.9, 155.3, 142.9, 148.7,
  164.8, 154.1, 150.4, 154.2, 161.4, 155.0, 146.8, 154.2, 152.7, 149.7,
  151.5, 154.5, 156.8, 150.3, 143.2, 149.5, 145.6, 140.4, 136.5, 146.9,
  158.9, 144.4, 148.1, 155.5, 152.4, 153.3, 142.3, 155.3, 153.1, 152.3,
};

int main(void)
{
  double sum = 0;
  for (int i = 0; i &lt; N; i++) sum += height[i];
  printf("sum = %f, avg = %f\n", sum, sum / N);
  return 0;
}
</pre>
<p> #define はマクロ記号を定義するプリプロセッサの命令です。
</p>
<pre class="item">
#define 記号 文字列
</pre>
<p> #define で定義したマクロ記号がソースファイルに現れると、その記号はプリプロセッサにより定義された文字列に置き換えられます。つまり、マクロ記号 N はコンパイルする前に 100 に置き換えられ、そのあとでコンパイルされます。Ｃ言語の場合、マクロ記号を使って定数を定義することがよく行われます。なお、マクロ記号名は英大文字のみで表す慣習があります。
</p>

<p> 配列 height に格納されているデータは乱数で生成した架空のものです。平均値は 合計値 / 人数 で求めることができます。変数 sum に合計値を求めます。最初、sum を 0 に初期化し、for ループで配列の要素 height[i] を sum に加算します。最後に、sum / N を計算して printf で表示します。結果は次のようになります。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample23
sum = 15062.700000, avg = 150.627000
</pre>

<h4>●繰り返しの制御</h4>
<p> while 文や for 文は break 文によって繰り返しを脱出することができます。contiune 文は繰り返しの先頭に戻ります。break 文と continue 文の動作を下図に示します。
</p>
<pre class="fig">
//
// break と continue
//
while (test_a) { ←──────┐
    処理A;                     │
    if (test_b) continue;───┘
    処理B;
    if (test_c) break; ───┐
    処理C;                   │
}                            │
 ←─────────────┘
処理D;

図 : break 文と continue 文の動作
</pre>
<p> test_b が真で continue 文が実行されると、それ以降の処理を実行せずに条件部のチェックが行われます。つまり、処理 B, test_c, 処理 C は実行されません。for 文で continue 文が実行されると、それ以降の処理は実行されずに更新処理が実行されます。
</p>
<p> test_c が真で break 文が実行されると、それ以降の処理を実行せずに while 文や for 文の繰り返しを脱出します。上図では、break 文で while 文の繰り返しを脱出すると、while 文の次の処理 D が実行されます。
</p>
<p> 簡単な例を示しましょう。次のリストを見てください。
</p>
<pre class="list">
リスト : break と contiune (sample24.c)

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main(void)
{
  int i = 0;
  while (true) {
    if (i &gt;= 10) break;
    printf("%d ", i);
    i++;
  }
  for (int j = 10; ; j++) {
    if (j &gt;= 20) break;
    if (j % 2 == 0) continue;
    printf("%d ", j);
  }
  printf("\n");
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample24
0 1 2 3 4 5 6 7 8 9 11 13 15 17 19 
</pre>
<p> while (true) { ... } は条件式が true なので無限ループになります。for 文の場合は for ( ; ; ) のように条件式を省略すると無限ループになります。while ループの中では、i の値が 10 以上になったら break でループを脱出しています。この if 文がないと、本当に無限ループになります。for ループでは、j の値が 20 以上になったらループを脱出します。次の if 文で j が偶数かチェックし、そうであれば continue でそれ以降の処理をスキップして更新処理に進みます。したがって、j が偶数のときは値を表示しません。
</p>
<h4>●パスカルの三角形</h4>
<p> 次は「パスカルの三角形」を表示するプログラムを作ってみましょう。
</p>
<pre class="fig">
                 １                                 0Ｃ0
               ／  ＼                              ／  ＼
             １      １                         1Ｃ0    1Ｃ1
           ／  ＼  ／  ＼                      ／  ＼  ／  ＼
         １      ２      １                 2Ｃ0    2Ｃ1    2Ｃ2
       ／  ＼  ／  ＼  ／  ＼              ／  ＼  ／  ＼  ／  ＼
     １      ３      ３      １         3Ｃ0    3Ｃ1    3Ｃ2    3Ｃ3
   ／  ＼  ／  ＼  ／  ＼  ／  ＼      ／  ＼  ／  ＼  ／  ＼  ／  ＼
 １      ４      ６      ４      １ 4Ｃ0    4Ｃ1    4Ｃ2    4Ｃ3    4Ｃ4 

                        図 : パスカルの三角形
</pre>
<p> パスカルの三角形は、左側の図のように両側がすべて 1 で、内側の数はその左上と右上の和になっています。これは (a + b)<sup>n</sup> を展開したときの各項の係数を表しています。そして、その値は右側の図のように組み合わせの数 <sub>n</sub>Ｃ<sub>r</sub> に対応します。

<p> パスカルの三角形は組み合わせの公式を使って作成することができます。
</p>
<pre class="item">
<sub>n</sub>C<sub>0</sub> = <sub>n</sub>C<sub>n</sub> = 1
<sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r-1</sub> + <sub>n-1</sub>C<sub>r</sub>
</pre>
<P> 公式からわかるように、<sub>n</sub>Ｃ<sub>r</sub> の値は <sub>n-1</sub>Ｃ<sub>r</sub> と <sub>n-1</sub>Ｃ<sub>r-1</sub> を足したものです。n = 0 から順番に組み合わせの数を求めて配列に格納していけばいいわけです。
</p>
<p> プログラムは次のようになります。
<pre class="list">
リスト : パスカルの三角形 (pascal1.c)

#include &lt;stdio.h&gt;

#define N 16

// パスカルの三角形
int table[16][16] = {[0][0] = 1, [1][0] = 1, [1][1] = 1};  // C99

int main(void)
{
  for (int i = 2; i &lt; N; i++) {
    table[i][0] = 1;
    for (int j = 1; j &lt; i; j++) {
      table[i][j] = table[i - 1][j - 1] + table[i - 1][j];
    }
    table[i][i] = 1;
  }
  // 表示
  for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt;= i; j++) {
      printf("%d ", table[i][j]);
    }
    printf("\n");
  }
  return 0;
}
</pre>
<p> 変数 table に組み合わせの数を格納する 2 次元配列をセットします。指示初期化子を使って table[0][0], table[1][0], table[1][1] を 1 に初期化しています。あとは二重の for ループで talbe[i][j] に table[i - 1][j - 1] + table[i - 1][j] の値をセットしていくだけです。このプログラムを gcc でコンパイルする場合はオプション -std=c99 を指定することを忘れないでください。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./pascal1 
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 
1 10 45 120 210 252 210 120 45 10 1 
1 11 55 165 330 462 462 330 165 55 11 1 
1 12 66 220 495 792 924 792 495 220 66 12 1 
1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1 
1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1 
1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1 
</pre>
<p> なお、table は二次元配列ではなく一次元配列で済ますこともできます。次の図を見てください。
</p>
<pre class="fig">
      0  1  2  3  4  5  6
   ------------------------- 
 0 [  1  1  1  1  1  1  1  ]

 1 [  1  1  1  1  1  1  1  ]
       ＼|
 2 [  1  2  1  1  1  1  1  ]
       ＼|＼|
 3 [  1  3  3  1  1  1  1  ]
       ＼|＼|＼|
 4 [  1  4  6  4  1  1  1  ]
       ＼|＼|＼|＼
 5 [  1  5 10 10  5  1  1  ]
       ＼|＼|＼|＼|＼|
 6 [  1  6 15 20 15  6  1  ]

    図 : パスカルの三角形
</pre>
<p> 最初に配列の内容を 1 に初期化します。n = 0, 1 の場合はこのままで大丈夫です。あとは図のように、隣の要素を足し算するだけです。プログラムは次のようになります。
</p>
<pre class="list">
リスト : パスカルの三角形 (2)

#include &lt;stdio.h&gt;

#define N 16

// パスカルの三角形
int table[N];

int main(void)
{
  // 初期化
  for (int i = 0; i &lt; N; i++ ) table[i] = 1;

  printf("%d\n", table[0]);
  printf("%d %d\n", table[0], table[1]);
  for (int i = 2; i &lt; N; i++) {
    for (int j = i - 1; j &gt; 0; j--) {
      table[j] += table[j - 1];
    }
    // 表示
    for (int j = 0; j &lt;= i; j++) printf("%d ", table[j]);
    printf("\n");
  }
  return 0;
}
</pre>
<p> このプログラムは配列 table の値を書き換えていくので、table の後方から計算していくことに注意してください。前方から計算すると値がおかしくなります。
</p>
<h4>●文字列は文字型の配列</h4>
<p> Ｃ言語の文字列は文字型の配列ですが、ひとつ注意点があります。それは文字列の最後は整数値 0 で終端されていることです。最後の 0 をヌル文字といって '\0' で表します。したがって、文字列 "abc" を格納する場合、配列の大きさは 3 バイトではなく 4 バイト必要になります。簡単な例を示しましょう。
</p>
<pre class="list">
リスト : 文字列 (sample25.c)

#include &lt;stdio.h&gt;

int main(void)
{
  char str1[6];
  str1[0] = 'h';
  str1[1] = 'e';
  str1[2] = 'l';
  str1[3] = 'l';
  str1[4] = 'o';
  str1[5] = '\0';
  char str2[] = "hello, world";
  char str3[16] = "foo bar baz";
  printf("%s\n", str1);
  printf("%s\n", str2);
  printf("%s\n", str3);
  char name[3][4] = {"foo", "bar", "baz"};
  for (int i = 0; i &lt; 3; i++) {
    printf("%s\n", name[i]);
  }
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample25
hello
hello, world
foo bar baz
foo
bar
baz
</pre>
<p> 文字列 str1 に hello を格納します。hello は 5 文字ですが、ヌル文字が必要なので、str1 の大きさは 6 バイトになります。文字列 str2 には hello, world を格納します。この場合、ヌル文字を含めて str2 の大きさは 13 バイトになります。文字列 str3 は foo bar baz を格納します。ヌル文字を含めて 14 バイトの領域を使用し、余った 2 バイトの値は不定になります。name のように 2 次元配列にすることもできます。この場合、初期値の要素は 3 つとわかるので、name[][4] と宣言することもできます。
</p>

<h4>●素数を求める</h4>
<p> 次は、100 以下の素数を求めるプログラムを作ってみましょう。いちばん簡単な方法は、奇数 3, 5, 7, 9, ... をそれまでに見つけた素数で割ってみることです。見つけた素数は配列に格納しておけばいいでしょう。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 素数を求める (sample26.c)

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define N 100

// 素数を格納する配列
int prime_table[N] = {[0] = 2};  // C99
int prime_size = 1;

int main(void)
{
  for (int n = 3; n &lt;= N; n += 2) {
    bool prime = true;
    for (int i = 1; i &lt; prime_size; i++) {
      int p = prime_table[i];
      if (p * p &gt; n) {
        break;
      } else if (n % p == 0) {
        prime = false;
        break;
      }
    }
    if (prime) prime_table[prime_size++] = n;
  }
  for (int i = 0; i &lt; prime_size; i++) {
    printf("%d ", prime_table[i]);
  }
  printf("\n");
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample26
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
</pre>
<p> 変数 prime_table は素数を格納する配列で 0 番目の要素を 2 に初期化します。変数 prime_size は格納されている素数の個数を表します。変数 n を 3 に初期化して、for ループで n の値を 2 ずつ増やしていきます。これで奇数列を生成することができます。
</p>
<p> このプログラムは変数 prime の使い方がポイントです。for ループの先頭で prime を true に初期化します。次の for ループで、prime_table に格納されている素数を取り出して変数 p にセットします。n は奇数なので、2 で割り算する必要はありません。prime_table の 1 番目の要素から順番に prime_size - 1 番目までの要素を調べます。
</p>
<p> n が素数か判別する場合、実際には prime_table の素数をすべて調べる必要はなく、√n より小さい素数を調べるだけで十分です。p &gt; √n のかわりに p * p &gt; n をチェックし、真であれば break で for ループを脱出します。x % y が 0 ならば、prime を false にセットしてから break します。
</p>
<p> そして、for ループが終了した後、prime が true であれば n を prime_table に追加して、prime_size の値を +1 します。これで、prime_table の先頭から順番に素数を格納していくことができます。最後に for ループで求めた素数を表示します。
</p>
<p> ところで、このプログラムはちょっとわかりにくいのが欠点です。この場合、関数を使うとわかりやすいプログラムを作ることができます。
</p>
<h4>●エラトステネスの篩</h4>
<p> もう一つ、素数を求める簡単な方法を紹介しましょう。最初に、2 から N までの整数列を生成します。先頭の 2 は素数なので、この整数列から 2 で割り切れる整数を取り除き除きます。2 で割り切れる整数が取り除かれたので、残った要素の先頭が素数になります。先頭要素は 3 になるので、今度は 3 で割り切れる整数を取り除けばいいのです。このように、素数を見つけたらそれで割り切れる整数を取り除いていくアルゴリズムを「エラトステネスの篩 (ふるい) 」といいます。
</p>
<p> プログラムは次のようになります。
</p>
<pre class="list">
リスト : エラトステネスの篩 (sample27.c)

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define N 100

// false は素数, true は素数ではない
bool primes[N + 1];

int main(void)
{
  for (int n = 2; n &lt;= N; n++) {
    if (primes[n]) continue;  // n は素数ではない
    // n の倍数を削除
    for (int m = 2 * n; m &lt;= 100; m += n) {
      primes[m] = true;
    }
    // 表示
    printf("%d ", n);
  }
  printf("\n");
  return 0;
}
</pre>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample27
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
</pre>
<p> bool 型の配列 primes で整数列を表します。false で素数を表し、素数でない場合は true をセットします。primes は false (0) で初期化されるので、最初はすべての数が素数ということになります。このとき、0 と 1 は除外します。次に、for ループで primes から素数 n を探します。n = 2 の場合、primes[n] は false なので n は素数になります。primes[n] が true の場合は continue で for ループの更新処理へ移ります。
</p>
<p> n が素数の場合は、次の for ループで primes から n の倍数を取り除きます。変数 m を 2 * n に初期化し、for ループの更新処理で m に n を加算していけば、m の値は n の倍数になります。あとは primes[m] に true をセットして、素数 n を表示するだけです。
</p>
<p> なお、このプログラムは改善の余地があります。奇数だけを調べるように工夫すると、配列の大きさを半分にすることができ、実行時間も速くなるでしょう。興味のある方はプログラムを改造してみてください。
</p>
<h4>●素因数分解</h4>
<p> エラトステネスの篩と同じ考え方で素因数分解を行うことができます。素因数分解とは、素数でない整数 (合成数) を素数の積の形に書き表すことです。たとえば、12 は 2 * 2 * 3 と素因数分解することができます。プログラムは次のようになります。
</p>
<pre class="list">
リスト : 素因数分解 (sample28.c)

#include &lt;stdio.h&gt;

int main(void)
{
  int m = 1234567890;
  // 2 で割れるだけ割り算する
  while (m % 2 == 0) {
    printf("2 ");
    m /= 2;
  }
  // 奇数で割り算していく
  for (int i = 3; i * i &lt;= m; i += 2) {
    while (m % i == 0) {
      printf("%d ", i);
      m /= i;
    }
  }
  if (m &gt; 1) printf("%d\n", m);
  return 0;
}
</pre>
<p> 最初に 2 で割り算します。それから、奇数で割り算していきます。割り算するときは、その数で割り切れるあいだは割り算を続けることに注意してください。たとえば、27 を素因数分解すると 3 * 3 * 3 になりますが、3 を一回だけしか割り算しないと、結果は 3 * 9 のように素数ではない数が含まれてしまいます。
</p>
<p> 実行結果は次のようになります。
</p>
<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample28
2 3 3 5 3607 3803
</pre>
<p> どの数も素数で、2 * 3 * 3 * 5 * 3607 * 3803 を計算すると 1234567890 になります。なお、これはとても単純なアルゴリズムなので、大きな整数の素因数分解には適していません。巨大な合成数の素因数分解はとても難しい問題です。興味のある方は素因数分解について調べてみてください。
</p>
<h4>●switch 文</h4>
<p> ひとつの値を比較して条件分岐を行う場合は if 文よりも switch 文を使ったほうが簡単です。switch 文の構文を示します。
</p>
<pre class="fig">
  switch (式) {
  case A:
    処理A1;
    処理A2;
    処理A3;
    break;
  case B:
    処理B1;
    処理B2;
    処理B3;
    break;
  case C:
    処理C1;
    処理C2;
    処理C3;
    break;
  default:
    処理Z1;
    処理Z2;
    処理Z3;
  }

  図 : case の構文
</PRE>

<p> switch 文は最初に ( ) の中の式を評価します。式の評価結果は文字型を含む整数値でなければいけません。そのあとに複数の case 節が続きます。case の後ろには定数値 (整数値) を指定します。そして、式の評価結果と case で指定した定数を比較します。
</p>
<p> 式の評価結果と等しい値を見つけた場合、その case 節以降の処理を順番に実行して、break 文で実行を中断します。break 文を忘れると、次の case 節の処理も実行してしまいます。ご注意くださいませ。そうでなければ、次の case 節に移ります。たとえば、定数 A と等しくない場合、次の節に移り定数 B をチェックします。
</p>
<p> もしも、等しい定数が見つからない場合は default 節が実行されます。なお、default 節は省略することができます。switch 文の動作を下図に示します。
</p>
<pre class="fig">
     評価結果
        ↓
  ┌─────┐Yes ┌────┐          ┌────┐
  │  定数 A  │─→│処理Ａ１│→・・・→│処理Ａ３│─ break →┐
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐Yes ┌────┐          ┌────┐           │
  │  定数 B  │─→│処理Ｂ１│→・・・→│処理Ｂ３│─ break →┤
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐Yes ┌────┐          ┌────┐           │
  │  定数 C  │─→│処理Ｃ１│→・・・→│処理Ｃ３│─ break →┤
  └─────┘    └────┘          └────┘           │
        ↓ No                                                    │
  ┌─────┐    ┌────┐          ┌────┐           │
  │ default  │─→│処理Ｚ１│→・・・→│処理Ｚ３│ ────→┤
  └─────┘    └────┘          └────┘           │
                                                                 │
                                                                 ↓

        図 : switch 文の流れ図
</pre>
<p> 簡単な例を示します。switch 文を使って FizzBuzz 問題を解いてみましょう。次のリストを見てください。
</p>
<PRE class="list">
リスト : FizzBuzz 問題 (sample29.c)

#include &lt;stdio.h&gt;

int main(void)
{
  for (int i = 1; i &lt;= 100; i++) {
    switch (i % 15) {
    case 0:
      printf("FizzBuzz");
      break;
    case 3: case 6: case 9: case 12:
      printf("Fizz");
      break;
    case 5: case 10:
      printf("Buzz");
      break;
    default:
      printf("%d", i);
    }
    if(i % 20 == 0){
      printf("\n");
    } else {
      printf(" ");
    }
  }
  return 0;
}
</PRE>

<pre>
mhiroi@mhiroi-VirtualBox:~/clang$ ./sample29
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz
Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz
41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz
61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz
Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz
</pre>

<p> switch 文で i % 15 を求めます。0 であれば 15 で割り切れるので、FizzBuzz を表示します。3, 6, 9, 12 であれば、3 の倍数なので Fizz と表示します。プログラムリストのように複数の case を続けて設定してもかまいません。5, 10 であれば 5 の倍数なので Buzz と表示します。それ以外の数値は default で i を表示します。
</p>
<p> 今回はここまでです。次回はＣ言語の「関数」について説明します。
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2015 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="clang01.html">PrevPage</a> | <a href="clang.html">Clang</a> | <a href="clang03.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>