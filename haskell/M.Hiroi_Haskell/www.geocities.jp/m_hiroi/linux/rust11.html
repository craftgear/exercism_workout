<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Linux Programming / お気楽 Rust プログラミング超入門</title>
  <meta name="description" content="Rust,入門,Linux Programming">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881817</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Linux Programming</h1>
<h2>お気楽 Rust プログラミング超入門</h2>
</div>
<div class="small">
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
<hr>
</div>
<section class="contents">
<h3>ファイルの圧縮</h3>
<h4 id="chap05">●LZW 符号</h4>
<p> 今回は J.Zip と A.Lempel が開発したもう一つのデータ圧縮アルゴリズムである「LZ78 符号」を取り上げます。LZ77 符号と同様に LZ78 符号にも多数のバリエーションが存在します。その中で、最も基本的で広く用いられている符号が、1984 年 T. Welch によって開発された「LZW 符号」です。
</p>
<p> LZSS 符号はスライド窓を辞書として使っていました。スライド窓の大きさは一定なので、記号を読み込むたびに古い記号から捨てていかなくてはいけません。つまり、LZ77 符号は局所的な辞書を構成していると考えることができます。したがって、同じ記号列がファイル内に分散している状態では、それを効果的に圧縮することはできません。
</p>
<p> この問題点を解決するため、LZW 符号ではスライド窓の使用をやめて、これまでに出現した記号列を辞書に登録することで大域的な辞書を作成します。詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo34.html">LZ78 符号 (LZW 符号)</a> をお読みくださいませ。
</p>

<h4 id="chap05a">●LZW 符号の符号化</h4>
<pre class="list">
//
// lzw_enccode.rs : LZW 符号 (符号化)
//
//                  Copyright (C) 2018 Makoto Hiroi
//
extern crate bitio;

use std::fs::{self, File};
use std::io::prelude::*;
use std::io::BufReader;
use std::collections::HashMap;
use std::cell::UnsafeCell;
use std::error::Error;
use bitio::BitWriter;

// 定数
const DIC_BITS: u64 = 16;
const DIC_SIZE: u64 = 1 &lt;&lt; DIC_BITS;

// 辞書は「トライ (trie)」を使う
// 子は HashMap に格納する
struct Node {
    code: u64, // 辞書番号
    child: UnsafeCell&lt;HashMap&lt;u8, Node&gt;&gt;  // 子
}

impl Node {
    fn new(m: u64) -&gt; Node {
        Node { code: m, child: UnsafeCell::new(HashMap::new()) }
    }
}

// ファイルの符号化
fn encode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut wr = BitWriter::create(dst)?;
    // ファイルサイズ
    let metadata = fs::metadata(src)?;
    let size = metadata.len();
    if size == 0 { return Ok(()); }    
    wr.putbits(64, size)?;

    // 記号 (0 - 255) を辞書に登録する
    let mut buff = vec![];
    for x in 0 .. 256 {
        buff.push(Node::new(x));
    }

    // 符号化
    let rd = BufReader::new(File::open(src)?);
    let mut iter = rd.bytes();
    let mut p = &amp;buff[iter.next().unwrap()? as usize];
    let mut num = 256;
    loop {
        match iter.next() {
            None =&gt; {
                wr.putbits(DIC_BITS, p.code)?;
                break;
            }
            Some(r) =&gt; {
                let c = r?;
                let ht = p.child.get();
                if let Some(q) = unsafe { (*ht).get(&amp;c) } {
                    p = q;
                } else {
                    wr.putbits(DIC_BITS, p.code)?;
                    if num &lt; DIC_SIZE {
                        unsafe { (*ht).insert(c, Node::new(num)) };
                        num += 1;
                    }
                    p = &amp;buff[c as usize];
                }
            }
        } 
    }    
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: lzw_encode input_file output_file");
    } else {
        match encode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>

<h4 id="chap05b">●LZW 符号の復号</h4>
<pre class="list">
//
// lzw_decode.rs : LZW 符号 (復号)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitio;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::error::Error;
use bitio::BitReader;

// 定数
const DIC_BITS: u64 = 16;
const DIC_SIZE: u64 = 1 &lt;&lt; DIC_BITS;
const NIL: u64 = DIC_SIZE;

// 出力
fn output(buff: &amp;Vec&lt;(u8, u64)&gt;, n: u64, wr: &amp;mut BufWriter&lt;File&gt;) -&gt; std::io::Result&lt;(u8, u64)&gt; {
    let (c, p) = buff[n as usize];
    if p == NIL {
        wr.write(&amp;[c])?;
        Ok((c, 1))
    } else {
        let x = output(buff, p, wr)?;
        wr.write(&amp;[c])?;
        Ok((x.0, x.1 + 1))
    }
}

// 復号
fn decode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd = BitReader::open(src)?;
    let mut wr = BufWriter::new(File::create(dst)?);
    // ファイルサイズの取得
    let mut size = rd.getbits(64)?;
    if size == 0 { return Ok(()); }

    // 記号 (0 - 255) を辞書に登録
    // 復号の場合、トライを構成する必要はない
    let mut buff =vec![];
    for x in 0 .. 256 {
        buff.push((x as u8, NIL));
    }

    let mut p = rd.getbits(DIC_BITS)?;
    let mut c;
    let mut l;
    let (x, n) = output(&amp;buff, p, &amp;mut wr)?;
    c = x;
    l = n;
    size -= l;
    while size &gt; 0 {
        let q = rd.getbits(DIC_BITS)?;
        let k = buff.len() as u64;
        if q &lt; k {
            let (x, n) = output(&amp;buff, q, &amp;mut wr)?;
            if k &lt; DIC_SIZE {
                buff.push((x, p));
            }
            c = x;
            l = n;
        } else {
            buff.push((c, p));
            let (x, n) = output(&amp;buff, q, &amp;mut wr)?;
            c = x;
            l = n;
        }
        p = q;
        size -= l;
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: lzw_decode input_file output_file");
    } else {
        match decode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>

<h4 id="chap05c">●簡単な実行例</h4>
<p> それでは簡単な実行例として、<a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#large">The Large Corpus</a> と <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> の ptt5 を圧縮してみましょう。
</p>
<table border=1>
<caption>表：The Large Corpus と ptt5 の評価結果</caption>
<thead>
  <tr><th>ファイル名</th><th>サイズ</th><th>LZW</th><th>LZSS</th><th>Huffman</th></tr>
</thead>
<tbody>
  <tr><td>bible.txt   </td><td> 4,047,392</td><td>1,729,899</td><td>1,523,519</td><td>2,218,536</td></tr>
  <tr><td>e.coli      </td><td> 4,638,690</td><td>1,238,483</td><td>1,576,480</td><td>1,159,686</td></tr>
  <tr><td>world192.txt</td><td> 2,473,400</td><td>1,297,628</td><td>1,172,800</td><td>1,558,721</td></tr>
  <tr><td>ptt5        </td><td>   513,216</td><td>66,105</td><td>  107,293</td><td>  106,758</td></tr>
</tbody>
</table>
<ul>
  <li>LZSS 符号のスライド窓の大きさは 8192, 最大一致長は 18</li>
  <li>LZW 符号の辞書サイズは 8192</li>
</ul>
<p> テキストファイルの場合、ファイル全体を通して同じ単語が繰り返し使われているので、LZW 符号で効率的に圧縮することができますが、一般的には LZSS 符号のほうが高い圧縮率になることが多いようです。
</p>
<p> 次は辞書サイズを大きくしてみましょう。
</p>
<table border=1>
<caption>表：The Large Corpus と ptt5 の評価結果 (2)</caption>
<thead>
  <tr><th>ファイル名</th><th>サイズ</th><th>8 k</th><th>16 k</th><th>32 k</th><th>64 k</th></tr>
</thead>
<tbody>
  <tr><td>bible.txt   </td><td> 4,047,392</td><td>1,729,899</td><td>1,607,648</td><td>1,522,079</td><td>1,425,644</td></tr>
  <tr><td>e.coli      </td><td> 4,638,690</td><td>1,238,483</td><td>1,227,814</td><td>1,223,437</td><td>1,221,486</td></tr>
  <tr><td>world192.txt</td><td> 2,473,400</td><td>1,297,628</td><td>1,142,296</td><td>1,027,595</td><td>933,710</td></tr>
  <tr><td>ptt5        </td><td>   513,216</td><td>66,105</td><td>65,661</td><td>65,860</td><td>70,124</td></tr>
</tbody>
</table>
<p> LZW 符号の場合、辞書を表す符号語（辞書番号）は固定長なので、辞書を大きくすれば圧縮率が向上するとは限りません。これは LZSS 符号と同じ欠点です。このような場合、辞書番号を可変長符号で表すと圧縮率を改善することができます。
</p>

<h4 id="chap06">●CBT 符号による改良</h4>
<p> 基本的な考え方は LZB 符号と同じです。辞書番号が 511 以下であれば 9 bit で、1023 以下であれば 10 bit で符号化することができます。符号語を出力するたびに辞書番号は一つずつ増えていくので、その値によって符号語長を変化させればいいわけです。ここで CBT 符号を使用すると、圧縮率をさらに向上させることができます。
</p>
<h4 id="chap06a">●符号化</h4>
<pre class="list">
//
// lzw_enccode.rs : LZW 符号 + CBT 符号 (符号化)
//
//                  Copyright (C) 2018 Makoto Hiroi
//
extern crate bitio;

use std::fs::{self, File};
use std::io::prelude::*;
use std::io::BufReader;
use std::collections::HashMap;
use std::cell::UnsafeCell;
use std::error::Error;
use bitio::BitWriter;

// 定数
const DIC_BITS: u64 = 16;
const DIC_SIZE: u64 = 1 &lt;&lt; DIC_BITS;

// 辞書は「トライ (trie)」を使う
// 子は HashMap に格納する
struct Node {
    code: u64, // 辞書番号
    child: UnsafeCell&lt;HashMap&lt;u8, Node&gt;&gt;  // 子
}

impl Node {
    fn new(m: u64) -&gt; Node {
        Node { code: m, child: UnsafeCell::new(HashMap::new()) }
    }
}

// 辞書番号の符号化
fn encode(code: u64, num: u64, dic_bits: u64, wr: &amp;mut BitWriter) -&gt; std::io::Result&lt;()&gt; {
    if dic_bits &lt; DIC_BITS {
        wr.cbt_encode(code, num, dic_bits)?;
    } else {
        wr.putbits(DIC_BITS, code)?;
    }
    Ok(())
}

// ファイルの符号化
fn encode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut wr = BitWriter::create(dst)?;
    // ファイルサイズ
    let metadata = fs::metadata(src)?;
    let size = metadata.len();
    if size == 0 { return Ok(()); }    
    wr.putbits(64, size)?;

    // 辞書の初期化
    let mut buff = vec![];
    for x in 0 .. 256 {
        buff.push(Node::new(x));
    }

    // 符号化
    let rd = BufReader::new(File::open(src)?);
    let mut iter = rd.bytes();
    let mut p = &amp;buff[iter.next().unwrap()? as usize];
    let mut num = 256;
    let mut dic_bits = 9;
    loop {
        match iter.next() {
            None =&gt; {
                encode(p.code, num, dic_bits, &amp;mut wr)?;
                break;
            }
            Some(r) =&gt; {
                let c = r?;
                let ht = p.child.get();
                if let Some(q) = unsafe { (*ht).get(&amp;c) } {
                    p = q;
                } else {
                    encode(p.code, num, dic_bits, &amp;mut wr)?;
                    if num &lt; DIC_SIZE {
                        unsafe { (*ht).insert(c, Node::new(num)) };
                        num += 1;
                        if dic_bits &lt; DIC_BITS &amp;&amp; num &gt; (1 &lt;&lt; dic_bits) - 1 { 
                            dic_bits += 1;
                        }
                    }
                    p = &amp;buff[c as usize];
                }
            }
        } 
    }    
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: lzw_encode input_file output_file");
    } else {
        match encode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>

<h4 id="chap06b">●復号</h4>
<pre class="list">
//
// lzw_decode.rs : LZW 符号 + CBT 符号 (復号)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitio;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::error::Error;
use bitio::BitReader;

// 定数
const DIC_BITS: u64 = 16;
const DIC_SIZE: u64 = 1 &lt;&lt; DIC_BITS;
const NIL: u64 = DIC_SIZE;

// 出力
fn output(buff: &amp;Vec&lt;(u8, u64)&gt;, n: u64, wr: &amp;mut BufWriter&lt;File&gt;) -&gt; std::io::Result&lt;(u8, u64)&gt; {
    let (c, p) = buff[n as usize];
    if p == NIL {
        wr.write(&amp;[c])?;
        Ok((c, 1))
    } else {
        let x = output(buff, p, wr)?;
        wr.write(&amp;[c])?;
        Ok((x.0, x.1 + 1))
    }
}

// 復号
fn decode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd = BitReader::open(src)?;
    let mut wr = BufWriter::new(File::create(dst)?);
    // ファイルサイズの取得
    let mut size = rd.getbits(64)?;
    if size == 0 { return Ok(()); }

    // 辞書の初期化
    let mut buff =vec![];
    for x in 0 .. 256 {
        buff.push((x as u8, NIL));
    }

    let mut dic_bits = 9;
    let mut num = 256;
    let mut p = rd.cbt_decode(num, dic_bits)?;
    num += 1;    
    let mut c;
    let mut l;
    let (x, n) = output(&amp;buff, p, &amp;mut wr)?;
    c = x;
    l = n;
    size -= l;
    while size &gt; 0 {
        let q;
        if dic_bits &lt; DIC_BITS {
            q = rd.cbt_decode(num, dic_bits)?;
            num += 1;
            if num &gt; (1 &lt;&lt; dic_bits) - 1 { dic_bits += 1; }
        } else {
            q = rd.getbits(DIC_BITS)?;
        }
        let k = buff.len() as u64;
        if q &lt; k {
            let (x, n) = output(&amp;buff, q, &amp;mut wr)?;
            if k &lt; DIC_SIZE {
                buff.push((x, p));
            }
            c = x;
            l = n;
        } else {
            buff.push((c, p));
            let (x, n) = output(&amp;buff, q, &amp;mut wr)?;
            c = x;
            l = n;
        }
        p = q;
        size -= l;
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: lzw_decode input_file output_file");
    } else {
        match decode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>

<h4 id="chap06c">●簡単な実行例</h4>
<p> それでは簡単な実行例として、<a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#large">The Large Corpus</a> と <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> の ptt5 を圧縮してみましょう。
</p>
<table border=1>
<caption>表：The Large Corpus と ptt5 の評価結果</caption>
<thead>
  <tr><th>ファイル名</th><th>サイズ</th><th>8 k</th><th>16 k</th><th>32 k</th><th>64 k</th></tr>
</thead>
<tbody>
  <tr><td>bible.txt   </td><td> 4,047,392</td><td>1,728,896</td><td>1,605,462</td><td>1,517,481</td><td>1,416,231</td></tr>
  <tr><td>e.coli      </td><td> 4,638,690</td><td>1,237,504</td><td>1,225,649</td><td>1,218,862</td><td>1,212,039</td></tr>
  <tr><td>world192.txt</td><td> 2,473,400</td><td>1,296,592</td><td>1,140,030</td><td>1,022,902</td><td>924,140</td></tr>
  <tr><td>ptt5        </td><td>   513,216</td><td>65,088</td><td>63,428</td><td>61,105</td><td>60,337</td></tr>
</tbody>
</table>
<p> 辞書番号を CBT 符号で符号化したことにより、ptt5 の圧縮率は高くなりました。ほかのファイルでも圧縮率は改善されているので、CBT 符号を用いた効果は十分に出ていると思います。
</p>
<hr>
<h4 id="chap07">●レンジコーダ (range coder)</h4>
<p> ハフマン符号は各記号の出現確率を調べ、頻繁に現れる記号は短いビットで表し、あまり現れない記号は長いビットで表すことで、データを圧縮する古典的な方法です。古典的とはいっても、ほかのアルゴリズムと簡単に組み合わせることができるため、ハフマン符号は今でも現役のアルゴリズムです。
</p>
<p> 記号の出現確率だけを利用してデータを圧縮する方法は、ハフマン符号のほかに「算術符号」という方法があります。一般に、算術符号はハフマン符号よりも性能が良いのですが、実装方法が難しくて実行速度がハフマン符号よりも遅いという欠点があります。これに対し、「レンジコーダ (range coder)」は、原理的には算術符号と同じ方法ですが、実装方法はとても簡単で実行速度も算術符号より高速です。性能は算術符号に比べるとわずかに劣化しますが、ハフマン符号よりも高性能です。
</p>
<p> レンジコーダの詳細は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo36.html">レンジコーダ [1]</a>, <a href="../light/pyalgo37.html">[2]</a> をお読みくださいませ。今回は適応型レンジコーダ (桁上がりなし) のプログラムを Rust で作ります。 
</p>
<h4 id="chap07a">●Binary Indexed Tree (BIT)</h4>
<p> 適応型レンジコーダの場合、単純な累積度数分布表を用いると、その更新処理に時間がかかってしまいます。今回は累積度数の取得と更新を比較的高速に行うことができる Binary Indexed Tree というデータ構造を使います。詳しい説明は拙作のページ <a href="../light/pyalgo38.html">レンジコーダ [3]</a> をお読みくださいませ。
</p>
<p> 構造体の名前は BITree とし、以下のメソッドを作成します。
</p>
<ul>
  <li>fn new(n: usize) -&gt; BITree, 大きさ n の BITree を生成する</li>
  <li>fn cumul(&amp;self, c: u32) -&gt; u32, 記号 c の累積度数を求める (0 から c - 1 までの度数の合計値) </li>
  <li>fn get_prob(&amp;self, c: u32) -> &gt; u32, 記号 c の度数を求める</li>
  <li>fn get_sum(&amp;self) -&gt; u32, 合計値を求める</li>
  <li>fn inc(&amp;mut self, c: u32, n: u32), 記号 c の度数に n を加算する</li>
  <li>fn dec(&amp;mut self, c: u32, n: u32), 記号 c の度数から n を減算する</li>
  <li>fn halve(&amp;mut self), 各記号の度数を半分にする (度数は 0 にはならない)</li>
  <li>fn search_code(&amp;self, value: u32) -&gt; (u32, u32), value を二分探索して記号とその累積度数を求める</li>
</ul>
<p> コンパイルは rustc -O --crate-type=lib bitree.rs とします。
</p>
<pre class="list">
//
// bitree.rs : Binary Indexed Tree
//
//             Copyright (C) 2018 Makoto Hiroi
//

// 構造体の定義
pub struct BITree {
    table: Vec&lt;u32&gt;,
    sum: u32,
    mid: usize
}

impl BITree {
    pub fn new(n: usize) -&gt; BITree {
        let mut m = 1;
        while m &lt; n / 2 { m *= 2; }
        let mut tree = BITree { table: vec![0; n], sum: 0, mid: m };
        for i in 0 .. n as u32 { tree.inc(i, 1); }
        tree
    }

    // 合計値を求める
    pub fn get_sum(&amp;self) -&gt; u32 { self.sum }

    // 累積度数を求める
    pub fn cumul(&amp;self, mut c: u32) -&gt; u32 {
        let mut n = 0;
        if c &gt; 0 {
            n = self.table[0];
            c -= 1;
            while c &gt; 0 {
                n += self.table[c as usize];
                c = c &amp; (c - 1);
            }
        }
        n
    }

    // 出現頻度を求める
    pub fn get_prob(&amp;self, mut c: u32) -&gt; u32 {
        let mut val = self.table[c as usize];
        if c &gt; 0 &amp;&amp; c &amp; 1 == 0 {
            let p = c &amp; (c - 1);
            c -= 1;
            while c != p {
                val -= self.table[c as usize];
                c = c &amp; (c - 1);
            }
        }
        val
    }

    // 出現頻度の更新
    pub fn inc(&amp;mut self, c: u32, n: u32) {
        let mut c = c as i32;
        if c &gt; 0 {
            let k = self.table.len() as i32;
            while c &lt; k {
                self.table[c as usize] += n;
                c += c &amp; (- c);
            }
        } else {
            self.table[0] += n;
        }
        self.sum += n;
    }

    pub fn dec(&amp;mut self, c: u32, n: u32) {
        if c &gt; 0 {
            let mut c = c as i32;
            let k = self.table.len() as i32;
            while c &lt; k {
                self.table[c as usize] -= n;
                c += c &amp; (- c);
            }
        } else {
            self.table[0] -= n;
        }
        self.sum -= n;
    }

    pub fn halve(&amp;mut self) {
        for i in 0 .. self.table.len() as u32 {
            let n = self.get_prob(i) / 2;
            if n &gt; 0 {
                self.dec(i, n);
            }
        }
    }

    // 記号の探索
    pub fn search_code(&amp;self, value: u32) -&gt; (u32, u32) {
        let mut c = 0;
        let mut n = 0;
        if self.table[0] &lt;= value {
            let mut h = self.mid;
            n = self.table[0];
            while h &gt; 0 {
                if c + h &lt; self.table.len() &amp;&amp; n + self.table[c + h] &lt;= value {
                    n += self.table[c + h];
                    c += h;
                }
                h /= 2;
            }
            c += 1;
        }
        (c as u32, n)
    }
}
</pre>
<h4 id="chap07b">●適応型レンジコーダ</h4>
<ul>
  <li>Decoder: 復号用の構造体</li>
  <li>fn open(filename: &amp;str) -&gt; std::io::Result&lt;Decoder&gt;, Decoder の生成</li>
  <li>fn decode(&amp;mut, freq: &amp;mut BITree, n: u32) -&gt; std::io::Reusult&lt;u32&gt;, 復号</li>
</ul>
<ul>
  <li>Encoder: 符号化用の構造体</li>
  <li>fn create(filename: &amp;str) -&gt; std::io::Result&lt;Encoder&gt;, Encoder の生成</li>
  <li>fn encode(&amp;mut, freq: &amp;mut BITree, c: u32, n: u32) -&gt; std::io::Reusult&lt;()&gt;, 符号化</li>
</ul>
<p> decode(), encode() の引数 n は記号の度数の増分値を表します。コンパイルは rustc -L . -O --crate-type=lib rangecoder.rs とします。
</p>

<pre class="list">
//
// rangecoder.rs : 適応型レンジコーダ
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;

use std::fs::File;
use std::io::{Result, BufReader, Read, BufWriter, Write};
use bitree::BITree;

// 定数
const MAX_RANGE: u32 = 0xffffffff;
const MIN_RANGE: u32 = 0x10000;
const MASK1: u32     = 0xff000000;
const SHIFT: u32     = 24;

//
// 桁上がりのないレンジコーダ
//

// 符号化
pub struct Encoder {
    writer: BufWriter&lt;File&gt;,
    range: u32,
    low: u32
}

impl Encoder {
    // ライトオープン
    pub fn create(filename: &amp;str) -> std::io::Result&lt;Encoder> {
        let fs = File::create(filename)?;
        Ok(Encoder { writer: BufWriter::new(fs), range: MAX_RANGE, low: 0})
    }

    // 正規化
    fn normalize(&amp;mut self) -> std::io::Result&lt;()> {
        while self.low &amp; MASK1 == (self.low + self.range) &amp; MASK1 {
            self.writer.write(&amp;mut [(self.low >> SHIFT) as u8])?;
            self.low = self.low &lt;&lt; 8;
            self.range &lt;&lt;= 8;
        }
        while self.range &lt; MIN_RANGE {
            self.range = (MIN_RANGE - (self.low &amp; (MIN_RANGE - 1))) &lt;&lt; 8;
            self.writer.write(&amp;mut [(self.low >> SHIFT) as u8])?;
            self.low = self.low &lt;&lt; 8;
        }
        Ok(())
    }

    // 符号化
    pub fn encode(&amp;mut self, freq: &amp;mut BITree, c: u32, n: u32) -> std::io::Result&lt;()> {
        let temp = self.range / freq.get_sum();
        self.low += freq.cumul(c) * temp;
        self.range = freq.get_prob(c) * temp;
        self.normalize()?;
        freq.inc(c, n);
        if freq.get_sum() >= MIN_RANGE { freq.halve(); }
        Ok(())
    }
}

impl Drop for Encoder {
    fn drop(&amp;mut self) {
        self.writer.write(&amp;mut [((self.low >> 24) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [((self.low >> 16) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [((self.low >> 8) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [(self.low &amp; 0xff) as u8]).unwrap();
    }
}

pub struct Decoder {
    reader: BufReader&lt;File>,
    code: u32,
    range: u32,
    low: u32
}

impl Decoder {
    // リードオープン
    pub fn open(filename: &amp;str) -> Result&lt;Decoder> {
        let fs = File::open(filename)?;
        let mut rd = BufReader::new(fs);
        let mut c = 0;
        for _ in 0 .. 4 {
            let mut buff = [0u8; 1];
            rd.read(&amp;mut buff)?;
            c = (c &lt;&lt; 8) + buff[0] as u32;
        }
        Ok(Decoder { reader: rd, code: c, range: MAX_RANGE, low: 0 })
    }

    // 正規化
    fn normalize(&amp;mut self) -> std::io::Result&lt;()> {
        let mut buff = [0u8; 1];
        while self.low &amp; MASK1 == (self.low + self.range) &amp; MASK1 {
            self.reader.read(&amp;mut buff)?;
            self.code = (self.code &lt;&lt; 8) + buff[0] as u32;
            self.low = self.low &lt;&lt; 8;
            self.range &lt;&lt;= 8;
        }
        while self.range &lt; MIN_RANGE {
            self.reader.read(&amp;mut buff)?;
            self.range = (MIN_RANGE - (self.low &amp; (MIN_RANGE - 1))) &lt;&lt; 8;
            self.code = (self.code &lt;&lt; 8) + buff[0] as u32;
            self.low = self.low &lt;&lt; 8;
        }
        Ok(())
    }

    // 復号
    pub fn decode(&amp;mut self, freq: &amp;mut BITree, n: u32) -> std::io::Result&lt;u32> {
        let temp = self.range / freq.get_sum();
        let (c, m) = freq.search_code((self.code - self.low) / temp);
        self.low += temp * m;
        self.range = temp * freq.get_prob(c);
        self.normalize()?;
        freq.inc(c, n);
        if freq.get_sum() >= MIN_RANGE {
            freq.halve();
        }
        Ok(c)
    }
}
</pre>
<h4 id="chap07c">●符号化</h4>
<p> コンパイルは rustc -L . -O rc_encode.rs とします。</p>
<pre class="list">
//
// rc_encode.rs : 適応型レンジコーダ (符号化)
//
//                Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::error::Error;
use bitree::BITree;
use rangecoder::Encoder;

fn encode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut freq = BITree::new(257);
    let mut wr = Encoder::create(dst)?;
    let rd = BufReader::new(File::open(src)?);
    for r in rd.bytes() {
        wr.encode(&amp;mut freq, r? as u32, 1)?;
    }
    // EOF を書き込む
    wr.encode(&amp;mut freq, 256, 1)?;
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc_encode input_file output_file");
    } else {
        match encode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<h4 id="chap07d">●復号</h4>
<p> コンパイルは rustc -L . -O rcdecode.rs とします。</p>

<pre class="list">
//
// rc_decode.rs : 適応型レンジコーダ (復号)
//
//                Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::error::Error;
use bitree::BITree;
use rangecoder::Decoder;

fn decode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd = Decoder::open(src)?;
    let mut wr = BufWriter::new(File::create(dst)?);
    let mut freq = BITree::new(257);
    loop {
        let c = rd.decode(&amp;mut freq, 1)?;
        if c == 256 { break; }
        wr.write(&amp;mut [c as u8])?;
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc_decode input_file output_file");
    } else {
        match decode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<h4 id="chap07e">●簡単な実行例</h4>
<p> それでは簡単な実行例として、<a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#large">The Large Corpus</a> と <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> の ptt5 を圧縮してみましょう。
</p>
<table border=1>
<caption>表：The Large Corpus と ptt5 の評価結果</caption>
<thead>
  <tr><th>ファイル名</th><th>サイズ</th><th>Range</th><th>Huffman</th></tr>
</thead>
<tbody>
  <tr><td>bible.txt   </td><td> 4,047,392</td><td>2,196,408</td><td>2,218,536</td></tr>
  <tr><td>e.coli      </td><td> 4,638,690</td><td>1,165,701</td><td>1,159,686</td></tr>
  <tr><td>world192.txt</td><td> 2,473,400</td><td>1,543,904</td><td>1,558,721</td></tr>
  <tr><td>ptt5        </td><td>   513,216</td><td>   76,816</td><td>  106,758</td></tr>
</tbody>
</table>
<p> e.coli を除き、適応型レンジコーダのほうが高い圧縮率になりました。特に ptt5 の圧縮率は、レンジコーダの方がとても高くなります。記号に 1 ビット未満の符号語を割り当てることができるレンジコーダ (算術符号) の特徴が結果に出ていると思います。
</p>
<hr>
<h4 id="chap08">●有限文脈モデル</h4>
<p> 有限文脈モデルは、直前に出現した記号列によって記号の出現確率を定める、という簡単なモデルです。直前に出現した記号列の長さを「次数 (order)」といいます。有限文脈モデルは 1 次 (order-1) がいちばん簡単です。直前に出力した記号を覚えておいて、それに従って出現頻度表を切り替えるという単純な方法で実現できます。つまり、各記号ごとに出現頻度表を用意しておいて、直前に出力した記号が a であれば、a の出現頻度表を使って符号化を行うわけです。詳しい説明は拙作のページ <a href="../light/index.html#python_algo">Algorithms with Python</a> <a href="../light/pyalgo39.html">有限文脈モデル</a> をお読みくださいませ。
</p>
<p> ところで、適応型レンジコーダには、出現しない記号が多数あると圧縮率が少し劣化する、という欠点があります。たとえば、記号が 0 と 1 しかないデータを符号化してみましょう。適応型符号化では記号 0 - 255 の出現頻度を 1 に初期化しています。このため、記号数が少ないうちは記号 2 - 255 の出現頻度の影響が大きくなり、圧縮率はどうしても劣化してしまいます。ようするに、記号をたくさん読み込まないと、その出現頻度表の確率はあてにならないというわけです。
</p>
<p> 高次の有限文脈モデルになればなるほど、多数の出現頻度表を使うことになるので、この欠点の影響はとても大きなものになりますが、この影響を緩和する簡単な方法が 2 つあります。一つは出現頻度表の累積度数の上限値を小さな値に設定することです。もう一つは、出現頻度表の更新時で記号数の増分値を +1 より大きくすることです。今回は後者の方法を使うことにします。
</p>

<h4 id="chap08a">●order-1</h4>
<pre class="list">
//
// rc1_encode.rs : 有限文脈モデル (order-1, 符号化)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::error::Error;
use bitree::BITree;
use rangecoder::Encoder;
use std::collections::HashMap;

fn encode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut ht = HashMap::new();
    let mut wr = Encoder::create(dst)?;
    let rd = BufReader::new(File::open(src)?);
    let mut c0 = 0;
    for r in rd.bytes() {
        let c = r?;
        if !ht.contains_key(&amp;c0) {
            ht.insert(c0, BITree::new(257));
        }
        // 増分値は +16
        wr.encode(ht.get_mut(&amp;c0).unwrap(), c as u32, 16)?;
        c0 = c;
    }
    // EOF を書き込む
    if !ht.contains_key(&amp;c0) {
        ht.insert(c0, BITree::new(257));
    }
    wr.encode(ht.get_mut(&amp;c0).unwrap(), 256, 16)?;
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc1_encode input_file output_file");
    } else {
        match encode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<pre class="list">
//
// rc1_decode.rs : 有限文脈モデル (order-1, 復号)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::error::Error;
use bitree::BITree;
use rangecoder::Decoder;
use std::collections::HashMap;

fn decode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd = Decoder::open(src)?;
    let mut wr = BufWriter::new(File::create(dst)?);
    let mut ht = HashMap::new();
    let mut c0 = 0;
    loop {
        if !ht.contains_key(&amp;c0) {
            ht.insert(c0, BITree::new(257));
        }
        // 増分値は +16
        let c = rd.decode(ht.get_mut(&amp;c0).unwrap(), 16)?;
        if c == 256 { break; }
        wr.write(&amp;mut [c as u8])?;
        c0 = c;
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc1_decode input_file output_file");
    } else {
        match decode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<h4 id="chap08b">●order-2</h4>
<pre class="list">
//
// rc2_encode.rs : 有限文脈モデル (order-2, 符号化)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::error::Error;
use bitree::BITree;
use rangecoder::Encoder;
use std::collections::HashMap;

fn encode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut ht = HashMap::new();
    let mut wr = Encoder::create(dst)?;
    let rd = BufReader::new(File::open(src)?);
    let mut c0: u16 = 0;
    for r in rd.bytes() {
        let c = r?;
        if !ht.contains_key(&amp;c0) {
            ht.insert(c0, BITree::new(257));
        }
        // 増分値は +32
        wr.encode(ht.get_mut(&amp;c0).unwrap(), c as u32, 32)?;
        c0 = (c0 &lt;&lt; 8) + c as u16;
    }
    // EOF を書き込む
    if !ht.contains_key(&amp;c0) {
        ht.insert(c0, BITree::new(257));
    }
    wr.encode(ht.get_mut(&amp;c0).unwrap(), 256, 32)?;
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc2_encode input_file output_file");
    } else {
        match encode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<pre class="list">
//
// rc2_decode.rs : 有限文脈モデル (order-2, 復号)
//
//                 Copyright (C) 2018 Makoto Hiroi
//
extern crate bitree;
extern crate rangecoder;

use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::error::Error;
use bitree::BITree;
use rangecoder::Decoder;
use std::collections::HashMap;

fn decode_file(src: &amp;String, dst: &amp;String) -&gt; std::io::Result&lt;()&gt; {
    let mut rd = Decoder::open(src)?;
    let mut wr = BufWriter::new(File::create(dst)?);
    let mut ht = HashMap::new();
    let mut c0: u16 = 0;
    loop {
        if !ht.contains_key(&amp;c0) {
            ht.insert(c0, BITree::new(257));
        }
        // 増分値は +32
        let c = rd.decode(ht.get_mut(&amp;c0).unwrap(), 32)?;
        if c == 256 { break; }
        wr.write(&amp;mut [c as u8])?;
        c0 = (c0 &lt;&lt; 8) + c as u16;
    }
    Ok(())
}

fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    if args.len() &lt; 3 {
        println!("usage: rc2_decode input_file output_file");
    } else {
        match decode_file(&amp;args[1], &amp;args[2]) {
            Ok(_) =&gt; (),
            Err(err) =&gt; println!("{}", err.description())
        }
    }
}
</pre>
<h4 id="chap08c">●簡単な実行例</h4>
<p> それでは簡単な実行例として、<a href="http://corpus.canterbury.ac.nz/">Canterbury Corpus</a> で配布されているテストデータ <a href="http://corpus.canterbury.ac.nz/descriptions/#large">The Large Corpus</a> と <a href="http://corpus.canterbury.ac.nz/descriptions/#cantrbry">The Canterbury Corpus</a> の ptt5 を圧縮してみましょう。
</p>
<table border=1>
<caption>表：The Large Corpus と ptt5 の評価結果</caption>
<thead>
  <tr><th>ファイル名</th><th>サイズ</th><th>order-0</th><th>order-1</th><th>order-2</th></tr>
</thead>
<tbody>
  <tr><td>bible.txt   </td><td> 4,047,392</td><td>2,196,408</td><td>1,640,940</td><td>1,250,370</td></tr>
  <tr><td>e.coli      </td><td> 4,638,690</td><td>1,165,701</td><td>1,154,027</td><td>1,143,803</td></tr>
  <tr><td>world192.txt</td><td> 2,473,400</td><td>1,543,904</td><td>1,127,912</td><td>882,226</td></tr>
  <tr><td>ptt5        </td><td>   513,216</td><td>   76,816</td><td>53,960</td><td>58,164</td></tr>
</tbody>
</table>
<p> 有限文脈モデルはテキストファイルとの相性が良く、次数を上げると圧縮率が大幅に向上します。ただし、ptt5 のように order-1 のほうが高い圧縮率になることもあります。興味のある方はいろいろ試してみてください。
</p>
<hr>
<h4 id="chap08d">●プログラムの改訂</h4>
<p> 今までは構造体 Encoder と Decoder にメソッド encode() と decode() を持たせていましたが、それを出現頻度表を表す構造体に移すことにします。そして、クレート bitree を frequency に、構造体 BITree を Freq に変更します。
</p>
<ul>
  <li>クレート : rangecoder</li>
  <ul>
    <li>構造体 : Encoder</li>
      <ul>
        <li>メソッド : create(), normalize()</li>
        <li>フィールド : range, low</li>
      </ul>
    <li>構造体 : Decoder</li>
      <ul>
        <li>メソッド : open(), normalize()</li>
        <li>フィールド : code, range, low</li>
      </ul>
  </ul>
  <li>クレート : frequency</li>
  <ul>
    <li>構造体 : Freq</li>
      <ul>
        <li>メソッド : new(), encode(), decode()</li>
      </ul>
  </ul>
</ul>
<p> メソッド encode() には Encoder を渡し、decode() には Decoder を渡すように修正します。
</p>
<h4>●適応型レンジコーダ (桁上がりなし)</h4>
<pre class="list">
//
// rangecoder.rs : 適応型レンジコーダ
//
//                 Copyright (C) 2018 Makoto Hiroi
//
use std::fs::File;
use std::io::{Result, BufReader, Read, BufWriter, Write};

// 定数
const MAX_RANGE: u32 = 0xffffffff;
const MIN_RANGE: u32 = 0x10000;
const MASK1: u32     = 0xff000000;
const SHIFT: u32     = 24;

//
// 桁上がりのないレンジコーダ
//

// 符号化
pub struct Encoder {
    writer: BufWriter&lt;File&gt;,
    pub range: u32,
    pub low: u32
}

impl Encoder {
    // ライトオープン
    pub fn create(filename: &amp;str) -&gt; std::io::Result&lt;Encoder&gt; {
        let fs = File::create(filename)?;
        Ok(Encoder { writer: BufWriter::new(fs), range: MAX_RANGE, low: 0})
    }

    // 正規化
    pub fn normalize(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        while self.low &amp; MASK1 == (self.low + self.range) &amp; MASK1 {
            self.writer.write(&amp;mut [(self.low &gt;&gt; SHIFT) as u8])?;
            self.low = self.low &lt;&lt; 8;
            self.range &lt;&lt;= 8;
        }
        while self.range &lt; MIN_RANGE {
            self.range = (MIN_RANGE - (self.low &amp; (MIN_RANGE - 1))) &lt;&lt; 8;
            self.writer.write(&amp;mut [(self.low &gt;&gt; SHIFT) as u8])?;
            self.low = self.low &lt;&lt; 8;
        }
        Ok(())
    }
}

impl Drop for Encoder {
    fn drop(&amp;mut self) {
        self.writer.write(&amp;mut [((self.low &gt;&gt; 24) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [((self.low &gt;&gt; 16) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [((self.low &gt;&gt; 8) &amp; 0xff) as u8]).unwrap();
        self.writer.write(&amp;mut [(self.low &amp; 0xff) as u8]).unwrap();
    }
}

pub struct Decoder {
    reader: BufReader&lt;File&gt;,
    pub code: u32,
    pub range: u32,
    pub low: u32
}

impl Decoder {
    // リードオープン
    pub fn open(filename: &amp;str) -&gt; Result&lt;Decoder&gt; {
        let fs = File::open(filename)?;
        let mut rd = BufReader::new(fs);
        let mut c = 0;
        for _ in 0 .. 4 {
            let mut buff = [0u8; 1];
            rd.read(&amp;mut buff)?;
            c = (c &lt;&lt; 8) + buff[0] as u32;
        }
        Ok(Decoder { reader: rd, code: c, range: MAX_RANGE, low: 0 })
    }

    // 正規化
    pub fn normalize(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        let mut buff = [0u8; 1];
        while self.low &amp; MASK1 == (self.low + self.range) &amp; MASK1 {
            self.reader.read(&amp;mut buff)?;
            self.code = (self.code &lt;&lt; 8) + buff[0] as u32;
            self.low = self.low &lt;&lt; 8;
            self.range &lt;&lt;= 8;
        }
        while self.range &lt; MIN_RANGE {
            self.reader.read(&amp;mut buff)?;
            self.range = (MIN_RANGE - (self.low &amp; (MIN_RANGE - 1))) &lt;&lt; 8;
            self.code = (self.code &lt;&lt; 8) + buff[0] as u32;
            self.low = self.low &lt;&lt; 8;
        }
        Ok(())
    }
}
</pre>
<h4>●出現頻度表 (Binary Indexed Tree)</h4>
<pre class="list">
//
// frequency.rs : 出現頻度表 (Binary Indexd Tree)
//
//                Copyright (C) 2018 Makoto Hiroi
//
extern crate rangecoder;
use rangecoder::{Encoder, Decoder};

// 定数
const LIMIT: u32 = 0x8000;    // rangecoder::MIN_RANGE (0x10000) 以下の値を選ぶこと

// 出現頻度表 (BIT)
pub struct Frequency {
    table: Vec&lt;u32&gt;,
    sum: u32,
    mid: usize
}

impl Frequency {
    pub fn new(n: usize) -&gt; Frequency {
        let mut m = 1;
        while m &lt; n / 2 { m *= 2; }
        let mut tree = Frequency { table: vec![0; n], sum: 0, mid: m };
        for i in 0 .. n as u32 { tree.inc(i, 1); }
        tree
    }

    // 累積度数を求める
    fn cumul(&amp;self, mut c: u32) -&gt; u32 {
        let mut n = 0;
        if c &gt; 0 {
            n = self.table[0];
            c -= 1;
            while c &gt; 0 {
                n += self.table[c as usize];
                c = c &amp; (c - 1);
            }
        }
        n
    }

    // 出現頻度を求める
    fn get_prob(&amp;self, mut c: u32) -&gt; u32 {
        let mut val = self.table[c as usize];
        if c &gt; 0 &amp;&amp; c &amp; 1 == 0 {
            let p = c &amp; (c - 1);
            c -= 1;
            while c != p {
                val -= self.table[c as usize];
                c = c &amp; (c - 1);
            }
        }
        val
    }

    // 出現頻度の更新
    fn inc(&amp;mut self, c: u32, n: u32) {
        let mut c = c as i32;
        if c &gt; 0 {
            let k = self.table.len() as i32;
            while c &lt; k {
                self.table[c as usize] += n;
                c += c &amp; (- c);
            }
        } else {
            self.table[0] += n;
        }
        self.sum += n;
    }

    fn dec(&amp;mut self, c: u32, n: u32) {
        if c &gt; 0 {
            let mut c = c as i32;
            let k = self.table.len() as i32;
            while c &lt; k {
                self.table[c as usize] -= n;
                c += c &amp; (- c);
            }
        } else {
            self.table[0] -= n;
        }
        self.sum -= n;
    }

    fn halve(&amp;mut self) {
        for i in 0 .. self.table.len() as u32 {
            let n = self.get_prob(i) / 2;
            if n &gt; 0 {
                self.dec(i, n);
            }
        }
    }

    // 記号の探索
    fn search_code(&amp;self, value: u32) -&gt; (u32, u32) {
        let mut c = 0;
        let mut n = 0;
        if self.table[0] &lt;= value {
            let mut h = self.mid;
            n = self.table[0];
            while h &gt; 0 {
                if c + h &lt; self.table.len() &amp;&amp; n + self.table[c + h] &lt;= value {
                    n += self.table[c + h];
                    c += h;
                }
                h /= 2;
            }
            c += 1;
        }
        (c as u32, n)
    }

    // 符号化
    pub fn encode(&amp;mut self, rc: &amp;mut Encoder, c: u32, n: u32) -&gt; std::io::Result&lt;()&gt; {
        let temp = rc.range / self.sum;
        rc.low += self.cumul(c) * temp;
        rc.range = self.get_prob(c) * temp;
        rc.normalize()?;
        self.inc(c, n);
        if self.sum &gt;= LIMIT { self.halve(); }
        Ok(())
    }
    
    // 復号
    pub fn decode(&amp;mut self, rc: &amp;mut Decoder, n: u32) -&gt; std::io::Result&lt;u32&gt; {
        let temp = rc.range / self.sum;
        let (c, m) = self.search_code((rc.code - rc.low) / temp);
        rc.low += temp * m;
        rc.range = temp * self.get_prob(c);
        rc.normalize()?;
        self.inc(c, n);
        if self.sum &gt;= LIMIT {
            self.halve();
        }
        Ok(c)
    }
}
</pre>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2018 Makoto Hiroi<br>All rights reserved.</b>
</div>
<div class="small">
<hr>
[ <a href="../index.html">Home</a> | <a href="index.html">Linux</a> | <a href="rust.html">Rust</a> ]
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>