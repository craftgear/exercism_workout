<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Perl/Tk プログラミング入門</title>
  <meta name="description" content="Perl/Tk,Perl/Tk入門,GUI,プログラミング">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881765</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Perl/Tk memo</h1>
<h2>お気楽 Perl/Tk プログラミング入門</h2>
<div class="small">
[ <a href="perltk03.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk05.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chapter9">キャンパスウィジェット</h3>
<p> 今度は図形を表示する <b>キャンバス(canvas)</b> ウィジェットを説明します。キャンバスは、矩形、直線、楕円などの図形のほかに、イメージ、文字列、任意のウィジェットを表示することができます。キャンバスウィジェットは、メソッド Canvas で生成することができます。次のプログラムを実行すると、空のウィンドウが表示されます。
</p>

<pre class="list">
リスト : キャンバスウィジェット

use Tk;

$top = MainWindow-&gt;new();
$canvas = $top-&gt;Canvas( width =&gt; 150, height =&gt; 150 );
$canvas-&gt;pack();

MainLoop();
</pre>
<p> これで図形を表示するキャンバスをウィンドウに配置したことになります。また、キャンバスとスクロールバーを組み合わせて、表示範囲を変更することもできます。
</p>

<h4>●create メソッド</h4>
<p> キャンバスを配置しただけでは、なにも図形は描かれていません。図形を生成するにはメソッド create を使います。
</p>
<pre class="item">
$canvas-&gt;create( 種別, 座標, オプション, ... );
</pre>
<p>指定できる種別には、次のものがあります。
</p>
<table border=1>
<caption>表：図形の種別</caption>
<tbody>
  <tr><td>line</td><td>直線（折れ線）</td></tr>
  <tr><td>oval</td><td>楕円</td></tr>
  <tr><td>arc</td><td>円弧（楕円の円周の一部）</td></tr>
  <tr><td>rectangle</td><td>矩形</td></tr>
  <tr><td>polygon</td><td>多角形</td></tr>
  <tr><td>image</td><td>イメージ</td></tr>
  <tr><td>bitmap</td><td>ビットマップ</td></tr>
  <tr><td>text</td><td>文字列</td></tr>
  <tr><td>window</td><td>任意のウィジェット</td></tr>
</tbody>
</table>

<h4>●楕円を描く</h4>
<p> それでは実際に図形を表示してみましょう。
</p>
<pre class="list">
$id = $canvas-&gt;create( 'oval', 10, 10, 140, 140 );
</pre>
<img src="img/oval1.png" alt="楕円 1"> 楕円の描画
<p> ウィンドウに楕円が描画されました。楕円の場合、指定した矩形に内接するように描画されます。create メソッドは、図形を表す番号 (ID) を返します。これを使って図形を操作することができます。ウィジェットのメソッド cget や configure に対応するのが、itemcget と itemconfigure です。たとえば、楕円の中を赤色に塗りつぶしてみましょう。
</p>
<pre class="list">
$canvas-&gt;itemconfigure( $id, -fill =&gt; 'red' );
</pre>
<img src="img/oval2.png" alt="楕円 2"> 楕円の描画(塗りつぶし)

<p> 楕円の中が赤くなりましたね。よく使われるオプションには次のものがあります。
</p>
<ul>
   <li><b>-fill 色</b><br>               内部を塗りつぶす色
   <li><b>-stipple ビットマップ</b><br>  内部を塗りつぶすときの模様になるビットマップ
   <li><b>-outline 色</b><br>            枠の色
   <li><b>-width 幅</b><br>              枠の幅（デフォルトは 1.0）
</ul>
<p> -fill のデフォルトは none です。これは透明を表してます。-fill で色を指定したあとでも、itemconfigure で none に再設定すれば透明に戻すことができます。
</p>

<h4>●矩形を描く</h4>
<p> 矩形も楕円と同じ指定方法です。-stipple には、Tk に標準で組み込まれているビットマップを指定するのが一般的です。よく使うビットマップが灰色の模様を表す gray12, gray25, gray50, gray75 です。それでは実際に描画してみましょう。
</p>
<pre class="list">
$canvas-&gt;create( 'rectangle', 10, 10, 140, 140, -fill =&gt; 'green', -stipple =&gt; 'gray25' );
</pre>
<img src="img/rect.png" alt="矩形"> 矩形の描画

<h4>●直線を描く</h4>
<p> 次は直線です。2 点間だけではなく複数の点を指定すると、その間を直線で結びます。
</p>
では、直線を描画してみましょう。
<pre class="list">
$id = $canvas-&gt;create( 'line', 10, 10, 140, 10, 10, 140, 140, 140 );
</pre>
<p> <IMG SRC="img/line1.png" ALT="直線 1"> 直線の描画
</p>
<p> 画面に Z 字型の線が描かれましたね。線の色を指定するオプションは、直線の場合は -outline ではなくて -fill で指定します。では緑色に変更してみましょう。
</p>
<pre class="list">
$canvas-&gt;itemconfigure( $id, -fill =&gt; 'green', -width =&gt; 2.0 );
</pre>
<p> -width で線を太くしています。
</p>
<img src="img/line2.png" alt="直線 2"> 直線の色と太さを変更

<p> オプション -smooth を真 (1) に指定すると、滑らかな曲線を描画することができます。
</p>
<pre class="list">
$canvas-&gt;create( 'line', 10, 10, 140, 10, 10, 140, 140, 140, -smooth =&gt; 1, -fill =&gt; 'red' );
</pre>
<img src="img/line3.png" alt="直線 3"> 直線の描画(-smooth 指定)

<p> このほかにも、矢印の設定や折り返しのときの形など、いろいろなオプションが用意されています。
</p>
<h4>●多角形を描く</h4>
<p> 次は多角形です。五角形を作ってみましょう。各頂点の座標を指定しますが、最初の点と最後の点が結ばれて閉じた図形となります。
</p>
<pre class="list">
$canvas-&gt;create( 'polygon', 75, 10, 140, 70, 110, 140, 40, 140, 10, 70 );
</pre>
<p> polygon では、デフォルトで -fill オプションが黒、-outline は描画されません。それから、line と同様に -smooth を真 (1) に指定すると、多角形の角を丸めます。実際に試してみてください。
</p>
<img src="img/poly.png" alt="多角形"> 多角形の描画

<h4>●円弧を描く</h4>
<p> 次は円弧です。楕円の円周の一部分を表示します。座標の指定は oval と同じですが、オプションで表示する範囲を指定します。
</p>
<ul>
    <li><b>-start 角度</b><br>    開始位置を角度で指定
    <li><b>-extent 角度</b><br>   終了位置を開始位置からの角度で指定
    <li><b>-style 種別</b><br>    <b>arc</b> : 円周のみ描画<br>
                   <b>chord</b> : 円周と始点終点を結ぶ線分<br>
                   <b>pieslice</b> : 円周と中心から始点、終点を結ぶ線分
</ul>
<p> 角度は度数でプラスが反時計回り、マイナスが時計回りとなります。また、oval と同じオプションが使えます。ただし、-style が arc の場合、-fill で色を指定しても表示されません。chord か pieslice に変更すると表示されます。
</p>
<h4>●イメージの表示</h4>
<p> キャンバスはイメージとビットマップも表示することができます。
</p>
<pre class="item">
$canvas-&gt;image( x, y, オプション, ... );
$canvas-&gt;bitmap( x, y, オプション, ... );
</pre>
<p> x, y は表示する座標を表します。イメージのどの位置に対応させるかは、オプション -anchor で指定します。これは pack と同じ指定方法です。データとの対応は -image と -bitmap で指定します。たとえば、earthris.gif (Perl/Tk 配布パッケージ demos/images 内) を表示するには、次のようにプログラムします。
</p>

<pre class="list">
リスト : イメージの表示

use Tk;

$top = MainWindow-&gt;new();
$canvas = $top-&gt;Canvas( width =&gt; 400, height =&gt; 300);
$canvas-&gt;pack();

$image = $top-&gt;Photo( -file =&gt; 'earthris.gif' );
$canvas-&gt;create( 'image', 200, 150, -image =&gt; $image );

MainLoop();
</pre>
<p> これでキャンバスの中央にイメージが描画されます。
</p>
<h4>●文字列の表示</h4>
<p> 次は文字列です。当然ですがキャンバスに文字を描くことができます。
</p>
<pre class="item">
$canvas-&gt;('text', x, y, オプション, ... );
</pre>
<p> x, y は座標で、オプションには次のものが使えます。
</p>
<ul>
    <li><b>-anchor 位置</b><br>    座標とテキストの位置関係
    <li><b>-font フォント</b><br>  文字のフォント
    <li><b>-fill 色</b><br>        文字の色
    <li><b>-justify mode</b><br>   center:中揃え, left:左揃え, right:右揃え
    <li><b>-text 文字列</b><br>    表示する文字列
    <li><b>-width 長さ</b><br>     1 行の長さ
</ul>
<p> それでは実際に試してみましょう。
</p>
<pre class="list">
$canvas-&gt;create( 'text', 75, 75, -text =&gt; 'hello, world!', -font =&gt; 'FixedSys 14' );
</pre>
<img src="img/text.png" alt="テキスト"> テキストの描画

<p>これでウィンドウの中央に hello, world! が表示されます。
</p>
<h4>●ウィジェットの挿入</h4>
<p> キャンバス中にほかのウィジェットを表示させる場合は window を使います。
</p>
<ul>
    <li><b>-anchor 位置</b><br>         座標とテキストの位置関係
    <li><b>-window ウィジェット</b><br> 表示するウィジェット
    <li><b>-width  幅</b><br>           ウィジェットの幅
    <li><b>-height 高さ</b><br>         ウィジェットの高さ
</ul>
<p> たとえば、ラベルを表示させてみましょう。
</p>
<pre class="list">
$label = $top-&gt;Label( -text =&gt; 'hello, world!', -bg =&gt; 'green', -font =&gt; 'FixedSys 14' );
$canvas-&gt;create( 'window', 75, 75, -window =&gt; $label );
</pre>
<img src="img/window.png" alt="ラベル"> ラベルの描画

<p> 今度は背景色が緑の hello, world! が表示されました。
</p>
<h4>●図形操作用メソッド</h4>
<p> キャンバスで使用できる図形を一通り説明したところで、図形を操作するときによく使うメソッドを示します。
</p>
<table border=1>
<caption>表：図形操作用メソッド</caption>
<tbody>
  <tr><td>type ID</td><td>図形の種別を返す</td></tr>
  <tr><td>bbox(ID, ...)</td><td>指定した図形を囲む領域（矩形）をリストにして返す</td></tr>
  <tr><td>coords(ID, x0, y0, ...)</td><td>図形の座標の設定や問い合わせ</td></tr>
  <tr><td>delete(ID, ...)</td><td>図形の削除</td></tr>
  <tr><td>move(ID, dx, dt)</td><td>図形の移動</td></tr>
  <tr><td>lower(ID1, ID2)</td><td>重なり順を低くする</td></tr>
  <tr><td>raise(ID1, ID2)</td><td>重なり順を高くする</td></tr>
  <tr><td>bind(ID, eventsequence =&gt callback)</td><td> バインディングの設定</td></tr>
</tbody>
</table>
<p> ウィジェットと同様に、図形に対してもバインディングを設定することができます。
</p>
これはタグと一緒に詳しく説明します。
</section>
<hr>
<section class="contents">
<h3 id="chapter10">タグとバインド</h3>
<h4>●バインディングの設定</h4>
<p> キャンバスで作成した図形にはバインディングを設定することができます。簡単な例題として、作成した矩形をドラッグで移動させてみましょう。次のプログラムを実行してください。
</p>

<pre class="list">
リスト : バインディングの設定

use Tk;

$top = MainWindow-&gt;new();
$canvas = $top-&gt;Canvas( -width =&gt; 200, -height =&gt; 150 )-&gt;pack();
$id = $canvas-&gt;create( 'rectangle', 10, 10, 20, 20, -fill =&gt; 'brown' );
$canvas-&gt;bind( $id, "&lt;B1-Motion&gt;" =&gt; [\&amp;move_rect, Ev('x'), Ev('y')]);

# 移動
sub move_rect {
    my ($obj,$x,$y) = @_;
    $canvas-&gt;coords( $id, $x - 5, $y - 5, $x + 5, $y + 5 );
}

MainLoop();
</pre>

<p>  最初に、一辺の長さが 10 の矩形を作ります。次に、その矩形に対してバインディングを設定します。イベント &lt;B1-Motion&gt; は、左ボタンを押した状態でマウスを動かした場合、つまりドラッグに対応します。マウスの座標は関数 Ev( x ), Ev( y ) で求めることができます。メソッド bind で設定されたコールバック関数 move_rect には、第 1 引数にウィジェットのインスタンスが渡されることに注意してください。この場合は、キャンバスウィジェットのインスタンスが渡されます。関数 move_rect では、新しい座標を計算してから、図形の位置を coords で変更します。
</p>
<h4>●タグの設定</h4>
<p> それでは、操作する矩形を 3 つに増やしてみましょう。それぞれの矩形にバインディングを設定してもいいのですが、同じようなプログラムをいくつも書くのは面倒ですね。このような場合、<b>タグ (tag)</b> を設定すると簡単にプログラムを記述することができます。
</p>
タグには荷札という意味があり、図形に識別子をつける働きをします。<p>図形には複数のタグを設定することができます。そして、図形を操作するコマンドは、操作対象となる図形の指定を、番号のほかにもタグを使って行うことができるのです。タグの設定は、図形を生成するときにオプション -tags で行います。それでは矩形にタグをセットして 3 つ作ります。
</p>

<pre class="list">
リスト : バインディングの設定

use Tk;

$top = MainWindow-&gt;new();
$canvas = $top-&gt;Canvas( -width =&gt; 200, -height =&gt; 150 )-&gt;pack();

$canvas-&gt;create( 'rectangle', 10, 10, 20, 20, -fill =&gt; 'brown', <b>-tags =&gt; 'brown'</b> );
$canvas-&gt;create( 'rectangle', 20, 10, 30, 20, -fill =&gt; 'brown', <b>-tags =&gt; 'brown'</b> );
$canvas-&gt;create( 'rectangle', 30, 10, 40, 20, -fill =&gt; 'brown', <b>-tags =&gt; 'brown'</b> );
$canvas-&gt;bind( <b>'brown'</b>, "&lt;B1-Motion&gt;" =&gt; [\&amp;move_rect, Ev('x'), Ev('y')]);

# 移動
sub move_rect {
    my ($obj,$x,$y) = @_;
    $canvas-&gt;coords( <b>'current'</b>, $x - 5, $y - 5, $x + 5, $y + 5 );
}

MainLoop();
</pre>

<p> タグは文字列で指定します。今回は brown としました。このタグに対してバインディングを設定するので、図形の番号ではなくタグ brown を指定します。ただし、このままでは関数 move_rect で操作対象となる矩形がわかりません。この場合、特別なタグ <b>current</b> を使います。
</p>
<p> current は Perl/Tk が設定するタグで、マウスカーソルがある図形上にくると、その図形にタグ current を設定し、その図形からマウスカーソルから出るとタグ current を削除します。つまり、マウスカーソルが指している図形はタグ current で指定することができるのです。これで、複数の矩形をひとつの関数で操作することができます。
</p>
<p> このほかにも、タグには図形をまとめて操作することができる、という利点があります。
</p>
たとえば、矩形の色をまとめて変更する場合は、タグを使って行えばいいのです。
<pre class="list">
$canvas-&gt;itemconfigure( 'brown', -fill =&gt; 'green' );
</pre>
<p> これでタグ brown の図形の色を green に変更することができます。
</p>
削除する場合もタグを使えば簡単です。
<pre class="list">
$canvas-&gt;delete( 'brown' );
</pre>
<p> これでタグ brown の図形をすべて削除することができます。
</p>

<h4>●図形の探索</h4>
<p> キャンバスの中から図形を探すにはメソッド find を使います。
</p>
<pre class="item">
$canvas-&gt;find( searchcommand, args, ..... );
</pre>
<p> searchcommand には次の種類があります。
</p>
<ul>
  <li><b>all</b><br>すべての図形をリストにして返す
  <li><b>withtag, IDorTAG</b><br>ID または TAG で指定した図形のリストを返す
  <li><b>above, IDorTAG</b><br>指定した図形の上にある図形を返す
  <li><b>below, IDorTAG</b><br>指定した図形の下にある図形を返す
  <li><b>enclosed, x1, y1, x2, y2</b><br>指定した矩形に完全に含まれる図形のリストを返す
  <li><b>overlapping, x1, y1, x2, y2</b><br>指定した矩形に一部でも含まれる図形のリストを返す
  <li><b>closest, x, y, [num], [ID]</b><br>
      座標 (x, y) にもっとも近い図形を返す。num (正の整数値) を指定すると、
      それよりも近い図形はすべて重なっているとみなし、一番上にある図形を返す。
      さらに ID を指定すると、それより下にある図形の中から検索する。
</ul>
<p> それでは簡単な例を示しましょう。キャンバスに矩形を 4 つ描きます。
</p>
<pre class="list">
$canvas-&gt;create( 'rectangle', 10, 10, 190, 140, -fill =&gt; 'darkgreen', -tags =&gt; 'base' );
$canvas-&gt;create( 'rectangle', 40, 40, 90, 90, -fill =&gt; 'red', -tags =&gt; 'rect' );
$canvas-&gt;create( 'rectangle', 70, 70, 120, 120, -fill =&gt; 'blue', -tags =&gt; 'rect' );
$canvas-&gt;create( 'rectangle', 130, 20, 180, 130, -fill =&gt; 'yellow', -tags =&gt; 'rect' );
</pre>
<p><IMG src="img/tag.png" alt="4 つの矩形"> 4 つの矩形を描画
</p>
<p> 各矩形の ID は描画した順番に 緑 (1), 赤 (2), 青 (3), 黄 (4) となります。この状態で、図形の探索を実行します。
</p>
<pre>
$canvas-&gt;find('all')
=&gt; 1, 2, 3, 4

$canvas-&gt;find('withtag', 'rect')
=&gt; 2, 3, 4

$canvas-&gt;find('above', 1 )
=&gt; 2

$canvas-&gt;find('below', 4 )
=&gt; 3

$canvas-&gt;find('enclosed', 30, 30, 100, 100 )
=&gt; 2

$canvas-&gt;find('overlapping', 30, 30, 100, 100 )
=&gt; 1, 2, 3

$canvas-&gt;find('closest', 0, 0 )
=&gt; 1
</pre>
<p> all を実行すると、すべての図形、緑、赤、青、黄を返します。withtag でタグ rect を探すと、赤、青、黄を返します。above と below は、見た目の重なりではありません。Tk で管理している <b>重なり順</b> で判断することに注意してください。
</p>
<p> 重なり順は描画した順番、緑、赤、青、黄になります。above で緑の上にある図形を探すと赤を返します。これは見た目と同じですが、below で黄の下にある図形を探してみると青を返すのです。見た目で判断すると緑を返すように思われますが、重なり順で黄の下にある青を返すのです。ご注意くださいませ。なお、重なり順はメソッド raise と lower で変更することができます。
</p>
<p> enclosed で領域 (30, 30, 100, 100) にある図形を探すと赤を返します。enclosed は指定した領域に図形が完全に含まれていないといけませんが、overlapping は一部でも指定した領域と重なっていればいいので、緑、赤、青が返されます。最後に closest で (0, 0) に一番近い図形を探しています。これは緑を返します。
</p>

<p> このほかに、タグを設定するメソッド addtag と、タグを削除するメソッド dtag があります。
</p>
<pre class="item">
$canvas-&gt;addtag( tag, searchcommand, args, ... );
$canvas-&gt;dtag(IDorTAG, tag );
</pre>
<p> メソッド addtag は find と同じ searchcommand を指定して、条件に合った図形に tag を設定します。図形の ID がわかっている場合は、メソッド itemconfigure で タグをセットすることもできます。メソッド dtag は指定した図形から tag を削除します。
</p>
</section>
<hr>
<section class="contents">
<h3><A name="chapter11">モグラたたき</A></h3>
<p> 今度は簡単なゲームを作ってみましょう。簡単なアクションゲームならば Perl/Tk だけでも何とかなりそうなので、「モグラたたき」を作ることにしました。5 行 5 列の穴からモグラが出くるので、それをマウスでクリックしてください。私は絵心のないプログラマなのでモグラの代わりに楕円を使いますが、グラフィック表示するように改造するとゲームらしくなるでしょう。
</p>

<h4>●after メソッド</h4>
<p> ゲーム作成のポイントは、モグラの出し入れとモグラを叩く処理です。モグラを叩くことはマウスのクリックで行いますので、モグラ（楕円）に対してバインディングを設定すれば簡単です。
</p>
<p> モグラの出し入れですが、ユーザーからの入力がなくてもゲームを進行させなくてはいけなので、単純なイベント駆動型アプリケーションでは「モグラたたき」を実現することはできません。このため、プログラム自身で何らかのきっかけを作ってやる必要があります。このような場合、役に立つメソッドが after です。after の機能を示します。
</p>
<ul>
   <li><b>$widget-&gt;atter( msec );</b><br>指定された時間（単位は msec）だけ待つ。
   <li><b>$widget-&gt;after( msec, callback );</b><br>指定した時間経過後 callback 関数を実行する。固有番号 id を返す。
   <li><b>$widget-&gt;afterCancel( id );</b><br>固有番号 id のコマンド実行待ちを取り消す。
   <li><b>$widget-&gt;afterCancel( callback );</b><br>callback の実行待ちを取り消す。
   <li><b>$widget-&gt;afterInfo( id );</b><br> 固有番号 id の実行待ちコマンド情報を返す。
</ul>
<p> このように、after には単純な時間待ちを行うほかに、一定時間後に指定したコマンドを起動するタイマーの働きも持っています。たとえば、ゲームを進行させる関数を game としましょう。game を一定間隔で実行させる場合、game の最後で after を使って自分自身の起動を設定すればいいのです。具体的には次のようにプログラムします。
</p>
<pre class="list">
sub game {
    # game の処理
    .....
    $top-&gt;after( 500, \&amp;game );
}
</pre>
<p> これで 500 msec 後に game が実行されます。もっとも、厳密に 500 msec ごとに game が実行されるわけではありません。game の処理にも時間がかかりますし、Windows はマルチタスクで動作しているので、ほかのタスクの影響も受けるからです。まあ、モグラたたきのようなゲームの場合、厳密なリアルタイム処理は必要としないので、これで十分です。
</p>

<p> game は一定間隔で時を刻むので、これを使ってモグラを管理します。モグラたたきの場合、モグラが隠れている状態から、モグラが出る、モグラを叩く、または叩き損ねてモグラが逃げる、そしてモグラが隠れている状態に戻ります。この場合、モグラが穴を移動するのではなく、各穴にモグラが一匹ずついて出たり隠れたりする、と考えた方が簡単です。つまり、モグラを中心に考えるのではなく、穴の状態を基準にプログラミングするのです。
</p>

<p> モグラを出す場合は、モグラが隠れている穴の中からランダムで選べばいいでしょう。このあとの状態は、それぞれ持続時間が異なります。モグラが出ている時間を 3 秒、叩かれた状態を 1 秒間、逃げた状態を 2 秒間表示するとしましょう。この時間管理を game を使って行います。具体的には、穴の状態を無名のハッシュで表します。この中で、状態を表す変数 state と持続時間を表す変数 mogutime を定義します。
</p>
<table border=1>
<caption>表：state の値</caption>
<thead>
  <tr><th>値</th><th>状態</th></tr>
</thead>
<tbody>
  <tr><td>０</td><td>モグラが隠れている状態</td></tr>
  <tr><td>１</td><td>モグラが出ている状態</td></tr>
  <tr><td>２</td><td>モグラを叩いた状態 (HIT! と表示する)</td></tr>
  <tr><td>３</td><td>モグラが逃げた状態 (MISS と表示する)</td></tr>
  <tr><td>４</td><td>準備中</td></tr>
</tbody>
</table>
<p> モグラの状態が変化するときは、state の値を書き換えると同時に mogutime の値をセットします。game は state が 0 以外の場合、mogutime の値を -1 していき、mogutime が 0 になったら (タイムアップ)、次の状態へ変化させます。たとえば、モグラを出すときは、state が 0 の穴からランダムに選び、state を 1 に書き換え、mogutime に 6 をセットします。game は 500 msec 間隔で実行されるので、これで約 3 秒間モグラを表示することになります。
</p>

<p> state が 1 でタイムアップした場合は、モグラを叩き損ねた場合です。このときは、state を 3 に書き換えて mogutime を 4 にセットします。モグラを叩いた場合は、state を 2 に書き換え、mogutime を 2 にセットします。この処理はモグラにバインディングされたイベントハンドラで行い、マウスの左クリックで実行されます。この処理は game の実行とは関係なく発生します。つまり、モグラを叩く処理と game の処理は非同期で行われるのです。
</p>

<p> 一般に、非同期の処理をプログラミングすることはたいへん難しいのですが、GUI アプリケーションの場合、イベントが非同期で発生することは当たり前のことです。Perl/Tk ではイベントントハンドラをプログラムするだけで済みます。
</p>

<p> state が 2 や 3 の状態でタイムアップしたら、state を 4 の状態（準備中）にします。これは同じ穴からモグラがすぐに出てこないようにするためです。この時間は 3 秒間とし、タイムアップしたら state を 0 に戻します。
</p>

<p> それから、ゲームに変化をつけるためにレベルを導入します。最初はレベル 1 で、10 匹モグラを叩くたびにレベルアップします。1 匹叩くたびにレベルだけ得点が入ります。レベル 1 のときは 1 点しか入りませんが、レベルが 10 になると 1 匹叩くたびに 10 点入ります。そして、レベルアップするたびに、同時に出現するモグラの数を増やしましょう。10 匹叩き損ねたらゲームオーバーとします。
</p>

<h4>●重なり順の変更</h4>
<p> 表示にはキャンバスウィジェットを使いますが、モグラを出すたびに楕円を描画していては無駄ですね。あらかじめ必要な図形を用意しておいて、穴を表す図形の背後に隠しておくことにします。
</p>

<p> ほとんどのウィンドウシステムでは、上にある窓が下にある窓を覆い隠します。ウィジェットにも順番があり、Tk の場合はあとから作成したウィジェットが上になります。ウィジェットの重なり順を変更するコマンドが raise と lower です。
</p>
<pre class="item">
$widget1-&gt;raise( $widget2 );
$widget1-&gt;lower( $widget2 );
</pre>
<p> $widget2 が省略された場合、raise は $widget1 の重なり順をいちばん上にし、lower はいちばん下にします。$widget2 を指定した場合は、$widget2 に対して $widget1 を、raise では上に lower では下にします。
</p>

<p> キャンバスウィジェットで作成する図形も同じです。あとから作成した図形が上となり、その順番をウィジェットのメソッド raise と lower で変更することができます。
</p>
<pre class="item">
$canvas-&gt;raise( $widget1, $widget2 );
$canvas-&gt;lower( $widget1, $widget2 );
</pre>
<p> $widget2 が省略されると、raise は $widget1 の重なり順をいちばん上にし、lower はいちばん下にします。このゲームでは、穴を矩形、モグラを楕円、HIT! と MISS をテキストで描画しておき、状態に合わせてその図形の優先順位を一番上にします。作成した図形の ID は無名のハッシュに格納しておきます
</p>
<table border=1>
<caption>表：図形の ID を格納</caption>
<tbody>
  <tr><td>hole</td><td>穴の ID を格納する</td></tr>
  <tr><td>mogu</td><td>モグラの ID を格納する</td></tr>
  <tr><td>miss</td><td>MISS の ID を格納する</td></tr>
  <tr><td>hit</td><td>HIT! の ID を格納する</td></tr>
</tbody>
</table>
<p> 穴は 5 行 5 列なので、各配列は 2 次元配列としてアクセスします。といっても、Perl の場合は 1 次元配列しかありません。リファレンスを使って「配列の配列」を作り、擬似的に 2 次元配列を実現します。
</p>

<pre class="list">
リスト : グローバル変数の初期化

@mogu_house = ();
for( $x = 0; $x &lt; 5; $x++ ){
    $mogu_house[$x] = [];
    for( $y = 0; $y &lt; 5; $y++ ){
	$mogu_house[$x][$y] = &amp;init_mogura( $x, $y );
    }
}
$buff1 = "Click Start Menu !!";
$hi_score = 0;
</pre>

<p> モグラが出入りする穴は配列 @mogu_house で表します。ここにモグラの状態やデータを格納した「無名のハッシュ」をセットします。無名のハッシュは関数 init_mogura で生成します。この関数でモグラに必要な図形を生成します。
</p>

<h4>●バインディングの設定</h4>
<p> モグラを作成したときは、バインディングを設定しなくてはいけません。これは次のように行います。
</p>

<pre class="list">
リスト : バインディングの設定

my $mogu = $canvas-&gt;create( 'oval', $x1, $y1, $x1 + 59, $y1 + 39,
                            -outline =&gt; 'darkgreen', -fill =&gt; 'blue',
                            -tags =&gt; 'mogura' );
$canvas-&gt;bind( $mogu, "&lt;Button-1&gt;" =&gt; [\&amp;attack, $x, $y] );
</pre>
<p> これは初期化ルーチン init_mogura から抜き出したものです。作成したモグラにイベントハンドラをバインディングしています。イベントハンドラは attack ですが、モグラの位置 $x と $y を引数に指定しているので、それぞれのモグラにバインディングされる attack には、異なる位置が与えられることに注意してください。これでクリックされたモグラを特定することができるので、わざわざマウスの位置を求める必要はありません。
</p>

<h4>●attack</h4>
<p> イベントハンドラ attack は次のようになります。
</p>

<pre class="list">
リスト : 命中処理

sub attack {
    my ($id, $x, $y) = @_;
    my $mogura = $mogu_house[$x][$y];
    ++$hit_count;
    if( $hit_count and ($hit_count % 10 == 0) ){
	$level++;
    }
    $score += $level;
    $now_mogu--;
    $mogura-&gt;{'state'} = 2;
    $mogura-&gt;{'mogutime'} = 2;
    $canvas-&gt;lower( $mogura-&gt;{'mogu'} );
    $canvas-&gt;raise( $mogura-&gt;{'hit'} );
    &amp;print_label();
}
</pre>
<p> グローバル変数 $hit_count は叩いたモグラの数、グローバル変数 $now_mogu は穴から出ているモグラの総数を表します。これらの変数はレベル管理に使います。モグラを隠している状態では、クリックしてもイベントハンドラは起動されないので、状態を表す state をチェックする必要はありません。このへんは Perl/Tk が面倒を見てくれるので、プログラムは簡単になります。print_label はスコアを計算してラベルに表示します。
</p>

<h4>●game</h4>
<p> ゲームを進めるために一定間隔で実行される game は次のようになります。
</p>

<pre class="list">
リスト : ゲームの実行

sub game {
    my ($x, $y);
    for( $x = 0; $x &lt; 5; $x++ ){
        for( $y = 0; $y &lt; 5; $y++ ){
            my $mogura = $mogu_house[$x][$y];
            if( $mogura-&gt;{'state'} != 0 ){
                if( --$mogura-&gt;{'mogutime'} == 0 ){
                    if( &amp;change_mogura( $mogura ) ){
                        &amp;game_over();
                        return;
                    }
                }
            } else {
                &amp;gen_mogura( $mogura );
            }
        }
    }
    $top-&gt;update;
    $top-&gt;after( 500, \&amp;game );
}
</pre>
<p> game では state が 0 以外の穴について mogutime を -1 していき、タイムアップしたならばモグラのステートを変更するため change_mogura を呼び出します。change_mogura ではモグラの状態を変更します。もしも、ミスが 10 回に達したら 1 を返すので、ゲームの終了処理を game_over で行います。このあとは return で game を抜けます。
</p>
<p> after の前のメソッド update は、待ちイベントを実行するコマンドです。モグラの出し入れやスコア表示など、Perl/Tk では簡単に行っているように見えますが、そのたびに画面更新のイベントが発生します。これらの処理は Perl/Tk が面倒をみてくれるのですが、プログラムの実行に時間がかかると、その処理を行うことができません。このため、すべての待ちイベントを処理する update を実行して、画面の状態を確実に更新するようにしています。
</p>

<p> あとは特に難しい処理を行っていないので、ここまでの説明でソースファイルは読むことができるはずです。ゲームは単純なのですぐに飽きるでしょう。いろいろと改造してみてください。
</p>
<img src="img/mogura.png" alt="モグラたたき"> モグラたたきゲームの画面

<p><A href="mogura.html">●ソースファイルを読む</A>
</p>
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2001-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="perltk03.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk05.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>