<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Perl/Tk プログラミング入門</title>
  <meta name="description" content="Perl/Tk,Perl/Tk入門,GUI,プログラミング">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881765</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Perl/Tk memo</h1>
<h2>お気楽 Perl/Tk プログラミング入門</h2>
<div class="small">
[ <a href="perltk05.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk07.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chapter15">ウィジェットの状態</h3>
<h4>●-state オプション</h4>
<p> Tk にはいろいろなウィジェットが用意されていますが、場合によっては、ウィジェットの機能を無効にしたいことがあります。たとえば、ボタンやメニューに割り当てた機能が動作しない場合、ボタンやメニューの選択を無効にしなければいけませんが、そのことをユーザーに知らせた方が使いやすいアプリケーションになります。この場合、ウィジェットの状態を制御する -state オプションを使うと便利です。-state の値を表に示します。
</p>

<table border=1>
<caption>表：-state の値</caption>
<tbody>
  <tr><td>normal</td><td>通常の状態</td></tr>
  <tr><td>active</td><td>アクティブな状態</td></tr>
  <tr><td>disabled</td><td>無効な状態</td></tr>
</tbody>
</table>

<p> ボタンなどのウィジェットでは、その上にマウスカーソルがくるとアクティブな状態になります。Tk では、ウィジェットがアクティブな状態になったときに、そのウィジェットを強調表示することができます。そのことで、マウスボタンを押したときに何か処理が行われることを表すことができます。
</p>

<p> -state に disabled を設定すると、そのウィジェットは無効な状態になります。ボタンウィジェットであれば、ラベルの色が変わりマウスでボタンをクリックしても押すことができなくなります。テキストの色はオプションで指定することができます。
</p>

<table border=1>
<caption>表：テキストの色を指定するオプション</caption>
<tbody>
  <tr><td>-activeforeground</td><td>アクティブ時の色を指定</td></tr>
  <tr><td>-activebackground</td><td>アクティブ時の背景色を指定</td></tr>
  <tr><td>-disabledforeground</td><td>無効時の色を指定</td></tr>
</tbody>
</table>

<p> 無効時の背景色は通常の背景色と同じになります。
</p>

<h4>●ボタンの状態を変更する</h4>
<p> それでは簡単な例を示しましょう。ラジオボタンを使ってボタンの状態を設定します。
</p>

<pre class="list">
リスト : ボタンの状態を変更する

use Tk;

$var = 'normal';

# ボタンの状態を変更
sub change_state {
  $button-&gt;configure( -state =&gt; $var );
}

# メインウィドウ
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

# ボタンの設定
$button = $top-&gt;Button( -text =&gt; 'button',
                        -activeforeground =&gt; 'green',
                        -disabledforeground =&gt; 'red' )-&gt;pack( -fill =&gt; 'x' );

# ラジオボタンの設定
foreach $i ( 'normal', 'active', 'disabled' ){
  $top-&gt;Radiobutton( -text =&gt; $i, -value =&gt; $i, -variable =&gt; \$var,
                     -command =&gt; \&amp;change_state )-&gt;pack( -anchor =&gt; 'w' );
}

MainLoop();
</pre>

<p> ラジオボタンで選択した値はグローバル変数 $var に格納し、関数 change_state でボタンの状態を変更します。変数 $var は、あらかじめ normal に初期化しておきます。change_state では、ウィジェットコマンド configure を使って -state に変数 var の値をセットするだけです。これでボタンの状態を変更することができます。
</p>

<p>
<img src="img/state0.png" alt="normal button">
<img src="img/state1.png" alt="active button">
<img src="img/state2.png" alt="disable button">
ボタンの状態を変更
</p>
<h4>●メニューの状態を変更する</h4>
<p> 次はメニューの状態を変更してみましょう。一般に、メニューには複数の項目を登録しますが、それらの項目に対してオプションを設定することができます。Tk の場合、メニュー項目を操作するために複数のメソッドが用意されていて、メニュー項目のオプションは entryconfigure メソッドで設定することができます。
</p>

<p> ところが Perl/Tk の entryconfigure は、使い方がよくわかりません。いろいろ試してみたのですが、Perl/Tk では Tcl/Tk のように動いてくれませんでした。使い方をご存知の方は教えてくださいませ。Tcl/Tk の entryconfigure は、Tcl/Tk 応用編の <a href="../tcl_tk_doc/tcltk202.html">ウィジェットの状態</a> をご覧ください。
</p>

<p> そこで、別の方法を使います。Perl/Tk では、メニュー項目を生成したときに、それに対応するオブジェクトを返します。たとえば、メニュー項目でチェックボタンを作るには checkbutton メソッドを呼び出しますが、その返り値はチェックボタンに対応するオブジェクトです。ウィジェットのオプションを設定するメソッドに configure がありますが、これはどのウィジェットでも共通に使えるメソッドです。ようするに、メニューオブジェクトの configure メソッドを呼び出せば、そのメニューのオプションを設定することができるのです。
</p>

<p> それでは configure メソッドを使って、メニューの状態を変更してみましょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : メニューの状態を変更する

use Tk;

# グローバル変数
@state = ('normal', 'normal', 'normal');

# メニューの状態を変更
sub change_state {
  my $i = shift;
  $menu_table[$i]-&gt;configure( -state =&gt; $state[$i] );
}

# メインウィンドウ
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

# メニューの設定
$m = $top-&gt;Menu( -type =&gt; 'menubar' );
$top-&gt;configure( -menu =&gt; $m );

$m1 = $m-&gt;cascade( -label =&gt; 'Menu', -under =&gt; 0, -tearoff =&gt; 0 );
foreach $i (0 .. 2) {
  $menu_table[$i] = $m1-&gt;command( -label =&gt; "Menu$i", -command =&gt; sub { } );
}

# チェックボタンの設定
foreach $i (0 .. 2){
  $top-&gt;Checkbutton( -text =&gt; "Menu$i disabled", -variable =&gt; \$state[$i],
                     -onvalue =&gt; 'disabled', -offvalue =&gt; 'normal',
                     -command =&gt; [\&amp;change_state, $i] )-&gt;pack( -anchor =&gt; 'e' );
}

MainLoop();
</pre>

<p> メニューのオブジェクトは配列 @menu_table に格納し、チェックボタンが選択されたら、関数 change_state でメニューの状態を変更します。チェックボタンではオン・オフの値を disabled と normal に設定し、その値は配列 @state に格納します。メニューも色を指定することができますが、無効時の色を指定する -disabledforeground は用意されていません。メニューの状態を disabled に設定すると、その Menu が灰色に表示され選択することができなくなります。
</p>

<img src="img/state3.png" alt="normal Menu"> 通常のメニュー
<br><br>
<img src="img/state4.png" alt="disabled Menu0"> Menu0 を disabled に設定
<br><br>
<img src="img/state5.png" alt="disabled Menu0, Menu1"> Menu0 と Menu1 を disabled に設定

<h4>●カーソルの状態を変更する</h4>
<p> もうひとつ便利なオプションを紹介しましょう。マウスカーソルの形状は -cursor オプションで変更することができます。たとえば、待ち状態を表すカーソルに変更するには、次のように指定します。
</p>
<pre class="item">
$top-&gt;configure( -cursor =&gt; 'wait' );
</pre>
<p> メインウィンドウのマウスカーソルを wait に変更します。空文字列を設定すると、デフォルトのマウスカーソルに戻ります。また、-cursor はウィジェットごとに設定することができます。Tk で使用できるカーソル名は、Tk のソースファイル cursorfont.h に記述されています。これらのカーソルを表示するプログラムを次に示します。
</p>

<pre class="list">
リスト : カーソルを表示する

use Tk;

# カーソル名
@cursor1 = qw(
  X_cursor arrow based_arrow_down based_arrow_up boat bogosity bottom_left_corner
  bottom_right_corner bottom_side bottom_tee box_spiral center_ptr circle clock
  coffee_mug cross cross_reverse crosshair diamond_cross dot dotbox double_arrow
  draft_large draft_small draped_box exchange fleur gobbler gumby hand1 hand2
  heart icon iron_cross left_ptr left_side left_tee leftbutton ll_angle lr_angle
  man middlebutton mouse pencil pirate plus question_arrow right_ptr right_side
  right_tee rightbutton rtl_logo sailboat sb_down_arrow sb_h_double_arrow
  sb_left_arrow sb_right_arrow sb_up_arrow sb_v_double_arrow shuttle sizing spider
  spraycan star target tcross top_left_arrow top_left_corner top_right_corner
  top_side top_tee trek ul_angle umbrella ur_angle watch xterm
);

# メインウィンドウ
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

# ラベルの設定
$c = 0;
for( $x = 0; $x &lt; 6; $x++ ){
  $f = $top-&gt;Frame;
  for( $y = 0; $y &lt; 13; $y++ ){
    $n = $cursor1[$c++];
    $f-&gt;Label( -text =&gt; $n, -cursor =&gt; $n )-&gt;pack( -fill =&gt; 'x' );
  }
  $f-&gt;pack( -side =&gt; 'left', -fill =&gt; 'x' );
}

MainLoop();
</pre>

<p> ラベルごとに -cursor を設定します。マウスカーソルがラベル上にくると、そのラベルに設定した形状に変化します。いろいろなマウスカーソルが用意されているので、実際に試してみると面白いですよ。
</p>

<p> このほかに、Windows で使用できるカーソル名には次のものがあります。
</p>
<pre class="item">
starting, ibeam, no, uparrow, wait, 
size_ne_sw, size_ns, size_nw_se, size_we
</pre>
<p> 別名でもカーソルの形状はほとんど同じという場合もありますので、実際に試してみてください。
</p>
</section>
<hr>
<section class="contents">
<h3 id="chapter16">ウィンドウのリサイズ</h3>
<p> 今回はウィンドウの大きさを変更してみましょう。もちろん、Tk はデフォルトでウィンドウのリサイズに対応しています。いままでのサンプルプログラムでも、マウスでウィンドウの大きさを変更することができます。ただし、ウィジェットの大きさは変化しません。ウィンドウを小さくしたらウィジェットが表示されなくなった、ということも起こります。まあ、これはウィンドウの大きさを制限することで回避することができます。ですが、アプリケーションによっては、ウィンドウのリサイズに合わせてウィジェットの大きさを変更した方がよい場合もあるでしょう。
</p>

<h4>●Packer のリサイズ</h4>
<p> ところで、ウィジェットのリサイズは面倒だな、と思われた方はいませんか。まじめに考えると、ウィンドウのサイズからウィジェットのサイズを計算して、大きさを変更する処理が必要になるのですが、Tk ではそんな難しいことをする必要はありません。ジオメトリマネージャーに用意されているオプションを設定するだけで、ウィンドウのサイズに合わせてウィジェットの大きさを変更することができます。Packer を使う場合は、次のオプションを設定します。
</p>
<ul>
  <li><b>-expand =&gt; boolean</b><br>
       ウィンドウに余白が生じたとき、boolean が真であれば余白をウィジェットに割り当てる。
</ul>
<p> 余白をウィジェットに割り当てただけでは、ウィジェットは大きくなりません。ウィジェットを引き伸ばすための -fill オプションを設定してください。それでは簡単な例を示しましょう。次のプログラムを見てください。
</p>

<pre class="list">
リスト : Packer のリサイズ

use Tk;

$top = MainWindow-&gt;new();

$top-&gt;Button( -text =&gt; 'button 0' )-&gt;pack( -expand =&gt; 1, -fill =&gt; 'both' );
$top-&gt;Button( -text =&gt; 'button 1' )-&gt;pack( -expand =&gt; 1, -fill =&gt; 'both' );

MainLoop();
</pre>

<img src="img/packer0.png" alt="2 つのボタン"> Packer によるボタンの配置
<br><br>
<img src="img/packer1.png" alt="2 つのボタン（大）"> ウィンドウを拡大する

<p> ウィンドウ全体に 2 つのボタンが表示されます。マウスでウィンドウの大きさを変えてみてください。ウィンドウに合わせてボタンの大きさも変化します。このように、Tk ではオプションを設定するだけで、ウィンドウのリサイズにも簡単に対応することができるのです。
</p>
<p> ウィジェットを配置する順番も大切です。Packer はウィンドウが小さくなるとウィジェットを圧縮しますが、本当にスペースが無くなるとウィジェットは表示されなくなります。このとき、配置された逆順でウィジェットが削除されます。つまり、最初に配置されたウィジェットが最後まで残るのです。大切なウィジェットは最初に配置した方がいいでしょう。
</p>

<h4>●Gridder のリサイズ</h4>
<p> Gridder のリサイズは、マスの状態を設定するメソッド gridColumnconfigure と gridRowconfigure で行います。
</p>
<pre class="item">
$window-&gt;gridColumnconfigure( column, options );
$window-&gt;Rowconfigure( row, options );
</pre>
<table border=1>
<caption>表：オプションの種類</caption>
<tbody>
  <tr><td>-minsize</td><td>最小の幅/高さを数値で指定する</td></tr>
  <tr><td>-weight</td><td>余白を配分するときの割合を数値で指定する</td></tr>
  <tr><td>-pad</td><td>詰め物を数値で指定する</td></tr>
</tbody>
</table>

<p> リサイズに対応するには、オプション -weight に 1 以上の整数値を指定します。簡単な使用例を示しましょう。ボタンを 4 つ Gridder で配置します。
</p>

<pre class="list">
リスト : Gridder のリサイズ

use Tk;

$top = MainWindow-&gt;new();

@column_data = (0, 0, 1, 1);
@row_data    = (0, 1, 0, 1);

foreach $i (0 .. 3) {
  $top-&gt;Button( -text =&gt; "button $i" )
      -&gt;grid( -column =&gt; $column_data[$i], -row =&gt; $row_data[$i], -sticky =&gt; 'nsew');
}

MainLoop();
</pre>

<img src="img/grider0.png" alt="4 つのボタン"> Gridder によるボタンの配置

<p> gridColumnconfigure は縦方向に配置されたマスのオプションを設定します。次のように、0 列に -weight =&gt; 1 を設定します。
</p>

<pre class="item">
$top-&gt;gridColumnconfigure( 0, -weight =&gt; 1 );
</pre>
<p> ボタンはメインウィンドウに配置されているので、gridColumnconfigure はメインウィンドウのオブジェクト $top のメソッドとして呼び出します。これで、ウィンドウが横に大きくなると、0 列に配置されたボタン button 0 と button 1 も横に大きくなります。
</p>

<img src="img/grider1.png" alt="4 つのボタン"> button 0, 1 は横方向に伸びる

<p> 1 列目は -weight オプションを設定していないので、余白は割り当てられません。それでは、次のプログラムを追加してみましょう。
</p>
<pre class="list">
$top-&gt;gridColumnconfigure( 1, -weight =&gt; 2 );
</pre>

<img src="img/grider2.png" alt="4 つのボタン"> 4 つのボタンが横方向に伸びる

<p> 今度は、1 列目にも余白が割り当てられますが、-weight オプションの設定が 2 なので 0 列の 2 倍の余白が割り当てられます。つまり、ボタン button 2 と button 3 の方が大きく伸びるわけです。
</p>

<p> このままではウィジェットの縦方向が大きくなりません。これに対応するには gridRowconfigure を使います。次のプログラムを追加してください。
</p>
<pre class="list">
$top-&gt;gridRowconfigure( 0, -weight =&gt; 1 );
$top-&gt;gridRowconfigure( 1, -weight =&gt; 2 );
</pre>

<img src="img/grider3.png" alt="4 つのボタン"> 4 つのボタンが縦横方向に伸びる

<p> 縦に増えた余白は、0 行と 1 行に 1 対 2 の割合で配分されます。したがって、ウィンドウを大きくするとボタン button 3 がいちばん大きくなります。縦と横の関係で混乱しそうですが、実際にプログラムを動かしてみてください。納得してもらえると思います。
</p>

<h4>●キャンバスウィジェットのリサイズ</h4>
<p> 次に、キャンバスウィジェットのリサイズを行ってみましょう。キャンバスもウィジェットなので、pack や grid のオプションを指定することで、ウィンドウのリサイズに対応することができます。次のプログラムを実行してください。
</p>

<pre class="list">
リスト : キャンバスウィジェットのリサイズ（その１）

use Tk;

# メインウィンドウの設定
$top = MainWindow-&gt;new();

# キャンバスの設定
$canvas = $top-&gt;Canvas( -bg =&gt; 'darkgreen', -width =&gt; 200, -height =&gt; 200 );
$canvas-&gt;create( 'rectangle', 20, 20, 180, 180, -fill =&gt; 'red' );
$canvas-&gt;pack( -fill =&gt; 'both', -expand =&gt; 1 );

MainLoop();
</pre>

<img src="img/canvas0.png" alt="キャンバス"> キャンバスウィジェットを配置
<br><br>
<img src="img/canvas1.png" alt="キャンバス"> ウィンドウを縮小
<br><br>
<img src="img/canvas2.png" alt="キャンバス"> ウィンドウを拡大

<p> キャンバスウィジェットの背景は darkgreen で、その上には赤い四角形が描かれています。ご覧のように、マウスでウィンドウの大きさを変えると、キャンバスウィジェットの大きさは変わりますが、図形の大きさは変わりません。
</p>
<p> 図形は pack で配置されているわけではないので、Packer はキャンバスウィジェットを引き伸ばすことはできても、その中の図形を操作することはできないのです。図形はユーザーが定義したものですから、Packer が関知しないのは当然のことですね。したがって、ウィンドウのリサイズに対応するには、ユーザー側で図形を再描画する処理をプログラムする必要があるのです。
</p>

<h4>●図形の再描画</h4>
<p> 図形を再描画するには、ウィンドウがリサイズされたときに発生するイベント <b>Configure</b> を使います。このイベントをバインドして、ウィンドウの大きさが変わったら図形を再描画します。バインドはメインウィンドウに対して設定します。
</p>
<pre class="list">
$top-&gt;bind( "&lt;Configure&gt;", \&amp;change_size );
</pre>
<p> キャンバスウィジェットは -fill と -expand を設定して pack されているので、ウィンドウの大きさが変わると、キャンバスの大きさも変わります。このときに図形の大きさを変える関数 change_size を実行すればいいわけです。
</p>

<p> キャンバスウィジェットの大きさですが、これは cget メソッドでは求めることができません。実際、ウィンドウがリサイズされキャンバスウィジェットが引き伸ばされても、最初に設定されたオプションの値そのままになっています。キャンバスウィジェットの大きさを求めるには、ウィジェットの情報を取得するメソッド width と height を使います。
</p>

<p> また、ウィンドウが小さくなると図形が見えなくなるので、ウィンドウの大きさを制限します。これはメソッド minsize と maxsizeで設定することができます。幅と高さはピクセル単位で指定します。
</p>

<p> プログラムは次のようになります。
</p>

<pre class="list">
リスト : キャンバスウィジェットのリサイズ（その２）

use Tk;

# 図形の大きさを変更
sub change_size {
  my $w = $canvas-&gt;width;
  my $h = $canvas-&gt;height;
  $canvas-&gt;coords( $id, 20, 20, $w - 20, $h - 20 );
}

# メインウィンドウの設定
$top = MainWindow-&gt;new();
$top-&gt;minsize( 100, 100 );
$top-&gt;maxsize( 400, 400 );

# キャンバスの設定
$canvas = $top-&gt;Canvas( -bg =&gt; 'darkgreen', -width =&gt; 200, -height =&gt; 200 );
$canvas-&gt;pack( -fill =&gt; 'both', -expand =&gt; 1 );
$id = $canvas-&gt;create( 'rectangle', 20, 20, 180, 180, -fill =&gt; 'red' );

# バインドの設定
$top-&gt;bind( "&lt;Configure&gt;", \&amp;change_size );

MainLoop();
</pre>

<p> 関数 change_size の処理は簡単です。メソッド width と height でキャンバスの大きさを求めたら、coords メソッドで図形の位置を変更するだけです。とても簡単ですね。たったこれだけの処理で、ウィンドウの大きさに合わせて図形の大きさを変更することができます。
</p>

<img src="img/canvas3.png" alt="キャンバス"> ウィンドウを縮小
<br><br>
<img src="img/canvas4.png" alt="キャンバス"> ウィンドウを拡大

</section>
<hr>
<section class="contents">
<h3 id="chapter17">フレームウィジェット</h3>
<p> フレームは、複数のウィジェットをひとまとめにする入れ物として使われるウィジェットです。単純なウィジェットですが、ジオメトリマネージャと組み合わせることで、複雑なウィジェットの配置にも簡単に対応することができます。
</p>

<h4>●Frame メソッド</h4>
<p> フレームウィジェットは Frame メソッドで生成します。オプションを指定する必要はほとんどありませんが、アプリケーションによっては形状や背景色を指定するといいでしょう。形状は -relief オプションで指定します。flat (平坦)、raised (出っぱり)、sunken (引っ込み)、groove (溝)、ridge (土手) の 5 種類が用意されています。デフォルトは flat です。次のプログラムを実行してください。
</p>

<pre class="list">
リスト : フレームの表示

use Tk;

$top = MainWindow-&gt;new();

foreach $r ('raised', 'sunken', 'flat', 'groove', 'ridge') {
  $top-&gt;Frame( -width =&gt; 60, -height =&gt; 40, -relief =&gt; $r,
               -borderwidth =&gt; 4, -bg =&gt; 'gray' )
      -&gt;pack( -padx =&gt; 5,  -pady =&gt; 5, -side=&gt; 'left' );
}

MainLoop();
</pre>
<p> これは 5 つの形状をすべて表示するプログラムです。-borderwidth は枠の幅を指定します。たとえば、レリーフが raised の場合、枠の上辺と左辺を背景よりも明るい色で、枠の下辺と右辺を暗い色で描くことにより、フレームがウィンドウから出っ張っているように見えます。-borderwidth の値を増やすと、この幅が増えるのでフレームはより出っ張って見えるようになります。実際に値を変えて試してみてください。
</p>

<img src="img/frame1.png" alt="フレームウィジェット"> フレームの形状

<h4>●ウィジェットの配置</h4>
<p> フレームにウィジェットを配置する方法はいままでと同じですが、もうひとつ、ジオメトリマネージャの -in オプションを使う方法があります。簡単な例題として、ボタンを 3 つ横に並べて、その下にボタンを縦に 3 つ配置するプログラムを作ってみます。
</p>
<p> これは Grid マネージャを使ってもプログラムできますが、ふたつのフレームと Pack マネージャを用いることで簡単に実現できます。横に並べるボタンをフレーム $f0 に配置し、縦に並べるボタンをフレーム $f1 に配置します。次のリストを見てください。
</p>

<pre class="list">
リスト : フレームにボタンを配置する

use Tk;

$top = MainWindow-&gt;new();

# フレームの生成
$f0 = $top-&gt;Frame();
$f1 = $top-&gt;Frame();

# フレーム $f0 にボタンを配置
$f0-&gt;Button( -text =&gt; "button 00" )-&gt;pack( -side =&gt; 'left' );
$f0-&gt;Button( -text =&gt; "button 01" )-&gt;pack( -side =&gt; 'left' );
$f0-&gt;Button( -text =&gt; "button 02" )-&gt;pack( -side =&gt; 'left' );

# フレーム $f1 にボタンを配置
$top-&gt;Button( -text =&gt; "button 10" )-&gt;pack( -in =&gt; $f1, -fill =&gt; 'both' );
$top-&gt;Button( -text =&gt; "button 20" )-&gt;pack( -in =&gt; $f1, -fill =&gt; 'both' );
$top-&gt;Button( -text =&gt; "button 30" )-&gt;pack( -in =&gt; $f1, -fill =&gt; 'both' );

# フレームを配置する
$f0-&gt;pack();
$f1-&gt;pack( -fill =&gt; 'both' );

MainLoop();
</pre>

<p> フレーム $f0 にはいままでと同じ方法でボタンを配置します。このボタンを pack するとフレーム $f0 に配置されます。この段階ではフレームにボタンを詰め込んだだけなので、まだウィンドウには表示されません。メインウィンドウにフレームを配置しないとボタンは表示されないのです。
</p>

<p> フレーム $f1 には、-in オプションを使ってボタンを配置します。この場合、ボタンはメインウィンドウ $top から生成しますが、pack の -in オプションによりフレーム $f1 に配置されます。-in オプションは grid でも使用することができます。
</p>

<p> 最後にフレーム $f0 と $f1 を pack で配置します。これでボタンが表示されます。それから、縦に配置したボタンを引き伸ばすため、-fill オプションを指定します。この場合、ボタンをフレームに配置するときと、フレームをウィンドウに配置するときの 2 か所で指定する必要があります。片方だけではボタンを引き伸ばすことはできません。ご注意くださいませ。
</p>

<img src="img/frame2.png" alt="フレームを使ったボタンの配置"> フレームを使ってボタンを配置する

<h4>●raise と lower</h4>
<p> <A href="perltk04.html#chapter11">モグラたたき</A> でも簡単に説明しましたが、ウィジェットには重なり順があり、Tk の場合はあとから作成したウィジェットが上になります。フレームウィジェットとそこに配置するウィジェットの重なり順を変更することで、ウィジェットをフレームの下に隠すことができます。つまり、ウィジェットを消去したことと同じ効果が得られるわけです。ウィジェットの重なり順はメソッド lower と raise で変更することができます。
</p>
<pre class="item">
$widget-&gt;lower( $widget1 );
$widget-&gt;raise( $widget1 );
</pre>
<p> lower メソッドは $widget の重なり順を $widget1 の下に変更します。引数 $widget1 を省略すると、$widget の重なり順はいちばん下になります。逆に、raise メソッドは $widget の重なり順を $widget1 の上に変更します。引数 $widget1 を省略すると、$widget の重なり順はいちばん上になります。
</p>

<p> ちなみに、ウィジェットを消去するメソッドに destroy がありますが、これは本当にウィジェットを削除します。したがって、もしも同じウィジェットが必要になれば、再度ウィジェットを生成しなければいけません。lower メソッドでウィジェットをフレームの下に隠しておけば、必要になったときに raise メソッドで表に出すだけで済みます。
</p>

<p> 簡単な例を示しましょう。次のプログラムを見てください。
</p>

<pre class="list">
リスト : フレームの下にボタンを隠す

use Tk;

@button = ();

# ボタンを隠す
sub hide {
  my $i = shift;
  $button[$i]-&gt;lower();
}

# メインウィンドウ
$top = MainWindow-&gt;new();

# フレーム
$frame = $top-&gt;Frame();

# ボタン
$top-&gt;Button( -text =&gt; 'Show', -command =&gt; sub { $frame-&gt;lower(); } )
    -&gt;pack( -in =&gt; $frame, -fill =&gt; 'x' );
foreach $i (1 .. 4) {
  $button[$i] = $top-&gt;Button( -text =&gt; "button $i", -command =&gt; [\&amp;hide, $i] )
                    -&gt;pack( -in =&gt; $frame, -fill =&gt; 'x' );
}

$frame-&gt;pack ( -fill =&gt; 'x' );

MainLoop();
</pre>

<p> 5 つのボタンをフレームに配置します。これらのボタンは pack の -in オプションでフレームに配置しますが、ボタンをフレームから生成すると、フレームとボタンの重なり順を変更できなくなります。ご注意くださいませ。
</p>

<p> button 1 - 4 を押すと、そのボタンがフレームの下に隠れます。ボタンを隠す処理は関数 hide で行います。ボタンウィジェットのオブジェクトは配列 @button に格納されているので、押したのボタンの重なり順を lower メソッドでいちばん下にすれば、フレームの下に隠すことができます。
</p>
<p> いちばん上のボタン Show を押すと、隠れたボタンを表に出します。このとき、ボタンを raise メソッドで表に出してもいいのですが、フレームウィジェットの重なり順をいちばん下に変更した方が簡単です。これですべてのボタンが表示されます。
</p>

<img src="img/frame3.png" alt="フレームの下にボタンを隠す"> button 1 と 3 を押した状態 
<br><br>
<img src="img/frame4.png" alt="フレームを使ったボタンの配置"> Show を押した状態
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2001-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="perltk05.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk07.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>