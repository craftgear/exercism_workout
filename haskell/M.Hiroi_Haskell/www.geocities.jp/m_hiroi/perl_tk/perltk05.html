<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>お気楽 Perl/Tk プログラミング入門</title>
  <meta name="description" content="Perl/Tk,Perl/Tk入門,GUI,プログラミング">
  <link rel="stylesheet" type="text/css" href="../home_styles.css">
</head>
<body><!-- geoguide start --><div align=center><script language="javascript">var jps=382116062;var jpt=1550881765</script><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/gg.js"></script></div><!-- geoguide end -->
M.Hiroi's Home Page
<div class="small">
http://www.geocities.jp/m_hiroi/
</div>
<div class="ce">
<h1>Perl/Tk memo</h1>
<h2>お気楽 Perl/Tk プログラミング入門</h2>
<div class="small">
[ <a href="perltk04.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk06.html">NextPage</a> ]
<hr>
</div>
</div>
<section class="contents">
<h3 id="chapter12">複数のウィンドウ</h3>
<h4>●複数のウィンドウを作る</h4>
<p> Perl/Tk は MainWindow-&gt;new() でメインウィンドウを生成しますが、このほかにも複数のウィンドウを生成することができます。新しいウィンドウは MainWindow-&gt;new() でも生成することができますが、この方法では最初のメインウィンドウとは独立したウィンドウ、つまり、新しいメインウィンドウとして扱われます。このため、最初のウィンドウを閉じても、新しいウィンドウはそのまま存在します。メインウィンドウと連動したウィンドウを生成するには、Toplevel メソッドを使います。
</p>
<pre class="item">
$sub_win = $main_win-&gt;Toplevel();
</pre>
<p> これで新しいウィンドウが生成されます。ウィンドウ $sub_win はメインウィンドウ $main_win から生成しているので、$main_win が閉じられると $sub_win も閉じられます。また、$main_win で設定したオプションは $sub_win でも有効です。あとはいままでのように、ウィンドウ $sub_win にウィジェットを配置します。
</p>

<p> それでは簡単な例題として、アプリケーションの情報などを表示するためのウィンドウを作ってみましょう。メインウィンドウのメニュー About が選択されたら、新しいウィンドウを開いてメッセージを表示します。まず、メインウィンドウとメニューを設定します。
</p>

<pre class="list">
リスト : メインウィンドウとメニュー

use Tk;

$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

$m = $top-&gt;Menu( -type =&gt; 'menubar' );
$top-&gt;configure( -menu =&gt; $m );
$m-&gt;command( -label =&gt; 'About', -under =&gt; 0, -command =&gt; \&amp;message_window );

$top-&gt;Label( -text =&gt; 'メニュー About を選んでね' )-&gt;pack();

MainLoop();
</pre>

<p> ここまでは簡単ですね。ウィンドウの生成は関数 message_window で行います。次のリストを見てください。
</p>

<pre class="list">
リスト : ウィンドウの生成

sub message_window {
  $sub_win = $top-&gt;Toplevel();
  $sub_win-&gt;Message( -text =&gt; 'message のサンプルプログラムです' )-&gt;pack();
}
</pre>

<p> 最初に Toplevel メソッドで新しいウィンドウ $sub_win を生成します。次に、Message メソッドでメッセージウィジェットを作りテキストを表示します。メッセージウィジェットはラベルと違い、複数行の文字列を表示することができます。デフォルトでは、縦と横の比率が 150 % になるように、文字列を表示する領域を調整します。この例では、-text で指定した文字列は 3 行に渡って表示されます。この比率を指定するオプションが -aspect です。
</p>
<ul>
  <li><b>-aspect</b><br>
文字列を表示する領域の縦横比、100 より大きいと横長で、デフォルトは 150。
  <li><b>-justify</b><br>
文字列の揃えを指定。center(中央寄せ）、right(右寄せ）、left(左寄せ）が指定できる。
</ul>
<p> -aspect は -width よりも優先順位が低いので、-width の値が優先されます。メッセージウィジェットの場合、-width の値は文字数ではなくドット数になるので注意してください。
</p>

<p> これでプログラムは完成です。たったこれだけで、メニュー About をクリックするとウィンドウが表示されます。
</p>

<img src="img/win0.png" alt="メインウィンドウ"> メインウィンドウ
<br><br>
<img src="img/win1.png" alt="サブウィンドウ"> About をクリックしてサブウィンドウを表示

<p> ところが、このままでは都合の悪いことがあるのです。このウィンドウを表示したまま、もう一度 About をクリックしてみてください。もうひとつ同じウィンドウが表示されてしまいます。それから、ウィンドウに表示されるタイトルが Toplevel になっています。きちんとしたタイトルをつけた方が良いでしょう。
</p>

<h4>●ウィンドウの状態を調べる</h4>
<p> ウィンドウの状態を調べる場合、Tcl/Tk ではコマンド winfo を使いますが、Perl/Tk では winfo のサブコマンドに相当するメソッドが多数用意されています。ウィンドウの状態を調べるメソッドの一部を表に示します。
</p>

<table border=1>
<caption>表：ウィンドウ情報に関するメソッド（一部）</caption>
<tbody>
  <tr><td>$widget-&gt;geometry;</td><td>$widget の位置を文字列 (幅x高さ+x+y) で返す</td></tr>
  <tr><td>$widget-&gt;width;</td><td>$widget の幅を返す</td></tr>
  <tr><td>$widget-&gt;height;</td><td>$widget の高さを返す</td></tr>
  <tr><td>$widget-&gt;x;</td><td>親ウィンドウ内での $widget の x 座標を返す</td></tr>
  <tr><td>$widget-&gt;y;</td><td>親ウィンドウ内での $widget の y 座標を返す</td></tr>
  <tr><td>$widget-&gt;rootx;</td><td>ディスプレイ上での $widget の x 座標を返す</td></tr>
  <tr><td>$widget-&gt;rooty;</td><td>ディスプレイ上での $widget の y 座標を返す</td></tr>
  <tr><td>Exists( $widget );</td><td>$widget が存在するか </td></tr>
</tbody>
</table>

<p> geometry メソッドでウィジェットを指定した場合、返される座標はディスプレイを基準にした座標ではなく、そのウィジェットが配置されたウィンドウを基準にした座標となります。また、x, y メソッドでメインウィンドウを指定すると、ディスプレイ上での座標を返します。
</p>
<p> このプログラムで必要になる、ウィンドウの存在を調べるメソッドは Exists です。たとえば、ウィンドウ $sub_win を調べるには、Exists( $sub_win ) とすればいいわけです。$sub_win が開いていれば真 (1) を、そうでなければ偽 (空文字列) を返します。
</p>

<h4>●ウィンドウの設定</h4>
<p> Tcl/Tk の場合、ウィンドウの設定はコマンド wm (Window Manager) で行いますが、Perl/Tk では wm のサブコマンドに相当するメソッドが多数用意されています。ウィンドウの状態を設定するメソッドの一部を表に示します。
</p>

<table border=1>
<caption>表：ウィンドウ設定のメソッド（一部）</caption>
<tbody>
  <tr><td>$window-&gt;withdraw;</td><td>ウィンドウを画面から取り除く</td></tr>
  <tr><td>$window-&gt;deiconify;</td><td>ウィンドウを見える状態に戻す</td></tr>
  <tr><td>$window-&gt;iconify;</td><td>ウィンドウをアイコン化する</td></tr>
  <tr><td>$window-&gt;state;</td><td>ウィンドウの状態を返す(状態は normal, withdrawn, iconic)</td></tr>
  <tr><td>$window-&gt;geometry(string);</td><td>ウィンドウを表示する位置を文字列で(幅x高さ+x+y)で指定する</td></tr>
  <tr><td>$window-&gt;maxsize(幅, 高さ);</td><td>ウィンドウの最大値を指定</td></tr>
  <tr><td>$window-&gt;minsize(幅, 高さ)</td><td>ウィンドウの最小値を指定</td></tr>
  <tr><td>$window-&gt;resizable(真/偽, 真/偽);</td><td>幅と高さの変更を許すか</td></tr>
  <tr><td>$window-&gt;title(タイトル名);</td><td>ウィンドウのタイトルを指定</td></tr>
</tbody>
</table>

<p> タイトルを設定するには title メソッドを使います。ウィンドウ $sub_win にタイトルをつけるには、$sub_win-&gt;title( 'タイトル' ); とすればいいわけです。
</p>

<h4>●プログラムの改良</h4>
<p> それではプログラムを改良してみましょう。
</p>

<pre class="list">
リスト：ウィンドウの生成（改良版）

sub message_window {
  unless( Exists( $sub_win ) ){
    $sub_win = $top-&gt;Toplevel();
    $sub_win-&gt;title( 'About' );
    $sub_win-&gt;Message( -text =&gt; 'message のサンプルプログラムです' )-&gt;pack();
  }
}
</pre>

<p> まず Exists メソッドでウィンドウ $sub_win が開いているかチェックします。まだ開いていないのであれば、Toplevel でウィンドウを生成します。次に、title メソッドでタイトルを設定します。あとはいままでと同じです。実際にプログラムを実行すると、ウィンドウが開いた状態でメニュー about をクリックしても、新しいウィンドウは開きません。
</p>

<img src="img/win2.png" alt="サブウィンドウ"> サブウィンドウ（改良版）

</section>
<hr>
<section class="contents">
<h3 id="chapter13">ダイアログ</h3>
<h4>●メッセージボックス</h4>
<p> 前回は Toplevel メソッドで新しいウィンドウを作り、メッセージウィジェットでテキストを表示しました。ところで、短いテキストを表示するだけならば、もっと簡単な方法があります。それは <b>メッセージボックス</b> というダイアログを使うことです。
</p>
<p>  GUI アプリケーションの場合、ボタンを押すとかメニューを選ぶといった操作は、基本的にはユーザーが自由に行うことができます。ところが、ある操作をしないと次の処理に進めない場合があります。たとえば、画像を表示する場合、表示するファイル名をユーザーから入力してもらわないと、画像ファイルを表示することはできませんね。このようなときは、必要な操作を行ってもらうようにユーザーを誘導した方がよいでしょう。このときによく使われるのが <b>ダイアログ (dialog)</b> です。
</p>
<p> ダイアログは重要なメッセージを表示するために開かれるウィンドウで、画面の前面に表示され、ユーザーがダイアログに応答しないかぎり、そのアプリケーションではほかの操作を行うことはできません。ダイアログは、ユーザーに特定の操作を強制したい場合には便利ですが、その反面、操作の自由度は減少します。使いすぎるとユーザーの不満が溜まることになるので注意してください。
</p>

<p> メッセージボックスを表示するには、messageBox メソッドを使います。このメソッドを実行すると、メッセージを表示してユーザーがボタンを押すまで待ちます。messageBox のオプションを表に示します。
</p>
<table border=1>
<caption>表：messageBox のオプション</caption>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>-type</td><td>
    <table>
    <caption>種別（ボタン構成の選択）</caption>
    <tbody>
      <tr><td>ok</td><td>OK ボタン</td></tr>
      <tr><td>okcancel</td><td>OK, キャンセルボタン</td></tr>
      <tr><td>yesno</td><td>はい、いいえボタン</td></tr>
      <tr><td>yesnocancel</td><td>はい、いいえ、キャンセルボタン</td></tr>
      <tr><td>retrycancel</td><td>再試行、キャンセルボタン</td></tr>
      <tr><td>abortretryignore</td><td>中止、再試行、無視ボタン</td></tr>
    </tbody>
    </table></td></tr>
  <tr><td>-message</td><td>ダイアログに表示する文字列</td></tr>
  <tr><td>-icon</td><td>ダイアログに表示するアイコン<br>error, info, question, warning のいずれかを指定）</td></tr>
  <tr><td>-default</td><td>デフォルトボタンの名前を指定</td></tr>
  <tr><td>-title</td><td>ダイアログのタイトルを指定</td></tr>
  <tr><td>-parent</td><td>ダイアログを表示するウィンドウを指定</td></tr>
</tbody>
</table>

<p> messageBox は押されたボタンの種類を文字列で返します。たとえば、種別に yesno を指定した場合、「はい」のボタンを押せば yes という文字列を返します。メッセージを表示するだけであれば、-type には ok を、-icon には info を指定すればいいでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : messageBox のサンプル

use Tk;

$icon = 'info';
$type = 'ok';

# ウィンドウの生成
sub message_window {
  $top-&gt;messageBox( -type =&gt; $type, -icon =&gt; $icon, -title =&gt; 'About',
                    -message =&gt; 'messageBox のサンプルプログラムです' );
}

# 画面の設定
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

# メニューの設定
$m = $top-&gt;Menu( -type =&gt; 'menubar' );
$top-&gt;configure( -menu =&gt; $m );
$m-&gt;command( -label =&gt; 'About', -under =&gt; 0, -command =&gt; \&amp;message_window );
$m1 = $m-&gt;cascade( -label =&gt; 'Type', -under =&gt; 0, -tearoff =&gt; 0 );
$m2 = $m-&gt;cascade( -label =&gt; 'Icon', -under =&gt; 0, -tearoff =&gt; 0 );

# メッセージボックスのボタンを指定するメニュー
$m1-&gt;radiobutton( -label =&gt; 'ok', 
                  -variable =&gt; \$type, -value =&gt; 'ok' );
$m1-&gt;radiobutton( -label =&gt; 'ok, cancel', 
                  -variable =&gt; \$type, -value =&gt; 'okcancel' );
$m1-&gt;radiobutton( -label =&gt; 'yes, no', 
                  -variable =&gt; \$type, -value =&gt; 'yesno' );
$m1-&gt;radiobutton( -label =&gt; 'yes, no, cancel', 
                  -variable =&gt; \$type, -value =&gt; 'yesnocancel' );
$m1-&gt;radiobutton( -label =&gt; 'retry, cancel', 
                  -variable =&gt; \$type, -value =&gt; 'retrycancel' );
$m1-&gt;radiobutton( -label =&gt; 'abort, retry, ignore', 
                  -variable =&gt; \$type, -value =&gt; 'abortretryignore' );

# メッセージボックスのアイコンを指定するメニュー
$m2-&gt;radiobutton( -label =&gt; 'info', -variable =&gt; \$icon, -value =&gt; 'info' );
$m2-&gt;radiobutton( -label =&gt; 'error', -variable =&gt; \$icon, -value =&gt; 'error' );
$m2-&gt;radiobutton( -label =&gt; 'question', -variable =&gt; \$icon, -value =&gt; 'question' );
$m2-&gt;radiobutton( -label =&gt; 'warning', -variable =&gt; \$icon, -value =&gt; 'warning' );

$top-&gt;Label( -text =&gt; 'メニュー About を選んでね' )-&gt;pack();

MainLoop();
</pre>

<p> メッセージウィジェットと違い、文字列はそのまま表示されます。文字列中に改行文字を含めれば、複数行に渡って表示することができます。-type と -icon はメニューで選ぶようにプログラムしたので、いろいろ試してみてください。
</p>

<img src="img/dialog0.png" alt="メインウィンドウ"> メインウィンドウの画像
<br><br>
<img src="img/dialog1.png" alt="メッセージボックス"> メッセージボックス(info, ok)の画像
<br><br>
<img src="img/dialog2.png" alt="メッセージボックス"> メッセージボックス(warning, yes/no)の画像

<h4>●ダイアログの作成</h4>
<p> このほかにも、ダイアログを作成する Dialog メソッドが用意されています。Dialog のオプションを表に示します。
</p>

<table border=1>
<caption>表：Dialog のオプション</caption>
<thead>
  <tr><th>オプション</th><th>機能</th></tr>
</thead>
<tbody>
  <tr><td>-title</td><td>ダイアログのタイトルを指定</td></tr>
  <tr><td>-text</td><td>ダイアログに表示する文字列</td></tr>
  <tr><td>-bitmap</td><td>ダイアログに表示するビットマップ</td></tr>
  <tr><td>-buttons</td><td>ボタン名 (文字列) を格納した配列へのリファレンス</td></tr>
  <tr><td>-default_button</td><td>デフォルトボタンを指定</td></tr>
</tbody>
</table>

<p> 一般に、-bitmap には Tk で用意されているビットマップを指定します。イメージを指定することはできないので注意してください。ボタンはいくつでも設定することができ、配列に格納した順番で表示されます。
</p>
<p> Dialog メソッドはダイアログを生成するだけで、ダイアログを表示しないことに注意してください。表示は Show メソッドで行います。Show メソッドはダイアログを表示し、押されたボタンの名前を文字列で返します。
</p>

<p> それでは、Dialog を使ってメッセージを表示してみましょう。
</p>

<pre class="list">
リスト : Dialog のサンプル

use Tk;
use Tk::Dialog;

# ウィンドウの生成
sub message_window {
  $dialog-&gt;Show();
}

# 画面の設定
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );

# メニューの設定
$m = $top-&gt;Menu( -type =&gt; 'menubar' );
$top-&gt;configure( -menu =&gt; $m );
$m-&gt;command( -label =&gt; 'About', -under =&gt; 0, -command =&gt; \&amp;message_window );

# ダイアログの生成
$dialog = $top-&gt;Dialog( -title =&gt; 'About', -bitmap =&gt; 'info',
                        -text =&gt; 'Dialog のテストです',
                        -buttons =&gt; ['Yes', 'No'], -default_button =&gt; 'Yes' );

$top-&gt;Label( -text =&gt; 'メニュー About を選んでね' )-&gt;pack();

MainLoop();
</pre>

<p> あらかじめ Dialog メソッドでダイアログを生成して変数 $dailog にセットします。そして、メニュー About が選択されたら、Show メソッドでダイアログを表示します。-bitmap には info を指定しました。このほかに、error, hourglass, questhead, question, warning などがあります。ボタンは Yes と No のふたつです。-default_button には Yes を指定しました。Yes のボタンを押すと、Show メソッドは文字列 Yes を返します。
</p>

<img src="img/dialog3.png" alt="メインウィンドウ"> メインウィンドウの画像
<br><br>
<img src="img/dialog4.png" alt="Dialog"> Dialog の画像

</section>
<hr>
<section class="contents">
<h3 id="chapter14">独自のダイアログを作る</h3>
<p> 前回は messageBox と Dialog メソッドを使って、メッセージを表示するダイアログを作成しました。また、ファイル名の入力であれば getOpenFile と getSaveFile メソッドや、FileSelect ウィジェットを利用することができます。しかしながら、これだけではほかの操作、たとえばキーボードから名前やパスワードを入力する、といった処理には対応できません。この場合、自前のダイアログを作成することになりますが、このときに使うメソッドが grab と wait です。
</p>

<h4>●grab と wait</h4>
<p> グラブ (grab) はマウスやキーボードからの入力を、特定のアプリケーションやウィンドウにだけ割り当てる働きをします。グラブに関するメソッドを表に示します。
</p>
<table border=1>
<caption>表：グラブに関するメソッド</caption>
<tbody>
  <tr><td>$widget-&gt;grab;</td><td>$widget にローカルグラブを設定する</td></tr>
  <tr><td>$widget-&gt;grabRelease;</td><td>$widget に設定されているグラブを解除する</td></tr>
  <tr><td>$widget-&gt;grabCurrent;</td><td>グラブが設定されているウィンドウの名前を返す</td></tr>
  <tr><td>$widget-&gt;grabGlobal;</td><td>$widget にグローバルグラブを設定する</td></tr>
  <tr><td>$widget-&gt;grabStatus;</td><td>$widget のグラブ状態(none, local, global)を返す</td></tr>
</tbody>
</table>

<p> グローバルグラブをセットすると、グラブをセットしたアプリケーションしか操作することができません。ローカルグラブは、セットしたアプリケーションだけにしか影響しません。つまり、ほかのアプリケーションは自由に操作することができます。グラブを設定したウィンドウが廃棄されると、グラブは自動的に解除されます。<A href="index.html#biblist">参考文献</A> [4] には、次のように書かれています。
</p>
<blockquote>
<cite>
『グローバルグラブは解除を忘れると画面全体がロックする恐れがあるので使用しない方がよい。』
</cite>
</blockquote>
<p> M.Hiroi が使用している Windows 版 Tk.pm Version 800.022 では、グローバルグラブを設定してもほかのアプリケーションの操作は可能でした。ほかの環境では不具合の原因になるかもしれないので、グローバルグラブは慎重に扱ってください。
</p>

<p> wait は待ち合わせのためのメソッドです。表に示すように 3 つのメソッドがあります。
</p>
<table border=1>
<caption>表：待ち合わせのためのメソッド</caption>
<tbody>
  <tr><td>$widget-&gt;waitWindow;</td><td>$widget が削除(destory)されるまで待つ</td></tr>
  <tr><td>$widget-&gt;waitVisibility;</td><td>$widget の可視・不可視の状態が変化するまで待つ</td></tr>
  <tr><td>$widget-&gt;waitVariable( refvar );</td><td>指定したグローバル変数に書き込みが行われるまで待つ</td></tr>
</tbody>
</table>

<p> grab と wait を組み合わせることで、ユーザーがデータを入力するまで待つといった処理を作ることができます。
</p>
<p> 簡単な例題を示しましょう。ボタンを押したら名前を入力するウィンドウを開くプログラムを作ります。これには 2 つの方法があります。ひとつは、ウィンドウを作っては壊す方法で、もうひとつは、あらかじめウィンドウを作っておいて、表示しては隠す方法です。この 2 つの方法でプログラムを作ってみましょう。
</p>

<h4>●ウィンドウを壊す方法</h4>
<p>  最初に、作っては壊す方法でプログラムを作ります。
</p>

<pre class="list">
リスト : ウィンドウを壊す方式(1)

use Tk;

# グローバル変数
$message = 'ボタンを押すと入力ウィンドウが開きます';
$buffer = '';

# 名前を入力する
sub input_name {
  my $sub_win = &amp;input_window();
  $sub_win-&gt;waitWindow;
  $message = "入力された名前は $buffer です";
}

# 画面の設定
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );
$top-&gt;title( 'Dialog Test' );

$top-&gt;Button( -text =&gt; 'InputName', -command =&gt; \&amp;input_name )-&gt;pack();
$top-&gt;Label( -textvariable =&gt; \$message )-&gt;pack();

MainLoop();
</pre>

<p> まずボタンとラベルを配置します。ボタンが押されたら関数 input_name を実行して、名前入力用のウィンドウを開きます。ウィンドウの生成は関数 input_window で行います。ウィンドウを開いたら、waitWindow メソッドを実行してウインドウが廃棄されるまで待機します。input_window は入力された名前をグローバル変数 $buffer にセットします。あとは、入力された名前を $buffer から取り出して、ラベル表示用のグローバル変数 $message にセットするだけです。
</p>
<p> 次は関数 input_window を作ります。
</p>

<pre class="list">
リスト : ウィンドウを壊す方式 (2)

# ウィンドウを作る
sub input_window {
  my $sub_win = $top-&gt;Toplevel();
  my $x = $top-&gt;x + 10;
  my $y = $top-&gt;y + 10;
  my $entry;
  $buffer = '';
  $sub_win-&gt;geometry( "+$x+$y" );
  $sub_win-&gt;title('Input Your Name');
  $sub_win-&gt;Label( -text =&gt; '名前を入力してね' )-&gt;pack();
  $entry = $sub_win-&gt;Entry( -textvariable =&gt; \$buffer );
  $entry-&gt;bind( "&lt;Return&gt;", ['destroy', $sub_win] );
  $entry-&gt;focusForce;
  $entry-&gt;pack();
  $sub_win-&gt;grabGlobal;
  $sub_win;
}
</pre>

<p> input_window は Toplevel メソッドでウィンドウを生成して、名前が入力されたらウィンドウを廃棄します。名前の入力はエントリーウィジェットを使います。入力用バッファとしてグローバル変数 $buffer を設定します。ウィンドウを開く位置は、メインウィンドウの近くがいいでしょう。x, y メソッドでメインウィンドウの位置を求め、作成するウィンドウの位置を geometry メソッドで設定します。
</p>

<p> このプログラムではウィンドウの位置を指定するだけなので、幅と高さは省略しています。この場合、書式は "+$x+$y" となります。先頭の + は省略できません。また、メインウィンドウの位置を求めているので、x, y メソッドの返す座標はディスプレイを基準にしていることに注意してください。
</p>

<p> あとは、入力フォーカスとグラブをセットします。一般の GUI アプリケーションでは、キー入力はアクティブになっているウィンドウに渡されます。Tk では、これを <b>フォーカスウィンドウ (focus window)</b> といいます。フォーカスウィンドウは、マウスの操作によって変更することができますが、focus メソッドによって設定することもできます。
</p>

<table border=1>
<caption>表：focus 関連のメソッド（一部）</caption>
<tbody>
  <tr><td>$widget-&gt;focus;</td><td>フォーカスウィンドウを $widget に設定する</td></tr>
  <tr><td>$widget-&gt;focusCurrent;</td><td>フォーカスウィンドウを返す</td></tr>
  <tr><td>$widget-&gt;focusForce;</td><td>フォーカスウィンドウを強制的に $widget に設定する</td></tr>
</tbody>
</table>

<p> focus メソッドはフォーカスウィンドウを設定します。forcForce メソッドは、フォーカスウィンドウを強制的に設定します。このメソッドを使うと、ほかのアプリケーションがアクティブになっている場合でも、指定したウィンドウがアクティブになります。このプログラムでは、エントリウィジェットに入力フォーカスを設定します。
</p>

<p> リターンキーが入力されたならば、データ入力終了とみなしてウィンドウを destroy メソッドで廃棄します。この処理は、エントリーのリターンキーにバインドすればいいですね。これでプログラムは完成です。実際に試してみてください。
</p>

<img src="img/dialog5.png" alt="メインウィンドウ"> メインウィンドウ
<br><br>
<img src="img/dialog6.png" alt="ダイアログ"> 名前を入力するダイアログ
<br><br><img src="img/dialog7.png" alt="メインウィンドウ"> 名前の表示

<h4>●ウィンドウを隠す方法</h4>
<p> 今度は、表示して隠す方式で作ってみましょう。ウィンドウを作ったら withdraw メソッドでウィンドウを隠しておきます。そして、ボタンが押されたら deiconify メソッドでウィンドウを表示し、名前の入力が終わったならば、withdraw メソッドでウィンドウを隠します。
</p>
<p> ところで、ウィンドウを隠す方法では問題点がひとつあります。それは、名前を入力するウィンドウで、右上隅の閉じるボタンを押したときの処理です。通常の動作では、このボタンが押されるとウィンドウが廃棄されるのですが、それでは困ってしまいますね。
</p>
<p> Tk の場合、重要なイベントが起こった、もしくはこれから起こるというときには、そのイベントをアプリケーションに知らせる仕組みが用意されています。これを <b>ウィンドウマネージャープロトコル</b> と呼びます。ウィンドウが廃棄されるときは <b>WM_DELETE_WINDOW</b> というプロトコルが通知されます。アプリケーション側では protocol メソッドを使って、このプロトコルが通知されたときの動作を設定することができます。
</p>
<pre class="item">
$widget-&gt;protocol( protocol_name, callback );
</pre>
<p> WM_DELETE_WINDOW のデフォルトの動作がウィンドウを廃棄することです。このプロトコルに新しいコールバック関数を定義することで、閉じるボタンが押されてもウィンドウを廃棄せずに隠すことができます。
</p>

<p> 今回は、名前の入力が終了したらグローバル変数 $flag に 1 をセットすることにします。名前入力用ウィンドウを表示したら、waitVariable メソッドで $flag に値が書き込まれるのを待ちます。また、WM_DELETE_WINDOW が通知された場合も入力終了とみなして、$flag に 1 をセットすればいいでしょう。プログラムは次のようになります。
</p>

<pre class="list">
リスト : ウィンドウを隠す方式

# グローバル変数
$message = 'ボタンを押すと入力ウィンドウが開きます';
$buffer = '';

# ウィンドウを作る
sub make_window {
  $sub_win = $top-&gt;Toplevel();
  $sub_win-&gt;title('Input Your Name');
  $sub_win-&gt;Label( -text =&gt; '名前を入力してね' )-&gt;pack();
  $entry = $sub_win-&gt;Entry( -textvariable =&gt; \$buffer );
  $entry-&gt;bind( "&lt;Return&gt;", sub { $flag = 1; } );
  $entry-&gt;bind( "&lt;Map&gt;", sub { $entry-&gt;focusForce; } );
  $entry-&gt;pack();
  $sub_win-&gt;protocol( 'WM_DELETE_WINDOW', sub { $flag = 1; } );
  $sub_win-&gt;withdraw;
}
</pre>
<p> Toplevel メソッドでウィンドウを生成して、ラベルとエントリーウィジェットを配置します。エントリーウィジェットで Return が入力されたら $flag に 1 をセットします。それから、ウィンドウが見える状態になったらエントリーにフォーカスを設定するため、もうひとつバインドを設定します。ウィジェットが見える状態になると発生するイベントが Map です。逆に、見えなくなると発生するイベントが Unmap です。よく使われるイベントを表に示します。
</p>

<table border=1>
<caption>表：一般的なイベントの種類</caption>
<thead>
  <tr><th>イベント</th><th>種類</th></tr>
</thead>
<tbody>
  <tr><td>ButtonPress(Button)</td><td>マウスボタンが押されたときに発生</td></tr>
  <tr><td>ButtonRelease</td><td>マウスボタンが離されたときに発生</td></tr>
  <tr><td>KeyPress(Key)</td><td>キーが押されたときに発生</td></tr>
  <tr><td>KeyRelease</td><td>キーが離されたときに発生</td></tr>
  <tr><td>Motion</td><td>ウィジェット上でマウスが移動したときに発生</td></tr>
  <tr><td>Enter</td><td>マウスがウィジェットの内に入ったときに発生</td></tr>
  <tr><td>Leave</td><td>マウスがウィジェットの外に出たときに発生</td></tr>
  <tr><td>FocusIn</td><td>ウィジェットが入力フォーカスを得たときに発生</td></tr>
  <tr><td>FocusOut</td><td>ウィジェットが入力フォーカスを失ったときに発生</td></tr>
  <tr><td>Map</td><td>ウィジェットがスクリーンに現れたときに発生</td></tr>
  <tr><td>Unmap</td><td>ウィジェットがスクリーンから消えたときに発生</td></tr>
  <tr><td>Configure</td><td>ウィンドウの大きさが変更されたときに発生</td></tr>
</tbody>
</table>

<p> あとは、protocol で WM_DELETE_WINDOW が通知されたら flag を 1 にセットするように定義し、withdraw メソッドで作成したウィンドウを隠します。それから、名前入力用ウィンドウはボタンが押される前に作っておかなければいけません。画面の設定が終わったら make_window を実行してウィンドウを作成しておきます。
</p>

<p> 関数 input_name はウィンドウを表示して、名前が入力されたらウィンドウを隠します。
</p>

<pre class="list">
リスト : 名前の入力

# 名前の入力
sub input_name {
  my $x = $top-&gt;x + 10;
  my $y = $top-&gt;y + 10;
  $buffer = '';
  $sub_win-&gt;geometry( "+$x+$y" );
  $sub_win-&gt;deiconify;
  $sub_win-&gt;grab;
  $sub_win-&gt;waitVariable( \$flag );
  $sub_win-&gt;grabRelease;
  $sub_win-&gt;withdraw;
  $message = "入力された名前は $buffer です";
}
</pre>

<p> まず geometry メソッドでウィンドウの位置を指定し、deiconify メソッドでウィンドウを見える状態にします。次にグラブを設定し、waitVariable メソッドでグローバル変数 $flag に書き込みが行われるまで待ちます。入力が終了したら、グラブを解除してウィンドウを隠します。ウィンドウを隠しただけでは、グラブは解除されません。ウィンドウを壊す方法とは違い、グラブの解除を忘れないでください。あとはメインウィンドウに入力された名前を表示します。
</p>
<p> これでプログラムは完成です。実際に試してみてくださいね。
</p>

<h4>●DialogBox ウィジェット</h4>
<p> 独自のダイアログを作成する方法を説明しましたが、今回のようにダイアログにウィジェットを設定するだけならば、Perl/Tk には <b>DialogBox</b> という便利なウィジェットが用意されています。前回説明した Dialog はメッセージとボタンを表示しましたが、DialogBox は任意のウィジェットを設置することができます。ウィジェットの設置は add メソッドで行います。
</p>
<pre class="item">
$widget = $dialog-&gt;add( 'widgetClass', options );
</pre>
<p> widgetClass には DialogBox に設置するウィジェットのクラス名、options でウィジェットのオプションを設定します。add メソッドは、ウィジェットを生成してそのオブジェクトを返します。ウィジェットの配置は、いままでと同じくジオメトリーマネージャで行います。add メソッドでウィジェットが配置されるわけではありません。ご注意ください。
</p>

<p> DialogBox を使ったプログラムは次のようになります。
</p>
<pre class="list">
リスト : DialogBox ウィジェットの使用例

use Tk;
use Tk::DialogBox;

# グローバル変数
$message = 'ボタンを押すと入力ウィンドウが開きます';
$buffer = '';

# 名前を入力する
sub input_name {
  $buffer ='';
  $entry-&gt;focus;
  $dialog-&gt;Show;
  $message = "入力された名前は $buffer です";
}

# メインウィンドウの設定
$top = MainWindow-&gt;new();
$top-&gt;optionAdd( '*font' =&gt; 'FixedSys 14' );
$top-&gt;title( 'Dialog Test' );
$top-&gt;Button( -text =&gt; 'InputName', -command =&gt; \&amp;input_name )-&gt;pack();
$top-&gt;Label( -textvariable =&gt; \$message )-&gt;pack();


# ダイアログの設定
$dialog = $top-&gt;DialogBox( -title =&gt; 'Input Your Name',
                           -buttons =&gt; ['OK'], -default_button =&gt; 'OK' );
$dialog-&gt;add( 'Label', -text =&gt; '名前を入力してね' )-&gt;pack();
$entry = $dialog-&gt;add( 'Entry', -textvariable =&gt; \$buffer );
$entry-&gt;pack();

MainLoop();
</pre>
<p> ダイアログは DialogBox メソッドで生成します。Dialog と違って、-text や -bitmap オプションは使用できません。必要なウィジェットは add メソッドで生成します。このプログラムでは、ラベルとエントリーウィジェットを使います。add メソッドで生成し、pack メソッドで配置します。エントリーのオブジェクトはフォーカスを設定するため必要になるので、グローバル変数 $entry にセットします。
</p>
<p> ボタンを押したときに実行する関数 input_name では、エントリーウィジェット用の変数 $buffer をクリアし、focus メソッドでフォーカスを設定してから、Show メソッドでダイアログ $dialog を表示します。Show メソッドの返り値は押したボタンの名前です。
</p>
<p> このように、DialogBox を使えば簡単にダイアログを作成することができます。
</p>
<img src="img/dialog8.png" alt="DialogBox ウィジェット"> DialogBox ウィジェット
</section>
<hr>
<div class="ce">
<b>Copyright (C) 2001-2003 Makoto Hiroi<br>All rights reserved.</b>
<div class="small">
<hr>
[ <a href="perltk04.html">PrevPage</a> | <a href="index.html">Perl/Tk</a> | <a href="perltk06.html">NextPage</a> ]
</div>
</div>
</body>
</html>
<!-- text below generated by geocities.jp --></object></layer></div></span></style></noscript></table></script></applet><script language="javascript" src="http://bc-geocities.yahoo.co.jp/js/geov2.js"></script><script language="javascript">geovisit();</script>